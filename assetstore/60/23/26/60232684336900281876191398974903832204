May 1981 Report. No. STAN-C+8 l-854
Oti the Security of Public Key Protocols
bY
D. Dolcv
A. C. Yao
neSearcl1 spollsoreu III  parr uy
National Science Foundation
and
Defense Advanced Research Projects Agency
Department of ‘Computer Science
Stanford University
Stanford, CA 94305

On the Security of Public Key Protocols*
D. Dolev and A. C. Yao
Computer Science Department
Stanford University
Stanford, California 94305
Abstract~-
Recently, the use of public key encryption to provide secure network communication has received
considerable attention. Such public key systems are usually effective against passive eavesdroppers, who
merely tap the lines and try to decipher the message. It has been pointed out, however, that an improperly
designed protocol could be vulnerable to an active saboteur, one who may impersonate another user or alter
the message being transmitted. In this paper we formulate several models in which the security of protocols
can be discussed precisely. Algorithms and characterizations that can be used to determine protocol security
in these models will be given.
* This research was supported in part by ARPA under grant MDA-903-80-C-102 and by National Science
Foundation under grant MCS-77-05313-AOl.
1
1. Introduction.
The use of public key encryption (Diffie and Hellman [l], R ivest, Shamir, and Adleman [ll]) to provide
secure network communication has received considerable attention (Diffie and Hellman [a], Merkle [7],
Needham and Schroeder [8], Popek and Kline IlO]).  Such public key systems are usually very effective
against a “passive” eavesdropper, namely, one who merely taps the communication line and tries to decipher
the intercepted message. However, as pointed out in Needham and Schroeder [8], an improperly designed
protocol could be vulnerable to an “active” saboteur, one who may impersonate another user and may alter
or replay the message. As a protocol might be compromised in a complex way, informal arguments that
assert the security for a protocol are prone to errors. It is thus desirable to have a formal model, in which the
security issues can be discussed in a precise manner. The models we introduce later will enable us to study
the security problem for families  of protocols, with very few assumptions on the behavior of the saboteur.
We briefly recall the essence of public key encryption (see [l] [ll] for more information). In a public
key system, every user X has an encryption function E, and a decryption function D,, both are mappings
f r o m  (0, 11’ into {O,l>*. There is a public directory containing all the (X, Ex) pairs, while the decryption
function D, is known only to user X. The main requirements on E,, D, are
( 1 )  E,D, = D,E,  =  1 ,  a n d .
(2) Knowing E,(M) d oes not reveal anything about the value A4.
Thus, every one can send X a message E, (M), X will be able to decode it by forming D,(E, (Ad))  = M,
but nobody other than X will be able to find M even if E,(M) is available to them.
We will be interested mainly in protocols for transmitting a secret plaintext M between two users. To
give an idea of the way a saboteur may break the system, we consider a few examples. A message sent
between parties in the network consists of three fields: the sender’s name, the receiver’s name, and the text.
The text is the encrypted part of the message. We will write a message in the format:
(sender’s name, text, receiver’s name).
Example 1.1. Consider the following protocol for sending a plaintext M between A and B:
step 8: A sends B the message (A, E,,(M), B);*
step b: B answers A with the message (13, EA(M),  A).- -
This protocol is easy to break by a saboteur 2 in the following way:
(1) 2 intercepts the message sent from A to B in step a.
(2) 2 sends to B the message (2, E,(M),B).
(3) B answers 2 according to the protocol (step b) by (B, E,(M), 2).
(4) 2 decodes E,(M) to find the plaintext M.
One way to overcome the weakness in the above ;.rotocol  is to encode the name of the sender together
with the plaintext in the encrypted text. Consider the following variation of a protocol suggested in Needham
and Schroeder [8].
Example 1.2. Consider the following protocol:
step a: A sends B the message (A, E,,( MA), B);
step b: B answers A by sending (B, E,(MB),  A).
We will prove later in this paper that this protocol is secure against arbitrary behavior of the saboteur.
What will happen if one tries to improve the ,above protocol by adding another layer of encryption?
Example 1.3. Consider the following protocol,
step a: A sends H the message (A, E,(E,,(  M)A), 11).
step b: I3 answers by sending (B, E,(E,(M)B),A).
Surprisingly, this protocol is breakable in the following way:
(1) Z takes the message sent back from B to A in step b, i.e., (B, E,,(E,( M)B), A).
Denote E,(M)R  by a, then 2 can extract E,,(a)  from the above message.
(2) 2 initiates a conversation with A, sending
(-WL(E$@)Z),A),
according to the protocol (step a).
(3) A, as a receiver, answers 2 by
(4 & ( & ( @ A ) ,  2).
(4) 2 decodes $ from the last message he received in step (3). As &I = E,,,(M)B,  2 now possesses
E,(M).
(5) 2 establishes a new connection and sends to A the message
(2, &(E,(G)Z), A).
(6) Now A should answer by (A, E, (E, (M)A),  2).
(7) At this step Z is able to find the plaintext M.
The precise mathematical models will be defined in the ensuing sections. Below we list the basic
assumptions on the system that we wish to model.
(1) A perfect public key system:
(a) The one-way functions used are unbreakable;
(b) The public directory is secure, and cannot be tampered with;
(c) Everyone has access to all E, ;
- (d) Only X knows D , .
(2) Two-party protocol: Only the two users who wish to communicate are involved in the transmission
process; the assistance of a third party in decryption or encryption is not needed.
(3) Uniform protocol: The same format is used by every pair of users that wish to communicate. In the
three examples given previously, the users’ names A, B are symbolic parameters and can be any two
names.
(4) Behavior of the saboteur: We will focus attention on saboteurs who are “active” eavesdroppers. That
means, someone who first taps the communication line to obtain messages, and then tries everything he
can in order to discover the plaintext. More precisely, we will assume the following about a saboteur:
(a) He can obtain any message passing through the network;
(b) He is a legitimate user of the network, and thus in particular can initiate a conversation with any
other user;
(c) He will have the opportunity to be a receiver to any user A. (More generally, we allow the possibility
that any user B may become a receiver to any other user A.)
We give a summary of the results obtained in this paper. Two models will be developed.
3
(1) The cascade protocols: These are protocols in which the users can apply the public key encryption-
decryption operations to form messages; several layers of such operators may be applied, however. A
simple example of cascade protocol is given in Example 1.1.
(2) The name-stamp protocols: These are protocols in which the users are allowed to append, delete, and
check names encrypted together with the plaintext. A name-stamp protocol can also contain layers of
encryptions (as in Examples 1.2 and 1.3).
In Section 2 we prove that a cascade protocol is secure if and only if both the following conditions are
satisfied:
(1) The messages transmitted between X and Y always contain some layers of encryption functions E,
or E, .
(2) In generating a reply message, each participant A (A = X, Y) never applies D, without also applying
EA’
This gives a simple characterization of security, and also an efiicient  algorithm for deciding whether a given
ca.scade  protocol is secure.
In Section 3 we give a polynomial-time algorithm for deciding if a given name-stamp protocol is secure.
In Section 4 we consider the question whether a saboteur can break the protocol without waiting for
others to initiate a conversation. This corresponds to the use of items (a) and (b) only in the previous
discussion of the behavior of the saboteur. We given extensions of the results in Sections 2 and 3 to this
case.
To end this introduction, we remark that there are other types of sabotage activities that may defeat
the purpose of a public-key protocol (or any protocol). We refer the readers to Needham and Schroeder [8]
for further discussions. The problem of sabotage in network communications also arises in other context (see
Dolev [3], Pease, et.al. [9]).
2. Cascade Protocols.
In this section we consider a simple class of protocols, in which the only operations the users employ
to generate messages are the encryption-decryption operators. Our goal is to analyze the security of such
protocols against saboteurs. To achieve that we have to develop a formal model. We have to specify:
( 1 )  t h e
(2) t h e
syntax of
inference
the protocol, i.e., what operations the users apply at each
rules that the traitor can use to discover the plaintext.
step to generate a message;
2.1. Notations.
Let C be a finite set of distinct symbols. We USC C* to denote the set of all finite sequences composed
of the symbols in C; the set’ C’ also contains the empty string X. We define C-k = C* - {X}, i.e., the set
of all non-empty words over C. The concatenation of the words cy and p is denoted by op. Let 7 = GYP  be
a word, then a is called a prefix of 7, and p is a sufix  of 7.
The basic properties of the public-key operators are E’,D, = D, E, = 1, the identity function.
As a result, any string of operators of the form CZJ G, D, 0’ will be equivalent to a or, in the sense  that
( a  E:,D,a’)P = (a a’)P for all P E (0, l}*. We will say that aEx D,a’ (or aD, E,a’)  can be reduced to
o 0’. For any string 7 of operators, let ‘71x denote the complete reduced string obtained from 7 by deleting
all E, D, and D, E, pairs iteratively, until no further reduction is possible. Derive by 7 the string obtained
from 7 by complete reduction with respect to all users X in the system, 7 is the reduced form of 7. Notice
that 71x  and 7 are all unique.
For convenience we sometimes write D, as EC, the complement of E, . Similarly E, is also written
as D”, . Let 7 = al . ..a., be a word of n symbols, each of which is an E or a D, define
The word 7’ is called the complement of 7, and it satisfies 77’ -= 7’7 = 1, when 7 and 7” are considered
as operators.
For any string 7, let et(7) be the set of symbols in 7.
2.2. The Model.
d Definition 2.1. A two-party cascade protocol T is specified by a series of finite strings
where  t’ = t or t - 1. For each pair of distinct user * X and Y, let N,(X, Y), pL( X, Y) denote Lhe  strings
zYz,  p, with the symbols zr , ~2, z3, z4 respectively replaced by E7,,  Ey , D,, D,.
Clearly, w(X, Y) E {E,, E,, D, }* and ,Bz(X, Y) E {E,, E,, II,.}*. Wh en liser X wants to transmit a
sccrct plaintcxt M to user Y, they exchange message according to 7’ in the following way:
X sends Y the message CY 1 (X, Y)M;
Y applies /?I (X, Y) to the received message and sends it to X;
X applies Q~(X,Y) to the received message and sends it to Y;
Y applies pz(X, Y) to the received message and sends it to X;
Note that the protocol is uniform in that q(A, B) and ,02(R,  IS), for any users A, U, can be obtained from
o[,(X,Y),  Pt(X Y) by substituting X by A and Y by 13.
5
For convenience, we assume that 6, and p, are such that CY,(X,  Y), pz(X, Y) are in reduced form.
Definition 2.2. Let 2’ be a two-party cascade protocol specified by { iS,,b,,  1 1 2 i < t, 1 5 j 5 t’}, and let
X, Y be two distinct users. Define
N(X,Y)  = &cY),
N2](X,Y) = P,(x,y)~2pl(X,Y)r 1 < j 2 t’,-
N2i+1(X,Y) = c&f, y>  NZz(X Y) J 1<i<t-1.
When X wishes to send a plaintext A4 to Y, the message exchanged are then N,(X, Y)M, where
i= 1,2, . ..) t+t’.
Example. Consider the protocol T given by { Cri = ~2~3 , PI = z~z~z~z~z~}.  O n e  h a s  or(X,Y)  = E,D,
and ,Bi(X,Y) = E,D,E,E,D,. For a plaintext M, the messages transmitted are Ni(X,  Y)M = E, D,M
a n d  Nz(X,Y)M  = E,D,E,M.
So far we have discussed the syntax of the cascade protocol. We will now define the notion of security for
a cascade protocol, i.e., when will a saboteur be able to deduce the plaintext M being transmitted between
two users. Let us first give a formal definition. Let X, Y, Z denote distinct user names.
Definition 2.3. Let T be a two-party cascade protocol specified by { G1,, PI}. Define
G(z) = {EA),
C2=(Q,(A,B)~forallA~Bandi~2},
C3 = {JlJ(A,B)  1 for all A # B a n d  i > 1).
We will say that 7’ is insecure if there exists some 7 E (Cl( 2) U C2 U C3)* such that
7 X(X, Y) = x
for some N,(X,Y);  T is secure otherwise.
Remark. It is clear that the above definition of security for T is independent of the choice of X, Y, 2.
We now give the motivation behind the definition. Suppose X is trying to send a plaintext M to Y
(using protocol T). The actual messages transmitted between them are then N,(X, Y)M (i = 1,2, . . . ),
and may fall into the hands of the saboteur 2. Taking any N,(X, Y)M , the saboteur 2 has the chance to
transform it by repeatedly applying any of the following three types of operators:
(a) Any c E G(z);
*(b) Any  0 E X3. 2 can initiate a plaintext transmission with a user B, claiming himself Uo be A, a n d
-send any string P to B in the (22’ - 1)-st message; Z then gets back P,(A, B)P, effectively putting
the operator Pe(A,  B) on any chosen P;
(c) A n y  u E C2: let 0 = cr,(A,  B); t h ere is a chance that A may wish to transmit a plaintext to B some
time in the future; 2 may intercept the (; - 1)st reply from B to A, prevent it from reaching A, and
replace it with any chosen string P and receive from A the string a,(A, B)P.
As a result, 2 has the opportunity to obtain the string 7 N,(X, Y)M for any 7 E (C,(Z)  U Cz U Es)‘. This
means  2 may deduce M, if 7 N,(X, Y) = X for some 7 E (C r(Z) U C2 U Es)‘.
We wish to point out that, in order to obtain at(A, B)P from P, 2 has to wait for A to initiate a
conversation with B. It may or may not happen. Thus, our definition of security is a conservative one, in
the sense that we are concerned with the worst case possibility.
2.3. A Characterization of Secure Protocols.
Definition 2.4. Let 7~ E {E, D}’ be a string and A be a user name. We say that 7r has the balancing property
with respect to A if
D, E et(n) i m p l i e s  E, E et(r).
As will h(> seen,  the balancing property is inherent in secure cascade protocols.
Definition 2.5. Let X, Y be two distinct user names. A two-party cascade protocol T = {zYL, p,} is a
balanced cascade protocol if
(i) for every i 2 2, CY~(X,Y)  h as the balancing property w.r.t. X, and
(ii) for every i 2 1, pl(X,Y) has the balancing property w.r.t. Y.
Remark. We cmphaske  that a,(X, Y), p,(X, Y) are in reduced form for i, j > 1.
The following result is proved in Appendix A.
Lemma 2.1. Let Z be a user name and T be a balanced cascade protocol. Then for every string q in
(C,(Z) u c-2 u x3)*, q h as the balancing property w.r. t. every A f 2.
Proof .  See  Appendix A.  1
We are ready now to state and prove the main result of this section. Let X, Y be two distinct user
names.
Theorem 2.1. A two-party cascade protocol 3” = {rYt,r?j,} is secure if and only if
. (i) ~t(c@LY))  n {&,Ey}  # A and
(ii) T is balanced.
Proof. Let 2 bc a user name distinct from X and Y.
(A). Necessity. Assume that either property (i) or (ii) is not true. We will show that 5” is insecure, i.e., there___.-~
exists 7 E (C,(Z)  IJ Cy U C,)*  such that 7N,(X,Y)  = x for some i.
If (i) is not true, then 7NI (X, Y) = X where 7 = ai E Cl (Z)*, and we are done. We can thus assume
that (ii) is false, i.e., T is not balanced. By definition, either some pk(X,  Y) contains D, but not E, go some
~L(X,Y) (i 2 2) contains D, but not E,. We first restrict ourselves to the former  case (pk contai[ls  ll)y but
d not E,, ); the latter case will be treated later. We will establish under this restriction the following stronger
result: For any 6 E {E,, E,, D}’  , th ere exists 7 E (C,(Z)  U {p,(Z,X), pk(Z,X)})* such that 715 = X. The
proof will be carried out by induction on r, the number of E, and E,, in the string 5.
If r = r) then 7 = SC E (C, (Z))*  sat is f ies  the  requirement . Now let r > 0 and assume that the
result has been established for all smaller values of r. Let 6 be a string containing exactly r E=,‘s and
E; ‘s. Without loss of generality, we can assume that the leftmost E is an E, . Write 6 = 01 EUoz,  where
&(a,) n {E,, E,.} == $; 1c early a; E (C, (2))‘.  By assumption, /3k(  %, Y) contains D,, but not E,; hence we
can write Pk( Z, Y) = 71 D, 72, w h e r e  71 E {E,, DY}* and  7-2 E {15,}*. Clear ly ,  7:‘ E (C,(Z))*  for i = 1, 2.
Now 02 contains r--l E’s, and by the inductive hypothesis, there exists 7’ E (C 1 (Z)U {/3k( Z, X), /?k( Z, Y)})*
s u c h  t h a t  7’02 = X. Define 7 = 7’7-;Pk(Z,  Y),G0;. Then 7 E (G(Z)  U {PI&X), L%@,Y)})* from the
above discussions. Furthermore
= 7’02
= x.
This completes the inductive step.
7
It remains to show that T is insecure when some CY~(X,Y)  (i 2 2) contains D, but not E, . One can
prove the following stronger result: For any 6 F_ {E, , E, , D} * , there  exists 7 E (C 1 (Z)U {Q, (X, Z), a,(Y)  Z)})’
satisfying 76 = X. The proof is almost identical to the previous proof, and will not be repeated.
(B). Suficiency.  Assume that both properties (i) and ( ii are satisfied, WC will prove that T is secure.)
Suppose to the contrary, there exists a 7 E (C,(Z)  tJ C2 U Es)* such that 7Ne(X,Y) = X for some
i. We will derive a contradiction. Write 7iV,(X,Y)  = Pa,l(X,Y)  such tht P E (C,(Z)  LJ C2 U Es)*.  B y
definition of 7, we have
PcYl(X,Y) = A. P-1)
By the definition of a protocol, Ct(cul (X, Y)) 5 {E,, D,, EY}. We distinguish two cases.
Cast l3.1.  E, E &(q(X,Y)).
As the string CY~  does not contain D,. , the only possibility for (2.1) to hold is that r) contains some D,
but no E, . I3ut this means that P does not have the balancing property w.r.t. Y. As Y =/ 2, this is a
contradiction to Lemma 2.1.
Case B.2. E, 4 &(a, (X, Y)).
In this case D, $J &(cY,(X, Y)), because al(X, Y) is in reduced form and the protocol satisfies property
(i) in the lemma. This implies that cyl (X, Y) = E$. 5L imilarly to Case 0.1, the only possibility for (2.1) to
hold is that P contains D, and does not contain E, ) which again contradicts Lemma 2.1. 1
A cascade protocol T is called doubly- verified if for some i, !t(N,(X, Y)) G {E,,  , D,, D, } and for some
j 2 2, ~f(~~X~) c, {Ed?dL}.
Theorem 2.2. Every doubly-verified protocol is imecure.
Proof. Let T be a doubly-verified protocol, such that,
et(&) C_ {En DAL), P-2)
and
Et(%) C {Ex, Dx, Dy} . (2.3)
(We have used the abbreviations Iv, for N,(X, Y).) Write m1 = CY 1 (X, Y), Nk = s(Y and Ne =
-___
7gcul(X, Y), where r3 E (C, U C,)* . Suppose 7’ is secure. We will derive a contradiction.
By Theorem 2.1, ?’ has to be balanced.
C a s e  J. E, E lt(c~,(X,Y)).
Clearly (2.3) d emands that ~3~  should contain D, but no E,. This contradicts Lemma 2.1.
Case 2. E, E &(cY, (X, Y)) and E:,, @ et(o I (X, Y)).
In this case, (2.2) recluires  that qk contains D, but no E, , contradicthg  hmma 2.1. 4
Theorem 2.2 implies that in a secure cascade protocol T, if the receiver Y is able to decode the encrypted
message M, then the sender  X cannot oblain M by simply decrypting some of the messages sent back to X.
That means, ,X should not be able to reconstruct M if X has thrown away M after the first transmission.
This theorem implies that the protocol in Example 1.1 is not secure (a fact we already demonstrated before).
It also implies that the protocol suggest in Diffie  and IIellman  [2] (th e message exchar;ges  being EI1  (D, (M)) ,
E,@n(M)))  for obtaining public key authentication is not secure.
8
We wish to emphasize that our security concept is based on the assumption that the plaintext M is
arbitrary. If the structure of M is known and a consistency check can be made, then the protocol is no
longer considered to be a cascade protocol. In the next section, we consider a case in which the internal
structure of the message can be used to achieve security.
3. Name-Stamp Protocols.
In Section 1 we discussed several protocols that append names to the message before the encryption.
We will now introduce a model that includes such protocols.
3.1. Informal Description.
Assume that the names of all users are of the same length, say, m bits. For any string 7 E (0, l}‘, we
will write 7 = head(r)ta  where tail(y) is a suffix of m bits. A user Y can apply any of the following
operations to a string 7:
(4 encryption E, ;~____
(b) decryption D , ;
(4 appending i, ; w i t h  i,7 = 7X;
(d) name-matching d, ; with d,7 = head(7) if tail(r)  = X and undefined otherwise;
(e) deletion d, with d7 = head(y).
The name X can be any user’s name, but the only decryption Y can apply is D,. The following equations
are clearly true: For any name X,
and
E,D, = D,E, = 1 ,
d,i, =di, =l.
(3-l)
We remark that i,d, # 1.
Under a name-stamp protocol, any text transmitted by a user is obtained by applying a sequence of
operations (a)-(e) to th e most recently received text. In particular, when a d, is applied to a string 7, the
transmission will not proceed unless tail(y)  = X. To insure the completion of the communication, we will
require that any text transmitted between two normal users X, Y will be of a form
7 E {E,, D,,i,, d,, d 1 all users A}*M
-such that no d, remains after (3.1) is repeatedly applied.
As before,  a saboteur is allowed to intercept all the texts between X and Y, modify them with operations
(a)-(e), and use them freely in any conversation, initiated either by him or by others. In this fashion he can
obtain numerous strings 7 E {EA,  D,, i,, d,, d / all A}* M. If any of the obtained 7 can be reduced to M
by the repeL 1 zd use of (3.1), then the saboteur will have succeeded in the quest for M .
3.2. Some Notations.
Consider the following set of rules:
E,D,+X , DxEx-4
d,i,-+X  , di, --+A. P-2)
For any string 7 E {E,, D,, d,, i,, d 1 all user A}*, let 7 denote a string obtained when the rules in (3.2) have
been used to reduce 7 until no further replacement can be made. It is clear that 7 is unique, independent
of the order of the reduction. Call 7 the reduced form of 7. A string 7 is irreducible if 7 = 7.
10
3.3. Formal Model.
Definition 3.1. A two-party name-stamp protocol T is specified by a set of strings
& E CF - +2})*  ) p3 E ( F  - {q})’
w h e r e  F = {z1,22,  . . . , zzg},  1 5 i 2 t, and 1 < j < t’ (t’ = t or t - 1). Let CLI,(X,  Y) and pi(X, Y)
denote  the  s t r ings  (IIL  and bJ w h e n  z1,22,  . . . , zg are  each replaced by D,, D,, E,, E,, i,, i,, d,,
d,, d .  L e t  Nl(X,Y)  = cyl(X,Y),  Ns(X,Y) = ,BI(X,Y)N~(X,Y),  Ns(X,Y)  = az(X,Y)Ns(X,Y),  . . . ,
NpL(X, Y) = ,BL(X,  Y)Nz,-1(X,  Y), N,,+,(X,  Y) = a,+l(X,  Y)Nz,(X,  Y), . . . . We require that N,(X,Y)
do not contain any dA.
Remark. {N,(X,  Y)M} is *the sequence of texts transmitted between X and Y, when X wishes to send
plaintext M to Y. That N,(X, Y) contains no d,l means the i-th transmission is well defined.
Definition 3.2. Let X, Y, 2 be three given distinct users. A two-party name-stamp protocol T is insecure
if there exists a string 7 E If;,,.{ N,(X,Y)}  such that 7 = X; the set V,,, is defined by
VZ,T = {aJ(A,  B) 1 all A # B all j 2 2) U
. {PJ(A,B) )allA#B, allj}U (3.3)
{E.-o L, d,,d 1 all A}U {D,}.
Otherwise T is secure.
Remarks. The security of T in the above definition is clearly independent of the choice of X, Y, 2. The
mot  iwtion for the definition is similar to the cascade case (set Section 2.2),  and will not be el;~t~c~r;tt,cd.
3.4. Examples.
(1) Consider the protocol given in Example 1.2. In the present notation, cyl(X,Y)  = E,i,, P,(X, Y) =-._____ ____--
E,i,d,D,..  We also have N,(X,Y)  = E,i, and Np(X,Y)  = E,i,. ,
(2) The protocol in Example 1.3 corresponds to the case CY~ (X, Y) = E,i, E, , ,01(X,  Y) = E, i, E, D,d, D, .
We then have Nl(X, Y) = E,i, E, and Nz(X, Y) = E, iyE,. This protocol is insecure, as the string
7 = Dz dDzPi(V+L  zi dD, dD,pl(Z,X)Esi.N2(X,Y)  E V;,,.{ W(X,Y)}
satisfies 7 = X. (This particular 7 actually corresponds to the sequence of operations used by the
saboteur in Example 1.3.)
3.5. A Secure Protocol.
We now prove that the protocol in Example 1.2 is secure in our model. Suppose to the contrary, there
exlists  a 7 E VE T { N,(X, Y) } with 7 = X. We will clerive  a contradiction.
Take such a 7 = ulu2...v~N,(X,Y) with  a  minimum number  of  VI, E Vg T. Assume i = 1 (the
other case i = 2 can be treated similarly). From the previous subsection, we have N,(X,Y)  = E,i, and
-&2(x,  Y) = Ex i, . s ince 7 = X, there must be a Dy in 7 that cancels the E, in NI (X, Y). Let vj be the
word that contams  this D,, then v3 = /?I (W, Y) = Ewi,d,,,D,F for some W (as D, occurs only in ,f31. This____-
implies j = e, otherwise 7’ = 211  212 . . . vJ Nl(X, Y) would be an instance shorter than 7. There are now two
cases:
(1) If PV# X, th en veNl(X, Y) = E,i,d,i,  , and 7 = v1 v2 . . . ue-1 E,i,d,i,  # X;
(2) If W = X, th en veNl(X, Y) = E,i,  = Iv;L(X,Y),  and hence the string 7’ = ,V~VZ  . . . ve--l Nz(X,Y)
satisfies 7 = 7 = X, contradicting the minimality of 7.
This completes the proof.
11
3.6. An Algorithm for Checking Protocol Security.
W C will give an algorithm that can decide if a given name-stamp protocol is secure. In particular, one
can run this algorithm to give an alternative proof of security for the protocol (1) in the subsection 3.4.
Given a two-party name-stamp protocol T, specified by { QI,,  pJ }, we will use n to denote the input
length c, I4 + c, IPJ I * Th e rest of this subsection is devoted to a proof of the following theorem.
Theorem 3.1. There is an algorithm that can decide in time O(n8)  whether a given two-party name-stamp
protocol T is secure.
We will prove as an intermediate step Theorem 3.2, which is of interest by itself.
In principle, the saboteur 2 may start a conversation with any user in the network. The next lemma
shows that we can assume that 2 only speaks to X and Y. This reduction is very useful for constructing
an algorilhm. Let us define
S={~~(A,B)IA,BE{X,Y,Z},A+B,~~~}U
{Pz(A,B)/A,BE{X,Y,Z},A#B}u (3.4) -
{E&,,d,,,d~A=X,Y,Z}u{D,}.
Lemma 3.1. The protocol T is insecure if and only if there exists a string 7 E S*{ NE(X,  Y) } such that
q= x.
Proof. It suffices to show that, if T is insecure, then there exists such a 7. In this situation, let 7’ E
v;,,( WXJT  > b e a string such that 7 = X. Replace in 7’ all the E,, , i,, d, when A @ {X, Y, 2) by
E,, i,, d,, and let 7 denote the resulting string. Clearly, 7 = X. Observe also that 7 E S*{ N,(X, Y) }, as
.cr,(A, B) and  P*(A,  13) become CY,(Z,  2) and pz(Z, 2) E S if A, B 4 {lX, Y, Z}, and CY,(A’,  B’) and Pt(A’, B’)
with A’, B’ E {X, Y, Z}, A’ # B’, otherwise. 1
Definition 3.3. Let q E {E,, D,,i,.,,d  I A = X,Y}* bc an irreducible string. Denote by C(q) the set of all
irreducible strings S E {E,, D,, i,, d,, d I all A}* satisfying 6 r] = X.
-Lemma 3.2. If 7 contains any d, then C(q) = rj. Otherwise, let 7 = bl b2 . . . bt, then C(v)  consists of all
the strings 6: bi-,  . . . b’,, where (E,)” = D,l, (DA)C = E,, (iA)’ = d, or d.
Proof. It follows from the fact that d has no left inverse, and the fact that b: are the only irreducible
strings satisfying b: b; = X. 1
Write  pk = Nk(X,  Y) and let pz,, piz, . . . pz, be those pk that do not contain d .
Lemma 3.3. T h e  p r o t o c o l  T  i s  i n s e c u r e  if a n d  only jf there exists a string 7 E S* srlch that 7 E C(pl,) for
some 1 < j < s.
Proof.
Sufficiency.  If 7 E S” and 7 E C(pz,), then 7’ = qpz, E S*{ N,(X, Y) } and 7 = X. Thus T is  insecure by
Lemma 3.1.
Necessity. If T is insecure, then by Lemma 3.1 there exists a string 7’ = 7 Nk(X,Y) with 7 E S* and- -
7’ = A. This implies 7pk r= A, and thus by Lemma 3.2 7 E C(p,,) for some j. 1
We will show the following:
12
Proposition 3.1. Given a set of strings S = {hl, hz, . . . , hp} and a string p, where
h, E {EJLL, d,, d 1 A = X,Y, Z}* and p E {En, DA , in 1 A = X, Y}* j
o n e  c a n  decide  i n  t i m e  O(q7) i f  t h e r e  e x i s t s  a  s t r i n g  7  E S’ such  that ;3 E G(p). (4 is defined  to be
CL Ihzl + IPI *I
Proposition 3.1 implies Theorem 3.1 by the following argument. Given a protocol T specified by { Zz, r8},
we first compute N,(X,Y) and then pt = J/,(X, Y) for all i in time O(n’). (Observe that each N,(X,Y)
is of length at most O(n).) C onsider those p1 that contain no d. For each such pt, use Proposition 3.1 to
decide if there exists a 7 E S* such that 7 E C(pz), where S is given by (3.3). Ry Lemma 3.3, the protocol
is then insecure if and only if there exists such a 7 for some pt. The total time is
O(C (Cla~l+ CIp31  + lPzl)‘)  = O(cn7) = O(n8).
2 3 j I
It remains to prove Proposition 3.1. We will consider a more general setting.
3.7. The Extended Word Problem.
L e t  C = {a,,az, . . ., a,} be an alphabet, i.e., a set of distinct symbols. We call u + v a transformation
rule ,  w h e r e  u  E C-b and v E C’. Let I’ = {ul + ~1~~2  -+ ~2, . . . , uq --+ vy} be  a  set  of  transformation
rules. For two strings 7, S E C’, we will write 7 bra b if 7 can be transformed  into 6 by repeatedly using
. rules in l?, i.e., replacing substrings u, by v,. For  a  s tr ing of  subsets  G, of C, 7 = GI Ga . . . G,, let
L(q) = { 7 I 7 = 91 92 * - - sq , w h e r e  q2 E G, }, We will U S C  the notation 7 l=+ly L(q) if 7 1317  p for some
-p E L(v). The extended word problem for (C,I’)  can be stated  as follows:
Given a set of input strings 6,,&, . . . ,6, (6, E C*) and a string of subsets q = Cl G2.. . G,, (G, C C;
G, -1 $), determine if there exists a concantenation  A = 6,, 6,2 . . . b2, such that A b13 L(q).
Remark. The input length n is defined to be C,lS,I + C,IG,l.
In general, the extended word problem is known to be undecidable, because it includes as a special case
the membership problem for a type-0 language, well known to be undecidable (see e.g. Hopcroft  and Ullman
[5]). However, we will show that the problem is solvable in polynomial time for a special class of the inputs.
Definition 3.4. A transformation rule of the form uzu3 4 X is called a cancellation rule.
Theorem 3.2. Let C be an alphabet and r a set of cancellation rules. Then the extended word problem for
(C!I’) can bc solved in time O(n7),  where n is the input length.
Theorem 3.2 implies Proposition 3.1 by the following argument. Let
C = {Dn,E,,L d,,dIA=X,Y,z),
7=(D,E,-tX,I!‘,D,tX,d,i,-tX,diA-tXIA=X,Y,Z}.
The problem stated in Proposition 3.1 with inputs hl, h2, . . . , hl,, p can be solved as an extended word
problem for (C, r). The inputs are 61,62,  . . . ,6, and a subset string 77 = Gl G2 . . . G,, where 5, = h, and 77
is such that L(q) = C(p). Th e input lengths are linearly related. Thus, proving Theorem 3.2 will complete
the proof of Theorem 3.1.
To prepare for the proof of Theorem 3.2, we define a few terms. Let 61,6~, . . . ,6, be the input words
in C’, and le t  q = G, Gz... G, be the input sequence of subsets (G, C C). W I11i lolit.  loss of generality, we
13
can assume that 6, # X for all i. Denote by I, I’ the set of all proper prefixes and suffixes of 6i,&, . . . ,6,
(including X, but not ~5~).  Let J be the set of all substrings of 7, and Jg the set of all substrings of 7 of ’
length  !. For each w E J, l e t
R,, = { (g, b) 1 9 E T’, b E I, there exists e E {61,62,  . . . , S,}* such that geb bi- L(w) } .
We emphasize that each w E J is of the form Gi G, +i . . . G, , where GI, C C;
Lemma 3.4. Rx can be’ computed in time O(n7).
Proof. See Appendix  l3. 1.
Proof of Theorem 3.2.
We compute R,, for w E Jt inductively on e by “dynamic programming”. Initially we compute 11~.
Now let .JJ > 0 and suppose R, have been computed for all w E Jo U JI LJ . - - U Jew-1  . For each w E Je,
w e  w i l l  c o m p u t e  R,,. Let w = G,u. For each g E I’, b E I, let us decide if (9, b) E R,, . S u p p o s e
$4, 6, * * - 6,. b =+I- L(G,u). Since cancellation rules do not create new symbols, g ~5,~ 6,, . . . Sfg b must be of
the form pakp’ for some a,~ E G, with p =+I- X and p’ ==+I‘ L(u). To cover all the possible breaking points
for p and p’, we employ the following procedure:
(i) If g = akgi  with ak E G, , determine if (gi, b) E R,, .
(ii) For each 6) and each occurrence of a symbol uk E G, in S,, write 6, = s uX;s’. Determine if both
( g ,  s) E 6, and  (s’, b) E R, .
. (iii) If b = bl b2 with b2  c T,(w),  determine if (g, b,) E R,.
Set (g, b) E R,, if any of the above tests yields a “yes” answer; otherwise (9, b) 4 R,,.
It is easy to check that the above procedure correctly determines if (g, 6) E R,. To find the running
time, note that each triplet (w, g, b) takes time at most
Thus the time needed to compute R,,, for all w E Je is
0 (  1 Jel . 111  - 11’1) - n3 = O(nG)  .
-
The total computing time for .! = 1,2, . . . 171  is thus O(n7). This completes the proof of Theorem 3.2.
I
14
4. The Impatient Saboteur.
To break a protocol that is insecure as defined in the previous sections, a saboteur may need to be the
receiver of a conversation. In this section, we are interested in the characterizations (or decision procedures)
for protocols that can be compromised by an impatient saboteur, i.e., one who only initiates conversations
(and does not rely on being spoken to).
For the name-stamp protocols, this corresponds to a modification of the definition of security (Definition
3.2). That is, one should omit the term {a,(/& B)} from the definition of Vz,,,,  (see (3.3)).
Theorem 4.1. There is an algorithm that can decide in
protocol T is secure  against an impatient saboteur.
time O(n8) whether a given two-party name-stamp
Proof. The proof is identical to the proof of Theorem 3.1, except that the {cY,(A,  B)} term should be
omitted from eq. (3.4). 1
For the cascade protocols, the definition of security (Definition 2.3) should be modified as follows: T is
insecure (against an impatient saboteur) if there exists some 7 E (C,(Z) U Es)* such that 7 N2(X, Y) = X
for some N,(X, Y); T is secure otherwise. We can obtain a characterization similar to that in Theorem 2.1.
Theorem 4.2. Let X, Y be distinct user names. A two-party cascade protocol T = {?Y~,  p,} is secure against
an impatient saboteur if and only if, for every k 2 1,
___-__-
(i) ~@b(X, Y)) n {E,, EY} # 4,
(ii) pk(X,  Y) has the balancing property w.r. t. Y.
Although the statement of this result is simple, the proof is quite involved. The rest of this section iS devoted
to a proof of Theorem 4.2.
In the following, a string always refers to a string of E’s and D’s. Let A bc any user name.
Definition 4.1. Let q be a string. A substring 7~ of 7 is called an A-substring if one of the following is true
for some X,Y # A:
(i) rl = ML n&m;
(ii )  7 = 71 D, 7r ;
(iii) q = 7~ D, r];!  .
Definition  4.2. A string 7 is strongly A-balanced if every A-substring K has the balancing property w.r.t.-
A.
Lemma 4.1. Let r] be a strongly A-balanced string.
(i) If 7 = 71 D, ~2 with B # A, then 71 and r/2 are both strongly A-balanced.
. (ii) If q = 1 77 I 2 and E, $Z et(yz), then r]l is strongly A-balanced.
Proof. It is easy to see that 7 is strongly A-balanced iff every A-substring, that does not contain any
D,, for B # A, has the balancing property w.r.t. A. This implies (i).
The balancing property w.r.t. A is concerned with the appearance of E, in case that D, appears.
Therefore, by removing a suffix or prefix which does not contain E, , we cannot change the balancing
property or the strongly balanced property. This proves (ii). i
The key idea in the proof of Theorem 4.2 is the property presented in the following lemma.
Lemma 4.2. Let 7, 6 be any strongly A-balanced strings given in a reduced form. If
(W u [t(6)) n {&, DA} f 4
15 ,
then 76 # X.
Proof. We prove the lemma by induction on n, the number of D,‘s in the word 76.
The lemma is trivially true for n = 0. Assume now that one D, appears in 76. We will assume that
it is in 7 and that 6 contains no D,. (The case that D, is in b can be similarly treated.) By assumption
the strings 7, 6 are in reduced form. Therefore, 76 = X implies that 7 does not contain any E,, w h i c h
contradicts the balancing property of 7. The lemma is thus true for n = 1.
For the inductive step, let n > 1. Assume that the lemma holds for every 7’, 6’ such that 7’6’ contains
at  most  n  - 1 D, ‘s. Let 7, S be  such that  76 c o n t a i n s  n D, ‘s, and that 7, 6 satisfy the induction
hypothesis. We wish to prove 7 6 # X.
We prove by contradiction. Suppose 7 6 = X. By assumption 7 and 6 are in reduced form; thus 6 == rc.
It follows that 7 and b contain the same number of operators from the set {E,,,,  Dn}.  Let us assume that
7 = 72 Dt 71 where  Ct(7r) n {E,, DA} = 4. (Th e case 7 = 72 Ez 71 is similar.) In this case 6 = 6i Ez-62
w h e r e  61 = 7: a n d  62 = 7;.
The string 7 is strongly A-balanced. Therefore  72 should be of the form 73Ex  for some X # A.
(Otherwise 7 = 73 D, 0: 71 for X # A and where En sf: &(7i), which contradicts the fact that 02 71
has the balancing property w.r.t. A.) This implies that 62 = D, 6:{ and 63 = 7:.
By Lemma 4.1 and the fact that .0(7,)  n {EA,  D,} = 4, we conclude that 73 and 63 are strongly
A-balanced. Moreover, the fact that 7 == 73 E, D$7i  and E, @ .!l(7,) implies that E, E .tt(7:S), which
implies that D,, E &(63).
The inductive assumption implies that 7363  # X, which is a contradiction to our assumption that
+?==A.  1
Lemma 4.3. Let C, = { p2(X, Y) I for all i and all users X } . If every member-of C, has the balancing
I)ronerty  w.r.t. Y, then for every stripg
vE(C,U{E}U{Dx IX#Y})*,
q is strongly Y-balanced.
Proof. The proof is very similar to the proof of Lemma 2.1 given in Appendix A. The property of being
strongly-balanced is a special case of having the linkage-property (Appendix A). The proof can be carried
along the same line, with attention paid to only one party Y in the present case. 1
We are now ready to prove Theorem 4.2.
Proof of Theorem 4.2. The necessity part is exactly as that of Theorem 2.1.
SufE<iency.  Assume to the contrary that there exists P E (Ci (2) U C3)’ such that for some k
PNI,==X.
(We will use the abbreviation NI, for Nk(X,  Y).)
Case A. If E, 4 t!t(~~).
Property (ii) and Lemma 4.3 imply that the string itTk  is strongly Y-balanced. Therefore, m,+ cannot
contain any D, . We thus have &T, = E$ , otherwise (i) would not hold. This means p = 0:. . Now,
condition (ii) states that pJ(A, X) h ave the balancing property w.r.t. X, for every A. Therefore, by Lemma
4.3, P is strongly X-balanced, which contradicts the fact that P = D$.
C a s e  II. E, E lt(nk).
16
In this case, by Lemma 4.3, n, and P are strongly Y-balanced. But Lemma 4.2 implies that
which provides the desired contradiction. 1
17
Appendix A. Proof of Lemma 2.1.
Let 2 be a distinguished user name. We will explore the structure of strings in (Ci lJ C2 lJ C,)‘, from
which we will derive Lemma 2.1. (We use Ci for C i( Z) throughout this appendix.)
Definition. Let 7r be a string and A be a user name. We say that 7r is A-balanced if the following condition
holds: 7r = D, 6 D, where X, Y # A and lt(6 I,+) n {D} & {D,,} im pl ies that 6 IA has the balancing property
w.r.t. A.
A string 7 is said to have the linkage property, if every s11  t:.;t,ring 7r of D, r] D, is A-balanced for all
A #  2.
Lemma A.1. Let 5” be a balanced cascade protocol. Let /.J be any string having the linkage property. For
every string 7 from either CT or C:! or Es, ~7 and 7~ satisfy the linkage property.
Proof. It suffices to prove that ,uq has the linkage property; the other case follows by symmetry.
Let A # 2 be any user of the network. We have to show that every substring of D, ~7 D, is A-balanced.
Consider first the case that 7 does not contain D,. In this case the number of DA’s in (pq)l,,  can
not increase and, therefore, every substring of D, ~7 D, is A-balanced since every substring of D, ,u D, is
A- balanced.
Next, assume q contains D,. In this case 7 should be some CY~(A,  B) or P,+(A,  B) for some users A and
B. Thus, 7 has the balancing property w.r.t. A. Moreover, 7 does not contain any D,, with u # A. L e t
QT = D, S D,, where X, Y # A, be a substring of D, ~7 D,. If D, E et(p) then 7r is A-balanced because 1-1
satisfies the linkage property. Otherwise, D, should be the rightmost D,, q cannot contain D, (as, Y # A).
. In this case 7r = D, 6’7 D,, where 6 = 6’~) because D, also cannot be in 7. We have to prove that
if b In contains D, then it must contain E’, . Assume to the contrary that 61, contains D, but no E,. It
is easy to see that either 7 or 6’1,, should contain D, with no 23, , because at most one block of D$ or
.E$ can be cancelled in 6 In. This leads to a contradiction of either the assumption that 7 has the balancing
property or the assurnption that t1 has the linkage property. H
Lemma A.2. Let T be a balanced cascade protocol. Then every string 7 E (Ci U Cz U Es)* has the linkage
property.
Proof. For each q E (Ci U C2 U C:s)*,  write 7 = wi . . . . . w,,, where each w, is either in C$ or C2 or
f3. One can finish the proof by a simple induction on n, the number of words in 71, using Lemma A.l. 4
Lemma A.3. For any string 7 and any 2, if r] has the linkage property, then ?j also has the same property.
Pj-oof.  It suffices to prove that, if a string has the property, then so does the new string obtained by
a reduction of any pair D, E, or E,\-  D,, for any X. Let q be any string which has the linkage property.
Assume
rl = 71 EJ?~ 712  .
Let A be any user other than 2. We have to show that every substring of D, r]i r/2  D, is A-balanced.
If A = X, then every substring of D, 771772  D, is A-balanced, because the corresponding substring of
D, 7 D, is A-balanced. In the following, we assume A # X.
Let D, be the first D, from the right of D,ql other than D,, and let D, be the first such D, (V f A)
from the left of q2Dz.  Then we can write
The fact that 7 has the linkage property implies that D, 61 E, D, and D, 62 D, are A-balanced. It is then
easy to see that D, ~5~62 D, is also A-balanced. This completes the proof. 0
Note that the lemma does not hold in the reverse direction, that is, if 7 has the linkage property, it
does not imply that 7 has it.
Example. Let 7 = E,D, E,- E, D,D,E,, then ?j has the linkage property but 7 does not have it.
Proof of Lemma 2.1. We have to prove that for every string q E (Ci U C2 U Es)*,  the reduced string +j
has the balancing property w.r.t. every A # 2.
Assume to the contrary that, for some A, +i does not have the balancing property w.r.t. A. It follows that
q contains a D, but does not contain any E,, . But this implies that i;l does not have the linkage property,
However, ?j must have the linkage property by Lemmas A.2 and A.3. This leads to a contradiction. 1
19
Appendix B. Proof of Lemma 3.4.
The purpose of this appendix is to show that Rx can be computed in O(n7)  time. (See Section 3 for
notations.)
For L = 0, 1,2,. . . , let
Qe{ (g,b) 1 9 E I ’ ,  6 E I, 3 il, i2, * * . , i, with 0 < j 5 f!. such that g 6,, 6,, . . . fSzJ  6 br X } .
Clearly,
Rx= fiQ[.
e=o
P - 1)
Define Vo = Qo. We will give a procedure K which generates a set Ve C I’ X I once Ve-1  is given. Consider
the sequence Vo, VI,  V;L, . . . generated by this procedure iteratively. We will show that the sequence {Ve}
satisfies the following properties:
1’1. F o r  a l l  ! 2 0, Ve C Ve+l  a n d  Ve C Rx.
P 2 .  F o r  a l l  JJ 2 0, Qe C Ve.
P 3 .  F o r  a l l  e 2 111  * II’/, Ve+l  = Ve:
It follows from (R-l) and PI--P3 that
R, = Ve w i t h  C = 111  . 11’1. (B - 2)
Thus, if we first compute Vo = Q 0, followed by 111  . 11’1  applications of procedure K, we will have obtained
the desired Rx. The time needed to compute Vo is easily seen to be O(nlll  - 11’1). Let cost(K) denote the
maximum running time of procedure I<, then the total time to compute Rx is O((n -t cost(Kj)lIl - [I’]) =
O(n” + n2 cost(K)). We will show that cost(K) = O(n5), thus giving a O(n7)  total running time.
We now give a description of procedure K. Assume that Ve-1  is given, we will describe how Ve is
generated.
Procedure K :
We process the pairs (g, 6) in I’ X I one at a time in the increasing order of the length s = 191 -I-- 161. For
each (g, b), we include (g, b) in Ve if it is in &-I,  and otherwise we execute the following steps according to
the cases:
Case 1. 191 =  0 ,  161 =  0 :
step a. F o r  e a c h  1  5 k, j 2 p,  test  i f  both (a,~,. -+ X) E I’ a n d  (bk, 6:) E Ve-1  w h e r e
6k = a,bi, b3 = Si a,; let (g, 6) E Ve if the answer is “yes”.
step b. F o r  e a c h  1  < j < p  a n d  elrsry  p a r t i t i o n  6J = st (s, t m a y  b e  X ) ,  t e s t  i f  b o t h
(g, s) E Ve-1 and (t, 6) E Ve-1;  let (g, 6) E Ve if the answer is “yes”.
Case 2. 191 = 0, 6 = bluj:
step a. For each 1 2 k 5 p, test if both ( utu3 -+ X) E I ’  and (6’,, 61) E Ve-1, w h e r e  6h =
u,6/k.;  let (g, 6) E Ve if the answer is “yes”.
step b. For  each 1  < k 5 p a n d  e v e r y  p a r t i t i o n  6k = st (s, t may be  X), test if both
(g, s) E Ve-1 and (t, 6) E Ve-1;  let (g, 6) E Vf if the answer is “yes”.
Case 3. g = ukgl, 161  = 0:
step a. For each 1 < j < p, test if both (ukui --+ X) E l? a n d  (g,, 6:) E Ve-1, w h e r e  bj =
6:~~; let (g, 6) E Ve if the ahswer is (‘yes”.
step b. For  each 1  < k 2 p and every  part i t ion  Sk = st, test if doth  (g, s) E Ve-1 a n d
(t, 6) E Vp-1; let (g, 6) E Ve if the answer is “yes”.
20
Case 4. g=akgl,  6=61aj:
step a. Test if both (okoj --+ X) E P and (gi, 61) E Ve; let (g, 6) E Ve if the answer is “yes”.
step b. For each 1 5 k 5 p and every  part i t ion  6k = st, test if both (g, s) E Ve-1  a n d
-(t, 6) E Ve-1;  let (g, 6) E Ve if the answer is ‘yes”.
[comment. If (g, 6) is not included in Ve after these steps, then (g, 6) 4 Ve.]
End Procedure K.
It is easy to check that, for each pair (g, 6)) the needed time in its processing is at most O(nlll . 11’1) =
O(n3). T h u s ,  c o s t ( K )  =  O(n”lTI . 11’1) = O(n5).
We can now complete the proof of the lemma, by showing that the sequence (Ve} satisfies Pl-P3.
We observe that, whenever a (g, 6) is added to Ve in procedure K, the conditions give a ‘natural
construction of a string 7 E g{a,}* 6 that can be reduced to X. We omit a straightforward proof. This
establishes P 1.
To prove P3, observe that the construction of Ve from Ve-1  does not explicitly depend on e. Thus,
o n c e  w e  f i n d  Ve = Ve-1,  t h e n  Ve = Vet-1  = Ve+2 t= s-s. But this condition must be reached for some
f? _< 111  . 11’1,  as there are at most /II . II’) e ements in any V,. This proves P3.1
We prove P2 by induction on .!!. The case e = 0 is trivial, as Vo  = Qo. Now assume that we have
proved P2 for all values less than !, and we will prove P2 for e (e > 0).
We need to show that, for any (g, 6) E Q e, one must have (g, 6) E Ve. We prove this by induction on the
v a l u e  s = 191  -/- 161. For any s 2 0, let us assume that the statement is true for all (g, 6) with Igl + 161 < s;
we will prove the statement when lgl+  161 = s. There are four cases to be considered, depending on whether
191  = 0 and whether 161  = 0. We will consider the case 191  > 0 and 161  > 0, and leave the other three cases
as an exercise.
If (9’6) E &e-l, then by induction hypothesis, (g, 6) E Ve-1 C Ve. We can thus assume that (g, 6) E
Qe  - &t-i.  Write g = ux;gi , 6 = 61 u3, and suppose
In the above reduction  process to A, either the last step is ukuJ -+ X or the cancellation of the leFtmost u/2 is
with a symbol a, in some 6,,, . In the former case (gi, 6,) E Qe and, since /gi I+ 161 I < s, we have (gi, 6,) E Ve
by induction hypothesis; this means (g, 6) will be included in VP during the execution of procedure K (Case
4, step a). In the latter case there is a partition bzU  = st such that (g, s) E &p-i and (t, 6) E &c-i ; this
e means (g, 6) is added to Ve in the process (Case 4, step b). This completes  the induction.
We have proved P2, and hence Lemma 3.4. 1
21
References
[l] W. Difie  and M. IIellman, “New direction in cryptography,” IEEE  Trans. on Inform. IT-22, 6 (1976),
644-654.
[2] W .  DifIie  a n d  M .  IIellman, “Multiuser cryptographic techniques,”  Proc. AFIPS 1976 NCC, AFIPS
Press, Montvale, N.J., 109-112.
[3] D .  D o l e v , “Uyzantine  Generals strike again,” ;lorlmal of Algorithms, to appear.
[4] M. A. Harrison, W. L. RUZZO,  and J. D. ~Jllman, “Protection in operating systems,” Comm. ACM 19
(1976), 461~-471.
[5] J. E. Hopcroft  and J. D. Ullman, Formal I,anguages  and TIleir Relation to Automata, Addison-Wesley,
Reading, Mass., 1969.
[6] R. Lipton and L. Snyder, “A linear time algorithm for deciding subject security,” Journal ACM 24
(1977), 455-464.
[7] R .  C.  Merkle , “Protocols for public key cryptography,” BNR technical report, Palo Alto, CA, 1980.
[8] R. M. Needham a n d  M .  D .  S c h r o e d e r , “Using encryption for authentication in large networks of
computers,” Comm. ACM 2 (1978),  993-999.
[9] M. Pease, 12. Shostak, and L. Lamport, “Reaching agreement in the presence of faults,” Journal ACM
27 (1980), 228-234.
[iO] G. J. Popek and C. S. Kline, “Encryption protocols, public key algorithms, and digital signatures in
computer networks,” in jbnndations  of Secure Computation, edited by R. A. Demillo et. al., Academic
Press, 1978.
[ll] R. L. Rivest, A. Shamir, and L. Adleman, “A method for obtaining digital signatures and public-key
cryptosystems,” Comm. ACM 21 (1978), 120-126.
22

