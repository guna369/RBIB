S. Delaune, P. Lafourcade,
D. Lugiez, R. Treinen
Symbolic Protocol Analysis in
Presence of a Homomorphism
Operator and Exclusive Or
Research Report LSV-05-20
November 2005
Symbolic Protocol Analysis in Presence of a
Homomorphism Operator and Exclusive Or .
Ste´phanie Delaune1,2, Pascal Lafourcade2,3, Denis Lugiez3 and Ralf Treinen2
1 France Te´le´com, Division R&D
2 LSV, CNRS UMR 8643, ENS de Cachan & INRIA Futurs
3 LIF, Universite´ Aix-Marseille1 & CNRS UMR 6166
Abstract. The symbolic verification of the security property of a cryp-
tographic protocol for a bounded number of sessions is usually expressed
as a symbolic trace reachability problem. Such a problem can be ex-
pressed as a constraint system for deducibility constraints for a certain
inference system describing the possible actions of an attacker.
We show that symbolic trace reachability for well-defined protocols is
decidable in presence of both the exclusive or operator and a homo-
morphism over this operator. The exclusive or operator is often used in
security protocols as a symmetric encryption operation. The homomor-
phism may model a hash function, or may be used to model a special
situation in asymmetric encryption where an intruder may encrypt a
message but can never learn about the corresponding decryption key.
One main step of our proof consists in reducing the constraint system
for deducibility into a constraint system for deducibility in one step and
using one particular rule of the constraint system. This constraint sys-
tem, in turn, can be expressed as a system of quadratic equations of a
particular form over the ring of polynomials in one indeterminate over
the finite field Z/2Z[h]. We show that satisfiability of these systems of
equations is decidable.
1 Introduction
Cryptographic protocols are small programs designed to ensure secure commu-
nication via a channel that is controlled by an attacker. They involve a high
level of concurrency and are difficult to analyze by hand. For instance, a flaw
in the so-called Needham-Schroeder public key authentication protocol [NS78]
was discovered by Lowe [Low96] using an automatic tool only 17 years after its
publication. Therefore, the need of formal methods to achieve this analysis has
been recognized and many approaches have been proposed.
A cryptographic protocol is defined by a set of programs (or roles) which
may be executed by agents which are distributed over a network. In the simplest
of cases these programs are linear sequences of receive and send instructions on
a public communication channel. The attacker may modify the messages sent on
. This work has been partly supported by the RNTL project PROUVE´ 03V360 and
the ACI-SI Rossignol.
the channel using a certain set of intruder capabilities. The fact that all messages
may be modified by the attacker is often expressed by saying that the attacker
is the network.
The most basic property of cryptographic protocols is the so-called security
property, which states that for any number of agents executing the roles, for any
possible interlacing of the program execution, and for any modifications of the
messages by the attacker (according to his deduction capabilities) the intruder
is not able to deduce a certain message which is supposed to remain secret.
Security of a protocol is undecidable if the number of role instances running
in parallel is unbounded [DLMS99]. Rusinowitch and Turuani [RT03] have shown
that security of a cryptographic protocol is decidable, and in fact NP-complete,
when the number of parallel role instances is bounded. In this case there is only
a bounded number of symbolic traces, each of which represents an interlacing of
the execution of the parallel role instances. Every message received during the
execution of a role is a message that can be deduced using the intruder deduction
capabilities from the messages sent before on the communication channel. The
idea of the algorithm is to guess a symbolic trace in which the messages are
represented by terms containing variables. This symbolic trace corresponds to a
concrete execution trace if the variables can be instantiated in such a way that
at every moment a message received by an agent can in fact be deduced by the
intruder from the messages seen before. Hence, verifying security of a protocol
amounts to a non-deterministic guessing of the symbolic trace plus the resolution
of a system of deducibility constraints. These constraints can be solved in NP in
case of the intruder deduction capabilities described by the so-called Dolev-Yao
model.
This result, as many others, relies on the so-called perfect cryptography as-
sumption which states that the cryptographic primitives like encryption, hash-
ing, etc are perfect and can be treated as black boxes. This assumption allows to
represent messages built using cryptographic primitives in a free term algebra.
On the one hand, even this quite strong assumption provides a useful abstraction
of the problem since it allows one to detect many attacks on protocols, as for in-
stance the attack on the Needham-Schroeder protocol mentioned before. On the
other hand, many security flaws of protocols may go undetected when one ab-
stracts away all properties of the cryptographic primitives. Indeed, some attacks
exploit in a clever way the interaction between protocol rules and properties of
cryptographic primitives.
Hence, a recent research direction in symbolic protocol analysis consists in
relaxing the perfect cryptography assumption by taking into account some of
the properties of the cryptographic primitives (see [CDL05] for a survey). The
most important of these, the so-called algebraic properties, can be stated by
a set of equational axioms. Most of these works extend the pioneering result
by Rusinowitch and Turuani and take into account a particular (or a class of)
equational theories [MS05,DJ04]. Recently, Chevalier and Rusinowitch [CR05]
have developed a procedure to combine disjoint intruder theories, provided that
satisfiability of intruder constraints can be decided in each theory.
2
In this paper, we prove the decidability of security protocols in the active
case (the intruder may send messages that he has forged) for the equational
theory ACUNh which is the combination of the homomorphism axiom h(x+y) =
h(x) + h(y) with the well-known exclusive or (ACUN) theory. Note that each of
these two equational theories models basic properties of important cryptographic
primitives. Exclusive or is a basic building block in many symmetric encryption
methods like DES or AES. It is even used directly as an encryption method
(Vernam encryption). Homomorphisms are ubiquitous in cryptography. Some
protocols relying on these algebraic properties are described in [CDL05]. For
instance, the ElGamal encryption method has this property. It also occurs in case
of the Wired Equivalent Privacy (WEP) protocol in which a checksum function
C is used. This function has the homomorphism property over +, i.e. C(x +
y) = C(x) + C(y). Another well-known example, the TMN protocol [TMN89],
is detailed in Section 9. The homomorphism property is also crucial in the field
of electronic voting protocols [CGS97].
Our results extends previous works [CLT03,LLT05a] for the case of passive
attacks (the intruder can only listen to messages) that have resulted in a PTIME
decision procedure [Del05] for the ACUNh theory. This latter algorithm is an im-
portant ingredient to the algorithm for active attacks developed in this paper.
Another important ingredient to our algorithm is unification modulo the equa-
tional theory ACUNh which has been shown decidable by [GNW00]. Decidability
of unification modulo an equational theory E is a necessary condition for decid-
ability of the security property for a bounded number of role instances [CDL05].
Moreover, our algorithm will rely on the fact that unification modulo ACUNh is
finitary, that is that every problem has a finite set of most general solutions.
The ACUNh equational theory does not fall in any of the results cited above
for the active case. Although the equational theory is a combination of the homo-
morphism axiom with the theory of exclusive or, we can not use the combination
result by Chevalier and Rusinowitch [CR05] since these two theories are not dis-
joint. Moreover, their result relies on a model which is different to ours in that
it allows to model only a restricted class of protocols. In particular, their model
does not cope with the TMN protocol which is described in Section 9. Lastly,
the promising approach of H. Comon-Lundh [CL04] which consists in separat-
ing the offline intruder theory (i.e. the capabilities of the intruder to build new
messages) from the equational theory will not handle the ACUNh theory since
this theory does not enjoy the finite variant property [CD05].
Our algorithm is largely inspired by Millen and Shmatikov’s approach [MS05]
for the equational theories of Abelian groups and Diffie-Hellman exponentiation.
Although the overall structure of our proof is the same as theirs there are many
differences in the technical details. In particular, we think that our procedures
to reduce deducibility constraints to one-step deducibility constraints, and the
procedure to solve a special case of quadratic equations in polynomials over the
finite field Z/2Z[h], remedy some of the shortcomings of [MS05].
3
2 Preliminaries
2.1 Terms
We use classical notations and terminology on terms, unification and rewrite
systems. We write T (F ,X ) for the set of terms built over the finite (ranked)
alphabet F of function symbols and the set of variable symbols X . For our
purpose, we assume that F contains at least the function symbols 〈., .〉, {.}.,
.+ . and h(.). The set T (F , ∅) of ground terms (terms without variables) is also
written T (F). The set of positions of a term t is written O(t). The subterm of
t ∈ T (F ,X ) at position p ∈ O(t) is written t|p. The term obtained by replacing
t|p with s is denoted t[s]p. We refer to any term u that is the same as t everywhere
except below p, i.e. such that u[s]p = t, as the linear context within which the
replacement takes place. More precisely, a linear context is a term u with a
distinguished position p. The set of variables occurring in t is denoted vars(t).
A substitution σ is a mapping from a finite subset of X called its domain,
and written dom(σ), to T (F ,X ). Substitutions are extended to endomorphisms
of T (F ,X ) as usual. We use a postfix notation for their application. The image
of a substitution σ is the set img(σ) = {xσ | x ∈ dom(σ)}. Given two terms u
and v the replacement of u by v, denoted by [u %→ v], maps every term t to the
term t[u %→ v] which is obtained by replacing all occurrences of u in t by v. Note
that the result of such replacement is uniquely determined.
2.2 Unification
If E is a set of equations (unordered pairs of terms), we denote by sig(E) the set
of all function symbols occurring in E. An E-context is a λ-term λx1, . . . , xn.t
with t ∈ T (sig(E), {x1, . . . , xn}), also written t[x1, . . . , xn]. The application of a
context t[x1, . . . , xn] to arguments u1, . . . , un is written t[u1, . . . , un].
We denote by =E the least congruence on T (F ,X ) such that uσ =E vσ for
all pairs u = v ∈ E and substitutions σ. Two terms s, t are E-unifiable if there
is a substitution σ such that sσ =E tσ. Such a substitution is called an E-unifier
of s, t. An E-unification problem Γ is a finite set of equations between terms. A
substitution σ is an E-unifier of Γ if and only if sσ =E tσ holds for each pair (s, t)
of terms in Γ . If all terms are in T (sig(E),X ) the problem is called elementary
E-unification problem. If terms contains additional “free” constant symbols the
problem is called E-unification problem with constant, and if terms can contain
additional “free” function symbols the problem is called general E-unification
problem.
Let σ and θ be two E-unifiers, σ ≤ θ if and only if there exists a substitution
λ such that xθ =E xσλ for all variables x; σ is said more general than θ. It is a
most general E-unifier (E-mgu) if for every E-unifier θ, σ ≤ θ. We say that there
is an E-unification algorithm if it is possible, for any unification problem Γ to
compute a complete set σ1, . . . ,σn of E-unifiers of Γ . This means that for every
E-unifier σ of Γ , there is an index i such that σi ≤ σ. The unification type of E
(w.r.t. a signature Σ) is finitary if for every E-unification problem over Σ, the
minimal complete set of E-unifiers has a finite cardinality
4
2.3 Term Rewriting System
A term rewriting system (TRS) is a finite set of rewrite rules l → r where
l ∈ T (F ,X ) and r ∈ T (F , vars(l)). Given a TRS R and a set of equations E,
the relation →R/E (rewriting modulo E) is defined as follows: s →R/E t if and
only if s =E u[lσ]p and u[rσ]p =E t, for some linear context u, position p in
u, rule l → r ∈ R, and substitution σ. The rewrite system is R/E is strongly
terminating if there is no infinite chains t1 →R/E t2 →R/E . . . and it is locally
confluent if for every terms t, s1 and s2 such that t →R/E s1, t →R/E s2, there
exists a term s such that s1
∗
−→R/E s, s2
∗
−→R/E s where
∗
−→R/E is the reflexive and
transitive closure of →R/E. A rewrite system R/E is said to be E-convergent if
it is both strongly terminating and locally confluent. A term t is in normal form
(w.r.t. →R/E) if there is no term s such that t →R/E s. If t
∗
−→R/E s and s is in
normal form then we say that s is a normal form of t.
3 Attacker Model
3.1 Inference System
The most widely used deduction relation representing the deduction abilities of
an intruder is often referred to as Dolev-Yao model [DY81]. Here we augment
the intruder abilities by allowing for equational reasoning modulo a given set E
of equational axioms. The deduction system is given in Figure 1: the equational
theory is taken into account through the normalization function ↓.
Unpairing (UL)
T ! 〈u, v〉
T ! u
Compose (C)
T ! u1 . . . T ! un
with f ∈ F ! sig(E)
T ! f(u1, . . . , un)
Unpairing (UR)
T ! 〈u, v〉
T ! v
Context(ME)
T ! u1 . . . T ! un
with C an E-context
T ! C[u1, . . . , un] ↓
Decryption (D)
T ! {u}v T ! v
T ! u
Fig. 1. Dolev-Yao Model Extended with an Equational Theory
The intended meaning of a sequent T * u is that the intruder is able to
deduce the term u ∈ T (F ,X ) from the finite set of terms T ⊆ T (F ,X ). As in
the standard Dolev-Yao model, the intruder can compose new terms (C) from
known terms, he can also decompose pairs (UL, UR) and decrypt ciphertexts,
providing that he can deduce the decryption key (D). Finally, we relax the perfect
cryptography assumption by allowing the intruder to apply function symbols such
5
as +, h. The algebraic properties of these primitives are automatically take into
account thanks to the normalization.
In this paper, we are interested in the equational theory E = ACUNh which
is made up of the well-known axioms of exclusive or in combination with an
homomorphism symbol. More formally, ACUNh contains the following equations:
– Associativity, Commutativity (AC): x+ (y+ z) = (x+ y) + z, x+ y = y+ x,
– Unit (U): x+ 0 = x,
– Nilpotence (N): x+ x = 0,
– Homomorphism (h): h(x+ y) = h(x) + h(y).
Given an homomorphic symbol h, the notation hn(t) represents the term t if
n = 0 and h(hn−1(t)) otherwise. We represent the ACUNh equational theory by
an AC-convergent rewrite system. This can be obtained by orienting from left
to right the equations (U), (N), (h) and by adding the consequence h(0) → 0
(see [LLT05a] for details). After each deduction step, the term u obtained is
reduced to its normal form u ↓. Equivalence modulo AC is easy to decide, so we
omit the equality rule for AC and just work with equivalence classes modulo AC.
More generally, along this paper, we consider implicitly that terms are kept in
normal forms, hence we write u (resp. uσ) instead of u ↓ (resp. uσ ↓).
This deductive system is equivalent in deductive power to a variant of the
system in which terms are not automatically normalized, but in which arbitrary
equational proofs are allowed at any moment of the deduction (see [Del05,LLT05a]).
The inference system described in Figure 1 deals with symmetric encryption only.
However, it is not difficult to design a similar deduction system for asymmetric
encryption and to extend the result of this paper to this new inference system.
3.2 Factors, Subterms
A term t is standard if and only if it is not of the form f(u) for some term u
and some f ∈ sig(E).
Definition 1. Let t be a term in normal form. We have t = C[t1, . . . , tn] for
some standard terms t1, . . . , tn and an E-context C. The set FactE(t) of factors
of t is defined by FactE(t) = {t1, . . . , tn}. The set StE(t) of subterms of t is the
smallest set such that:
– t ∈ StE(t),
– if f(t1, . . . , tn) ∈ StE(t) is standard then t1, . . . tn ∈ StE(t),
– if s ∈ StE(t) is not standard then FactE(s) ⊆ StE(t).
These notations are extended as expected to sets of terms: FactE(T ) (resp.
StE(T )) is the union of the sets FactE(t) (resp. StE(t)) for every term t oc-
curring in T . Note that, by definition, 0 is not a standard term and the factors
of any term are necessarily standard.
Example 1. Let t1 = h2(a)+b+c, t2 = h(〈a, b〉)+c and t3 = 〈a+b+c, d〉. We have
FactE(t1) = {a, b, c}, StE(t1) = {t1, a, b, c}, FactE(t2) = {〈a, b〉, c}, and StE(t2) =
{t2, 〈a, b〉, a, b, c}, FactE(t3) = {t3}, and StE(t3) = {t3, a+ b+ c, d, a, b, c}.
6
Definition 2. A substitution σ is non-collapsing w.r.t. a set T of terms iff:
∀u, v ∈ StE(T ) \ X : uσ =E vσ ⇒ u =E v
Definition 3. The set of non-standard subterms NSt(t) of a term t is
NSt(f(t1, . . . , tn)) =
⋃n
i=1 NSt(ti) if f .∈ sig(E)
NSt(t) = {t} ∪
⋃
s∈FactE(t)\X
NSt(s) otherwise
Example 2. Let t = h(X1)+X2+〈X3, X4+X5〉, then NSt(t) = {t,X3, X4+X5}.
3.3 Proofs
Definition 4. A proof P of T * u is a finite tree such that
– every leaf of P labeled with T * v is such that v ∈ T ,
– for every node of P labeled with T * v having n sons (n ≥ 1) labeled with T *
v1, . . . , T * vn, there is an instance
T * v1 . . . T * vn
(R)
T * v
of an inference
rule in Figure 1. If this node labeled with T * v is the root of P , we say that
P ends with an instance of (R).
– the root of P is labeled with T * u.
Note that the terms in the proof are not necessarily ground. The size of a
proof P , denoted by |P |, is the number of nodes in P . A proof P of T * u is
minimal if there is no proof P ′ of T * u such that |P ′| < |P |. A proof P of T * u
is a decomposition proof in any of the following cases:
– |P | = 1 (this means that P is reduced to a leaf),
– P ends with an instance of a decomposition rule (i.e. (UL, UR, D)),
– P ends with an instance of (ME) and u is a standard term.
Definition 5. A term u is R-one-step deducible from a set of terms T in any
of the following cases:
– T * u is a proof of T * u (i.e, u ∈ T ),
– there exists u1, . . . , un such that
T * u1 . . . T * un
(R)
T * u
is a proof of T * u.
We say that u is one-step deducible from T if there exists an inference rule (R)
in Figure 1 such that u is R-one-step deducible from T . We say also that u is
DY-one-step deducible from T if R ∈ {C,UL,UR,D}.
Example 3. Consider the ACUNh theory, let T = {a+h(a), b}, the proof P below
is a proof of T * a+ h3(a) + h(b). It is made up of an instance of the rule (ME)
with C = x1 + h(x1) + h2(x1) + h(x2).
T * a+ h(a) T * b
(ME)
T * a+ h3(a) + h(b)
Since a + h3(a) + h(b) is not standard, P is not a decomposition proof. We
have |P | = 3 and a + h3(a) + h(b) is ME-one-step deducible from T but is not
DY-one-step deducible from T since ME .∈ {C,UL,UR,D}.
7
3.4 Locality Lemma
Now, we can state the following locality lemma. This notion was first introduced
by McAllester [McA93] in order to characterize theories with a deduction prob-
lem decidable in PTIME. This result, proven in [Del05], allows us to focus on
proof trees that involve only some particular terms.
Lemma 1. A minimal proof P of T * u contains only terms in StE(T ∪ {u}).
Moreover, if P is a decomposition proof, then P contains only terms in StE(T ).
4 Constraint System
4.1 Well-Defined Constraint System
Definition 6. A constraint (resp. one-step constraint, ME constraint) is a se-
quent of the form T ! u (resp. T !1 u, T !ME u) where T is a finite subset
of T (F ,X ) and u ∈ T (F ,X ). We call T (resp. u) the hypothesis set (resp. the
target) of the constraint. A system of constraints is a sequence of constraints. A
solution to a system C of constraints is a substitution σ such that:
– for every T ! u ∈ C there exists a proof of Tσ * uσ
– for every T !1 u ∈ C uσ is one-step deducible from Tσ
– for every T !ME u ∈ C, uσ is ME-one-step deducible from Tσ.
If F ′ is a sub-signature of F then a solution σ to a constraint system is called a
F ′-solution if xσ ∈ T (F ′,X ) for every x ∈ dom(σ).
Note that, if σ is solution to a constraint (resp. one-step constraint, ME
constraint) c, then σθ is also a solution to c for every substitution θ.
Definition 7. A constraint system C = {Ti ! ui}1≤i≤k is well-formed if:
1. (monotonicity) 0 ∈ T0 and for all i < k, Ti ⊆ Ti+1,
2. (origination) for all i ≤ k, for all x ∈ vars(Ti), there exists j < i such that
x ∈ vars(uj).
We say that C is well-defined if for every substitution θ, Cθ is well-formed.
This notion of well-definedness is defined in a similar way on systems of
one-step (resp. ME) constraints. This definition is due to Millen and Shmatikov.
In [MS05] they show that “reasonable” protocols, in which legitimate protocol
participants only execute deterministic steps (up to the generation of random
nonces) always lead to a well-defined constraint system. In the following we will
only consider well-defined protocols. This allows us to restrict our attention to
well-defined constraint systems.
8
4.2 Conservative Solutions
The completeness of our decision procedure is ensured by the existence of a con-
servative solution (Lemma 2) which does not introduce any new structure. More-
over, conservative solutions allow us to lift the locality Lemma (see Lemma 3).
The proofs of Lemmas 2 and 3 are detailed in Appendix A.
Definition 8. Let C be a constraint system and σ a substitution, σ is conserva-
tive w.r.t. C if and only if for all x ∈ vars(C), FactE(xσ) ⊆ (StE(C) \ vars(C))σ.
Lemma 2. Let C be a well-defined constraint system. If there exists a solution σ
to C then there exists a conservative one.
Example 4. Consider the following well-defined constraint system C:
0, a, h(b) ! h(x)
0, a, h(b), x ! 〈a, b〉
One solution is σ = {x %→ 〈a, a〉+ b}. This solution is not conservative w.r.t. C.
Indeed FactE(〈a, a〉 + b) = {〈a, a〉, b}, and 〈a, a〉 does not belong to (StE(C) \
{x})σ which is equal to {0, h(b), b, h(〈a, a〉+ b), 〈a, b〉, a}. However, as it is said
in Lemma 2, there is a conservative solution: {x %→ b}.
Lemma 3. Given a conservative solution σ of C = {C1, . . . , Ck}. For each
i ≤ k, there exists a proof Pi of Ciσ which involves only terms in StE(C)σ.
5 Some Results about E-Unification
The following theorem (proved in Appendix B) states that unification in ACUNh
is finitary. This is an important ingredient of our decision procedure (see Lemma 6).
Theorem 1. Unification in the theory ACUNh is finitary and there exists an
algorithm to compute a complete finite set of unifiers of any unification problem.
In the rest of the paper, we use some notations that are useful to deal with
terms and polynomials of Z/2Z[h]. The multiplication between polynomials is
denoted by . and a polynomial P (h) ∈ Z/2Z[h] can be written
∑n
i=0 bih
i where
bi ∈ Z/2Z. The product 1 of a polynomial by a term is a term defined as follows:
(
n∑
i=0
bih
i)1 t =
n∑
i=0 | bi &=0
hi(t)
For instance (h2+1)1 (X+a) = h2(X)+X+h2(a)+a. Conversely a term t
such that vars(t) = {X1, . . . , Xp} can be written tX1 1X1 + . . .+ tXp 1Xp + t0
for some tX1 , . . . , tXp ∈ Z/2Z[h], and t0 a ground term.
9
The following technical lemma will be used in the proof of Lemma 5.
Lemma 4. Let P be a unification problem in the theory E = ACUNh (including
free function symbols) and θ be an mguE of P . Then for all x ∈ dom(θ) and
v ∈ StE(xθ) \ vars(xθ) there exists t ∈ StE(P ) such that v =E tθ.
To a polynomial P (h) =
∑i=n
i=0 bih
i with bi ∈ {0, 1}, we associate the number
nb(P ) whose representation in base 2 is bn . . . b0. This correspondence is one-one.
We define a total ordering < on polynomials in Z/2Z[h] by P < P ′ if and only
if nb(P ) < nb(P ′). This is a total Noetherian ordering (no infinite decreasing
sequence exists).
6 From Constraints to ME Constraints
To reduce the satisfiability of a constraint system to the satisfiability of ME
constraint system, we proceed in two steps:
1. Firstly, we reduce our problem to the satisfiability of one-step (but not nec-
essary ME) constraints (Lemma 5).
2. Secondly, we reduce the satisfiability of one-step constraint system to the
satisfiability of ME constraint system (Lemma 6).
Proofs are given in Appendix C.
Input: C = {T1 ! u1, . . . , Tk ! uk}
Output: C′
Algorithm:
guess S ⊆ StE(C).
for all s ∈ S, guess j(s) ∈ {1, . . . , k}.
C′:= ∅
for i = 1 to k do
let Si := {s | j(s) = i}.
choose a total ordering on Si (Si = {s
1
i , . . . , s
ki
i })
for j = 1 to ki do
T := Ti ∪ S1 . . . ∪ Si−1 ∪ {s1i , . . . , s
j−1
i }
C′:= C′ ∪ {T !1 s
j
i}
end
C′:= C′ ∪ {T !1 ui}
end
return C′.
Fig. 2. From Constraints to One-Step Constraints
The non-deterministic algorithm described in Figure 2 allows us to reduce
the satisfiability of a system of constraints to the satisfiability of a system of
one-step constraints. First, it guesses among the subterms of C those which are
10
going to be deduced by the intruder and inserts each deducible subterm in the
constraint system. The completeness of this step of the procedure is essentially
due to the existence of a conservative solution (Lemma 2) and the lifting locality
lemma (Lemma 3). In the resulting constraint system, every constraint can be
solved by application of a single inference rule.
Lemma 5. Let C be a well-defined system of constraints. Let C ′ be the set of
constraint systems obtained by applying the algorithm of Figure 2 on C.
1. C ′ is a finite set of well-defined system of one-step constraints.
2. Let C′ ∈ C ′. If σ is a solution to C′ then σ is a solution to C.
3. If σ is a conservative solution to C then there exists C ′ ∈ C ′ such that σ is
a solution to C′.
4. For any C′ ∈ C ′, σ is conservative w.r.t. C if and only if σ is conservative
w.r.t. C′.
Lemma 6 allows to reduce the satisfiability of a system of one-step constraints
to the satisfiability of a system of ME constraints. We first guess a set of equali-
ties between subterms and thus obtain a unification problem which has a finite
and complete set of solutions thanks to Theorem 1. We apply the unifier to the
constraint system. Then, one-step constraints which can be solved by the ap-
plication of a standard inference rule, i.e. (D, UL, UR, C), can be determined
by syntactic inspection. Hence, we can eliminate all constraints which can be
satisfied by a single application of an inference rule other than (ME).
Lemma 6. Given C a well-defined system of one-step constraints. Let P =
{
∧
(s1,s2)∈S′
s1 = s2 | S′ ⊆ StE(C)2}. Let R ∈ P and θ ∈ mguE(R). Let
Cθ = {Tθ !ME uθ | T !1 u ∈ C and uθ is not DY-one-step deducible from Tθ}.
1. There are only finitely many outputs for a given input C. Each of them is a
well-defined system of ME constraints.
2. If there exists Cθ (obtained by the procedure above) which has a solution then
C has a solution.
3. If C has a conservative solution then there exists Cθ (obtained by the procedure
above) which has a non-collapsing solution.
7 Dealing with ME Constraints
Now, we have to solve well-defined ME constraint systems. In the remainder, we
consider a ME constraint system C of the following form:
t1, . . . , tn !ME u1
t1, . . . , tn, tn+1 !ME u2
...
t1, . . . , tn, tn+1, . . . , tn+k−1 !ME uk
11
We assume (w.l.o.g) that the hypotheses (i.e. t1, . . . tn+i) of the i+ 1
th constraint
contain exactly one term more than the hypotheses of the ith constraint. This
can be achieved by duplicating some terms or by adding some constraints.
The proofs of this section can be found in Appendix D.
7.1 Factor Preservation
Definition 9. A constraint system is factor-preserving if for all i, 1 ≤ i ≤ k,
we have that FactE(ui) \ X ⊆
⋃j=n+i−1
j=1 FactE(tj).
Lemma 7. If a well-defined ME-constraint system C has a non-collapsing solu-
tion then it is factor-preserving.
7.2 Another Characterization of Well-Definedness
Let vars(C) = {X1, . . . , Xp}. As we have already seen in Section 5, every ti (or
ui) can be written t
X1
i 1X1 + . . . t
Xp
i 1Xp + t
0
i with t
Xv
i in Z/2Z[h] and t
0
i is a
sum of standard terms. We will denote with ti the vector (t
X1
i , . . . , t
Xp
i ).
Definition 10. Let V = {v1, . . . , vm} be a subset of Z/2Z[h]n. V is independent
if whenever there exist αi ∈ Z/2Z[h] such that α1v1+. . .+αmvm = 0 then αi = 0
for all 1 ≤ i ≤ m. Otherwise V is dependent.
Proposition 1. Let A be a matrix n × m over Z/2Z[h] such that the n row
vectors are independent (n ≤ m) then:
∃Q ∈ Z/2Z[h], ∀b ∈ Z/2Z[h]n, ∃X ∈ Z/2Z[h]m A ·X = Q · b (1)
Moreover, a coefficient Q is computable as a determinant of a sub matrix of A.
Given C a well-defined ME constraint system, we construct first the set L
containing the indexes of the defining constraints by using the following algo-
rithm:
Input: C = {T1 !ME u1, . . . , Tk !ME uk}
Output: L
Algorithm:
L := ∅;
for i = 1 to k do
if {ui} ∪ {uj | j ∈ L } is independent then L := L ∪ {i};
end
return L.
Let Bi = {uj | j ∈ L, j ≤ i}, and B = Bn. By construction of L, each Bi, and
hence B, is independent. Let Qmax be a coefficient Q witnessing equation (1) for
the matrix B.
12
Example 5. (running example) To illustrate our procedure, we consider the fol-
lowing well-defined ME constraint system:
0, h(a) + a, b+ h2(a) !ME h(X1) + h
2(X2)
0, h(a) + a, b+ h2(a), X1 + h(X2) !ME X1 + a
0, h(a) + a, b+ h2(a), X1 + h(X2), h(X1) + h(a) !ME h(X1) + h
2(X2) +X1 + a
We have u1 = (h, h2), u2 = (1, 0) and u3 = (1 + h, h2). The algorithm returns
L = {1, 2} and we obtain Qmax = det(u1,u2) = h2.
Lemma 8. Let C = {t1, . . . , tn+i−1 !ME ui}i=1,...,k be a well-defined and factor-
preserving ME constraint system. Then for every i ≤ k and s ∈ NSt(tn+i−1) the
set {s} ∪ Bi−1 is dependent.
Example 6. Consider the following constraint system :
0, a !ME X1 +X2
0, a, b !ME X1
0, a, b, 〈h(X1), a〉+ 〈h(X2), a〉 !ME a+ b
This system is well-defined and factor-preserving. We have L = {1, 2}, u1 =
(1, 1) and u2 = (1, 0). We have NSt(〈h(X1), a〉 + 〈h(X2), a〉) = {〈h(X1), a〉 +
〈h(X2), a〉;h(X1);h(X2)}. The sets {(1, 1), (1, 0), (0, 0)}, {(1, 1), (1, 0), (h, 0)} and
{(1, 1), (1, 0), (0, h)} are dependent.
If we omit the second constraint, we obtain L = {1} and for instance the
sets {(1, 1), (h, 0)} is independent. However, note that such a constraint system
is not well-defined as witnessed by the substitution θ : Xi %→ Xi +W .
7.3 Reducing the Signature
We will show in Lemma 9 that we can reduce the satisfiability of ME constraint
systems to the satisfiability of ME constraint systems over a signature consisting
only of +, h, and a set of constants.
If ρ : M → N is a replacement, that is a bijection between two finite sets
of terms M and N , then we denote for any term t by tρ the term obtained
by replacing in t any top-most occurrence of a subterm s ∈ M by sρ. This
extends in a natural way to constraint systems, and to substitutions by setting
x(σρ) = (xσ)ρ for all variables x ∈ dom(σ).
Lemma 9. Let C be a well-defined factor-preserving ME constraint system and
F = FactE(C)\X . Let F0 be a set of new constant symbols of the same cardinality
as F and ρ : F → F0 a bijection.
1. Cρ is well-defined.
2. vars(Cρ) = vars(C).
3. If C has a non-collapsing solution then Cρ has a F0 ∪ {h,+}-solution.
4. If Cρ has a F0 ∪ {h,+}-solution then C has a solution.
13
7.4 Solving ME Constraint Systems over {h,+} ∪ F0
We may by Lemma 7 assume that we have a factor-preserving ME constraint
system. By Lemma 9 satisfiability of such a system can be reduced to satisfia-
bility of a ME constraint system over a signature {h,+}∪F0 where F0 is a finite
set of constants. Satisfiability of such an ME constraint system C is equivalent
to the satisfiability of the following system S of equations between terms.
z[1, 1]1 t1 + . . .+ z[1, n]1 tn = u1
z[2, 1]1 t1 + . . .+ z[2, n]1 tn + z[2, n+ 1]1 tn+1 = u2
...
z[p, 1]1 t1 + . . .+ z[p, n]1 tn + . . .+ z[p, n+ p− 1]1 tn+k−1 = uk
The variables z[i, j], called context variables, take their value in Z/2Z[h]. Let
Z = {z[i, j] | 1 ≤ i ≤ k, 1 ≤ j ≤ n+ i− 1}. The ui’s and ti’s are terms that are
not necessarily ground.
Example 7. (running example) For sake of clarity we omit the contexts associ-
ated to 0 and we note t1 = h(a) + a and t2 = b+ h2(a).
z[1, 1]1 t1 + z[1, 2]1 t2 = h(X1) + h2(X2)
z[2, 1]1 t1 + z[2, 2]1 t2 + z[2, 3]1 (X1 + h(X2)) = X1 + a
z[3, 1]1 t1 + z[3, 2]1 t2 + z[3, 3]1 (X1 + h(X2)) + z[3, 4]1 (h(X1) + h(a))
= h(X1) + h2(X2) +X1 + a
Definition 11. Let C be a well-defined ME constraint system over the signature
{h,+} ∪F0 and S(C) be the system of equations obtained from C. A solution to
S(C) is a couple (ρ : Z %→ Z/2Z[h], θ : vars(C) %→ T ({h,+} ∪ F0)) such that all
the equations of S(C)ρθ are satisfied.
We split the context variables Z in two parts, those which stem from L and
the others. More formally, ZL = {z[i, j] | i ∈ L and 1 ≤ j < n + i}.Note that
the variables of Z are totally ordered by the lexicographic order of the indices
of variables, that is z[i, j] ≺ z[i′, j′] iff i < i′, or else i = i′ and j < j′.
The following Lemma is the crucial point in the proof of Lemma 11.
Lemma 10. Let S(C) be a system of equations obtained from a well-defined ME
constraint system C over the signature {h,+} ∪ F0. If S(C) has a solution then
there exists σ a solution to S(C) such that for all z ∈ ZL, 0 ≤ zσ < Qmax.
Lemma 11. Given C a well-defined MEconstraint system. It is decidable whether
S(C) has a solution.
Example 8. (running example) Thanks to Lemma 10, we know that z[1, 1],
z[1, 2], z[2, 1], z[2, 2] and z[2, 3] are bounded by h2, the value of Qmax. We choose
14
ρ1 = {z[1, 1] %→ 0; z[1, 2] %→ h; z[2, 1] %→ h+1; z[2, 2] %→ 1; z[2, 3] %→ 0}. We do the
replacement on the two first equations:
h1 (b+ h2(a)) = h(X1) + h2(X2)
(h+ 1)1 (h(a) + a) + 11 (b+ h2(a)) = X1 + a
This completely determines the value of X1 and X2: θ = {X1 %→ b,X2 %→ h(a)}.
Lastly, we can apply the substitution θ on the third equation to obtain:
z[3, 1]1 (h(a) + a) + z[3, 2]1 (b+ h2(a)) + z[3, 3]1 (b+ h2(a))+
z[3, 4]1 (h(b) + h(a)) = h(b) + h3(a) + b+ a
We can decide whether there exists a solution by solving the following system
of linear equations over Z/2Z[h]. Notice that u3 = u1 + u2, hence there is a
solution ρ2 = {z[3, 1] %→ h + 1; z[3, 2] %→ h + 1; z[3, 3] %→ 0; z[3, 4] %→ 0} and
(ρ1 ∪ ρ2, θ) is a solution to the system of equations described in Example 7.
8 Main Result
Theorem 2. Satisfiability of a well-defined constraint system C is decidable in
presence of the equational theory ACUNh.
Proof. The procedure described along the paper is sound and complete. Let C
be a well-defined constraint system.
Soundness: Let C1 be some factor-preserving ME constraint system obtained
by applying the first part of our procedure on C. Thanks to Lemma 5 and 6, C1
is well-defined since C is well-defined. Let C2 be the constraint system obtained
from C1 by replacing all factors by different constants. C2 is well-defined thanks
to Lemma 9. Assume that S(C2) (the system of equations associated to C2) has
a solution. We easily deduce that C2 has a solution, hence by Lemma 9 that C1
has a solution, and by Lemma 5 and 6 that C has a solution.
Completeness: Assume that σ is a solution to C. Thanks to Lemma 2, we can
assume that σ is conservative w.r.t. C. Let C ′ be the finite set of well-defined
one-step constraint systems obtained by applying the algorithm described in
Figure 2 on C. By Lemma 5, we know that there exists C ′ ∈ C ′ such that σ is
a conservative solution of C ′. By Lemma 6, we know that there exists Cθ a well-
defined ME constraint system which has a non-collapsing solution. Hence, Cθ is
factor-preserving due to Lemma 7. By Lemma 9, Cρθ has solution over {+, h}∪F0
Then, Lemma 11 allows us to conclude. "
9 Example: TMN’s Protocol
We illustrate our constraint solving technique by applying it to a protocol due
to Tatebayashi, Matsuzaki and Newman (TMN) [TMN89].
15
9.1 Description
The TMN protocol is a symmetric key distribution protocol involving three
participants and four exchanges of messages4. The only trusted key is the public
key of the server S.
1. A→ S : A,B, {Ka}pub(S)
2. S → B : A
3. B → S : B,A, {Kb}pub(S)
4. S → A : B,Kb ⊕Ka
When the agent A wants to communicate with B, he chooses a key Ka,
encrypts it, and sends it to the server S (msg 1). The server sends a message
to B informing that A wants to communicate with him (msg 2). B chooses a
key Kb, encrypts it, and sends it to S (msg 3). The server forms the Vernam
encryption of the two keys Ka and Kb, and returns this message to A (msg 4).
Now, knowing Ka ⊕Kb and Ka, A can retrieve the session key Kb. To prevent
replay attacks, the server S verifies that the keys Ka and Kb have not been used
in previous sessions.
The protocol employs two kind of encryptions: the standard asymmetric en-
cryption and the Vernam encryption. In the first encryption scheme, everyone
who knows m can produce {m}pub(S), but only the server knows how to decrypt
such a ciphertext. This can be achieved by using RSA encryption. The Vernam
encryption, denoted ⊕, simply consists in applying the exclusive or operator on
the message and the key.
In [TMN89], an attack on the protocol, due to Simmons, was described. The
attack makes use of the fact that if the asymmetric encryption is implemented
using RSA, then we have the following homomorphic property:
{x× y}pub(S) = {x}pub(S) × {y}pub(S)
where × represents multiplication modulo the public modulus.
The attack presented in [Sim94] is based on the fact that the intruder can
eavesdrop the message {Kb}pub(S) exchanged between A and B during a normal
session of the protocol. The intruder I can fool the server during a new session
to obtain Kb. Firstly, I sends {Ki}pub(S), then he sends {Ki}pub(S) × {Kb}pub(S)
which is equal to {Ki ×Kb}pub(S) thanks to the homomorphism property. The
server thinks that it is a fresh key and plays the rest of the protocol. In particular,
he sends (Ki × Kb) ⊕ Ki to I. The intruder, knowing Ki can retrieve Kb, the
session key established during a previous session between two honest agents A
and B. Note that the simple attack consisting in replaying {Kb}pub(S) at step 1
does not work since it is assumed that S can detect keys that have already been
used in previous sessions.
4 For sake of notations, we often omit the pairing function symbol 〈 , 〉.
16
9.2 Modeling
In the remainder, we are going to use the homomorphism function symbol h to
model RSA encryption with the public key of S. The fact that the decryption key
of the server S is a trusted key is take into account by the fact that the intruder
can not obtain m from h(m). In our model, we can not model the fact that the
homomorphism is over a multiplication, i.e. an Abelian group operator. It is for
this that we choose to model it by an homomorphism over ⊕. This operator
satisfies more algebraic properties, hence this abstraction could find some non
realistic attacks. Lastly, in the constraint solving model, we can not deal with
the test perform by the server to detect keys that have already been used in
previous sessions. Hence, we simply omit it. For sake of clarity, we restrict the
number of constraints by considering the minimum needed to retrieve the attack
due to Simmons.
During the first session, the attacker eavesdrops the communication network
to increase his initial knowledge T0 = {A,B,C, S, I, h(Kb), h(Ka),Ki}. The in-
truder knows the identity of the agents, the two ciphertexts he has seen on the
network during the execution of the first session and the key Ki that he shares
with his accomplice. Now, we are going to write the constraint system corre-
sponding to the execution of the session in which I sends his two requests to the
server S. The constraint system obtained is the following one:
C :=


T0 ! Xa, Xb, h(Ya) S receives a request from I
T1 := T0, S,Xa S answers the request to Xb
T1 ! Xb, Xa, h(Yb) S receives the answer of Xb
T2 := T1, S,Xb, Ya ⊕ Yb S answers the request to I
T2 ! Kb the secret Kb is revealed
9.3 Constraint Solving
First, we guess a subset of StE(C), we split this set in three subsets S0, S1
and S2 and we order the terms in each subset. We have S0 = {Xa, Xb, h(Ya)}
S1 = {Yb, h(Yb)} and S2 = {Kb}. The non-deterministic algorithm of Figure 2
apply on C with the choices described above, returns the following set of one-step
constraints.
C′ :=


T0 !1 Xa T1, S0 !1 Yb
T0, Xa !1 Xb T1, S0, Yb !1 h(Yb)
T0, Xa, Xb !1 h(Ya) T1, S0, Yb, h(Yb) !1 Xb, Xa, h(Yb)
T0, Xa, Xb, h(Ya) !1 Xa, Xb, h(Ya) T2, S0, S1 !1 Kb
Then, we guess an equivalence relation R on StE(C′)
R = {Xa = I;Xb = C;Yb = Ki;Kb = Ya ⊕ Yb}.
This equivalence relation represents a unification problem modulo ACUNh. There
are finitely many most general unifiers. One of them is:
θ = {Xa %→ I;Xb %→ C;Yb %→ Ki;Ya %→ Kb ⊕Ki}.
17
Lastly, we apply θ on C′. For each constraint T !1 u ∈ C′, we have that uθ
is one-step deducible from Tθ. The system of ME constraints obtained is empty,
hence satisfaisable.
10 Conclusion
Our procedure generalizes previous works on the verification of protocols that
involve the exclusive or operation [CKRT03,CLS03]. Our solution for solving ME
constraints is general enough to hold in other similar equational theories since it
relies on general algebraic concepts. For instance, unification in Abelian groups
with homomorphism has been shown to be finitary by Baader [Baa93] with the
help of Gro¨bner bases. Therefore, our approach should extend to that case, thus
generalizing the result [MS05]. Apart from the extension to Abelian groups, a
future line of research is to study the complexity of the procedure. Contrary to
the results obtained in the empty theory [RT03], there is little hope to get an NP-
procedure: the similarity between ACUNh unification and AC unification leads to
conjecture that there are exponentially many minimal unifiers and that the size of
a minimal unifier may be exponential. Since unifiers are explicitly applied during
the resolution of deducibility constraints, this would result in an exponential blow
up. Another open question is the case of an encryption algorithm distributing
over the exclusive or. Although the case of a passive intruder is decidable in this
framework [LLT05b], the case of an active intruder seems quite intricate since it
amounts to having an infinite number of distinct homomorphisms (one for each
term used as a key in the encryption algorithm).
References
[Baa93] F. Baader. Unification in commutative theories, Hilbert’s basis theorem and
Gro¨bner bases. Journal of the ACM, 40(3):477–503, 1993.
[BC96] A. Boudet and H. Comon. Diophantine equations, Presburger arithmetic
and finite automata. In Proc. Coll. on Trees in Algebra and Programming
(CAAP’96), volume 1059 of LNCS, pages 30–43. Springer, 1996.
[BG00] A. Blumensath and E. Gra¨del. Automatic structures. In Proc. 15th IEEE
Symposium on Logic in Computer Science (LICS’00), pages 51–62, Santa
Barbara, California, USA, 2000. IEEE Comp. Soc. Press.
[BS96] Franz Baader and Klaus U. Schulz. Unification in the union of disjoint equa-
tional theories: Combining decision procedures. J. Symbolic Computation,
21:211–243, 1996.
[CD05] H. Comon-Lundh and S. Delaune. The finite variant property: How to get
rid of some algebraic properties. In Proc. 16th International Conference on
Rewriting Techniques and Applications (RTA’05), volume 3467 of LNCS,
pages 294–307, Nara (Japan), 2005. Springer.
[CDG+97] H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S. Tison,
and M. Tommasi. Tree automata techniques and applications. Available
on: http://www.grappa.univ-lille3.fr/tata, 1997.
18
[CDL05] V. Cortier, S. Delaune, and P. Lafourcade. A survey of algebraic properties
used in cryptographic protocols. Journal of Computer Security, 2005. To
appear.
[CGS97] R. Cramer, R. Gennaro, and B. Schoenmakers. A secure and optimally
efficient multi-authority election scheme. In Proc. International Confer-
ence on the Theory and Application of Cryptographic Techniques (EURO-
CRYPT’97), volume 1233 of LNCS, pages 103–118, Konstanz, Germany,
1997.
[CKRT03] Y. Chevalier, R. Ku¨sters, M. Rusinowitch, and M. Turuani. An NP deci-
sion procedure for protocol insecurity with XOR. In Proc. of 18th Annual
IEEE Symposium on Logic in Computer Science (LICS’03), pages 261–270,
Ottawa (Canada), 2003. IEEE Comp. Soc. Press.
[CL04] H. Comon-Lundh. Intruder theories (ongoing work). In Proc. 7th Inter-
national Conference on Foundations of Software Science and Computation
Structures (FOSSACS’04), volume 2987 of LNCS, pages 1–4, Barcelona
(Spain), 2004. Springer.
[CLS03] H. Comon-Lundh and V. Shmatikov. Intruder deductions, constraint solving
and insecurity decision in presence of exclusive or. In Proc. of 18th Annual
IEEE Symposium on Logic in Computer Science (LICS’03), pages 271–280,
Ottawa (Canada), 2003. IEEE Comp. Soc. Press.
[CLT03] H. Comon-Lundh and R. Treinen. Easy intruder deductions. In Verification:
Theory & Practice, Essays Dedicated to Zohar Manna on the Occasion of
His 64th Birthday, volume 2772 of LNCS, pages 225–242. Springer, 2003.
[CR05] Y. Chevalier and M. Rusinowitch. Combining intruder theories. In Proc.
32nd International Colloquium on Automata, Languages and Programming
(ICALP’05), volume 3580 of LNCS, pages 639–651, Lisbon (Portugal), 2005.
Springer.
[Del05] Ste´phanie Delaune. Easy intruder deduction problems with homomor-
phisms. Information Processing Letters, 2005. To appear.
[Dic13] L. Dickson. Finiteness of the odd perfect and primitive abundant numbers
with n prime factors. American Journal Mathematical Society, 35:413–422,
1913.
[DJ04] S. Delaune and F. Jacquemard. A decision procedure for the verification
of security protocols with explicit destructors. In Proc. 11th ACM Confer-
ence on Computer and Communications Security (CCS’04), pages 278–287,
Washington, D.C., USA, 2004. ACM Press.
[DLMS99] N. Durgin, P. Lincoln, J. Mitchell, and A. Scedrov. Undecidability of
bounded security protocols. In Proc. Workshop on formal methods in secu-
rity protocols, Trento, Italy, 1999.
[DY81] D. Dolev and A.C. Yao. On the security of public key protocols. In Proc.
of the 22nd Symp. on Foundations of Computer Science, pages 350–357,
Nashville (USA, Tennessee, 1981. IEEE Comp. Soc. Press.
[GNW00] Q. Guo, P. Narendran, and D. A. Wolfram. Complexity of nilpotent unifica-
tion and matching problems. Information and Computation, 162(1-2):3–23,
2000.
[KKS87] E. Kaltofen, M. S. Krishnamoorthy, and B. D. Saunders. Fast parallel com-
putation of Hermite and Smith forms of polynomial matrices. SIAM Journal
of Algebraic and Discrete Methods, 8(4):683–690, 1987.
[LLT05a] P. Lafourcade, D. Lugiez, and R. Treinen. Intruder deduction for AC-like
equational theories with homomorphisms. In Proc. 16th International Con-
19
ference on Rewriting Techniques and Applications (RTA’05), volume 3467
of LNCS, pages 308–322, Nara (Japan), 2005. Springer.
[LLT05b] P. Lafourcade, D. Lugiez, and R. Treinen. Intruder deduction for the equa-
tional theory of exclusive-or with distributive encryption. Research Report
LSV-05-19, Laboratoire Spe´cification et Ve´rification, ENS Cachan, France,
2005.
[Low96] G. Lowe. Breaking and fixing the Needham-Schroeder public-key protocol
using FDR. In Proc. 2nd International Workshop on Tools and Algorithms
for the Construction and Analysis of Systems (TACAS’96), volume 1055 of
LNCS, pages 147–166, Berlin (Germany), 1996. Springer.
[McA93] D. A. McAllester. Automatic recognition of tractability in inference rela-
tions. Journal of the ACM, 40(2):284–303, 1993.
[MS05] J. Millen and V. Shmatikov. Symbolic protocol analysis with an abelian
group operator or Diffie-Hellman exponentiation. Journal of Computer Se-
curity, 13(3):515 – 564, 2005.
[Nar96] P. Narendran. Solving linear equations over polynomial semirings. In Proc.
11th Annual IEEE Symposium on Logic in Computer Science (LICS’96),
pages 466–472, New Brunswick, New Jersey, 1996. IEEE Comp. Soc. Press.
[NS78] R. Needham and M. Schroeder. Using encryption for authentification in
large networks of computers. Communications of the ACM, 21(12):993–999,
1978.
[RT03] M. Rusinowitch and M. Turuani. Protocol insecurity with a finite number
of sessions, composed keys is NP-complete. Theoretical Computer Science,
1-3(299):451–475, 2003.
[Sim94] G.J. Simmons. Cryptoanalysis and protocol failures. Communications of
the ACM, 37(11):56–65, 1994.
[TMN89] M. Tatebayashi, N. Matsuzaki, and D. B. Newman. Key distribution pro-
tocol for digital mobile communication systems. In Proc. 9th Annual Inter-
national Cryptology Conference (CRYPTO’89), volume 435 of LNCS, pages
324–333, Santa Barbara (California, USA), 1989. Springer.
20
Appendix A Conservative Solutions
Definition 12. (decomposed) Let P be a proof of T * u. We say that a standard
term v is decomposed in P if:
– either v = 〈u1, u2〉 and P contains an instance of (UL) or (UR) whose
premise is labeled with T * 〈u1, u2〉.
– or v = {u1}u2 and P contains an instance of (D) whose premises are labeled
with T * {u1}u2 and T * u2.
The following proposition has been proved in [RT03] for the standard Dolev-
Yao model. The proof of [RT03] can be transferred in a straightforward way to
our intruder model which comprises in addition to the standard rules the rule
(ME). It will be used in Lemma 2 to ensure the existence of a proof of T * u
which respects some conditions.
Proposition 2. Let P be a proof of T * u and P ′ be a minimal proof of T * γ.
Moreover, assume that P ′ ends with an instance of (C). Then, there exists a
proof of T * u in which γ is never decomposed.
Proof. The proof can be done by induction on the number of instances of infer-
ence rules in P which decompose γ. Base case: If there is no such an instance,
then P is the expected proof. Assume there are n+1 instances of inference rules
in P which decompose γ. We can distinguish two cases depending on the fact
that γ is a pair (i.e. 〈γ1, γ2〉) or a ciphertext (i.e. {γ1}γ2). In the first case, this
means that there exists an instance of (UL) (or (UR)) whose premise is 〈γ1, γ2〉
and conclusion is γ1 (or γ2). From P ′, we can easily extract a proof P1 of T * γ1
(resp. P2 of T * γ2). Note that P1 (resp. P2) does not decompose γ by minimal-
ity of P ′. Hence, such a proof can be plugged to replace the subproof of T * γ1
(resp. T * γ2) in P which decompose γ. The second case where γ = {γ1}γ2 is
similar. We obtain a proof of T * u which contains less instances of inference
rules which decompose γ than P . Hence we can apply the induction hypothesis
to conclude. "
Remember that we consider implicitly that terms are kept in normal forms,
hence we write uσ instead of uσ ↓.
Lemma 2. Let C be a well-defined constraint system. If there exists a solution σ
to C then there exists a conservative one.
Proof. We assume given a linear well-founded ordering ≺ on standard terms of
T (F ,X ) such that the constant 0 is minimal w.r.t. ≺. We shall use below the
multi-set extension 6 of ≺ to multi-sets of standard ground terms. For sake of
notation, given two solutions σ1 and σ2 of a constraint system, we write σ1 6 σ2
if and only if FactE(img(σ1))6 FactE(img(σ2)). Let σ be a minimal (w.r.t. 6)
solution to C.
21
We reason by contradiction to show that σ is conservative w.r.t. C. Assume
that there exists x ∈ vars(C) and vx ∈ FactE(xσ) such vx .∈ (StE(C) \ vars(C))σ
i.e. for all t ∈ T (F ,X )\X with tσ =E vx, we have t /∈ StE(C). We will show that
under this condition there exists a smaller solution σ′ of C. Let C = {C1, . . . , Ck}
and for each i ≤ k, let Ti ! ui be the constraint Ci and Ciσ be the constraint
obtained from Ci by instantiating (and normalizing) all the terms with σ.
Fact 1 If vx ∈ StE(sσ) for some s ∈ Ti (i ≤ k), then there exists j < i such
that vx ∈ StE(ujσ).
We show this result by contradiction. Assume that vx ∈ StE(sσ) for some s ∈ Ti
(i ≤ k), and that for all j < i, we have vx .∈ StE(ujσ). Let z be a fresh variable,
and ρ be the replacement {vx %→ z}. Let θ := σρ. We are going to show that
Cθ is not well-formed, leading to a contradiction with the fact that C is well-
defined. Firstly, since vx .∈ (StE(C) \ vars(C))σ, we have (Cσ)ρ = C(σρ) (= Cθ).
By hypothesis, vx ∈ StE(Tiσ), hence z ∈ vars(Tiθ). However, for all j < i, we
have z .∈ vars(ujθ) since vx .∈ StE(ujσ).
This allows us to define: m = min{j
∣∣ vx ∈ StE(ujσ)}.
Fact 2 There exists P ′ a proof of Tmσ * vx which ends with an instance of (C).
By hypothesis, there exists a minimal proof P of Tmσ * umσ. Firstly, we show
that there exists in P a node labeled with Tmσ * vx. If P contains a node labeled
by Tmσ * vx, then it is the expected node. Otherwise, we can find recursively a
path in P , from the root up to one leaf, where every node which is labeled by
Tmσ * u is such that vx ∈ StE(u). Thanks to Fact 1, the existence of such a path
leads to a contradiction with the minimality of m. Secondly, by definition of m
and thanks to Lemma 1 (locality lemma), the subproof P ′ of P labeled with
Tmσ * vx can not be a decomposition proof (otherwise vx ∈ StE(Tmσ)). Since
vx is necessarily a standard term, this implies that P ′ ends with an instance
of (C).
Now, we let δ be the replacement {vx %→ 0}. We will show that σ′ := σδ is
also a solution of C, which is a contradiction since σ′ 6 σ (vx is a standard term
since it is a factor, hence 0 ≺ vx). For this purpose, we have to build a proof of
each Ciσ′, i ≤ l. We distinguish two cases.
1. Case i < m: By definition of m, vx /∈ StE(Ciσ). In this case, (Ciσ)δ = Ciσ =
Ciσ′, i.e. σ′ is a solution to Ci.
2. Case i ≥ m: In the remainder, we are going to show that σ′ = σδ is also a
solution to Ci = Ti ! ui.
Firstly, we may note that Ci(σδ) = (Ciσ)δ since by hypothesis vx .∈ (StE(C)\
vars(C))σ. By hypothesis σ is a solution to Ci, this means that we have a proof
P of Tiσ * uiσ. Moreover, Fact 2 ensures the existence of a proof of Tiσ * vx
which ends with (C) in P . σ′ is a solution of Ci, it is obvious for i = m and we
22
extend the result for i > m by well-definedness of C (stability by any substitution
that C is well-formed). Now, we can apply Proposition 2 to obtain a proof Pi of
Tiσ * uiσ in which vx is never decomposed. We shall build from Pi a proof P ′i
of (Tiσ)δ * (uiσ)δ by replacing every subtree ended by
Tiσ * v1 . . . Tiσ * vn
(C)
Tiσ * vx
with a leaf labeled with Tiσ * vx and then by applying δ to every term of the
tree obtained.
Fact 3 P ′i is a proof of (Tiσ)δ * (uiσ)δ.
To prove this, we have to show that for every node in P ′i labeled with Tiσδ * v0
and with n sons labeled respectively by Tiσδ * v1, . . . Tiσδ * vn, the inference
Tiσδ * v1 . . . Tiσδ * vn
Tiσδ * v0
is an instance of an inference rule of Figure 1.
We distinguish several cases:
– If the inference is a leaf added by the replacement of an instance of (C) in
the construction of P ′i given above, then we have v0 = 0, hence v0 ∈ Tiσδ.
– If the inference is not a leaf added by the replacement, then we have a “corre-
sponding” inference in Pi. This means that there exists
Tiσ * u1 . . . Tiσ * un
Tiσ * u0
an inference step in Pi such that vi = uiδ for each 0 ≤ i ≤ n. Since, by con-
struction of P ′i we know that vx is never decomposed in Pi and the conclusion
of an instance of (C) can not be vx, we can show by case analysis on the
inference rule, that when we apply δ on the inference above, we retrieve an-
other instance of the same inference rule. "
Proposition 3. Let t be a term and σ a substitution. We have:
StE(tσ) ⊆ StE(t)σ ∪
⋃
x∈vars(t)
StE(xσ)
Proof. This can be easily proved by structural induction on t. If t is a constant
or a variable, it is obvious. Now, assume that t is a standard term, i.e. t =
f(t1, . . . , tn) with f ∈ F \ sig(E). We have:
StE(tσ) = {tσ} ∪
⋃n
i=1 StE(tiσ)
⊆ {tσ} ∪
⋃n
i=1 (StE(ti)σ ∪
⋃
x∈vars(ti)
StE(xσ)) by induction hypothesis
⊆ StE(f(t1, . . . , tn)σ) ∪
⋃
x∈vars({t1,...,tn}
StE(xσ))
⊆ StE(t)σ ∪
⋃
x∈vars(t) StE(xσ)
Lastly, if t is not a standard term, then we have t = C[t1, . . . , tn] for some
standard terms t1, . . . , tn and an E-context C, and we can do the same reasoning
as before. "
Obviously, the proposition above can be extended to any set of terms. Note,
however, that the inclusion may be strict.
23
Example 9. Let t = x + y and σ = {x %→ a; y %→ a}. We have StE(tσ) = {0}
whereas StE(t)σ ∪ StE({xσ, yσ}) = {0, a}.
Lemma 3. Given a conservative solution σ of C = {C1, . . . , Ck}. For each
i ≤ k, there exists a proof Pi of Ciσ which involves only terms in StE(C)σ.
Proof. Thanks to Lemma 1 (locality lemma), for each i there exists Pi a minimal
proof of Tiσ * uiσ which only involves terms in StE(Cσ). Thanks to Proposi-
tion 3, we have StE(Cσ) ⊆ StE(C)σ ∪
⋃
x∈vars(C) StE(xσ). Hence, we have:
StE(Cσ) ⊆ StE(C)σ ∪
⋃
x∈vars(C) StE(xσ)
⊆ (StE(C) \ vars(C))σ ∪
⋃
x∈vars(C) StE(xσ)
⊆ S¯ (C)σ since σ is conservative w.r.t. C
where S¯ (C) = {C[t1, . . . , tn]
∣∣ ∀i. ti ∈ StE(C)\vars(C) and C is an E-context}
Let
Tiσ * u1 . . . Tiσ * un
Tiσ * u0
be an inference in Pi which is an instance of some
rule other than (ME). We can easily show that for all j ∈ {0, . . . n}, uj ∈ StE(C)σ.
Now, we have to deal with the instance of (ME). By minimality of Pi, an instance
of a rule (ME) can not be followed by another instance of (ME) (we could oth-
erwise merge the two instances). Hence, for each premise Tiσ * u of an instance
of (ME),
– either Tiσ * u is the conclusion of an instance of another inference rule
than (ME),
– or we have u ∈ Tiσ.
We have also that, the conclusion Tiσ * u of an instance of (ME) is:
– either the premise of an instance of another inference rule than (ME),
– or we have u = uiσ.
Hence we conclude, that there exists a proof Pi of Tiσ * uiσ that involves only
terms in StE(C)σ. "
Appendix B ACUNh Unification
For a signature Σ consisting of constants, an ACUN symbol + and a homo-
morphism h, the problem of deciding whether two terms are unifiable has been
proved decidable in [Nar96]. Baader gives an algorithm for the unification of
several equational theories that involve homomorphism, for instance Abelian
groups [Baa93]. These algorithms rely on Gro¨bner bases and are hard to study
from the complexity point of view. Therefore we provide a simpler algorithm for
the theory ACUNh which generalizes the procedure of [Nar96]. This algorithm
provides a finite complete set of unifiers in the signature Σ and it is very close to
24
the classical AC-unification algorithm, which should allow a precise complexity
analysis. Then we show that unification with constant restriction (see [BS96] for
details) is finitary. This allows us to use the combination algorithm described
in [BS96] to get an algorithm that computes a finite complete set of unifiers in
Σ augmented with free symbols.
In this Appendix, Σ denotes {+, h, c1, . . . , cm}. Our solution for computing
a finite complete set of unifiers for a unification problem in Σ follows the same
lines as the classical approach for AC-unification.
Appendix B.1 Solution to Linear Diophantine Equations in Z/2Z[h]
Let (E) be a system of equations of the following form:
A1,1.X1 + . . .+ A1,n.Xn = B1
. . .
Am,1.X1 + . . .+Am,n.Xn = Bm
where the Ai,j ’s, Bj ’s are polynomials in Z/2Z[h], and the unknowns are instan-
tiated by polynomials in Z/2Z[h]. The homogeneous system (H) associated to
(E) is obtained by replacing all Bj ’s by 0.
Fact 4 A solution to (E) is the sum of a solution to (E) and of a solution
to (H).
Proof. The difference of two solutions to (E) is a solution to (H). "
To a polynomial P (h) =
∑i=n
i=0 bih
i with bi ∈ {0, 1}, we associate the number
nb(P ) whose representation in base 2 is bn . . . b0. This correspondence is one-one.
We define a total ordering < on polynomials in Z/2Z[h] by P < P ′ if and only
if nb(P ) < nb(P ′). This is a total Noetherian ordering (no infinite decreasing
sequence exists). Given a (finite or infinite) set of polynomials S, an element
P ∈ S is minimal if there is no element P ′ ∈ S such that P ′ < P . For a tuple of
polynomials P = (P1, . . . , Pn), we define Nb(P ) as (Nb(P1), . . . , Nb(Pn)). The
ordering < is extended component-wise, yielding a partial order on tuples of
polynomials. From now on, less than, minimal,.. are defined with respect to this
ordering.
Fact 5 The number of minimal non-null solutions to a system of equations (E)
is finite.
Proof. We recall the classical Dickson’s lemma [Dic13]: every infinite sequence
of distinct tuples of natural numbers contains at least two (actually infinitely
many) comparable tuples. A non-null solution to (E) is a tuple of polynomials.
Let us assume that the number of minimal non-null solutions to (E) is infinite.
This yields a sequence T1,T2, . . . of distinct incomparable tuples of polynomials.
Therefore we would have an infinite sequence of incomparable tuples of natural
numbers Nb(T1), Nb(T2), . . ., contradiction. "
25
Since the sum of two solutions to (H) is a solution to (H), we have that a
(non-null) solution to (H) is a linear combination of (non-null) minimal solutions
to (H). This justifies the next fact:
Fact 6 A solution to (E) is the sum of a minimal solution to (E) and of a linear
combination of the minimal solutions to (H).
Appendix B.2 ACUNh Unification is finitary for Σ
Fact 7 Unification in ACUNh is finitary.
The rest of this section is devoted to the proof of this result. A unification
problem is equivalent to an equation5:
i=n∑
i=1
Ai 1Xi = B
where the Ai’s are constant polynomials, and B = Σmi=1Bi1ci with Bi a constant
polynomial, i = 1, . . . , n. Each variable Xi can be written Σ
j=m
j=1 Xi,j 1 cj where
Xi,j are unknown polynomials of Z/2Z[h] for j = 1, . . . ,m.
The unification problem is equivalent to the following system of linear Dio-
phantine equations (E) over Z/2Z[h]:
A1.X1,1 + . . .+ An.Xn,1 = B1
. . .
A1.X1,m + . . .+An.Xn,m = Bm
Example 10. let Σ = {h,+, c1, c2}. Let s = h(X1) + X2 + h(c1) and t = X1 +
h2(X2) + c2 be two terms, then the unification of s and t amounts to solving
h(X1) +X2 + h(c1) = X1 + h2(X2) + c2
i.e. h(X1) +X1 + h2(X2) +X2 = h(c1) + c2
By writing X1 = X1,1 1 c1 + X1,2 1 c2, X2 = X2,1 1 c1 + X2,2 1 c2, this is
equivalent to:{
h.X1,1 +X1,1 + h2.X2,1 +X2,1 = h
h.X1,2 +X1,2 + h2.X2,2 +X2,2 = 1
i.e
{
(h+ 1).X1,1 + (h2 + 1).X2,1 = h
(h+ 1).X1,2 + (h2 + 1).X2,2 = 1
Each solution to (E) is the sum of a minimal solution to (E) and of a solution
to the associated homogeneous system (H). Given a solution X1,1, . . . , Xn,m of
(E), we derive a solution X1 = Σ
j=m
j=1 X1,j 1 cj , . . . , Xn = Σ
j=m
j=1 Xn,j 1 cj of the
unification problem. This means that a solution X1, . . . , Xn of the unification
problem can be written X1 = X
µ
1 +X
h
1 , . . . , Xn = X
µ
n +X
h
n , where (X
µ
1 , . . . , X
µ
n)
is derived from a minimal solution to (E) and (Xh1 , . . . , X
h
n) is derived from a
solution to (H). Therefore (Xh1 , . . . , X
h
n) is a solution to the unification problem
Σi=ni=1Ai 1Xi = 0.
5 for simplicity, we consider only one equation, but the algorithm for a finite set of
equations is similar
26
What remains to do is to compute a complete finite set of unifiers of this
unification problem from the set of minimal solutions to the equation A1X1 +
. . . + AnXn = 0 in Z/2Z[h]. Given a tuple e = (*1, . . . , *n) of polynomials of
Z/2Z[h], and a variable U , we denote by e1 U the tuple (*1 1 U, . . . , *n 1 U).
Fact 8 (X1, . . . , Xn) is a solution to the unification problem Σi=ni=1Ai 1Xi = 0
if and only if (X1, . . . , Xn) = Σi∈Iei 1 Ui with I ⊆ {1, . . . , p}, U1, U2, . . . fresh
variables.
Proof. (⇒) Let (X1, . . . , Xn) be a solution to the unification problem Σi=ni=1Ai1
Xi = 0. We write Xi = Σi=mi=1 Xi,j 1 cj and we get that Σ
i=n
i=1Ai.Xi,j = 0 for
j = 1, . . . ,m. Therefore each element of the sequence X1,j , . . . , Xn,j is a linear
combination of the ei’s, i.e. it is an expression Σi∈Iλi,j .ei where λi,j ∈ Z/2Z[h]
for i ∈ I. Hence X1, . . . , Xn = Σ
j=m
j=1 (Σi∈I(λi,j .ei)1 cj) = Σ
i=p
i=1ei 1Ui for some
Ui.
(⇐) Simply decompose Ui as Σi=mi=1 Ui,j1cj and use the fact that ei is a solution
to the equation. "
Since there is a finite number of minimal solutions to (E), an immediate
consequence is that unification is finitary. The last step is to compute the set of
minimal solutions.
Appendix B.3 An Effective Unification Algorithm
What we need is a way to compute the minimal solutions to a system of Dio-
phantine equations (E). One possible approach is to perform algebraic compu-
tations similar to what is done by AC-unification algorithms. Instead, we shall
use an automata-theoretic approach that yields a more general result: the first-
order theory ACUNh is decidable (for the signature Σ) since it is an automatic
structure [BG00]. Then we show how to construct an automaton that accepts
the set of minimal solutions associated to a unification problem. We denote by
FO(≤,+) the first-order theory of the predicate ≤ in the theory ACUNh (for the
signature Σ).
Proposition 4. FO(≤,+) is decidable.
Proof. The proof is similar to the automata-based procedure for deciding Pres-
burger arithmetic, and the reader is referred to [BC96] for details.
Case of a Single Constant. Firstly, we consider the case where Σ contains
only one constant c. Let s, t be ground terms, then there exists polynomials
P = Σi=ki=0aih
i, Q = Σi=li=0bih
i such that s = P (h) 1 c, t = Q(h) 1 c. We define
the relation s ≤ t by P ≤ Q i.e. ak . . . a0 ≤ bl . . . b0 (we compare the binary
representation of two integers). Since s = t is equivalent to s ≤ t ∧ t ≤ s, we
shall consider only the predicate ≤.
Like in the classical automata-based decision procedure for Presburger arith-
metic, we consider automata accepting the representations of tuples of variables
(that we read from the right to the left: b0b1 . . . with a possible addition of
trailing zero’s). The automata described in Figure 3 accept:
27
– all pairs (X,Y ) such that Y ≤ X,
– all triples (X,Y, Z) such that X = Y + Z.
Actually these automata are simpler than the corresponding automata for Pres-
burger arithmetic since there is no carry-over to deal with.
start
„
1
1
«
,
„
1
0
«
,
„
0
0
«
„
0
1
«
„
1
0
«
„
1
1
«
,
„
0
1
«
,
„
0
0
«
Fig. 3. Automata for Y ≤ X.
start
0
@10
1
1
A,
0
@11
0
1
A,
0
@00
0
1
A,
0
@01
1
1
A
Fig. 4. Automata for X = Y + Z.
The automaton accepting the pairs (X,Y ) such that X = h(Y ) is more
complex: it contains two states which remember the previous values of Y . It is
described in Figure 5.
The construction of an automaton accepting the terms X such that X ≤ t for
some ground term t is straightforward. This yields that FO(≤,+) is decidable
if Σ contains only one constant, see [CDG+97] for the description of a similar
procedure in the case of Presburger arithmetic.
Case of an Arbitrary Number of Constants. The generalization to several
constants is straightforward. Let s = Σi=mi=1 Qi(h) 1 ci and t = Σ
i=m
i=1 Pi(h) 1 ci
28
start
Y = 0
Y = 1
„
0
0
«
„
0
1
«
„
1
1
«
„
0
1
«
„
0
0
«
„
1
0
«
Fig. 5. Automaton for X = h(Y )
be two ground terms, Qi, Pi are polynomials in Z/2Z[h]. We define s ≤ t by∧i=m
i=1 Pi ≤ Qi. As in the one constant case, we have s = t if and only if
s ≤ t ∧ t ≤ s. As previously a polynomial P (h) = Σi=li=0bih
i is identified to
the sequence bn . . . b0 and a ground term t is identified to the tuple (of represen-
tations) (P1, . . . , Pn). Therefore the pairs of terms X,Y such that X ≤ Y is rec-
ognized by the automaton which accepts the 2m-tuples X1, . . . , Xm, Y1, . . . , Ym
such that Xi ≤ Yi. This automaton is simply the product of m automata equals
to the first automaton of Figures 3 and 5. The decidability of FO(≤,+) follows
immediately. "
We use this decidability procedure to compute the minimal solutions to a
system of Diophantine equations (E).
Fact 9 The set of minimal solutions to a system of linear Diophantine equations
is computable.
Proof. The unification of two terms leads to a unification problem (U)
i=n∑
i=1
Ai 1Xi = B
which is equivalent to the system of Diophantine equations (E)
A1.X1,1 + . . .+ An.Xn,1 = B1
. . .
A1.X1,m + . . .+An.Xn,m = Bm
where Xi = Σ
j=m
j=1 Xi,j 1 cj and there is a one-one correspondence between a
solution X = (X1, . . . , Xn) of the unification problem and a solution to the
system of Diophantine equations. We write X ∈ Sol(U) to denote the fact that
X is a solution to (U). This is a formula of the first-order theory FO(≤,+).
29
A minimal solution to the system of Diophantine equation corresponds to a
solution X = (X1, . . . , Xn) of the unification problem such that
∀Y Y ≤ X ∧ Y ∈ Sol(U) =⇒ X = Y
The set of elements X which satisfy this formula is accepted by an automaton
that is effectively computable. Since we know that there is only a finite number
of minimal solutions and the language of this automaton is finite. To obtain the
set of minimal solutions, we simply use the automaton to generate all the terms
of its language. "
Appendix B.4 Unification in Σ Augmented with Free Symbols
A Unification Algorithm To apply the combination algorithm of [BS96], we
must prove that unification with linear constant restriction is finitary. Given a
unification problem (i.e. a finite set of equations si = ti), we associate to each
constant c appearing in the problem a set Vc of variables that are the variables
in which c must not occur.
Assume that we have a linear ordering < on the set of constants and vari-
ables, then we define Vc = {X | X < c}. A unification problem with linear
constant restriction is a unification problem with the additional constraint re-
striction corresponding to the given ordering <. This amounts to stating that
each variable X of the problem can be instantiated only by terms containing
constants c such that X .∈ Vc. This set is computable and finite and we can
write X = Σ{X &∈Vc}Xi,c 1 c for Xi,c a polynomial of Z/2Z[h]. Therefore unifi-
cation problems with linear constant restriction are solved in the same way as
unification problems are.
As a result, we get a unification algorithm for the theory ACUNh in Σ ex-
tended with free symbols as a simple application of the combination algorithm
(actually we can even choose the simpler version designed for the combination
with the empty theory, see [BS96]).
A Technical Result about Unification To prove the next result (Lemma 4),
we shall rely on notations and algorithms introduced in the study of combination
algorithms, see [BS96] for more details.
From now on, we assume that F = Σ ∪Σ ′ where Σ′ is a set of free symbols
which contains at least one symbol of arity greater than or equal to 2. The
context notation is extended as follows: t = C[t1, . . . , tn] if C is a context made
of symbols of Σ only and the ti’s are standard, or if C is a context made of
symbols of Σ′ and the ti’s are not standard.
If a term t contains only symbols of Σ and variables, or only symbols of Σ ′
and variables we say that it is pure.
The number of theory alternation in a term is defined by #(t) = 0 if t is
pure, otherwise #(C[t1, . . . , tn]) = 1 +max{#(ti) | i = 1, . . . , n}.
The set AF (t) of alien factors of t is defined by:
30
– AF (t) = {t} if t is pure,
– AF (t = C[t1, . . . , tn]) = {t} ∪AF (t1) ∪ . . . ∪AF (tn)
Lemma 4. Let P be a unification problem in the theory E = ACUNh (including
free function symbols) and θ be an mguE of P . Then for all x ∈ dom(θ) and
v ∈ StE(xθ) \ vars(xθ) there exists t ∈ StE(P ) such that v =E tθ.
Actually, we prove the result for the complete set of unifiers computed by the
combination algorithm described by Baader and Schulz in [BS96].
Proof. Firstly, we remark that the lemma is true for a pure unification with linear
constant restriction. This is obvious for the empty theory, and for ACUNh it is
a consequence of our results on unification: a solution of an system of equations⊕
i∈I Pi(h) 1 Xi ⊕
⊕
j∈J Qj(h) 1 cj = 0 with linear constant restriction is a
linear combination of fresh variables and ci’s.
To generalize to the union of the theories, we analyze the combination algo-
rithm. We recall this (non-deterministic) algorithm.
(1) Replace each non pure term t = C[t1, . . . , tn] by C[Xt1 , . . . , Xt1 ] and add the
equations Xti = ti where the Xti ’s are fresh variables.
(2) Replace each equation s = t such that s, t are pure but not in the same
theory by Xs,t = t ∧Xs,t = s where Xs,t is a new variable.
(3) Choose a partition of the set of variable X1, . . . ,Xp, for each Xi choose a
representative Xi and replace all variables X ∈ Xi by Xi (this amounts to
adding equations Xi = X for all X ∈ Xi).
(4) Label each variable by Σ or Σ ′ non-deterministically, and choose a linear
ordering X1 < . . . < Xn.
(5) The problem is decomposed into to pure unification problems with linear
constant restrictions (otherwise return fail). Each problem is solved by taking
the variable of the other theories as constant and the variables of the theory
as variables. The unifier is given by the combination of the solutions of
both unification problems (some replacement can be done to get the actual
substitution).
We use the following properties of the algorithm. Assume that the algorithm
returns the substitution θ.
– For each pair of variables X,Y in the same equivalence class Xθ = Y θ.
– For each alien factor t = C[t1, . . . , tn] of P , there exist variablesXt, Xt1 , . . . , Xtn
such that Xtθ = tθ = C[Xt1θ, . . .Xtnθ].
– For variable Xs,t, we have Xs,tθ = sθ = tθ.
– For each term C[X1, . . . , Xl] occurring in the final pure unification problems,
there exist Yt1 in the same equivalence class as X1,. . . , Ytl in the same
equivalence class as Xl such that C[t1, . . . , tl] is a alien factor of P .
The solution of the pure unification problems has the form:X = C ′[X1, . . . , Xn]
or X is a linear combination of fresh variables and variables Xi’s and constants
31
of Σ. In any case the factors of Xθ for a variable X of the initial problems are
either Xθ, or are some Xtθ for a variable Xt hence there are some tθ for a factor
t of P or fresh variables. "
Actually, the combination algorithm computes a complete finite set of unifiers
CS(P ). To find the actual set of mgu, one must add a last step that detects the
unifiers that are subsumed by other elements of CS(P ). This step doesn’t change
the result and it is irrelevant for our purpose, since what is required in our result
is that all possible ground substitutions covered by the set of unifiers that we
consider.
Appendix C From Constraints to ME Constraints
Lemma 5. Let C be a well-defined system of constraints. Let C ′ be the set of
constraint systems obtained by applying the algorithm of Figure 2 on C.
1. C ′ is a finite set of well-defined system of one-step constraints.
2. Let C′ ∈ C ′. If σ is a solution to C′ then σ is a solution to C.
3. If σ is a conservative solution to C then there exists C ′ ∈ C ′ such that σ is
a solution to C′.
4. For any C′ ∈ C ′, σ is conservative w.r.t. C if and only if σ is conservative
w.r.t. C′.
Proof. 1. The algorithm described in Figure 2 (see Section 6) is non-deterministic
and at each step there are only finitely many possibilities to consider. Hence,
C ′ is finite. By construction, each constraint system in C ′ is a one-step con-
straint system. Now, let C′ be a one-step constraint system in C ′. The mono-
tonicity of C′ is clearly due to the monotonicity of C. To complete the prove
of well-definedness of C′ we may observe that each term which appears in an
hypothesis set of a constraint is either a term introduced by the algorithm
(i.e. a term in S) or a term issuing from an hypothesis set of a constraint in
C. In the first case, this means that the term appears previously in the target
of a constraint by construction. In the second case, we conclude thanks to
the well-definedness of C.
2. For each constraint Ti ! ui ∈ C, there exists a constraint Ti ∪ S1 ∪ . . . ∪
Si !1 ui ∈ C′. Since σ is a solution to C′ (by hypothesis), this means that
uiσ is one-step deducible from Tiσ ∪ S1σ ∪ . . . ∪ Siσ. By construction of C′,
we can show that each term in Sjσ is deducible by using only terms in Tjσ.
Intuitively, each proof is obtained by stacking “one-step” proofs in a correct
order. From this, we easily deduce that uiσ is deducible from T1σ∪ . . .∪Tiσ
which is equal to Tiσ thanks to the monotonicity of C.
3. By hypothesis, for each constraint Ti ! ui ∈ C, there exists a proof Pi of
Tiσ * uiσ. Since σ is conservative and thanks to Lemma 3 (lifting locality
lemma), we can assume that Pi involves only terms in StE(C)σ. Let S′i =
{s ∈ StE(C) | Tiσ * sσ}. In other words, S ′i contains all the subterms of C
32
whose instance by σ is deducible at step i (i.e. by using the terms in Ti). Note
that, thanks to the monotonicity of C, we have S ′i ⊆ S
′
i+1 for all 1 ≤ i < +.
Now, let S1 = S′1 and Si = S
′
i \ (S
′
1∪ . . .∪S
′
i−1). Si contains all the subterms
of C whose instance by σ is deducible at step i and not before. Lastly, for each
i, we order the elements in Si such that: for all s, s′ ∈ Si such that Tiσ * sσ
is the root of a subproof of a minimal proof of Tiσ * s′σ, then s ≺i s′. Hence,
by construction, for each s ∈ Si, we have that sσ is one-step deducible from
S1σ ∪ . . . ∪ Si−1σ ∪ {s′σ | s′ ≺i s and s′ ∈ Si}. It remains to show that uiσ
is one-step deducible from Tiσ ∪S1σ ∪ . . .∪Siσ. By definition of the Sj and
thanks to the fact that uiσ is deducible at least at step i, we know that
ui ∈ S1 ∪ . . . ∪ Si. So, we easily deduce that uiσ ∈ Tiσ ∪ S1σ ∪ . . . ∪ Siσ.
Hence, the result holds.
4. Let C′ ∈ C ′. We have StE(C′) = StE(C). Hence σ is conservative w.r.t. C if
and only if σ is conservative w.r.t. C ′. "
Lemma 6. Given C a well-defined system of one-step constraints. Let P =
{
∧
(s1,s2)∈S′
s1 = s2 | S′ ⊆ StE(C)2}. Let R ∈ P and θ ∈ mguE(R). Let
Cθ = {Tθ !ME uθ | T !1 u ∈ C and uθ is not DY-one-step deducible from Tθ}.
1. There are only finitely many outputs for a given input C. Each of them is a
well-defined system of ME constraints.
2. If there exists Cθ (obtained by the procedure above) which has a solution then
C has a solution.
3. If C has a conservative solution then there exists Cθ (obtained by the procedure
above) which has a non-collapsing solution.
Proof. 1. P is a finite set of equation systems since StE(C) is finite. Each system
of equations represents a unification problem and has a finite complete set of
unifiers thanks to Theorem 1. Let θ be such a unifier. Let Cθ be a constraint
system obtained by using the substitution θ. The system of constraints Cθ
contains only ME constraints. Now, we have to show that Cθσ is well-formed
for every substitution σ. Let C′ = Cθσ. Thanks to the well-definedness of C,
we deduce that C′ is well-formed. It remains to show that the constraints that
we need to remove to obtain Cθ from C′ do not change anything regarding
well-definedness. In other words, we need to show that a removed constraint
Tθ !1 uθ does not introduce a variable for the first time, i.e. there exists
x ∈ vars(uθ) and x .∈ vars(Tθ). By hypothesis, such a constraint Tθ !1 uθ is
such that uθ is DY-one-step deducible from Tθ. Hence vars(uθ) ⊆ vars(Tθ).
2. Let Cθ be the ME constraint system obtained from C by applying the transfor-
mation described in the lemma with the substitution θ. Let θ′ be a solution to
Cθ. We are going to show that θθ′ is a solution to C. Let T !1 u ∈ C. Either uθ
is one-step-deducible from Tθ (without any instantiation) or Tθ !ME uθ ∈ C
′.
In both case, this means that uθθ′ is one-step deducible from Tθθ′. Hence
θθ′ is a solution of C.
33
3. Let σ be a conservative solution to C. Let
R = {(s1, s2) | s1, s2 ∈ StE(C) and s1σ =E s2σ}
Let θ ∈ mguE(R) such that θ is more general than σ. Then, let θ′ be the
substitution such that θ ◦ θ′ =E σ. Let Cθ = {Tθ !ME uθ | T !1 u ∈
C and uθ is not DY-one-step deducible from Tθ}. We are going to show that
θ′ is a solution to Cθ, i.e. uθ′ is ME-one-step deducible from Tθ′ for each ME
constraint in Cθ.
Let T !1 u ∈ C such that uσ is DY-one-step deducible from Tσ. We are
going to show that uθ is DY-one-step deducible from Tθ. Hence, the one-step
constraints which remains in Cθ are those that can be solved by using (ME).
If uσ ∈ Tσ, this means that there exists t ∈ T such that tσ = uσ. Hence, we
have tθ = uθ since t, u ∈ StE(C). Hence uθ ∈ Tθ: uθ is one-step deducible
from Tθ. Otherwise, uσ is one-step deducible from Tσ by using an inference
rule such as (C, UL, UR, D).
In the first case (C), we have uσ = f(v1, . . . , vn) for some vi ∈ Tσ and
f ∈ F \ sig(E). Hence, ∀ i ≤ n ∃v′i ∈ T such that vi = v
′
iσ. There are two
possibilities:
– If u is not a variable, then u = f(u′1, . . . , u
′
n) and we have u
′
i, v
′
i ∈ StE(C)
and u′iσ = v
′
iσ for each i ≤ n. Hence, we deduce that u
′
iθ = v
′
iθ. Hence
uθ is DY-one-step deducible from Tθ.
– If u is a variable, this means (since σ is conservative w.r.t. C) that there
exists t ∈ StE(C)\vars(C) such that uσ =E tσ. Hence t = f(t1, . . . , tn) for
some ti ∈ StE(C). We can deduce that ti = v′i. Hence uθ is DY-one-step
deducible from Tθ.
The others cases (UR), (UL) and (D) are similar.
We finally have to show that θ′ is non-collapsing for Cθ. Let u, v ∈ StE(Cθ)\X .
Hence, by Proposition 3, u, v ∈ StE(C)θ∪
⋃
x∈vars(C) StE(xθ), by consequence
u, v ∈ StE(C)θ. By Lemma 4 there are u1, v1 ∈ StE(C) such that u = u1θ
and v = v1θ. Assuming that uθ′ = vθ′, we get:
uθ′ = vθ′
⇒ u1θθ
′ = v1θθ
′
⇒ u1σ = v1σ
⇒ (u1, v1) ∈ R
⇒ u1θ = v1θ (by construction of θ)
⇒ u = v
"
Appendix D Dealing with ME Constraints
Proposition 5. Let C = {t1, . . . , tn+k−1 !ME ui}i=1,...,k be a well-defined ME
constraint system and σ a non-collapsing solution of ME. Then for all i, 1 ≤ i ≤ k
34
1. FactE(uiσ) ⊆ (FactE(t1, . . . , tn+i−1) \ X )σ.
2. For all x such that i = min{j | x ∈ vars(uj)} we have that FactE(xσ) ⊆
(FactE(t1, . . . , tn+i−1) \ X )σ.
Proof. By induction on the number i of constraints.
If i = 1 then t1, . . . , tn are ground. We have FactE(u1σ) ⊆ FactE(t1, . . . , tn).
Since FactE(t1, . . . , tn) ⊆ (FactE(t1, . . . , tn) \ X )σ, we conclude. Moreover, no
variable x may occur inside a factor v of u1, otherwise we would have that
vσ = tg for some ground term tg ∈ StE(t1, . . . , tn) which contradicts the fact
that σ is a non-collapsing substitution. Hence, x must be a factor of u1, and we
conclude as above.
If i > 1 then we know that FactE(uiσ) ⊆ (FactE(t1, . . . , tn+i−1))σ. If for
some v ∈ FactE(uiσ) we have that v = xσ for some x ∈ FactE(tj) with 1 ≤
j < n + i − 1 then we conclude by induction. Now let x ∈ vars(uiσ), but
x .∈ vars(ujσ) for j < i. Hence, by well-definedness of the constraint system,
x .∈ vars(t1, . . . , tn+i−1). Hence x cannot occur inside a factor of ui since this
would contradict the non-collapsing of σ. As a consequence, x ∈ FactE(ui), and
we conclude as in the first half of the induction hypothesis. "
Lemma 7. If a well-defined ME-constraint system C has a non-collapsing solu-
tion then it is factor-preserving.
Proof. We write Ti = {tj | 1 ≤ j ≤ n + i − 1}. Let σ be a non-collapsing
solution of C and v ∈ FactE(ui) \ X . Thanks to Proposition 5, there exists
v′ ∈ FactE(Ti) \ X such that vσ = v′σ. Since σ is a non-collapsing substitution,
we have v = v′. This allows us to conclude. "
Proposition 1. Let A be a matrix n × m over Z/2Z[h] such that the n row
vectors are independent (n ≤ m) then:
∃Q ∈ Z/2Z[h], ∀b ∈ Z/2Z[h]n, ∃X ∈ Z/2Z[h]m A ·X = Q · b (1)
Moreover, a coefficient Q is computable as a determinant of a sub matrix of A.
Proof. Let A˜ be a matrix m × m obtained from A by adding some rows and
such that all the rows of A˜ are independent. Let Q = det(A˜) (det(A) denotes the
usual mathematical notion of determinant of the matrix n×n A over Z/2Z[h]).
We have det(A˜) .= 0 since all the rows of A˜ are independent and A˜−1 (the
inverse of A˜) is equal to 1Q .A
′ where A′ is a matrix with coefficients in Z/2Z[h].
Let b ∈ Z/2Z[h]n, let b˜ ∈ Z/2Z[h]m be a vector obtained from b by adding
some arbitrary coefficients. X˜ = A˜−1.Q.b˜ is a particular solution of the over
constrained system A˜ · X˜ = Q.b˜. Note that X obtained from X˜ by keeping the
n first components is a solution of A ·X = Q.b. "
35
Let t be a term with the decomposition t = tX1 1 X1 + . . . tXn 1 Xn + t0,
where tXi ∈ Z/2Z[h] and t0 a ground term. The application of a substitution σ
to t is calculated as
tσ = tX1 1X1σ + . . .+ t
Xn 1Xnσ + t0
This can be seen as the sum of some kind of scalar product and the constant
term t0, that is in matrix notation:
tσ = (tX1 , . . . , tXn)1


X1σ
...
Xnσ

+ t0
This will be used in later in the proofs.
Proposition 6. Let t1, t2 ∈ T (F ,X ) with t1 .= t2. Let cX ∈ Z/2Z[h] for every
X ∈ X , let W .∈ X be a fresh variable, and let θ : X → T (F ,X ∪ {W}) be a
substitution such that Xθ = X + cX 1W for every X ∈ X . Then t1θ .= t2θ.
Proof. We proceed by induction on the size of the terms t1 and t2. The base
case is obvious.
– If t1 and t2 are both standard terms then we have
t1 = f1(t
1
1, . . . , t
n
1 )
t2 = f2(t
1
2, . . . , t
m
2 )
If f1 .= f2 then obviously t1θ .= t2θ.
If f1 = f2 then ti1 .= t
i
2 for some i, hence by induction hypothesis t
i
1θ .= t
i
2θ,
and t1θ = f1(t11θ, . . . , t
n
1 θ) .= f2(t
1
2θ, . . . , t
n
2 θ) = t2θ.
– If t1 is standard and t2 is not standard then we have
t1 = f1(t
1
1, . . . , t
n
1 )
t2 = Σs∈FactE(t2)(p
s 1 s)
for some polynomials ps ∈ Z/2Z[h], and FactE(t2) contains at least two
elements. By induction hypothesis for all s1, s2 ∈ FactE(t2) with s1 .= s2,
s1θ .= s2θ . As a consequence, t2θ is not standard, and since t1θ is standard
we conclude that t1θ .= t2θ.
– If both t1 and t2 are not standard then let F = FactE(t1) ∪ FactE(t2). We
can decompose t1 and t2 as
t1 = ΣX∈F∩X (p
X
1 1X) +Σs∈F\X (p
s
1 1 s)
t2 = ΣX∈F∩X (p
X
2 1X) +Σs∈F\X (p
s
2 1 s)
Hence, by definition of θ, we obtain that
t1θ = ΣX∈F∩X (p
X
1 1X) +ΣX∈F∩X ((p
X
1 .c
X)1W ) +Σs∈F\X (p
s
1 1 sθ)
t2θ = ΣX∈F∩X (p
X
2 1X) +ΣX∈F∩X ((p
X
2 .c
X)1W ) +Σs∈F\X (p
s
2 1 sθ)
36
Since t1 .= t2 we have two cases:
In the first case, pX1 .= p
X
2 for some X ∈ F ∩ X , by consequence, since
W .= X, we obtain that X occurs in t1θ with coefficient pX1 and in t2θ with
coefficient pX2 , hence t1θ .= t2θ.
In the second case ps1 .= p
s
2 for some s ∈ F \ X . By induction hypothesis,
sθ .= s′θ for every s ∈ F \ X with s .= s′. As a consequence, sθ occurs in t1θ
with coefficient ps1 and in t2θ with coefficient p
s
2, hence t1θ .= t2θ. "
Remark 1. We can show that such a θ (defined in Proposition 6) do not allow
us to cancel distinct standard subterms in a term t. More precisely, if s is a non
variable standard subterm of t, then sθ is also a non variable standard subterm
of tθ.
Lemma 8. Let C = {t1, . . . , tn+i−1 !ME ui}i=1,...,k be a well-defined and factor-
preserving ME constraint system. Then for every i ≤ k and s ∈ NSt(tn+i−1) the
set {s} ∪ Bi−1 is dependent.
Proof. We proceed by induction on i. If i = 1 then tn+i−1 = tn is ground, and
hence s = (0, . . . , 0) for every s ∈ NSt(tn). We conclude since the set {(0, . . . , 0)}
is dependent.
Let 1 < i ≤ k. By contradiction, we suppose that there is a s ∈ NSt(tn+1−1)
such that {s} ∪ Bi−1 is independent. We will now construct a substitution θ
such that Cθ is not well-founded. The idea of the construction is to generalize
the example 6.
By Proposition 1 there is someQ ∈ Z/2Z[h], Q .= 0, and a vector (cX1 , . . . , cXp) ∈
(Z/2Z[h])p such that


uX11 . . . u
Xp
1
...
...
uX1i−1 . . . u
Xp
i−1
sX1 . . . sXp

 .


cX1
...
cXp

 =


0
...
0
Q


where only those row vectors uj appear in the matrix for which j ∈ L. We define
the substitution θ : {X1, . . . , Xp}→ T (F, {X1, . . . , Xp,W}) by
Xθ = X + cX 1W
for any X ∈ {X1, . . . , Xp}.
Claim 1: Let j < i. For any subterm v of tn+j−1 we have that W .∈ vars(vθ) (*).
If v is a standard term, that is v = f(v1, . . . , vn) with f standard then vθ =
f(v1θ, . . . , vnθ) and the claim follows by application of the induction hypothesis
(*) to the terms vi. Otherwise we can decompose:
v = Σi=1,...,p(v
Xi 1Xi) +Σf∈FactE(v)\X (v
f 1 f)
37
Hence we obtain by definition of θ that
vθ = Σi=1,...,p(v
Xi 1Xiθ) +Σf∈FactE(v)\X (v
f 1 fθ)
= Σi=1,...,p(v
Xi 1Xi)︸ ︷︷ ︸
σ1
+Σi=1,...,p((v
Xi .cXi)1W )︸ ︷︷ ︸
σ2
+Σf∈FactE(v)\X (v
f 1 fθ)︸ ︷︷ ︸
σ3
Since W .= X1, . . . , Xp we have that W .∈ vars(σ1). By induction hypothesis (*)
, W .∈ vars(σ3). By induction hypothesis (of Lemma 8), the set {v} ∪ Bj−1 is
dependent. Hence, there are coefficients α,α1, . . . ,αj−1 ∈ Z/2Z[h] with α .= 0
such that
α.v + α1.u1 + . . .αj−1.uj−1 = (0, . . . , 0)
that is
α.v = α1.u1 + . . .αj−1.uj−1
If we apply scalar multiplication with the vector (cX1 , . . . , cXp) to both sides of
this equation we obtain that
α.Σpi=1(v
Xi .cXi) = α1.Σ
p
i=1(u
Xi
1 .c
Xi) + . . .+ αj−1.Σ
p
i=1(u
Xi
j−1.c
Xi)
The right hand side of this equation is 0 according to the definition of θ (since
in fact each parts of the sum is 0), hence so is the left hand side. Since α .= 0 we
conclude that Σpi=1(v
Xi .cX1) = 0, that is σ2 = 01W = 0, and W .∈ vars(σ2).
As a consequence, W .∈ vars(tn+j−1θ) for any j < n.
Claim 2: W .∈ vars(ujθ) for any j < i.
Let us assume to the contrary thatW ∈ vars(ujθ). If j ∈ L thenΣ
p
i=1(u
Xi
j .c
Xi) =
0 by construction of θ, and if j .∈ L we also have that Σpi=1(u
Xi
j .c
Xi) = 0
since in this case uj is dependent on Bj−1. As a consequence, there is some
f ∈ FactE(ujθ) \ X such that W ∈ vars(f). This is only possible if there is a
f ′ ∈ Fact(uj) such that W ∈ f = f ′θ. By factor-preservation of the constraint-
system C there is some j′ ≤ j < i such that f ′ ∈ Fact(tn+j′−1). By Proposi-
tion 6, for every f ′′ ∈ FactE(tn+j′−1) with f ′ .= f ′′ we have f ′θ .= f ′′θ, hence
W ∈ vars(tn+j′−1θ), which is a contradiction to claim (1) proved above.
Claim 3: W ∈ vars(tn+i−1θ).
We can decompose
s = Σpi=1(s
Xi 1Xi) +Σf∈Fact(s)\X (s
f 1 f)
By definition of θ we obtain that
sθ = Σpi=1(s
Xi 1Xi) +Σ
p
i=1((s
Xi .cXi)1W )︸ ︷︷ ︸
=Q(W
+Σf∈Fact(s)\X (s
f 1 fσ)
and hence W ∈ sθ.
If s = tn+i−1 then we conclude immediately that W ∈ vars(tn+i−1θ). Oth-
erwise, let f ∈ FactE(tn+i−1) \ X such that s ∈ NSt(f). By Proposition 6,
38
since f ∈ FactE(tn+i−1) \ X hence fθ can not be canceled, we also have that
W ∈ vars(fθ), and that W ∈ vars(tn+i−1θ).
Hence, W ∈ vars(tn+i−1θ) and W .∈ vars(ujθ) for all j < i, which is a
contradiction to the origination of Cθ, and hence also a contradiction to the
well-definedness of C. "
Lemma 12. Let C = {t1, . . . , tn+k−1 !ME ui}i=1,...,k be a ME constraint system
over the signature {h,+} ∪ F0, and let L ⊆ {1, . . . , k} be the set of indices
computed as in Section 7.2. The system C is well-defined if and only if for all
1 ≤ j ≤ k the set {ui | i ∈ L and i ≤ j} ∪ {tn+j} is dependent.
Proof. (⇐) Firstly, it is easy to see that monotonicity is clearly satisfied. Sec-
ondly, we have to show that for every substitution θ, Cθ satisfies the origination
property. Let θ be a substitution and t be a term which appears in an hypothesis
set of C such that tθ contains a variable Z. We have necessarily t = tn+j for some
j (otherwise t would be a ground term) and we have to show that Z ∈ uiθ for
some i ≤ j. By hypothesis, we know that there exist α,αi ∈ Z/2Z[h] such that∑
αiui +αtn+j = 0 and α,αi are not all null. Note that {ui | i ∈ L and i ≤ j}
is independent since it is a subset of B. This implies that α .= 0. Hence, we have:
α.tn+j = −
∑
i∈L,i≤j αi.ui
⇒ α.(
∑l=p
l=1 t
Xl
n+j + t
0
n+j − t
0
n+j) = −
∑
i∈L,i≤j αi.(
∑l=p
l=1 u
Xl
i + u
0
i − u
0
i )
⇒ α.(tn+j − t0n+j) = −
∑
i∈L,i≤j αi.(ui − u
0
i )
⇒ α.(tn+jθ − t0n+j) = −
∑
i∈L,i≤j αi.(uiθ − u
0
i )
⇒ α.tn+jθ = −
∑
i∈L,i≤j αi.(uiθ − u
0
i ) + αt
0
n+j
Hence, Z ∈ vars(tn+jθ) implies that Z ∈ vars(uiθ) for some i ∈ L and i ≤ j.
(⇒) Assume that there exists 1 ≤ j ≤ k such that {ui | i ∈ L and i ≤ j} ∪
{tn+j} is independent. By Proposition 1, there exists Q ∈ Z/2Z[h] such that
the following system of equations has a solution over Z/2Z[h].


uX11 u
X2
1 . . . u
Xp
1
...
uX1j u
X2
j . . . u
Xp
j
tX1n+j t
X2
n+j . . . t
Xp
n+j

 ·


X1
...
Xp

 = Q.


0
...
0
1


Let (c1, . . . , cp) be a solution to this system of equations. Let Z be a fresh
variable and θ be the substitution defined by Xi %→ ci.Z for 1 ≤ i ≤ p where Z is
a fresh variable. By construction of θ, we have uiθ = u0i for each i ∈ L such that
i ≤ j and tn+jθ = Q.Z + t0n+j . In other words, we have found a substitution θ
such that Z appears for the first time in an hypothesis set of Cθ. This contradicts
the well-definedness of C. "
39
Lemma 9. Let C be a well-defined factor-preserving ME constraint system and
F = FactE(C)\X . Let F0 be a set of new constant symbols of the same cardinality
as F and ρ : F → F0 a bijection.
1. Cρ is well-defined.
2. vars(Cρ) = vars(C).
3. If C has a non-collapsing solution then Cρ has a F0 ∪ {h,+}-solution.
4. If Cρ has a F0 ∪ {h,+}-solution then C has a solution.
Proof. 1. Well-definedness of Cρ is a consequence of Lemma 8 and Lemma 12.
2. We have that vars(Cρ) ⊆ vars(C) since ρ does not introduce any new vari-
ables. Conversely, if x ∈ vars(C) then let i be the smallest index such that
x ∈ vars(ui). By the same argument as above, x must have an occurrence
in ui which is not inside a factor, hence x ∈ vars(Cρ).
3. Let σ be a non-collapsing solution to C. By non-collapsing of σ, v1σ = v2σ
implies v1 = v2 and hence v1ρ = v2ρ for all v1, v2 ∈ FactE(C) \X . Hence, σρ
is a solution to Cρ.
4. Let σ be a solution to Cρ. Then σ(ρ
−1) is a solution to C. "
Lemma 13. Let C = {t1, . . . , tn+k−1 !ME ui}i=1,...,k be a well-defined ME con-
straint system over the signature {h,+}∪F0, and let L ⊆ {1, . . . , k} be the set of
indices computed as in Section 7.2. Let N ≤ k and σ,σ′ two substitutions (not
necessarily solutions to C). If uiσ = uiσ′ for all 1 ≤ i ≤ N with i ∈ L then we
also have that tjσ = tjσ′ for all 1 ≤ j < n+N .
Proof. This is an immediate consequence of Lemma 12 and of the independence
of the set {ui | i ∈ L}. "
Note that the variables of Z are totally ordered by the lexicographic order of
the indices of variables, that is z[i, j] ≺ z[i′, j′] if and only if i < i′, or else i = i′
and j < j′.
Lemma 14. Let S(C) be a system of equations obtained from a well-defined ME
constraint system C, and let Z ′ ⊆ ZL be downward closed (i.e., if z1 ≺ z2 ∈ Z ′
then z1 ∈ Z ′). If S(C) has a solution then there exists a solution σ to S(C) such
that 0 ≤ zσ < Qmax for all z ∈ Z ′.
Lemma 10 follows from Lemma 14 by choosing Z ′ = ZL.
Proof. We prove this result by induction on the cardinality of Z ′.
Base case: Z ′ = ∅ and the result is trivial.
Induction step: let z = max≺(Z ′). Since Z ′ ⊆ ZL, we have z = z[N,M ] for
some integers N , M such that N ∈ L and 1 ≤ M < n + N . By induction
hypothesis there exists a solution σ such that 0 ≤ z′σ < Qmax for all z′ ∈ Z ′
with z′ .= z.
In the following, we construct a solution σ′ of S such that 0 ≤ zσ′ < Qmax
for all ∀z ∈ Z ′. The construction of σ′ will be in four steps. Finally, we will prove
that σ′ is indeed a solution to S.
40
1. Definition of z′σ′ for z′ ≺ z We set
z′σ′ = zσ for z′ ∈ Z ′ \ {z}
2. Definition of zσ′
Note that z = z[N,M ]. Let K, r ∈ Z/2Z[h] such that 0 ≤ r < Qmax and
zσ = r +K ·Qmax. We set
z[N,M ]σ′ = r
3. Definition of xσ′ for x ∈ vars(S)
Our goal is to find σ′ such that:
– for each i ∈ L \ {N}, uiσ − uiσ′ = 0
– uNσ − uNσ′ = K ·QmaxtMσ
Note that these equations do not involve the context variables from Z, hence we
can solve these equations without having yet fixed the value of σ′ on all variables
from Z. We have to solve the following matrix equation, where the value of a
variable X ′i corresponds to Xiσ −Xiσ
′:

uX11 u
X2
1 . . . u
Xp
1
...
uX1N u
X2
N . . . u
Xp
N
...
uX1% u
X2
% . . . u
Xp
%


1


X ′1
...
X ′p

 =


0
...
K ·Qmax 1 tMσ
...
0


(2)
This can be achieved by solving the system of equations described below where
the unknowns Yi take values in Z/2Z[h]:

uX11 u
X2
1 . . . u
Xp
1
...
uX1N u
X2
N . . . u
Xp
N
...
uX1% u
X2
% . . . u
Xp
%


·


Y1
...
Yp

 =


0
...
K ·Qmax
...
0


(3)
Thanks to Proposition 1 the equation (3) has a solution (c1, . . . , cp). As a con-
sequence, (c1 1 tMσ, . . . , cp 1 tMσ) is a solution to (2).
This allows us to define σ′ on vars(C) by:
Xiσ
′ = Xiσ − ci 1 tMσ i = 1, . . . , p
4. Definition of z′σ′ for z ≺ z′
Note that z ≺ z′ if and only if z′ is some z[i, q] with either i = N and q > M ,
or i > N . Hence , if z ≺ z[i, q] then either q = M and i > N , or q .= M .
z[i, q]σ′ =


z[i, q]σ +
n+i−1∑
j=n+N
(
p∑
l=1
tXlj · cl) · z[i, j]σ if q = M, i > N
z[i, q] if q .= M
41
5. Verification that σ′ is a solution to S
First note that
tjσ = tjσ
′ for 1 ≤ j < n+N (4)
This is a consequence of Lemma 13 and of the fact that uiσ = uiσ′ for 1 ≤ i < N .
First case i < N : This is immediate by (4) and the fact that uiσ = uiσ′ for
1 ≤ i < N .
Second case i = N : we notice that
r = z[N,M ]σ −K ·Qmax (5)
Hence,
n+N−1∑
j=1
z[N, j]σ′ 1 tjσ
′
=
M−1∑
j=1
z[N, j]σ′ 1 tjσ
′ + z[N,M ]σ′ 1 tMσ
′ +
n+N−1∑
j=M+1
z[N, j]σ′ 1 tjσ
′
=
M−1∑
j=1
z[N, j]σ 1 tjσ + r 1 tMσ +
n+N−1∑
j=M+1
z[N, j]σ 1 tjσ
(by (4) and z[N, j]σ = z[N, j]σ′ for j .= M)
=
M−1∑
j=1
z[N, j]σ 1 tjσ + (z[N,M ]σ −K ·Qmax)1 tMσ +
n+N−1∑
j=M+1
z[N, j]σ 1 tjσ
(by (5))
=
n+N−1∑
j=1
z[N, j]σ 1 tjσ −K.Qmax 1 tMσ
= uNσ −K.Qmax 1 tMσ
(since σ is a solution to S)
= uNσ
′
(by definition of σ′)
Third case i > N : we consider the i-th equation of S i.e.:
∑
1≤j<n+i z[i, j]1 tj =
ui Note that, using Xiσ′ = Xiσ − ci 1 tMσ, we get that:
tjσ
′ =
∑
v∈FactE(C)\vars(C)
(tvj 1 v)σ
′ +
∑
v∈vars(C)
(tvj 1 v)σ
′
=
∑
v∈FactE(C)\vars(C)
(tvj 1 v) +
p∑
l=1
(tXlj 1Xlσ)−
p∑
l=1
(tXlj .cl 1 tMσ) (6)
42
Hence, we obtain:
n+i−1∑
j=1
z[i, j]σ′ 1 tjσ
′
=
M−1∑
j=1
z[i, j]σ′ 1 tjσ
′ + z[i,M ]σ′ 1 tMσ
′ +
n+N−1∑
j=M+1
z[i, j]σ′ 1 tjσ
′ +
n+i−1∑
j=n+N
z[i, j]σ′ 1 tjσ
′
=
M−1∑
j=1
z[i, j]σ 1 tjσ + z[i,M ]σ
′ 1 tMσ
′ +
n+N−1∑
j=M+1
z[i, j]σ 1 tjσ +
n+i−1∑
j=n+N
z[i, j]σ 1 tjσ
′
(by (4) and z[N, j]σ = z[N, j]σ′ for j .= M)
=
M−1∑
j=1
z[i, j]σ 1 tjσ + (z[i,M ]σ +
n+i−1∑
j=n+N
(
p∑
l=1
tXlj · cl) · z[i, j]σ)1 tMσ
+
n+N−1∑
j=M+1
z[i, j]σ 1 tjσ
+
n+i−1∑
j=n+N
z[i, j]σ · (
∑
v∈FactE(C)\vars(C)
(tvj 1 v)
+
p∑
l=1
(tXlj 1Xlσ)−
p∑
l=1
(tXlj · cl 1 tMσ))
(by the definition of σ′ and (6))
=
n+i−1∑
j=1
z[i, j]σ 1 tjσ
= uiσ
(since σ is a solution to S)
= uiσ
′
(since uiσ = uiσ′ for i > N)
"
Lemma 11. Given C a well-defined MEconstraint system. It is decidable whether
S(C) has a solution.
Proof. By Lemma 10 we know that if there exists a solution to S(C) then there
also exists a solution in which the values of all variables in ZL ⊆ Z are bounded
by Qmax. Hence we can simply guess the value of each variable z[i, j] ∈ ZL since
there is only a finite number of possibilities.
It remains to decide, for any substitution ρ1 : ZL → Z/2Z[h], whether the
system S(C)ρ1 has a solution. To do this we will proceed in two steps:
43
1. We will construct by induction on the number of constraints a substitution
θ : vars(C) → T (F) such that θ ∪ ρ1 is a solution to all constraints of S(C)
with index in L provided that such a substitution exists.
We will at the same time show that ρ1 completely determines the value of
each term t in C. In other words, we will show that if θ1 and θ2 are solutions
to S(C) extending ρ1 then tθ1 = tθ2 for any term t of S(C). To do so we will
show by induction on the number i of equations in S(C) that S(C) may have
a solution only if there exists a substitution θ : vars(C) → T (F) such that
the equations corresponding to indexes in L are satisfied.
2. We show how to decide the remaining problem, i.e the satisfiability of the
equations in S(C)ρ1θ the indexes of which are not in L.
1. Construction of θ: The base case i = 1 we have that either 1 .∈ L and
all the terms of the constraint are ground, or otherwise 1 ∈ L and the context
variables z[1, 1], . . . , z[1, n] are in ZL and have already been substituted by ρ1.
It is easy to deduce the value v1 of u1. Now, consider the matching problem
{u1 = v1}. Either this matching has a solution allowing us to ensure that there
exists a substitution θ such that u1θ = v1. Otherwise, the first equation has no
solution, and the system is not satisfiable (for this choice of ρ1). Note that the
value v1 is uniquely determined independently of the choice of θ.
Now, we consider a system of i+ 1 equations. We distinguish two cases:
Case i+ 1 ∈ L: We know by induction hypothesis that there exists a substitu-
tion θ such that all the equations corresponding to indexes in L and smaller
than or equal to i are satisfied. Moreover, since i+ 1 ∈ L, the context vari-
ables appearing in the left hand side of the i+ 1th equation are in ZL, hence
they have already been substituted by ρ1. Now, it is easy to deduce the value
vi+1 of ui+1. We consider the matching problem {uj = vj | 1 ≤ j ≤ i + 1}.
Either this matching problem has a solution and this allows us to ensure,
thanks to the well-definedness of the constraint system, that the value of
the term tn+i which is completely determined by the values v1, . . . , vi of
u1, . . . , ui is a ground term. Otherwise, the matching problem does not have
a solution. This means that we cannot find a solution which extends ρ1.
Case i+ 1 .∈ L: By construction the set U = {uj | 1 ≤ j ≤ i, i ∈ L} is indepen-
dent but U ∪ {ui+1} is not independent. Hence ui+1θ is ground and we can
easily determine this value. The same holds for tn+i.
2. Verify the constraints not in L: So far we have obtained a system of
equations in which all the terms are ground. We also know that for each i ∈ L,
the ith equation is satisfied. Now, we have to deal with the remaining constraints.
To do this, we can view each term as a vector (one component per constant)
and we can develop each equation to obtain a system of linear equations over
polynomials in Z/2Z[h]. At the end, we have to check whether a linear system of
equations over Z/2Z[h] has a solution. This is decidable according to [KKS87].
This allows us to decide whether there exists ρ2 : Z \ ZL → Z/2Z[h] a solution
of this system. If this is the case then θ ∪ ρ1 ∪ ρ2 is a solution to S(C). "
44
