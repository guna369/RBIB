Theoretical Computer Science 238 (2000) 183{220
www.elsevier.com/locate/tcs
Conuence of extensional and non-extensional -calculi
with explicit substitutions
Delia Kesner 
Univ. de Paris-Sud (Paris XI), Centre de Orsay, Lab. de Recherche en Informatique,
CNRS U.R.a. 410, Ba^t. 490, F-91405 Orsay Cedex, France
Received March 1997; revised March 1998
Communicated by P.-L. Curien
Abstract
This paper studies conuence of extensional and non-extensional -calculi with explicit sub-
stitutions, where extensionality is interpreted by -expansion. For that, we propose a scheme
for explicit substitutions which describes those abstract properties that are sucient to guarantee
conuence. Our method makes it possible to treat at the same time many well-known calculi
such as ; * ; ; s; v; f; d and dn. cÂ© 2000 Elsevier Science B.V. All rights reserved.
Keywords: Functional programming; -calculi; Explicit substitutions; Conuence; Extensionality
1. Introduction
The -calculus is a convenient framework to study functional programming, where
the evaluation process is modeled by -reduction. The main mechanism used to perform
-reduction is substitution, which consists of the replacement of formal parameters by
actual arguments. The correctness of substitution is guaranteed by a systematic renam-
ing of bound variables, inconvenient which can be simply avoided in the -calculus
a la de Bruijn by using natural numbers to encode the names of variables. However,
substitution remains, as far as classical -calculus or -calculus a la de Bruijn is con-
cerned, as a meta-level operation described by operations that are completely external
to the language. This becomes a concrete problem in real implementations where the
behavior of substitution must be described by other operations. Therefore, -calculi
with explicit substitutions a la de Bruijn appear as a natural formalism to implement
-reduction as they are able to specify the substitution operation by symbols and reduc-
tion rules belonging to the syntax of the calculus. Nowadays, many theorems provers
 E-mail: delia.kesner@lri.fr (D. Kesner).
0304-3975/00/$ - see front matter cÂ© 2000 Elsevier Science B.V. All rights reserved.
PII: S0304 -3975(98)00166 -2
184 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
(HOL, ALF, Nuprl) and functional languages (Haskell, ML) use explicit substitutions
in their implementations.
However, when working with functions, not only -reduction takes place in the
process of evaluation, as an extensional equality is also necessary to reason about
programs. Extensionality means that whenever two programs yield the same result for
every possible argument, then they are equal. The classical extensional axiom in the
theory of -calculus is the -equality, written in a classical formalism as
x :Mx= M if x is not free in M
This equality can be operationally interpreted from left to right, yielding the classi-
cal -contraction rule, or in the other way round as already suggested in [26, 40, 45],
yielding the b-expansion. The traditional contractive way is well behaved in the sim-
ply typed -calculus, but it breaks conuence in many other -calculi [8, 14, 31]. On
the other hand, the typed b-expansion can also be combined with many other reduc-
tion rules, such as expansive surjective pairing [2, 13, 16, 27], recursion [13, 16], sums
[13, 16], algebraic rewriting systems [14] and second order -calculus [15]. All these
combinations are well-behaved as they preserve conuence and strong normalization.
However, none of the mentioned works covers the combination of b-expansion with
calculi having explicit substitutions as they are all based on formalisms with -reduction
rules modelized by a meta-level substitution.
The main goal of this paper is to study conuence of -calculi with explicit sub-
stitutions in de Bruijnâ€™s notation, with or without extensional rules. For that, we keep
the classical denition of Beta-reduction associated to -reduction, and dene the cEta-
expansion rule associated to the classical b-expansion one, this rule being more natural
than all the contractive interpretations given before in the literature [5, 21, 22, 46]. We
study conuence of the reduction relation associated to the Beta-reduction alone as
well as that associated to the combination of Beta-reduction and cEta-expansion.
Since we are interested in many dierent -calculi with explicit substitutions (such
as  [1], * [24],  [42], v [34], f [19], s [28], d [29] and dn [29]), we
develop an \abstract" proof that allows to handle in a simple and general way all
these calculi, by a simple instantiation of the proof on each case-study. This is done
by extracting a set of sucient conditions to guarantee conuence, then formulating a
notion of \scheme" of -calculi with explicit substitution, and nally translating every
mentioned calculus into a calculus verifying the scheme. If the calculus itself already
ts in our scheme then the translation is just the identity, otherwise another function
has to be used as is done for example for s.
This is an extended and detailed version of [29] which is organized as follows. In
Section 2 we recall the untyped and typed versions of the -calculus a la de Bruijn with
their standard  reduction rule. We present the denition of the associated b-expansion
rule, which is only well-dened in a typed framework.
In Section 3 we describe the scheme of -calculi with explicit substitutions, which is
dened to have a concrete structure of -terms, but it does not specify the full behavior
of all the substitution constructors. The intended meaning of the scheme is to take into
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 185
the account at the same time various -calculi with explicit substitutions existing in
the literature which t this \abstract" specication.
We dene in Section 4 the notion of cEta-expansion associated to that of b-expansion
in classical -calculus, and we show that the denition is correct with respect to the
corresponding equational axiomatization. Section 5 is devoted to the abstract proofs of
conuence of Beta and Beta[ cEta by using a generalized interpretation method.
In Section 6 we apply the method to some well known -calculi with explicit sub-
stitutions such as v; ; ; f; s; * ; d and dn. We nally conclude in Section 7.
2. The -calculus a la de Bruijn
When using the -reduction rule to model evaluation in classical -calculus, bound
variables need to be renamed in order to ensure the correctness of the substitution
operation. Thus substitution is not really dened on terms but on -equivalence classes.
A classical way to avoid -conversion problems is to use the de Bruijnâ€™s notation
[11, 12] for -terms, where names of variables are replaced by natural numbers. Hence,
the set of rst-order representations of -terms, called here pure terms or simply terms
to dierentiate them from classical -terms, is dened by the following grammar, where
n denotes some representation of the natural number n:
Naturals n ::= 1jn+ 1
Pure Terms a ::= nj(a a)ja
Notice that this denition is slight dierent from the original one [11, 12], where
every variable is replaced exactly by a natural number and not by a given representation
of a natural number. We prefer however this denition which allows us to make the
set of normal forms of a given calculus and the set of pure terms to coincide: for
example, in , the representation of 2 is the term 1["], which is considered here as a
pure term.
Indeed, a given occurrence u of a variable, say x, is replaced by the (representation
of the) number of symbols  whose occurrences are between the binder of this x and
u. For example, x :y :x(z :zx)y is written ((2((1 3))1)). Remark that a same
variable can be translated in many dierent ways (as the variable x is translated into 2
and 3), and that dierent variables can be translated into the same term (as the variables
z and y are both translated into 1). Representation of free variables is retrieved from a
given context of variables in such a way that an occurrence of a variable n represents
the (n âˆ’ m)-th free variables of the context when n>m and there are m symbols 
surrounding this occurrence n. For example, the term x:(y z) is written as (2 3)
with respect to the context y; z.
To avoid confusion we will note classical -terms with capital letters M;N; : : : and
de Bruijnâ€™s terms with lower case letters a; b; : : : .
186 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
Denition 2.1 (Contexts and applied terms). A context is a term containing a special
symbol denoting a hole. We shall note a context as C[ ] and the textual replacement
of the hole by a term a as C[a]. Thus, C[a] denotes a term. The subterm a in a term
C[(a b)] is said to be applied.
2.1. -reduction in the -calculus a la de Bruijn
In -calculus, evaluation is performed by means of the rule (x :M)N!  Mfx  
Ng, where f  g denotes a meta-operation, usually dened by induction on terms
as follows:
(M L)fx  Ng=(Mfx  Ng Lfx  Ng)
(y:M)fx  Ng=(y:Mfx  Ng)
xfx  Ng=N
yfx  Ng=y
This operation is dened modulo -conversion in order to avoid the capture of free
variables so that in the second equation x is dierent from y and y is not free in N .
Working with de Bruijnâ€™s notation allows to avoid clashes of variable names and thus
explicit -conversion is no more needed in -calculus a la de Bruijn [11, 12]. However,
numbers have to be adjusted when a substitution is performed in order to guarantee
correctness.
Denition 2.2 (Substitutions). Let a and b be terms and n>1. Then, the substitution
of a by b at level n is dened by means of an updating function Uni (i>0 and n>1)
as follows:
(a1 a2)fn bg = (a1fn bg)(a2fn bg) Uni (a b) = Uni (a)Uni (b)
(a)fn bg = (afn+ 1 bg) Uni (a) = (Uni+1(a))
mfn bg =
8>><>>:
mâˆ’ 1 if m>n
Un0 (b) if m= n
m if m<n
Uni (m) =
(
m+ nâˆ’ 1 if m>i
m if m6i
Now, it is possible to dene the -rule using the notions of substitution and contexts
described above:
Denition 2.3 (-reduction). Let a and b be pure terms. We say that a -reduces to
b, written as a!  b, if and only if there is a context C and terms d and e such that
a=C[(d)e] and b=C[df1 eg].
Notice that substitution is still a meta-operation in this calculus, completely external
to the reduction rules of the formalism.
Type information can be added to this formalism in order to model the typed
-calculus. Types are built over some set of base types by means of the arrow con-
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 187
structor for functional types. The type information will be kept in an environment,
which is just a list of types. Typing judgments have the form   â€˜ a : A where   is
an environment, a is a pure term and A is a type. The typing rules are the following:
A;   â€˜ 1 : A   â€˜ n : B
A;   â€˜ n+ 1 : B
A;   â€˜ b : B
  â€˜ A:b : A! B
  â€˜ a : A! B   â€˜ b : A
  â€˜ (a b) : B
When   â€˜ a : A is derivable from the previous set of typing rules, the term a is
said to be of type A. We may omit types if they are clear from the context.
2.2. -reduction in the -calculus a la de Bruijn
Due to the deep connections between -calculus, proof theory and category theory,
studies on extensional equalities have appeared with dierent motivations in all these
elds.
By far, the best known extensional equality in -calculus is the -axiom, written as
() x :A:Mx=M provided x is not free in M
This equality captures the fact that both functions, x : A:Mx and M , return the same
result when applied to the same argument in any context C[ ]. This is expressed as:
C[(x : A:Mx)N ] = C[MN ]
When one wants to turn the -equality into a rule there are two dierent choices:
either from left to right as a contraction, called -contraction, or in the other way
round as an expansion, called -expansion or b-expansion depending on whether some
other restrictions are imposed to its application.
The -axiom has traditionally been turned into a contraction. Such an interpretation is
well behaved in the simply typed -calculus as it preserves conuence [44]. However,
-contraction does not preserve conuence in many other -calculi [8, 14, 31].
Fortunately, expansions can be combined with many other higher-order reduction
rules, such as expansive surjective pairing [2, 13, 16, 27], recursion [13, 16], sums
[13, 16], algebraic rewriting systems [14] and second order -calculus [15]. All these
combinations preserve conuence and strong normalization. For that, application of the
-expansion has to be restricted by some conditions in order to guarantee the strong
normalization property: indeed, remark that the reduction relation is no more a con-
gruence on terms.
Denition 2.4 (The conditional b-expansion).
C[M ]!b C[x : A:(Mx)] if
8>><>>:
x =2FV (M)
M is of type type A! B
M is not a -abstraction
M is not applied in C[M ]
188 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
This denition is adequate, i.e. b-expansion generates the same equational theory as
the -axiom, even if it seems more restrictive because of the syntactic conditions it
imposes. We refer the readers to [13] for a detailed discussion on these conditions.
The -equality in the calculus a la de Bruijn must be able to express that for any
context C[ ], the de Bruijnâ€™s representations of two terms C[x:Mx] and C[M ] are
equal. In terms of representation of variables, this means that all the free variables in
M (that may be bound with respect to C[ ]) traverse one more  when M is replaced
by x:Mx, suggesting in this way that a term a is not -equivalent to (a 1) because
of the adjustments to be made on the free variables of a. As an example, the term
(2 1), placed for example in a context [ ] is -equivalent to the term 1 and not to
2. This is not surprising since ((2 1)) is the de Bruijnâ€™s representation of y:x:yx,
which is -equivalent to y:y, represented by 1. Both conditions can be expressed
using the following formalism:
Denition 2.5 (Binding depth of a position in a term). The binding depth of a posi-
tion in a term is dened by a function h from positions and pure terms to natural
numbers dened in the following way:
h(; m) = 0; h(1:; ab) = h(; a);
h(1:; a) = 1 + h(; a); h(2:; ab) = h(; b):
Denition 2.6 (a^n and a+). Let a be a pure term and n>0. The term a^n is dened
as follows:
(a b)^n = (a^n b^n)
(a)^n = a^n+1
m^n =

m+ 1 if m>n
m if m6n
From now on, we denote by a+ the term a^0 , i.e. a+ is obtained by lifting any free
variable of a by 1. This lifting is performed by replacing every index m at position 
such that m>h(; a) by m+ 1.
Remark 2.1. If a is a pure term, then U 20 (a) is a
+. Indeed, U 2m(a) is exactly a
^m
according to denition 2.2 and thus U 20 (a)= a
^0 = a+.
Denition 2.7 (-equality). Let a and b be pure terms. Then (a 1)= b if a= b+.
The -contraction rule is obtained by orienting the previous equality from left to
right, while the -expansion rule is obtained by orienting the equation into the other
way round. Analogously to what is done in classical -calculus to guarantee strong nor-
malization of extensional expansions [13], we can now dene a conditional b-expansion
as follows:
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 189
Denition 2.8 (The conditional b-expansion). Let C[ ] be any context and let a be a
pure term.
C[a]!b C[A:(a+ 1)] if
8<:
a is of type A! B
a is not a -abstraction
a is not applied in C[a]
Exactly as in the case of the simply typed -calculus, this denition is adequate,
i.e. the limitations imposed on the reduction system do not make us loose any valid
equality as they are just introduced to avoid reduction loops. The result can be obtained
by proving that any -equality can be generated by the reexive, symmetric and
transitive closure of b-reduction. We omit here the details of this (standard) proof,
which can be found in [30] (Theorem 2.7).
As expected, the b-expansion rule enjoys the subject reduction property:
Lemma 2.2 (Subject reduction for b). If   â€˜ a : A and a!b b; then   â€˜ b : A.
Proof. If a!b b is a root expansion step, then A is a functional type B ! C and
b= B:(a+ 1), so we have to show that   â€˜ B:(a+ 1) : B ! C. For that, we rst
show by induction on the structure of a, that for every n>0 and for every type B,
if  ;  â€˜ a : A and n is the length of the environment  , then  ; B;  â€˜ a^n : A. As
a corollary,   â€˜ a : A implies B;   â€˜ a+ : A so that we obtain the following typing
sequence:
  â€˜ a : B! C
B;   â€˜ a+ : B! C B;   â€˜ 1 : B
B;   â€˜ (a+ 1) : C
  â€˜ B:(a+ 1) : B! C
If a!b b is not a root expansion, then one proceeds by induction on terms.
A direct proof of conuence of [b in the -calculus a la de Bruijn can be found in
[30], but since we know that the union of  and b yields a conuent reduction relation
in the typed -calculus, and also that the -calculus is isomorphic 1 to the -calculus
a la de Bruijn [6, 11, 37], then we are able to conclude that
Theorem 2.3. !
b is conuent in the typed -calculus a la de Bruijn.
As a consequence, using the fact that = can be generated by the reexive, sym-
metric and transitive closure of ! b we obtain
1 In the sense that there exist a translation T from -terms into -terms a la de Bruijn such that a!  b
if and only if T(a)! T(b).
190 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
Corollary 2.4. If a= b; then there is a term c such that a!b c and b!b c.
3. A scheme for -calculi with explicit substitutions
When substitutions are specied at a meta-level, as in classical -calculus or
-calculus a la de Bruijn, an external mechanism takes place each time a -redex
needs to be reduced. The approach is very dierent in -calculi with explicit substitu-
tions, where the manipulation of substitutions is incorporated in an explicit way to the
calculus via a set of rewrite rules. Such -calculi oer the possibility to have a more
rened control over substitutions, by allowing for example to delay or record them,
and they can be used to describe dierent implementations in a uniform way.
In this section we introduce a scheme for -calculi with explicit substitutions which
is dened to have a concrete structure of terms, but does not specify the full behavior
of all the substitution constructors. The intended meaning of this scheme is to extract
from the various -calculi with explicit substitutions existing in the literature a uniform
description of their behavior and a set of common features being sucient to reason
about conuence.
3.1. Syntax and rewriting rules
Let us consider two distinguished symbols T (for terms) and S (for substitutions).
Denition 3.1 (Substitution signatures). A substitution declaration is a (possibly
empty) word over the alphabet fT;Sg. A substitution signature is dened to be
a set of symbols  all equipped with an arity n and a substitution declaration of
length n. We usually write  : hn; 1 : : : ni if the symbol  has arity n and substitution
declaration 1 : : : n.
Denition 3.2 (Substitution language). The set of objects over a substitution signature
 constitutes a substitution language which is the union of objects of sort T and S
constructed in the following way:
 If n is a natural number, then n is of sort T.
 If a and b are of sort T, then (a b) is of sort T.
 If a is of sort T, then (a) is of sort T.
 If a is of sort T and s is of sort S, then a[s] is of sort T.
 If every fi is of sort i, and  : hn; 1 : : : ni 2, then (f1; : : : ; fn) is of sort S.
We will say that n is a variable, (a b) an application, (a) a -abstraction and a[s]
a closure. We also omit parenthesis when they are clear from the context. For each
substitution language W , the set of objects of sort T (resp. S) is called the set of
terms (resp. substitutions) of W . We write W for the set of terms and substitutions
of W .
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 191
As an example, the substitution signature of the -calculus [34] is the set f#;*; "g,
where # : h1;Ti, *: h1;Si and ": h0; i, while the the substitution signature of the
-calculus [1] is the set f; ; id ; "g, where  : h2;TSi,  : h2;SSi, id : h0; i and
": h0; i. We refer the reader to Section 6 for a more detailed presentation of these
calculi.
We now introduce some of the rewriting rules required for our scheme. We start with
the Beta rule that is the main mechanism in all the -calculi with explicit substitutions:
it is used to initiate the computation and to explicitly introduce substitutions in the
terms to be evaluated. The left-hand side of the Beta rule corresponds to a classical
-redex (a)b while the right-hand side must be an expression used to denote the
term a where the index 1 is replaced by the term b, the index 2 by 1, the index 3
by 2, etc. This is done in dierent ways according to the substitution language of the
corresponding calculus, but we can, in general, write this expression as a[consW (b)],
where consW is a cons-function from terms to substitutions that must be dened for
each -calculus W . The Beta rule of the scheme can then be expressed as 2
(Beta) (a)b! a[consW (b)]
As an example, the cons-function of the v-calculus is cons(b)= #(b), while the cons-
function of the -calculus is cons(b)= b  id .
The second rule of the scheme for -calculi with explicit substitutions, called the App
rule, is used to distribute a substitution with respect to the subterms of an application
term. It is expressed as
(App) (a b)[s]! (a[s] b[s])
The third rule, called Lambda, is used when a substitution goes under a  constructor.
The left-hand side of this rule corresponds then to a redex (a)[s], while the right-
hand side will be written in general as (a[liftW (s)]), where liftW is a lift-function
from substitutions to substitutions which must be dened for each -calculus W . The
substitution liftW (s) denotes a function which does not aect the indices 1 (which
represent the variables which are bound by the -abstraction that [s] has crossed within
the Lambda rule) but only changes the other free variables making the correspondent
adjustments of indices. The Lambda rule of the scheme can then be expressed as 3
(Lambda) (a)[s]! (a[liftW (s)])
As an example, the lift-function of the v-calculus is lift
v(s)=* (s), while the lift-
function of the -calculus is lift
(s)= 1  (s  ").
2 Since the right-hand side of the Beta rule depends on the substitution calculus W , we should denote this
rule as BetaW , but we prefer to omit the index W to make easier the notation.
3 Since the right-hand side of the Lambda rule depends on the substitution calculus W , we should denote
this rule as LambdaW , but we prefer to omit the index W to make the notation easier.
192 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
Denition 3.3 (Substitution calculus). A rewrite rule l! r is said to be sort-
preserving if r is of sort K when l is of sort K. A Substitution Calculus 4 con-
sists of a signature containing the substitution constant shiftW : h0; i, which is called a
shift-constant and will be used to denote extensional equalities, a lift-function, a cons-
function, and a set of sort-preserving rewriting rules containing App and Lambda (but
not Beta). For simplicity we will often omit the superscript W from shiftW, liftW (s)
and consW (b) when they are clear from the context.
Notation 3.1. We write simply W for the set of rewriting rules of the substitution
calculus W , and W for the set W [Beta. The notations !R and =R are respectively
used to denote R-reduction and R-equality. If s is a substitution, we note [s]n the
concatenation of substitutions [s] : : : [s]| {z }
n times
, assuming that [s]0 denotes the empty word.
For any function h, hi (i>0) is dened by h0(s)= s and hn+1(s)= h(hn(s)).
3.2. The scheme
The rewriting rules Beta, App and Lambda introduced in Section 3.1 are necessary
to describe some relations between terms and substitutions, but they are not sucient
to express all of them. In particular, we want to prove conuence for some reduction
relations associated to all the -calculi with explicit substitutions satisfying our scheme,
so we have to impose some additional conditions on the set of rewriting rules of a
substitution calculus W . These conditions are mainly inspired from the various proofs
of conuence existing in the literature for the relations ! W, where W is for example
the -calculus [1], the *-calculus [24], or the -calculus [34].
Denition 3.4 (Basic conditions). A substitution calculus W is said to be basic (writ-
ten BSC) if it satises the following conditions:
1. W is strongly normalizing. 5
2. W is conuent.
3. W -normal forms of terms are pure terms.
4. W (a b)= (W (a) W (b)) and W (a)= W (a), where W (a) denotes the W -normal
form of a.
5. For every substitution s in W , 1[liftW (s)]=W 1
6. For every substitution s in W and every m>1, m+ 1[liftW (s)]=W m[s][shift
W ]
7. For every term k in W and every m>1, m+ 1[consW (k)]=W m
8. For every term k in W , 1[consW (k)]=W k
9. For every variable m in W we have m[shiftW ] =W m+ 1.
4 Another notion of substitution calculus can be found in [47].
5 The well-known substitution calculi appearing in the literature are all strongly normalizing, and moreover,
standard proof techniques like polynomial orders or semantic labellings [48] are usually sucient to show
this property. However, when adding the Beta rule, strong normalization does not always hold, even in a
typed framework [39].
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 193
It is evident that there exist even more abstract properties to ensure conuence and
strong normalization of any rewriting system W , but the intention of Denition 3.4
is to consider a set of sucient tools to reason about conuence of extensional and
non-extensional -calculi; we think that this presentation is quite reasonable to attack
these conuence problems from an abstract point of view.
From conditions 1 and 2 in Denition 3.4 we deduce that W -normal forms are
unique, 6 and this, together with condition 3 guarantees that for every object a in
W and every pure term b such that W (a)= b, then a!W b. This property will be
used in several lemmas of the paper. Conditions 5{9 state the behavior of the main
substitutions lift, shift and cons that we need in any calculus with explicit substitutions
in order to implement  and  reduction. They interact between them as follows.
Corollary 3.2. Let W be a basic substitution calculus. Then for every m>1; for every
n>0; every term k in W and every substitution s in W :
W (m[liftn(s)])=

W (mâˆ’ n[s][shift]n) if m>n;
m if m6n;
W (m[liftn(shift)])=

m+ 1 if m>n;
m if m6n;
W (m[liftn(cons(k))])=
8<:
mâˆ’ 1 if m>n+ 1;
m if m<n+ 1;
W (k[shift]n) if m= n+ 1:
Now, we add some simple restrictions that are very easy to prove when working with
concrete calculi, as they just concern the interaction between variables and substitutions
of the substitution language.
Denition 3.3 (Scheme). We say that a basic substitution calculus W obeys the scheme
i for every variable m2W and every function symbol  2 of arity q one of the
two following conditions holds:
 There exist a variable n, indices i1; : : : ; ip (p>0) and substitutions u1; : : : ; uk (k>0)
such that
{ 16i1; i2; : : : ; ip6q and the ijâ€™s are all distinct, and
{ For all s1 : : : sq we have m[(s1; : : : ; sq)]=W n[si1 ] : : : [sip ][u1] : : : [uk ].
 There exists i (16i6q) such that for all s1 : : : sq we have m[(s1; : : : ; sq)]=W si.
We assume these equations to be well-typed, in the sense that whenever the rst
case holds, then si1 ; : : : ; sip are substitutions, and whenever the second case holds, then
si is a term.
6 Even if uniqueness of normal forms can also be deduced from weak normalization and conuence, we
require a substitution calculus to have the strong normalization property to guarantee that any evaluation
strategy used to eliminate substitutions will terminate. Substitution calculi are supposed to preserve the
properties of the languages they implement so it is reasonable to require strong (and not weak) normalization
and conuence.
194 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
This condition says that the behavior of any substitution s= (s1; : : : ; sq) with respect
to a variable m is only determined by the constructor  and not at all by the other
components s1 : : : sq, that is, the semantics of any substitution is given by the constructor
and not by their arguments. Remark that we use the equality =W instead of the rewrite
relation !W because sometimes the scheme is veried by a rewrite step !W and some
other times by W : indeed, in the -calculus, we have m[s  t]Clos m[s][t], while for
example in the v-calculus, we have m["]!VarShift1m+ 1.
To understand the (technical) motivations of Denition 3.5 let us suppose that lift,
shift and cons are just primitive constructors. Then, conditions 5, 6, 7 and 9 of Def-
inition 3.4 corresponds to the rst case of the scheme while condition 8 corresponds
to the second one. Since lift, shift and cons are not always implemented via a sin-
gle primitive constructor as for example lift(s)= 1  (s  ") is dened as a \macro"
using three dierent constructors  ;  and ", we ask all the primitive constructors of
substitutions to verify the scheme. Doing so, the three \macro" substitutions lift, shift
and cons as well as all the primitive constructors of the language for substitutions
will follow the scheme, having in this way a certain type of \regular" behavior which
makes easier to reason by induction on the structure of objects.
4. Extensional -calculi with explicit substitutions
In this section we dene the notion of cEta-expansion associated to that of b-expansion
in classical -calculus, and we show that the denition is correct with respect to the
corresponding equational axiomatization via the Eta-axiom. The basic conditions given
in Denition 3.4 will be sucient to show that the cEta-expansion rule is a correct
restriction of the Eta-axiom, while the scheme given in Denition 3.5 is also needed
to show that both Beta and Beta[ cEta are conuent reduction relations.
4.1. The Eta-axiom
The standard equation corresponding to -equality in classical -calculus is usually
written in the formalism of -calculi with explicit substitutions as the axiom:
(Eta) (a[shift] 1)= a
The shift-constant is then necessary to express the extensional Eta-axiom, but it will
be also useful to express some relations between explicit substitutions, even if the Eta-
axiom is not considered in the substitution calculus W . For example, one can express
the behavior of lift-functions in terms of the shift-constant as done in Denition 3.4,
condition 6.
We show here a characterization of a pure term a+ and we give the relation between
updating functions and explicit substitutions.
Lemma 4.1. Let W be a basic substitution calculus. Let a be a pure term; i>0 and
n>1. Then Uni (a)=W (a[lifti(shift)]
nâˆ’1).
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 195
Proof. By induction on the structure of the term a, using Corollary 3.2.
Corollary 4.2. Let W be a basic substitution calculus and let a be a pure term. Then
W (a[shift]) is the term a+.
Proof. The property follows from Lemma 4.1 for the case n=2 and i=0, using the
fact that U 20 (a) is a
+ (Remark 2.1).
4.2. Turning the Eta-axiom into a reduction rule
When turning the Eta-axiom into a reduction rule some problems arise. If we orient
this equation from left to right as the rewriting rule (a[shift] 1)! a, an innite set
of critical pairs is usually generated. As a consequence, the rule is often expressed by
the following conditional rule [21, 22, 46]:
(Eta1) (a 1)! b if a=Wb[shift]:
However, the condition a=Wb[shift] depends on the particular denition of the sub-
stitution calculus W , and may be dicult (or expensive) to be veried each time that
an Eta1-reduction is performed.
There is another unconditional rewriting rule associated to the Eta-axiom, proposed
by Briaud [5], expressed in our syntax as follows:
(Eta2) (a 1)! a[cons(?)]
where ? is a new constant added to the set of terms. This rule can be expressed in
classical -calculus as
(Eta3) x:(M x)!Mfx  ?g
The -contraction rule in classical -calculus coincides with the Eta3-rule only if
the variable x is not free in M . Similarly, the Eta2-rule coincides with the conditional
Eta1-rule if the variable represented by 1 is not free in the term a. Otherwise, the Eta1-
rule is not allowed (because the condition is not veried), but Eta2 is. The intended
meaning of the constant ? is to denote something that is not a term, i.e., a meaningless
term. For this reason, every normal form involving terms with ? has to be discharged,
and this requires some kind of backtracking in the computation process, which is, as
we know, an expensive operation. However, the Eta2-rule can also be interpreted as
the following conditional rule
(Eta02) (a 1)! a[cons(?)]; if ? 62W (a[cons(?)])
This leads to perform a verication before applying the rule and therefore this so-
lution is still expensive by means of computation steps. Also, the Eta02 rule depends
on the particular denition of the substitution calculus W exactly as in the case of the
Eta1-rule.
196 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
Fortunately, there is still another reading of the Eta-axiom that avoids all these
problems which corresponds to the unrestricted Eta-expansion:
(Eta) a! (a[shift] 1)
As explained in Section 2.2, the expansive interpretation of the -axiom has been
very successful in these last years, mainly because it has been shown to be compatible
with many other higher-order rules. This suggests that it would also be a good solution
to dene extensional versions of -calculi with explicit substitutions containing the
expansive interpretation of the Eta-axiom.
As the unrestricted Eta-expansion rule is not strongly normalizing, one has to restrict
its application by imposing some conditions to guarantee termination, exactly as in the
case of the b-expansion rule. Even if we are not going to study strong normalization
properties in this paper, a more restricted version of Eta-expansion will be considered
here in order to model exactly the standard conditional b-expansion rule. For that,
we know that b-expansion is only applied to typed terms of functional type which
verify some syntactic restrictions: the terms are not -abstractions and they are not
applied to other subterms. All these conditions can also be expressed when dealing
with Eta-expansion in -calculi with explicit substitutions.
Denition 4.1 (Applied-terms and Lambda-abstractions). We say that a term a is a
Lambda-abstraction if a= b, or a= b[s] and b is a Lambda-abstraction. Similarly, let
C[ ] be any context. We say that a subterm a is an Applied-term in C[a], if either it
is applied in C[a], or a= b[s] and b is an Applied-term in C[b].
As an example, (1) and (1)[shift][shift] are Lambda-abstractions and 1 is an
Applied-term in both (1 2) and (1[shift] 2).
The type system associated to each substitution calculus depends on the substitution
function symbols of its signature. However, there is a set of common typing rules that
will be found in all these systems:
A;   â€˜ 1 : A A;   â€˜ shift .  
  â€˜ n : B
A;   â€˜ n+ 1 : B
  â€˜ a :A  â€˜ s .  
 â€˜ a[s] : A
  â€˜ a : A! B   â€˜ b : A
  â€˜ ab : B
A;   â€˜ b : B
  â€˜ A:b : A! B
We now present the conditional cEta-expansion rule, remark that the relation generated
by this rule is no longer a congruence as in the case of classical -calculus and -
calculus a la de Bruijn.
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 197
Denition 4.2. The conditional cEta-expansion rule is dened as:
C[a]! bEta C[A:(a[shift] 1)] if
8<:
a is of type A!B
a is not a Lambda-abstraction
a is not an Applied-term in C[a]
Denition 4.3. Given a basic substitution calculus W , we dene its extensional version
as the calculus containing the rules W , Beta and cEta. We denote the reduction relation
associated to the extensional substitution calculus W by !
W[ bEta.
As expected, the cEta-expansion rule enjoys subject reduction.
Lemma 4.3 (Subject reduction for cEta). If   â€˜ a :C and a! bEta b; then   â€˜ b :C.
To justify the denition of Applied-terms, it is sucient to remark that given a
term C[(a[s] b)], then the cEta-expansion rule will not be terminating as the following
innite reduction sequence shows:
a! bEta (a[shift] 1)! bEta (((a[shift] 1))[shift] 1) : : :
However, our restriction is sucient to keep the strong normalization property:
Lemma 4.4 (Strong normalization of cEta). The reduction ! bEta is strongly normaliz-
ing.
Proof. Using a decreasing measure as dened in [41], we refer the reader to [31] for
details.
It is also worth noticing that even if a term a is not a Lambda-abstraction according
to Denition 4.1, its W -normal form may be one: for example 1[cons(1)] is not a
Lambda-abstraction but W (1[cons(1)])= 1 is. The same happens with the notion
of Applied-terms. This remark suggests that one could also use a dierent notion of
restriction in Denition 4.2, saying that a term a is a Lambda-abstraction if a=Wb.
This alternative notion of restricted expansion coincides exactly with that of simply
typed -calculus, but introduces at the same time a condition that depends on the
particular denition of the substitution calculus W , exactly as in the case of the Eta1
previously mentioned. Even if our approach also introduces a condition in order to use
Eta as a reduction rule, the restriction does not depend at all on the particular theory
generated by the substitution calculus and there is no backtracking at all.
4.3. Adequacy of cEta-expansions
The cEta-expansion generates the same equational theory generated by the Eta-
equality, even if it seems more restrictive because of the syntactic conditions to be
veried. This property is called adequacy of cEta with respect to Eta. We show here
198 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
that Denition 4.2 of cEta-expansion is adequate with respect to the equational theory
generated by the Eta-equality in any -calculus with explicit substitutions verifying the
basic conditions. For that, we rst study some syntactic properties which are helpful
not only in proving Theorem 4.6 but also for other results of the paper.
Lemma 4.5 describes two dierent cases where the successive application of two
dierent explicit substitutions on a term does not change its meaning.
Lemma 4.5. Let W be a basic substitution calculus; a be a pure term and k be a
term in W . Then for every n>0;
1. a[liftn(shift)][liftn(cons(k))]!W a
2. a[liftn+1(shift)][liftn(cons(1))]!W a
Proof. By induction on pure terms, using Corollary 3.2.
We can now show Theorem 4.6 that has already been announced:
Theorem 4.6. Let W be a basic substitution calculus. Then any Eta-equality a=Eta b
can be generated by the reexive; symmetric and transitive closure of !
W[ bEta.
Proof. Suppose a=Eta b holds but a does not cEta-reduce to b, neither b to a. Without
loss of generality we can suppose that one of the restrictions holds for a, and we
reason as follows:
 a is a Lambda-abstraction according to Denition 4.1. Then a=(b)[s1] : : : [sn] and
we want to show that (b)[s1] : : : [sn] and (((b)[s1] : : : [sn])[shift] 1) are interre-
ducible. Let us consider the pure term W ((b)[s1] : : : [sn]) that is necessarily a -
abstraction, say k, so that (b)[s1] : : : [sn]!W k. Then,
(((b)[s1] : : : [sn])[shift] 1) !W
((k)[shift] 1) ! Lambda
((k[lift(shift)]) 1) ! Beta
(k[lift(shift)][cons(1)]) !W (by L 4:5(2))
k
 a is an Applied-term according to Denition 4.1. Then a is a subterm of (a[s1] : : :
[sn]c) and we want to show that (a[s1] : : : [sn] c) and (((a[s1] : : : [sn][shift] 1))c)
are interreducible. Let us take the term k such that a[s1] : : : [sn]!W k. Then,
(((a[s1] : : : [sn][shift] 1)) c) !W
(((k[shift] 1)) c) ! Beta
(k[shift] 1)[cons(c)] !App
(k[shift][cons(c)] 1[cons(c)]) !W (Def 3:4(5))
(k[shift][cons(c)] c) !W (by L 4:5(1))
(k c)
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 199
5. Conuence for the scheme
We show in this section that extensional and non-extensional basic substitution cal-
culi having the scheme are conuent. As we deal with extensional rules, the interpreta-
tion method [20], which is the standard technique used to prove conuence of -calculi
with explicit substitutions, has to be slightly modied, resulting in the generalized in-
terpretation method, that allows also to deal with conditional extensional rules. It is
also worth noticing that standard techniques, like the Tait and Martin-Lofâ€™s parallel
moves lemma, do not work when dealing with restricted expansions, and this is the
reason we prefer to use directly the interpretation method even for the non-extensional
versions of our -calculi.
The interpretation method allows to reason in a quite modular way, by splitting an
entire reduction relation R into two dierent and disjoint relations R1 and R2. Indeed,
one has to verify that R1 is conuent and strongly normalizing; and also that R2 enjoys
some kind of \preservation of reduction" by R1-normal forms. These facts make it
possible to put them together guaranteeing conuence of the whole reduction relation
R. The method can be summarized by the following lemma:
Lemma 5.1 (Interpretation method). Let R=R1 [R2; where R1 is a conuent and
strongly normalizing reduction relation and R2 an arbitrary reduction relation. If
there exists a reduction relation S on the set of R1-normal forms such that
(i) !S  !R; and
(ii) a! R2b implies R1(a)!S R1(b)
then if S is conuent; R is also conuent.
When showing conuence for any relation ! W associated to a -calculus with
explicit substitutions, one usually takes S as , R1 as W and R2 as Beta. However,
when the cEta-expansion is also considered in the reduction system, this method is no
longer useful because condition ii does not always hold, as the following example
shows:
Example 5.2. Let us consider the extensional v-calculus and the following cEta-
expansion step: a=1[#(1)]! bEta ((1[shift] 1))[#(1)]= b.
Then W (a)= 1 and W (b)= ((1) 1), so it is neither true that W (a)!b W (b),
nor that W (a)!
b W (b). In fact, W (a) is a b-normal form so it cannot be reduced
at all.
As the previous example suggests, condition (ii) required by the interpretation method
can be weakened to recover conuence as follows:
a! R2 b implies R1(a)=TR1(b)
where =T stands for an equality contained in !S S  .
200 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
This formulation yields our generalized interpretation method, as condition ii required
by Lemma 5.1 is a particular case of this condition above.
Lemma 5.3 (Generalized interpretation method). Let R=R1 [R2; where R1 is a con-
uent and strongly normalizing reduction relation and R2 an arbitrary reduction rela-
tion. If there exists a reduction relation S and an equality T on the set of R1-normal
forms such that
(i) !S  !R;
(ii) =T  !S S  and
(iii) a! R2 b implies R1(a)=T R1(b):
Then R is conuent.
Proof. First of all, since R1 is conuent and strongly normalizing, we know that R1-
normal forms are unique and so, from condition iii we have that a!R b implies
R1(a)=T R1(b). Now, suppose b R
 a!R c. Reduce b and c to their R1-normal
forms R1(b) and R1(c). As R1R, then R1(b) R  a!R R1(c) and by the previous
remark we have that R1(b)=R1(R1(b))=T R1(a)=T R1(R1(c))=R1(c). By condition ii
R1(b)!S S  R1(c), and by condition i R1(b)!R R  R1(c) so we can close the
diagram as follows:
b!R R1(b)!R R  R1(c) R  c
When showing conuence for any relation ! W , one usually takes S as , T as ,
R1 as W and R2 as Beta, while for any relation ! W[ bEta, one usually takes S as [b,
T as [ , R1 as W and R2 as Beta[ cEta. We are now able to devote the rest of this
section to prove the hypothesis required by Lemma 5.3, namely:
!  !W and !b  !W[ bEta (1)
= !   and = !b b  (2)
a! Beta b implies W (a)= W (b) and a! Beta[ bEta b implies W (a)= W (b)
(3)
Property 1 is quite simple to prove (see Lemma 5.17) whereas the rst (resp. second)
part of Property 2 holds by the fact that  (resp. b) is conuent. Property 3 is the
essential part of the general abstract proof that distills the dierent techniques used in all
the proofs appearing in the literature. The main idea used to prove them comes from the
case where a and b are closures c[s] and c[s0] such that s! Beta s0 (resp. s! bEta s0). As
 (resp. b) equality is only dened on pure terms (and W -normal forms of substitutions
are not), the previous property needs to be proven together with a similar statement
for substitutions, resulting in something like s! Beta s0 (resp. s! bEta s0) implies that
for every pure term d, W (d[s])= W (d[s0]) (resp. W (d[s])=b W (d[s0])). See Lemma
5.14 (resp. Lemma 5.15) for the precise formulation of these properties.
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 201
One remark concerning Property 3 above is that one might in fact prove a stronger
property (as done in [29]), namely that a!
Beta[ bEta b implies W (a)! b   W (b).
Even if this also yields to the desired result, the proof becomes more complicated as
we have to deal with a lot of details concerning the conditional reduction rule b.
5.1. Some technical lemmas
When showing conuence of -reduction in classical -calculus, one is often faced
to show the substitution lemma, which is usually stated as follows:
M [x :=N ][y :=L] =M [y :=L][x :=N [y :=L]]; if x 62FV (L)
This section is devoted to show the substitution lemma in the framework of explicit
substitutions, which will be used latter in Section 5.2 to show the properties required
by our generalized interpretation method.
Lemma 5.4. For every basic substitution calculus W; every pure term a and every
n>0 we have W (a[shift][liftn+1(shift)])=W (a[liftn(shift)][shift]).
Proof. One shows, by induction on the structure of a using Corollary 3.2, that for any
n>k>0 W (a[liftk(shift)][liftn+1(shift)])=W (a[liftn(shift)][liftk(shift)]). Then, the
property follows from the case k =0.
By n iterations of Lemma 5.4 we obtain:
Corollary 5.5. Let W be a basic substitution calculus. For any pure term a; we have
W (a[shift]n[liftn(shift)])=W (a[shift]
n+1)
Lemma 5.6. Let W be a basic substitution calculus; a be a pure term and s be a
substitution in W . Then W (a[s][shift])=W (a[shift][lift(s)]).
Proof. We prove, by induction on the structure of a, that for every n>0
W (a[liftn(s)][liftn(shift)])=W (a[liftn(shift)][liftn+1(s)])
Then, the property follows from the case n=0.
 For a=m, we have two cases:
{ If m>n, then
W (m[liftn(s)][liftn(shift)]) =Cor 3:2
W (mâˆ’ n[s][shift]n[liftn(shift)]) =Cor 5:5
W (mâˆ’ n[s][shift]n+1) =Cor 3:2
W (m+ 1[liftn+1(s)]) =Cor 3:2
W (m[liftn(shift)][liftn+1(s)])
202 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
{ If otherwise m6n, then
W (m[liftn(s)][liftn(shift)]) =Cor 3:2
W (m[liftn(shift)]) =Cor 3:2
m =Cor 3:2
W (m[liftn+1(s)]) =Cor 3:2
W (m[liftn(shift)][liftn+1(s)])
 For a=(a1 a2) or a= b the property immediately follows from the induction hy-
pothesis.
Corollary 5.7. Let W be a basic substitution calculus. Let a be a pure term and s
be a substitution in W . Then for every k>1 we have W (a[shift]k [liftk(s)])=W (a[s]
[shift]k).
Proof. By induction on k using Lemma 5.6.
Lemma 5.8. Let W be a basic substitution calculus. Let a be a pure term; b be a
term in W and n>0. Then
W (a[liftn(cons(b))][liftn(s)])=W (a[liftn+1(s)][liftn(cons(b[s]))])
Proof. By induction on the structure of a. We show only the interesting case which
corresponds to a=m.
 If m>n+ 1, then we have
W (m[liftn(cons(b))][liftn(s)]) =Cor 3:2
W (mâˆ’ n[cons(b)][shift]n[liftn(s)]) =Def 3:4(7)
W (mâˆ’ nâˆ’ 1[shift]n[liftn(s)]) =Cor 5:7
W (mâˆ’ nâˆ’ 1[s][shift]n]) =L 4:5(1)
W (mâˆ’ nâˆ’ 1[s][shift][cons(b[s])][shift]n) =Cor 5:7
W (mâˆ’ nâˆ’ 1[s][shift][shift]n[liftn(cons(b[s]))]) =Cor 3:2
W (m[liftn+1(s)][liftn(cons(b[s]))])
 If m= n+ 1, then we have
W (m[liftn(cons(b))][liftn(s)]) =Cor 3:2
W (1[cons(b)][shift]n[liftn(s)]) =Def 3:4(8)
W (b[shift]n[liftn(s)]) =L 5:7
W (b[s][shift]n) =Def 3:4(8)
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 203
W (1[cons(b[s])][shift]n) =Cor 3:2
W (n+ 1[liftn(cons(b[s]))]) =Def 3:4(9)
W (1[shift]n[liftn(cons(b[s]))]) =Def 3:4(5)
W (1[lift(s)][shift]n[liftn(cons(b[s]))]) =Cor 3:2
W (m[liftn+1(s)][liftn(cons(b[s]))])
 If otherwise m<n + 1, then m6n and the property holds as a consequence of
Corollary 3.2.
Corollary 5.9. Let W be a basic substitution calculus and let a and b be two terms
in W . Then W (a[cons(b)][s])=W (a[lift(s)][cons(b[s])]).
Proof. Taking n=0 in Lemma 5.8, we can conclude that the property holds for pure
terms. Now, W (a[cons(b)][s])=W (W (a)[cons(b)][s]) and W (a) is a pure term by
Denition 3.4(3), so that W (W (a)[cons(b)][s]) is equal to W (W (a)[lift(s)][cons(b[s])])
=W (a[lift(s)][cons(b[s])]).
Lemma 5.10 gives the implementation of a classical substitution fn bg applied to
a term a in terms of the W -normal form of an object in W .
Lemma 5.10. Let W be a basic substitution calculus. Let a and b be pure terms.
Then for every n>1 afn bg=W (a[liftnâˆ’1(cons(b))]).
Proof. By induction on the structure of a, using Corollary 3.2 and Lemma 4.1.
The notion of -reduction is stable by substitution, but this is no longer true when
working with the b-expansion rule: indeed, given a term x of type A ! B, we have
x!b y : A ! B:xy, but xfx  z : A ! B:zg does not reduce via b to (y : A !
B:xy)fx  z : A ! B:zg. The same situation arises in the -calculus a la de Bruijn,
and also when dealing with explicit substitutions: it is not true that a!b b implies
W (a[s])! b W (b[s]) as the following example shows:
Example 5.11. Let us consider the following b-expansion step:
a=1!b ((2 1))= b
Take s= 1. Then W (a[s])= 1 and W (b[s])= ((1) 1) but W (a[s])! b W (b[s])
does not hold.
As in the case of the -calculus a la de Bruijn, we can state a weak property that
will be sucient for our purpose.
204 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
Lemma 5.12. Let W be a basic substitution calculus; a and a0 be pure terms and s
be any substitution in W . If a= a0; then W (a[s])= W (a0[s]); and if a= a0; then
W (a[s])= W (a0[s]).
Proof. By induction on the number of derivation steps of a= a0 or a= a0. If a= a0
(resp. a= a0) in 0 steps (by reexivity), the property is trivial. Otherwise, there is a
term b such that a= b (resp. a= b) in 1 step and b= a0 (resp. b= a0) in n steps
(n>0) so that W (b[s])= W (a0[s]) (resp. W (b[s])= W (a0[s])) holds by induction
hypothesis. Now, if a= b, then if the equality comes from a context closure, one
proceeds by induction on the structure of a, otherwise we consider the two possible
cases. If a= b then a=(a1)a2, b= a1f1 a2g and we have
W (a[s])
=W (((W (a1))W (a2))[s])
=App; Lambda (W (a1[lift(s)]))W (a2[s])!  W (a1[lift(s)])f1 W (a2[s])g
=L 5:10W (a1[lift(s)][cons(a2[s])])
=Cor 5:9W (a1[cons(a2)][s])
=L 5:10W (W (a1)f1 W (a2)g[s])
=W (b[s])
If on the contrary a= b, then b= (a+ 1) and so we have
W (b[s]) = W (((a+ 1))[s])
=Lambda;App W (a+[lift(s)] 1[lift(s)])
=Def 3:4(5) (W (a+[lift(s)]) 1)
=Cor 4:2 (W (W (a[shift])[lift(s)]) 1)
= (W (a[shift][lift(s)]) 1)
=L 5:6 (W (a[s][shift]) 1)
=Cor 4:2 (W (a[s])+) 1)
= W (a[s])
In both cases we obtain W (a[s])= W (a0[s]) (resp. W (a[s])= W (a0[s])) by transi-
tivity.
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 205
Corollary 5.13. Let a and b be pure terms such that a=b. Then, for every substi-
tution s of any basic substitution calculus W we have W (a[s])=W (b[s]).
5.2. The conuence proofs
We proceed now to show the main lemmas of this section, where we can nd the
justication of the general conditions stated in Denition 3.5.
Lemma 5.14. Let W be a basic substitution calculus having the scheme and let o be
an object of W . If o! Beta o0; then
1. if o is a term; then W (o)= W (o0)
2. for every pure term d such that d[o] is a term; and every n>0; we have
W (d[liftn(o)])= W (d[liftn(o
0)])
Proof. We show the property by induction on the lexicographic order induced by the
pair ho; di.
 If o is either a variable or a substitution constant, the properties vacuously hold
because o is in Beta-normal form. We also remark that if o is an application, an
abstraction or a closure, there is nothing to prove for the second property because
d[o] is not a term.
 If o is an application (a b), we then consider two cases for the rst property:
{ If either o0=(a0 b), where a! Beta a0, or o0=(a b0), where b! Beta b0, then the
rst property immediately holds by the induction hypothesis (1) and Denition
3.4(4) since ha; di<h(a b); di and hb; di<h(a b); di.
{ If o0= c[cons(b)], where a=(c), then we have
W (o)=App; Lambda (W (c))W (b) !  W (c)f1 W (b)g
=l 5:10W (W (c)[cons(W (b))])
=W (c[cons(b)])=W (o0)
 If o is a -abstraction a, where a! Beta a0, then the rst property immediately holds
by the induction hypothesis (1) and Denition 3.4(4) since ha; di< ha; di.
 If o is a closure a[v], then we consider two cases for the rst property:
{ o0= a0[v], where a! Beta a0. Since a is a subterm of o, then ha; di<ha[v]; di, so
we have W (a)= W (a0) by the induction hypothesis (1) and W (o)=W (W (a)[v])
=W (W (a0)[v])=W (o0) by Lemma 5.12 and the fact that W -normal forms are
pure terms by Denition 3.4(3).
{ o0= a[v0], where v! Beta v0. Since W (a) is a pure term by Denition 3.4(3), then
W (o)=W (W (a)[v])= W (W (a)[v0])=W (o0) holds by the induction hypothesis
(2) since hv;W (a)i<ha[v]; W (a)i.
 If o is a substitution (s1; : : : ; sj; : : : ; sq) (q > 0), and o0= (s1; : : : ; s0j; : : : ; sq), where
sj! Beta s0j, then there is nothing to prove for the rst property as o is not a term.
For the second property, we proceed by cases on the pure term d.
206 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
{ If d=(d1 d2) or d= d1, then the property follows using the induction hypothesis
(2) since ho; dii<ho; di for i=1; 2.
{ If d=m, we have to prove that for all n>0 we have W (m[liftn(o)])=
W (m[liftn(o
0)]). We proceed by induction on n.
(i) If n=0, we proceed by cases according to Denition 3.3:
(i.1) Suppose that there exist a variable l, indices i1; : : : ; ip (p>0) and sub-
stitutions u1; : : : ; uk (k>0) such that 16i1; i2; : : : ; ip6q, the ijâ€™s are all
distinct and for all s1 : : : sq m[(s1; : : : ; sq)]=W l[si1 ] : : : [sip ][u1] : : : [uk ].
(i.1.1) If j 62 fi1; : : : ; ipg, then the property is trivial since W (m[o])=
W (m[o0])=W (l[si1 ] : : : [sip ][u1] : : : [uk ]).
(i.1.2) If j2fi1; : : : ; ipg, let us say j= ih, then the term W (m[o0]) is
equal to W (l[si1 ] : : : [s
0
ih ] : : : [sip ][u1] : : : [uk ]) where W (l[si1 ] : : :
[sihâˆ’1 ])= e is a pure term by Denition 3.4(3). We have
hsih ; ei<h(s1; : : : ; sq); mi, so by the induction hypothesis (2)
W (e[sih ])= W (e[s
0
ih ]). Since W (e[sih ]) is a pure term, we can
repeatedly apply Lemma 5.12 to obtain:
W (m[o]) =W (W (e[sih ])[sih+1 ] : : : [sip ][u1] : : : [uk ])
= W (W (e[s0ih ])[sih+1 ] : : : [sip ][u1] : : : [uk ])= W (m[o
0])
(i.2) Suppose that there exists an index i (16i6q) such that for all s1 : : : sq
we have m[(s1; : : : ; sq)]=W si.
(i.2.1) If i 6= j, then we trivially have W (m[o0])=W (si)=W (m[o0]).
(i.2.2) If i= j, then W (m[o])=W (sj) and W (m[o0])=W (s0j). Since
hsj; mi<h(s1; : : : ; sj; : : : ; sq); mi, we get W (sj)= W (s0j) by the
induction hypothesis (1).
(ii) If n>0, we consider two cases:
(ii.1) If m6n; then W (m[liftn(o)])=m=W (m[liftn(o
0)]) by Corollary 3.2.
(ii.2) If m>n, then by Corollary 3.2 we have
W (m[liftn(o)])=W (mâˆ’ 1[liftnâˆ’1(o)][shift])
W (m[liftn(o
0)])=W (mâˆ’ 1[liftnâˆ’1(o0)][shift])
Since variables are equivalent with respect to our ordering ho; di, we
have h(s1; : : : ; sj; : : : ; sq); mi= h(s1; : : : ; sj; : : : ; sq); mâˆ’ 1i, and then
we can apply the induction hypothesis on n to obtain
W (mâˆ’ 1[liftnâˆ’1(o)])= W (mâˆ’ 1[liftnâˆ’1(o0)])
Since every W -normal form of a term is a pure term by Denition
3.4(3), the result nally follows from Lemma 5.12, so that
W (m[liftn(o)]) =W (W (mâˆ’ 1[liftnâˆ’1(o)])[shift])
= W (W (mâˆ’ 1[liftnâˆ’1(o0)])[shift])=W (m[liftn(o0)])
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 207
Lemma 5.15. Let W be a basic substitution calculus having the scheme and let o be
an object of W . If o! bEta o0; then
1. if o is a term; then W (o)=W (o0)
2. for every pure term d such that d[o] is a term; and every n>0; we have
W (d[liftn(o)])=W (d[liftn(o
0)])
Proof. If o! bEta (o[shift] 1)= o0 is a root expansion, then o is a term and the second
property vacuously holds since d[liftn(o)] is not a term. The rst property holds since
W (o)= (W (o)+ 1)=cor 4:2(W (W (o)[shift]) 1)=W ((o[shift] 1))=W (o0)
If o! bEta o0 is not a root expansion, one proceeds exactly as in Lemma 5.14, showing
simultaneously the two properties by induction on the lexicographic ordering induced
by the pair ho; di.
Corollary 5.16. Let W be a basic substitution calculus having the scheme and let a
be a term of W such that a!
Beta[ bEta b. Then W (a)= W (b).
Finally, we can obtain property (1) as follows:
Lemma 5.17. Let W be a basic substitution calculus and a be a pure term. If a! b;
then a!W b and if a!b b; then a!W[ bEta b.
Proof. The proof proceeds by induction on the number of steps from a to b. We only
show here the case a!  b, the rest of the proof being straightforward. If a!  b, then
a=C[(c)d] and b=C[cf1  dg]. By lemma 5.10 cf1  dg=W (c[cons(d)]), so
a=C[(c)d]! Beta C[c[cons(d)]]!W C[cf1  dg] = b. Suppose now C[a]!b
C[(a+ 1)], where a!b (a+ 1). Then a is not a -abstraction and is not applied
to another term so by denition a! bEta (a[shift] 1), and by Corollary 4.2 W (a[shift])
is exactly a+, so that (a[shift] 1)!W (W (a[shift]) 1)= (a+ 1) which implies
a!
W[ bEta (a+ 1) and concludes the proof.
Since every basic substitution calculus W satisfying the scheme is conuent and
strongly normalizing, then we can use Lemma 5.17 and Corollary 5.16 to derive con-
uence of W and W [ cEta as follows:
Theorem 5.18 (W is conuent). For every basic substitution calculus W satisfying
the scheme; the relation W is conuent.
Proof. Using Lemma 5.3, where S is , T is , R1 is W and R2 is Beta.
Theorem 5.19 (W [ cEta is conuent). For every basic substitution calculus W hav-
ing the scheme; the relation W [ cEta is conuent.
208 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
Proof. By Lemma 5.3, where S is [b, T is [ , R1 is W and R2 is Beta[ cEta.
6. Conuence for calculi with explicit substitutions
In this section we apply our method to some well-known calculi such as , * ,
, s, v, d, dn and f. The method applies directly to most of them, and needs a
special treatment for -calculi which do not t our denition of substitution calculus,
but that can be translated to some calculus tting the scheme. For that, we require the
following:
Theorem 6.1. Let X be a calculus such that
 X is strongly normalizing.
 X -normal forms of terms are pure terms.
 a! b b implies a!X[ bEta b.
 There is a translation T from X to terms of some substitution calculus W such
that:
 the translation T is the identity on pure terms;
 a!
X[ bEta b implies T(a)!W[ bEtaT(b).
Then X [ cEta is conuent.
Proof. Let a be a term such that b
X[ bEta  a!X[ bEta c. Since X is strongly nor-
malizing we can reduce b and c to their X -normal forms X (b)= b0 and X (c)= c0 so
that b0
X[ bEta  a!X[ bEta c0. By the translation we obtain T(a)!W[ bEtaT(c0) and
T(a) !
W[ bEta T(b0) and by Corollary 5.16 W (T(b0))=bW (T(a))=bW (T(c0))
so that W (T(b0)) !
b k b  W (T(c0)) by Theorem 2.3. Since b0 and c0 are pure
terms by the second hypothesis, then T(b0)= b0 and T(c0)= c0 hold by the fourth
hypothesis and W (b0)= b0 and W (c0)= c0 hold by denition of substitution
calculi. We have b0 !
b k b  c0, which implies, by the second hypothesis, that
b0 !
X[ bEta kX[ bEta c0 and concludes the proof.
In the case of , * , , v, d, dn and f the translation T( ) is simply the
identity, while for the s-calculus one can use for example the translation from s to
v given in [28]. We omit here all the verications concerning the treatment of s but
we refer the interested reader to [30] for full details.
As a summary of the calculi we analyze in this section, we give in the following
table the set of substitutions as well as the representation of variables we use for each
of them. In particular, the variable 1 is always represented by 1 but the representation
of a variable n+ 1 (n>1) changes from one calculus to another.
When using composition, we will often assume the following notations:
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 209
Notation 6.2. We use the notation n for succ(: : : succ| {z }
n times
(0) : : :), ["]n for ["] : : : ["]| {z }
n times
. The
notations n(s) and n(s; u) are dened by induction as follows:
0(s)= id 0(s; u)= u
1(s)= s n+1(s; u)= n (s; (s  u))
n+1(s)= s  n (s)
Note that n(s)  u is dierent from n(s; u) (as we have for example 3(s)  u=
(s  (s  s))  u and 3(s; u)= s  (s  (s  u))), but n(s)  u=Ass n (s; u). Remark also
that n(s; s)= n+1 (s).
Calculus Reference Variable n+ 1 (n>1) Substitutions
 [1] 1[n(")] s ::= id j a  s j " j s  s
* [24] n+ 1 s ::= id j a  s j * (s) j " j s  s
 [42] 1["n ] s ::= "n j a  s j s  s
v [34] n+ 1 s ::= #(a) j * (s) j "
f [19] 1["]n s ::= #(a) j * (s) j "
d [29] 1[n(")] s ::= id j #(a) j * (s) j " j s  s
dn [29] n+ 1 s ::= id j #(a) j * (s) j " j s  s
The rewrite rules of each calculus will be given independently in dierent subsec-
tions, so that we present here the denition of the dierent functions shiftW ; liftW and
consW .
Calculus shift lift(s) cons(b)
 " 1  (s  ") b  id
* " * (s) b  id
 "succ(0) 1  (s  "succ(0)) b  "0
v " * (s) #(b)
f " * (s) #(b)
d " * (s) #(b)
dn " * (s) #(b)
6.1. The calculi ; * and 
The  calculus [1] was introduced as a bridge between the classical -calculus
and concrete implementations of functional programming. It is inspired by de Bruijn
notation [11, 12] and Categorical Combinatory Logic (CCL) [7], it is very useful to
derive machines for the -calculus [25] or to implement higher-order unication [17].
We nd in the -calculus the main features which characterize a calculus of explicit
substitutions: substitutions are incorporated to the language and manipulated explicitly,
terms are divided in two sorts { terms themselves and substitutions { and -reduction
is simulated in two stages, rst by the application of the Beta rule which activates
the calculus of substitutions, then by propagation of the substitution until variables are
210 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
reached. Strong normalization of the -calculus is proved in [10], but the -calculus
does not preserve -strong normalization of terms [39], i.e. there exists a term which is
-strong normalizing but it is not -strongly normalizing. The -calculus is conuent
on closed terms, and remains conuent when meta-variables for terms are added to
the syntax (i.e.,  is conuent on semi-open terms), but is no longer conuent when
variables for substitutions are also considered (conuence fails for open terms). The
rewriting rules of  are
(Beta) (a)b ! a[b  id]
(App) (a b)[s] ! (a[s] b[s])
(Lambda) (a)[s] ! (a[1  (s  ")])
(Clos) (a[s])[t] ! a[s  t]
(VarId) 1[id] ! 1
(VarCons) 1[a  s] ! a
(IdL) id  s ! s
(ShiftId) "  id ! "
(ShiftCons) "  (a  s) ! s
(Ass) (s1  s2)  s3 ! s1  (s2  s3)
(Map) (a  s)  t ! a[t]  (s  t)
To overcome the problem of conuence of , Hardin and Levy introduced in [24]
the * -calculus which considers a new operator, written *, that allows to recover
conuence on the set of open terms [9]. Indeed, the implementation of the lift-function
is much more simpler in the * -calculus: it only uses a unary constructor. As ,
neither the * -calculus preserve -strong normalization [38]. The rewriting rules of
* are
(Beta) (a)b ! a[b  id]
(App) (a b)[s] ! (a[s] b[s])
(Lambda) (a)[s] ! (a[* (s)])
(Clos) (a[s])[t] ! a[s  t]
(Varshift1) n["] ! n+ 1
(Varshift2) n["  s] ! n+ 1[s]
(FVar) 1[a  s] ! a
(FVarLift1) 1[* (s)] ! 1
(FVarLift2) 1[* (s)  t] ! 1[t]
(RVar) n+ 1[a  s] ! n[s]
(RVarLift1) n+ 1[* (s)] ! n[s  "]
(RVarLift2) n+ 1[* (s)  t] ! n[s  ("  t)]
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 211
(Ass) (s1  s2)  s3 ! s1  (s2  s3)
(Map) (a  s)  t ! a[t]  (s  t)
(Shift) "  (a  s) ! s
(ShiftLift1) "  * (s) ! s  "
(ShiftLift2) "  (* (s)  t) ! s  ("  t)
(Lift1) * (s)  * (t) ! * (s  t)
(Lift2) * (s)  (* (t)  u) ! * (s  t)  u
(LiftEnv) * (s)  (a  t) ! a  (s  t)
(IdL) id  s ! s
(IdR) s  id ! s
(LiftId) * (id) ! id
(Id) a[id] ! a
The -calculus is not locally conuent on open terms, so that Ros proposed in [46]
a slight variant, called 0 -calculus, in order to overcome this problem. The -calculus
[42] is a left-linear variant of 0 , which is practical for implementations and does not
poses typing problems when working in higher-order type theories. As well as , the
-calculus is weak normalizing and conuent on semi-open terms. The rewriting rules
of  are
(Beta) (a)b ! a[b  "0]
(App) (a b)[s] ! (a[s] b[s])
(Lambda) (a)[s] ! (a[1  s  "succ(0)])
(Clos) (a[s])[t] ! a[s  t]
(VarCons) 1[a  s] ! a
(Id) a["0] ! a
(Map) (a  s)  t ! a[t]  (s  t)
(IdL) "0  s ! s
(ShiftCons) "succ(n)  (a  s) ! "n  s
(ShiftShift) "succ(n)  "m ! "n  "succ(m)
(Shift1) 1  "succ(0) ! "0
(Shift2) 1["n]  "succ(n) ! "n
212 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
6.2. The calculi v and f
Pierre Lescanne introduces in [34] the v-calculus which preserves -strong normal-
ization [3, 36], but is not conuent on (semi) open terms. The system is very simple as
it has no composition operators for substitutions and has as few forms of substitutions
as possible. As a consequence, it can be derived from our scheme in a very direct way:
we have just to associate a constant to the shift-constant shift, a unary substitution
constructor to the cons-function cons, and another one to the the lift-function lift,
then each of the basic conditions 5, 6, 7, 8 and 9 becomes a rewrite rule; whereas
conditions on substitutions in Denition 3.5 can be immediately deduced from the
calculus which is obtained from the basic conditions. The rewriting rules of v are
(Beta) (a)b ! a[#(b)]
(App) (a b)[s] ! (a[s] b[s])
(Lambda) (a)[s] ! (a[* (s)])
(FVar) 1[#(a)] ! a
(RVar) n+ 1[#(a)] ! n
(FVarLift1) 1[* (s)] ! 1
(RVarLift1) n+ 1[* (s)] ! n[s]["]
(Varshift1) n["] ! n+ 1
The f-calculus was introduced in [19] in order to show preservation of -strong
normalization of d and dn. It is in some sense the minimal calculus of explicit
substitutions that one can expect: it correctly implements the lambda calculus and it
has as few forms of substitutions and rewriting rule schemes as possible. The v-
calculus can also be translated to it [19]. The rewriting rules of f are the following,
where i>0; *0 (s) denotes s and *n (s) denotes * (: : : *| {z }
n times
(s) : : :).
(Beta) (a)b ! a[#(b)]
(App) (a b)[s] ! (a[s] b[s])
(Lambda) (a)[s] ! (a[* (s)])
(FVar) 1[#(a)] ! a
(FVarLift1) 1[* (s)] ! 1
(Shift) a[*i (")][*i (#(b))] ! a
(ShiftLift) a[*i (")][*i+1 (s)] ! a[*i (s)][*i (")]
6.3. The calculi d and dn
Strongly inspired from the -calculus in [46], which was in turn inspired by [18],
we proposed in [29] the d-calculus by putting together the nice properties of the
three previous substitution calculi: we just use unary substitution operators for the lift-
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 213
function and the cons-function, keeping composition of substitutions which is one the
main features needed to describe dierent implementations of functional programming.
The rewriting rules of d are
(Beta) (a)b ! a[#(b)]
(App) (a b)[s] ! (a[s] b[s])
(Lambda) (a)[s] ! (a[* (s)])
(Clos) (a[s])[t] ! a[s  t]
(FVar1) 1[#(a)] ! a
(FVar2) 1[#(a)  s] ! a[s]
(FVarLift1) 1[* (s)] ! 1
(FVarLift2) 1[* (s)  t] ! 1[t]
(Ass) (s1  s2)  s3 ! s1  (s2  s3)
(Shift1) "  #(a) ! id
(Shift2) "  (#(a)  s) ! s
(ShiftLift1) "  * (s) ! s  "
(ShiftLift2) "  (* (s)  t) ! s  ("  t)
(Lift1) * (s)  * (t) ! * (s  t)
(Lift2) * (s)  (* (t)  u) ! * (s  t)  u
(IdL) id  s ! s
(IdR) s  id ! s
(LiftId) * (id) ! id
(Id) a[id] ! a
Note that the MapEnv rule of the -calculus in [46] #(a)  s!* (s)  #(a[s]) is
replaced here by FVar2 and Shift2. This may be in principle superuous, but is es-
sential to make our calculus t in the scheme proposed in this paper. This dierence
makes it possible to prove conuence and strong normalization of d, while conuence
of  is still a conjecture and -strong normalization does not hold [35]. However, the
rule MapEnv is essential if one wants to recover conuence on open terms, 7 and is
at the same time, as explained by [39] and [3], the cause of non termination in many
-calculi with explicit substitutions. Preservation of -strong normalization holds for
d and dn (see [19] for details).
7 Indeed, the open term ((X )a)[s] reduces to both X [#(a)  s] and X [* (s)  #(a[s])], which have no
common reduct in d but can be joined in the -calculus proposed in [46].
214 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
The dn-calculus is just d plus natural numbers to represent variables. It is a natural
extension of d which also satises the abstract properties required by the scheme. To
dene the set of rewriting rules of dn, we add the following set of rules to those of
d:
(Varshift1) n["] ! n+ 1
(Varshift2) n["  s] ! n+ 1[s]
(RVar) n+ 1[#(a)] ! n
(RVarLift1) n+ 1[* (s)] ! n[s  "]
(RVarLift2) n+ 1[* (s)  t] ! n[s  ("  t)]
(RMap) n+ 1[#(a)  s] ! n[s]
It remains now to verify for each calculus presented above not only the exis-
tence of the Lambda; App and Beta rules, but also the basic conditions required
in Denitions 3.4 and the conditions on substitutions appearing in Denition 3.5. We
start by studying the basic conditions.
Theorem 6.3. Every calculus W 2f; *; ; ; f; d; dng is strongly normalizing.
Proof. See [10, 23] for , [24] for * , [34] for v, [42] for  and [19] for f. For
d and dn we proceed as follows. We rst dene a function T from objects in dn
into objects in *:
T(m) = m T(a) = (T(a)) T(* (s)) = * (T(s))
T(") = " T(a b) = T(a)T(b) T(s  t) = T(s) T(t)
T(id) = id T(a[s]) = T(a)[T(s)] T(#(a)) = T(a)  id
Since ddn, then the function T also denes a translation from d to * .
Now, one shows that for every o2d (resp. for every o2dn) such that o! d o0
(resp. o! dn o0), then T(o)!+*T(o0), so that strong normalization of * implies
that of d and dn. For that, it is sucient to check the cases where the reduction
o! d o0 (resp. o! dn o0) takes place at the root of o, verications that we leave to the
reader, for the other cases one proceeds by induction on the object o.
Theorem 6.4. Every calculus W 2f; *; ; ; f; d; dng is conuent.
Proof. A consequence of local conuence and Theorem 6.3, by application of
Newmanâ€™s lemma.
Theorem 6.5. For every calculus W 2f; *; ; ; f; d; dng; all the W -normal forms
are pure terms.
Proof. See [1] for , [24] for * , [34] for v, [42] for  and [19] for f. For d
and dn we proceed as in [46]:
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 215
 Let a2d in d-normal form. We proceed by induction on the structure of a:
If a is 1 the property holds. Now, if a is an application or an abstraction, the
property comes by induction hypothesis. So, let us suppose that a is equal to k[s].
If k is an application (resp. a -abstraction or a substituted term k 0[t]), then App
(resp. Lambda and Clos) can be applied, so k is necessarily the variable 1.
Let us see which are the possible cases for s. If s is #; * or id , then FVar1;
FVarLift1 or Id can be applied, so s is necessarily " or . If s= " we are done
because 1["] is a pure term according to our denition. So let us suppose that
s= t  u. If t is #; *;  or id , then FVar2; FVarLift2; Ass or IdL can be applied,
so t is necessarily ".
Let us show by induction on u that "  u is n(") for some n.
If u is id ; # or *, then IdR; Shift1 or ShiftLift1 can be applied, so u is " or
u1  u2. If u= " we are done because "  " = 2 ("). If u= u1  u2, suppose that
u1 is ; id ; # or *. Then Ass; IdL; Shift2 or ShiftLift2 can be applied, so that
u1 is " and by induction hypothesis u2 is m(") for some m so that u= u1  u2 is
equal to "  m (")= m+1 (").
Now, since s= "  u and u= n (") for some n, then k[s] is equal to 1[n+1(")]
that is a pure term according to our denition.
 Let a2d in dn-normal form. We proceed by induction on the structure of a:
If a is a variable the property holds. Now, if a is an application or an abstraction,
the property comes by induction hypothesis. So, let us suppose that a is equal to
k[s]. If k is an application (resp. a -abstraction or a substituted term k1[t]), then
App (resp. Lambda and Clos) can be applied, so k is necessarily a variable n.
Now, if s is #, then FVar1 or RVar applies. If s is *, then FVarLift1 or RVarLift1
applies. If s is id (resp. "), then Id (resp. Varshift1) applies. So let us see the case
s= s1  s2. If s1 is *, then FVarLift2 or RVarLift2 applies. If s1 is #, then RMap
applies. If s1 is id (resp. "), then IdL (resp. Varshift2) applies. So, s1 = s3  s4 but
in that case Ass applies. We can conclude that a cannot be a term k[s] and thus we
are done.
Theorem 6.6. Every W 2f; *; ; ; f; d; dng veries the basic conditions in
Denition 3.4.
Proof. Every calculus W 2f; *; ; ; f; d; dng is strongly normalizing (Theorem 6.3)
and conuent (Theorem 6.4). On the other hand, W -normal forms are pure terms by
Theorem 6.5 and Property 4 is evident for all the cases, so it remains now to verify
Properties 5, 6, 7, 8 and 9 in Denition 3.4.
 Property 5: we have 1[liftW (s)]=VarCons 1 for W 2f; g, and 1[* (s)]=FVarLift1 1
in *; d; dn; v and f.
 Property 6: We have m+ 1[* (s)]=RVarLift1;Clos m[s]["] in * and dn; m+ 1[* (s)]
=RVarLift1m[s]["] in v; m+ 1[* (s)]= 1["]mâˆ’1["][* (s)]=ShiftLift 1["]mâˆ’1[s]["] =
m[s]["] in f.
216 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
{ For  we have m+ 1[1  (s  ")] = 1[m(")][1  (s  ")]=Clos;Ass 1[m("; ()1  (s 
"))]. If m=1, the
1[1("; (1  (s  ")))]= 1["  (1  (s  "))]=ShiftCons 1[s  "] =Clos 1[s]["]
If m>1, then
1[m("; (1  (s  ")))] = 1[mâˆ’1("; "  (1  (s  ")))] =ShiftCons
1[mâˆ’1("; (s  "))] =Ass
1[m(")  (s  ")] =Clos m[s]["]
{ For :
m+ 1[1  (s  "succ(0))] = 1["succ(mâˆ’1)][1  (s  "succ(0))] =Clos
1["succ(mâˆ’1)  (1  (s  "succ(0)))] =ShiftCons 1["mâˆ’1  (s  "succ(0))]
If m=1, then 1["mâˆ’1  (s  "succ(0))]=IdL 1[s  "succ(0)] =Clos 1[s]["].
If m>1, then 1["mâˆ’1  (s  "succ(0))]= 1["succ(mâˆ’2)  (s  "succ(0))] which is equal
by Clos to 1["succ(mâˆ’2)][s]["succ(0)] =m[s]["].
{ For d:
m+ 1[* (s)]= 1[m(")][* (s)]=Clos 1[m(")  * (s)]=Ass 1[m(";* (s))]
If m=1, then 1[1(";* (s))]= 1["  * (s)]=ShiftLift1 1[s  "] =Clos 1[s]["].
If m>1, then
1[m(";* (s))] = 1[mâˆ’1("; "  * (s))] =ShiftLift1
1[mâˆ’1("; s  ")] =Ass
1[mâˆ’1(")  (s  ")] =Clos m[s]["]
 Property 7: we have m+ 1[k  id] =RVar; Idm in *; m+ 1[#(k)]=RVar m in v and
dn m+ 1[#(k)]= 1["]mâˆ’1["][#(k)]=Shift 1["]mâˆ’1 =m in f.
{ For  we have m+ 1[k  id] = 1[m(")][k  id] =Clos;Ass 1[m("; (k  id))].
If m=1, then 1[1("; (k  id))]= 1["  (k  id)]=ShiftCons 1[id] =VarId 1.
If m>1, then
1[m("; (k  id))]= 1[mâˆ’1("; ("  (k  id)))]=ShiftCons;ShiftId 1[mâˆ’1(")]=m
{ For :
m+ 1[b  "0]= 1["succ(mâˆ’1)][b  "0]=Clos;ShiftCons 1["mâˆ’1  "0]=ShiftId 1["mâˆ’1]=m
{ For d:
m+ 1[#(k)]= 1[m(")][#(k)]=Clos 1[m(")  #(k)]=Ass 1[m("; #(k))]
If m=1, then 1[1("; #(k))]= 1["  #(k)]=Shift1 1[id] =Id 1.
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 217
If m>1, then
1[m("; #(k))]= 1[mâˆ’1("; "  #(k))]=Shift1 1[mâˆ’1("; id)]=IdR 1[mâˆ’1(")]=m
 Property 8: we have 1[k  id] =VarCons k in ; 1[k  id] =FVar k in *; 1[#(k)]=FVar k
in  and f; 1[#(k)]=VarCons k in ; 1[#(k)]=FVar 1k in d and dn.
 Property 9: we have m["] =Varshift1 m+ 1 in *; ; dn, and m["] = 1["]mâˆ’1
["] =m+ 1 in f.
 For  and d: If m=1, then 1["] = 2.
If m>1, then m["] = 1[mâˆ’1(")]["] =Clos 1[mâˆ’1(")  "] =Ass 1[m(")]=m+ 1
 For : If m=1, then 1["succ(0)] = 2.
If m>1, then m["] = 1["succ(mâˆ’2)]["succ(0)] =Clos 1["succ(mâˆ’2)  "succ(0)] =ShiftShift
1["0  "succ(mâˆ’1)] =IdL 1["m] =m+ 1
Theorem 6.7. Every calculus W 2f; *; ; ; f; d; dng veries the scheme in
Denition 3.5.
Proof. We have to verify that for every variable m and every constructor  one of
the conditions described in Denition 3.5 holds. So let us analyze each constructor in
detail:
 For id : one veries for W 2f; *; d; dng, that m[id] =Id m, so that the rst case of
Denition 3.5 applies for n=m; k =0 and p=0.
 For : one veries for W 2f; *; ; d; dng, that for every substitutions s and t we
have m[s  t] =Clos m[s][t], so the rst case of Denition 3.5 applies for n=m; k =0;
p=2; i1 = 1 and i2 = 2.
 For #: let us consider W 2fd; dn; f; vg where we have dened consW (a)= #(a).
If m=1, then by Denition 3.4(8) we have 1[consW (k)]=W k, so that the second
case of Denition 3.5 applies for i=1. Otherwise, by Denition 3.4(7) we have
m+ 1[#(a)])=W m, so the rst case of Denition 3.5 applies for n=m; p=0 and
k =0.
 For *: let us consider W 2fd; dn; f; v; *g where we have dened liftW (s)=* (s). If
m=1, then by Denition 3.4(5) we have 1[* (s)]=W 1, so the rst case of Denition
3.5 applies for n=1; p=0 and k =0. Otherwise, by Denition 3.4(6) we have
m+ 1[* (s)]=W m[s]["], so the rst case of Denition 3.5 applies for n=m; p=1;
i1 = 1; k =1 and u1 = ".
 For : let us consider W 2f; ; *g. If m=1, then 1[a  s] =W a, so the second case
of Denition 3.5 applies for i=1. Otherwise, m+ 1[a  s] =W m[s] so that the rst
case of Denition 3.5 applies for n=m; p=1; i1 = 2 and k =0.
 For ": let us consider W 2f; *; f; d; dn; g where shiftW = ". Then m["] =W m+ 1
by Denition 3.4(9), so that the rst case of Denition 3.5 applies for n=m+ 1;
p=0 and k =0.
 For "k : this constructor only concerns the -calculus, where m["k ] = m+ k, so
that the rst case of Denition 3.5 applies for n=m+ k; p=0 and k =0.
218 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
Theorem 6.8. The non-extensional and extensional versions of ; * ; ; v; d;
dn and f are all conuent.
Proof. The proof comes from Theorems 6.6 and 6.7, by application of Theorems 5.18
and 5.19.
7. Conclusion
We give a general and homogeneous treatment of -calculi with explicit substitutions.
Such treatment is essential in the eld of implementation of functional programming
because of the growing number of such calculi proposed in the literature. The major
contributions of this paper can be summarized by the following points:
 We propose a scheme for -calculi with explicit substitutions which allows to reason
about explicit substitutions in an abstract way. In particular, we are able to deal with
many dierent calculi such as , * ; v; f; ; d; dn and s, using the same
formalism and tools.
 We study conuence of extensional and non-extensional -calculi with explicit sub-
stitutions, where extensionality is interpreted by -expansion. This reading of ex-
tensionality turns out to be much more natural and less complex than previous
interpretations via -contraction.
Our approach turns out to be also useful to derive new calculi with explicit substi-
tutions having nice properties. In particular, d and dn were derived in [29] from the
scheme using an automatic tool to perform completion.
We think that an abstract approach in the spirit of the one proposed in this paper
would also be useful to study conuence on open terms and preservation of strong
normalization, the challenge being the denition of an appropriate scheme associated
to those properties. The scheme proposed in this paper could also be combined with
Combinatory Reduction Systems [32, 33], generalizing in that way the formalisms in
[4, 43] which are dened to just cover one particular explicit substitution calculus.
Acknowledgement
I would like to thank Pierre Lescanne and Gilles Dowek for interesting discussions,
Roberto Di Cosmo and Pierre-Louis Curien for useful comments, and Alejandro Ros
and Paul-Andre Mellies for explaining me some key points in the theory of calculi
with explicit substitutions.
References
[1] M. Abadi, L. Cardelli, P.L. Curien, J.-J. Levy, Explicit substitutions, J. Funct. Programming 4 (1)
(1991) 375{416.
D. Kesner / Theoretical Computer Science 238 (2000) 183{220 219
[2] Y. Akama, On Mintsâ€™ reductions for ccc-Calculus, in: Proc. Int. Conf. on Typed Lambda Calculi and
Applications (TLCA), Lecture Notes in Computer Science, vol. 664, Springer, Berlin, 1993.
[3] Z.-E.-A. Benaissa, D. Briaud, P. Lescanne, J. Rouyer-Degli, , a calculus of explicit substitutions which
preserves strong normalisation, J. Funct. Programming 6 (5) (1996) 699{722.
[4] R. Bloo, K. Rose, Combinatory reduction systems with explicit substitution that preserve strong
normalisation, in: H. Ganzinger (Ed.), Proc. 7th Internat. Conf. on Rewriting Techniques and
Applications (RTA), Lecture Notes in Computer Science, vol. 1103, Springer, Berlin, 1996.
[5] D. Briaud, An explicit eta rewrite rule, in: M. Dezani-Ciancaglini, G. Plotkin (Eds.), Proc. Internat.
Conf. on Typed Lambda Calculi and Applications (TLCA), Lecture Notes in Computer Science, vol.
902, Springer, Berlin, 1995.
[6] P.-L. Curien, Combinateurs Categoriques, algorithmes sequentiels et programmation applicative, These
dâ€™etat, Universite Paris VII, 1983.
[7] P.-L. Curien, Categorical combinators, sequential algorithms and functional programming, Progress in
Theoretical Computer Science, 1st ed., Birkhauser, Basel, 1986.
[8] P.-L. Curien, R. Di Cosmo, A conuent reduction system for the -calculus with surjective pairing
and terminal object, in: Leach, Monien, Artalejo (Eds.), Internat. Conf. on Automata, Languages
and Programming (ICALP), Lecture Notes in Computer Science, vol. 510, Springer, Berlin, 1991,
pp. 291{302.
[9] P.-L. Curien, T. Hardin, J.-J. Levy, Conuence Properties of Weak and Strong Calculi of Explicit
substitutions, Technical Report 1617, INRIA-Rocquencourt, 1992.
[10] P.-L. Curien, T. Hardin, A. Ros, Strong normalisation of Substitutions, MFCSâ€™92, Lecture Notes in
Computer Science, vol. 629, Springer, Berlin, 1992, pp. 209{218.
[11] N. de Bruijn, Lambda-Calculus notation with nameless dummies, a tool for automatic formula
manipulation, with application to the Church-Rosser theorem, Indag. Mat. 5 (35) (1972) 381{392.
[12] N. de Bruijn, Lambda-Calculus notation with namefree formulas involving symbols that represent
reference transforming mappings, Indag. Mat. 40 (1978) 356{384.
[13] R. Di Cosmo, D. Kesner, A conuent reduction for the extensional typed -calculus with pairs, sums,
recursion and terminal object, in: A. Lingas (Eds.), Internat. Conf. on Automata, Languages and
Programming (ICALP), Lecture Notes in Computer Science, vol. 700, Springer, Berlin, 1993.
[14] R. Di Cosmo, D. Kesner, Combining rst order algebraic rewriting systems, recursion and extensional
typed lambda calculi, Internat Conf. on Automata, Languages and Programming (ICALP), Lecture Notes
in Computer Science, vol. 820, Springer, Berlin, 1994.
[15] R. Di Cosmo, D. Kesner, Rewriting with Extensional Polymorphic -Calculus (Extended Abstract), in:
Proc. Annual Conf. of the European Association for Computer Science Logic (CSL), Lecture Notes in
Computer Science, vol. 1092, Springer, Berlin, 1995.
[16] D. Dougherty, Some lambda calculi with categorical sums and products, Proc. 5th Int. Conf. on
Rewriting Techniques and Applications (RTA), Lecture Notes in Computer Science, vol. 690, Springer,
Berlin, 1993.
[17] G. Dowek, T. Hardin, C. Kirchner, Higher-Order Unication via explicit substitutions, Proc. Symp. on
Logic in Computer Science (LICS), 1995.
[18] T. Ehrhard, Une semantique categorique des types dependants. Application au calcul des constructions,
These de doctorat, Universite de Paris VII, 1988.
[19] M.C.F. Ferreira, D. Kesner, L. Puel, -Calculi with Explicit Substitutions and Composition which
preserve -Strong Normalization (Extended abstract), in: M. Hanus, M. Rodrguez-Artalejo (Eds.), Proc.
5th Int. Conf. on Algebraic and Logic Programming (ALP), Lecture Notes in Computer Science, vol.
1139, Springer, Berlin, 1996, pp. 284{298.
[20] T. Hardin, Resultats de conuence pour les regles fortes de la logique combinatoire categorique et liens
avec les lambda-calculs, These de doctorat, Universite de Paris VII, 1987.
[21] T. Hardin, -reduction for explicit substitutions, Algebraic and Logic Programmingâ€™92, Lecture Notes
in Computer Science, vol. 632, Springer, Berlin, 1992.
[22] T. Hardin, Eta-conversion for the languages of explicit substitutions, Applicable Alg. Eng. Commun.
Comput. 5 (1994) 317{341.
[23] T. Hardin, A. Laville, Proof of termination of the rewriting system subst on c.c.l., Theoret. Comput.
Sci., 1986.
[24] T. Hardin, J.-J. Levy, A conuent calculus of substitutions, France{Japan Articial Intelligence and
Computer Science Symp., 1989.
220 D. Kesner / Theoretical Computer Science 238 (2000) 183{220
[25] T. Hardin, L. Maranget, B. Pagano, Functional back-ends and compilers within the lambda-sigma
calculus, 1995, Draft.
[26] G. Huet, Resolution dâ€™equations dans les langages dâ€™ordre 1; 2; : : : ; !, These de Doctorat dâ€™etat,
Universite Paris VII, 1976.
[27] C.B. Jay, N. Ghani, The Virtues of Eta-expansion, J. Funct. Programming (5) (2) (1995) 135{154.
[28] F. Kamareddine, A. Ros, A -calculus a la de Bruijn with explicit substitutions, Proc. Int. Symp. on
Programming Language Implementation and Logic Programming, Lecture Notes in Computer Science,
vol. 982, Springer, Berlin, 1995.
[29] D. Kesner, Conuence properties of extensional and non-extensional -calculi with explicit substitutions,
in: Harald Ganzinger (Ed.), Proc. 7th Internat. Conf. on Rewriting Techniques and Applications (RTA),
Lecture Notes in Computer Science, vol. 1103, Springer, Berlin, 1996, pp. 184{199.
[30] D. Kesner, Conuence of extensional and non-extensional -calculi with explicit substitutions, Technical
Report 1103, LRI, Universite Paris-Sud, 1997.
[31] D. Kesner, Reasoning about redundant patterns, J. Funct. Logic Programming, 1997, to appear.
[32] J.W. Klop, Combinatory Reduction Systems, Mathematical Centre Tracts, vol. 127, CWI, Amsterdam,
1980, Ph.D. Thesis.
[33] J.W. Klop, V. van Oostrom, F. van Raamsdonk, Combinatory reduction systems: introduction and
survey, Theoret. Comput. Sci. 121 (1993) 279{308.
[34] P. Lescanne, From  to v, a journey through calculi of explicit substitutions, in: Ann. ACM Symp.
on Principles of Programming Languages (POPL), ACM, 1994, pp. 60{69.
[35] P. Lescanne, Personal Communication, 1996.
[36] P. Lescanne, J. Rouyer-Degli, The calculus of explicit substitutions , Technical Report, INRIA,
Lorraine, 1994.
[37] M. Mauny, Compilation des langages fonctionnels dans les combinateurs categoriques. Applications au
langage ML, These 3e me cycle, Universite Paris VII, 1985.
[38] P.-A. Mellies, Four typed-lambda calculi with explicit substitutions may not terminate: the rst examples,
1994, Draft.
[39] P.-A. Mellies, Typed -calculi with explicit substitutions may not terminate, in: M. Dezani-Ciancaglini,
G. Plotkin (Eds.), Proc. Internat. Conf. on Typed Lambda Calculi and Applications (TLCA), Lecture
Notes in Computer Science, vol. 902, Springer, Berlin, 1995.
[40] G. Mints, Closed categories and the theory of proofs, Zapiski Nauchnykh Seminarov Leningradskogo
Otdeleniya Matematicheskogo Instituta im. V.A. Steklova AN SSSR 68 (1977) 83{114.
[41] G. Mints, Teorija categorii i teoria dokazatelstv.I, Aktualnye problemy logiki i metodologii nauky, 1979,
pp. 252{278.
[42] C. Mu~noz, A left-linear variant of , in: M. Hanus, J. Heering, K. Meinke (Eds.), Proc. Internat.
Conf. on Algebraic and Logic Programming (ALPâ€™97), Lecture Notes in Computer Science, vol. 1298,
Springer, Berlin, 1997.
[43] B. Pagano, Des calculs de substitution explicite et de leur application a la compilation des langages
fonctionnels, These de doctorat, Universite Pierre et Marie Curie, 1998.
[44] G. Pottinger, The Church Rosser theorem for the typed lambda-calculus with Surjective pairing, Notre
Dame J. Formal Logic 22 (3) (1981) pp. 264{268.
[45] D. Prawitz, Ideas and results in proof theory, Proc. 2nd Scandinavian Logic Symp., 1971, pp. 235{307.
[46] A. Ros, Contribution a lâ€™etude des -calculus avec substitutions explicites, These de doctorat, Universite
de Paris VII, 1993.
[47] V. van Oostrom, F. van Raamsdonk, Weak orthogonality implies conuence: the higher-order case,
Proc. 3rd Internat. Symp. on Logical Foundations of Computer Science, 1994, pp. 379{392.
[48] H. Zantema, Termination on term rewriting: interpretation and type elimination, J. Symbolic Comput.
1 (17) (1994) 23{50.
