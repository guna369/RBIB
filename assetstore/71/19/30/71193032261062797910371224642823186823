Journal of Automated Reasoning 11: 333-351, 1993. 333 
© 1993 by Kluwer Academic Publishers. Printed in the Netherlands. 
Automated Proofs of Equality Problems in 
Overbeek's Competition 
HANTAO ZHANG* 
Department ofComputer Science, The University of Iowa, Iowa City, IA 52242, U.S.A. 
E-mail: hzhang@cs.uiowa.edu 
(Received: 23 February 1993; accepted: 24 May 1993) 
Abstract. This paper reports the detailed computer proofs of nine equality problems in Overbeek's 
competition obtained by Herky, a completion-based theorem prover developed by the author. Advanced 
techniques implemented in Herky made it a high-performance theorem prover for equational reasoning. 
Herky is able to prove the first nine of the ten equality problems in the competition (the tenth is an 
open problem). These equality problems are likely to serve as good exercises for theorem provers based 
on different approaches, and the proofs of these problems may help people to solve them using their 
own theorem provers. 
Key words. Automated theorem proving, equational reasoning. 
1. Introduction 
In the summer of 1990, Ross Overbeek proposed two small competitions on 
constrained aspects of automated eduction - one in basic components of 
resolution theorem proving and one for equality reasoning - with no pretense that 
the winning systems will have to be 'best' in any overall sense. The motivation 
behind such competitions i to encourage researchers to focus on well-defined, 
relevant implementation issues in attacking hard problems. 
The competition for equality reasoning consists of ten problems, many of which 
were considered challenging in the theorem-proving community. During the years 
of 1990-92, we have successfully used the theorem prover Herky I to prove the first 
nine of the ten equality problems, in the style required by the competition: 
Systems must accept as input only the clauses (in whatever format is most convenient); no parameters, 
designation of set of support, or weighting templates are allowed. For equality problems, programs are 
allowed to accept as input a term ordering for each of the problems. 
In this paper, we report only Herky's detailed proofs of these equality problems 
and do not discuss in detail the impact of different techniques implemented in Herky. 
Herky is a general, high-performance equational reasoning prover based on 
rewriting and completion [29] and developed in RRL. 2 The project on Herky started 
in the fall of 1988, when we were trying to convert the RRL code from Franz 
Lisp into Common Lisp. At that time, we also studied the code of Hiper, a high 
performance ompletion-based theorem prover written by Jim Christian [3]. Instead 
334 HANTAO ZttANG 
of merely converting the code of RRL, we decided to rewrite the code of RRL so 
that the new code would have the advantages of both RRL and Hiper. This new 
code was later named Herky [29]. 
The adoption of some advanced techniques in Herky, such as new data structures 
for equations and rewrite rules, the term-indexing technique of discrimination trees 
for fast rewriting and term-sharing [3, 14], constrained rewriting for handling non- 
terminating equations [17], cost-free techniques for detecting unnecessary critical pairs 
[28], the special completion procedures for Abelian group theories and distributivity 
laws [30], etc., is essential for Herky to solve Overbeek's completion problems. 
We consider this paper as a sequel to Lusk and Overbeek's article 'Reasoning 
about equality' [11]. In that article, they offered the complete details of the proofs 
of a set of six equality problems that represent a spectrum in terms of difficulty. 
The proofs were included 'as aids for those who wish to study exactly why their 
systems might be failing to reach a complete proof.' That is also the purpose of 
this paper. We think that the detailed proofs produced by Herky can help someone 
who is experimenting with his own system to track precisely at least one path to each 
proof. We are glad to acknowledge that the development of Herky has benefited 
from that article of Lusk and Overbeek. We sincerely thank Deepak Kapur, Rusty 
Lusk, Bill McCune, Ross Overbeek, Sivakumar, Mark Stickel, and Larry Wos for 
encouragement and enthusiasm shown for our work. 
This paper is organized as follows. In the next section, we list the ten equality 
problems in Overbeek's competition. In Section 3, we present Herky's strategies 
that were used to obtain the proofs of these problems. The details of Herky's proofs 
are presented in Section 4, the major section of this paper. In the last section, we give 
the statistics of Herky on these problems. 
2. The Ten Equality Problems 
In this section we present he ten equality problems in Overbeek's competition; 
following each problem, we also insert a short comment with related references. 
PROBLEM 1. In a group, i f  x • x * x = e for  all x in the group, then the commutator 
h (h(x ,y ) ,y )  = e for  all x and y, where h(x ,y)  = x * y * g(x) * g (y) .  
This problem is Number 4 in Lusk and Overbeek's article [11]. According to 
Lankford, the first computer proof of this problem was reported by Nevin in 1974. 
PROBLEM 2. In a Robbin8 algebra, i f  there exists c, such that o(c, c) = c, then it is a 
Boolean algebra. 
A Robbins algebra is specified by a single axiom n(o(n(o(n(y) ,  x)),  n(o(x, y)))) = x, 
where o is commutative and associative. It is an open problem whether a Robbins 
algebra is Boolean. The first computer proof of Problem 2was obtained by Winker [23]. 
PROBLEM 3. In a ternary Boolean algebra with the third axiom removed, it is true 
that f (x ,  g(x),  y) = y for  all x and y. 
This problem appears in [11] as Number 5. See also [24]. 
AUTOMATED PROOFS OF EQUALITY PROBLEMS 335 
PROBLEM 4. The operator * is associative in the algebra specified by the axiom 
x ,  i ( ( i ( i (y )  • (i(x) * w)) * z) * i (y  , z)) = w. 
The above single-law axiomatization of free groups is from a paper by B. H. 
Neumann [16]. A computer proof of this theorem is reported by U. Martin in [12]. 
See also [9]. 
PROBLEM 5. The Wajsberg algebra formulation of  a conjecture by Lukasiewicz is 
true. 
Larry Wos described this problem in the November 1990 issue of the AAR News- 
letter [25] as a challenge for theorem provers. A computer proof of this theorem was 
first reported by Bonacina [2]. The first automatic proof (in which no auxiliary 
lemmas and functions are needed) of this theorem was obtained by McCune [13]. 
PROBLEM 6. There exists a fixed-point combinator in {B ,W,M},  where 
Bxyz  = x(yz) ,  Wxy  = xyy  and Mx = xx. 
This problem and Problem 8 are taken from a large set of the theorems collected 
by Wos and McCune at Argonne National Laboratory in their experiments in using 
theorem provers to search for fixed point combinators [26]. Computer proofs of 
Problems 6 and 8 appear in [15]. 
PROBLEM 7. A ring in which x * x * x = x for  all x is commutative. 
This problem is the last one in [11]. The first computer proof of this problem was 
obtained by Veroff [20] by carefully encoding the problem into clauses. In 1984, 
Stickel was able to prove this problem automatically using the completion-based 
approach [19]. Later, Wang obtained a proof using his Z-module method [21]. 
Stickel's proof has been reproduced by at least two completion-based theorem 
provers, RRL and SbReve2. This problem is a special case of the theorem that a 
ring in which Vx3n.  x" = x is commutative. For the computer proofs of some cases 
other than n = 3, see [10]o 
PROBLEM 8. There exists a fixed-point combinator in {B, W}.  
See the comment to Problem 6. 
PROBLEM9. The skew-symmetry of  the Kleinfeld function ( f (w ,x ,y ,z )= 
a(w*  x ,y ,z ) -  x*  a (w,y ,z ) -  a (x ,y ,z ) *  w) holds in every alternative ring, where a 
is the associator. 
The book [31] by K. A. Zhevlakov et al. is a good resource for equality problems 
in alternative rings. A variant of Problem 9 has been proved by Anantharaman d 
Hsiang [1]. Wang's Z-module method [21] can easily prove this problem. 
PROBLEM 10. In every right alternative ring, a (x, x, y) * x * a (x, x, y) = 0 is' true, 
where a is the associator. 
The proof of this problem is not known. In 1988, Wang and Stevens, using the 
Z-module method, proved the conjecture that Vn>~l .a (x ,x ,y ) ,a (x ,x ,y ) ,  
xn ,  a(x, x ,y )*  a(x,  x ,y)  = 0 in every right alternative ring [22]. Since Problem 10 
is not an instance of this theorem, the truth of Problem 10 remains open. 
336 HANTAO ZHANG 
3. Herky's Self-Adjusted Strategies 
Herky is a completion-based theorem prover for equality reasoning. The two key 
operations in the well-known Knuth-Bendix completion procedure [6] are 
rewriting (also called demodulation) and superposition (a special case of paramodu- 
lation). In this approach, equations are transformed into rewrite rules by a 
reduction ordering, and these rewrite rules are used to simplify other equations by 
rewriting and to generate new equations by superposition. We assume that the 
reader is familiar with this approach as described in [5]. 
Because there are many ways to handle equations and to control rewriting and 
superposition, and because many problems in Overbeek's completion are very 
challenging, we cannot expect hat Herky can solve all of them using a simple 
default strategy. In the following, we describe briefly Herky's elf-adjusted strategies 
by which all the first nine problems in the previous ection can be solved. Unless 
stated explicitly, these strategies do not pertain to the competition problems. 
3.1. REDUCTION ORDERINGS 
A reduction ordering is a well-founded partial ordering on terms which is stable by 
substitution and instantiation. Herky supports three reduction orderings, each of 
which extends an ordering on function symbols (called precedence) to an ordering 
on terms. 
• The lexicographic recursive path ordering (LRPO) [4]: Used in Problems 1, 3, and 4. 
• The associative-commutative (AC) extension of LRPO (ACLRPO) [7]: Used in 
Problems 2, 7, and 9. 
• The Knuth-Bendix ordering (KBO) [6]: Used in Problems 5, 6, and 8 (the weight 
of each symbol is 1 by default for these problems). 
For the competition problems, Herky automatically chose an ordering as follows: 
the default ordering is LRPO. If there are AC axioms presented in the input, the 
ordering is switched to ACLRPO. If some input equations cannot be made into 
terminating rewrite rules, the ordering is switched to KBO. 
3.2. COMPLETION PROCEDURES 
Herky supports everal extensions of the Knuth-Bendix completion procedure: 
• The standard completion procedure [6]: Used with LRPO. 
• The associative-commutative completion procedure [18]: Used with ACLRPO. 
Moreover, Herky can recognize whether there exists an Abelian group axio- 
matization or distributivity laws in the input; if so, a special completion for these 
theories is turned on. We have found this completion to be very useful in solving 
Problems 7 and 9; however, no comprehensive study has been made of its general 
utility (see [30]). 
AUTOMATED PROOFS OF EQUALITY PROBLEMS 337 
• The unfailing completion procedure [17]: Used with KBO. 
In this procedure, a nonterminating equation is represented as an ordinary rule 
plus a constraint (or condition) which ensures that the left-hand side of the rule is 
greater than its right-hand side. For instance, the equation a(M, x) = a (x, x) can 
be represented as the rule a(x, x) ~ a(M, x) plus the constraint x >XBO M. This 
idea is a generalization (with KBO) of the so-called 'lexically dependent' rewrite 
rules described in [27, Ch. 8]. 
After we implemented the idea of constraint rewriting in Herky, we learned that a 
formal account of this idea appeared in [17] (where the recursive lexicographic 
path ordering instead of the Knuth-Bendix ordering is used in the constraints). 
We found that the Knuth-Bendix ordering is suitable for supporting constraint 
rewriting because (i) the Knuth-Bendix ordering is very flexible (in addition to 
the precedence, the user can also specify the weight of a function); and (ii) it is rela- 
tively easy to reduce constraints to primitive ones. For instance, a(x, x) >r~o (M, x) 
reduces to x >XBO M. The latter is very important o the efficiency of constraint 
rewriting since the constraints are checked very frequently. 
3.3. WEIGHTING 
By default, the size of a term is 1 plus the sizes of its direct subterms, which is the 
number of symbols appearing in this term. An exception to this definition is that 
if the outmost symbol of the term is a Skolem function, its size is considered as 1. 
This exception was first used by Bill McCune and is very important o the proofs 
of Problems 6 and 8. Herky assumes that every function that appears only in the 
negated equations (i.e., disequations) is a Skolem function. 
The same weighting is used both for picking out the next 'lightest' rule for super- 
positions and for discarding 'heavy' equations. To obtain fast proofs, we set some 
criteria to discard some 'heavy' equations. For the competition problems, an 
equation is considered 'heavy' if its size is greater than 30 (the default is 500 for 
general problems). A 'heavy' equation is always discarded except in the completion 
procedure for the theories of Abelian groups and distributivity laws; in this case, an 
equation is discarded if the maximum degree of product terms in this equation is 
greater than 5 (the default is 50). 
3.4. INTRODUCING NEW OPERATORS 
Besides some other conditions, Herky automatically introduces a new function 
symbol (or operator) when one of the following happens: 
• An equation isgenerated in which each side has variables that do not occur in the other 
side [6]. For instance, in Problem 4, (i((x • i(x))) *f2) =f l ( i ( (x l  * i(xl)))) is such 
an example. A new function symbol f3 is automatically introduced which splits the 
above equation into two: (i((x • i(x))) *f2) =f3 andf l ( i ( (x l  * i(xl))) ) =J3. 
338 HANTAO ZHANG 
• A non-constant ground term appears many times in the system. For the 
competition problems, the number is set to 3. For instance, in Problem 8, after 
the term a (W, B) has been generated three times, a new function symbol Ji is 
automatically introduced as shorthand for a(W,B), i.e., a(W,B)=f l .  This 
technique was used by Overbeek in one of his early theorem provers. To avoid 
Herky's generating too many shorthands, we restrictf(cl, c2) from being replaced 
by a new constant if (i) c2 is a constant in the input, and (ii) el is either an input 
constant or a shorthand for g(c3, c4), where both c3 and c4 are in the input. 
Regarding the precedence used in the reduction orderings, if the newly introduced 
operator is a constant, then it is less than any other existing operators in the 
precedence. If the new operator is not a constant, then it is less than any existing 
non-constant operators but greater than any constants in the precedence. In this 
way, if the previous precedence is total, we can always have a total precedence after 
adding new function symbols. 
4. Hcrky's Proofs 
In this section we describe the proofs of the first nine equality problems in 
Overbeek's competition obtained by Herky. Each proof consists of a list of rewrite 
rules (i.e., equations) and disequations. 
Following each rewrite rule we append a message indicating how this rewrite 
rule is obtained. This message should allow the reader (who is familiar with the 
completion-based approach) to reproduce that rewrite rule by hand. For instance, 
if the rewrite rule is made from a critical pair of ll --+ rl and 12 --+ r2, we provide 
the subterm t of l 2 to indicate that the rewrite rule is obtained by superposing 
ll -+ rl into t of 12. That is, t and ll are unifiable with an mgu (most general 
unifier) or, and the critical pair is (~rr2, ~12[t +-- rl] ). 
To save space, we omit most mgu's if they can be simply reproduced by hand. We 
also omit intermediate steps of rewriting and provide only a list of rewrite rules in the 
order they applied to rewrite a given equation. 
During the superposition, two rewrite rules are assumed to be variable-disjoint. In 
Herky, this is done by explicitly renaming x to xb y to Yl, etc., in one rule (for 
instance, if the original rule is numbered as [8], the variable-renamed rule is denoted 
by [8*]). Note that an identifier starting with a lower-case letter from u to z is 
considered as a variable name by Herky. 
Problem 1 
Input  : 
1 f (e ,  x) = x s is a left identity 
2 f(g(x), x) = e there is a left inverse 
3 f(f(x, y), z) = f(x, f(y, Z)) associativity 
4 h(x, y) = f(X, f(y, f(g(X), g(y)))) commutator  
5 f(x, f(x, x)) = e special hypothesis 
6 h(h(a, b), b) := e denial of the theorem 
AUTOMATED PROOFS OF EQUAL ITY  PROBLEMS 339 
Precedence :  h > g > ~ > e 
Proof: 
[1] f(e, x) ~ x { from Input 1. } 
[2] f(g(x), x) - -  e { from Input 2. } 
[3] f ( f (x,  y), z) ~ f(x, f(y, z)) { from Input 3. ) 
[4] h(x, y) --  f(x,  f(y, f(g(z), g(y)))) { from Input 4. } 
[5] f(z, f (z,  z)) ~ e { from Input 5. } 
[6] f(g(x), f(x, y)) - -  y { by superposing [2] into f(x, y) of [3], then reduced by [1]. } 
[7] f(z, f(z, f(x,  y))) ~ y { by superposing [.5] into f(x, y) of [3], then reduced by [3], and [1]. } 
[8] f(x, flY, f(x,  f(y, f(x,  y))))) - -  e { by superposing [3] into f(x, :c) of [5], then reduced by [3]. } 
[10] f(g(gix)),e) ~ x { by superposing [2] into f ix,  y) of[8]. } 
[11] fig(x), e) -- f(x,  x) { by superposing [,5] into f(  x, y) of [6]. } 
[12] f(g(x),g(z)) ~ x { by deleting [10] by [11]. } 
[13] f(g(g(x)), y) ~ f(z,  y) { by superposing [6] into f(x, y) of [6]. } 
[16] g(x) ~ f(x, z) { by superposing [12] into f(x, y) of [6], then reduced by [13]. } 
[19] f(x, e) - -  x { by deleting [12] by [16], then reduced by [5], and [3]. ) 
[21] f(y, f(z,  f(y, f(x, y)))) ~ f(x, ~) { by superposing [8] into f(z, y) of [7], then reduced by [19]. } 
[23] f(z, f(x, f(y, f(z, f(x,  f(y, z)))))) -- f (x , f (y ,  f(x,y))) 
{ by superposing [3] into f(x, y) of [21], then reduced by [3]. } 
[26] f( u, f(x, f(y, f(z, f(u, f(x, f(y, f(z, u)))))))) -- f(x, flY, f(z, f( x, f(y, z))))) 
{ by superposing [31 into f(x, f(y, z)) of [23], then reduced by [3]. } 
[27] f(y, f(x, f(y, f(y, f (x,  y))))) - -  f(x, f(y, x)) 
{ by superposing [21] into f(u, f(x, f(y, f(z, u)))) of [28], then reduced by [19], and [5]. } 
[29] .f(z, f(z, f(x, f(x, f(z, f(x,  y)))))) ~ f(z, f(x,  f(z, y))) 
{ by superposing [27] into f(x, y) of [3], then reduced by [3]. } 
[33] f(z, f(~:, f(u, f(~, :(~, f(~:, flu, f(z, ~)))))))) ~ f(~, f(u, f(z, f(~:, f(u, ~))))) 
{ by superposing [3] into f(z, f(z,  y)) of [29], then reduced by [3]. } 
[34] e ¢ e { from Input 6, then reduced by [4], [3], [6], [16], [3], [5], [7], [19], [33], [7], and [5]. ) 
The detMls of the rewritings in the last step are: 
h(h(u,b),b) # 
f( a, f(b, f(g(a), f(g(b), f(b, f(g(f(a, f(b,f(g(a),g(b))))),g(b))))))) # e 
f(u,fib, f(g(a),fig(fia, f(b,f(g(a),g(b))))),gib))))) C e 
f(a,f(b, fib, f (a, f (a, f (b, f (b, f (a,  fib, f (a, f(a,  fib, e)))))))))))) ¢ e 
f(a,f(b,f(b,f(a,f(a,f(b, fib, f(a,f(b,f(a,f(a,b)))))))))) ) ¢ e 
eCe 
Input 6. 
by [4], [3] 
by [6] 
by [18], [3], [7], [5] 
by [19] 
by [33], [7], [5] 
P rob lem 2 
I nput :  
1 o(x, y) = o(y, x) 
2 o(o(x, y), z) = o(x, o(y, z)) 
3 n(o(n(o(x, y)), n(o(x, n(y))))) = x 
4 o(c ,  c) = c 
S o(n(o(a,  n (b ) ) ) ,  n (o(n(a) ,  n (b) ) ) )  != b 
Precedence :  n > o > c 
commutativity 
associativity 
Robbins' axiom 
special hypothesis 
denial of Huntington's axiom 
It is known that every Huntington algebra (specified by o(n(o(x, n(y))), n(o(n(x), n(y)))) = 
y) is a Boolean algebra. 
Proof: 
[sl] o(x,y) = o(y,x) { from Input 1. "o" is commutative. }
Is2] o(o(x, y), z) = o(z, o(y, z)) { from Input 2. Now "o" is associative and commutative (AC).} 
[11 n(o(n(o(n(y),s:)),n(o(z,y)))) - -x  { from Input 3. } 
[2] o(c, c) ~ e { from Input 4. ) 
340 HANTAO ZHANG 
[3] n(o(n(o(n(e), e)), n(c))) ~ c { by superposing [21 into o(x, y) of [1] with the mgu: [y[e, z[e]. } 
[5] n(o(n(o(n(e), e ~)), n(o(e, ~)))) ~ o(c, ~) 
{ by superposing Extension of [2] into o(x, y) of [1] with the mgu: [yic, z[o(c, Ug)]. } 
[7] n(o(,~(o(n(e), n(e), e)), c)) - n(e) 
{ by superposing [3] into n(o(n(y), x)) of [l] with the mgu: [ylo(n(c), c), z]n(c)]. } 
[9] n(o(n(o(n(o(n(c), e)), n(c), z)), u(o(c, x)))) ~ z 
{ by superposing [3] into n(y) of [1] with the mgu: [ylo(n(o(n(c), c)), n(c))]. } 
[12] n(o(n(o(n(o(n(c), c)), n(e), e)), n(c))) ~ c 
{ by superposing [2] into o(c,x) of [9] with the mgu: [z]c]. } 
[14] n(o(n(o(n(c), u(c), c)), n(c))) ---* c { by superposing [7] into n(o(n(y), z)) of [1] with the mgu: 
[y]o(n(c), n(c), c), x],'.], then reduced by [2]. } 
[15] n(o(n(c), n(c), c)) ~ n(o(n(c), c)) { by superposing [7] into n(o(z, y)) of [1] with the mgu: 
[y]c, z]n(o(n(c), n(e), c))], then reduced by [14]. } 
[16] n(o(n(o(n(c), c)), c)) ---* n(c) { by deleting [7] by [15], then reduced by [15]. } 
[23] o(n(o(n(c), c)), c) - e 
{ by superposing [16] into n(o(c, x)) of [5] with the mgu: [z]n(o(n(c), e))], then reduced by [12]. } 
[26] o(n(o(n(c), c)), z) ~ x { by superposing Extension of [23] into o(x, y) of [1] with the mgu: 
[ytc, x]o(n(o(n(c), c)), us)]: then reduced by [9]. } 
[3:1] ,~(Ü(n(o(,~(c), ~, ~)), n(~))) -- 
{ by superposing [26*] into o(n(y), x) of [1] with the mgu: [ylo(n(c), c), xxlz]. } 
[34] n(o(n(n(z)), n(z))) -~ n(o(n(c), c)) { by superposing [26*] into o(n(y), x) of [1] with the mgu: 
[x]n(o(n(c),c)), xtln(y)], then reduced by [26]. } 
[44] n(n(o(n(n(z)), x))) ~ n(n(x)) { by superposing [34*] into n(o(n(y), z)) of [1] with the mgu: 
[x, lY, z[n(n(y))], then reduced by [26]. } 
[45] n(n(n(x))) ~ n(z) { by superposing [34*] into n(o(z, y)) of [1] with the mgu: 
[yln(n(xl)), zln(xl)], then reduced by [44], and [26]. } 
[47] n(o(n(n(z)), x)) ~ n(x) { by superposing [44] into n(n(a:l)) of [45*] with the mgu: 
[x;lo(n(n(x)), z)], then reduced by [451. } 
[53] n(n(x)) ---* z { by supetposing [33] into n(zl)  of [45*] with the mgu: 
[xllo(n(o(n(c), c, x)), n(x))], then reduced by [33]. } 
[5,5] n(o(x, x)) ---* n(x) { by deleting [47] by [53]. } 
[57] o(z, z) ~ ~ { by superposing [55*] into n(x) of [53] with the mgu: [zlo(xt, xt)], 
then reduced by [53]. } 
[6.31 o(n(o(n(v), ~)), n(o(~, U))) ~ n(~) 
{ by superposing [1] into n(zl) of [53*] with the mgu: [xl]o(n(o(n(y), z)), n(o(x, y)))]. } 
[64] b # b { from Input 5, then reduced by [63] ~nd [53]. } 
Note  that  in the messages fo l lowing [5] and [26], respectively, the extension of  [2] is 
o(c, c, u9) ~ o(c, u9), and the extension of  [23] is o(n(o(n(e), e)), c, u9) ~ o(e, u9). See 
[18] for  the reason for using extension rules in the AC complet ion  procedure.  
Prob lem 3 
Input: 
I f(~(v, ~, x), y, f(v, w, z)) = f(v, ~, f(x, y, z)) 
2 f (y ,  x, x) = x 
3 f(x, x, y) = x 
4 f(g(y), y, x) = x 
5 f(a, g(a) ,  b) != b denial of the theorem 
Precedence: f > g 
Proof: 
[1] f( f(x,  y, z), u, f(x, y, v)) -- f(z, y, f(z, u, v)) { from Input 1. } 
[2] f(z,  V, Y) - -  Y { from Input 2. } 
[3] f(x, x, y) - -  x { from Input 3. } 
[4] f(g(x), z, y) ~ y { from Input 4. } 
[5] f(x, y, f(z, f(x,  y, z), u)) - -  f(x, y, z) { by superposing [3] into f(f(x, y, z), u, f(z, y, v)) of [1]. } 
[6] f(x, y, x) - -  z { by superposing [3] into f(z, y, z) of [1], then reduced by [3]. } 
[7] f(z, y, f(z, f(z, y, u), u)) -- f(x, y, u) { by superposing [2] into f(f(x, y, z), u, f(z, y, v)) of [1]. } 
AUTOMATED PROOFS OF EQUAL ITY  PROBLEMS 341 
[8] f ( f (x ,  u, y), z, u) ~ f (x ,  u, f (y,  z, u)) { by superposing [2] into f (x ,  y, v) of [1]. } 
[11] f ( f (u ,x ,y ) , z ,u )~f (u ,x , f (y , z ,u ) )  { bysuperposing [6] into f(x, y, v) of[1]. } 
[19] f(a:, z , f (x ,y , z ) )  ~ f ( z ,y , z )  { by superposing [6] into f ( z ,u ,y )  of [8]. } 
[25] f ( f ( z ,  y, f (z ,  w, u)), v, w) - -  f ( f ( z ,  y, z), w, f ( f (x ,  y, u), v, w)) 
{ by superposing [1] into f(z,  u, y) of [8]. } 
[31] f (x ,y , f ( z ,y , z ) ) - -  f (x ,y , z )  { bysuperposing [3]into f ( z , f ( z ,y ,u ) ,u )o f [7 ] .  } 
[44] f (z ,  y, f (z ,  u, f (x ,  y, v))) ---, f ( z ,  y, f (z ,  u, v)) 
{ by superposing [31] into f (x ,  y, v) of [1], then reduced by [t]. } 
[66] f(~, f(v, ~, ~), f(v, z, u)) - -  f(v, ~, ~:) 
{ by superposing [.5] into f (z ,  u, f(z,  y, v)) of [44], then reduced by [2]. } 
[7[] f ( z , f (y , z , z ) , z ) - - f (y , z ,x )  { bysuperposing [2] into f(y, z, u) of[66]. } 
[72] f (x ,  f (z ,  y, x), z) - -  f (z ,  y, z) { by superposing [6] into f(y,  z, u) of [66]. } 
[89] f ( f (x ,u ,z ) ,y , z )~f (z , f (x ,u ,z ) , f ( z ,y , z ) )  { bysuperposing [72] into f (u ,x ,y )  of[ l l J .  } 
[97] f ( f (x ,  y, z), f (z ,  g, u), u) ~ f (z ,  y, u) 
{ by superposing [66] into f (z,  y, z) of [72], then reduced by [66]. ) 
[292] f(f(y,~,z),f(v,z,u),u) ~ f (v ,z ,u )  { by superposing [19] into f (x ,y , z )  of [97]. } 
[318] f ( f ( z ,  y, x), u, f (x ,  u, z)) --~ f (x,  u, z) 
{ by superposing [71] into f(y,  z, u) of [292], then reduced by [71], [6], and [25]. } 
[349] f ( f (x ,y , z ) ,u , f (y ;u ,z ) )  ~ f (y ,u ,z )  { by superposing [71] into f ( z ,y ,x )  of [318]. } 
[371] f(y,  f(z,  g(z), y), f (x ,  z, y)) --~ y 
{ by superposing [4] into f(y,  u, z) of [349], then reduced by [4], and [89]. } 
[386] f (y,  g(Y), x) --~ x { by superposing [3] into f (x ,  z, y) of [371], then reduced by [72]. } 
[387] b # b { from Input .5, then reduced by [386]. } 
P rob lem 4 
Input: 
1 i ( z  * i ( z ) )  * ( i ( i ( (x  * W) * y) * x) * i (y ) )  = 
2 (a  * b )  * c != a * (b  * c )  
Precedence:  i > * 
group axiomatization 
denial of associativity 
Proof: 
[11 
[2] 
(i((x * i(a))) * (i((i(((y * z) * u)) * y)) * i(u))) - -  z { from Input I. } 
( i ( ( i ( ( (x*y )*z ) ) *z ) ) * i ( z ) )~fa(y )  { by superposing [1'] into (y * z) of [1] with the mgu: 
[yli((xt * i(xt))), zl(i((i(((yl * zl) * ul)) * Yl)) * i(ul))] to generate 
(i((z * i(x))) * (i((i((z, * u)) * i((zl * i(xt))))) * i(u))) = (i((i(((y * zt) * y)) * z)) * i(z)), 
which is split by the new operator fa. } 
[4] ( i ( (x* i (x ) ) ) * f l (y ) )  - -y  { by deleting [1] by [2]. } 
[5] ( i (x )* i ( i ( ( f l (x )*y) ) ) ) - - - * f l (y )  {bysuperpos ing[4] in to ( i ( ( (x*y )*z ) ) *x )o f [2 ] .  } 
[6] (i((i((y * z)) * i((z * i(z))))) * i(z)) - -  f t ( f t (Y) )  { by superposing [4] into (x * y) of [2]. } 
[8] f l ( f l ( i ( (x  * i(z))))) - -  f2 
{ by superposing [4] into (Yl * zl) of [6"] with the mgu: [Yl [i((z * i(z))), zl [fa(Y)] to generate 
(i((i(y) * i((xl * i(zt))))) * i ( f l (y))) = f l ( f l ( i ( (x  * i(x))))), which is split by the new operator f2. } 
[10] f l ( i ( (x  * i(x)))) - -  f3 
{ by superposing [8*] into fl (Y) of [4] with the mgu: [Ylfl (i((xi * i(a:t ))))] to generate 
(i((x * i(x))) * f2) = f l ( i ( (z l  * i(xl)))), which is split by the new operator f3. } 
Ill] ( i ( ( z* i ( z ) ) ) * f2 )~f3  { by the same source as [lO]. } 
[12] ft(f3) - -  f2 { by deleting [8] by [lO]. } 
[13] (i(fa) * i(i((f2 * x)))) - -  fl(;c) { by superposing [12] into f l (z) of [5]. } 
[14] i((z * i(z))) - -  f4 { by superposing [10"] into f l (Y) of [4] with the mgu: [yli((zt * i(x~)))] 
to generate (i((x * i(z))) * fa) = i((xi * i(xt))), which is split by the new operator f4. } 
[1.5] (f4 * f3) - -  f4 { by the same source as [14], then reduced by [14]. } 
[16] (f4 * f l(x)) ~ x { by deleting [4] by [14]. } 
[17] ( i ( ( i ( (x*y ) ) * f4 ) ) * i (y ) ) - - f l ( f l (x ) )  { by deleting [6] by [i4]. } 
[19] fl(f4) - -  f3 { by deleting [10] by [14]. } 
[20] ( f4* f2 ) - - f3  { by deleting [ll] by [14]. } 
[22] i(((x * i(x)) * f4)) ~ f4 { by superposing [14] into i(z) of [14]. } 
[24] fl (i(fa (x))) - -  (i(z) * i(f4)) { by superposing [14] into i((ft (2:) * y)) of [5]. } 
[25] ( i ( ( f4*z ) ) * i ( i ( (x*y ) ) ) )~f l (y )  {bysuperpos ing[14] in to i ( ( (z*y)*z ) )o f [2] .  } 
[28] f l ( i ( fz) )  - -  (i(f4) * i(f4)) { by superposing [19] into f l (z )  of [24]. } 
342 HANTAO ZHANG 
[29] i (f ,  (x)) ~ (./:4 * (i(x) * i(f4))) { by superposing [24] into f l (z )  of [16]. } 
[32] i ( f3 )~( f4* ( i ( f4 )* i ( f4 ) ) )  { by superposing [28] into fl(z) of[16]. } 
[33] ( ( f4* ( i ( f4 )* i ( f4 ) ) ) * i ( i ( ( f2*x ) ) ) )~f l ( z )  { by deleting [13] by [32]. } 
[34] i((f3 * (f4 * (i(f4) * i(f4))))) ~ f4 { by superposing [32] into i(x) of [14]. } 
[46] ( i ( ( f4*x ) ) * i ( f4 ) )~f l ( i ( z ) )  {bysuperpos ing[22] in to i ( ( (ac*y)*z ) )o f [2 ] .  } 
[51] f l ( i ( i ( f4)))  - -  (]'4 * i(f4)) { by superposing [14] into i((f4 * z)) of [46]. } 
[53] i ( i ( f4) ) - - - * ( f4*( f4* i ( f4) ) )  { by superposing [51] into f1(x) of[16]. } 
[77] (i((f4 * f4)) * i((f4 * (i(f4) * i(f4))))) ~ f,(f2) 
{ by superposing [20] into (z * y) of [25], then reduced by [32]. } 
[78] (i((f, • /4) )  • (h  • (f,  * i(f4)))) --, f2 
{ by superposing [1.5] into (z * y) of [25], then reduced by [12], and [53]. } 
[79] (i((f4 * f4)) * i ( i(z))) ---, fl (fl (z)) { by superposing [16] into (z * y) of [25]. } 
[81] (f4 * (i(A) * i(f4))) --.,. f4 
{ by superposing [2,5] into (z'* i(z)) of [14], then reduced by [32], and [19]. } 
[82] (J'4 * i ( i ((fz * z)))) ---* ft(z) { by deleting [33] by [81]. ) 
[83] i((fz * f4)) ---' f4 { by deleting [34] by [81]. } 
[94] ft(i(A)) ---* f l ( f2 )  { by deleting [77] by [81], then reduced by [46]. } 
[99] i(f4) - -  fz { by superposing [94] into ft(z) of [16], then reduced by [16]. } 
[107] (i((f4 * z)) * f2) ~ fl (i(z)) { by deleting [46] by [99]. } 
[119] (i((h * .f4)) * h )  ~ f2 { by deleting [78] by [99], then reduced by [15], and [20]. } 
[125] (]'2 * f2) - -  f3 { by superposing [83] into i((z * Y)) of [25], then reduced by [19], [99], and [15]. } 
[126] f~(f2) --, f~ 
{ by superposing [125] into (z * y) of [25], then reduced by [15], [125], [99], [32], and [20]. } 
[129] f2 ~ f4 { by superposing [126] into fl(z) of [16], then reduced by [15]. } 
[130] (]'4 * f4) ---* f3 { by deleting [20] by [129]. } 
[131] (,(4 * i(i((f4 * z)))) ---* £(z)  { by deleting [82] by [129]. } 
[138] (i((f4 * z)) * f4) "-" f l  (i(x)) { by deleting [107] by [129]. } 
[145] (f4 * i ( i(z))) ~ ft(ft(z)) 
{ by deleting [79] by [130], then reduced by [15], [130], [129], [99], and[32]. } 
[146] f3 - -  f4 { by deleting [119] by [130], then reduced by [15], [130], [129], [99], and[32]. } 
[147] f l ( f~(( f4 * x))) --, f~(x) { by deleting [131] by [145]. } 
[153] fi((f4 * x)) - -  z { by superposing [147] into ft (x) of [16], then reduced by [16]. } 
[154] i( i(z)) --,- f l ( f l ( f l ( z ) ) )  { by superposing [14,5] into (./'4 * z) of [153]. } 
[156] (i(x) • fd f~( f t ( ( f t ( z )  * y))))) --+ f~(y) { by deleting [5] by [154]. } 
[158] (i((.t'4 * ~)) * f t ( f~ (f~((z • y))))) --, f~(y) { by deleting [25] by [154]. } 
[163] fd fd f~( (z  * i(x))))) - .:4 
{ by superposing [14] into i(z) of [154], then reduced by [129], and [99]. } 
[16.5] i((A * (i(x) * A))) ~ f1 ( fd f t ( fdx) ) ) )  
{ by superposing [29] into i (z) of [154], then reduced by [129], and [99]. } 
[172] f~(f,((:~ • i(~)))) - -  :4 { by superposing [163] into ft(z) of [16], then reduced by [146], and [130]. 
[173] f~ ((x * i(z))) ~ f4 { by superposing [172] into f~ (z) of [16], then reduced by [146], and [130]. } 
[174] (x * i(z)) - -  .:4 { by superposing [173] into ft(z) of [16], then reduced by [146], and [130]. } 
[175] (i(~) • f~(fdf l ( .~))) )  ~ A { by superposing [154] into i(zl) of [174"]. } 
[177] (i((i((f4 * y)) * z)) * i(y)) - -  ft  ( i(z)) { by superposing [174] into (z * y) of [2]. } 
[178] (i((f4 * x)) * f l ( f l  (x))) --* f4 { by superposing [153] into fl (;gl) of [175"]. } 
[179] ( f , ( f , ( f l (X ) ) )  * f l ( f t ( f l ( i ( z ) ) ) ) )  - -  f4 { by superposing [154] into i (z l )  of [17.5"]. } 
[181] ( i ( ( f4* ( f4*z ) ) ) *  fl(z))---~ f4 {bysuperposing[153]intof1(zl)of[178*].} 
[189] f l ( i ( ( i (z )  * f4))) - -  ( f , ( f t ( f t ( f t ( z ) ) ) )  * ]'4) { by superposing [165] into i((f4 * z)) of [138]. ) 
[192] i (( i(z) * f4)) - -  (f4 * ( f t ( f l ( f l ( f l ( z ) ) ) )  * f4)) { by superposing [189] into fl(x) of [16]. ) 
[193] ((f4 * (f] (f] (fl (f, ((x * y))))) * f4)) * i(y)) ~ f,  (fl(z)) { by deleting [17] by [192]. ) 
[208] ((Y4 * ((Y4 * Ci(~') * :4)) * f4)) */4) - y~(/~(f~(L( i(~)))))  
{ by superposing [179] into ( f~(z i )  * Yl) of [156"], then reduced by [146], [19], [129], [99], and[29]. } 
[209] ( i ( ( i ( ( f l (z)  * z)) * i(y))) * i(z)) ~ f t ( fd fd f~( ( f~(y)  * ~))))) 
{ by superposing [156] into (x * y) of [2]. } 
[214] ((f4 * (i(z) * f4)) * ./'4) ~ (f4 * i(z)) 
{ by superposing [178] into (i((f4 * yl)) * x l )  of [177"], then reduced by [153], [29], [129], and [99]. } 
[218] ((Y4 * (:4 * i ( z ) ) ) ,  :4) ~ f , ( f t ( f~(f~(iO:)))))  { by deleting [208] by [214]. } 
[221] (f4 * i((f4 • z))) ~ (i(z) • .:4) 
{ by superposing [181] into (i((f4 * U~)) * ~1) of [177"], then reduced by [153], [29], [129], ~nd [99]. } 
[225] i ( ( f4*z ) )~f~( ( i ( z ) * f4 ) )  { by superposing [221] into (f4*z)0f[153]. } 
AUTOMATED PROOFS OF EQUAL ITY  PROBLEMS 343 
{229] 
[23.5] 
[236] 
[246] 
[251] 
[2541 
[256] 
[257] 
[260] 
[267] 
[271] 
[272] 
[273] 
[274] 
[275] 
[280] 
[287] 
[288] 
[311] 
[312] 
[319] 
[326] 
[329] 
[331] 
[336] 
[339] 
[344] 
[345] 
[349] 
[350] 
[353] 
[371] 
[372] 
P rob lem 5 
Input : 
1 i(T,x) = x 
2 i ( i (x ,y ) , i ( i (y , z ) , i (x , z ) ) )  = T 
3 ±( i (x ,y ) ,y )  = i ( i (y ,x ) ,x )  
4 i ( i (n (x ) ,n (y ) ) , i (y ,x ) )  = 2" 
S i(i(i(a,b),i(b,a)),i(b,a)) != Y 
( f l ( ( f l ( ( i (x )  * ]'4)) * f4)) * f l(x)) ~ ]'4 { by deleting [181] by [225], then reduced by [225]. } 
( f i ( ( i (x )  * f4)) * f4) ~ f l  ( i (x)) { by deleting [138] by [225]. } 
( f t ( ( i (x )  * f4)) * f l ( f l ( f l ( (x  * y))))) ~ £(y)  { by deleting [158] by [225]. } 
( f l ( f t ( i ( z ) ) )  * f l (z))  ~ f4 { by deleting [2291 by [235]. } 
(fl(f1(f1((i(x) * f4))))* z )~ f4 
{ by superposing [153] into f l (x l )o f  [246"], then reduced by [225]. } 
((f4 * ( f l ( f t  (fl(m))) * f4)) * f4) ~ f l ( f l ( z ) )  { by superposing [246] into ( f l (x )  * y) of [156], 
then reduced hy [146], [19], [129], [99], [1541, and [291. } 
(fl ( ( f l ( f I ( f l (~)))  * h ) )  * f4) -'* fl ( f l ( f l  (fl (x)))) 
{ by superposing [154] into i(xl) of [235"], then reduced by [154]. } 
( :1( :1( i (~)) )  • /4 )  -* f l ( / , ( ( i (~)  • :4))) 
{ by superposing [225] into i (x l )  of [235"], then reduced by [225], and [235]. } 
(fl (fl (fl (fl (fl (X))))) * f4) -"* fa (fl ((fl (fl ()el (Z))) * f4))) 
{ by superposing [154] into i (x l )  of [257"], then reduced by [154]. } 
((f4 * ( f l ( f1 (z ) )  * f4)) * f4) ~ f l ( z )  { by superposing [251] into (f l(x) * if) of [156], 
then reduced by [146], [19], [16], [254], [129], [99], [192], and [29]. } 
((f4 * ( f , ( z )  * f4)) * f4) "-* z { by superposing [153] into f l ( z~)  of [267"], then reduced by [153]. } 
( (h  * (z * f4)) * ]'4) - -  (f4 * z) { by superposing [153] into f l (z t )  of [271"]. } 
((f4 * (f4 * x)) * f4) ---* (f4 * (f4 * (x * f4))) { by superposing [272] into (x * f4) of [272]. } 
(]'4 * (f4 * (i(~) * f4))) - -  f~(f l  ( f l ( f l ( i (x ) ) ) ) )  { by deleting [218] by [273]. } 
fx ((z * ]'4)) - -  f l  ( f l (z)) { by superposing [272] into ((z * y) * z) of [2], then reduced 
by [16], [272], [129], [99], [154], [29], [235], and [225]. } 
fl (fl (ft (fl (fl (fl (~)))))) -- fl (f! (fl (fl (x)))) 
{ by deleting [256] by [275], then reduced by [275], and [260]. } 
f l ( f , ( f~( i (x ) ) ) )  - -  f ,( i(z:)) { by deleting [235] by [275], then reduced by [275], and [257]. } 
( fa ( f l ( i (x ) ) )  * f l ( f~(£( (z  * y))))) ~ f l (Y)  { by deleting [236] by [275]. } 
(x * f4) - -  f l  (x) { by superposing [275] into fl (x) of [16], then reduced by [16]. } 
( f l ( fa ( f l ( f~( (z  * y))))) * i(y)) - -  f l ( f1 (z ) )  { by deleting [193] by [311], then reduced by [16]. } 
(]4 * m) - -  f , (z)  { by deleting [272] by [311], then reduced by [16], and [311]. } 
Y, (£ (£ (£ (fl (~))))) - A (A (fl (fl (~)))) 
{ by deleting [192] by [311], then reduced by [280], [319], [311], [129], [99], [154], and [29]. } 
f , ( f t ( i ( z ) ) )  ~ f l( i(x)) { by deleting [274] by [311], then reduced by [287], and [319]. } 
A(A(~:)) - -  ~ { by deleting [16] by [319]. } 
ft (x) ~ z { by deleting [280] by [326], then reduced by [331]. } 
( i(x) * (z * y)) - -  y { by deleting [288] by [329], then reduced by [336]. } 
((z * y) * i(y)) - -  x { by deleting [312] by [331], then reduced by [336]. } 
( i ( ( i ( (z * z))  * i(y))) * i(x)) - -  (y * z) { by deleting [209] by [336], then reduced by [336]. } 
(y * i((z * y))) - -  i(x) { by superposing [339] into (x * y) of [344]. } 
i ((x • y)) - -  (i(y) • i (z))  { by superposing [344] into (xl * Yl) of [349*]. } 
((y * (z * x)) * i (z))  - -  (y ,  z) { by deleting [34.5] by [350], then reduced by [350], [336], and [L54]. } 
((z • ~) • u) ~ (~ * (~ * u)) 
{ by superposing [344] into (zi * xl) of [353*], then reduced by [336], and [t54]. } 
(a* (b* c)) # (a* (b* c)) { from Input 2, then reduced by [371]. } 
denial of the theorem 
Precedence:  i > n > a > b > T 
Proof: 
[1] i (T ,x )  ~ x { from Input 1. } 
[2] i ( i (x,  y), i( i(y, z), i(z, z))) --, T { from Input 2. } 
[3] i ( i (z,  y), y) ~ i( i(y, x), x) { from Input 3. } 
[4] i ( i (n(x),  n(y)),  i(y, m)) ~ T { from Input 4. } 
[5] i( i(n(m), n(T) ) ,  z) ~ T { by superposing [1] into i(y, x) of [4]. } 
344 HANTAO ZHANG 
[8] i(x, i(i(x, y), y)) ---. T { by superposing [1] into i(x, y) of [2], then reduced by [1]. } 
[42] i(x, x) ---* T { by superposing [1] into i(x, y) of [8], then reduced by [1]. } 
[48] i(i(v, x),i(i(x, V), T)) ~ T { by superposing [42] into i(z, z) of [2]. } 
[49] i(x, T) ---, T { by superposing [1] into i(v, x) of [48], then reduced by [42], [1], and [3]. } 
[,501 i(y, i(z, y)) ~ T { by superposing [49] into i(x, y) of [2], then reduced by [1]. } 
[51] i(i(i(x, y), V), x) ~ i(v, x) { by superposing [50] into i(x, y) of [3], then reduced by [3], and [1]. } 
[52] i(i(i(z, x), y}, i(x, y)) --~ T { by superposing [50] into i(z, Y) of [2], then reduced by [1]. } 
[531 i(i(x, y), i(x, i(z, y))) ~ T { by superposing [50] into i(v, z) of [2], then reduced by [1]. } 
[62] i(y, i(z, i(~, y))) --~ T { by superposing [50] into i(x, y) of [53], then reduced by [1]. } 
[70] i(z,i(i(i(y,z),x),x)) ---~T { by superposing [3] into i(z,i(x,y)) of [62]. } 
[82] i(n(y), i(y, x)) --~ T { by superposing [4] into i(i(y, z), x) of [70], then reduced by [1]. } 
[83] i(z, i(i(z, a:), i(y, x))) ~ T { by superposing [2] into i(i(y, z), x) of [70], then reduced by [1]. } 
[89] i(n(z), i(x, i(z, y))) ---* T { by superposing [82] into i(x, y) of [53], then reduced by [1]. } 
[92] i(n(z),i(i(i(z,y),x),x)) --~ T { by superposing [3] into i(x,i(z,y)) of [89]. } 
[130] i(n(n(~)), x) ~ T { by superposing [5] into i(i(z, y), x) of [92], then reduced by [1]. } 
[137] i(x, n(n(x))) ~ T { by superposing [130] into i(n(x), n(y)) of [4], then reduced by [1]. } 
[140] n(n(x)) ~ x { by superposing [137] into i(x, y) of [3], then reduced by [130], and [1]. } 
[142] i(i(x, n(T)), u(x)) ~ T { by superposing [140] into n(x) of [5]. } 
[155] i(x, n(T)) --  n(x) { by superposing [142] into i(x, y) of [3], then reduced by [82], and [1]. } 
[I.56] i(n(i(y, x)), n(x)) ~ T { by superposing [1.55] into i(i(z, x), y) of [52], then reduced by [155]. } 
[157] i(i(x, y), i(n(y), n(x))) - -  T { by superposing [155] into i(y, z) of [2], then reduced by [155]. } 
[158] i(u(i(y, n(x))), x) ~ T { by superposing [140] into n(x) of [156]. } 
[162] i(n(i(i(n(y), ~e), x)), y) ~ T { by superposing [3] into i(y, n(x)) of [158]. } 
[18.3] i(n(i(i(x, y), y)), n(x)) --* T { by superposing [140] into n(y) of [162]. } 
[184] i(n(i(y, x)), y) ~ T { by superposing [82] into i(n(y), x) of [162], then reduced by [1]. } 
[196] i(i(x, y), i(n(i(x, z)), y)) ~ T { by superposing [184] into i(x, y) of [2], then reduced by [1]. } 
[227] i(n(y), n(z)) -- i(x, Y) { by superposing [157] into i(x, y) of [3}, then reduced by [4], and [1]. } 
[228] i(x, n(y)) --  i(y, n(x)) { by superposing [140] into n(y) of [227]. } 
[229] i(n(y), x) --  i(n(x), y) { by superposing [140] into n(x) of [227]. } 
[230] i(n(y), i(z, n(i(x, y)))) ~ T { by superposing [227] into i(x, y) of [8], then reduced by [228]. } 
[2:~1] i(u, u(i(~, n(i(~, y))))) --, i(y, ~) 
{ by superposing [227] into i(x, y) of [51], then reduced by [140], and [228]. } 
[244] i(y, i(i(y, x), i(n(x), z))) - -  T { by superposing [229] into i(y, x) of [83]. } 
[2701 i(n(i(x, z)), i(i(z, y), y)) --  T 
{ by superposing [183] into i(y, x) of [244], then reduced by [229], [1], and [140]. } 
[281] i(x, i(n(z), i(i(x, y), y))) ~ T 
{ by superposing [183] into i(x, y) of [270], then reduced by [140], [228], [1], and [229]. } 
[288] i(y, i(x, i(i(y, z), z))) ~ T { by superposing [140] into n(z) of [281]. } 
[293] i(y,i(i(i(i(y,z),z),x),x)) - -T  { by superposing [3] into i(x,i(i(y,z),z)) of [288]. } 
[313] i(i(x, y), n(i(y, n(i(y, ~))))) ~ x 
{ by superposing [231] into i(x, y) of [3], then reduced by [1], [230], and [229]. } 
[327] i(i(x, Yl, i(n(y), if x, z))) ~ T { by superposing [229] into i(n(i(x, z)), y) of [196]. } 
[398] i(i(y, x), n(i(i(x, y), y))) ~ n(x) 
{ by superposing [227] into i(y, x) of [313], then reduced by [227], [140], and [228]. } 
[4t 11 ,~(i(u, n(i(u, ~)))) ~ ,~(i(~, u(i(~,, u)))) 
{ by superposing [231] into i(y, x) of [313], then reduced by [1], [230], and [229]. } 
[414] i(x, i(9, n(i(y, z)))) ---., i(x, i(z, u(i(z, y)))) 
{ by superposing [41 I] into n(y) of [227], then reduced by [140], and [228]. } 
[479] i(y, i(n(z), i(i(y, z), x))) ~ T 
{ by superposing [327] into i(i(i(y, z), z), x) of [293], then reduced by [1]. } 
[480] i(9, i(i(z, x), i(i(9, z), ~))) ~ T 
{ by superposing [2] into i(i(i(y, z), z), x) of [293], then reduced by [1]. } 
[481] i(z, i(z, i(i(x, n(z)), y))) ---* T { by superposing [140] into (z) of [479], then reduced by [228]. } 
[483] i(n(y), i(z, i(i(x, y), z))) --~ T { by superposing [227] into i(9 , z) of [479], then reduced by [140]. 
[593] i(n(y), i(x, i(z, n(i(z, i(x, Y))))-)) --~ T { by superposing [414] into i(;e, i(i(x, Y), z)) of [483]. } 
[59,5] i(y, i(z, i(z, n(i(z, i(x, n(y))))))) ~ T { by superposing [414] into i(z, i(i(x, n(z)), Y)) of [481]. } 
[725] i(n(i(i(z, Y), x)), i(z, n(i(y, x)))) ~ T 
{ by superposing [480] into i(z, i(~:, y)) of [593], then reduced by [1], and [228]. } 
[729] i(x, i(i(i(y, x), i(x, y)), y)) --* T 
{ by superposing [398] into i(z, n(i(y, x))) of [725], then reduced by [140], and [228]. } 
AUTOMATED PROOFS OF EQUALITY PROBLEMS 345 
[730] i(i(z, y), i(z, i(i(z, z), y))) -+  T 
{ by superposing [72,5] into i(z, i(2, n(y))) of [595], then reduced by [1], [140], and [228]. } 
[736] i(x, i(z, i(i(z, i(z, y)), y))) -- T 
{ by superposing [730] into i(i(i(y, z), z), z) of [293], then reduced by [1]. } 
[742] i(i(y, z), i(i(z, y), i(z, z))) - -  T { by superposing [2] into i(z, i(z, y)) of [736], then reduced by [1]. } 
[7.53] i(x, i(i(z, i(2, y)), i(z, y))) ~ T 
{ by superposing [742] into i(i(i(y, z), z), 2) of [293], then reduced by [1]. } 
[761] i(i(z, i(x, y)), i(z, i(z, y))) --* T 
{ by superposing [753] into i(z, i(z, y)) of [736], then reduced by [1]. } 
[766] i(z, i(z, y)) -- i(z, i(z, y)) { by superposing [761] into i(z, y) of [3], then reduced by [761], and [1]. } 
[772] i(y, i(i(y, i(i(z, y), z)), z)) ~ T 
{ by superposing [227] into i(y, 2) of [729], then reduced by [227], [766], [140], and [228]. } 
[773] T # T { from Input 5, then reduced by [3], [766], and [772]. } 
P rob lem 6 
Input : 
1 a(a(a(B, x), y), z) = a(x, a(y, z)) combinator  B 
2 a(a(W, x), y) = a(a(x, y), y) combinator  W 
3 a(M, x) = a(x, x) combinator  M 
4 a(y, f (y))  != a( f (y) ,  a(y, f (y) ) )  denial of the theorem 
Precedence: a > f > B > W > M 
Proof: 
[1] a(a(a(B,z),y),z)--a(z,a(y,z))  { from Input I. } 
[2] a(a(x, y), y) ~ a(u(W, r), y) { from Input 2. } 
[3] a(z, x) -- a(M, z) { from Input 3. } 
[4] (a(f(z), a(z, f(x))) # a(x, f(x))) { from Input 4. } 
[9] (a(f(a(a(B,z),U)),a(z,a(v,f(a(a(B,z),V))))) # a(z,a(y,.f(a(a(B,x),V))))) 
{ by superposing [1] into a(z, f(z)) of [4], then reduced by [l]. } 
[10] a(a(W,a(B,z)),y) ---* a(¢,a(M,y)) 
{ by superposing [2] into a(a(a(B, x), y), z) of [1], then reduced by [3]. } 
[28] a(x,a(M,u(W,a(B,z)))) ~ a(M,a(W,a(B,z))) 
{ by superposing [3] into a(a(W, a(B, z,)), Yl) of [10"]. } 
[66] (a(f(a(a(B, a(a(B, z), y)), z)), a(z, a(y, a(z, f(a(a(B, a(a(B, x), y)), z)))))) # 
a(x, a(v, a(z, f(a(a(B, a(a(B, z), V)), z)))))) 
{ by superposing [1] into a(zl, a(yl, f(a(a(B, zl), YI)))) of [9"] with the mgu: 
[27 [a(a(B, z), y), zma(y,, f(a(a(B, u(a(B, x), y)), Yl )))], then reduced by [1]. } 
[67] a(M, a(W, u(B, f(a(a(B, a(a(B, M), W)), B))))) # a(M, a(W, a(B, f(a(a(B, a(a(B, M), W)), B))))) 
{ by superposing [28*] into a(f(a(a(B, a(a(B, z), y)), z)), a(x, a(y, a(z, f(a(a(B, a(a(B, 2), y)), z)))))) 
of [66] with the mgu: [21 [f(a(a(B, a(a(B, M), W)), B)), xlM, y(W, zlB ]. } 
Prob lem 7 
Input: 
1 (x + y) = (y + x) 
2 (x + y) + z = x + (y + z) 
3 (x + O) = • 
4 (x + i (x))  = 0 
S ((x * y) * z) = (x*  (y * z)) 
6 (x * (y  + z ) )  = ( (x  * y)  + (x * z ) )  
7 (* + y) * z = (x * z) + (y*  z) 
8 (x * x * x) = • 
9 (a * b) != (b * a) 
Precedence: * > i > + > 0 
Proof: 
[.l] 
[.2] 
commutat iv i ty  of + 
assoc iat iv i ty  of + 
0 is a r ight ident i ty  of + 
there is a r ight inverse of + 
assoc iat iv i ty  of * 
d is t r ibut iv i ty  
d is t r ibut iv i ty  
special  hypothes is  
denia l  of the theorem 
(z + y) = (y + x) { from Input 1. "+" is commutative. } 
((x + y) + z) = (z + (y + z)) { from Input 2. "+" is associative and commutative. } 
346 HANTAO ZHANG 
Is3] (x+O)----z { from Input 3. "O" is the unit o f "+ ' .  } 
Is4] (z + i(z)) = 0 { from Input 4. 'T' is the inverse of "+". } 
[sh] z * (y * z)  = (z  * y) • z { from Input 5. "*" is associative: }
Is6] (z • (y + z)) = ((z * y) + (z • z)) ( from Input 6. %" left-distributes over "+". ) 
Is7] ( ( r  + y) * z)  = ( (z  * z) + (y*  z))  { from Input 7. %" right-distributes over "+". } 
[1] ( z  * z * z )  --* z { from Input 8. } 
[2] ((~*x*v)+(~*v*~)+(~*v*v)+(v*~,~)+(v,~,v)+(v,v,~:))--,o 
{ by superposing Is6] into (z • z) of [1], then reduced by [1]. } 
[3] (6x) ---* 0 { by superposing [1] into (z * z * V) of [2], then reduced by [1]. } 
[4] (3(z * z)) ---* (3z) { by superposing [1] into (z • V) of [2], then reduced by [1]. } 
[5] (3(V * z)) - -  (3(z * V)) { by superposing Is6] into (z * z) of [4], then reduced by [4]. } 
[6] ((~*y**)+(~*z*v)+(v*~*=)+(v,z,~)+(z,~,v)+(z,u,~))-- .o 
{ by superposing Is6] into ( r ,  x) of [2]. then reduced by [6], [4]. and [1]. } 
[7] ((y * z * y * y) + (y .  y ,  z * y)) -* (2(i((x * y))) + 2(i((y * z)))) 
{ by superposing [1] into (x ,  y) of [6], then reduced by [1]. } 
Is] ( (v*~*v*:)+(v*~*'-*u)+(v*~*z*z)+(v,v,~**)+(v,z,~,v)+(v***~**)+ 
( :*~*v*v)+( ' -*~*v*~)+(z*~***v)+(z ,u ,~,v)+(z ,v ,~,z)+(z ,~,~,v)) - - ,o  
{ by superposing Is6] into (y ,  y) of [7], then reduced by [7]. } 
[9] ((~ * • * u) + (~ * v * ~) + (v * • * ~)) ~ (3(~ • v)) 
{ by superposing (xt * Yl * zl) of [6*] into (z * y * y) of [2], then reduced by [2], and [4]. } 
[10] ((~*v*v*~)+ 2(v*~,~,v))~(3(~,v)) 
{ by superposing (xl * zl * Yl * zl) of [8*] into (y .  z * y • z) of [8], 
then reduced by [4], [9], [7], and [l]. } 
[11] ( (x*Y*z*x)+(z*z*y*z )+2(y*~*x ,z )+2(z ,x ,~,y ) ) - - .O  
{ by superposing Is6] into (y ,  y) of [10], then reduced by [lO], [4], and [1]. } 
[13] (2 (~*z*u*y)+2(x*n*z*y)+2(y*z*u*x)+2(y*u .z ,x )+(z .x .y .u )+(z ,y ,z ,u )  + 
(u*x*y*  z )+(u*y ,x ,  z)) ~0 
{ by superposing Is6] into ( z ,  x) of [l 1], then reduced by [11], [10], [7], [9], [4], and [1]. } 
[14] (2 (~*z*v*~*z)+(v ,z ,~,~,~)+(z ,~,~,z ,v )+2(z ,z ,v ,~,~) )~ 
(2i((x * y • z)) + i((y • ~, • z)) + i((z • x * y)) + 2i((z • y ,  x))) 
{ by superposing [1] into (u ,  y) of [13], then reduced by [7], and [1]. } 
[I5] (2(~*v*v*z*v)+(v*v*~*v,z)+2(v,z ,v ,v ,~)+(z ,v ,~,v ,v) ) - .~ 
(2i((z * z * y)) + i((y * x * z)) + 2i((y * z * z)) + i((z * z * y))) 
{ by superposing [1] into (y ,  u) of [13], then reduced by [14], and [1]. } 
[16] ( z , z .y ,x ,x )~(2 i ( ( z ,x .y ) )+ i ( (x .y .x ) )+2 i ( (y .x . z ) ) )  
{ by superposing [1] into (zl * za * xl) of [14"], then reduced by [9], [4], [15], and [1]. } 
[18] ( (x*x*Y*Y)+(z*y*~*y)+2(y*z*y ,x )+2(y ,y .z ,x ) ) - - .O  
{ by superposing (Yt * ~t * xt * yt) of [lO*] into (y* x * z * y) of [8], 
then reduced by [9], [4], [7], [13], [16], [6], and [1]. } 
[19] (2(~,~,v*~)+ 2(~,~,~,v)+ 2(~,y,~,~)+ 2(~,z ,~,v )+(v ,~,z ,~)  + 
(u*~*~*~)+C~*~*v*~)+(~*v*~*~)) -o  
{ by superposing Is6] into (x * x) of [18], then reduced by [18], and [1]. } 
[21] (2(v • ~)) --, (2(~ •u)) 
{ by superposing [1] into (x * x * z) of [19], then reduced by [1], [4], [6] and [3]. } 
[22] (y* x) ~ (z * y) { by deleting [5] by [21]. } 
[23] (b* a) :# (b * a) { from Input 9, then reduced by [22]. } 
Note that Equations [ l]-[sT] are all built into Herky so that every equation will be 
simplified by [sl]-[sT] into a form of pl = P2, where Pl and P2 are polynomials and 
every monomia l  of  p2 is less (by ACLRPO)  than a monomia l  o fp l .  (6x) in rule [3] is 
shorthand for (x + x + x + x + x + x). 
In the message following rule [9], we see an example of not superposing the whole 
left-hand side of  a rule into a subterm of  the left-hand side of another rule. Suppose 
tl +P l  ~ ql and t 2 +P2 '+  q2 are two rewrite rules, where + is AC and t l and t2 are 
unifiable with an mgu or. Then a new equation, i.e., ap2 + crql = aPl + aq2, can be 
generated from these two rewrite rules. This new equation can be generated 
from the extensions of tl +P l  --+ ql and t 2 +P2 ---+ q2 by the conventional (AC) 
AUTOMATED PROOFS OF EQUALITY PROBLEMS 347 
superposition. However, the conventional superposition is very expensive because it 
involves the AC unification of  +. For rule [9], we avoided the superposition between 
the extensions of rules [2] and [6] and simply unified tl = (Xl *Yl *Zl) and 
t2 = (x ,  y ,  y). [9] is thus derived inexpensively. The same technique was used to 
derive rules [10] and [18] and in Problem 9. 
Prob lem 8 
Input: 
1 a(a(a(B, x), y), z) = a(x, a(y, z)) combinator B 
2 a(a(W, x), y) = a(a(x, y), y) combinator W 
3 a(y, f(y))  != a( f (y) ,  a(y, f (y)))  denial o~ the theorem 
Precedence:  a > f > B > 
Proof: 
[1] a(a(a(B, x), y), z) --, a(x, a(y, z)) { from [nput 1. } 
[2] a(a(x,y),y) ---* a(a(W,x),y) { from Input 2. } 
[3] (a(f(x), a(x, f(x))) 7£ a(x, f(x))) { from Input 3. } 
[41 a(a(W, a(V, ~)), ~) --  a(a(W,a(W,v)),~:) 
{ by superposing [2*] into a(x, y) of [2] with the mgu: [x]a(xi, y), y~ lY], then reduced by [2]. } 
[5] (~(f(a(a(B,~),V)),a(~,a(V,f(a(a(B,~),V))))) # ~(~,a(v,f(a(a(m~),V))))) 
{ by superposing [t*] into a(~, f(x)) of [3], then reduced by [1]. } 
[6] aO(W,.(m~)),v)~a(~,~(V,V)) 
{ by superposing [2] into a(a(a(B, xl),yl),zJ of [1"] with tile mgu: bla(B,~),ytz,,y,m]. } 
i7] a(.(~(w, B), ~), V) --* a(~, ~(~, V)) 
{ by superposing [2] into a(a(B, xi), Yi) of [l*] with the mgu: [x]B, Y]Yl, xi]yJ. } 
[9] a(W, B) ~ fl { from the system-generated shorthand. }
[10] ~(a(~,(W,W),B),~)--~a(B,a(m~)) 
{ by superposing [2] into a(a(W, B), xt) of [7*] with the mgu: [x]W, y]B, z]]B]. } 
[12] a(a(f,, J:), y) --+ a(x, a(x, y)) { by superposing [9] into a(W, B) of [7]. } 
[44] a(f(a(a(B,a(a(B,z),y)),z)),a(x,a(y,a(z,f(a(a(B,a(a(B,x),y)),z)))))) # 
.(~, ~(v, a(z, f(a(u(B, ~(a(B, ~), V)), z))))) 
{ hy superposing [1] into a(zl, a(yl, f(a(a(B, zt), Yl)))) of [.5*] with the mgu: 
[xi la(a(B, z), y), z]a(yl, f(a(a(B, a(a(B, x), y)), y~ )))], then reduced by [1]. } 
[56] a(W, W) ~ ]'2 { from the system-generated shorthand. }
[57] a(fl, W) ~ f3 { from the system-generated shorthand. }
[62] a(W, a(W, z)) -.-* a(f3, z) { by superposing [57*] into a(ft, x) of [12] with the mgu: [x[W]. } 
[65] a(a(f2, B), z) ~ a(B, a(B, x)) { by superposing [56] into a(W, W) of [10"]. } 
[113] a(B, W) ~ f4 { from the system-generated shorthand. }
[116] a(a(f4, x), y) ~ a(W, a(x, y)) { by superposing [113"] into a(B, x) of [1] With the mgu: [xlW ]. } 
[159] a(.(W, ~(A, v)), ~) --* .(~(fs, y), ~) 
{ by superposing [116"] into a(x, y) of [2], then reduced by [62], and [4]. } 
[186] a(f2, B) ~ f5 { from the system-generated shorthand. }
[188] a(B, a(B, z)) --~ a(fh, z) { by superposing [186] into a(f2, B) of [65]. } 
[196] a(fl, B) ---* ]'6 { from the system-generated shorthand. ) 
[199] a(£,x) ~ a(f6,z) 
{ by superposing [196] into a(fn x) of [12] with the mgu: [xlB ], then reduced by [188]. } 
[508] a(a(fs, z'), a(f4, ~)) -- a(f~, a(f4, z)) 
{ by superposing [2] into a(a(W, a(f4, y)), x) of [159], then reduced by [56]. } 
[688] a(f4, B) ~ f7 { from the system-generated shorthand. }
[690] a(W, a(B, x)) ~ a(fT, x) { by superposing [688] into a(f4, z) of [116] with the mgu: [xlB]. } 
[703] .(w, ~(f~, .)) --. ~(fs, .(m *)) 
{ by superposing [690*] into a(W, x) of [62] with the mgu: [xla(B, xl)]. } 
[707] a(a(fT, x), y) ---+ aQ:, a(y, y)) 
{ by superposing [690*] into a(W, a(B, z)) of [6] with the mgu: [z~lx]. } 
[768] a(a(y, a(x, x)), z) -- a(a(f3, a(B, y)), ~:) 
{ by superposing [707*] into a(z, y) of [2] with the mgu: [zla(fT, xt), Vl IV], then reduced by [7O3]. } 
348 HANTAO ZHANG 
[1144] a(a(f3, a(f6, x)), y) -- a(z, a(a(W, y), y)) 
{ by superposing [11 into a(a(y, a(z, x)), x) of [768], then reduced by [1991, [lS8], and [2]. } 
[1463] a(x, a(f2, a(f4, a(f6, r)))) --+ a(f2, a(f4, a(f6, x))) 
{ by superposing [508] into a(a(fa, a(f6, x)), y) of [1144], then reduced by [508], and [159]. } 
[1464] a(.f~, a(f4, a(f6, f(a(a(B, a(a(B, f2), f4)), f6))))) ~ a(f2, a(f4, a(f6, f(a(a(B, a(a(B, f2), f4)), f6))))) 
{ by superposing [1463"] into a(f(a(a(B, a(a(B, x), y)), z)), a(x, a(y, a(z, f(a(a(B, a(a(B, x), y)), z)): 
of [44] with the mgu: [xt [f(a(a(B, a(a(B, f2), f4)), f6)), xIf2, Ylf4, zlfs]. } 
Prob lem 9 
Input : 
1 x+y=y+x 
2 x + (y + z) = (x + y) + z 
3 X + 0 = X 
4 x + - (x )  = 0 
S (x * (y + z) )  : ((x * y) + (x * z ) )  
6 ( (x  + y) * z )  = ( (x*  z )  + (y * z ) )  
? (x * y) * y = x * (y * y) 
8 (x * x) * y = x * (x * y) 
9 a(x,  y, z) = ((x * y) * z) + - (x  * (y * z ) )  
10 
ii 
commutativity of + 
associativity of + 
0 is a right identity of + 
there  is a right inverse of + 
distributivity 
distributivity 
right alternative law 
left alternative law 
the associator 
f(w, x, y, z) = a((w * x) ,  y, z) + - (x  * a (w,y ,z ) )  + - (a (x ,y ,z )  * w) 
the Kleinfeld function 
f(e, b, c, d) + (f(b, e, c, d)) != 0 denial of the theorem 
Precedence:  f > a > * > - > + > 0 
Proof: 
[sl] (~ + y) = (~ + ~) 
[~2] 
Is3] 
Is4] 
Is6] 
[1] 
[2] 
[3] 
[41 
{ from Input 1. "+" is commutative. }
(x + (y + z)) = ((x + y) + z) { from Input 2. "+" is associative and commutative. }
(x + O) = • { from Input 3. "0" is the unit of "+". } 
(x + - ( z ) )  = 0 { from Input 4. "i" is the inverse of "+". } 
(x * (y + z)) = ((x * y) + (z * z)) { from Input 5. "*" left-distributes over "+". } 
((x + y) * z) = ((x * z) + (y * z)) { from Input 6. '%" right-distributes over "+". ) 
(z * (y * y)) ~ ((z * y) * y) { from Input 7. } 
(z*  (z*  y)) ~ ((x* x) * y) { from Input 8. } 
a(z, y, z) -~ (((z * y) * z) + -((z  * (y * z)))) { from Input 9. } 
f (x ,y , z ,u )~( ( ( (x*y)*z )*u)+( (y* (z*u) ) *x )+(y* (x* (z*u) ) )  + 
- ( ( f l y  • _~) • ~) • ~)) + - ( ( (~ • ~) • ( z ,  u))) + - ( (y  • ( (~,  z) • ~)))) 
{ from Input 10, then reduc(~d by [3]. } 
[5] (x * ((x * x) * y)) ~ ((x * x) * (x * y)) { by superposing [2] into (x * y) of [2]. } 
[6] (y * ((y * z) * x)) ---* (((y * y) * z) * x) { by superposing [1] into (x * y) of [2], then reduced by [1]. 
[7] ((~ • (~ • z)) + (~ • (z • y))) ~ (((~ • y) • z) + ((~ • z ) ,  y)) 
{ by superposing Is6] into (y * y) of [1], then reduced by [1]. } 
IS] ((~ • (.- • ~))  + (z • (y • ~)))  - ( ( (y  • z) • ~) + ((z • y) • ~)) 
{ by superposing Is6] into (x * y) of [2], then reduced by [2]. } 
[9] (z * (y * x)) - -  ((x * y) * x) { by superposing [2] into (z * (y * z)) of [7], then reduced by [i]. } 
[10] ((~ • ~) • (~ • ~))  - ( ( (~ • ~) • y) • ~) 
{ by superposing [9] into (x * y) of [2], then reduced by [2], and [9]. } 
[16] ((~ • ~) • (~ • y)) ~ (((~ • ~) • ~) • y) 
{ by superposing [5] into (x * (y * z)) of [7], then reduced by [9], and [1]. } 
[ ls] (~ • ((~ • ~) • y))  - ( (~ • y) • (~ • y)) 
{ by superposing [6] into (x * (y * z)) of [7], then reduced by [2], and [9]. } 
[21] ((y • ~) • (y • ~)) --, (((~ • ~) • y) • ~) 
{ by superposing [6] into (y * (z * x)) of [8], then reduced by [2], Ill, and [16]. } 
[~4] (y • ((~ • ~) • ~))  - ( f ly  • ~) • ~) • ~) 
{ by superposing [10] into (y * (z * x)) of [8], then reduced by [1], and [16]. } 
[26] ((x * y) * (y* x)) ~ (((x * y) * y) * x) { by superposing [18] into (x * (y* z)) of [7], 
then reduced by [51, [lO], [9], [2], [2I], [181, [11, [24], and [16]. } 
AUTOMATED PROOFS OF EQUALITY PROBLEMS 349 
[29] (u , O: , (z , v))) - ((u , (O: , v) , z)) + (u , ((~ , z) , v)) + (,, , ((y , z) , ~:)) + 
- ( ( (u * (y * z)) * x)) + - ( ( (u * z) * (y * z)))) { by superposing (x * (y * z)) of [7] 
into (Yl *zt) of [7"], then reduced by [18], [16], [5], [10], [24], [i], [2], [6], [9], [21], and [26]. } 
[34] ((x • ((v * ~) * ~)) + (x * ((v * u) • z)) + (~,  ((z • u ) ,  y)) + (~ • ( (~,  z ) ,  v))) 
(((~ • (~,  u)) • v) + ((~ * (u • .-)) • v) + ((~ * v) * (z • u)) + ( (x ,  v) * (u • z))) 
{ by superposing [29] into (x * (y* z)) of [7]. } 
[37] ((u* ((z * y) * z)) + (u* ((z * z) * y)) + - ( (y*  ((x* z) * u))) + - ( (y*  ((u* x) * z))) + 
- (  (y*  ((u * z) * x))) + - ( (u  * ((y * z) * x)))) - -  (((u * (x , y)) , z) + ((u , z) , (x , y)) + 
- ( ( (v  * (~ * :)) * u)) + - ( ( (v  * u) • (x • _-))) + - ( ( (v  * u) • (: • ~))) + - ( ( (u  • y ) ,  ( . - ,  ~)))) 
{ by superposing (y * (z * .~)) of [8] into (zl * zl) of [8"], then reduced by [29]. } 
[38] ((~ • ( : ,  v)) + - ( (y  * (~ * ~)))) ~ (((~ • ~) • v) + - ( ( (v  * ~) * ~))) 
{ by superposing (Yl * (zl * xl)) of [8*] into (z * (y * z)) of [7], then reduced by [37], and [29]. } 
[44] ( ( z* ( (x*y)*u) )+(z* ( (u ,x ) ,y ) )+(z , ( (u ,y ) , z ) ) ) - - ( ( (y ,x ) , ( z ,u ) )  + 
((-" * (~ * v)) * u) + ((z • u ) ,  (~ • v)) + ((z • u) • (v * x)) + - ( ( ( (v  * ~) * -') * ~))) 
{ by superposing [29] into (z * (z * y)) of [38], then reduced by [5], [6], [211, [18], [9], [26], 
[21, [24], [1], [29], and [16]. } 
[45] (x ,  ((u • z ) ,  y)) - -  ( ( ( (u ,  z) • x) • y) + ( (x ,  (u • z ) ) ,  y) + - ( ( (u ,  z) • (x • y)))) 
{ by deleting [34] by [44], then reduced by [44]. } 
[61] 0 ¢ 0 { from Input 11, then reduced by [4], [8], and [45]. } 
Note that equations [sl]-[s7] are built into Herky and are used to simplify every equation. 
In the last step, Input 11 is rewritten by [4] to 
(b* (e* (c*d) ) )+(e , (b , (c ,d ) ) )+- ( ( (b ,c ) ,d ) ,e )+- ( ( (e ,c ) ,d ) ,b )  + 
- ( (b ,  c) • (c • d)) + - ( (c  • b) • (c • d)) + - (b  • ( (~,  c) • d)) + - (e  • ((b • c) • d)) + 
( ( ( (b*e)*c )*d) )+( ( ( (e*b)*c )*d) )+( ( (b , (c ,d ) ) , c ) )+( ( (e , (c ,d ) ) ,b ) )#O 
which is rewritten by [8] to 
0 # (b • ((e • c ) ,  d ) )+ (e ,  ((b • c) • d ) ) )+ - ( ( (b • e) • c) • d )+ - ( ( (e  • b) • c) * d ) -  
- ((b, (~, d ) ) ,~)  + - ( (~,  (~, d ) ) ,b )+ ((((b, c ) ,d ) ,  e))+ ((((~, ~),~),b)) 
which is further rewritten by [45] (twice, together with s l -s6) to 0 # O. 
5.  Summary  
We have presented the complete proofs of the first nine equality problems in 
Overbeek's competition (the last equality problem is an open problem). These 
Table I. Statistics of Herky on Overbeek's competition problems. 
Critical Generated Retained Proof Total 
Problem pairs rules rules length time 
I 379 34 19 14 2.68 
2 365 65 12 24 7.13 
3 1484 440 387 24 9.71 
4 521 372 34 102 4.68 
5 370430 773 771 62 1180.17 
6 71 67 67 9 0.98 
7 338 23 20 21 6.53 
8 2607 1464 1461 31 45.88 
9 199 61 22 23 10.77 
350 HANTAO ZHANG 
proofs are exactly those generated by Herky, a completion-based theorem prover (we 
only polished the messages at the end of each rewrite rule). 
In Table I, we list the statistics of Herky for solving the problems given in the 
previous section. Column 2 lists the number of critical pairs (or new inferences) 
for each problem. Columns 3 and 4 list the numbers of rewrite rules made and 
retained by Herky at the time a proof is found. Column 5 gives the number of 
rewrite rules (including the input equations) in the proof found by Herky. The last 
column gives the total computing times, which are measured in Sun Common 
Lisp on a Sun SPARCstation 2 (with 64 megabytes ofmain memory) when the trace 
flag of Herky is set to 1 (no printing of intermediate equations or rules). 
It will be interesting to see how such problems can be solved using theorem 
provers based on other approaches, such as clausal and nonclausal resolution, 
connection graphs, and natural deduction. We think that the detailed proofs 
presented here might help the people to find a complete proof using different 
approaches. 
Notes 
*Partially supported by the National Science Foundation Grants No. INT-9016100, CCR-9202838, and 
CCR-9357851. 
l Herky stands for 'High-performance _k y operations'. 
2 RRL (Rewrite Rule Laboratory) is a theorem-proving environment for experimenting and developing 
reasoning methods based on rewriting techniques and equational logics [8]. 
References 
1. Anantharaman, S. and Hsiang, J., 'Automated proofs of the Moufang identities in alternative rings', 
J. Automated Reasoning 6, 79 109 (1990). 
2. Bonacina, M. P., 'Problems in Lukasiewicz logic', AAR Newsletter, No. 18 (1991). 
3. Christian, J., 'Fast Knuth Bendix completion: summary', Proc. Third International Conference of 
Rewriting Techniques and Applications, Lecture Notes in Computer Science, Vol. 355, Springer- 
Verlag, pp. 548-610 (1989). 
4. Dershowitz, N., 'Termination of rewriting', J. Symbolic Computation 3, 69-116 (1987). 
5. Dershowitz, N. and Jouannaud, J. P., 'Rewriting systems', in Leuven, V. (Ed.), Handbook of 
Theoretical Computer Science, North Holland (1990). 
6. Knuth, D. E. and Bendix, P. B., 'Simple word problems in universal algebras', in Leech, J. (Ed.), 
Computational Problems in Abstract Algebras, Pergamon Press, pp. 263-297 (1970). 
7. Kapur, D., Sivakumar, G. and Zhang, H., 'A new method for proving termination of AC-rewrite 
systems', Proc. lOth Conference on Foundations of Software Technology and Theoretical Computer 
Science, Bangalore, India (1990). 
8. Kapur, D. and Zhang, H., 'An overview of RRL: Rewrite Rule Laboratory', Proc. of the Third Inter- 
national Conference on Rewriting Techniques and Its Applications, Lecture Notes in Computer Science, 
Vol. 355, Springer-Verlag, pp. 513-529 (1989). 
9. Kapur, D. and Zhang, H., 'Proving equivalence of different axiomatizations of free groups', 3.. 
Automated Reasoning 4, 331-352 (1988). 
10. Kapur, D. and Zhang, H., 'A case study of the completion procedure: Proving ring commutativity 
problems', in Lassez, J.-L. and Plotkin, G. (Eds.), Computational Logic: Essays in Honor of Alan 
Robinson, MIT Press, Cambridge, Mass. (1991). 
11. Lusk, E. L. and Overbeek, R. A., 'Reasoning about equality', J. Automated Reasoning 1, 209-228 
(1985). 
AUTOMATED PROOFS OF EQUALITY PROBLEMS 351 
12. Martin, U., 'Doing aigebra with REVE', Technical Report UMCS-86-10-4, Dept. of Computer 
Science, University of Manchester (1986). 
13. McCune, W., OTTER 2.0 Users' Guide. Technical Report, ANL-90/9, Argonne National Laboratory, 
Argonne, Illinois (1990). 
14. McCune, W., 'Experiments with discrimination-tree indexing and path indexing for term retrieval', J.
Automated Reasoning 9 (2), 147-168 (1992). 
15. McCune, W. and Wos, L., 'A case study in automated theorem proving: Finding sages in combinatory 
logic', J. Automated Reasoning 3 (1), 91-108 (1987). 
16. Neumann, B. H., 'Another single law for groups', Bull. Austr. Math. Soc. 23, 81-102 (1981). 
17. Peterson, G.L., 'Complete sets of reductions with constriants', Proe. lOth International Conference on 
Automated Deduction, Lecture Notes in Artificial Intelligence, Vol. 449, Springer-Verlag, Berlin, 
pp. 381-395 (1990). 
18. Peterson, G. L and Stickel, M. E., 'Complete sets of reductions for some equational theories', J. ACM 
28 (2), 233-264 (1981). 
19. Stickel, M., 'A case study of theorem proving by the Knuth-Bendix method: Discovering that x 3 = x 
implies ring commutativity', Proc. 7th Conf. on Automated Deduction, Lecture Notes in Computer 
Science, Vol. 170, Springer-Verlag, pp. 248-258 (1984). 
20. Veroff, R,  'Canonicalization and demodulation', Technical Report ANL-81-6, Argonne National 
Laboratory, Argonne, Illinois (1981). 
21. Wang, T. C., 'Case studies of Z-module reasoning: Proving benchmark theorems from ring theory', J. 
Automated Reasoning 3, 437 451 (1987). 
22. Wang, T, C. and Stevens, R., 'Solving open problems in right alternative rings with Z-module 
reasoning', 9". Automated Reasoning 5, 141-165 (1989). 
23. Winker, S., 'Robbins algebra: Conditions that make a near-Boolean algebra Boolean', J. Automated 
Reasoning 6 (4), 465-489 (1990). 
24. Winkler, S. and Wos, L., 'Automated generation of models and counterexamples and its 
application to open questions in ternary Boolean algebra', in: Proc. Eighth International Symposium on 
Multiple-Valued Logic. Rosemont, Ill., pp. 251-256 (1978). 
25. Wos, L., 'New challenge problem in sentential calculus', AAR Newsletter, No. 16 (1990). 
26. Wos, L. and McCune, W., 'Searching for fixed point combinators by using automated theorem 
proving: A preliminary report', Technical Report ANL-88-10, Argonne National Laboratory, 
Argonne, Illinois (1988). 
27. Wos, L., Overbeek, R., Lusk, E. and Boyle, J., 'Automated reasoning: Introduction and applications', 
2rid edn., McGraw-Hill, New York (1992). 
28. Zhang, H., 'Criteria of critical pair criteria: A practicai approach and a comparative study', Internal 
Report, Dept. of Computer Science, University of Iowa (1991). 
29. Zhang, H., 'Herky: High-performance r writing techniques in RRL; in Kapur, D. (Ed.), Proc. 
1992 International Conference of Automated Deduction, Lecture Notes in Artificial Intelligence, 
Springer-Verlag, pp. 696-700 (1992). 
30, Zhang, H., 'A case study of completion modulo distributivity and Abelian groups', in Kirchner, C. 
(Ed.). Proc. International Conference on Rewrite Techniques and Applications, Lecture Notes in 
Computer Science, Vol. 690, Springer-Verlag, pp. 32-46 (1993). 
31. Zhevlakov, K. A. et al., Rings That are Nearly Associative (Tr. by H. F. Smith from the Russian), 
Academic Press, New York (t982). 
