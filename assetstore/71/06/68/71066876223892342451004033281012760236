A Simpler Proof Theory for Nominal Logic
James Cheney
University of Edinburgh (jcheney@inf.ed.ac.uk)
Abstract. Nominal logic is a variant of ﬁrst-order logic equipped with a “freshname quantiﬁer” N and other features useful for reasoning about languages with bound names. Its original presentation was as a Hilbert axiomatic theory, but several attempts have been made to provide more convenient Gentzen-style sequent or natural deduction calculi for nominal logic. Unfortunately, the rules for N in these calculi involve complicated side-conditions, so using and proving properties of these calculi is difﬁcult. This paper presents an improved sequent calculus N L⇒ for nominal logic. Basic results such as cut-elimination and conservativity with respect to nominal logic are proved. Also, N L⇒ is used to solve an open problem, namely relating nominal logic’s N-quantiﬁer and the self-dual ∇quantiﬁer of Miller and Tiu’s F Oλ∇.
1 Introduction
Gabbay and Pitts [8] have introduced a new way of reasoning about names and binding, in which α-equivalence and capture-avoiding substitution can be deﬁned in terms of the basic concepts of swapping and freshness. This approach provides a cleaner treatment of α-equivalence than the classical ﬁrst-order approach in which α-equivalence and capture-avoiding substitution are deﬁned by mutual recursion. On the other hand, unlike higher-order techniques for dealing with names and binding, the semantics of this model of name-binding is relatively straightforward, so well-understood mathematical tools like structural induction can be used to reason about syntax with bound names.
These ideas have been incorporated into a logic called nominal logic [12]. Nominal logic is typed, ﬁrst-order equational logic augmented with:
– name-types ν, ν , . . . inhabited by countably many names a, b, . . .; – a swapping operation (− −) · − : ν → ν → τ → τ for each name-type ν and type
τ , which acts on values by exchanging occurrences of names; – a freshness relation − # − : ν → τ → o1 for each name-type ν and type τ , that
holds between a name and a value independent of the name; – an abstraction type constructor − − and abstraction function symbol − − : ν →
τ → ν τ which constructs values equal up to consistent renaming, axiomatized as follows:
∀a, b, x, y. a x = b y ⇐⇒ (a = b ∧ x = y) ∨ (a # y ∧ x = (a b) · y) ;
– a some/any fresh-name quantiﬁer N that is self-dual (¬Na.ϕ ⇐⇒ Na.¬ϕ); – and freshness and equivariance principles which state that fresh names can always
be chosen and truth is preserved by name-swapping, respectively.
1 o is the type of propositions

1.1 The Problem
This paper is concerned with developing simple rules for reasoning with the N-quantiﬁer. Pitts’ original formalization of nominal logic was a Hilbert-style collection of ﬁrst-order axioms (which we call N L). There were no new inference rules for N. Instead, N was deﬁned using the axiom scheme ∀x.(Na.ϕ ⇐⇒ ∃a.a # x ∧ ϕ), where F V (ϕ) ⊆ {a, x}. While admirable from a reductionist point of view, Hilbert systems have well-known deﬁciencies for modeling actual reasoning. Instead, Gentzen-style natural deduction and sequent systems provide a more intuitive approach to formal reasoning in which logical connectives are explained as proof-search operations. Gentzen systems are especially useful for computational applications, such as automated deduction and logic programming. A sequent calculus formalization would also be convenient for relating nominal logic with other logics by proof-theoretic translations.
Gentzen-style rules for N have been considered in previous work. Pitts [12] proposed sequent and natural deduction rules for N based on the observation that
∀a.(a # x ⊃ ϕ(a, x)) ⊃ Na.ϕ(a, x) ⊃ ∃a.(a # x ∧ ϕ(a, x)) .
These rules (see Figure 1(NL)) are symmetric, emphasizing N’s self-duality. However, they are not closed under substitution, which greatly complicates the the proof of cutelimination or proof-normalization properties.
Gabbay [6] introduced Fresh Logic (F L), an intuitionistic natural deduction calculus for nominal logic, and studied semantic issues including soundness and completeness as well as proving proof-normalization. Gabbay and Cheney [7] presented a similar sequent calculus called F LSeq. In F L, Gabbay introduced a technical device called slices for obtaining rules that are closed under substitution. Technically, a slice ϕ[a#u] of a formula ϕ is a decomposition of the formula as ϕ(a, x)[u/x] for fresh variables x, such that a does not appear in any of the u. Slices were also used in the F LSeq rules (see Figure 1(F LSeq)). The slice-based rules shown in Figure 1(F LSeq) are closed under substitution, so proving cut-elimination for these rules is relatively straightforward once several technical lemmas involving slices have been proved. Noting that the F LSeq rules are structurally similar to ∀L and ∃R, respectively, Gabbay and Cheney observed that alternate rules in which NL was similar to ∃L and NR similar to ∀R were possible (see Figure 1(F LSeq)). These rules seem simpler and more deterministic; however, they still involve slices.
Gabbay and Cheney presented a proof-theoretic semantics for nominal logic programming based on F LSeq. However, this analysis suggested an interpretation of Nquantiﬁed formulas that was radically different from the approach used in the αProlog nominal logic programming language [2]. The proof-search interpretation of Na.ϕ suggested by F LSeq is “search for a slice ϕ[a#u] of ϕ and substitution t for a such that t # u and solve ϕ(t, u)”, while in αProlog, the interpretation of Na.ϕ is “generate a fresh name a and solve ϕ(a )”. The approach motivated by the F LSeq proof-theoretic semantics seems much more complicated than experience with αProlog suggests.
Gabbay and Cheney also gave a translation from F Oλ∇, a logic introduced by Miller and Tiu that also includes a self-dual quantiﬁer, ∇ [9] into F LSeq. This translation was sound (mapped derivable sequents to derivable sequents), but incomplete

Γ, a # x ⇒ ϕ, ∆ (†)

Γ ⇒ Na.ϕ, ∆

NR

Γ, a # x, ϕ ⇒ ∆ (†)

Γ, Na.ϕ ⇒ ∆

NL (N L)

Γ Na.ϕ Γ u # t

Γ u # t Γ ϕ[u/a] (∗)

Γ, ϕ[u/a] ψ (∗)

Γ Na.ϕ NI Γ ⇒ ψ

NE (F L)

Γ, u # t ⇒ ϕ[u/a] (∗) Γ, u # t ⇒ Na.ϕ NR

Γ, a # t ⇒ ϕ (∗), (∗∗)

Γ ⇒ Na.ϕ

NR

Σ#a : Γ ⇒ ϕ (a ∈/ Σ)

Σ : Γ ⇒ Na.ϕ

NR

Γ, u # t, ϕ[u/a] ⇒ ψ (∗)

Γ, u # t, Na.ϕ ⇒ ψ

NL (F LSeq)

Γ, a # t, ϕ ⇒ ψ (∗), (∗∗)

Γ, Na.ϕ ⇒ ψ

NL (F LSeq)

Σ#a : Γ, ϕ ⇒ ψ (a ∈/ Σ)

Σ : Γ, Na.ϕ ⇒ ψ

NL (N L⇒)

(†) x = F V (Γ, Na.ϕ, ∆) (∗) ϕ = ϕ[a#t] (∗∗) a ∈ F V (Γ, ψ)

Fig. 1. Evolution of rules for N

(mapped some non-derivable sequents to derivable ones). Gabbay and Cheney conjectured that their translation would be complete relative to F Oλ∇ extended with weakening and exchange for ∇.
In this paper we present a simpliﬁed sequent calculus for nominal logic, called N L⇒, in which slices are not needed in the rules for N (or anywhere else), and which seems more compatible with the proof-search reading of N in αProlog. Following Urban, Pitts, and Gabbay [14, 6], we employ a new syntactic class of name-symbols a, b, . . .. Like variables, such name-symbols may be bound (by N), but unlike variables, two distinct name-symbols are always regarded as denoting distinct name values. In place of slices, we introduce variable contexts that encode information about freshness. Speciﬁcally, contexts Σ#a:ν may be formed by adjoining a fresh name-symbol a which is also assumed to be semantically fresh for any value mentioned in Σ. Our rules for N (Figure 1(N L⇒)) are in the spirit of the original rules and are very simple.
Besides the sequent calculus itself, we present two applications. First, we verify that N L⇒ and Pitts’ axiomatization N L are equivalent. Second, we present and prove the soundness and completeness of a new translation from F Oλ∇ to nominal logic, solving a problem left unsolved by Gabbay and Cheney. We have also found that the original translation is complete relative to F Oλ∇ extended with ∇-weakening and contraction.
The structure of this paper is as follows: Section 2 presents the sequent calculus N L⇒ along with proofs of structural properties and conservativity of N L⇒ relative to N L. In Section 3, we present sound and complete translations from F Oλ∇ (with and without ∇-weakening and exchange) to N L⇒. Section 4 discusses additional related and future work, and Section 5 concludes.

2 Sequent Calculus
The sequent calculus in this section is a generalization of the one presented in Chapter 4 of the author’s dissertation [5]. Full proofs can be found there and in a companion technical report [3].
2.1 Syntax and Well-Formedness
The types τ , terms t, and formulas ϕ of N L⇒ are generated by the following grammar:
τ ::= o | δ | ν | τ → τ | ν τ t, u ::= c | a | λx:τ.t | t u | x ϕ, ψ ::= | ⊥ | t | ϕ ∧ ψ | ϕ ∨ ψ | ϕ ⊃ ψ | ∀x:τ.ϕ | ∃x:τ.ϕ | Na:ν.ϕ
The base types are datatypes δ, name-types ν, and the type o of propositions; additional types are formed using the function and abstraction type constructors. Variables x, y are drawn from a countably inﬁnite set V ; also, name-symbols a, b are drawn from a disjoint countably inﬁnite set A. The letters a, b are typically used for terms of some name-sort ν. Note that λ-terms are included in this language and are handled in a traditional fashion. In particular, terms are considered equal up to αβη-equivalence. Similarly, ∀, ∃, and N-quantiﬁed formulas are identiﬁed up to α-equivalence. We assume given a signature that maps constant symbols c to types τ , and containing at least the following declarations:
eqτ : τ →τ →o freshντ : ν→τ →o swapντ : ν→ν→τ →τ absντ : ν→τ → ν τ
for all name-types ν and types τ . The notations t ≈ u, t # u, (t u) · v, and t u are syntactic sugar for eq t u, fresh t u, swap t u v, and abs t u, respectively.
The contexts used in N L⇒ are generated by the grammar:
Σ ::= · | Σ, x:τ | Σ#a:ν
We often abbreviate ·, x:τ and ·#a:ν to x:τ and a:ν respectively, and may omit type declarations when no ambiguity ensues. We write ω for a term that may be either a name-symbol a or a variable x. The functions F V (−), F N (−), F V N (−) calculate the sets of free variables, name-symbols, or both variables and name-symbols of a term or formula. Note that abstraction − − is just a function symbol and does not bind its ﬁrst argument (which may be any term of type ν), and so F N ( a t) = F N (a)∪F N (t), whereas Na.ϕ does bind a, so F N (Na.ϕ) = F N (ϕ) − {a}. We write ω:τ ∈ Σ if the binding ω:τ is present in Σ. We write Σ; Σ for the result of concatenating two contexts such that F V N (Σ) ∩ F V N (Σ ) = ∅.
Remark 1. The inclusion of λ-terms and identiﬁcation of terms and formulas with bound names up to α-equivalence may be objectionable because it appears that we are circularly attempting to deﬁne binding in terms of binding. This is not the case. A key contribution of Gabbay and Pitts’ approach is that it shows how one can formally justify a traditional, informal approach to binding syntax by constructing syntax trees modulo α-equivalence as simple mathematical objects in a particularly clever way [8][5, Ch. 3–4]. We assume that this or some other standard technique for dealing with binding in nominal logic’s terms and formulas is acting behind the scenes.

We write Σ t : τ or Σ ϕ : o to indicate that t is a well-formed term of type τ or ϕ is a well-formed formula. From the point of view of typechecking, the freshness information given by the context is irrelevant. There are only two nonstandard rules for typechecking:
ω:τ ∈ Σ Σ#a:ν ϕ : o Σ ω : τ Σ Na:ν.ϕ : o
Terms viewed as formulas must, as usual, be of type o. Quantiﬁcation using ∀ and ∃ is only allowed over types not mentioning o; N-quantiﬁcation is only allowed over nametypes.
Let T mΣ = {t | Σ t : τ } be the set of well-formed terms in context Σ. We associate a set of freshness formulas |Σ| to each context Σ as follows:
| · | = ∅ |Σ, x : τ | = |Σ| |Σ#a : ν| = |Σ| ∪ {a # t | t ∈ T mΣ}
For example, a # x, b # a, and b # f x y ∈ |x:τ #a:ν, y:τ #b:ν | (provided f : τ → τ → σ is a function symbol). We say that Σ is stronger than Σ (Σ ≤ Σ) if T mΣ ⊆ T mΣ and |Σ | ⊆ |Σ|. For example, a, x ≤ x#a, y.
Lemma 1 (Term Weakening). If Σ t : τ and Σ ≤ Σ then Σ t : τ .
Lemma 2 (Term Substitution). If Σ t : τ and Σ, x : τ ; Σ u : τ then Σ; Σ u[t/x] : τ .
2.2 The Rules
Judgments are of the form Σ : Γ ⇒ ∆, where Σ is a context and Γ, ∆ are multisets of formulas. We deﬁne classical and intuitionistic versions of N L⇒. Classical N L⇒ is based on the classical sequent calculus G3c [11] (see Figure 2), whereas Intuitionistic N L⇒ (IN L⇒) is based on the intuitionistic calculus G3im (in which ⊃, ∀R, and ∃Lrules are restricted to a single-conclusion form). Both versions include two additional logical rules, NL and NR, shown in Figure 1(N L⇒). In addition, N L⇒ includes several nonlogical rules (Figure 4) deﬁning the properties of swapping, equality, freshness and abstraction. Figure 5 lists some admissible rules.
Many of the nonlogical rules correspond to ﬁrst-order universal axioms of nominal logic (Figure 3), which may be incorporated into sequent systems in a uniform fashion using the Ax rule without affecting cut-elimination [11]. The remaining nonlogical rules are as follows. Rule A2 expresses an invertibility property for abstractions: two abstractions are equal only if they are structurally equal or equal by virtue of A1. A3 says that all values of abstraction type are formed using the abstraction function symbol. The F rule expresses the freshness principle: that a name fresh for a given context may always be chosen. Finally, the Σ# rule allows freshness information to be extracted from the context Σ. It states that in context Σ, any constraint in |Σ| is valid.
2.3 Structural Properties
We now list some routinely-veriﬁed properties of N L⇒ derivations. We write n J to indicate that judgment J has a derivation of height at most n.

hyp Σ : Γ, p t ⇒ p t, ∆

Σ : Γ ⇒ ,∆ R

Σ : Γ, ⊥ ⇒ ∆ ⊥L

Σ : Γ ⇒ ϕ, ∆ Σ : Γ ⇒ ψ, ∆

Σ : Γ ⇒ ϕ ∧ ψ, ∆

∧R

Σ : Γ ⇒ ϕ1, ϕ2, ∆ Σ : Γ ⇒ ϕ1 ∨ ϕ2, ∆

∨R

Σ : Γ, ϕ ⇒ ψ, ∆ Σ : Γ ⇒ ϕ ⊃ ψ, ∆ ⊃R

Σ : Γ, ϕ1, ϕ2 ⇒ ∆ Σ : Γ, ϕ1 ∧ ϕ2 ⇒ ∆

∧L

Σ : Γ, ϕ ⇒ ∆ Γ, ψ ⇒ ∆

Σ : Γ, ϕ ∨ ψ ⇒ ∆

∨L

Σ : Γ ⇒ ϕ, ∆ Σ : Γ, ψ ⇒ ∆

Σ : Γ, ϕ ⊃ ψ ⇒ ∆

⊃L

Σ, x : Γ ⇒ ϕ, ∆ (x ∈ Σ)

Σ t : σ Σ : Γ, ∀x:τ.ϕ, ϕ[t/x] ⇒ ∆

Σ : Γ ⇒ ∀x.ϕ, ∆

∀R

Σ : Γ, ∀x:τ.ϕ ⇒ ∆

∀L

Σ t : σ Σ : Γ ⇒ ∃x:τ.ϕ, ϕ[t/x], ∆

Σ, x : Γ, ϕ ⇒ ∆ (x ∈ Σ)

Σ : Γ ⇒ ∃x:τ.ϕ, ∆

∃R

Σ : Γ, ∃x.ϕ ⇒ ∆

∃L

Σ : Γ, t ≈ t ⇒ ∆ Σ : Γ ⇒ ∆ ≈R

Σ : Γ, t ≈ u, P (t), P (u) ⇒ ∆ Σ : Γ, t ≈ u, P (t) ⇒ ∆ ≈S

Fig. 2. Classical typed ﬁrst-order equational logic (G3c)

Lemma 3 (Weakening). If n Σ : Γ ⇒ ∆ is derivable then so is n Σ : Γ, ϕ ⇒ ∆.
Lemma 4 (Context Weakening). If n Σ : Γ ⇒ ∆ and Σ ≤ Σ then n Σ : Γ ⇒ ∆

Lemma 5 (Substitution). If n Σ t : τ and Σ, x:τ ; Σ : Γ ⇒ ∆ then n Σ; Σ : Γ [t/x] ⇒ ∆[t/x].

The remaining structural transformations do not preserve the height of derivations. However, they do preserve the logical height of the derivation, which is deﬁned as follows.

Deﬁnition 1. The logical height of a derivation is the maximum number of logical rules

in any branch of the derivation. We write

l n

J

to

indicate

that

J

has

a

derivation

of

logical height ≤ n.

Lemma 6 (Admissibility of EV L, EV R). If

l n

Σ

:

Γ, (a

b) ·

ϕ

⇒

∆,

then

so

is

l n

Σ

:

Γ, ϕ

⇒

∆.

Similarly,

if

l n

Σ

:

Γ

⇒

(a b) · ϕ, ∆ is derivable, then so is

l n

Σ

:

Γ

⇒

ϕ, ∆.

Lemma 7 (Admissibility of hyp∗). The judgment Σ : Γ, ϕ ⇒ ϕ, ∆ is derivable for

any ϕ.

Proof (Sketch). Induction on the construction of ϕ. The only new case is for ϕ = Na.ψ(a, x). By induction we know that Σ#a#b : Γ, ψ(b, x) ⇒ ψ(b, x). Using equivariance we have Σ#a#b : Γ, (a b) · ψ(a, x) ⇒ ψ(b, x). Since x ⊂ F V (Σ), using Σ# we know that a # x, b # x, hence (a b) · x ≈ x, so using equational reasoning we have (a b) · ψ(a, x) ≈ ψ(b, x). Then using NL and NR we can conclude Σ : Γ, Na.ψ ⇒ Na.ψ, ∆.

(S1) (a a) · x ≈ x (E4) (a b) · λx.e[x] ≈ λx.(a b) · e[(a b) · x]

(S2) (a b) · (a b) · x ≈ x (F1) a # x ∧ b # x ⊃ (a b) · x ≈ x

(S3) (a b) · a ≈ b (F2) a # b (a : ν, b : ν , ν ≡ ν )

(E1)

(a b) · c ≈ c

(F3)

a#a⊃⊥

(E2) (a b) · (t u) ≈ ((a b) · t) ((a b) · u) (F4)

a#b∨a≈b

(E3)

p(x) ⊃ p((a b) · x)

(A1) a # y ∧ x ≈ (a b) · y ⊃ a x ≈ b y

Fig. 3. Equational and freshness axioms

Σ : Γ, P , Q1 ⇒ ∆ · · · Σ : Γ, P , Qn ⇒ ∆ Ax Σ : Γ, P ⇒ ∆

V P ⊃ W Q an axiom instance

Σ : Γ, a t ≈ b u, a ≈ b, t ≈ u ⇒ ∆ Σ : Γ, a t ≈ b u, a # u, t = (a b) · u ⇒ ∆

Σ : Γ, a t ≈ b u ⇒ ∆

A2

Σ t : ν σ Σ, a:ν, x:σ : Γ, t ≈ a x ⇒ ∆ (a, x ∈/ Σ)

Σ:Γ ⇒∆

A3

Σ#a : Γ ⇒ ∆ (a ∈/ Σ)

Σ:Γ ⇒∆

F

Σ : Γ, t # u ⇒ ∆ (t # u ∈ |Σ|)

Σ:Γ ⇒∆

Σ#

Fig. 4. Nonlogical rules

Σ:Γ ⇒∆ Σ : Γ, ϕ ⇒ ∆

W

Σ : Γ, ϕ ⇒ ϕ, ∆ hyp∗

Σ : Γ ⇒ ϕ, ∆ Σ : Γ , ϕ ⇒ ∆

Σ : Γ, Γ ⇒ ∆, ∆

cut

Σ : Γ, ϕ, ϕ ⇒ ∆ Σ : Γ, (a b) · ϕ ⇒ ∆ Σ : Γ, ϕ ⇒ ∆ C Σ : Γ, ϕ ⇒ ∆ EV L

Σ : Γ ⇒ (a b) · ϕ, ∆ Σ : Γ ⇒ ∆, ϕ EV R

Fig. 5. Some admissible rules of N L⇒

Lemma 8 (Inversion). The ⊃L, ∃L, ∧L, and ∨L rules are invertible, in the sense of

lemma 2.3.5 and 4.2.8 of Negri and von Plato [11]. In addition, NL is invertible: if

l n

Σ

:

Γ,

Na.ϕ

⇒

∆

is

derivable

then

so

is

l n

Σ#a

:

Γ,

ϕ

⇒

∆

for

fresh

a.

Lemma 9 (Contraction). If

l n

Σ

:

Γ, ϕ, ϕ

⇒

∆

is derivable

then

so

is

l n

Σ

:

Γ, ϕ ⇒ ∆.

2.4 Cut-Elimination

Lemma 10 (Admissibility of Cut). If Σ : Γ ⇒ ∆, ϕ and Σ : Γ , ϕ ⇒ ∆ have cut-free derivations then so does Σ : Γ, Γ ⇒ ∆, ∆ .

Proof (Sketch). We show the most interesting case, that for principal cuts on N-quantiﬁed formulas. In this case, the derivations are of the form

Π Σ#a : Γ ⇒ ϕ, ∆ Σ : Γ ⇒ Na.ϕ, ∆ NR

Π Σ#a : Γ , ϕ ⇒ ∆ Σ : Γ , Na.ϕ ⇒ ∆ NL

where without loss of generality we assume that the same fresh name a ∈ Σ was used in both sub-derivations. Since ϕ is smaller than Na.ϕ, we can obtain a derivation Π of Σ#a : Γ, Γ ⇒ ∆, ∆ from Π and Π by the induction hypothesis. Then
Π Σ#a : Γ, Γ ⇒ ∆, ∆
Σ : Γ, Γ ⇒ ∆, ∆ F
follows using rule F .
Theorem 1 (Cut-elimination). If Σ : Γ ⇒ ∆ has any derivation then it has a cut-free derivation.
Corollary 1 (Consistency). There is no derivation of Σ : · ⇒ ⊥.
Corollary 2 (Orthognality). Suppose Σ : Γ ⇒ ∆ and Γ, ∆ have no subterms of the form a t (respectively, λx.t). Then there is a derivation of Σ : Γ ⇒ ∆ that does not use any nonlogical rules involving abstraction (respectively, λ).

2.5 Conservativity

In this section, we show that N L⇒ is conservative relative to Pitts’ original axiomatization N L [12]. That is, every theorem of N L is provable in N L⇒, and no new theorems
become provable. For convenience, we assume that the same underlying ﬁrst-order sequent calculus is used for N L and N L⇒.
Write NL Σ : Γ ⇒ ∆ if there is a ﬁrst-order equational sequent proof of Σ : Γ, Γ ⇒ ∆. for some set of N L axioms Γ . Write NL⇒ Σ : Γ ⇒ ∆ if Σ : Γ ⇒ ∆ is derivable in N L⇒ without using any rules involving λ. Write IX for the intuitionistic
version of provability in system X, that is, provability using only single-conclusion
sequents. We translate N L formulas ϕ to N L⇒ formulas ϕ∗ by replacing all subformulas of
the form Na.ϕ(a) with Na.ϕ∗(a), for fresh name-symbols a. This translation is uniquely deﬁned up to α-equivalence. For example, (Na.Nb.p(a, b))∗ = Na.Nb.p(a, b).
To prove the reverse direction of conservativity, it is necessary to show that N L⇒
sequents involving fresh name-symbols and contexts Σ#a are equivalent to sequents
involving only variables.

Lemma 11 (Name-Elimination). Suppose Σ mentions only variables and

l n

Σ#a

:

Γ [a] ⇒ ∆[a]. Then

l n

Σ, a

:

Γ [a], a

#

Σ

⇒

∆[a],

where

a

#

Σ

is

an

abbreviation

for {a # x | x ∈ Σ}.

Theorem 2 (Conservativity). (I)NL Σ : Γ ⇒ ∆ if and only if (I)NL⇒ Σ : Γ ∗ ⇒ ∆∗

Remark 2 (Semantics). Conservativity justiﬁes N L⇒’s description as a sequent calculus for nominal logic. Although this paper focuses exclusively on proof theory at the expense of more traditional model theoretic semantics, conservativity guarantees that N L⇒ inherits Pitts’ nominal set semantics for nominal logic (as well as suffering from the same completeness problem). Space constraints preclude further discussion; however, these issues are considered in detail in Cheney’s dissertation and a paper in preparation.

3 A Sound and Complete Translation of F Oλ∇

Miller and Tiu introduced a sequent calculus called F Oλ∇, which abbreviates “Firstorder Logic with λ-terms and the ∇-quantiﬁer” [9]. Like N, the ∇ quantiﬁer is self-dual. However, N and ∇ have distinctly different properties. Nominal logic and F Oλ∇ have
similar aims (reasoning about languages in which binding and fresh name-generation play an important role), so it is of interest to determine the relationship between F Oλ∇ and IN L⇒. Also, F Oλ∇ has only been studied using proof theory, but nominal logic
has a well-understood semantics [12], so relating the two systems may also elucidate the semantics of F Oλ∇.
In F Oλ∇, formulas are generalized to formulas-in-context σ ϕ, where σ is a list of local parameters (variables introduced by ∇) and ϕ is a formula built out of ﬁrst-order connectives and quantiﬁers or ∇x.ψ. We abbreviate “formula-in-context”
to “c-formula”. Local parameter contexts are subject to α-renaming, so that a p(a)
and b p(b) are considered equal c-formulas. However, c-formulas are not considered
equivalent up to reordering or extension of the contexts. Thus, a, b p(a), a p(a), and
b, a p(a) are all considered different c-formulas. The sequent calculus rules dealing with ∇ are as follows:

Σ : Γ ⇒ (σ, x) ϕ

Σ : Γ, (σ, x) ϕ ⇒ A

Σ : Γ ⇒ σ ∇x.ϕ ∇R Σ : Γ, σ ∇x.ϕ ⇒ A ∇L

where in either case x must not already appear in σ or Σ. However, x may appear in
some other local context. Most of the other sequent rules of F Oλ∇ are standard, except for the presence of
local contexts. For example,

Σ : Γ, σ ϕ, σ ψ ⇒ A

Σ:Γ ⇒σ ϕ Σ:Γ ⇒σ ψ

Σ : Γ, σ ϕ ∧ ψ ⇒ A ∧L

Σ :Γ ⇒σ ϕ∧ψ

∧R

are the rules dealing with ∧. The only exceptions are the ∀ and ∃ rules. In ∀R and ∃L, the bound variable is “lifted” to show its dependence on local parameters. Dually, in ∀L and ∃R, the term substituted for the bound variable may depend on local parameters. Here are the ∀-rules; the rules for ∃ are similar.

Σ, h:τσ → τ Σ:Γ

: Γ ⇒ σ A[h σ/x] ⇒ σ ∀τ x.A

∀R

Σ, σ

t : τ Σ : Γ, σ A[t/x] ⇒ C

Σ : Γ, σ ∀τ x.A ⇒ C

∀L

Although ∇ and N have some properties in common and seem to have similar motivations, the relation between them is not obvious. For example, IN L⇒ includes nametypes, and N may only quantify over them; F Oλ∇ has no name-types, and ∇ may
quantify over any simple type. In addition, N admits weakening (ϕ ⇐⇒ Na.ϕ where
a ∈ F N (ϕ)) and exchange (Na.Nb.ϕ ⇐⇒ Nb.Na.ϕ), and satisﬁes ∀x.ϕ(x) ⊃
Na.ϕ(a) ⊃ ∃x.ϕ(x). None of these inferences are derivable with ∇ substituted for N.
On the other hand, ∇ commutes with all propositional connectives, ∀, and ∃, while N
only commutes with propositional connectives. Gabbay and Cheney studied the problem of embedding F Oλ∇ into nominal logic.
They presented a translation (which we call TGC ) from F Oλ∇ to F LSeq satisfying

a soundness property: if J is derivable in F Oλ∇ then its translation [[J]] is derivable in F LSeq. However, their translation did not satisfy the corresponding completeness property: some non-derivable judgments of F Oλ∇ were translated to derivable F LSeq judgments. In particular, the translation failed to reconcile the different behavior of N and ∇ with respect to weakening and exchange principles.
In the rest of this section, we present a modiﬁed translation and prove its soundness and completeness. We also sketch a proof that the original translation is complete with respect to F Oλ∇ with ∇-weakening and exchange. Full proofs will be given in a companion technical report [4].
Our translation T departs from TGC in two ways. First, TGC translated c-formulas such as x ϕ∧ψ by ﬁrst using N-quantiﬁers for the local context, then translating ϕ∧ψ, and ﬁnally substituting n(a) for x, resulting in Na.[[ϕ]][n(a)/x] ∧ [[ψ]][n(a)/x]. In this approach, the head symbol of a translated c-formula was hidden beneath a sequence of N-quantiﬁers, which made TGC difﬁcult to analyze. Instead, our translation delays N-quantiﬁcation as long as possible and preserves the head symbol for most formulas: for example, the prior example translates to [[x ϕ]] ∧ [[x ψ]]. Any N-quantiﬁcation is delayed as long as possible, that is, until the base case for atomic formulas.
The second change is the translation of atomic formulas. As noted earlier, the validity of c-formulas is sensitive to both the order and number of local parameters in context. To deal with this, we relativize atomic formulas to their local contexts. This is accomplished by adding an argument to each atomic formula symbol for a list of names representing the local context. Let ν∗ be a type with constructors nil : ν∗ and cons : ν → ν∗ → ν∗, that is, a type of lists of names. We use a conventional commaseparated list notation for lists: [a, b, c] = cons(a, cons(b, cons(c, nil))). The translation of an atomic c-formula σ pt is Na.p∗ [a] t[nτ (a)/σ], where if p : τ → o then p∗ : ν∗ → τ → o.
Otherwise, T is similar to TGC . Ordinary ∀ and ∃-quantiﬁed values are lifted to equivariant functions applied to lists of names. For example, σ ∀x:τ .p(x) was translated to Na.∀h:τ1 → · · · τn → τ .ev(h) ⊃ p(h nτ (a)), where each ai is the name representing xi, and ev(x) = ∀a : ν.a # x.
The new translation is shown in full in Figure 6. The function [[·]] translates judgments, contexts, and c-formulas of F Oλ∇ to judgments, formula multisets, and formulas of IN L⇒ respectively. Note that the context Σ is translated to a set of hypotheses ev(x), one for each x ∈ Σ. Here are two examples of the new translation. The formula ∇x.p ⇐⇒ p is translated to Na.p∗ [a] ⇐⇒ p∗ []. Likewise, we translate ∇x, y.p x y ⇐⇒ ∇y, x.p x y to Na, b.p∗ [a, b] (n(a))(n(b)) ⇐⇒ Nb, a.p∗ [b, a] (n(a)) (n(b)). Neither of these translated formulas is derivable in nominal logic.
Lemma 12. If Σ F Oλ∇ t : τ then Σ INL⇒ t : τ ; in addition, Σ : [[Σ]] ⇒ ev(t). Also, if Σ : Γ ⇒ A is well-formed then so is [[Σ : Γ ⇒ A]].
Proposition 1 (Soundness). If Σ : Γ ⇒ A is derivable in F Oλ∇ then [[Σ : Γ ⇒ A]] is derivable in IN L⇒.
Proof. Similar to, but simpler than, the proof for TGC .

[[σ ]] =

[[σ ϕ ∨ ψ]] = [[σ ϕ]] ∨ [[σ ψ]]

[[σ ⊥]] = ⊥

[[σ ϕ ⊃ ψ]] = [[σ ϕ]] ⊃ [[σ ψ]]

[[σ p t]] = Na.p∗ [a] (t[nτ (a)/σ]) [[σ ϕ ∧ ψ]] = [[σ ϕ]] ∧ [[σ ψ]]

[[σ [[σ

∀x:τ.ϕ]] = ∀h:τσ→τ .ev(h) ⊃ [[σ ϕ[hσ/x]]] ∃x:τ.ϕ]] = ∃h:τσ→τ .ev(h) ∧ [[σ ϕ[hσ/x]]]

[[σ ∇x:τ.ϕ]] = [[σ, x:τ ϕ]]

[[·]] = ·

[[Σ, x:τ ]] = [[Σ]], ev(x) (ev(x) = ∀a:ν.a # x)

[[Σ : Γ ⇒ A]] = Σ : [[Σ]], [[Γ ]] ⇒ [[A]]

Fig. 6. Translation T from F Oλ∇ to IN L⇒

Theorem 3 (Completeness). If [[Σ : Γ ⇒ A]] is derivable in IN L⇒ then Σ : Γ ⇒ A is derivable in F Oλ∇.
Proof (Sketch). We break the proof into the following steps:
1. Identify two normal forms for IN L⇒ proofs, and show that proofs of translated sequents can be normalized.
2. Show that proofs of the ﬁrst normal form are proofs of initial sequents. 3. Show that proofs of the second normal form correspond to applications of F Oλ∇
rules.
In the analysis to follow, it simpliﬁes matters to eliminate as many nonlogical rules as possible from derivations. By the orthogonality property, we need not consider the rules for abstraction in translated derivations, since abstractions are not used in the translation. In addition, the nonlogical rules F3 and F4 can also be eliminated, as we shall now show.
Lemma 13. Suppose Σ has no name-variables. If Σ a : ν, then for some a ∈ Σ, Σ : · ⇒ a ≈ a.
Proposition 2. If [[Σ : Γ ⇒ A]] is derivable then it has a derivation that does not use F3 or F4.
Proof. To show that F3 cannot be used in a derivation of a translated sequent, note that [[Γ ]] and [[A]] do not mention equality or freshness, and the formulas [[Σ]] = ∀a.a # x1, . . . , ∀a.a # xn cannot be instantiated to xi # xi since the variables xi are not of name-type. We can therefore show that no sequent occurring in the derivation of a translated sequent can contain a # a using methods similar to those used for consistency and orthogonality.
Consider a subderivation ending with F4, of the form
Σ : Γ, a # b ⇒ ϕ Σ : Γ, a ≈ b ⇒ ϕ Σ:Γ ⇒ϕ
Name-variables are never introduced in translated derivations, so by Lemma 13, we have Σ ⇒ a ≈ a, Σ : · ⇒ b ≈ b for some a, b ∈ Σ. If a = b then clearly Σ : · ⇒ a ≈ b, so we can use the second subderivation and cut to derive Σ : Γ ⇒ ϕ. On the other hand, if a = b then clearly Σ : · ⇒ a # b and also Σ : · ⇒ a # b. Using cut and the subderivation Σ : Γ, a # b we can derive Σ : Γ ⇒ ϕ.

Deﬁnition 2. A derivation is in ﬁrst normal form if it uses only the rules NL, NR, hyp, and nonlogical rules.
A derivation beginning with a left- or right-rule is in second normal form provided that if the toplevel rule is ∀L, ∀R, ∃L, or ∃R, then the next rule used is ⊃L, ⊃R, ∧L, or ∧R, respectively.
Before proving that translated derivations always have normal forms, we need some additional technical machinery. We write ϕˆ(t) for the formula ev(t) ⊃ ϕ(t); translations of universal c-formulas are always of the form ∀x.ϕˆ(x). We write Γˆ(t) for a set of formulas ϕˆ1(tn), . . . , ϕˆn(tn) such that ∀x.ϕˆi(x) ∈ [[Γ ]] for each i.
Lemma 14. If Σ is a F Oλ∇ context, Σ#a t : τ and Σ#a : [[Σ]] ⇒ ev(t) then Σ t : τ.
Lemma 15. If Σ is a F Oλ∇ context, Σ#a : [[Σ]], [[Γ ]], Γˆ(t) ⇒ ev(t) then either Σ : [[Γ ]] ⇒ ϕ has a normal derivation for any formula ϕ, or Σ#a : [[Σ]] ⇒ ev(t).
Lemma 16. If Σ : Γ ⇒ ϕ has a derivation using only nonbranching nonlogical rules, then it has either a ﬁrst normal form derivation or one that starts with F or a logical rule.
Proposition 3. If [[Σ : Γ ⇒ A]] is derivable, then it has a normal derivation.
Proof (Sketch). First, by Corollary 2 and Proposition 2, [[Σ : Γ ⇒ A]] must have a derivation that does not use the rules A1, A2, A3, F3 or F4.
Because of subtleties involved in the interaction between the F and ∀L rule, we need a stronger induction hypothesis. We prove that if Σ#a : [[Σ]], [[Γ ]], Γˆ(t) ⇒ [[A]] has a derivation, then Σ : [[Σ]], [[Γ ]] ⇒ [[A]] has a normal derivation.
Using Lemma 16, the sequent either has a ﬁrst normal form derivation (in which case we are done) or begins with F or a logical rule. If it starts with a propositional rule applied to an element of [[Γ ]], then we are done. The induction steps for F and ∀L are immediate. For ∃L, ∀R, we can use the invertibility of ∧L and ⊃R respectively and then use ∀L. This leaves the cases for ∃R and for ⊃L applied to an element of Γˆ. For ⊃L we must have subderivations of Σ#a t : τ and Σ#a : [[Γ ]], Γˆ(t), ϕ(t) ⇒ [[A]]. Using the lemmas we can show that the witnessing term t does not mention any names, and so we can construct a derivation starting with ∀L and ⊃L. In the similar case of ∃R, we also need the invertibility of ∧R.
We next show that if the derivation is in ﬁrst normal form, then the F Oλ∇ sequent is derivable. We need two auxiliary facts.
Lemma 17. Suppose x#a t : τ and π · [a] = [b]. Then x#a#b : · ⇒ π · t ≈ t[b1/a1, . . . , bn/an]
Lemma 18. Suppose that Σ has no name-variables and Γ consists of freshness and equality formulas only. If Σ : Γ, p t ⇒ p u then for some permutation π of names in Σ, we have Σ : Γ ⇒ π · t ≈ u.

Proof. The proof is by induction on the structure of the derivation. Only the hypothesis
and nonbranching nonlogical rules can be involved, of these cases, only F poses a
challenge. In the case for F , the π obtained by induction may mention the fresh name a introduced by F ; however, a cannot appear in t or u, so b = π−1(a) must not appear in t, and so π = π ◦ (a b) also works since π · t = π · (a b) · t = π · t = u.

Proposition 4. Let [[Σ : Γ ⇒ A]] have a ﬁrst-normal form derivation. Then Σ : Γ ⇒ A is derivable.

Proof. If [[Σ : Γ ⇒ A]] has a ﬁrst normal form derivation, then A and some element B of Γ must be of the form σ ∇x.p t. Without loss of generality, we consider the case where no ∇-quantiﬁers appear. After stripping off the initial sequence of NL and NR rules, there must be a subderivation of
Σ#a#b : [[Σ]], [[Γ ]], p∗ [a] θ(t) ⇒ p∗ [b] θ (u)

for some names a, b, where θ = [n(a)/σ] and θ = [n(b)/σ ]. Note that θ and θ are one-to-one and so invertible on on their ranges, and that Σ#a θ(t) : τ (that is, none of the b appear in θ(t)).
By Lemma 18, there must be a ground permutation π such that Σ : · ⇒ π · ([a] θ(t)) ≈ [b] θ (u). Clearly, π · [a] = [b], so by Lemma 17 we have u[n(b)/σ ] = θ (u) ≈ π · θ(t) ≈ θ(t)[b1/a1, . . . , bn/an] = t[n(b)/σ]. Since [n(b)/σ ] is invertible, we have u ≈ t[n(b)/σ][σ /n(b)] = t[σ /σ], which implies σ p t ≡α σ p u.
Proof (Completeness Theorem). In F Oλ∇, ∇ commutes with all propositional connectives, ∀, and ∃. Therefore, every judgment is equivalent to one in which ∇-quantiﬁers only occur around atomic formulas, that is, in subformulas of the form ∇x.p t. So it sufﬁces to consider only judgments of this form.
The proof is by induction on the complexity of the judgment Σ : Γ ⇒ A. If the normalized derivation is of the ﬁrst form, then by Proposition 4, the sequent is derivable. If the normalized derivation is of the second form, there are many subcases, one for each possible starting left- or right-rule. The cases for propositional rules are straightforward. The remaining cases are those for ∀ and ∃. We will show that translated sequents derived using ∀L/R, ∃L/R in IN L⇒ can be derived using ∀L/R and ∃L/R in F Oλ∇.
If the ﬁnal step of the derivation is ∀R, then the derivation must be of the form
Σ, h : [[Σ]], ev(h), [[Γ ]] ⇒ [[σ ϕ[hσ/x]]] Σ, h : [[Σ]], [[Γ ]] ⇒ ev(h) ⊃ [[σ ϕ[hσ/x]]] ⊃R Σ : [[Σ]], [[Γ ]] ⇒ ∀h.ev(h) ⊃ [[σ ϕ[hσ/x]]] ∀R

Note that [[Σ]], ev(h) = [[Σ, h]], so the topmost sequent is of the form [[Σ, h : Γ ⇒ σ ϕ[hσ/x]]]. By induction, Σ, h : Γ ⇒ σ ϕ[hσ/x] is derivable, and using ∀R, we conclude Σ : Γ ⇒ σ ∀x.ϕ. The ∃L case is similar.
If the ﬁnal inference is ∀L, then the derivation must be of the form

Σ : [[Σ]], [[Γ ]] ⇒ ev(t) Σ : [[Σ]], [[Γ ]], [[σ ϕ[hσ/x]]][t/h] ⇒ [[A]]

Σ

t : τσ → τ

Σ : [[Σ]], [[Γ ]], ev(t) ⊃ [[σ ϕ[hσ/x]]] ⇒ [[A]]

Σ : [[Σ]], [[Γ ]], ∀h.ev(h) ⊃ [[σ ϕ[hσ/x]]] ⇒ [[A]]

∀L

⊃L

Since Σ does not mention name-constants, we have Σ t : τσ → τ and also Σ, σ t σ : τ in F Oλ∇. Note that [[σ ϕ[hσ/x]]][t/h] = [[σ ϕ[t σ/x]]] so we also have Σ : [[Σ]], [[Γ ]], [[σ ϕ[t σ/x]]] ⇒ [[A]], which is the same as [[Σ : Γ, σ ϕ[t σ/x] ⇒ A]]. By induction, Σ : Γ, σ ϕ[t σ/x] ⇒ A is derivable, and since Σ, σ t σ : τ , we can use ∀L to conclude that Σ : Γ, σ ∀x.ϕ ⇒ A. The ∃R case is similar.
Remark 3. If we modify the translation step for atomic formulas by deﬁning [[σ p t]] = Na.p t[n(a)/σ] then we obtain a translation TW X that is essentially the same as TGC , and is complete with respect to F Oλ∇ with ∇-weakening and exchange principles.
We write θ : σ → σ to indicate that θ is a partial injective renaming mapping σ to σ . We say that c-formulas are W X-equivalent (σ A ≡W X σ B) if there is a θ : σ → σ such that θ(A) = B. For example, x, y p(x, y) ≡W X y, x, z p(x, y). Note that ≡W X subsumes α-equivalence. Let F Oλ∇W X be F Oλ∇ except that atomic c-formulas are considered equal modulo ≡W X .
It is not difﬁcult to show that the formulas ∇x.ϕ ⇐⇒ ϕ (where x ∈ F V (ϕ)) and ∇x.∇y.ϕ ⇐⇒ ∇y.∇x.ϕ are derivable in F Oλ∇W X for any formula ϕ. In addition, using the same techniques as above, we can show that the translation is sound and complete relative to F Oλ∇W X . The proof is the same as that for completeness relative to F Oλ∇, except that we need to show that Proposition 4 holds for atomic c-formulas equal modulo ≡W X instead of α-equivalence.
4 Related and Future Work
Besides previous formalizations of nominal logic by Pitts, Gabbay, and Cheney (surveyed in Section 1.1), several other logics and type systems have considered rules for N-quantiﬁed formulas or types. Caires and Cardelli [1] investigated a logic incorporating proof rules for N-quantiﬁed formulas based on maintaining a set of side-conditions involving freshness constraints. However, the freshness constraints are not formulas of their logic. These rules are similar in spirit to (and partly inspired) the slice-based rules of F L and F LSeq. Another related system is the type system of Nanevski [10], which includes rules similar to those of F L for N-quantiﬁed types. A third closely related system is Scho¨pp and Stark’s dependent type theory for names and binding [13], in which a bunched context is used to store freshness information. Our freshness contexts and rules for N are simpler special cases of the contexts and rules in their theory.
There are several directions for future work. N L⇒ may be useful for developing an improved proof-theoretic semantics for nominal logic programming. Natural deduction calculi or type theories for nominal logic based on our approach could be used as the basis of proof checkers and interactive theorem provers for nominal logic. The existence of translations from F Oλ∇ to N L⇒ suggest that F Oλ∇ can be interpreted using the semantics of nominal logic. Moreover, a semantic approach may lead to a simpler proof of the completeness of the translations.
5 Conclusions
This paper makes two contributions. First, we present a new sequent calculus for nominal logic which avoids the slices used in the rules for N in F L and F LSeq. Instead,

our calculus deals with N using freshness contexts that encode freshness information as well as typing information. Although this is partly a matter of taste, we believe that our approach is easier to use and analyze and provides a more transparent reading of N as a proof search operation than any previous system. In particular, the proofs of cut-elimination and conservativity relative to Pitts’ axiomatization seem simpler and require fewer technical lemmas than previous attempts.
The second contribution of this paper is an improved translation from F Oλ∇ to intuitionistic nominal logic (IN L⇒), which explains the behavior of the ∇-quantiﬁer in terms of N. We show that F Oλ∇ can be soundly and completely interpreted in IN L⇒, so any argument carried out in F Oλ∇ can also safely be carried out in IN L⇒. In addition, we argued that the translation originally proposed by Gabbay and Cheney is complete relative to F Oλ∇ with weakening and exchange for ∇.
Acknowledgments Discussions with Ian Stark and Uli Scho¨pp and the anonymous reviewers’ comments were of great value in improving this paper.
References
1. Lu´ıs Caires and Luca Cardelli. A spatial logic for concurrency–II. Theoretical Computer Science, 322(3):517–565, September 2004.
2. J. Cheney and C. Urban. Alpha-Prolog: A logic programming language with names, binding and alpha-equivalence. In Proc. 20th Int. Conf. on Logic Programming (ICLP 2004), number 3132 in LNCS, pages 269–283, 2004.
3. James Cheney. A simpler proof theory for nominal logic. Technical Report EDI-INF-RR0237, LFCS, University of Edinburgh, November 2004.
4. James Cheney. A sound and complete translation of generic judgments into nominal logic. Technical report, LFCS, University of Edinburgh, 2005. In preparation.
5. James R. Cheney. Nominal Logic Programming. PhD thesis, Cornell University, Ithaca, NY, August 2004.
6. M. J. Gabbay. Fresh logic: A logic of FM, 2003. Submitted. 7. M. J. Gabbay and J. Cheney. A proof theory for nominal logic. In Proceedings of the 19th
Annual IEEE Symposium on Logic in Computer Science (LICS 2004), pages 139–148, Turku, Finland, 2004. 8. M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax with variable binding. Formal Aspects of Computing, 13:341–363, 2002. 9. Dale Miller and Alwen Tiu. A proof theory for generic judgments: extended abstract. In Proc. 18th Symp. on Logic in Computer Science (LICS 2003), pages 118–127. IEEE Press, 2003. 10. Aleksandar Nanevski. Meta-programming with names and necessity. In Proc. 8th ACM SIGPLAN Int. Conf. on Functional Programming, pages 206–217. ACM Press, 2002. 11. Sara Negri and Jan von Plato. Structural Proof Theory. Cambridge University Press, 2001. 12. A. M. Pitts. Nominal logic, a ﬁrst order theory of names and binding. Information and Computation, 183:165–193, 2003. 13. Ulrich Scho¨pp and Ian Stark. A dependent type theory with names and binding. In Proceedings of the 2004 Computer Science Logic Conference, number 3210 in Lecture notes in Computer Science, pages 235–249, Karpacz, Poland, 2004. 14. C. Urban, A. M. Pitts, and M. J. Gabbay. Nominal uniﬁcation. Theoretical Computer Science, 323(1–3):473–497, 2004.

