See	discussions,	stats,	and	author	profiles	for	this	publication	at:	http://www.researchgate.net/publication/229026712
Principality	and	Decidable	Type	Inference	for Finite-Rank	Intersection	Types
ARTICLE	Â·	JANUARY	1999
DOI:	10.1145/292540.292556
CITATIONS
70
2	AUTHORS,	INCLUDING: A.	J.	Kfoury Boston	University 291	PUBLICATIONS			3,914	CITATIONS			
SEE	PROFILE
Available	from:	A.	J.	Kfoury Retrieved	on:	26	August	2015

Principality and Decidable Type Inference

for Finite-Rank Intersection Types

A. J. Kfoury y Boston University Boston, MA 02215, U.S.A. kfoury@cs.bu.edu http://www.cs.bu.edu/~kfoury

J. B. Wellsyz Heriot-Watt University Edinburgh, EH14 4AS, Scotland
jbw@cee.hw.ac.uk http://www.cee.hw.ac.uk/~jbw

Abstract Principality of typings is the property that for each typable term, there is a typing from which all other typings are obtained via some set of operations. Type inference is the problem of nding a typing for a given term, if possible. We de ne an intersection type system which has principal typings and types exactly the strongly normalizable -terms. More interestingly, every nite-rank restriction of this system (using Leivant's rst notion of rank) has principal typings and also has decidable type inference. This is in contrast to System F where the nite rank restriction for every nite rank at 3 and above has neither principal typings nor decidable type inference. This is also in contrast to earlier presentations of intersection types where the status (decidable or undecidable) of these properties is unknown for the niterank restrictions at 3 and above. Furthermore, the notion of principal typings for our system involves only one operation, substitution, rather than several operations (not all substitution-based) as in earlier presentations of principality for intersection types (without rank restrictions). In our system the earlier notion of expansion is integrated in the form of expansion variables, which are subject to substitution as are ordinary variables. A uni cation-based type inference algorithm is presented using a new form of uni cation, -uni cation.

1 Introduction

1.1 Background and Motivation

The Desire for Polymorphic Type Inference Program-

ming language designers now generally recognize the

bene ts (as well Languages such

as as

HthaeskceollstsP!)JHofHs+tr9o3n],g

static typing. Java GJS96],

and ML MTHM90] were all designed with strong typ-

ing in mind. To avoid imposing an undue burden on

Partly supported by NATO grant CRG 971607. yPartly supported by NSF grant CCR{9417382. zPartly supported by EPSRC grant GR/L 36963.

the programmer, the compiler is expected to infer as

much type information as possible. To avoid rejecting

perfectly safe programs, the type inference algorithm

should support as much type polymorphism as possi-

bs9alel^:.ty,T.paehn(sedT, whumenraiiirtiontnednuotpya8pltsieo:san,rs,ewafrntoihtrdteepinneotxleyirsm_steeocnrtt.pi)ioahnlistmtyyppaeersse,,

univerwritten written

rithTmhWe mboystDpamopauslaarndtyMpeilninefrerDenMce82a]lgfoorritthhemtyips easlgyos--

tem commonly called Hindley/Milner which supports

polymorphism with a restricted form of universal types.

In practice this type system is somewhat in exible,

sometimes forcing the programmer into contortions to

convince the compiler that their code is well typed. This

has motivated a long search for more expressive type

systems with decidable typability. In this search, there

have been a great number of negative results, e.g., unde-

cidability of System F Wel94], nite rank restrictions of

Fanadbouvnere3stKriWcte9d4]i,nFtersePcitei9o4n],tFy!pesUrPz9o7t8],0F].+AloWngel9t6h]e,

way, there have been a few positive results, some ex-

tensions of the Damas/Milner approach, but, perhaps

more interestingly, some with intersection types.

What are Principal Typings? The various systems of intersection types have generally had a principal typings property, which di ers from the principal types property of the Hindley/Milner system, as described by Jim Jim96]:

PrinciGpiavlenT:ypamesteenrtmAM. typable in type environ-

There exists:

a type types for

MrepirnesAen. ting

all

possible

Principal Typings

Given: There exists:

a a

tjuydpgaebmleetnetrmA

ing all possible

M` M. :
typings

forerpMres.ent-

A typing for a program is principal if all other typings for the same program can be derived from it by some set of operations. As explained by Jim, this kind of approach supports the possibility of true separate compilation as well as other bene ts.

Principal Typings with Intersection Types The rst

system of intersection types for which principal typings

was proved (as far as we are aware) was presented by

Coppo, Dezani, and Venneri CDCV80] (a later version

iirstigihCstDsioCmfVi\la8!r1]"t)o.aLonuidkres^mi-nealnitmhyaisntya\stt^ieo"mn cscaoanfninnootntelryaspeocptceicoaunrrttoaytptehse-,

term variables. Like our system, this system is restricted

so that the binding type of the bound variable of an

abstraction must be an intersection of exactly the set of

types at which it is used. However, this system di ers

from ours by allowing di erent occurrences of the bound

variable also has

to use the same member of an a rule to assign the special type

!int(errespercetsieonnt.inIgt

the intersection of 0 types) to any term.

There is a general approach for an algorithm for

nding principal typings that was followed by Coppo,

Dezani, and Venneri for their type system as well as

by Ronchi della Rocca and Venneri RDRV84] and van

Bakel vB93] for other systems of intersection types. In

this approach, the principal typing algorithm rst nds

a normal form (or approximate normal form) and then

creates a typing for the normal form. A separate proof

shows that any typing for the normal form is also a

typing for the original term. The algorithms of this

approach are intrinsically impractical, not only due to

the expense of normalization but, more importantly, be-

cause there is no possibility of a short cut to normaliza-

tion. The principality of the principal typing is shown

using a technique of several di erent kinds of opera-

tions: expansion (sometimes called duplication), lifting

(sometimes called rise), and substitution. The biggest

di erence with the approach we present in this paper is

that we use expansion variables to formalize expansion

in a much simpler way as part of substitution. This

allows our approach to be based on both substitution

and uni cation. This opens the possibility of more ef-

cient algorithms by adding additional (unnecessary)

constraints to the uni cation problem to shortcut the

solution, an adaptation we leave to future work.

Sayag and Mauny SM97, SM96] continue the ear-

lier work cited above, and succeed in de ning a simpler

notion of principal typings for a system of intersection

types. An important di erence with our analysis is the

continued use of an expansion operation, although con-

siderably simpli ed from earlier formulations, in part

because they restrict attention to -terms in normal

form. Moreover, their approach is not substitution-

based and it is not immediately clear how to extend

it to arbitrary -terms not in normal form.

The rst uni cation-based approach to principal

typing with intersection types is by Ronchi della

Rocca RDR88]. Of course, the general method here

will diverge for some terms in the full type system, but

a decidable restriction is presented which bounds the

height of types. Unfortunately, this approach uses the

old, complicated approach to expansion and is very dif-

cult tivity

to understand. It and associativity

aolfs\o^h"a.s

trouble

with

commuta-

Subsequent uni cation-based approaches to princi-

pal typing with intersection types have focused on the

rank-2 restriction of intersection types, using Leivant's

notion of rank Lei83]. Van Bakel presents a uni ca-

tion algorithm for principal typing for a rank-2 sys-

tem vB93]. Later independent work by Jim also at-

tacks the same problem, but with more emphasis on handling practical programming language issues such as recursive de nitions, separate compilation, and accurate error messages Jim96]. Successors to Jim's method include Banerjee's Ban97], which integrates ow analysis, and Jensen's Jen98], which integrates strictness analysis. Other approaches to principal typings and type inference with intersection types include CG92] and JMZ92].

1.2 Contributions of This Paper
The main contributions of this paper are the following:
A fully substitution-based notion of principality for a system of intersection types (with or without a rank restriction on types). Expansion variables abstractly represent the possibility of multiple subderivations for the same term, supporting a substitution-based approach in place of the old notion of expansion. This contribution makes the technology of intersection types signi cantly more accessible to nontheorists. The notions of expansion in earlier literature are so complicated that few but the authors could understand them.
A uni cation-based type inference algorithm for intersection types using a novel form of uni cation, -uni cation. The algorithm always returns principal typings when it halts. The algorithm is terminating when restricted to nite-rank types. This algorithm is the rst understandable type inference algorithm for intersection types beyond the rank-2 restriction which does not require that terms rst be -reduced to normal form. Although it may seem that there is quite a bit of material in this report, the vast majority of it exists only to prove properties of the algorithm. The actual algorithm is largely contained in de nitions 2.11, 2.12, 2.13, 2.15, 3.1, 4.1, 4.2, 4.4, and 5.1, together with theorem 5.6.
Decidability of type inference and principal typings for the restrictions to every nite rank. Ours is the rst system of intersection types for which this has been shown. At rank 3, to(shhueoxrw:zsvn(yexsur(tynetmfypupo:aafwlburele)rea)fu(idnxly(Fst!yvysgpbt:eegysmvU)t)re)Fzr(ym!c,ysz:yyenny.ogyt.U),,rtwzyt9hhp7eiac]b.hlteewraimns

1.3 Future Work

Using Intersection Types in ried out in the context of

tPhreacCthicuerchTPhirsowjeocrtk,1isacafor--

cused e ort to explore the implications of intersection

types for programming language design and implemen-

tation. The Church Project is actively implementing

and evaluating intersection-type-based technology in an

ML compiler. A number of practical concerns need to

be addressed to nish the task of making the technol-

ogy presented in this report usable in the overall project

e ort. In particular, the following tasks are important:

1hURL:http://www.cs.bu.edu/groups/church/i.

1. Adapt the technology to type systems in which \^"
is associative, commutative, and idempotent. This will be vital for reducing the space and time complexity of our algorithm, because it will enable the expression of the rank restrictions without requiring an essentially linear ow analysis. 2. Add support for sum types, e.g., booleans and conditionals. This is highly likely to require the addition of union types. 3. Add support for recursive de nitions, e.g., a xpoint operator or letrec bindings. This will signi cantly complicate the analysis, because it will interfere with the invariant that -compatible constraint sets (de nition 3.7) have constraints neatly divided into positive and negative types (de nition 3.3). Also, polymorphic/polyvariant analysis of recursion is notoriously di cult. 4. Take advantage of the new notion of substitution developed in this report to devise e cient representations of polyvariant program analyses. This is particularly promising.

Theoretical Concerns The work presented here inspires the following possible tasks:
Investigate the relationship between -uni cation and other forms of uni cation { decidable and undecidable. In particular, investigate the relationship with second-order uni cation and semiuni cation. Further develop the meta-theory of -uni cation. In particular, investigate conditions under which uni cation (1) satis es a principality property and (2) is decidable. Use this to develop more sophisticated type inference algorithms. Investigate the complexity of the decidable niterank restriction of -uni cation introduced in section 6. Separately, investigate the complexity of the set of programs typable in the various niterank restrictions.

2 Intersection Types with Expansion Variables

This section de nes a system of intersection types for

the -calculus with the additional feature of expansion

variables. The expansion variables do not a ect what is

typable; instead they support reasoning about principal

typings via a notion Throughout the

of substitution. paper, the notation

X~ n

is

meta-

notation notation

Xs~tasntdanindgs

for for

Xt~hne

notation for some

X1; n

: : : ; Xn. The 0 which either

does not matter or is clear from the context. A warning:

Some authors use the notation X for similar purposes,

but in this paper the bar mark on a symbol is not used

to stand for a sequence.

2.1 The Type System
De nition 2.1 ( -Terms). Let x and y range over
-Var, the set of -term variables. We use the usual set

of -terms

M; N 2 ::= x j x:M j MN ;

quotiented by -conversion as usual, and the usual notion of reduction

( x:M)N ! M x := N] :

AMs. usual, FV(M) denotes the set of free variables of

The following de nition gives a structure to type variable names that will be helpful later when we need to rename them distinctly.

De nition 2.2 (Type Variables). The set of ba-

TstftbhoiaaVcseniaiWcaurjtbmynieEpai2eoe-unvn(sdNaaevrEnEaibgVdaVri.ibanalalararebbTbtrsleeyahrsiresTstetoEoVsrderriVainetsrangjbboros.aabifmnsi=nitbceas)fsfe0viTtcF;as-1i,rveigajaaxnribp,idal2aecnbusaNsl.sleileoesIgfndV.siaos;vrWtab rT2steieoVatfabda0sllrease;bnubs1eomglot=seer,,

ws e

wtritheolsds

t i

fotr

=thesir

sco0 nfcoartesonmateions0.

2Thf0e; s1tgat.emTehnet

set of type variables or T-variables and and the set of

expansion variables or E-variables are:

TVar = f asi j i 2 N; s 2 f0; 1g g EVar = f Fsi j i 2 N; s 2 f0; 1g g

LteFaEWamnsiVekedttapi.nrTut.lygesVLFetsaaeotrtivFrraiten(nox(agdiaapb.nnmpeELdriVpaetoaatl"iperl(r,iacbapiinasfesir)dto)etmplbFdydeeieeretdltnnaayoeovocteatbmoexeresriteaaaetaFbtsinasi"ielvdt,,edastaw)TrhnirhVeaadaenbsanrlrlegaeebitt"narm(dgnadFeendesiontgn)avEoitoventVatrdegaerseTsrinoaabVtvobsibhetaltyeeerr. ranging over the disjoint union Var = EVar TVar.

De nition 2.3 (Types). Let \!" and \^" be binary

tTy!peascownesltlrausctmorest.avaTrhiaeblseest

T of types and its subset over these sets are given as

follows:

2 T! ::= j ( ! ) 2 T ::= j ( ^ 0) j (F )

Note that is only a metavariable over T!. The letters and will be used later to range over certain other
srauicg2cbhostrTedtcsithnhoiglafdtTtono. fotOh\\be!^s"er"ur.avlene dWitnhneatothsoEe\m-!tvreaet"reimiaarbneepslderoe\cms^aenin"ttoaapctsacisouronercniaoathtfseeatsnhteyoes (theh3i.geg=h.r,ei(rg(FhFptre)a1cn)ehdd^aestnh2hce)eig!athhpeaprn3lip.c\ra!etcieo"dn. eFnoofcreaentxhaeamxnppa\lne^,s"iFownh1vi^achria2hb!ales

De nition 2.4 (Type
vironment is a function

AEnfvroimronm-Veanr ttso).T

A type with

ennite

domain of de nition. A type environment may be writ-

ten as a nite list of pairs, as in

x1 : 1; : : : ; xk : k

rfaT(toAohnrnedanxmsnoA7!demAnnxetssxo=,d]m)7!it(shAxetei)n?nk]=cAtfixsx^17!a;tB0nh:.d:Aei:s((;xtAaIxyf)kgpnxA.ee2w7!IfeistnA-yVv]pa)aiar(ernoy,tden)ysnmpoB=vmeeirnaAeoetrnn(eym1vst);iuyer:iocnp:fhnt:eym;geti6=nevkhnvea2tixnt-,
by:

(A

^

B)(x)

=

8>>>>><>>>>>:AABun(((dxxxe)))

^ B(x)
ned

if both A(x) and B(x)

idfeonnleydA, (x) de ned,

if if

only both

BA((xx))

daendnBed(,x)

unde ned.

IrfonFme2nt,EVthaernisF

an A

E-variable is the type

and A is a type environment such

envithat

(F A)(x) = F(A(x)).

De nition 2.5 (Skeletons and Derivations). The
sets of judgements, rule names, and pre-skeletons are determined by the following grammar:

J 2 Judg ::= A ` M : j A `e M : R 2 Rule ::= V^Aj RF j ABS-K j ABS-I j APP j Q 2 PSkel ::= hR; J; Q~i

Jreusdtrgiecmt etnhtes^foramndedFwriuthlesthseo`tehessyemrbuolelswailrlebueseudseodntlyo

fOobr sseurbvteertmhastwahipchrea-srkeetlheteoanrgSumisenatsruolfeannaamppe,licaationna.l

judgement, and zero or more subskeletons. The order
nothfaamttAh,eefsofsokrureebleevsvtekoerenyrlyestSuFobno-2spf irESseVy-sssiakgtreen.mlietcoIannisQt.a0 N=porhteRe-s;tkJhe;alQet~tiFonocisQcuarsrruiunclhge

in Q, it holds that the judgement J is end judgements of the pre-skeletons

Qo~b(twaihnoesdefroormderthies

signi cant) by rule R skeletons of System I

and rule in gure

R 1.

is one of The rule

tnhaemreudle\s(fSor)

APP" order

is of

used in skeletons the pre-skeletons

Q~fordettheermcainsees

of APP. The the order in

wthheicrhultehRei.r instead as:

eAndskjeuldetgoenmheRnt;sJ;mQu1st:

:m: Qatncihmthaeypbreemwirsietsteonf

Q1

::: J

Qn R

aeinvsearAgyuudsureeesreoi1vf.oatfthTitoehhnmeeD\or(ruoDelfe)rSenAysatsPmrtiePcemt"divIr\eui(srlSeua)ldesAiknPeealrPemst"oefdnraolS\ms(oDstuq)hcuehAa\lPti(hPSae"s)t
APP" rule in requiring the type of the term in function position to be a function type, requiring the domain portion of the function type to match the type of the term in argument position, and requiring the codomain
iacpnaloltnrestrrkipeoefrnleeertotiotfnontghseteiathnfheudenrrucdAlteeiros`invinaMttyipog:neusrteoobr1emA,loatnh`tcgeehptMtoahtSe:tyerrse.ntseHuAmletn`Itcy.?epMfoer. t:Ihn,
Observe that the set Deriv of derivations is a proper subset of the set Skel of skeletons. Henceforth, we do not consider pre-skeletons that are not also skeletons.

aA d`LerMeitvat:thieo.nsWtDahteeomnf etSnhytissAtheom`ldIsIM, wwhe:ossaeyhotlnhdaalti

for M. A term holds for some

AManisdtyp.able

in

System

I

i

there exists
jDuAdigs`eamIteMynpti:nigs

Observe that the rule ABS-K is not a special case

of the rule ABS-I. This is because there is no rule or

other provision for \weakening" (adding redundant type

assumptions to a
twhheerreefoxre62, ifFtVh(eMre

)it,sytapheperneonoAvfi(rfxoo)rnimtsheennojtut)ddigneemonueerndts.yAst`emMan: d

The following result is merely what anyone would

expect from a without a rule

fsoyrst!em.

of

intersection

types

formulated

Theorem 2.6 (Strong Normalization). M is strongly normalizable (i.e., there is no

A in

-term nite -

reduction sequence starting from M) if and only if M is

typable in System I.

Corollary 2.7 (Undecidability of Typability). It is undecidable whether an arbitrarily chosen -term M
is typable in System I.

Later in the paper, we will show certain restrictions of System I to have decidable typability.

Remark 2.8. System I does not have the subject reduction property. For example,

z : 2 ! 1 ! 3; w : 1 ^ 2 `I ( x:( y:zyx)x)w : 3 ;

but

z : 2 ! 1 ! 3; w : 1 ^ 2 0I ( x:zxx)w : 3 :

By theorem 2.6, typability is preserved, so for example:

z : 2 ! 1 ! 3; w : 2 ^ 1 `I ( x:zxx)w : 3 : (pT1oh)tee\n^rte",a(si2os)nntehfioetrhiemtrhpaeliscsliaotcc^kia-teoilvfimes,uincboajmteicomtnurdteaodtnuievcetb,iyonntohriesidVteAhmaRt-
rule and the way type environments are built together x the component of an intersection type associated with a particular variable, and (3) there is no provision for weakening (i.e., introducing unneeded type assumptions). If subject reduction is viewed as a means to achieve other goals rather than as a goal by itself, then the lack of subject reduction is not a problem, because derivations of System I can be easily translated into derivations of more permissive systems of intersection types (see vB93] for a survey) for which numerous desirable properties have already been veri ed. The features of System Iwhich prevent subject reduction make the later analysis of principal typings and type inference much easier.

2.2 Substitution The notion of substitution de ned here will be used later in uni cation for type inference and in establishing a principal typing property for System I.
De nition 2.9 (Type Contexts). The symbol de-
ansesottfeTosl!2loawa\ssh:woleel"l.asTmheetsaevtaTri2abolfestyopveercotnhteesxetsseatnsdarietsgsivuebn-
' 2 T!2 ::= j j (' ! ') ' 2 T2 ::= ' j (' ^ '0) j (F ')

Inference Rules for both Skeletons and Derivations

VAR x : ` x :

ABS-I

A x 7! ] ` M : A ` ( x:M) : ( ! )

^

A1 `? M : 1; A2 `? M : 2 A1 ^ A2 `e M : 1 ^ 2

F

A `? M : F A `e M : F

ABS-K

A`M: A ` ( x:M) : ( 0 ! )

if x 62 FV(M)

Remember that ; 0 2 T! and F 2 EVar.

Inference Rule for Skeletons Only

Inference Rule for Derivations Only

(S) APP

A1

`M: A1 ^

; A2

`

A2 MN

`?
:

N
0

:

(D) APP

A1 ` M : ! ; A2 `? N : A1 ^ A2 ` M N :

Figure 1: Inference Rules of System I.

ndNeohntooelteetsh,tahwtees'ewirnsitoehno#llye2sa(i'nm) te=htaenviraaroniraddbeulerseoovf eo(r1c)cT,u!2:r:r.:e,nIcf e'(nin)hat'os fitaDinmrhoegetmmysnpeu1idle;tbeii:fsaot:etn:tet=;o2Tr.in!3rg'i.hg.2thS1tTop;.f:ei:C\cn:i!a;trch"eane,l]mltyhhw,uoeslhinetfischbhoioeflmieas'puvpsinat(liil)eiboddreindawrece'rhcsetotirnrosidcioittnnobesgdtetarhttitnooe-

De nition 2.10 (Expansions). The set E of expan-

sions is a proper grammar:

subset

of

T2,

de

ned

by

the

following

e 2 E ::= j (e ^ e0) j (Fe)

In no

wTo-rvdasr,iaabnleexapnadnsnioon\!is a".type

context

which

mentions

De nition 2.11 (Paths in Type Contexts). We

de ne path position of inition goes

a(si) as

a partial function which determines the

in ' as follows,

a string using a

in f L; R; 0;
\value" of

1?g

. to

The defindicate

that the function is unde ned on that input:

path( (i); )

=

(" ?

if i = 1; otherwise.

path( path(
path(

(i); ) (i); ' ! ')
(i); ' ^ '0)

= =
=

?8

>>><

L R

>>>:8>>><?01

>>>:?

p q p q

if p = path( if q = path(

((ii?) ;#'2)('6=)?) ; ;')

and q 6=?;

otherwise.

if p = path( if q = path(

((ii?);#'2)('6=)?); ;'0 )

and q 6=?;

otherwise.

path( (i); F ') = path( (i); ')

Lfctnha0oeua;tt1nsmepgaieantnnfhtofsiroe(Lxn'a;p)\dRa!=n;u0sa"i;lf,o1pnapguapert.apht2o(hWsEei(ne:i)iea;sth'sisau)pastjayst1utphsreseinicignboiinnentxa#efprx0y2at;n(1s'tsgthi)roaignntr.sagdtsaBhoneieendsr-
as o set labels to rename variables (see de nition 2.2). The coincidence between the two is by design.

De

tf

2 L;

nition 2.12 (Variable Renaming).

fR0;;01; g1g)(,wwee

do de

not ne

aneveadriatbolecornesniadmerintgheh

For every
liatrfgreormseTt

to T, by induction:

1. h si it = si t for every si 2 TVar.

2. h ! it = h it ! h it.

3. h 1 ^ 2it = h 1it ^ h 2it. 4. hFis it = Fis t h it for every Fis 2 EVar. In words, h it is obtained from by appending t to
every o set that is part of a variable name in .

DsrSwhetarisevtipute2eetnicaoTSitntns!Fio\Einssif-noovarrs2attr.tsee1io"vaa3t,ebdarlilye(.oeSff.uo,urnSSb2c(\FtsF^itTo)i"V2ntauaiSnnErt.dio:ofNonuSVrotaetorerevnim!netsrhoTtysa(etEytaFpdpSeo2(oTssfi)!t)E.iSVoc)(nAaaw.nr)hs,anWuincaobdhest-

ltountgionasSntoo

aamfbuingcutiitoynisS

introduced. We from T to T by

lift a substiinduction on

T:

1. S = S .

2. S( ! ) = (S ) ! (S ).

3. S( 1 ^ 2) = (S 1) ^ (S 2).

4.

S(F ) = e S(h where SF = e #2(e) = n.

is1); : : and si

:; =

S(h isn
path(

)(i]),

;

e)

for

1

i

SWhefonr nSo(

ambiguity ).

is

possible,

we

write

S

for

S

and

DStEmfTrDDiaev:oioi2nammnVlTo(i(aStfSEVriS))o-a:d!rn(=oTojm2rhS(f.eatE1hiFnn4e6=o2st(auaTSnEptg!udiVp;oop)anrrnrpetbosjoponeSrf-etFtacSrti)oi6=vsvfiuiesaFblSlDys.utoTibTmtg-usdh(attoSeinimot)dnnua=o.tTinniEDo-tTDnoroimhsofv)mei(.SaS(lnS)Loda)nore=et--

fF1 := e1; : : : ; Fm := em; 1 := 1; : : : ; n := n]g

fdwehn1eo;r:tee: s:E;aDonsumgb.(sSt)itu=tionfFS1;w:i:t:h; FthmeginadnicdatTedDomma(pSp)ing=s

DSkeelnetitoinosn).2.1T5 h(eOnpoetriaontioonfs

on Judgements and
renaming from de ni-

tion 2.12 is lifted to type environments, judgements, rule

names, The

a^ndospkeerlaettoornsanind

the obvious way. the operation of

applying

an

E-variable are lifted to skeletons as follows:

1.

S ^ S0 = h^; A1 ^ A2 SS 0==hhRR12;;AA12``??MM ::

1`2;;eS~S~Mi0ia.n: d1

^

2; S; S0i if

2.

F S

S
=

= hF; F A `e hR; A `? M :

M ;

S~: iF.

; Si if

Using the preceding, the notation for \expansion lling"

is lifted to skeletons as follows:

1.

(eeS^1;e:0:):S;1S;j:]:

:; =

SSn, ]a=ndSe^0 SSj+0 1if;

:#: 2: (;eS)n=] =j,S

0.

2. (F e) S1; : : : ; Sn] = F (e S1; : : : ; Sn]).

3. S] = S.

SlSmif((teAAenTd(txh`ste)?so)o.nMsotkShteiual:oetbntsoS)toniAf=tsusauitSssibo(tfsnAohtli)eltiosuf`wutl?iisnof:tcMnetdiios:ntloSisftu(jeucd)hd.gttoehSmauttybepns(ttSeisteAusnt)ovi(oixtrn)hona=ist-

1. SRhR2=;EJV; Sar1.: : : Sni = hR; S J; (S S1) : : : (S Sn)i if

2.

ShF; J; Si = e S(hSis1);

SF
1

= i

e

#an2d(es)i

= =

path( n.

:

(:i:)

; S(hSisn ; e) for

)],

where

Lemma 2.16 (Substitution Preserves Skeletons

and Derivations). Let S be any substitution.

1. If S is a skeleton, then S(S) is a skeleton.

2. If D is a derivation, then S D is a derivation.

DsDfourebissMtnaitiutapitnroiidonnncfo2iSpr.a1els7vutecy(rhpPyintrohgitnahtfceoirDrpta0yl-=ptTeinrSymg(pDDiMn)0.gfsoiT)rh.DMeAp,isrdtiehanrecitrviyepaaptiliisiontnagy
property for typings is the existence of a principal typing for every typable -term.

Subsequent sections will establish that System Ihas the principality property. We next give two simple examples to illustrate how notions introduced so far are used, in particular, the key concepts of \skeleton", \derivation" and \substitution" in the presence of expansion variables.

tpaSI(E(thnr1xeoxxdiasd::fsxxmouiijtz))rcups((eesldtMoseyyif::zaf1yy2reM.yyo.d1m))i1es8).:c.TotM(hrhPaDe1ertreeebipdsnfyokiLccrevtetielehpteeradet\solsiSnomMiknnae1Sllol1"fag,ldtugihseior.Tneeero.aiy,tptp2heappimrnrasiogsertopthfitoacerrsuetelesicaoktrnoei-oflateonfletMnrootm5erno1., yy

x yy

x:x y:yy

( x:x)( y:yy)

tiAnapinpnAliaystnseinoloycgtihmaaetnraendsaykrwebslikeittethrolaenSrty1ofnoisrssuafMbosrc1to.iMtnuTs1tth.irouanisn, ttSos1eStis1,awscehceamne

obfor

1

=

f

G1

!2 =:

G1 (=:FG3(

!2 ^

F 1)

g3

!

1) !

2;

(p\rCodouncsetrdaifnrtomsetsM" 1anbdy

the ? algorithm of section 5. restrictions on them are de ned

ialpnalrgreocsriu1sitbehflsyomtriitnueoaftsicesohcentciutoSisnoe1n,3o.o4f)b,ttNihasoeigntieAevdtPehnPfarbotrymtu:hleerie1niusSso1inn. egActohpneastUrrtaniciinufyt-

SSS111F21===FFS1

,

2!=S1(,G(F=S1!,3

) =

^F
,

S)1!1

, =

.

AotphpelrysinkgelestuobnstwithuitcihonisSn1otwo
depicted in gure 2.

sakdeleertiovnatSio1n,

wDe1

o=btSai1n(Sa1n)-,

tfSoh0r.atAMD1c1oisnissoaefqptuhreiennfccoieprmoafl tDtyh0pe=inagnSaf0o(lyDrsM1is)1if,noir.sese.oc,mteivoeenrssyu4btysatpnitidnugt5iDoins0

E((oaffrontoxrexxemadA,M::mpswMyy2pr::.iiolxxnt2dheyybue))2ySx((c.ea21tdzzmh9i::sezzfprzz(l?toeA))hm).ae2.Dl.gN1feoo82plr,lPiioLbcttwrhthyeemiitenndtghcsiokMenifpceSoal2seenklgtcesoudttlnrireoeaannSli3gonT2ot5tiersy:iissptaehitatnshm,kgpepe.alrerAottdio-sctusnufeocorlcSeamird2r-

2

=

f

1
H1

=!3: =F:FH22(!G!

411!, =:

H2)(g.3

^

G

4!

2) !

3,

AthepUarntiicfyulaalrgosruibthstmituotfiosnectSio2n,

obtained from 4, is given by:

2 using

SSSS2222F1102====

SSS222^

G233 ===,(G(.GS2!G!=,

G) S^2,G12S)=2!HS2=,4

, =

,

awocOlnaebysyasprepsrruwiavnbrehgtseisttcnihutauwl02atte,riaoincvnnodasntluahsreii12desteoaeorfpxtpahml22ie,epidabtlsceu\et,tolifSoud.n2tosTeoiadhsfseisnSs-igio2nfnto"osln,lnoveaweaFndlsdutefb2ros:oetcamoossmttighhenees

(S(G2 (^F!G2 ) ))=S^(G02 ;^S:G12 ])=SSh

202i0^;

GSh(S2i121)]

= =

AnepwplsykienlgetsounbwsthiticuhtioisnaSls2o
depicted in gure 3.

to skeleton a derivation

SD22,

=weS2o(bSt2a)in, aas

tfSoh0r.atAMD2c2oisnissoaefqptuhreiennfccoieprmoafl tDtyh0pe=inagnSaf0o(lyDrsM2is)2if,noir.sese.oc,mteivoeenrssyu4btysatpnitidnugt5iDoins0

The skeleton S1 = Skel(M1) is:

x `

:1 x:x

`
:

x 1

:1
!

VAR
ABS-I 1
`(

y: x:x)(

2 ` y : 2 VAR y: 2^F ` y:yy : 2
`e y:yy : G(
y:yy) : 2

y:
y:F 3 ` yy ^F 3 2^F

3:!33!`1`e1yy1A)::BGAFS3P-VIP3AFARPP

Letting 1 = ?(M1) and S1 = Unify( 1), the derivation D1 = S1(S1) is:

x `

: `x x:x :

:
!

VAR y : F !
ABS-I
` ( x:x)( y:yy)

`y: y : (F
:

F

!

VAR

y: y:F

! ) ^ F ` yy :

` y:yy : APP

`y: `e y :
ABS-I

VAR

F

F APP

where = ((F ! ) ^ F ) ! .

Figure 2: Skeleton S1 and derivation D1 for M1 = ( x:x)( y:yy).

The skeleton S2 = Skel(M2) is:

x:

1

`x: x: x:
` x:

VAR 1

y: y:F

1; y : F 2 ` xy

1 ` y:xy : F 2

y:xy : 1 ! F

!22:2!``1e1yy1A::BAF2SB-VSI2A-FAIRPP

` ( x: y:xy)(

z:

3`z:

VAR 3

z: 3^G

` z:zz : 3

`e z:zz : H(

z:zz) : 3

z:
z:G
4 ` zz ^G 4 3^G

4:!44!`2`e2zz2A:):BHAGS4P-VI4PAGARPP

Letting 2 = ?(M2) and S2 = Unify( 2), the derivation D2 = S2(S2) is:

x:

3`x:

3

VAR y : 1 ` y :
x : 3; y : 2 ` xy : x : 3 ` y:xy : 3 ` x: y:xy : 3 !

1 VAR
y : 2 `e
ABS-I 3 ABS-I

y: y:G y: 2

`y `e y
APP

: :

VAR

G

G ^

` ( x: y:xy)( z:zz) : 3

z:

1`z:

VAR 1

z

z : 2 ` zz

` z:zz :

z: `z:

: G `e z :

: 3

ABS-I APP

VAR

G

G APP

where 1, 2 and 3 abbreviate the following types:

1 = G ! ; 2 = 1 ^ G = (G ! ) ^ G ; 3 = 2 ! = (G ! ) ^ G ! :

Figure 3: Skeleton S2 and derivation D2 for M2 = ( x: y:xy)( z:zz).

3 Lambda-Compatible Beta-Uni cation

The problem of -uni cation was introduced and shown undecidable by Kfoury in Kfo9X]. This section introduces -compatible -uni cation, a restriction of uni cation, in order to develop a principality property and in preparation for a uni cation algorithm presented later.

De nition 3.1 (E-paths). The set EVar of all nite

sequences of E-variables is also called the set of E-paths.

We de ne a function E-path from Var T to nite sub-

sets of EVar . By induction:

1. E-path(v;

)

=

(f"g
?

if v = if v 6=

; :

2. E-path(v; ! 0) = E-path(v; ) E-path(v; 0).

3. E-path(v; ^ 0) = E-path(v; ) E-path(v; 0).

4.

E(-ffpF"agtG~h(jfvGF;~FG~2

)
jEG-~pa2thE(-vp;at)hg(v;

)g

if v 6= F; if v = F:

=

De nition 3.2 (Well Named Types). If 2 T, we

write EVar( ) for the set of E-variables occurring in ,

TVar( ) for the set of T-variables occurring in , and

Var( that

) a

tfyopr ethe2diTsjoisinwteullnnioanmEedVair(

) TVar( ). We say both of the following

statements hold:

1. FfGo~rge(vaersyinvgle2toVnars(et)),withehroeldvsdtoheastnEo-tpoacthcu(vr;in)G~=.

2.

Ff0o;r1gall, ivfss; vt

2 Var( ) with t then s = t.

v

basic

and

s; t

2

Informally, the rst condition says that, for every (type or expansion) variable v, the sequence of E(v-iveawreiadbalessaentrceoeu)nttoeraendyaosccwuerrgeoncferoomf vtihsearlwooatysotfhe
IEsfa-mpEae-tp.haF(tvuh;r(tvh);e=r)mF~iosrwet,hitEeh-osvuiantrgialaembtlobensigduseoittyn.foFt~ng,eswt ethceamnsewlvrietse. ivnariTa,bhtlheeesvnescnotonisdpcrcaoolpnleeddritaoionnsopsrasiynpsgritnohfgavtofiofvcasc.uvraNsroiiatnbelteh, vawtohtceycrpueerass
that mention only basic variables automatically satisfy the second condition.

De nition 3.3 (Positive and Negative Types).

We identify two proper subsets R and S of T, which

we call the \positive types" and the \negative types",

respectively. We rst de ne R and S with polarities

inRse!rteadn,das

S!R,

and S, de ned simultaneously together with metavariables over

with these

sets, as follows:

2 R! ::= + j ( ! ) 2 R ::= j (+F ) 2 S! ::= ? j (+F ! ) 2 S ::= j ( ^ 0) j (?F )

We obtain R! and R from R! and

bSyfroommittiSn!g

all polarities. and S.

Similarly

we

Rob, traeisnpeSc!tivaenlyd,

Note that there is a restriction that exactly one E-

v\a!ri"a,balendoc\c^u"rs

in each positive position to the left of occurs only in negative positions. Note

asulsboIsfethtsat2Rt!hRea(mnredestpSa.!va,rir2aebsSple)es,cttihvaeenrldey.

is

are restricted to the exactly one way of

(t(Linyrne)espt+eseedpr(tf.erin)xo0+mgp(2rr2peeRSsoss)plit.a.ooRrnWito(0ie)erRbsettwshaaipinuint.nshde(hd(pa()borv)?ey?leasi2prtnfiwr.tsoioeemrsS)wt)iSisnesoblglt-eiotpndhtoeahlateSnRr.etiuthdn(ieerifseqursuinepnsec.ultyilot2idnSneRs)g-:.

De nition
an equation

3o.f4th(Ce ofonrsmtrain=:t

S0 ewtsh)e.re A ; co0 n2strTai.ntAins

instance of -uni cation is a nite set of constraints,

i.e.,

= f 1 =: 10; 2 =: 20; : : : ; n =: n0 g

GEaIfnVivdaerVn(isa1ra(^osfe)ttf^hooerf na0ct)bho,noeTvisrtVerdafaoiris(nrjmotsi),nawtfoneurdnwtFihroeint2seEeEEtVVVTaaarV(rr,a(rw())e1fw^oTrrVittaher^e(Fsne0)t).
to denote the set of constraints:
F = F =: F 0 j =: 0 is a constraint in

DVcbueaerr(orfne)nitt\chioeiVssna)fr.o3(r.mL5)e.t)(=OF~uW?t2:eer(EsAVaalyanlrdct,ohInenstne2rxeapRrinatnEassn-iVodgneanrevir2aaarbtiSaele,dblwOewitciGlh-l

Fh~as

=a: nF~outierG(r2esFp~.

inner (resp.

) i

occurrence
G 2 EVar(

in the constraint
^ )). In words,

an \outer" occurrence appears on both sides of the con-

straint and at the top level. Occurrences of T-variables

are always inner; only occurrences of E-variables are

di erentiated between outer and inner.

Let speci ed

be a in the

nite two

psreetcoefdicnognsptararaingtrsa,pehasc.hWofetshaeyfoGrm2

EVar has an outer (resp. inner) occurrence in if G

has an outer (resp. inner) occurrence in a constraint in

.

The de nition of \outer" and \inner" occurrences of

Etio-vnarF~ia(bl)e+s

c=:arF~ri(es)o?vearf,teinr

the obvious way, to the polarities are inserted.

equaOnly

inner occurrences are said to be positive or negative.

De nition 3.6 (Connected Constraint Sets). We

s\sffoat~rry1a=:1i=t:nh~tas01t"0 ;Via:ias:=r:c:(\o;ninn0sn=t:?=a:r=na: 1idi0nn)0 ntw"0~g\.hs=ee:trVe~a0r\(isinsui+c=c:h1o,n=t:nht0he"aceit0+triese1d)\air6=1e

for all conconstraints
?
=: 10" and

De nition 3.7 ( -Compatibility). A constraint set

is -compatible i is of the form:

= fF~1 1 =: F~1 1; : : : ; F~n n =: F~n ng

wimf hoerireeo2vF~eRri !2

EVar then satis

e,isaa2nldlSo!fith2feoRrfoelalvonewdriyng1i

2

Si

sucnh,

that and

conditions:

(A)

is type

F~w1el1l

^naF~m1 e1d,^whi^chF~nwen

^deF~nnentios

hold i the well named.

redundant mappings. The three principal solutions in question are:

(B)

Every expansion variable F 2 EVar
one inner positive occurrence in ,

has i.e.,

at most +F oc-

curs at most once in , where is obtained by

inserting polarities in :

= fF~1( 1)+ =: F~1( 1)?; : : : ; F~n( n)+ =: F~n( n)?g

(C) Every type variable 2 TVar occurs at most twice

in . itively

And if as +

iatnodccounrcsetwneicgea,tiivteolyccausrs?oncienptohse-

constraint set .

(D)

For Var(

e)ve\ry

constraint F~ Var( ) = ?.

=: F~

in

, we have

(E)

FFV~oarr(einv0e)r\y

?conn0e,cteeitdher0
Var( ) = ?.

Var(

a0n) d\cVonars(tr)ain=t

F~
?

=: or

In words, the variables of a connected 0 can
oovf earlcaopnwstirtahinttheF~inn=:erF~variinables?of a0.t most one side

S1 = f F := ; G := ( ^ ) ^ ( ^ )]g S0 S2 = f F := ^ ; G0 := ^ ; G1 := ^ ]g S3 = f F := ( ^ ) ^ ( ^ );
G00 := ; G01 := ; G10 := ; G11 := ]g

S0 S0

wfr4oh]gme.retNhSoe0noe=thofefrth0t0ewot:=hbryee1v;saurb0ia1sbti:lt=eutrieon2n;asm1ci0anng:=,bien

3o;bt1a1in:e=d contrast

thuiSSSptiUbr;;ohianae21tnjjevflh,i=iorpef2msery2craoeiafSnilfn=UswutGdi1cfit]nogon;i1.ipr,in2ooSS;fka;n,y232t=sls3;shuiga3nsieabinngoSsrass.ldie=(tnued\rSicedtettptojciounToirSotipttonihhviin3-n6=)tosieedcysnrr4oifeipjownisSd;o.fasruonnlabisIr"sinntuminsroandtscfdmsiaspiathste-tsueuceowhhwtotldtrheaifesoidooauiaruemntnutktbrhn,hr.enseSeeirtdiiuqt.iniHe,utnuscco=u.eriea,aettnntnsnithiSicnseseiotceaoe,gsneSn.tnse,i3btx.SoSoHh,wyapnjfa,bfoa,e,ttpetwnIewwacfsrrmdaeaeikhhlvnsmuSgiuaeeencoslrrFs1riilgeeet---,,,

We use the name \ -compatible" because, as shown in

lemma 5.2, every constraint set induced by a -term satis es the conditions above.

4 Algorithm for Lambda-Compatible BetaUni cation

De
be a

snuibtisotnitu3t.io8n(aSnodlulettions=).f

a -compatible constraint set.

L1We=t:eSs1a0:;yV: :Sa:r

;i!s na(=E:solnu0 Tgti!obne)

for i two conditions hold:

1. Dom(S) \ Var(Sv) = ? for every v 2 Var. 2. S i = S i0 for every i 2 f1; : : : ; ng.
The rst condition is a mild restriction. It can probably be eliminated, at the price of making these propositions and their proofs more complicated.

cVDctehoviapemearartlpy!nSassit0otoi(libluEoulte=ntiioocn3SonT.n0!90Sfs(otS0)r(rfaPboier)nr.it2naisc,eTsitutSph.hbaeeTsilrstpheirteaSuiisnstosuciaoloibulpnusstauttilaiiboitotnsunyntdtsiipt)foluro.enotrtipSoenrLitsSyebaat0ne0idspsaSrutifhcnoher--:
existence of a principal solution for every constraint set that has a solution.

Example 3.10 (Uniqueness of Principal Solu-
tions in a Weaker Sense). A peculiarity resulting from the presence of expansion variables is illustrated by a simple example. Let be the constraint set:

= fFG =: ( 1 ^ 2) ^ ( 3 ^ 4)g

where is

-c1o;mp2;ati3b;le4.

2 S! are arbitrary. Assume that
By inspection, it is not di cult to

see that has three distinct principal solutions, ignor-

ing any principal solution obtained from one of these

three by renaming variables in its range or by adding

We design a non-deterministic algorithm Unify which takes a -compatible constraint set as input, such that if has a solution then every evaluation of Unify( ) terminates returning a principal solution for
, and if has no solution then every evaluation of Unify( ) diverges.
The presentation of algorithm Unify in gure 4 is largely self-contained | except for two parts in the
\apmnladiondt.heIeonfegoveapnleueraarattiiloo, nnth"o,efnsSata1mn=edlayS,rdthcEeodSme0p, onwsitihtiioiconhnowoffeEt-nweonowvs(uebx)-cTasis.taaeoinrl.tl,ieuwly\wftoosioraerbknxfiesisnusaactbruorosasymutiinnsotpugudpobtes\itsriohttanii"itotssiunoddtSniori1oeeonlsanacntSunisdl3vouteytbSs,ust2ptowc,rihteotEuhdt"utehui,sroacewenetsh\dS,aeo3wreEess=hu"Eibnct(shooSitsti2wtdanueenetnSciweooe1nitns)le--l.,
vironment expressing certain naming constraints.

De nition 4.1 (E-Path Environment). Given a

well-named type context ', we form its E-path envi-

ronment as follows:

(E-env('))(v)

=

(F~ unde

ned

if E-path(v; ') = fF~ g; if E-path(v; ') = ?:

An E-path environment is a partial function E : Var ! EaEEisV--wpeaaenarlvtl-h(wtnhea1ealmnl^t-vneiisdar10mott^hnyeempdreeencsc^outosnln.ttnseotx^Ifrftaa.ipnn0Lpt)el.y=tsiEentfgb, te1hta=eh:meEn-e10et;naE:vv:-a:efrun;invanb(ctl=ei:o)onvn0te=ogr

2We purposely write S0 = S00(S ) instead of S0 = S00 S in order to avoid pitfalls associated with the composition of substitutions in -uni cation.

De nition

a function expansion

e

4aw.n2hdi(caSh,asfgueibvsCetniotumatpipoaonirsiS(te,io;rSne)t)u.croWnnsseiastrisnntgidtoeef

ne an set

Metavariable conventions:

2 R!, 2 R, F; G 2 EVar and

H

2 2

S!,
EVarb,

; 02
with

S, F

; and

0; G

i; i0 2 T,
distinct and

2 H

TVar. fresh

in

rule

4.

Mode of operation:

Initial call: Unify( ) ) Unify(simplify( ); f ]g; E-env( )).

Unify(?; S; E) ) S.

Uanniifnys(tan0c;eS0o;fEo)n)e oUf tnhifeyr(ew1r;iSte1;rEul)e,sw. here 0 = F~f =: g, 1 = S 0 and S1 = S E S0, provided =: ) S is

Rewrite rules:

==::

)) ff

:= :=

]g]g

((rruullee 12))

FF F

===:::

G ^

0

)) )

ffFF F

:::===GF]Hg0

]^g F1

(((rrruuullleee 435)))

ApplSsyi(mifnpgl=i:sfyu(bf0gst=i:tut)0gi=onssimt)po=licfsyoi(mn(sSptlri)fay=i(:nt(=S:se0t)0s)):

S.
simplify(

).

simplify(

=:

0)

=

8>>>>><>>>>>:Fsfs?iimms=ipp:mlliipff0yylgi((fy11(0

==1::

=:110 ))10 )

simplify( simplify(

2 2

==::

2200

) )

if if if if

= = = =

F110,^!1 a2n2daannd0d=0

F0==10 ,10 10^!20

, 20 ,

otherwise.

Figure 4: Algorithm Unify.

(e; S) of
nition of

triples in f0; 1g
is by induction

on

fe,0;fo1rga

f0;
xed

1Sgth. rTouhgehdoeut-:

De nition 4.4 (Uni cation Algorithm). The op-
eration of Unify is based on the rewrite rules shown

( ; S)

((eFw0===eh^; eSfffer()((1e"is;;isSS"ip;)Fp;="i;)=qgp;qase;ti0rh;)(r#j)(2(jpi();(e;pqe0;;)0rq)=);fro2n)r;21a(eni(d;hiSei)s;ini;

2 f0; S); 1

1g g i

ng

The intention of

the path p ti es hole

id(je)nitni

es

is that hole

(iif)

e of which

(p; i(ni)

q; r) 2 (e; S), then S e, the path q idenin S e is a copy, and

srrpeualibtashGsttitviiehvteneuevnttsioiruosonbEunsbmSiessq.teuianteutnnteEciwoe,ntosshufeSbts1shateaiftenpudcatoitoSmhn2p,pdotescoiogtnnieoettnhrdiebobrufywt:Seid1thabnaydntSEh2e-

(S2

E

S1)(v)

=

8>><S2hS1(v0q >>:f ]g (v)

)ir

iS(fp1;v(qF~=; r)v)0p2=, Ee((,vea0;)nSd=2),F~,
otherwise.

in gure 4. Because Unify is non-deterministic, there

are in general many evaluations of Unify for the

same input . We exhibit the consecutive rewrite

siUEntnegp=i:fsyU(oEfn-ieia;fnySv(pi(;aEr0t));i.fc)u]glTa;roE)eivn)awdlihuceaaUrtteineoinftyh(0oaft=1U;tSnhsie1ifm;yEe(pv)laif)l)yu(bayti)ownarni)otd-f

Unify( ) makes i 1 calls to Unify (beyond the ini-

tial call), and that
ecnonvsirtornaimntenstetE, wi,e

ttwhhreeitaseur:gbustmiteunttisonofStih,eaintdh

call the

are the E-path

Unify( 0; f ]g; E) =)i Unify( i; Si; E) :

WvfwUtesohtvianrrraeayaoiltWfsinuwynUoma(ethrmtniieeittsieonnhefe;yntetSesUsvru;ioEesbsnEfr,(usid)fUtcwweyifh0ton(eeu;nritfftshaeys0iadsaoo(;ys]tngmfug;sUum)eE]gaSn)se;irauiEafantcyn=)hnhd(t1ad=)e.tte(h;SsSs0aU0itt;;mahnaSErUapine;)ftldynEi)sf(i)yfis-myco(Uo(o;mprSmnl)ei;i0pfftE;yy=hEaf)((et-irptb]geoa00l;);.teESimh=s)c0Te;oe=aah)Enninne)--0

again.

In lemma 4.3, we state a condition and prove that it

tcisuomtsiuopnocsSiite2inotnEtSSo21gounSar1aanotytnepee.thaist

the action of the substiequal to the action of the

Lemma 4.5 ( -Compatibility Is Invariant). Let
0 and 1 be constraint sets such that
Unify( 0; S0; E) =) Unify( 1; S1; E)

EpttLyh.oepemsenIi,ftmSaion0(aandn)4)ld.e.=t3SLS1Se(02tS=(auSSrSe11(2wcaein)eEl)dln.S-ntS1a2CfmoboreednsosdtumyipbteesiotsEinta-upntfadioothrEnseS,navlEfeiert-oeCnnmvob(eemn)a-t,

vfcionoirrmodsnpeoammtniebeintlteiso,uEntbhs(et3win.t7uhsitociaohrinessdoiSn1v0n.aoIartninamdwnatoStr1trdeesarl,antthdhievereseop)mrt.ooepIetEfhrte-ipear0sethlwiissretientde--
rules of Unify.

mtcLooegemmentpthmaEetri,abltwe4hie.tc6nhonta(hsPtesrrruaeobinsgitstriteasusetstci)oos.nnusctShIr0fatihanant0tdsesiaitsmnapE1li-nfpsyoua(ncth-he0met)hnp=avttiyron0--,

Unify( 0; S0; E) ) Unify( 1; S1; E)

for some substitution S1 (which does not matter here).

In words, processed

by

0onaelwoafytshecornetwarinitse

a constraint that rules of Unify.

can

be

LfSocer:emV)a.m,r a!tLhee4t(n.E7w(ebSTeco!aalnu) tbci-eoocnnoasmstsrpuwuabctsitittbihatleuFtsicuoiobnnnsi.sttitetIrufatSiSinoutnipsspSeaot0srafotrnloudSmtiuolefSn-t
such that:
1. Dom(S0) is nite. 2. S0 is a solution for .

De nition 4.8 (Size). Given a type 2 T, the func-

tion size( ) applied to returns an integer size( ) 1

which is the number of symbols in excluding all oc-

currences size( ) to

eoxfpEa-nvsairoinabs lees2anEdinallthpearoebnvtihoeussesw. aWy.e

extend Formal

de nitions, by induction on and e respectively, are

omitted.

cDaosenosltunrtaiitioninotnfsoe4rt,.9wiw(tDhitehEgVranerie(t)e.D) Lo=metf(FS1);,b:s:ea:ya;:Fk-gc:oLmeptaStibblee

S = fG1 := e1; : : : ; Gm := em; 1 := 1; : : : ; n := n]g :

If F~ 2 EVar , let jF~ j denote its length, i.e., the num-

sbpu;eqrre; rodf2egvNraere,ia(aSbsl;efosl)lion=wst(:hpe;

qs;erq)uoenncteh. e

We pair

d(eS;ne),awmheerae-

p=

P
1

i

m (size(ei) ? 1)

q = size( )

r=

P
1

i

k

(k ? jE-path(Fi;

)j)

obGreirvpse,n=wtwepo0wtarrniitpdeleq(sp<(;pq;;qqr0;),r)o<ranp(dp=0(;pq0p0;;0qr,00;q)r0i=) oqef0inthaanetrudrparl <<numpr00-.,

This is the so-called \lexicographic ordering" on triples

of natural numbers, and it is easy to see that it is well-

founded.

baLebelame)cm.onaLset4rt.a1in00t

(Decreasing Degree when
be a -compatible constraint set, set, and let

Solv-
let 1

Unify( 0; S0; E) ) Unify( 1; S1; E)

fidvaosierrsgoaorsnelosumeomt(lieSuoent01ntis;ouSEnb001sS()tiwf01t<ouhrftidoicoerhng0srdeow1Se(i0wnSthoai00tt;nhDdmoD0mSa)o.t1(mtSea(r00nS)d01h)esrnoeim)nt.eie,teEItfhs-euptnachhtehtrhetehenaries-t

Lemma 4.11 (Principal Solution Constructed).

LEe-tenv(0

be 0),

a let

-compatible constraint set with 1 be a constraint set, and let

E

=

Unify( 0; S; E) =) Unify( 1; S~ E S; E)

for some substitutions S

solution for 0.

1, then S1

EanS~disS~a.

If S1 is
principal

a principal solution for

The following theorem shows that the algorithm is sound (i.e., the substitutions Unify produces when it terminates are in fact solutions) and complete (i.e., Unify produces a solution if there is one), as well as showing it produces principal solutions.

TwPirhtihenoEcriep=maEli-t4ey.n1)v.2(

(Soundness, Completeness,
Let be a -compatible constraint ).

&
set

1. sUonmhifaeys(ssuaimbssoptilltuiuftytiio(onn)i;fSf.an]gd; Eon)ly=)if Unify(?; S; E) for

2.

IsfomUeniSfy,(tshimenplSifyi(s

); f ]g; E) =) Unify(?; S; E)
a principal solution for .

for

Note that Unify diverges exactly when there is no solution. The evaluation strategy does not matter, because lemma 4.10 implies termination when there is a solution and lemma 4.11 implies divergence when no solution exists.

5 Type Inference Algorithm

This section de nes a procedure which, given a -term

M, generates a nite set ?(M) of constraints, the solv-

taebrimlityMo.f Wwehiucshe

is equivalent this to prove

to the

the typability of the principality property

for System I and to de ne a complete type inference

algorithm.

Dsterainnittsionan5d.1 S(Akelgleotrointh).m FoGreneveerrayting-termCoMn-,

dcogenusnrteerda5instisgmivu?el(tsMana)enoaunsidnlydauwcdtiitevhreivaadteitoynnpietsikoeTnlyetpoo(fnMaS)kesalen(tMd o)af,

type given

esnuvbirtoenrmmenotccEurnrve(nMce).N

In this , when

de nition, for a a fresh variable

is chosen, the same fresh variable must be used in

Env(N ), of going

fTroymp(NM),

t?o(N?()M, a)ndandSkeSlk(eNl()M. )Tihs eunpirqouceeslys

determined up to the choice of expansion variables and

type variables.

Lemma 5.2 (Constraint Set is -Compatible). LinedtuMcedbebyanMaribsitr-acroymp-atetirbmle.. The constraint set ?(M)

SLkeeml(Mma)).5.3 I(fADll sunbasltijtuudtigoenmSenstucAh

Derivations Instances it`shaaMt Dde:=rivS,a(tStihokenenl(Motfh)e)Sr.eysteexmistsI

of
with some

TEqhueoivraelmen5t)..4

(Constraint
Given -term

Set M, a

odanerslyiovlaiufttiiMoonniosffotrySpy?asb(teMlem)inIi.fSyTasnhteudms,oIn?.l(yMi)f

sSaun(bSdsktietlu(SMtiko)en)leSitsoinas
is solvable if and

Corollary 5.5. It is undecidable whether an arbitrarily
chosen -compatible constraint set has a solution.

From the principality property for -compatible uni cation, we can derive the following.

If M = x, for fresh 2 TVarb: If M = (N1N2), for fresh F 2 EVarb, If M = ( x:N), for fresh 2 TVarb:

2 TVarb:

TE?Sk(nyMevpl((()MMM)))

= = ==

f?hVx;;A7!R;

g; Env(M)

`

M

:

i:

TE?Sk(nyMevpl((()MMM)))

= = = =

E?hA;(nNPv(1PN);1E)nF^v(?FM(NE)2n`)v(MNf2T:)y; p; S(Nke1l()N=:1)F(FTySpk(eNl(2N)2!))i:

g;

Typ(M

)

=

(Env(N)(x) ! ! Typ(N)

Typ(N

)

if Env(N)(x) de ned, otherwise,

E?Sk(nMevl(()MM))

= = =

E?hwR(nhN;veEr()eN;nvi)f(nMxx;2)

`FVM(N:

)T,ytph(eMn )R; S=keAl(BNS)-iI,

else

R

=

ABS-K.

Figure 5: De nition of ?(M), Skel(M), Typ(M), and Env(M).

nTehsesoroefmTy5p.6e

(IPnrfeinrecinpcael).TyLpetinPgTs

and Complete-
be the algorithm

such that

PT(M) = (Unify(?(M)))(Skel(M))

If M is typable in System I, then PT(M) returns a principal typing for M, else PT(M) diverges. Thus, System Ihas the principality property and PT is a complete
type inference algorithm for System I.

6 Termination and Decidability at Finite Ranks

TrithhismsUecntiifoynwdheichnepsroUdnuifcyeFs Ra,soalnutiaodnapStawtiitohn

of algobounded

rank k for a -compatible constraint set . The de -

nition of UnifyFR di ers from Unify only in the \mode

of operation" as presented in
okUf.nUiOfynt(ihfye)FrwRpirsoeodnUucneisfyaSFt Rarannhdkatlthkse

prragonudkrueoc6ef.sSTaishseobloiunutvnioodnceadtSiboinyf
indicating failure, unlike

Unify which diverges if it can not nd a solution.

Note that the principality of solutions produced by

UnifyFR follows from the principality of solutions produced by Unify.

rfDtehLnee;creeRnfs;oi0tro;eifo1, gnuLn,i6niq.l1euste.()#RL'eaLt2n(skT)22doTwefn.itoThTtyehnpeterhese)1i.snhuaomFlseobmsresareullvcoeehfsrtytoh(caascnutdr2-,

1. = ' 1; : : : ; n] for some 1; : : : ; n 2 T.

2.

None of currence

tohfe\t^y"p.es

in

f

1;::: ;

ng

contains

an

oc-

The rank hole-rank(
does not

m(ie)o;nf'ti)onh=oal#enyL(\p^(a"it),hw( ein(di)e;

' is given by ')). If ' = , i.e., ne rank( ) = 0. If

' 6= , we de ne rank( ) by:

rank( ) = 1 + maxfhole-rank( (i); ') j 1 i #2(')g :

This de nition of rank( ) is equivalent to others found
icnontIshfteraliitne=trasetftu,r1ew.=e: de10;n: :e:r;annk(=: ) nb0 yg: is a -compatible

rank( ) =
maxfrank( 1); rank( 10); : : : ; rank( n); rank( n0 )g

eDwTavnhyeederpryseneasdiyet)evi.rtoeihvnraLyetde6teS.tn2ykvipsi(reRaohnar1aman.snekkrn-Ia-tkfknSktsySkpyieselsektath,eoawmnssk.eerwlaeonrtfioktneInroatfkenSrk?sy(eSs1tc)etmaionndkI AparstWkiecelueltdaoernsnSuesbotfehtIeoirsfestathrseikcretailoentnko-nkIkoskof efIlkeStyiosntesramanrkeI(tSahs)eforallkno.wk-Ask.
derivations.

De nition 6.3 (Rank-k Solution). Let be a -

scsaooylmuttpihaoatntibfaloersucobnsrtseittlrauattiinivotensteSot,A: VAparro!vTidV(eEadr:,

aTn!d)kis

a

1. We rank-k

1. S is a solution for .

2. rank(S ) k ? 1, for every 2 A.

3. rank(S ) k, for every 62 A.

The set A discriminates between T-variables corressimnppugoo,snnttddhhiinneaggvettroosrtadenmenkrvuivisretodknh.tmayvepenetsraitnnykpaestyapkni?ndg1;T,f-ovaranradiartbahnleeks-skeccotoryrnped--

LiMseamisrmaSnyaks-t6ke.m4s.oIlkuL+tei2to.nMofbe

a ,

-term and then there is

= ?(M). If S
a derivation of

To show that for a xed A TVar and xed k 1, an evaluation of UnifyFR( ; A; k) always terminates, we need to reason about the rank of a constraint in a constraint set. The following de nitions support this.

De nition 6.5 ( -Compatible Pairs). Let ( ; 0) be sa(eaenqpnturadieierntshc,oeefwrdtehy(feoprr;eees0.u')nW=2iqe(uT'de2;)e^tw1yn;ipe:te:hi:tcsn;o^cnnot;ne^xs010tt;rha:sou:inl:ceth;s^dtin0esh)caotwthmietpholas1ri+tgie2osnnt

((f0=iii=;;; 'iii'000))g==1=10;;:((f::^^:^ii:0:i;;;;^^;^ii0ni))0n0g];];iifffohhrooll1ee--rraainnkk((

n;((ii));;

') ')

is is

even, odd.

Mode of operation:
Initial call: UnifyFR( ; A; k) ) UnifyFR(simplify( ); f ]g ; E-env( ); A; k) for A TVar and k 1.
UnifyFR(?; S; E; A; k) ) S. UnifyFR( 0; S0; E; A; k) ) UnifyFR( 1; S1; E; A; k) if Unify( 0; S0; E) ) Unify( 1; S1; E) and also:
{ rank(S1 ) k ? 1 for every 2 A. { rank(S1 ) k for every 62 A.
Figure 6: Algorithm UnifyFR (refer to gure 4 for missing parts).

IsfetG~die=coEm-ppoastihti(on(ii)s;:') for 1 i n, then its constraint

( ; 0) = fG~1^1 =: G~1^10; : : : ; G~n^n =: G~n^n0 g:

If (

is a

for 1

1i

-;con0im)apinsadtnaib,wlesr-oictpoeawmierp.(acaIt;ninblt0le)heticisno^ncitasht=serea,fion^iritma2sn:edtR,

then ^ai0n=d

^(i0i;2fo0Sr)

( ; 0) = fG~1 1 =: G~1 1; : : : ; G~n n =: G~n ng:

cNhnooetoetshtehseatrthasneikmlaoprfgliecfysot(ns't(rwa;iintht0))Gt~h=ie

( ; 0), because d( ; 0) is=t:atG~edi pi rionpe(rt;y.0)W: e de-

rank(G~i i =: G~ i i; ( ; 0)) = hole-rank( (i); '):

We also de ne h( ; 0):

h( ; 0) = minf hole-rank( (i); ') j 1 i n g;

i.e., the If

h( ; holes =

0i0n)='is'fa,rolimo.ew.,ietrs'brhooouatsnd(0voihenwolteehdse, awsLe-adlibestainavnaercyeh(torf;eea)0l)l.

unde ned.

DLaeebte(no0int;eio00on)f at6nh.de65((rE1u;vlea10s)lulbiasetteind-cgionm-pCgautorimbel4ep.apWtaiibresl.weLrPietteairrusl)e.

( 0; 00) =)a ( 1; 10)

if1;d:(: :0;; n00g) s=uc(h';th1a;t::: : ; n; 1; : : : ; n) and there is i 2 1. i =: i ) S is an instance of rule a. 2. ( 1; 10) = (S 0; S 00).
tebIdnhvyicaasarltuutucetalhdhteieaobanycc.aofwsnrMeosr,timotrwrianee(iognsvt0ae;yr,i0t0h)i=fa:thtoo((lie0-1i;rs;a00an10)tk)i(sriasen(vaika)ls;luok'a)ataet=ndrdatkont,hk(waket1,;stiahn10ye)-

( 0; 00) =(=a=;k)) ( 1; 10):

W(sobofe0me);aLwene.00rrt)ieutvR=elRa)ne(lua0a(;,tfniao100;n)n;d:)n0s:)=e): q(t;uo5f1eog;inrn.cd10teL)ihcweieantitrtcee(hats0enhe;xa(it0v0 )0et1;h)ters00at)eenv=p)saaistl.u)i(vaWe1t(i;ecolnno1w0 ;)srhufinoart0 eers)

(finsor0si;ntFseoiR0p0nm)sa-,enl=laR)oyanr,dm2(iatRfh1l ;a.ftoth10r)eem,are.cthhiessntewpnoeisspcaaayrirrtihe(adt1o;tuht1e0)upsiasnuirgch(ru0tl;eha00at) wiRLth5ushaa.ieatvtam=htieoofbmnounfort1uaoer;nfv:u6dMe:(.lr:e7My0(;;54(e(0E.vg0;0a0,)vI;l00fuaim).al0(.e0uut).i,0Isaosnt;tnRoiulw0n0wes)oigleiystrihsditdwnshRae,eip:tnaeshi-n(etncodetoo0ulimyn;not-gfpmt00aea)Rotralin=mlnubR)nylril(eenet(wa0pitm;ar51iiin;)ter00eg.,s)10t)rersh,uvuuLelawcelrelehees-t LrRRareures-ablnmtienHrtoirkmyrc5a)mtpr,i.ayooaatnl6sLhe).vefei8oantsarilnsumR(l:deaEm,trviLbomuweaenllitaetuthhw(6ae5i.tk0t7ihsr;n.ee=gstt00ht)roewhifbc(reitaute0lhdlale; strRo0e0i)-wnu,crraoliReanmtnekp5d(akrwtua:ciilbottehlnseasniwpdoFaietiirrhrxaoeanuidnnkt ( 0; 00) =a)1 ( 1; 10) =a)2 ( 2; 20) =a)3 =a)n ( n; n0 )
k(Ms(wthos.heneoleee;rClrseyedtoone0envf)pdoeceinrrl(psu,ieetsiiini?vnifoode1(nnrRi;ny:n6-gi0;n.1?6Too1)n0r)nh,)me=i)tcr5(ahealen0(nf;ninosio,er0;0mite)atiihb0t)esaehuurneiencsdrvihfaanaiolntturi=hmra2(aat5tenR;ndb0kknof)oukou-rn.rnrdtohahr(NiemNr=n(,a(;li50.0fn;e0o;a.)r,0n00m>0)id)f. LiDinnecetlreeRmnasimbtinieaogtn-6rh.a8e6n..sk9eLtee(votIafn(luacl0arl;teriaoe00snw)irnboigftee-(aRr0ua;ln-ec0s0ko)wmisipthoaEfotviutbahtlleeruupfaoaltreiimro.5n:,Asa)ns.
( 0; 00) =R) ( 1; 10) =R=)1 ( 2; 20) =R=)2 iwafnhdeir(6=e i(+i110;;thi100+e)n1i)sRiisni i=nR-RRnio-rnmofra(m5l ;faoklrimf)ogramwnh.de,rfeorkiev=erhy(ii; i10), Dscgotiverdeai=nninngbittyfi:op1Sneq6=t:s.10oa1f0s;(:C:ao: d;-Cinno-gcmo=:mppaat-n0itCbgibolleemis pPtcahoateniirbssptl)reaa.irint(CT;osnhe0et-)
0==(( 110^^ ^^(( nn0??11^^ nn0))))
It is clear that p q is a -compatible pair (de ni-
tion 6.5).

CLeommmplaet6e.)1.1
set, and let ( evaluation of (

(Increasing-Rank Evaluations

;;Le00)t)

= bpe qa.

-compatible constraint If an increasing-rank

does not terminate, then has no

solution.

UAThnaei soecrtaeotmifoTn6-.)v1.a2rLi(eaDtbleesc,ibdaenaadbikli-tcyom1.opaftibFleincioten-sRtraainnkt

-
set,

1.

has a rank-k solution relative successful evaluation UnifyFR(

t;oAA; k)i

=)thSer.e

is

a

2. TinhgerfreoamreUnnoifiynFRn(ite;(Adi;vke)r.ging) evaluations start-

3. IattiivsedteociAda.ble whether has a rank-k solution rel-

References
vB93] S. van Bakel. Intersection Type Disciplines in Lambda Calculus and Applicative Term Rewriting Systems. PhD thesis, Catholic University of Nijmegen, 1993.
Ban97] A. Banerjee. A modular, polyvariant, and typebased closure analysis. In Proc. 1997 Int'l Conf. Functional Programming, 1997.
CDCV80] M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. Principal type schemes and -calculus semantics. In Seldin and Hindley SH80], pp. 535{560.
CDCV81] M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. Functional characters of solvable terms. Z. Math. Log. Grund. Math., 27:45{58, 1981.
CG92] M. Coppo and P. Giannini. A complete type inference algorithm for simple intersection types. In 17th Colloq. Trees in Algebra and Programming, vol. 581 of LNCS, pp. 102{123. Springer-Verlag, 1992.
DM82] L. Damas and R. Milner. Principal type schemes for functional programs. In Conf. Rec. 9th Ann. ACM Symp. Principles of Programming Languages, pp. 207{212, 1982.
GJS96] J. Gosling, B. Joy, and G. Steele. The Java Language Speci cation. Addison Wesley, 1996.
Jen98] T. Jensen. Inference of polymorphic and conditional strictness properties. In Conf. Rec. POPL '98: 25th ACM Symp. Principles of Prog. Languages, 1998.
Jim96] T. Jim. What are principal typings and what are they good for? In Conf. Rec. POPL '96: 23rd ACM Symp. Principles of Prog. Languages, 1996.
JMZ92] B. Jacobs, I. Margaria, and M. Zacchi. Filter models with polymorphic types. Theor. Comp. Sc., 95:143{158, 1992.
Kfo9X] A. J. Kfoury. Beta-reduction as uni cation. In D. Niwinski, ed., Logic, Algebra, and Computer Science (H. Rasiowa Memorial Conference, December 1996). Springer-Verlag, 199X.
KW94] A. J. Kfoury and J. B. Wells. A direct algorithm for type inference in the rank-2 fragment of the secondorder -calculus. In Proc. 1994 ACM Conf. LISP Funct. Program., 1994.

Lei83] D. Leivant. Polymorphic type inference. In Conf. Rec. 10th Ann. ACM Symp. Principles of Programming Languages, pp. 88{98, 1983.

MTHM90] R. Milner, M. Tofte, R. Harper, and D. B. MacQueen. The De nition of Standard ML (Revised). MIT Press, 1990.

Pie94] B. Pierce. Bounded quanti cation is undecidable. Inf. & Comput., 112:131{165, 1994.
PJHH+93] S. L. Peyton Jones, C. Hall, K. Hammond, W. Partain, and P. Wadler. The Glasgow Haskell compiler: A technical overview. In Proc. UK Joint Framework for Information Technology (JFIT) Technical Conf., 1993.

Pot80] G. Pottinger. A type assignment for the strongly normalizable -terms. In Seldin and Hindley SH80], pp. 561{577.

RDR88] S. Ronchi Della Rocca. Principal type schemes and uni cation for intersection type discipline. Theor. Comp. Sc., 59:181{209, 1988.

RDRV84] S. Ronchi Della Rocca and B. Venneri. Principal type schemes for an extended type theory. Theor. Comp. Sc., 28:151{169, 1984.

SH80] J. P. Seldin and J. R. Hindley, eds. To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus, and Formalism. Academic Press, 1980.

SM96] E. Sayag and M. Mauny. A new presentation of the intersection type discipline through principal typings of normal forms. Technical Report RR-2998, INRIA, Oct. 16, 1996.

SM97] E. Sayag and M. Mauny. Structural properties of intersection types. In Proceedings of the 8th International Conference on Logic and Computer Science { Theoretical Foundations of Computing (LIRA), pp. 167{175, Novi Sad, Yugoslavia, Sept. 1997.

Urz97]

P. Urzyczyn. Type Struc. in Comp. Sc.,

r7e(c4o)n:3s2t9ru{3ct5i8o,n19in97F. !.

Math.

Wel94] J. B. Wells. Typability and type checking in the second-order -calculus are equivalent and undecidable. In Proc. 9th Ann. IEEE Symp. Logic in Computer Sci., 1994. Superseded by Wel9X].

Wel96] J. B. Wells. Typability is undecidable for F+eta. Tech. Rep. 96-022, Comp. Sci. Dept., Boston Univ., Mar. 1996.

Wel9X] J. B. Wells. Typability and type checking in System F are equivalent and undecidable. Ann. Pure & Appl. Logic, 199X. To appear. Supersedes Wel94].

