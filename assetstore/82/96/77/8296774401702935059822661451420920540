Universidade de Bras´ılia
Instituto de Cieˆncias Exatas
Departamento de Matema´tica
Formalizac¸a˜o da conflueˆncia para
sistemas de reescrita ortogonais
por
Ana Cristina Rocha Oliveira
Bras´ılia
2012
Universidade de Bras´ılia
Instituto de Cieˆncias Exatas
Departamento de Matema´tica
Formalizac¸a˜o da conflueˆncia para
sistemas de reescrita ortogonais
por
Ana Cristina Rocha Oliveira ∗
Dissertac¸a˜o apresentada ao Departamento de Matema´tica da Universidade de Bras´ılia
como parte dos requisitos necessa´rios para obtenc¸a˜o do grau de
MESTRE EM MATEMA´TICA
agosto de 2012
Comissa˜o Examinadora:
Prof. Dr. Mauricio Ayala-Rinco´n - UnB - Orientador
Prof. Dr. Andre´ Luiz Galdino - UFG - Membro
Prof. Dr. Edward Hermann Haeusler - PUC-Rio - Membro
∗A autora foi bolsista do CNPq durante a elaborac¸a˜o deste trabalho.
Dedicato´ria
A Jesus
porque dele, por ele e para ele
sa˜o todas as coisas.
Glo´ria, pois, a ele eternamente.
i
Agradecimentos
A Deus, primeiramente, por todas as portas abertas e consolo quando as coisas
pareciam nebulosas e dif´ıceis de enfrentar.
Aos meus pais Francisco de Assis e Sebastiana e ao meu irma˜o Bruno pelo carinho e
amor em qualquer situac¸a˜o. Voceˆs foram meu grande exemplo de forc¸a e disposic¸a˜o em
fazer o melhor.
Ao meu marido e grande amor Ricardo pelo cuidado e palavras de incentivo, a quem
tambe´m dispenso o meu cuidado e afeto eternamente.
Aos meus amigos e colegas de mestrado e graduac¸a˜o Mayra, Gabriella, Aristo´teles,
Dhiego, Ange´lica, Getu´lio, Joa˜o Paulo, Robson e Linniker que me acompanharam sempre,
seja na hora dos passeios e diversa˜o, seja nas muitas horas de estudo para as provas de
qualificac¸a˜o.
Aos meus amigos e colegas do Grupo de Teoria da Computac¸a˜o Andre´ia, Thaynara,
Daniel e Kaliana por me receberem no grupo e darem todo o suporte necessa´rio. Obrigada
pela amizade. Agradec¸o especialmente a` Andre´ia pela pacieˆncia em sanar as minhas
muitas du´vidas neste longo processo.
Ao meu querido orientador Mauricio, que suportou toda a minha temosia e orientou-
me por tantos anos com a perseveranc¸a de quem ensina a uma filha.
Aos membros da banca examinadora Edward Hermann Haeusler, Fla´vio Leonardo
Cavalcanti de Moura e Andre´ Luiz Galdino por aceitarem o convite de compor a banca,
ale´m das cr´ıticas e sugesto˜es que enriquecem este trabalho. Agradec¸o particularmente ao
Andre´, a quem recorri muitas vezes para sanar du´vidas, pela prontida˜o em me atender
sempre.
Ao professor Celius, pelas horas de boa conversa e incentivo, ale´m da disposic¸a˜o em
ajudar em qualquer dificuldade. Voceˆ e´ um grande amigo!
Aos funciona´rios do MAT pela gentileza e carinho dispensados. Obrigada
especialmente a` Cla´udia e D. Irene pelas boas conversas no subsolo.
Ao CNPq pelo apoio financeiro.
Novamente, a Jesus, que e´ o in´ıcio e fim de todas as coisas. A minha vida e trabalho
sa˜o teus, Senhor!
ii
Resumo
Ortogonalidade e´ uma caracter´ıstica da programac¸a˜o que consiste, de uma maneira
sinta´tica, em garantir o determinismo de especificac¸o˜es funcionais. Essencialmente, a
ortogonalidade na˜o permite, por um lado, a ambiguidade inerente do na˜o determinismo,
isto e´, a existeˆncia de diferentes regras que especificam a mesma func¸a˜o e que podem ser
aplicadas simultaneamente (na˜o ambiguidade) e, por outro, tambe´m pro´ıbe a repetic¸a˜o
de varia´veis no lado esquerdo dessas regras (linearidade a` esquerda). Na teoria dos
Sistemas de Reescrita de Termos (TRSs), determinismo e´ identificado pela renomada
propriedade de conflueˆncia, que basicamente afirma que sempre que houver possibilidades
de simplificac¸o˜es ou computac¸o˜es diferentes de um termo, as respostas computadas
ou os termos reduzidos obtidos devem coincidir. Embora a prova seja tecnicamente
elaborada, conflueˆncia e´ bem conhecida como uma consequeˆncia da ortogonalidade.
Dessa forma, ortogonalidade e´ uma importante caracter´ıstica matema´tica intr´ınseca a`
especificac¸a˜o de func¸o˜es recursivas, sendo naturalmente aplicada em programac¸a˜o e
especificac¸a˜o funcionais. A comec¸ar pela formalizac¸a˜o da teoria de TRSs no assistente
de provas PVS, esse trabalho descreve como a conflueˆncia de TRSs ortogonais esta´ sendo
formalizada utilizando essa ferramenta. Progressos substanciais foram constatados nessa
pesquisa, obtendo-se ate´ o presente momento formalizac¸o˜es completas para propriedades
similares, pore´m com restric¸o˜es, tais como a formalizac¸a˜o completa para a propriedade
de conflueˆncia de TRS’s na˜o amb´ıguos e lineares (a` esquerda e a` direita).
Palavras-chave: TRS, ortogonalidade, conflueˆncia, PVS, formalizac¸a˜o.
iii
Abstract
Orthogonality is a discipline of programming that in a syntactic manner guarantees
determinism of functional specifications. Essentially, orthogonality avoids, on the one
side, the inherent ambiguity of non determinism, prohibiting the existence of different
rules that specify the same function and that may apply simultaneously (non-ambiguity),
and, on the other side, it eliminates the possibility of occurrence of repetitions of variables
in the left-hand side of these rules (left linearity). In the theory of term rewriting
systems (TRSs) determinism is captured by the well-known property of confluence, that
basically states that whenever different computations or simplifications from a term are
possible, the computed answers or the obtained reduced terms should coincide. Although
the proof is technically elaborated, confluence is well-known to be a consequence of
orthogonality. Thus, orthogonality is an important mathematical discipline intrinsic to the
specification of recursive functions that is naturally applied in functional programming and
specification. Starting from a formalization of the theory of TRSs in the proof assistant
PVS, this work describes how confluence of orthogonal TRSs is being formalized in this
proof assistant. Substantial progress has been done in this research, obtaining until now
complete formalizations for some similar, but restricted properties, such as a complete
formalization for the property of confluence of non ambiguous and (left and right) linear
TRSs.
Keywords: TRS, orthogonality, confluence, PVS, formalization.
iv
Suma´rio
Introduc¸a˜o 1
0.1 Considerac¸o˜es Preliminares . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
0.2 Objetivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
0.3 Contribuic¸o˜es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
0.4 Organizac¸a˜o do Trabalho . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1 Fundamentos 4
1.1 Ca´lculo de Sequentes no PVS . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.1.1 Regras estruturais . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.1.2 Regra de Corte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.1.3 Axiomas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.1.4 Regras Condicionais . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.1.5 Regras de Igualdade . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.1.6 Regras de Extensionalidade . . . . . . . . . . . . . . . . . . . . . . 7
1.1.7 Regra de Apresentac¸a˜o de Tipo . . . . . . . . . . . . . . . . . . . . 8
1.2 Teoria de Reescrita . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.2.1 Sistemas Abstratos de Reescrita . . . . . . . . . . . . . . . . . . . . 8
1.2.2 Sistema de Reescrita de Termos . . . . . . . . . . . . . . . . . . . . 9
1.2.3 Principais Teoremas . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2 Especificac¸a˜o 19
2.1 Sistemas Abstratos de Reescrita . . . . . . . . . . . . . . . . . . . . . . . . 19
2.2 Sistemas de Reescrita de Termos . . . . . . . . . . . . . . . . . . . . . . . 20
2.3 Posic¸o˜es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.4 Sequeˆncias finitas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.5 Subtermos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.6 Substituic¸o˜es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.7 Reduc¸a˜o simples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
2.8 Ortogonalidade . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
2.9 Definic¸o˜es auxiliares . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
2.10 Reduc¸a˜o em paralelo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.11 Comparadores de sequeˆncias de posic¸o˜es . . . . . . . . . . . . . . . . . . . 30
2.12 Sequeˆncias de varia´veis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2.13 Tratamento de sequeˆncias de posic¸o˜es . . . . . . . . . . . . . . . . . . . . . 34
2.14 Sequeˆncias de termos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
2.15 Sequeˆncias de substituic¸o˜es . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
v
3 Formalizac¸a˜o 42
3.1 RTC(reduction?(E)) = RTC(parallel reduction?(E)) . . . . . . . . . . . 43
3.2 Orthogonal implies confluent . . . . . . . . . . . . . . . . . . . . . . . 50
3.3 parallel reduction is DP . . . . . . . . . . . . . . . . . . . . . . . . . . 51
3.3.1 Resultados demonstrados . . . . . . . . . . . . . . . . . . . . . . . . 53
3.3.2 Resultados axiomatizados . . . . . . . . . . . . . . . . . . . . . . . 56
4 Conclusa˜o 60
4.1 Considerac¸o˜es Finais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
4.2 Sugesto˜es para Pesquisas Futuras . . . . . . . . . . . . . . . . . . . . . . . 62
Refereˆncias Bibliogra´ficas 63
Introduc¸a˜o
0.1 Considerac¸o˜es Preliminares
A programac¸a˜o funcional, muito explorada no meio acadeˆmico, tem rompido fronteiras
e, atualmente, e´ inclusive utilizada em sistemas comerciais. Nesse contexto, a reescrita
tambe´m tem se estabelecido como efetivo modo de programar. Nos u´ltimos anos, alguns
trabalhos relacionados a` formalizac¸a˜o de va´rias propriedades de Sistemas de Reescrita
de Termos (TRS’s) foram desenvolvidos em [2, 5–7] e disponibilizados em [1]. Esse tipo
de desenvolvimento, com natureza semelhante a` do trabalho que se segue, e´ de grande
relevaˆncia uma vez que garante caracter´ısticas importantes, deseja´veis e nem sempre
o´bvias a partir de outras que sa˜o facilmente detecta´veis computacionalmente.
Assim, o resultado que nos propusemos a formalizar e´ o de que TRS’s ortogonais
sa˜o confluentes. Ortogonalidade diz respeito a programas cujas regras na˜o entram em
conflito, isto e´, que na˜o se sobrepo˜em e tambe´m tais que as premissas de cada regra de
reescrita sa˜o lineares (na˜o ha´ repetic¸a˜o de varia´veis do lado esquerdo das regras). Ja´
a conflueˆncia diz respeito a` independeˆncia de caminhos tomados, sendo que, para cada
duas rotas divergentes, existem dois caminhos que levam a` computac¸a˜o de um resultado
comum.
Portanto, assim como a terminac¸a˜o e´ uma caracter´ıstica fundamental e muitas vezes
buscada por obrigar a existeˆncia de formas normais (termos irredut´ıveis dentro de um
programa), a conflueˆncia e´ desejada em muitos sistemas computacionais uma vez que
garante a unicidade de resposta, independentemente do caminho tomado dentro do
programa.
Ortogonalidade e´ apenas uma das propriedades capazes de garantir conflueˆncia.
Anteriormente, um dos resultados que nos propusemos a formalizar foi o de que TRS’s
na˜o amb´ıguos (sem sobreposic¸a˜o de regras) e lineares (sem repetic¸a˜o de varia´veis tanto
a` direita quanto a` esquerda das regras) sa˜o confluentes. Esse e´ um enfraquecimento do
teorema que temos como objetivo e sua formalizac¸a˜o ja´ foi mencionada em [9] tendo sua
conclusa˜o ocorrida durante o tempo de decorreˆncia do presente trabalho.
Sec¸a˜o 0.2 • Objetivo 2
O Lema de Newman e´ outro resultado que garante conflueˆncia, mostrando que
terminac¸a˜o e conflueˆncia local tambe´m implicam em conflueˆncia. A formalizac¸a˜o deste
u´ltimo lema esta´ dispon´ıvel em [5] e depende exclusivamente da teoria ars, que trata
dos Sistemas Abstratos de Reescrita (ARS’s). Lemas como esses envolvendo apenas
ARS’s sa˜o interessantes em formalizac¸o˜es sobre TRS’s pois e´ muito mais simples provar
propriedades locais como conflueˆncia local, conflueˆncia forte e propriedade diamante do
que a conflueˆncia. Isso ocorre devido ao tratamento da divergeˆncia em um nu´mero
qualquer de passos nesta u´ltima propriedade, enquanto que naquelas treˆs primeiras
tratam-se divergeˆncias em um u´nico passo. Portanto, provando propriedades locais
obtemos a conflueˆncia atrave´s desse tipo de lema.
0.2 Objetivo
O objetivo principal do presente trabalho e´ apresentar o que se tem desenvolvido
no sentido de formalizar o teorema de conflueˆncia para TRS’s ortogonais no assistente
de provas Prototype Verification System (PVS). Para tanto, mostraremos a prova
anal´ıtica do teorema principal apresentando os pontos chave da demonstrac¸a˜o e como
usamos esses pontos no sentido de especificar e formalizar o nosso resultado. Tambe´m
apresentaremos a formalizac¸a˜o de alguns dos lemas auxiliares que foram usados no
caminho da demonstrac¸a˜o.
0.3 Contribuic¸o˜es
A teoria orthogonality, criada para tratar a formalizac¸a˜o do teorema sobre
conflueˆncia de TRS’s ortogonais, e´ uma extensa˜o das teorias ars (em [8]) e trs (em [6]),
sendo os resultados destas teorias a base completa para o trabalho que fizemos. Esse
arcabouc¸o constitui-se da formalizac¸a˜o de questo˜es e propriedades apresentadas nos livros-
texto ( [3, 4]) envolvendo conflueˆncia, noetherianidade e TRS’s em geral.
Um resultado importante, que utilizou esse arcabouc¸o sobre ARS’s e TRS’s no PVS,
foi o de que que TRS’s na˜o amb´ıguos e lineares sa˜o confluentes, tratando-se de uma
formalizac¸a˜o um pouco menos complexa do que a do teorema de conflueˆncia para TRS’s
ortogonais. Esse resultado foi apresentado em [9] com sua formalizac¸a˜o completa desde
2010.
Para provar que ortogonalidade implica em conflueˆncia foi necessa´rio especificar
a reduc¸a˜o em paralelo (denota-se esta como ⇒ e a reduc¸a˜o simples como →) e
demonstraram-se alguns lemas importantes sobre ⇒ como, por exemplo:
1. →⊆⇒;
2. ⇒⊆→∗, onde →∗ e´ o fecho reflexivo-transitivo da relac¸a˜o;
Sec¸a˜o 0.4 • Organizac¸a˜o do Trabalho 3
3. ⇒∗=→∗;
4. ⇒ tem a propriedade diamante, o que implica que tambe´m e´ confluente;
5. finalmente, → e´ confluente.
Para provar os itens 2 e 3, utilizamos muito do que ja´ t´ınhamos da teoria sobre TRS’s
e foi necessa´rio criar va´rios outros lemas te´cnicos ja´ que ⇒ ainda na˜o havia sido tratada
pela teoria trs.
Logo, destacamos que as principais contribuic¸o˜es deste trabalho sa˜o as formalizac¸o˜es
em PVS do lema de conflueˆncia para TRS’s na˜o amb´ıguos e lineares, do teorema de
conflueˆncia de TRS’s ortogonais e dos lemas auxiliares utilizados. Tambe´m destacamos a
descric¸a˜o construtiva do termo de juntabilidade necessa´rio a` prova, como veremos.
0.4 Organizac¸a˜o do Trabalho
Comec¸aremos o trabalho mencionando as principais regras do ca´lculo de sequentes
dentro da Teoria de Prova, o qual e´ base para o assistente de prova PVS. Em seguida,
estaremos a par das definic¸o˜es necessa´rias ao entendimento da Teoria de Reescrita
considerada aqui, levando-se em conta propriedades dos Sistemas Abstratos de Reescrita
e, mais especificamente, dos Sistemas de Reescrita de Termos. Tendo bem conhecidos
os conceitos utilizados, demonstraremos analiticamente os resultados chave. Por fim,
entraremos na parte voltada ao desenvolvimento da teoria no assistente de prova PVS,
tratando primeiramente da especificac¸a˜o e, em seguida, da formalizac¸a˜o e me´todos
utilizados.
Cap´ıtulo
1
Fundamentos
A intenc¸a˜o deste cap´ıtulo e´ apresentar os conceitos, as principais demonstrac¸o˜es
anal´ıticas e os mecanismos de prova utilizados durante a formalizac¸a˜o do teorema de
conflueˆncia de Sistemas de Reescrita de Termos (TRS’s) ortogonais.
1.1 Ca´lculo de Sequentes no PVS
O ca´lculo de sequentes foi proposto na de´cada de 30 por Gentzen dentro da Teoria
de Prova com o objetivo de provar a consisteˆncia da aritme´tica de Peano, uma vez que
enfrentava dificuldades com o me´todo de deduc¸a˜o natural (tambe´m desenvolvido por
Gentzen). Esse ca´lculo e´ utilizado na construc¸a˜o de provas e, apesar de ser pouco natural,
torna as demonstrac¸o˜es mais simples tecnicamente.
Um sequente e´ uma estrutura da forma Σ `Γ Λ, onde Σ e´ o conjunto de fo´rmulas
antecedentes, Λ e´ o conjunto de fo´rmulas consequentes e Γ e´ o contexto. No´s assumimos
a conjunc¸a˜o das fo´rmulas em Σ, implicando na disjunc¸a˜o das fo´rmulas em Λ.
Para construir provas, no´s utilizamos as regras de infereˆncia, sendo o nosso objetivo
encontrar sequentes onde e´ poss´ıvel aplicar as regras axioma´ticas que trataremos a seguir.
A forma de apresentac¸a˜o das regras e´
premissa
conclusa˜o
nome da regra
Neste trabalho, as formalizac¸o˜es foram todas feitas no Prototype Verification System
(PVS), um assistente de prova semiautoma´tico que permite especificar teorias e
demonstrar teoremas. O PVS esta´ baseado numa lo´gica de ordem superior, isto e´, que
possibilita que func¸o˜es sejam aplicadas a indiv´ıduos tanto quanto a func¸o˜es, levando-se em
conta determinadas restric¸o˜es para que na˜o haja contradic¸o˜es. A semaˆntica da lo´gica de
ordem superior e´ dada pelo mapeamento de tipos bem formados da lo´gica em conjuntos
e de termos bem formados da lo´gica em elementos dos conjuntos representantes dos seus
Sec¸a˜o 1.1 • Ca´lculo de Sequentes no PVS 5
tipos.
No PVS, abre-se cada teorema num ambiente de demonstrac¸a˜o que organiza as
proposic¸o˜es como negativas quando as tomamos como premissas e positivas quando sa˜o
teses. Assim, os sequentes no PVS sa˜o apresentados da seguinte forma:
[-1] p1
[-2] p2
[-3] p3
...
|-------
[1] t1
[2] t2
[3] t3
...
Dessa forma, assume-se a conjunc¸a˜o dos itens negativos e busca-se provar a disjunc¸a˜o
da parte positiva, ou seja, assumindo todas as premissas, precisa-se provar alguma tese.
A seguir, no´s mostraremos algumas regras de infereˆncia do ca´lculo de sequentes e sua
correspondeˆncia com os comandos de prova de PVS. E´ importante ressaltar que o ca´lculo
de sequentes sofreu alterac¸o˜es desde a sua concepc¸a˜o por Gentzen. Os sequentes em PVS
sera˜o mais explorados posteriormente no Cap´ıtulo 3, onde sera˜o mostrados alguns passos
da formalizac¸a˜o.
1.1.1 Regras estruturais
As regras estruturais permitem ao sequente ser rearranjado ou enfraquecido pela
introduc¸a˜o de novas fo´rmulas tanto em meio a`s antecedentes quanto nas consequentes. A
primeira regra e´ a de enfraquecimento e as outras sa˜o, de certa forma, casos particulares
dessa.
Σ1 `Γ Λ1
Σ2 `Γ Λ2 W se Σ1 ⊆ Σ2 e Λ1 ⊆ Λ2
Isso significa que, se conseguimos provar alguma fo´rmula em Λ1 atrave´s das fo´rmulas
em Σ1, continuaremos provando com Λ2 e Σ2 devido a`s incluso˜es.
No entanto, o comando de prova do PVS correspondente e´ o (hide), que esconde as
fo´rmulas desnecessa´rias para a prova. Assim, conseguindo uma prova de um sequente
mais forte, o mais fraco sera´ trivial e teremos a prova do nosso objetivo inicial. Dessa
forma, todos os comando do PVS trabalhara˜o no sentido de baixo para cima em relac¸a˜o
a essas regras de infereˆncia, com o objetivo de alcanc¸ar axiomas.
As regras de contrac¸a˜o (C) e de comutatividade (X) sa˜o casos particulares do
enfraquecimento, pois vale a relac¸a˜o de inclusa˜o requerida no caso anterior.
Sec¸a˜o 1.1 • Ca´lculo de Sequentes no PVS 6
a, a,Σ `Γ Λ
a,Σ `Γ Λ C
Σ `Γ a, a,Λ
Σ `Γ a,Λ C
O comando de prova correspondente a C e´ (copy).
Σ1, b, a,Σ2 `Γ Λ
Σ1, a, b,Σ2 `Γ Λ X
Σ `Γ Λ1, b, a,Λ2
Σ `Γ Λ1, a, b,Λ2 X
Por outro lado, a regra de troca de ordem das proposic¸o˜es (X) na˜o foi utilizada em
PVS durante a elaborac¸a˜o da formalizac¸a˜o.
1.1.2 Regra de Corte
A regra de corte representa no PVS a considerac¸a˜o de um caso atrave´s do comando
(case). A prova se divide em duas partes em que uma fo´rmula a e´ introduzida em meio
a`s antecedentes e, na outra, nas consequentes o que quer dizer que podemos considerar a
desde que provemos a. Outra forma de ver e´ que vale a ou ¬a.
(τ(Γ)(a) ∼ bool)Γ Σ, a `Γ Λ Σ `Γ a,Λ
Σ `Γ Λ Cut
1.1.3 Axiomas
A regra axioma´tica (Ax) faz com que o programa se deˆ conta de que a segue de a.
Assim, com o comando (assert), conseguimos fechar um ramo de prova do PVS.
Σ, a `Γ a,Λ Ax
Outras duas regras axioma´ticas do ca´lculo de sequentes sa˜o FALSE`, em que alguma
fo´rmula antecedente e´ falsa, e `TRUE, em que uma fo´rmula consequente e´ verdadeira.
Σ, FALSE `Γ Λ FALSE` Σ `Γ TRUE,Λ `TRUE
1.1.4 Regras Condicionais
Como trabalhou-se com va´rias definic¸o˜es recursivas (veremos isso mais a` frente), e´
interessante verificar a regra que controla a eliminac¸a˜o de IF-THEN-ELSE em uma prova.
Consideremos IF(a, b, c) como sendo IF a THEN b ELSE c. Enta˜o, utilizando comandos
como (prop), podemos dividir a prova nos casos em que vale a (com valor booleano) e
em que na˜o vale a.
Σ, a, b `Γ,a Λ Σ, c `Γ,¬a a,Λ
Σ, IF(a, b, c) `Γ Λ IF`
Σ, a `Γ,a b,Λ Σ `Γ,¬a a, c,Λ
Σ `Γ IF(a, b, c),Λ `IF
Caso os valores de a, b e c na˜o sejam booleanos, no´s podemos aplicar o comando
(lift-if) para que IF-THEN-ELSE seja colocado mais exteriormente na fo´rmula.
Sec¸a˜o 1.1 • Ca´lculo de Sequentes no PVS 7
1.1.5 Regras de Igualdade
A notac¸a˜o a[e] utilizada nas regras abaixo marca uma ou mais ocorreˆncias de e em a
tal que na˜o haja varia´veis livres em e. O mesmo vale para o conjunto de fo´rmulas Λ[e].
Σ `Γ a = a,Λ Refl
a = b,Σ[b] `Γ Λ[b]
a = b,Σ[a] `Γ Λ[a] Repl
Para utilizac¸a˜o da regra Repl utilizamos o comando (replace i), onde i e´ o ı´ndice
da fo´rmula a = b no sequente do PVS.
No´s temos alguns casos especiais para replace em que uma fo´rmula a antecedente pode
ser tratada como a =TRUE e, quando a e´ uma fo´rmula consequente, pode ser tratada como
a =FALSE.
Σ[TRUE], a `Γ Λ[TRUE]
Σ[a], a `Γ Λ[a] Repl TRUE
Σ[FALSE], a `Γ Λ[FALSE]
Σ[a] `Γ a,Λ[a] Repl FALSE
Por fim, temos a regra TRUE-FALSE que da´ conta que TRUE e FALSE teˆm valores
distintos.
Σ, TRUE = FALSE `Γ Λ TRUE-FALSE
1.1.6 Regras de Extensionalidade
As regras de extensionalidade sa˜o tambe´m regras de igualdade para estabalecer a
equivaleˆncia entre duas expresso˜es de func¸o˜es ou produtos. A regra FunExt introduz uma
constante de skolemizac¸a˜o s (s na˜o pertencente ao contexto Γ, isto e´, Γ(s) e´ indefinido)
para determinar que duas func¸o˜es f e g sa˜o equivalentes sempre que a aplicac¸a˜o das duas
a um argumento arbitra´rio s produz resultados iguais.
Σ `Γ,s:A (f s) =B[s/x] (g s),Λ
Σ `Γ f =[x:A→B] g,Λ FunExt Γ(s) e´ indefinido
Assim, vemos que uma igualdade entre func¸o˜es de tipo A → B se transforma numa
igualdade entre elementos de tipo B.
A regra TupExt da´ conta que dois produtos sa˜o iguais se suas projec¸o˜es
correspondentes o sa˜o.
Σ `Γ p1(a) =T1 p1(b),Λ Σ `Γ p2(a) =T2[(p1a)/x] p2(b),Λ
Σ `Γ a =[x:T1T2] b,Λ
TupExt
O comando do PVS correspondente a essas regras e´ o (decompose-equality).
Sec¸a˜o 1.2 • Teoria de Reescrita 8
1.1.7 Regra de Apresentac¸a˜o de Tipo
A regra Typepred e´ responsa´vel por introduzir uma fo´rmula mostrando que um
determinado elemento tem tipo A no constexto Γ.
τ(Γ)(a) = A pi(A)(a),Σ `Γ Λ
Σ `Γ Λ Typepred
De fato, analisando a primeira linha da regra, vemos que e´ extra´ıdo do contexto Γ que
a tem tipo A (τ(Γ)(a) = A) e acrescenta-se a proposic¸a˜o correspondente nas premissas
do sequente (pi(A)(a),Σ `Γ Λ).
Nesse caso, o comando do PVS responsa´vel pela aplicac¸a˜o dessa regra e´ o pro´prio
(typepred a).
1.2 Teoria de Reescrita
A teoria de reescrita, tomada como importante paradigma dentro da programac¸a˜o
funcional, pode apresentar diversas peculiaridades, desde que exibam sempre pares de
elementos relacionados num determinado contexto. Nesse sentido, voltamos o nosso
olhar para os Sistemas de Reescrita de Termos (TRS’s), mas antes veremos como tratar
caracter´ısticas comuns a quaisquer sistemas de reescrita.
1.2.1 Sistemas Abstratos de Reescrita
Sistemas Abstratos de Reescrita (ARS’s) sa˜o formados basicamente por um
conjunto A com uma relac¸a˜o bina´ria →R sobre o conjunto, sendo denotado por (A,→R).
Dizemos que, se a, b ∈ A e a→R b, a esta´ relacionado com b por→R, ou a reescreve para
b por →R, ou a reduz para b por →R. Esse conceito traz ferramentas necessa´rias para
trabalhar mais genericamente propriedades dos Sistemas de Reescrita de Termos (TRS’s)
que trataremos na pro´xima sec¸a˜o.
Para simplificar o nosso trabalho, considere a seguinte notac¸a˜o:
• R← denota a relac¸a˜o inversa.
• →=R denota o fecho reflexivo da relac¸a˜o, ou seja, 1 ou 0 passos.
• →+R denota o fecho transitivo, ou seja, 1 ou mais passos da relac¸a˜o.
• →∗R denota o fecho reflexivo transitivo, isto e´, 0 ou mais passos da relac¸a˜o.
• =R←, +R←, ∗R← denotam, respectivamente, os fechos reflexivo, transitivo e reflexivo
transitivo da relac¸a˜o inversa.
Quando o contexto for o´bvio, usaremos apenas → ao inve´s de →R.
Sec¸a˜o 1.2 • Teoria de Reescrita 9
Considere, por exemplo, o sistema (N,→D), onde
a→D b se, e somente se, b|a ∀a, b ∈ N.
Assim, temos que 36 →D 12 →D 6 →D . . . . No entanto, tambe´m sabemos que
36 →D 9 →D . . . . Assim, observamos uma divergeˆncia 6 D← 12 D← 36 →D 9. Pore´m,
podemos encontrar um elemento que junta 6 e 9 uma vez que 6 →D 3 D← 9. Observe o
diagrama:
36
D}}||
||
||
||
D @
@@
@@
@@
@
12
D~~
~~
~~
~~
9
D
~~}}
}}
}}
}}
}}
}}
}}
}}
}}
}
6
D @
@@
@@
@@
@
3
Num ARS (A,→), para quaisquer b, c ∈ A, b e c sa˜o junta´veis sempre que existe
d ∈ A tal que b →∗ d ∗← c. Assim, (A,→) e´ um sistema confluente sempre que
∀a, b, c ∈ A, b ∗← a→∗ c implica em b e c junta´veis.
Outra definic¸a˜o importante e´ a de propriedade diamante. Um sistema ter tal
propriedade significa que qualquer divergeˆncia em um passo e´ junta´vel em um passo, isto
e´, num sistema (A,→), ∀a, b, c ∈ A, se b← a→ c, enta˜o existe d ∈ A tal que b→ d← c.
a
∗
wwppp
ppp
ppp
ppp
pp
∗
''NN
NNN
NNN
NNN
NNN
b
∗
&&N
NN
NN
NN Conflueˆncia c
∗
xxp p
p p
p p
p
d
a
vvmmm
mmm
mmm
mmm
mmm
m
((QQ
QQQ
QQQ
QQQ
QQQ
QQ
b
((P
PP
PP
PP
PP Propr. Diamante c
vvn n
n n
n n
n n
n
d
Logo, o sistema (N,→D) e´ confluente e tem a propriedade diamante, pois para qualquer
divergeˆncia, o elemento 1 e´ um elemento de juntabilidade uma vez que divide qualquer
nu´mero natural.
1.2.2 Sistema de Reescrita de Termos
Termos sa˜o estruturas definidas indutivamente a partir de um conjunto de constantes
e func¸o˜es Σ e outro conjunto infinito enumera´vel de varia´veis V , de modo que Σ ∩ V = ∅
e:
1. varia´veis sa˜o termos;
Sec¸a˜o 1.2 • Teoria de Reescrita 10
2. constantes sa˜o termos;
3. f(t1, t2, . . . , tn) e´ um termo sempre que f /∈ V e´ uma func¸a˜o n-a´ria e, ∀i = 1, . . . , n,
temos que ti e´ um termo.
O conjunto de termos formados a partir de Σ e de V e´ denotado por T (Σ, V ). De
fato, as constantes podem ser vistas como func¸o˜es com aridade 0. O subtermo t de um
termo s em uma posic¸a˜o p pode ser escrito como t = s|p e denotamos por s[p ← t1] o
termo resultante da troca do subtermo da posic¸ao p em s por t1, ou seja, e´ o termo s a
menos da posic¸a˜o p, onde fizemos a troca.
As posic¸o˜es de um termo t tambe´m sa˜o descritas indutivamente como sequeˆncias de
naturais, sendo que:
1.  e´ a posic¸a˜o raiz e qualquer termo a tem como posic¸a˜o;
2. se t e´ uma varia´vel, enta˜o sua u´nica posic¸a˜o e´ ;
3. se t = f(t1, . . . , tn) e´ um termo funcional, enta˜o ∀i = 1, . . . , n, i concatenado com
uma posic¸a˜o de ti e´ uma posic¸a˜o de t.
Veja alguns exemplos:
t = f(g(x, a, h(y, a))) e t|1.3 = h(y, a)
f
g
  
  
  
  
NNN
NNN
NNN
NNN
NN
x a h
  
  
  
 
>>
>>
>>
>>
y a
s = g(f(a), h(b, f(y)), x) e s|2.2 = f(y)
g
ppp
ppp
ppp
ppp
pp
NNN
NNN
NNN
NNN
NN
f h




<<
<<
<<
<<
x
a b f
y
Tambe´m dizemos que duas posic¸o˜es p e q sa˜o paralelas sempre que na˜o houver prefixo
comum entre elas ale´m da posic¸a˜o raiz. Por exemplo, as posic¸o˜es 2.3.1 e 2.3.5 na˜o sa˜o
paralelas, pois teˆm como prefixo comum a posic¸a˜o 2.3. Por outro lado, as posic¸o˜es 1.3.3
e 2.3 sa˜o paralelas pois na˜o possuem prefixo comum, uma vez que o primeiro natural de
uma posic¸a˜o e´ diferente do primeiro natural da outra.
Sistemas de Reescrita de Termos (TRS’s) sa˜o programas com um nu´mero finito
de regras de reescrita. Uma regra e´ basicamente um par de termos, que pode ser
representado por 〈l, r〉 ou por l −→ r, sendo esta u´ltima a mais comum, de modo que o
lado esquerdo l esta´ relacionado com o lado direito r. Como tanto o lado esquerdo quanto
Sec¸a˜o 1.2 • Teoria de Reescrita 11
o lado direito de uma regra sa˜o termos, ambos devem assumir a estrutura apresentada
para tais. No entanto, existem algumas restric¸o˜es que devem ser observadas. O lado
esquerdo l na˜o deve ser uma varia´vel e qualquer varia´vel que ocorrer do lado direito r
necessariamente devera´ ocorrer em l tambe´m. Exemplo:
S : f(a) −→ g(b)
h(x, y) −→ f(g(x))
Uma regra de reescrita e´ dita linear a` esquerda quando o termo que ocorre ao lado
esquerdo da referida regra possui no ma´ximo uma ocorreˆncia de determinada varia´vel,
ou seja, se uma varia´vel aparecer, ela so´ ocorrera´ uma vez. Um sistema e´ dito linear a`
esquerda se todas as suas regras sa˜o lineares a` esquerda. O mesmo conceito de linearidade
vale para o lado direito. Assim, um sistema sera´ linear se for tanto linear a` esquerda
quanto linear a` direita.
Linear a` esquerda Linear a` direita Linear
S : f(0, x) −→ f(x, g(x)) R : 1 −→ 2 E : g(x) −→ f(x, 0)
h(y, x, 1) −→ g(f(x, y)) h(x, x, y) −→ h(x, y, 1) h(1, x, y) −→ f(y, x)
g(1) −→ 0 g(f(y, y)) −→ f(a, b) h(0, 0, 1) −→ g(1)
Uma substituic¸a˜o σ e´ uma aplicac¸a˜o σ : V −→ T (Σ, V ), ou seja, leva varia´veis em
termos. Ale´m disso, σ somente deixa de fixar um nu´mero finito de varia´veis; assim, o
domı´nio de σ, Dom(σ), conjunto das varia´veis que na˜o sa˜o mapeadas nelas mesmas, e´
finito. A substituic¸a˜o σ pode ser extendida ao conjunto de termos; para tσ, por exemplo,
basta trocar a ocorreˆncia de cada varia´vel do termo t pela sua respectiva imagem em
σ. Uma substituic¸a˜o ρ e´ um renomeamento se a imagem de qualquer varia´vel e´ uma
varia´vel.
Dois termos t e s sa˜o ditos unifica´veis se existe uma substituic¸a˜o γ tal que tγ = sγ.
Nesse caso, γ e´ chamado um unificador de t e s.
Em TRS’s, o conceito de reescrita toma uma outra dimensa˜o. Acrescentaremos
alguns detalhes que tornara˜o o processo mais preciso em relac¸a˜o ao modo como podemos
trabalhar, pore´m todos os outros conceitos que vimos e resultados que obteremos sa˜o
ainda aplica´veis aqui. Dizemos que, num sistema E de regras, para t, s ∈ T (Σ, V ), t
reescreve ou reduz para s (denotamos t −→E s ou t −→ s quando o sistema for o´bvio
no contexto) sempre que existir uma regra e = 〈l, r〉 ∈ E tal que, em alguma posic¸a˜o p
de t, t|p = lσ e s = t[p← rσ].
E : h(x, y) −→ g(x, x)
g(x, f(y)) −→ h(y, y)
Sec¸a˜o 1.2 • Teoria de Reescrita 12
A partir do sistema E, e´ poss´ıvel proceder com a sequeˆncia
de reduc¸o˜es h(f(a), h(f(b), b)) −→E h(f(a), g(f(b), f(b))) −→E h(f(a), h(b, b)) −→E
g(f(a), f(a)) −→E h(a, a) −→E g(a, a). De fato, observemos a primeira reduc¸a˜o. O
subtermo de t = h(f(a), h(f(b), b)) na posic¸a˜o 2 e´ exatamente o lado esquerdo da primeira
regra l1 = h(x, y) instanciado com a substituic¸a˜o σ = {x/f(b), y/b} (leva x em f(b) e y em
b), isto e´, t|2 = l1σ. Ale´m disso, o termo resultante s = h(f(a), g(f(b), f(b))) e´ o termo
t, trocando o subtermo da posic¸a˜o 2 pelo lado direito da primeira regra r1 = g(x, x)
instanciado tambe´m por σ, ou seja, s = t[2← r1σ].
Outro conceito importante e´ o de par cr´ıtico. Para que dois termos t e s sejam um
par cr´ıtico, e´ necessa´ria a existeˆncia de duas regras de reescrita e1 = 〈l1, r1〉 e e2 = 〈l2, r2〉
tais que os conjuntos de varia´veis dos termos l1 e l2 sejam disjuntos (se na˜o forem, basta
renomear de forma que sejam), o subtermo de l1 numa posic¸a˜o p, l1|p, na˜o seja uma
varia´vel e l1|p e l2 sejam unifica´veis com um unificador γ. Da´ı, devemos ter que t = r1γ
e s = l1γ[p ← r2γ] e´ o par cr´ıtico considerado. Em outras palavras, para que haja um
par cr´ıtico, e´ necessa´rio que o lado esquerdo de uma regra seja unifica´vel com o subtermo
do lado esquerdo de outra regra numa posic¸a˜o que na˜o seja de varia´vel. O par cr´ıtico e´ o
produto da divergeˆncia dessas duas regras que se sobrepo˜em. Considere, por exemplo, o
seguinte sistema:
A : f(x, g(y)) −→ h(y)
g(h(a)) −→ f(a, a)
γ = {y/h(a)} e´ um unificador para g(y) e g(h(a)),
pois (g(y))γ = g(h(a)) e γ na˜o altera g(h(a)),
uma vez que na˜o ha´ varia´veis neste termo.
Assim, temos um par cr´ıtico, que e´ basicamente uma divergeˆncia a partir das regras
onde ocorreu matching.
f(x, g(h(a)))
wwooo
ooo
ooo
oo
((QQ
QQQ
QQQ
QQQ
Q
h(h(a)) f(x, f(a, a))
Quando ocorre um par cr´ıtico, no´s dizemos que o sistema de regras e´ amb´ıguo. Na
verdade, o que nos interessa principalmente sa˜o os sistemas na˜o amb´ıguos, onde na˜o ha´
par cr´ıtico, e que sejam lineares a` esquerda. Tais sistemas sa˜o chamados ortogonais.
1.2.3 Principais Teoremas
Nesta sec¸a˜o, veremos alguns resultados fundamentais ate´ desenvolvermos a prova de
que TRS’s ortogonais sa˜o confluentes. Em alguns teoremas, veremos a ideia principal
para a prova, sem apresentar todos os detalhes te´cnicos.
Sec¸a˜o 1.2 • Teoria de Reescrita 13
Teorema 1.2.1 Todo sistema de reescrita que tem a propriedade do diamante e´
confluente.
Demonstrac¸a˜o: Seja o ARS (A,→) e a, b, c ∈ A tais que b ∗← a →∗ c. Precisamos
provar que existe d ∈ A tal que b →∗ d ∗← c. Faremos a prova por induc¸a˜o sobre o
nu´mero de passos m em que a atinge b e sobre o nu´mero de passos n em que a atinge c
(b m← a→n c).
Base de induc¸a˜o (BI) sobre m: se m = 0, enta˜o na˜o ha´ divergeˆncia, pois a→0 b
implica que a = b. Assim, ja´ sabemos que b = a →∗ c 0← c. Logo, c e´ o nosso
elemento de juntabilidade.
Passo indutivo (PI) sobre m: se m ≥ 1, enta˜o sabemos que existe b′ ∈ A tal que
a→ b′ →m−1 b.
BI sobre n: se n = 0, enta˜o na˜o ha´ divergeˆncia e b e´ o termo de juntabilidade,
pois temos que b→0 b ∗← c = a.
PI sobre n: se n ≥ 1, enta˜o sabemos que existe c′ ∈ A tal que a→ c′ →n−1 c.
Como temos a divergeˆncia em um passo b′ ← a → c′, pela hipo´tese da
propriedade do diamante, existe e ∈ A tal que b′ → e ← c′. Agora,
temos a divergeˆncia b m−1← b′ → e e, pela hipo´tese de induc¸a˜o (HI) sobre
m, existe d′ ∈ A tal que b →∗ d′ ∗← e. Finalmente, temos a divergeˆncia
d′ ∗← e ← c′ →n−1 c. Pela HI sobre n, existe d ∈ A tal que d′ →∗ d ∗← c. Pela
transitividade do fecho reflexivo transitivo, b→∗ d′ →∗ d implica b→∗ d ∗← c,
como quer´ıamos demonstrar. 
A estrate´gia de prova utilizada em [3, 4] para a prova de que TRS’s ortogonais sa˜o
confluentes utiliza o fato de que uma segunda relac¸a˜o entre termos chamada reduc¸a˜o ou
reescrita em paralelo tem a propriedade diamante. Da´ı, pelo teorema anterior, temos
a conflueˆncia para a reduc¸a˜o em paralelo, que equivale a` conflueˆncia para a reescrita
simples, uma vez que o fecho reflexivo transitivo da primeira corresponde ao fecho reflexivo
transitivo da segunda.
No´s definimos a reescrita em paralelo de modo semelhante ao da reescrita simples,
sendo que a reduc¸a˜o pode ocorrer em va´rias posic¸o˜es paralelas dentro do termo
original. Denotaremos a reescrita em paralelo sobre as regras de um sistema E por
⇒E. Assim, quando dizemos que t1 ⇒E t2, estamos afirmando que ha´ uma sequeˆncia
(possivelmente vazia) Π = (pi0, . . . , pin) de posic¸o˜es paralelas do termo t1, uma sequeˆncia
 = (〈l0, r0〉, . . . , 〈ln, rn〉) de regras em E e uma sequeˆncia Γ = (γ0, . . . , γn) de substituic¸o˜es,
tais que, ∀i = 0, . . . , n (n = |Π| − 1), temos:
Sec¸a˜o 1.2 • Teoria de Reescrita 14
1. t1|pii = liγi;
2. t2|pii = riγi e as diferenc¸as entre t1 e t2 ocorrem somente nessas posic¸o˜es.
Teorema 1.2.2 t1 ⇒∗E t2 se, e somente se, t1 →∗E t2.
Demonstrac¸a˜o:
(⇒) De fato, como para cada passo de⇒E no´s temos va´rios passos de→E, enta˜o t1 ⇒∗E t2
corresponde a t1(→∗E)∗t2. Mas isso corresponde a t1 →∗E t2 e temos o que quer´ıamos.
(⇐) No´s podemos considerar que cada passo de →E corresponde a um passo de ⇒E.
E´ so´ tomar a sequeˆncia unita´ria de posic¸a˜o, de regra e de substituic¸a˜o. Assim, ja´
temos diretamente que t1 →∗E t2 implica que t1 ⇒∗E t2. 
Para provar o teorema seguinte, consideraremos verdadeiro que a relac¸a˜o ⇒E tem a
propriedade diamante no caso em que E seja ortogonal e, posteriormente, faremos um
esboc¸o da demonstrac¸a˜o da afirmac¸a˜o.
Teorema 1.2.3 Seja E um sistema de regras de reescrita ortogonal. Enta˜o, a relac¸a˜o
→E e´ confluente.
Demonstrac¸a˜o: Assumiremos que⇒E tem a propriedade diamante. Pelo teorema 1.2.1,
sabemos enta˜o que ⇒E e´ confluente, o que quer dizer que, ∀s, t1, t2 ∈ T (Σ, V ) tais que
t1
∗⇔ t⇒∗ t2 implica que ∃u ∈ T (Σ, V ) tal que t1 ⇒∗ u ∗⇔ t2.
Como temos a equivaleˆncia entre →∗E e ⇒∗E, segue que →E e´ confluente. 
Teorema 1.2.4 Seja E um sistema de regras de reescrita ortogonal. Enta˜o, a relac¸a˜o
⇒E tem a propriedade diamante.
Esboc¸o da prova: Sejam s, t1, t2 ∈ T (Σ, V ) tais que t1 ⇔ s⇒ t2. Enta˜o, existem duas
sequeˆncias Π1 e Π2 de posic¸o˜es paralelas de s onde ocorrem as reduc¸o˜es. No entanto, essas
posic¸o˜es podem na˜o ser paralelas quando se considera as posic¸o˜es das duas sequeˆncias
juntas.
Consideraremos as posic¸o˜es onde ocorrera˜o as reduc¸o˜es como sendo o ve´rtice superior
dos triaˆngulos coloridos na Figura 1.1. Os triaˆngulos vermelhos e o roxo representam
os subtermos de s que sera˜o modificados para atingir o termo t1 em um u´nico passo de
reescrita em paralelo; os triaˆngulos azuis e o roxo representam os subtermos de s que
sera˜o modificados para atingir o termo t2.
Como esses subtermos sera˜o reescritos, isso significa que fazem matching com alguma
instanciac¸a˜o do lado esquerdo de regras que esta˜o no sistema ortogonal E. Chamaremos
de 1 e Γ1 as sequeˆncias de regras e de substituic¸o˜es, respectivamente, responsa´veis pela
Sec¸a˜o 1.2 • Teoria de Reescrita 15
s
Figura 1.1: Termo inicial
reescrita para t1 e de 2 e Γ2 as sequeˆncias de regras e substituic¸o˜es, respectivamente,
responsa´veis pela reescrita para t2.
Assim, como a Figura 1.1 mostra, de fato ha´ a possibilidade de encontrarmos o lado
esquerdo de regras em 1 instanciado com as substituic¸o˜es de Γ1 dentro do lado esquerdo de
regras em 2 instanciado com as substituic¸o˜es em Γ2 e vice-versa. Note que ha´ penta´gonos
interpostos entre os triaˆngulos sempre que ha´ “sobreposic¸a˜o” de regras. De fato, na˜o
ha´ sobreposic¸a˜o, pois esses penta´gonos representam varia´veis cuja instanciac¸a˜o pelas
substituic¸o˜es correspondentes ao termo colorido maior conte´m os subtermos coloridos.
A existeˆncia dessas varia´veis e´ devida a` na˜o ambiguidade das regras em E. No caso do
subtermo roxo, como as posic¸o˜es coincidem, tambe´m pela na˜o ambiguidade ja´ sabemos
que e´ uma u´nica regra que faz a reduc¸a˜o para o termo t1 e para t2.
Da´ı, temos a seguinte divergeˆncia quando acontecem as reescritas em paralelo:
Os triaˆngulos preenchidos representam o lado direito das regras, ou seja, onde ja´
ocorreram as modificac¸o˜es, mas ainda assim pode haver triaˆngulos vazados no seu interior.
Isso acontece porque as varia´veis que conteˆm o lado esquerdo de algumas regras podem
ocorrer tambe´m do lado direito de uma regra; mais que isso, as varia´veis podem se replicar
no lado direito. De fato, quando no´s falamos de ortogonalidade, falamos de linearidade a`
esquerda, mas a` direita na˜o ha´ restric¸o˜es quanto ao nu´mero de ocorreˆncias de uma dada
varia´vel.
Note ainda que as posic¸o˜es das varia´veis podem ser modificadas dentro do termo
colorido maior. Assim, os subtermos coloridos das varia´veis tambe´m assumira˜o novas
posic¸o˜es, podendo se replicar.
O nosso objetivo e´ obter um termo u que satisfac¸a o que acontece na figura seguinte:
Para tanto, vamos analisar o que deve ocorrer para que t1 ⇒E u. Entendendo como
isso ocorre, sabemos que t2 ⇒E u e´ um caso sime´trico a este.
Como falamos anteriormente, o termo de contorno roxo na˜o sera´ modificado de t1 para
u, pois na˜o ha´ diferenc¸a entre t1 e t2 nessa posic¸a˜o.
Sec¸a˜o 1.2 • Teoria de Reescrita 16
E E
s
t t1 2
Figura 1.2: Divergeˆncia em um passo de reescrita em paralelo
E E
E E
s
t t
u
1 2
Figura 1.3: Termo de juntabilidade
Sec¸a˜o 1.2 • Teoria de Reescrita 17
t1s
E E
u
Figura 1.4: Cadeia de reduc¸o˜es passando por t1
Os subtermos vazados azuis que esta˜o dentro do triaˆngulo vermelho preenchido
precisam ficar preenchidos tambe´m. A u´nica observac¸a˜o ao se reduzir esses termos e´
que precisamos atualizar as posic¸o˜es, uma vez que as varia´veis que os conteˆm trocam as
posic¸o˜es no triaˆngulo preenchido, isto e´, quando o triaˆngulo vermelho deixa de ser lado
esquerdo para ser lado direito da regra instanciada. Nesse caso, as regras que utilizaremos
sa˜o as de 2 e as substituic¸o˜es de Γ2 que as acompanham.
Em relac¸a˜o ao triaˆngulo azul vazado grande em t1, ha´ que se tomar cuidado. Observe
que a substituic¸a˜o que instanciava essa regra em s na˜o serve mais, pois o termo foi
modificado em suas “subposic¸o˜es”. No entanto, a mesma substituic¸a˜o pode ser alterada
de forma que a mesma regra fac¸a matching com esse termo em t1. Nesse momento, e´
importante lembrar que as substituic¸o˜es agem somente sobre varia´veis. Mas as alterac¸o˜es
que o termo do triaˆngulo azul grande sofreu ocorreram justamente dentro das instanciac¸o˜es
de varia´veis, ou seja, dentro dos penta´gonos. Assim, criamos uma nova substituic¸a˜o que
age exatamente como a de antes, mas onde aparecem as nossas varia´veis de interesse,
trocam-se os triaˆngulos vermelhos vazados (como em s) pelos triaˆngulos vermelhos
preenchidos (como em t1).
Logo, chegamos ao fim do nosso esboc¸o pois encontramos as posic¸o˜es, as regras e as
substituic¸o˜es que precisa´vamos encontrar para fazer a reduc¸a˜o em paralelo de t1 para u.
O outro caso, e´ ana´logo. 
A mesma ideia apresentada aqui sera´ utilizada para a formalizac¸a˜o do teorma em
um assistente de prova: primeiramente descrevemos quem e´ o termo de juntabilidade e,
depois, nos damos conta de que existem sequeˆncias de posic¸o˜es, regras e substituic¸o˜es que
satisfazem as condic¸o˜es para reduc¸a˜o em paralelo.
A na˜o ambiguidade e´ fundamental nessa prova uma vez que e´ dela que sacamos a
existeˆncia das varia´veis onde podemos agir para criar novas substituic¸o˜es. Por outro
lado, a linearidade a` esquerda e´ importante pois a reescrita em paralelo age em posic¸o˜es
espec´ıficas enquanto que a substituic¸a˜o age em todas as ocorreˆncias das varia´veis em seu
domı´nio. Isso acarretaria diferenc¸as no termo final. Para entendermos essa diferenc¸a,
acompanhemos o exemplo que temos a seguir.
Sec¸a˜o 1.2 • Teoria de Reescrita 18
Considere o sistema T na˜o amb´ıguo, pore´m na˜o linear a` esquerda.
T : f(x, g(x)) −→ g(b)
h(a, x) −→ g(a)
a −→ c
Acompanhe a divergeˆncia que ocorre a partir do termo s = f(h(a, y), g(h(a, y))).
f(h(a, y), g(h(a, y)))
T
rz nnn
nnn
nnn
nnn
n
nnn
nnn
nnn
nnn
n
T &.TT
TTTT
TTTT
TTTT
T
TTTT
TTTT
TTTT
TTT
g(b) f(g(a), g(h(c, y)))
Assim, na˜o existe substituic¸a˜o capaz de instanciar a primeira regra de tal forma que
ocorra o matching do lado esquerdo com o termo f(g(a), g(h(c, y))), pois a imagem de x
teria que ser g(a) e h(c, y) ao mesmo tempo.
Agora, vamos fazer uma pequena modificac¸a˜o em T e criar o sistema ortogonal T˜ .
T˜ : f(x, g(y)) −→ g(b)
h(a, x) −→ g(a)
a −→ c
Novamente, no´s temos a mesma divergeˆncia a partir do termo s.
f(h(a, y), g(h(a, y)))
T˜
v~ vv
vv
vv
vv
vv
vv
vv
vv
T˜
#+N
NNN
NNN
NNN
NNN
NNN
NNN
NN
NNN
NNN
NNN
NNN
NNN
NNN
NNN
g(b) f(g(a), g(h(c, y)))
T˜
ks
No entanto, a divergeˆncia e´ junta´vel. Quando fizemos f(h(a, y), g(h(a, y))) ⇒T˜ g(b),
utilizamos a primeira regra e a substituic¸a˜o σ = {x/h(a, y) , y/h(a, y)}. Finalmente,
para fazer f(g(a), g(h(c, y))) ⇒T˜ g(b), utilizamos a mesma regra e a substituic¸a˜o
σ′ = {x/g(a), y/h(c, y)}.
Cap´ıtulo
2
Especificac¸a˜o
Toda a teoria apresentada aqui tem se especificado com o objetivo de formaliza´-la em
um assistente de prova semi-automa´tico. O assistente utilizado no trabalho e´ o Prototype
Verification System (PVS) na versa˜o 5.0, provador baseado numa lo´gica de ordem superior.
O nome da teoria desenvolvida e´ orthogonality e utiliza grande parte das teorias ars
e trs desenvolvidas pelo Grupo de Teoria da Computac¸a˜o (GTC/UnB), dispon´ıveis em [1],
na forma dos pro´prios arquivos de formalizac¸a˜o, e em [2, 6, 7], como artigos apresentados
pelos desenvolvedores do GTC/UnB.
2.1 Sistemas Abstratos de Reescrita
Algumas definic¸o˜es tratadas nesses trabalhos nos dara˜o base para entender a
especificac¸a˜o desenvolvida aqui. Apresentamos primeiramente as que se relacionam aos
ARS’s. Esses conceitos esta˜o dispon´ıveis na teoria ars como mencionado acima.
RC(R): reflexive = union(R, =)
iterate(f, n)(x): RECURSIVE T =
IF n = 0 THEN x ELSE f(iterate(f, n-1)(x)) ENDIF
MEASURE n
TC(R): transitive = IUnion(LAMBDA (p:posnat): iterate(R, p))
RTC(R): reflexive_transitive = IUnion(LAMBDA (n:nat): iterate(R, n))
joinable?(R)(x,y): bool = EXISTS z: RTC(R)(x,z) & RTC(R)(y, z)
confluent?(R): bool = FORALL x, y, z: RTC(R)(x,y) & RTC(R)(x,z) =>
joinable?(R)(y,z)
Sec¸a˜o 2.2 • Sistemas de Reescrita de Termos 20
diamond_property?(R): bool = FORALL x, y, z: R(x,y) & R(x,z) =>
EXISTS r: R(y,r) & R(z,r)
Note que R e´ uma relac¸a˜o de reescrita. Ate´ este momento, ainda estamos trabalhando
somente as definic¸o˜es relacionadas aos ARS’s. Temos que RC (reflexive closure) nos da´
o fecho reflexivo da relac¸a˜o R, isto e´, se temos RC(R)(x,y), enta˜o R(x,y) ou x=y. Ja´ a
func¸a˜o iterate faz a func¸a˜o f agir sobre x por n vezes, sendo definida recursivamente,
nos resultando numa multi-composic¸a˜o da mesma func¸a˜o. O fecho transitivo da relac¸a˜o
R e´ denotado por TC(R) e e´ definido como a unia˜o de todas as composic¸o˜es de R por um
nu´mero p natural positivo de vezes (p≥ 1). O fecho reflexivo transitivo de R, denotado
por RTC(R), e´ definido da mesma forma, mas para n natural qualquer, ou seja, ha´ a
possibilidade de que na˜o haja iterac¸a˜o alguma de R se n=0.
Ja´ a noc¸a˜o de juntabilidade de dois elementos x e y atrave´s da relac¸a˜o R e´ dada pelo
predicado joinable?, onde joinable?(R)(x,y) significa que ha´ um elemento z tal que
x e y atingem z atrave´s de RTC(R), ou seja, existe uma cadeia de reduc¸a˜o de x a z
com 0 ou mais passos e outra cadeia de reduc¸a˜o tambe´m em 0 ou mais passos de y a
z. O predicado confluent? aponta que uma determinada relac¸a˜o R e´ confluente, isto
e´, para qualquer divergeˆncia a partir de um elemento x, RTC(R)(x,y) e RTC(R)(x,z),
esses elementos y e z sa˜o junta´veis. A propriedade diamante e´ expressa pelo predicado
diamond property? que avalia se uma relac¸a˜o R tem ou na˜o tal propriedade o que quer
dizer que, se diamond property?(R) e´ verdadeira, qualquer divergeˆncia em um passo
para cada lado (R(x,y) e R(x,z)) implica na existeˆncia de um elemento de juntabilidade
r que pode ser alcanc¸ado em um passo de cada lado (R(y,r) e R(z,r)).
2.2 Sistemas de Reescrita de Termos
Outras definic¸o˜es chave para a compreensa˜o do co´digo sa˜o os conceitos relacionados
aos TRS’s, tratados anteriormente ao presente trabalho e dispon´ıveis na teoria trs. Sa˜o
estes:
term: TYPE
vars?, app?: [term -> boolean]
V: set[term] = {x: term | vars?(x)}
vars: [variable -> (vars?)]
app:
[[f: symbol,
Sec¸a˜o 2.2 • Sistemas de Reescrita de Termos 21
{args: finite_sequence[term] | args‘length = arity(f)}] ->
(app?)]
v: [(vars?) -> variable]
f: [(app?) -> symbol]
args:
[d: (app?) ->
{args: finite_sequence[term] | args‘length = arity(f(d))}]
term_v_vars: AXIOM
FORALL (vars1_var: variable): v(vars(vars1_var)) = vars1_var;
term_f_app: AXIOM
FORALL (app1_var: symbol,
app2_var:
{args: finite_sequence[term] |
args‘length = arity(app1_var)}):
f(app(app1_var, app2_var)) = app1_var;
term_args_app: AXIOM
FORALL (app1_var: symbol,
app2_var:
{args: finite_sequence[term] |
args‘length = arity(app1_var)}):
args(app(app1_var, app2_var)) = app2_var
term_inclusive: AXIOM
FORALL (term_var: term): vars?(term_var) OR app?(term_var)
Foi criado o tipo term cujos elementos podem ser avaliados pelos predicados vars?
(que julga se um dado termo e´ uma varia´vel) e app? (diz se e´ um termo funcional).
V e´ definido como o conjunto de todas as varia´veis. A func¸a˜o vars toma qualquer
varia´vel e lhe da´ o valor de verdade como varia´vel pelo predicado vars? e a func¸a˜o
app faz o correspondente em relac¸a˜o a`s aplicac¸o˜es, termos funcionais com um s´ımbolo f
e uma sequeˆncia de termos args aplicados como argumentos em cada posic¸a˜o de f cujo
comprimento coincide com a aridade do s´ımbolo.
As func¸o˜es v, f e args fazem o oposto, tomando o que tem valor de verdade como
varia´vel no caso de v ou aplicac¸a˜o no caso de f/args, retornando a varia´vel avaliada por
vars?, ou ainda, para o termo avaliado como funcional por app?, o s´ımbolo de func¸a˜o
ou os argumentos do termo, respectivamente. Vale mencionar que essa parte e´ gerada
automaticamente pelo PVS quando definimos um datatype. Os axiomas term v vars,
Sec¸a˜o 2.3 • Posic¸o˜es 22
term f app e term args app mostram justamente essas propriedades descritas acima. O
axioma term inclusive restringe as opc¸o˜es de caracterizac¸a˜o de um termo, que so´ pode
ser uma varia´vel ou uma aplicac¸a˜o.
2.3 Posic¸o˜es
position: TYPE = finseq[posnat]
positions: TYPE = set[position]
positionsOF(t: term): RECURSIVE positions =
(CASES t OF
vars(t): only_empty_seq,
app(f, st): IF length(st) = 0
THEN
only_empty_seq
ELSE
union(only_empty_seq,
IUnion((LAMBDA (i: upto?(length(st))):
catenate(i, positionsOF(st(i-1)) ))))
ENDIF
ENDCASES)
MEASURE t BY <<
Como tratamos antes, cada posic¸a˜o, denotada por position, e´ uma sequeˆncia
finita de naturais na˜o nulos (finseq[posnat]) e positions e´ um conjunto de posic¸o˜es
(set[position]). O conjunto de posic¸o˜es de um termo t, denotado por positionsOF(t),
e´ definido recursivamente onde, se t e´ uma varia´vel, enta˜o o conjunto sera´ only empty seq,
ou seja, a u´nica posic¸a˜o de t e´ empty seq, a posic¸a˜o raiz; sena˜o, t e´ uma aplicac¸a˜o
app(f,st) e, caso a sequeˆncia de argumentos st aplicados a f tenha comprimento nulo,
enta˜o temos novamente only empty seq e, caso contra´rio, temos que positionsOF(t)
sera´ a unia˜o de only empty seq e as posic¸o˜es formadas pela ac¸a˜o de concatenar cada
ı´ndice i da sequeˆncia st adicionando 1, isto e´, i+1, com as posic¸o˜es do termo dentro
do argumento na posic¸a˜o i da sequeˆncia (e´ somado 1 ao ı´ndice, pois trabalhamos com
posnat em relac¸a˜o a`s posic¸o˜es de termos, enquanto que utilizamos nat nos ı´ndices de uma
sequeˆncia finita).
p, q: VAR position
fsp: VAR finseq[position]
t: VAR term
Sec¸a˜o 2.4 • Sequeˆncias finitas 23
<=(p, q): bool = (EXISTS (p1: position): q = p o p1)
parallel(p, q): bool = (NOT p <= q) & (NOT q <= p)
PP?(fsp): bool = IF fsp‘length < 2
THEN true
ELSE
FORALL (i, j: below[length(fsp)]): i /= j =>
parallel(fsp(i), fsp(j))
ENDIF
SP?(t)(fsp): bool = FORALL (i: below[length(fsp)]):
positionsOF(t)(fsp(i))
SPP?(t)(fsp): bool = PP?(fsp) & SP?(t)(fsp)
Temos que a posic¸a˜o p e´ prefixo de q sempre que existir uma posic¸a˜o complemento
p1, ou seja, q e´ p concatenada com p1. Por exemplo, se p= 3.2 e q= 3.2.2.4.5, enta˜o
temos que p<=q, pois q=p o p1, onde p1= 2.4.5. Agora, vale parallel(p,q) se na˜o vale
a relac¸a˜o bina´ria <= em nenhum dos dois sentidos. Sendo assim, algumas propriedades
sa˜o extra´ıdas facilmente como, por exemplo, a comutatividade de parallel, que vem
diretamente da comutatividade do conectivo lo´gico &. O predicado PP? aplicado a uma
sequeˆncia de posic¸o˜es fsp compara todas as posic¸o˜es da sequeˆncia e verifica se todas
sa˜o paralelas duas a duas. Ja´ SP?(t)(fsp) e´ verdade se todas as posic¸o˜es de fsp sa˜o
posic¸o˜es do termo t e vale SPP?(t)(fsp) se valem as duas proposic¸o˜es acima (PP?(fsp)
e SP?(t)(fsp)).
2.4 Sequeˆncias finitas
Antes de continuar, vale a pena trazer alguns conceitos sobre sequeˆncias finitas
(finseq’s) que dara˜o base a va´rias definic¸o˜es daqui para frente. E´ importante dizer
que a teoria que trata esses conceitos finite sequences extras[T: TYPE] trabalha com
um tipo arbitra´rio T, sendo que a teoria pode ser importada e instanciada tranquilamente
por qualquer outro tipo existente, o que faremos extensamente durante a especificac¸a˜o.
Esse modelo de tipagem e´ chamado polimorfismo.
first(seq: not_empty_seq): T = seq(0)
rest(seq): finseq = IF seq‘length = 0
THEN seq
ELSE ^(seq,(1, seq‘length - 1))
Sec¸a˜o 2.4 • Sequeˆncias finitas 24
ENDIF
delete(seq, (n: below[length(seq)])): finseq =
(IF seq‘length = 0
THEN seq
ELSE (# length := seq‘length - 1,
seq := (LAMBDA (i: below[seq‘length - 1]):
(IF i < n THEN seq(i)
ELSE seq(i + 1)
ENDIF)) #)
ENDIF)
insert?(x, seq, (n: upto[length(seq)])): finseq =
(# length := seq‘length + 1,
seq := (LAMBDA (i: below[seq‘length + 1]):
(IF i < n THEN seq(i)
ELSIF i = n THEN x
ELSE seq(i - 1) ENDIF)) #)
add_first(x, seq): finseq = insert?(x, seq, 0)
replace(x, seq, (n: below[length(seq)])): finseq =
(IF seq‘length = 0 THEN seq
ELSE
(# length := seq‘length,
seq := (LAMBDA (i: below[seq‘length]):
(IF i < n THEN seq(i)
ELSIF i = n THEN x
ELSE seq(i) ENDIF)) #)
ENDIF)
A func¸a˜o first pode ser aplicada a uma finseq na˜o vazia seq e retorna o primeiro
elemento da sequeˆncia seq(0) de tipo T. Por outro lado, rest pode ser aplicada a qualquer
sequeˆncia finita e retorna outra finseq, que e´ o resto da sequeˆncia (retira o primeiro
elemento, se houver). A func¸a˜o delete que tem como argumentos uma sequeˆncia seq e
um natural n menor que o comprimento da sequeˆncia, retorna seq a menos do elemento
seq(n), que e´ retirado, e os ı´ndices posteriores a n sa˜o ajustados. Quando insert? e´
aplicado a um elemento x de tipo T, a seq, que e´ uma finseq[T], e a n natural menor
ou igual ao comprimento de seq, temos que e´ acrescentado a seq o elemento x na posic¸a˜o
de ı´ndice n, ajustando-se os ı´ndices posteriores. A aplicac¸a˜o add first utiliza insert?
para inserir o elemento x na primeira posic¸a˜o da sequeˆncia seq, ou seja, a de ı´ndice 0.
Por u´ltimo, temos a func¸a˜o replace que toma em seq o elemento seq(n), que esta´ na
posic¸a˜o n+1-e´sima, e o troca por x.
Sec¸a˜o 2.5 • Subtermos 25
2.5 Subtermos
Voltamos a tratar dos conceitos dentro dos TRS’s. Repare a ocorreˆncia das notac¸o˜es
apresentadas para finseq[T], sendo que temos agora o tipo T instanciado com position
e term, por exemplo, e va´rios outros tipos que precisaremos mais a` frente.
subtermOF(t: term, (p: positions?(t))): RECURSIVE term =
(IF length(p) = 0
THEN
t
ELSE
LET st = args(t),
i = first(p),
q = rest(p) IN
subtermOF(st(i-1), q)
ENDIF)
MEASURE length(p)
Vars(t): set[(V)] = {x: (V) | EXISTS (p: positions?(t)): subtermOF(t, p) = x}
Pos_var(t, x): positions = {p: positions?(t) | subtermOF(t,p) = x}
A aplicac¸a˜o subtermOF nos da´ o subtermo de t na posic¸a˜o p, onde p pertence ao
conjunto de posic¸o˜es de t. O algoritmo trabalha recursivamente atrave´s do comprimento
de p. Enquanto o comprimento da posic¸a˜o que no´s trabalhamos na˜o for 0, enta˜o t e´ um
termo funcional e no´s podemos tomar o argumento i-e´simo (de ı´ndice i-1 na sequeˆncia),
onde i e´ o primeiro posnat na formac¸a˜o de p, e no´s aplicamos novamente subtermOF
a esse argumento e a` posic¸a˜o rest(p). Assim, o comprimento da posic¸a˜o sempre vai
diminuindo, uma vez que aplicamos rest a` posic¸a˜o anterior em cada passo. Quando
obtivermos p=empty seq, isto e´, length(p)=0, enta˜o podemos parar e retornar o pro´prio
termo aplicado naquele passo. O conjunto Vars(t) engloba todas as varia´veis que ocorrem
em t baseado na existeˆncia de posic¸o˜es desse termo cujos subtermos sejam varia´veis. Ja´
o conjunto Pos var(t,x) abarca as posic¸o˜es de t onde ocorre uma dada varia´vel x.
2.6 Substituic¸o˜es
sigma: VAR [(V) -> term]
Dom(sigma): set[(V)] = {x: (V) | sigma(x) /= x}
Sec¸a˜o 2.7 • Reduc¸a˜o simples 26
Ran(sigma): set[term] =
{y: term | EXISTS (x: (V)): member(x, Dom(sigma)) & y = sigma(x)}
Sub?(sigma): bool = is_finite(Dom(sigma))
ext(sigma)(t): RECURSIVE term =
CASES t OF
vars(t): sigma(t),
app(f, st): IF length(st) = 0
THEN t
ELSE
LET
sst = (# length := st‘length,
seq := (LAMBDA (n: below[st‘length]):
ext(sigma)(st(n)))#)
IN
app(f, sst)
ENDIF
ENDCASES
MEASURE t BY <<
Declaramos sigma como uma aplicac¸a˜o que leva varia´veis em termos e definimos o
domı´nio de sigma, Dom(sigma), como o conjunto das varia´veis cuja imagem por sigma
na˜o sa˜o elas mesmas. Ja´ Ran(sig) e´ o conjunto imagem de sigma sobre Dom(sigma)
exclusivamente. No´s dizemos que sigma e´ uma substituic¸a˜o (denotado por Sub?(sigma))
sempre que Dom(sigma) e´ finito. No´s tambe´m estendemos a aplicac¸a˜o sigma a qualquer
termo t homomorficamente, ou seja, fazemos ext(sigma)(t), sendo que, se t for
funcional, enta˜o aplicamos a extensa˜o da substituic¸a˜o novamente a cada argumento do
termo.
2.7 Reduc¸a˜o simples
replaceTerm(s: term, t: term, (p: positions?(s))): RECURSIVE term =
(IF length(p) = 0
THEN
t
ELSE
LET st = args(s),
i = first(p),
q = rest(p),
rst = replace(replaceTerm(st(i-1), t, q), st,i-1) IN
app(f(s), rst)
Sec¸a˜o 2.8 • Ortogonalidade 27
ENDIF)
MEASURE length(p)
O algoritmo replaceTerm(s,t,p) toma o termo s e troca o subtermo da posic¸a˜o
p pelo termo t. Como em subtermOF, replaceTerm trabalha sobre o comprimento de
p. Se p for a posic¸a˜o raiz, enta˜o basta trocar s por t. Sena˜o, s e´ funcional. Enta˜o,
no´s atualizamos um dos argumentos que sa˜o aplicados ao s´ımbolo de s e continuamos
trabalhando com o rest(p). A troca feita na sequeˆncia de argumentos em cada passo e´
realizada por replace.
rewrite_rule?(l,r): bool = (NOT vars?(l)) & subset?(Vars(r), Vars(l))
reduction?(E)(s,t): bool =
EXISTS ( (e | member(e, E)), sigma, (p: positions?(s))):
subtermOF(s, p) = ext(sigma)(lhs(e)) &
t = replaceTerm(s, ext(sigma)(rhs(e)), p)
Temos tambe´m o predicado rewrite rule? que avalia que um par de termos (l,r)
e´ uma regra de reescrita sempre que l na˜o for uma varia´vel e Vars(r) estiver contido em
Vars(l). Enfim, no´s dizemos que reduction?(E)(s,t) sempre que o termo s reduzir
para t com as regras do TRS E, isto e´, se houver uma posic¸a˜o p de s, uma substituic¸a˜o
sigma e uma regra e em E tais que o subtermo de s em p e´ ext(sigma)(lhs(e)) e o
termo resultante t e´ replaceTerm(s, ext(sigma)(rhs(e)), p), onde lhs e rhs sa˜o o
lado esquerdo e direito de uma regra respectivamente.
2.8 Ortogonalidade
Essas foram as principais definic¸o˜es utilizadas daquilo que ja´ havia sido realizado
em [6–8]. Passamos agora a introduzir o que foi produzido durante o presente trabalho.
O nome da teoria criada para tratar os nossos conceitos e resultados e´ orthogonality.
O teorema que motivou o desenvolvimento da teoria foi o seguinte:
Orthogonal_implies_confluent: LEMMA
FORALL (E : Orthogonal) :
LET RRE = reduction?(E) IN
confluent?(RRE)
No entanto, ainda nos cabe mostrar como definimos o conceito de Orthogonal que
aparece aqui.
Sec¸a˜o 2.9 • Definic¸o˜es auxiliares 28
Ambiguous?(E): bool = EXISTS (t1, t2) : CP?(E)(t1,t2)
linear?(t): bool = FORALL (x | member(x,Vars(t))) : Card[position](Pos_var(t,x)) = 1
Left_Linear?(E): bool = FORALL (e | member(e, E)) : linear?(lhs(e))
Orthogonal?(E): bool = Left_Linear?(E) & NOT Ambiguous?(E)
Orthogonal: TYPE = (Orthogonal?)
A noc¸a˜o de ambiguidade (Ambiguous?) sobre um sistema de reescrita E dita a
existeˆncia de dois termos que formem um par cr´ıtico nesse sistema, como indicamos na
sec¸a˜o 1.2. O predicado linear? avalia um termo t quanto a` ocorreˆncia de suas varia´veis,
tomando cada varia´vel x em Vars(t) e conferindo se a cardinalidade de Pos var(t,x) e´
1. Assim, um sistema e´ dito Left Linear? se o termo do lado esquerdo de cada regra
lhs(e) for linear?. Finalmente, temos que um sistema e´ tido como Orthogonal? se
for Left Linear? e na˜o for Ambiguous?. Orthogonal e´ o tipo de todo sistema que seja
Orthogonal?.
2.9 Definic¸o˜es auxiliares
Durante a prova do teorema principal, no´s precisamos criar algumas definic¸o˜es que nos
auxiliara˜o. Elas sa˜o mais ba´sicas e tratam sequeˆncias finitas de tipo T instancia´vel. Como
estamos tratando de tipos polimo´rficos mais uma vez, como na subsec¸a˜o 2.4, precisamos
criar subteorias para tratar conceitos que envolvem um tipo arbitra´rio T. Tal tipo podera´
ser instanciado como termo, posic¸a˜o, substituic¸a˜o, regra de reescrita e outros, conforme
a convenieˆncia.
mem_seq(x, seq): RECURSIVE bool =
IF length(seq) = 0 THEN false
ELSIF x = seq(0) THEN true
ELSE mem_seq(x, rest(seq))
ENDIF
MEASURE length(seq)
seq2set(seq): RECURSIVE set[T] =
IF seq‘length = 0 THEN emptyset
ELSE add(seq(0), seq2set(rest(seq)))
ENDIF
MEASURE length(seq)
power(seq,n):
Sec¸a˜o 2.10 • Reduc¸a˜o em paralelo 29
RECURSIVE finseq[T] = IF n=0 THEN empty_seq
ELSE seq o power(seq,n-1)
ENDIF MEASURE n
index(seq,x): RECURSIVE nat =
IF seq‘length=0 THEN 0
ELSIF x = seq‘seq(0)
THEN 0
ELSE 1+index(rest(seq),x)
ENDIF MEASURE(seq‘length)
choose_seq(seq:PP, seq1:PP, (seq2 | seq1‘length=seq2‘length)):
RECURSIVE finseq[T] =
IF length(seq1)=0 THEN empty_seq
ELSIF mem_seq(seq1(0),seq)
THEN add_first(seq2(0),choose_seq(seq,rest(seq1),rest(seq2)))
ELSE choose_seq(seq,rest(seq1),rest(seq2))
ENDIF
MEASURE(length(seq1))
Temos o predicado mem seq, que e´ aplicado a um objeto x de tipo T e uma sequeˆncia
seq, julgando se x ocorre em seq. A func¸a˜o power toma a sequeˆncia seq e a replica n
vezes. Ja´ o algoritmo seq2set toma a sequeˆncia finita seq e a leva no conjunto formado
pelos seus argumentos. O recurso index e´ utilizado para extrair o primeiro ı´ndice da
sequeˆncia seq onde ocorre o elemento x. Por outro lado, se x na˜o ocorre em seq, enta˜o
index(seq,x)=length(seq), que na˜o e´ um ı´ndice de seq.
A func¸a˜o choose seq por sua vez, toma duas sequeˆncias finitas de posic¸o˜es paralelas
seq e seq1, ale´m de outra sequeˆncia seq2 com elementos de tipo T que tenha o
mesmo comprimento de seq1. Da´ı, choose seq retorna como sa´ıda uma sequeˆncia cujos
argumentos ocorrem em seq2 com os mesmos ı´ndices dos argumentos de seq1 que ocorrem
em seq, ou seja, verifica-se se cada termo de seq1 ocorre em seq e, quando isso acontecer,
selecionamos o elemento de seq2 com ı´ndice correspondente a` posic¸a˜o em seq1. E´
interessante perceber que choose seq preserva ordem e, se seq for uma subsequeˆncia
de seq1, tambe´m preserva comprimento de seq.
2.10 Reduc¸a˜o em paralelo
replace_par_pos(s,(fsp:SPP(s)),fse|fse‘length=fsp‘length,fss|fss‘length=fsp‘length):
RECURSIVE term =
IF length(fsp) = 0
THEN s
Sec¸a˜o 2.11 • Comparadores de sequeˆncias de posic¸o˜es 30
ELSE replace_par_pos(replaceTerm(s,ext(fss(0))(rhs(fse(0))),fsp(0)),
rest(fsp),rest(fse),rest(fss))
ENDIF
MEASURE length(fsp)
parallel_reduction?(E)(s,t): bool =
EXISTS (fsp: SPP(s),fse|(FORALL(i:below[fse‘length]):member(fse‘seq(i),E)),fss):
fsp‘length = fse‘length AND fsp‘length = fss‘length
AND (FORALL (i:below[fsp‘length]):subtermOF(s,fsp(i))=ext(fss(i))(lhs(fse(i))))
AND t=replace_par_pos(s,fsp,fse,fss)
Esta aplicac¸a˜o replace par pos faz algo parecido com replaceTerm, mas a ac¸a˜o se
realiza em va´rias posic¸o˜es paralelas do mesmo termo e de uma forma mais espec´ıfica.
Nesse caso, temos uma sequeˆncia fsp de posic¸o˜es paralelas de s, uma de regras de
reescrita fse e uma de substituic¸o˜es fss, sendo que as treˆs teˆm o mesmo comprimento.
Assim, replace par pos troca o subtermo de s em cada posic¸a˜o de fsp pelo termo que
fica do lado direito de cada regra em fse instanciado com as substituic¸o˜es de fss. As
trocas comec¸am pelo primeiro argumento de cada uma das sequeˆncias e o passo recursivo
continua trabalhando com o rest. Todo esse trabalho e´ feito para construir a reduc¸a˜o
em paralelo que vimos na sec¸a˜o 1.2.3. Aqui, ela se chamara´ parallel reduction?. O
sistema E e os termos relacionados s e t sa˜o dados, enquanto que parallel reduction?
deduz a existeˆncia das sequeˆncias de posic¸o˜es, de regras e de substituic¸o˜es tais que o lado
esquerdo das regras ocorram em s nas posic¸o˜es correspondentes descritas pela sequeˆncia
de posic¸o˜es sendo instanciado pelas respectivas substituic¸o˜es, e o termo t seja fruto de
aplicarmos replace par pos a s com essas treˆs sequeˆncias.
2.11 Comparadores de sequeˆncias de posic¸o˜es
Ainda que estejamos sempre tratando de sequeˆncias de posic¸o˜es paralelas, quando
tomamos duas dessas sequeˆncias, na˜o temos mais a garantia de que as posic¸o˜es
permanecem paralelas. Da´ı, podemos particionar as posic¸o˜es de uma dada sequeˆncia
em relac¸a˜o a outra de acordo com as seguintes aplicac¸o˜es:
sub_pos((fsp : PP), p):
RECURSIVE finseq[position] =
IF length(fsp) = 0 THEN empty_seq[position]
ELSIF p <= fsp(0) AND p /= fsp(0)
THEN add_first(fsp(0), sub_pos(rest(fsp), p))
ELSE sub_pos(rest(fsp), p)
ENDIF
MEASURE length(fsp)
Sec¸a˜o 2.11 • Comparadores de sequeˆncias de posic¸o˜es 31
Pos_Over((fsp1 : PP), (fsp2 : PP)):
RECURSIVE finseq[position] =
IF length(fsp1) = 0
THEN empty_seq
ELSIF length(sub_pos(fsp2, fsp1(0))) > 0
OR PP?(add_first(fsp1(0), fsp2))
THEN add_first(fsp1(0), Pos_Over(rest(fsp1), fsp2))
ELSE Pos_Over(rest(fsp1), fsp2)
ENDIF
MEASURE length(fsp1)
Pos_Under((fsp1 : PP), (fsp2 : PP)):
RECURSIVE finseq[position] =
IF length(fsp2)=0
THEN empty_seq
ELSE sub_pos(fsp1, fsp2(0)) o Pos_Under(fsp1,rest(fsp2))
ENDIF
MEASURE length(fsp2)
Pos_Equal((fsp1 : PP), (fsp2 : PP)):
RECURSIVE finseq[position] =
IF length(fsp1) = 0 THEN empty_seq
ELSIF mem_seq(fsp1(0),fsp2)
THEN add_first(fsp1(0),Pos_Equal(rest(fsp1),fsp2))
ELSE Pos_Equal(rest(fsp1), fsp2)
ENDIF
MEASURE length(fsp1)
Cada um desses quatro construtores nos da˜o como produto sequeˆncias de posic¸o˜es
paralelas. Para a func¸a˜o sub pos, temos como argumentos uma posic¸a˜o p e uma sequeˆncia
de posic¸o˜es paralelas fsp; para as outras treˆs, temos duas sequeˆncias de posic¸o˜es paralelas
fsp1 e fsp2 em cada uma. A aplicac¸a˜o sub pos constro´i uma sequeˆncia com as posic¸o˜es
de fsp que estejam por baixo de p, ou seja, tais que p lhes seja prefixo sem coincidir. A
partir dela, as func¸o˜es Pos Over e Pos Under comparam as posic¸o˜es das sequeˆncias fsp1
e fsp2. No caso de Pos Over, seleciona-se as posic¸o˜es de fsp1 tais que sejam paralelas a
todas as posic¸o˜es de fsp2 ou que a sequeˆncia formada pelo sub pos dessas posic¸o˜es em
fsp1 sobre fsp2 na˜o seja vazia, isto e´, as que estejam por cima de alguma posic¸a˜o de
fsp2. Por outro lado, Pos Under seleciona as posic¸o˜es de fsp1 que estejam por baixo de
cada posic¸a˜o de fsp2. Por fim, temos a aplicac¸a˜o Pos Equal que seleciona as posic¸o˜es de
fsp1 que ocorram em fsp2.
Sec¸a˜o 2.12 • Sequeˆncias de varia´veis 32
2.12 Sequeˆncias de varia´veis
Se no´s temos duas regras num sistema na˜o amb´ıguo cujo lado esquerdo esta˜o em
posic¸o˜es na˜o paralelas, no´s sabemos da existeˆncia de uma varia´vel que se interpo˜e da
forma que sera´ apresentada aqui.
Pore´m, mais do que isso, no´s temos duas sequeˆncias de regras. Ha´ a possibilidade
de que o lado esquerdo de va´rias regras ocorram no lado esquerdo de outra. Assim,
precisamos organizar as muitas varia´veis, fruto das muitas sobreposic¸o˜es, em uma
sequeˆncia. As quatro aplicac¸o˜es a seguir nos ajudara˜o nisso.
set_var(sigma,e,t): set[(V)] =
{x:(V)| subterm(t,sigma(x)) AND Vars(lhs(e))(x)}
seq_var(E:Orthogonal,s,(p:positions?(s)),sigma,
(e|member(e,E) & subtermOF(s,p)=ext(sigma)(lhs(e))),
(fsp:SPP(s)|(FORALL(i:below[fsp‘length]):p<=fsp‘seq(i))),
fse|fsp‘length=fse‘length & (FORALL (i:below[length(fse)]) :
member(fse(i),E)), fss|fsp‘length=fss‘length &
(FORALL (i:below[length(fss)]) :
subtermOF(s,fsp‘seq(i))=ext(fss‘seq(i))(lhs(fse‘seq(i))))):
RECURSIVE finseq[(V)] =
IF length(fsp)=0 THEN empty_seq
ELSIF nonempty?(set_var(sigma,e,ext(fss‘seq(0))(lhs(fse‘seq(0)))))
THEN add_first(choose(set_var(sigma,e,ext(fss‘seq(0))(lhs(fse‘seq(0))))),
seq_var(E,s,p,sigma,e,rest(fsp),rest(fse),rest(fss)))
ELSE seq_var(E,s,p,sigma,e,rest(fsp),rest(fse),rest(fss))
ENDIF
MEASURE(length(fsp))
O conjunto set var(sigma,e,t) conte´m as varia´veis tais que t seja um subtermo da
instanciac¸a˜o dessas varia´veis pela substituic¸a˜o sigma e tais que ocorram dentro do lado
esquerdo da regra e. Resumindo, caso o termo t seja subtermo de lhs(e), queremos
selecionar as varia´veis cuja instanciac¸a˜o por uma substituic¸a˜o predefinida esteja numa
posic¸a˜o intermedia´ria entre os dois termos. No nosso caso, como as regras trabalhadas
sa˜o lineares a` esquerda, se o conjunto formado for na˜o vazio, enta˜o sera´ unita´rio.
O conceito anterior e´ importante para trabalharmos a definic¸a˜o de seq var, que
e´ muito mais complexa e as condic¸o˜es sobre os argumentos esta˜o mais amarradas.
Primeiramente, consideremos cada entrada dessa func¸a˜o: um conjunto de regras
ortogonais E; um termo s; uma posic¸a˜o p de s; uma substituic¸a˜o sigma; uma regra
e∈E tal que o subtermo de s em p e´ a instaciac¸a˜o do lado esquerdo de e por sigma;
uma sequeˆncia fsp de posic¸o˜es paralelas de s, tais que as posic¸o˜es teˆm p como prefixo
Sec¸a˜o 2.12 • Sequeˆncias de varia´veis 33
(esta˜o por baixo de p); uma sequeˆncia fse de regras em E com o mesmo comprimento
de fsp; uma sequeˆncia fss de substituic¸o˜es com o mesmo comprimento de fsp tal que,
para cada ı´ndice da sequeˆncia, o subtermo de s na posic¸a˜o em fsp e´ uma instanciac¸a˜o
do lado esquerdo da regra em fse pela substituic¸a˜o em fss. A ideia desse construtor e´
a de que, para cada subtermo formado por fss e fse nas posic¸o˜es em fsp, toma-se uma
varia´vel tirada do conjunto set var com argumentos sigma, e e cada subtermo. Sabemos
que esses conjuntos sa˜o na˜o vazios, pois todas as regras tratadas pertencem ao sistema
na˜o amb´ıguo E. Por outro lado, a sequeˆncia seq var e´ unicamente determinada pois cada
um desses conjuntos e´ unita´rio, uma vez que a regra e e´ linear a` esquerda.
seq_var_par(E:Orthogonal,s,(p:positions?(s)),sigma,
(e|member(e,E) & subtermOF(s,p)=ext(sigma)(lhs(e))),
(fsp:SPP(s)|FORALL(i:below[fsp‘length]):p<=fsp‘seq(i)),
fse|fsp‘length=fse‘length & (FORALL (i:below[length(fse)]) :
member(fse(i),E)), fss|fsp‘length=fss‘length &
(FORALL (i:below[length(fss)]) :
subtermOF(s,fsp‘seq(i))=ext(fss‘seq(i))(lhs(fse‘seq(i))))):
RECURSIVE finseq[(V)] =
IF length(fsp)=0 THEN empty_seq
ELSIF (FORALL (i: below[length(fsp)]):
i/=0 & seq_var(E,s,p,sigma,e,fsp,fse,fss)‘seq(0)/=
seq_var(E,s,p,sigma,e,fsp,fse,fss)‘seq(i))
THEN add_first(seq_var(E,s,p,sigma,e,fsp,fse,fss)‘seq(0),
seq_var_par(E,s,p,sigma,e,rest(fsp),rest(fse),rest(fss)))
ELSE seq_var_par(E,s,p,sigma,e,rest(fsp),rest(fse),rest(fss))
ENDIF
MEASURE(length(fsp))
seq var par utiliza os mesmos argumentos que seq var e tera´ como resultado uma
sequeˆncia com as mesmas varia´veis que resultam da outra, diferindo pelo fato de eliminar
repetic¸o˜es de varia´veis.
SEQ_VAR_multi(E:Orthogonal,s,(fsp1:SPP(s)),fss1|fss1‘length=fsp1‘length,
(fse1|FORALL(i:below[fse1‘length]):member(fse1‘seq(i),E)
& subtermOF(s,fsp1‘seq(i))=ext(fss1‘seq(i))(lhs(fse1‘seq(i)))),
(fsp2:SPP(s)),fse2|fsp2‘length=fse2‘length &
(FORALL (i:below[length(fse2)]) :
member(fse2(i),E)), fss2|fsp2‘length=fss2‘length &
(FORALL (i:below[length(fss2)]) :
subtermOF(s,fsp2‘seq(i))=ext(fss2‘seq(i))(lhs(fse2‘seq(i))))):
RECURSIVE finseq[finseq[(V)]] =
IF length(fsp1)=0 THEN empty_seq
Sec¸a˜o 2.13 • Tratamento de sequeˆncias de posic¸o˜es 34
ELSE add_first(seq_var_par(E,s,fsp1‘seq(0),fss1‘seq(0),fse1‘seq(0),
sub_pos(fsp2,fsp1‘seq(0)),
choose_seq(sub_pos(fsp2,fsp1‘seq(0)),fsp2,fse2),
choose_seq(sub_pos(fsp2,fsp1‘seq(0)),fsp2,fss2)),
SEQ_VAR_multi(E,s,rest(fsp1),rest(fss1),rest(fse1),
fsp2,fse2,fss2))
ENDIF
MEASURE(length(fsp1))
O algoritmo SEQ VAR multi cria uma sequeˆncia de sequeˆncias de varia´veis. Toma-
se o primeiro argumento das sequeˆncias fsp1 de posic¸o˜es, fss1 de substituic¸o˜es e fse1
de regras e aplica-se a seq var par (fsp1’seq(0) como a posic¸a˜o, fse1’seq(0) como a
regra e fss1’seq(0) como a substituic¸a˜o) de forma que se cumpram as condic¸o˜es exigidas
anteriormente. Para que a condic¸a˜o de subtermo seja cumprida tambe´m, como sequeˆncia
de posic¸o˜es a aplicar-se a seq var par, tomamos sub pos(fsp2,fsp1‘seq(0)) e, para
as sequeˆncias de regras e substituic¸o˜es, utilizamos choose seq para ajustar fse2 e fss2
a sub pos.
2.13 Tratamento de sequeˆncias de posic¸o˜es
Quando lidamos com duas reduc¸o˜es em paralelo sobre o mesmo termo, formando uma
divergeˆncia, algumas posic¸o˜es de uma das sequeˆncias de posic¸o˜es podem estar por baixo
de posic¸o˜es da outra sequeˆncia. Como em cada posic¸a˜o, no´s temos um termo que faz
matching com o lado esquerdo de uma regra dentro de um sistema ortogonal, mesmo
que instanciado por uma substituic¸a˜o, pela sec¸a˜o anterior sabemos que existem varia´veis
que se interpo˜em se estiverem em posic¸o˜es na˜o paralelas. No entanto, apo´s a reescrita, as
varia´veis podem assumir diferentes posic¸o˜es no lado direito da regra que a conte´m. Assim,
os subtermos das varia´veis tambe´m se deslocara˜o.
Os pro´ximos construtores tratam as posic¸o˜es dessas sequeˆncias desmembrando as
posic¸o˜es de varia´veis e concatenando com as novas no lado direito das regras. Vejamos
como isso acontece passo a passo.
complement_pos_set(p1,p): set[position] =
IF p1 <= p & p1 /= p
THEN {p2 | p=p1 o p2}
ELSE emptyset
ENDIF
complement_pos(p,(fsp:PP)):
RECURSIVE finseq[position] =
IF length(fsp)=0 THEN empty_seq
Sec¸a˜o 2.13 • Tratamento de sequeˆncias de posic¸o˜es 35
ELSIF nonempty?(complement_pos_set(p,fsp‘seq(0)))
THEN add_first(choose(complement_pos_set(p,fsp‘seq(0))),
complement_pos(p,rest(fsp)))
ELSE complement_pos(p,rest(fsp))
ENDIF
MEASURE(length(fsp))
Temos aqui o conjunto complement pos set(p1,p), que seleciona o complemento de
p1 ate´ p, caso p1 seja prefixo de p e as duas posic¸o˜es na˜o coincidam. Obviamente, se estas
duas condic¸o˜es sa˜o atendidas, o conjunto sera´ unita´rio; caso contra´rio, sera´ vazio. Ja´ a
sequeˆncia complement pos(p,fsp) e´ formada pelo complemento das posic¸o˜es de fsp em
relac¸a˜o a p, caso eles existam. Assim, complement pos e´ o nosso instrumento para cortar
posic¸o˜es.
compo_pos(p,(fsp:PP)): RECURSIVE finseq[position] =
IF length(fsp)=0 THEN empty_seq
ELSE add_first(p o fsp‘seq(0),compo_pos(p,rest(fsp)))
ENDIF
MEASURE(length(fsp))
compo_pos_multi(fsp1,fsp2:PP): RECURSIVE finseq[position] =
IF length(fsp1)=0 THEN empty_seq
ELSE compo_pos(fsp1‘seq(0),fsp2) o
compo_pos_multi(rest(fsp1),fsp2)
ENDIF
MEASURE(length(fsp1))
compo pos fara´ o contra´rio, concatenando a posic¸a˜o p a cada uma em fsp. Esse
procedimento e´ repetidamente realizado em compo pos multi, que concatena cada posic¸a˜o
de fsp1 a todas as posic¸o˜es de fsp2.
compo_pos_var(s,t,fsv,p,(fsp:PP)): RECURSIVE finseq[position] =
IF length(fsv)=0 THEN empty_seq
ELSIF nonempty?(Pos_var(s,fsv‘seq(0)))
THEN compo_pos(p,compo_pos_multi(set2seq(Pos_var(t,fsv‘seq(0))),
complement_pos(choose(Pos_var(s,fsv‘seq(0))),
complement_pos(p,fsp)))) o
compo_pos_var(s,t,rest(fsv),p,fsp)
ELSE compo_pos_var(s,t,rest(fsv),p,fsp)
ENDIF
MEASURE(length(fsv))
Sec¸a˜o 2.13 • Tratamento de sequeˆncias de posic¸o˜es 36
Compo_pos_var(fst1:finseq[term],(fst2:finseq[term]|fst1‘length=fst2‘length),
FSV:finseq[finseq[(V)]]|fst1‘length=FSV‘length,
fsp1:PP|fsp1‘length=fst1‘length,
(fsp2:PP)):
RECURSIVE finseq[position] =
IF length(fsp1)=0 THEN empty_seq
ELSE add_first(compo_pos_var(fst1‘seq(0),fst2‘seq(0),FSV‘seq(0),
fsp1‘seq(0),fsp2),
Compo_pos_var(rest(fst1),rest(fst2),rest(FSV),
rest(fsp1),rest(fsp2)))
ENDIF
MEASURE(length(fsp1))
Nesse momento, os dois tipos de operac¸o˜es sa˜o realizadas: o corte e a composic¸a˜o de
posic¸o˜es. Para cada varia´vel na sequeˆncia fsv, caso esta ocorra no termo s, a func¸a˜o
compo pos var toma o complemento de uma posic¸a˜o da varia´vel em s ate´ o complemento
de p a uma sequeˆncia de posic¸o˜es paralelas fsp. Teremos em ma˜os o complemento das
posic¸o˜es de fsp dentro da varia´vel. Depois disso, concatenaremos essas posic¸o˜es curtas a`s
posic¸o˜es da varia´vel no outro termo t e, por fim, compomos com a posic¸a˜o p novamente.
compo_rr_var(s,t,fsv,p,(fsp:PP),fse|length(fsp)=length(fse)):
RECURSIVE finseq[rewrite_rule] =
IF length(fsv)=0 THEN empty_seq
ELSIF nonempty?(Pos_var(s,fsv‘seq(0)))
THEN power(choose_seq(sub_pos(fsp,
compo_pos(p,set2seq(Pos_var(s,fsv‘seq(0))))‘seq(0)),
fsp,fse),
card(Pos_var(t,fsv‘seq(0))))
o compo_rr_var(s,t,rest(fsv),p,fsp,fse)
ELSE compo_rr_var(s,t,rest(fsv),p,fsp,fse)
ENDIF
MEASURE(length(fsv))
compo_Sub_var(s,t,fsv,p,(fsp:PP),fss|length(fsp)=length(fss)):
RECURSIVE finseq[Sub] =
IF length(fsv)=0 THEN empty_seq
ELSIF nonempty?(Pos_var(s,fsv‘seq(0)))
THEN power(choose_seq(sub_pos(fsp,
compo_pos(p,set2seq(Pos_var(s,fsv‘seq(0))))‘seq(0)),
fsp,fss),
card(Pos_var(t,fsv‘seq(0))))
o compo_Sub_var(s,t,rest(fsv),p,fsp,fss)
Sec¸a˜o 2.13 • Tratamento de sequeˆncias de posic¸o˜es 37
ELSE compo_Sub_var(s,t,rest(fsv),p,fsp,fss)
ENDIF
MEASURE(length(fsv))
Quando no´s tomamos sequeˆncias de posic¸o˜es formadas por construtores como
Pos Over ou sub pos, que apenas selecionam posic¸o˜es espec´ıficas dentro das originais,
e´ fa´cil ajustar as sequeˆncias de substituic¸o˜es e regras que as acompanham atrave´s de
choose seq. Pore´m, isso na˜o vale para compo pos var, pois as posic¸o˜es na sequeˆncia
resultante sa˜o diferentes do que t´ınhamos nas originais. Assim, criamos as aplicac¸o˜es
compo rr var e compo sub var que fazem o ajuste necessa´rio para este tipo espec´ıfico
de sequeˆncia de posic¸o˜es, fazendo com que as sequeˆncias de regras e substituic¸o˜es criadas
pelos respectivos construtores acompanhem os ı´ndices da sequeˆncia de posic¸o˜es criada por
compo pos var.
No´s temos os mesmos argumentos de compo pos var acrescidos de uma sequeˆncia fse
de regras de reescrita para o caso de compo rr var e fss de substituic¸o˜es para o caso de
compo Sub var, em ambos os casos com o mesmo comprimento da sequeˆncia de posic¸o˜es
fsp.
No´s sabemos que complement pos(p,fsp) e sub pos(fsp,p) selecionam as mesmas
posic¸o˜es, com a diferenc¸a que o primeiro as quebra e o segundo na˜o. Isso fara´ toda
a diferenc¸a, pois usando sub pos, poderemos nos utilizar de choose seq pelos motivos
supra mencionados.
Para cada varia´vel em fsv, tomamos as subposic¸o˜es de fsp em relac¸a˜o a` uma
posic¸a˜o da varia´vel em s. Da´ı, ajustamos as regras/substituic¸o˜es que acompanham
essas subposic¸o˜es atrave´s de choose seq. Depois, no´s replicamos essa sequeˆncia de
regras/substituic¸o˜es pelo nu´mero de ocorreˆncia da varia´vel no termo t usando a aplicac¸a˜o
power.
Compo_rr_var(fst1,(fst2|fst1‘length=fst2‘length),
FSV|fst1‘length=FSV‘length,fsp1:PP|fsp1‘length=fst1‘length,
(fsp2:PP),fse|length(fsp2)=length(fse)):
RECURSIVE finseq[rewrite_rule] =
IF length(fsp1)=0 THEN empty_seq
ELSE compo_rr_var(fst1‘seq(0),fst2‘seq(0),
FSV‘seq(0),fsp1‘seq(0),fsp2,fse)
o Compo_rr_var(rest(fst1),rest(fst2),
rest(FSV),rest(fsp1),fsp2,fse)
ENDIF
MEASURE(length(fsp1))
Compo_Sub_var(fst1,(fst2|fst1‘length=fst2‘length),
Sec¸a˜o 2.14 • Sequeˆncias de termos 38
FSV|fst1‘length=FSV‘length,fsp1:PP|fsp1‘length=fst1‘length,
(fsp2:PP),fss|length(fsp2)=length(fss)):
RECURSIVE finseq[Sub] =
IF length(fsp1)=0 THEN empty_seq
ELSE compo_Sub_var(fst1‘seq(0),fst2‘seq(0),
FSV‘seq(0),fsp1‘seq(0),fsp2,fss)
o Compo_Sub_var(rest(fst1),rest(fst2),
rest(FSV),rest(fsp1),fsp2,fss)
ENDIF
MEASURE(length(fsp1))
As func¸o˜es Compo rr var e Compo Sub var fazem o mesmo que Compo pos var,
aplicando respectivamente compo rr var e compo Sub var, aos termos da sequeˆncia fst1
como primeiro termo, os da sequeˆncia fst2 como segundo termo e a cada sequeˆncia de
varia´veis dentro de FSV.
Pos_seq_var(s,fsv): RECURSIVE finseq[position]=
IF length(fsv)=0 THEN empty_seq
ELSE set2seq(Pos_var(s,fsv‘seq(0))) o
Pos_seq_var(s,rest(fsv))
ENDIF
MEASURE(length(fsv))
Durante a prova sera´ importante considerar as posic¸o˜es onde varia´veis ocorrem, na˜o
uma a uma (pois ja´ temos o recurso Pos var), mas de todas ao mesmo tempo. Para tanto,
temos Pos seq var(s, fsv), que nos da´ a sequeˆncia formada pelas posic¸o˜es onde cada
varia´vel da sequeˆncia fsv ocorre no termo s.
2.14 Sequeˆncias de termos
Ao longo da especificac¸a˜o no´s abordamos e ainda abordaremos sequeˆncias de termos
como argumento nas nossas func¸o˜es. No entanto, quando tratamos de reduc¸a˜o em paralelo,
as u´nicas sequeˆncias que surgem sa˜o as de posic¸o˜es, substituic¸o˜es e regras de reescrita.
Torna-se fundamental, enta˜o, construir tais sequeˆncias de termos para que as nossas
ferramentas criadas ate´ agora se tornem u´teis.
left_rewrite_rules(fse): RECURSIVE finseq[term]=
IF length(fse)=0 THEN empty_seq
ELSE add_first(lhs(fse‘seq(0)),left_rewrite_rules(rest(fse)))
ENDIF
MEASURE(length(fse))
Sec¸a˜o 2.15 • Sequeˆncias de substituic¸o˜es 39
right_rewrite_rules(fse): RECURSIVE finseq[term]=
IF length(fse)=0 THEN empty_seq
ELSE add_first(rhs(fse‘seq(0)),right_rewrite_rules(rest(fse)))
ENDIF
MEASURE(length(fse))
Subs_right_rr(fse,(fss|fse‘length=fss‘length)): RECURSIVE finseq[term]=
IF length(fse)=0 THEN empty_seq
ELSE add_first(ext(fss‘seq(0))(rhs(fse‘seq(0))),
Subs_right_rr(rest(fse),rest(fss)))
ENDIF
MEASURE(length(fse))
Os nossos construtores aqui sa˜o extremamente simples. O primeiro e´
left rewrite rules, que e´ aplicado a uma sequeˆncia de regras de reescrita e retorna
uma sequeˆncia com o termo do lado esquerdo de cada uma. Do mesmo modo,
right rewrite rules retorna o lado direito das regras. Ja´ a aplicac¸a˜o Subs right rr
e´ aplicado a duas sequeˆncias: uma de regras e outra de substituic¸o˜es, as duas com o
mesmo comprimento. Toma-se o termo do lado direito de cada regra e instancia-se com
a substituic¸a˜o correspondente.
2.15 Sequeˆncias de substituic¸o˜es
Quando no´s realizamos uma reduc¸a˜o em paralelo, existem sequeˆncias de posic¸o˜es,
regras e substituic¸o˜es associadas entre si. Mas, quando no´s consideramos duas reduc¸o˜es em
paralelo sobre o mesmo termo, pode existir a sobreposic¸a˜o das posic¸o˜es trabalhadas, sendo
que existem regras instanciadas cujo lado esquerdo esta´ dentro do lado esquerdo de uma
outra regra instanciada. Depois que a reescrita e´ feita nas subposic¸o˜es, e´ necessa´rio realizar
a reescrita sobre a regra que as conte´m (o termo maior). Todavia, a antiga substituic¸a˜o
que a instanciava antes na˜o serve mais, pois alguns subtermos foram modificados. Assim,
precisamos criar uma nova substituic¸a˜o que deˆ conta de criar o matching do termo maior
com o lado esquerdo da regra instanciada com essa substituic¸a˜o atualizada.
Vamos agora considerar como viabilizaremos isso.
replace_terms(s,fst,(fsp:SPP(s)|fsp‘length=fst‘length)): RECURSIVE term =
IF length(fst)=0 THEN s
ELSE replace_terms(replaceTerm(s,fst‘seq(0),fsp‘seq(0)),rest(fst),rest(fsp))
ENDIF
MEASURE(fst‘length)
Sec¸a˜o 2.15 • Sequeˆncias de substituic¸o˜es 40
SIGMA(sigma, x, fst, (fsp:SPP(sigma(x))|length(fsp)=length(fst)))(y:(V)):
term = IF length(fst)=0 OR y/=x
THEN sigma(y)
ELSE replace_terms(sigma(x),fst,fsp)
ENDIF
O recurso replace terms nos permite trocar todos os subtermos de s nas posic¸o˜es
paralelas em fsp pelos termos da sequeˆncia fst. A aplicac¸a˜o SIGMA utilizara´ o u´ltimo meio
de forma que, quando aplicamos SIGMA(sigma,x,fst,fsp) a uma varia´vel y, teremos a
mesma ac¸a˜o de sigma a menos que y seja igual a x. Nesse caso, trocamos todos os
subtermos de sigma(x) nas posic¸o˜es em fsp pelos termos em fst.
SIGMAP(sigma,fsv,(fsp1:PP|fsp1‘length=fsv‘length),
fst,(fsp2:PP|fsp2‘length=fst‘length))(y:(V)):
RECURSIVE term=
IF length(fsv)=0 THEN sigma(y)
ELSIF y=fsv‘seq(0) &
SP?(sigma(fsv‘seq(0)))(complement_pos(fsp1‘seq(0),fsp2))
THEN SIGMA(sigma,fsv‘seq(0),
choose_seq(sub_pos(fsp2,fsp1‘seq(0)),fsp2,fst),
complement_pos(fsp1‘seq(0),fsp2))(y)
ELSE SIGMAP(sigma,rest(fsv),rest(fsp1),fst,fsp2)(y)
ENDIF
MEASURE(length(fsv))
SIGMAP faz o trabalho de SIGMA em cada varia´vel da sequeˆncia fsv. Para ajustar as
condic¸o˜es sobre a sequeˆncia de posic¸o˜es para que estejam dentro da sigma-instanciac¸a˜o
de cada varia´vel, tomamos as posic¸o˜es de fsp2 que tenham complemento em relac¸a˜o a`s
posic¸o˜es em fsp1. A ideia e´ que cada entrada em fsp1 seja posic¸a˜o da varia´vel em um
termo maior. Por enquanto, essa situac¸a˜o na˜o esta´ expl´ıcita, mas quando estivermos
formalizando as provas, sera´ necessa´rio ter as condic¸o˜es requeridas nos argumentos de
SIGMA.
SIGMA_multi(fsp1:PP,(fss1|fsp1‘length=fss1‘length),
(FSV:finseq[finseq[(V)]]|fsp1‘length=FSV‘length &
FORALL(i:below[FSV‘length]):
FORALL(m,n:below[(FSV‘seq(i))‘length]):m/=n
IMPLIES (FSV‘seq(i))‘seq(m)/=(FSV‘seq(i))‘seq(n)),
(fse1|fsp1‘length=fse1‘length & (FORALL(i:below[fse1‘length]):
Pos_seq_var(lhs(fse1‘seq(i)),FSV‘seq(i))‘length=(FSV‘seq(i))‘length)),
Sec¸a˜o 2.15 • Sequeˆncias de substituic¸o˜es 41
fst,(fsp2:PP|fsp2‘length=fst‘length)):
RECURSIVE finseq[Sub]=
IF length(fsp1)=0 THEN empty_seq
ELSE add_first(SIGMAP(fss1‘seq(0),FSV‘seq(0),
Pos_seq_var(lhs(fse1‘seq(0)),FSV‘seq(0)),
choose_seq(sub_pos(fsp2,fsp1‘seq(0)),fsp2,fst),
complement_pos(fsp1‘seq(0),fsp2)),
SIGMA_multi(rest(fsp1),rest(fss1),
rest(FSV),rest(fse1),fst,fsp2))
ENDIF
MEASURE(length(fsp1))
Agora temos uma sequeˆncia de substituic¸o˜es criada por SIGMA multi. Esse construtor
ordenara´ a aplicac¸a˜o de SIGMAP sobre as substituic¸o˜es em fss1, as sequeˆncias de varia´veis
em FSV e as posic¸o˜es dessas sequeˆncias de varia´veis dentro do lado esquerdo de cada regra
em fse1.
Isso completa a nossa especificac¸a˜o das definic¸o˜es que sera˜o nossas ferramentas na
formalizac¸a˜o que desenvolveremos no pro´ximo cap´ıtulo.
Cap´ıtulo
3
Formalizac¸a˜o
O assistente de provas PVS pode ser utilizado atrave´s dos comandos de prova
apresentados na sec¸a˜o 1.1. Abre-se cada teorema num ambiente de demonstrac¸a˜o que
organiza as proposic¸o˜es como negativas quando as tomamos como premissas e positivas
quando sa˜o teses, da formada apresentada a seguir:
[-1] x=9
[-2] f(x,a) <= 0
[-3] ...
...
|-------
[1] 4 > 9
[2] f(9,a) = 0
[3] ...
...
Como vimos anteriormente, assume-se a conjunc¸a˜o dos itens negativos e busca-se
provar a disjunc¸a˜o da parte positiva, ou seja, assumindo todas as premissas, precisa-se
provar alguma tese. Isso e´ obtido quando podemos aplicar uma regra axioma´tica, isto e´,
quando ocorre um dos cinco casos:
1. uma premissa coincide com uma tese.
Ex: [-2] x + 3 = 9
|---
[1] x = 6
2. uma premissa e´ obviamente falsa.
Ex: [-1] 0 > 3
3. as premissas se contradizem
Ex: [-1] a <= 8
Sec¸a˜o 3.1 • RTC(reduction?(E)) = RTC(parallel reduction?(E)) 43
[-2] a = b
[-3] b > 12
4. uma tese e´ obviamente verdadeira
Ex: [3] 12 <= 12
5. a unia˜o de duas ou mais teses englobam todas as possibilidades para um dado objeto
Ex: [1] n <= 1
[2] 2 <= n
Isso nos deixa prontos para falar a respeito da formalizac¸a˜o do teorema que mostra
que TRS’s ortogonais sa˜o confluentes. Aqui seguiremos a estrate´gia apresentada na sec¸a˜o
1.2.3. Como vimos, a ideia principal e´ provar a propriedade do diamante para a reduc¸a˜o
em paralelo (parallel reduction?(E)) para um sistema ortogonal. Como a conflueˆncia
e´ inferida da propriedade diamante, provando a equivaleˆncia entre o fecho reflexivo
transitivo da reduc¸a˜o em paralelo e da reduc¸a˜o usual, temos a prova que procura´vamos.
3.1 RTC(reduction?(E)) = RTC(parallel reduction?(E))
Para demonstrar a enquivaleˆncia entre as relac¸o˜es RTC(reduction?(E)) e
RTC(parallel reduction?(E), vamos demonstrar primeiramente as incluso˜es de
reduction?(E) em parallel reduction?(E) e desta em RTC(reduction?(E)). Isso e´
expressado pelo lema abaixo, que diz que, para quaisquer dois termos t1 e t2 valem as
incluso˜es mencionadas.
parallel_reduction: LEMMA
(reduction?(E)(t1, t2) => parallel_reduction?(E)(t1, t2))
& (parallel_reduction?(E)(t1, t2) => RTC(reduction?(E))(t1, t2))
A prova quebra-se em duas partes atrave´s do comando split para que se prove cada
uma das incluso˜es. A primeira e´ mais tranquila de ser provada, como veremos. De fato,
no´s temos:
parallel_reduction.1 :
{-1} reduction?(E)(t1, t2)
|-------
{1} parallel_reduction?(E)(t1, t2)
Sec¸a˜o 3.1 • RTC(reduction?(E)) = RTC(parallel reduction?(E)) 44
Expandindo-se a definic¸a˜o de reduction?(E) com o comando expand no´s inferimos a
existeˆncia de uma posic¸a˜o, uma regra e uma substituic¸a˜o com as quais se realiza a reduc¸a˜o
de t1 para t2. Por outro lado, ao expandirmos a definic¸a˜o de parallel reduction?(E),
precisamos fornecer uma sequeˆncia de posic¸o˜es, uma de regras e uma de substituic¸o˜es que
realizam a reduc¸a˜o dos mesmos termos. Enta˜o, no´s temos:
parallel_reduction.1 :
{-1} EXISTS ((e: rewrite_rule[variable, symbol, arity] | member(e, E)),
sigma: Sub[variable, symbol, arity],
(p: positions?[variable, symbol, arity](t1))):
subtermOF(t1, p) = ext(sigma)(lhs(e)) &
t2 = replaceTerm(t1, ext(sigma)(rhs(e)), p)
|-------
{1} EXISTS (fsp: SPP(t1),
fse: finseq[rewrite_rule]
| FORALL (i: below[fse‘length]): member(fse‘seq(i), E),
fss):
fsp‘length = fse‘length AND
fsp‘length = fss‘length AND
(FORALL (i: below[fsp‘length]):
subtermOF(t1,
finseq_appl[position[variable, symbol, arity]]
(fsp)(i))
=
ext(finseq_appl[Sub[variable, symbol, arity]](fss)(i))
(lhs(finseq_appl[rewrite_rule[variable, symbol, arity]]
(fse)(i))))
AND t2 = replace_par_pos(t1, fsp, fse, fss)
Depois aplicamos o comando skosimp que substitui as varia´veis quantificadas
existencialmente por constantes em {-1} com a regra e!1, a substituic¸a˜o sigma!1 e a
posic¸a˜o p!1. Da´ı podemos instanciar {1} com a sequeˆncia unita´ria de posic¸a˜o (# length
:= 1, seq := (LAMBDA (n: below[1]): p!1) #) (de comprimento 1 e termos iguais
a p!1), de regra (# length := 1, seq := (LAMBDA (n: below[1]): e!1) #) e de
substituic¸a˜o (# length := 1, seq := (LAMBDA (n: below[1]): sigma!1) #).
No entanto, ao instanciarmos com essas sequeˆncias, devemos estar certos de que elas
cumprem as condic¸o˜es para a reduc¸a˜o em paralelo. Da´ı a prova se divide em dois casos
o primeiro onde assumimos que a sequeˆncia unita´ria de posic¸a˜o e´ de posic¸o˜es paralelas
do termo t1 e o segundo onde provamos essa tal propriedade. No primeiro caso, temos a
seguinte situac¸a˜o:
Sec¸a˜o 3.1 • RTC(reduction?(E)) = RTC(parallel reduction?(E)) 45
parallel_reduction.1.1 :
[-1] subtermOF(t1, p!1) = ext(sigma!1)(lhs(e!1))
[-2] t2 = replaceTerm(t1, ext(sigma!1)(rhs(e!1)), p!1)
|-------
{1} (FORALL (i: below[1]):
subtermOF(t1,
finseq_appl[position[variable, symbol, arity]]
((# length := 1,
seq := (LAMBDA (n: below[1]): p!1) #))
(i))
=
ext(finseq_appl[Sub[variable, symbol, arity]]
((# length := 1,
seq := (LAMBDA (n: below[1]): sigma!1) #))
(i))
(lhs(finseq_appl[rewrite_rule[variable, symbol, arity]]
((# length := 1,
seq := (LAMBDA (n: below[1]): e!1) #))
(i))))
AND
t2 =
replace_par_pos(t1,
(# length := 1,
seq := (LAMBDA (n: below[1]): p!1) #),
(# length := 1,
seq := (LAMBDA (n: below[1]): e!1) #),
(# length := 1,
seq := (LAMBDA (n: below[1]): sigma!1) #))
Este caso se resolve trivialmente usando o comando grind, que substitui as varia´veis
quantificadas existencialmente por constantes e expande as definic¸o˜es necessa´rias. Da´ı,
ele se da´ conta que a u´nica posic¸a˜o a se considerar e´ p!1, a u´nica regra e´ e!1 e a
u´nica substituic¸a˜o e´ sigma!1, ale´m do fato que replace par pos equivale a replaceTerm
quando as sequeˆncias sa˜o unita´rias. Vamos ao segundo caso.
parallel_reduction.2 :
{-1} parallel_reduction?(E)(t1, t2)
|-------
{1} RTC(reduction?(E))(t1, t2)
Sec¸a˜o 3.1 • RTC(reduction?(E)) = RTC(parallel reduction?(E)) 46
Como parallel reduction? utiliza a aplicac¸a˜o replace par pos, que e´ constru´ıda
recursivamente sobre o comprimento de uma sequeˆncia fsp de posic¸o˜es, desejamos
fazer uma prova por induc¸a˜o sobre essa medida. No entanto, quando expandimos a
definic¸a˜o de parallel reduction? apresentada na Sec¸a˜o 2.10, fsp aparece quantificada
existencialmente. Isso nos impede de aplicarmos o me´todo de induc¸a˜o diretamente. Assim,
supomos uma proposic¸a˜o onde fsp aparece quantificada universalmente, a partir da qual
seja trivial obtermos a nossa prova. Assim, utilizamos o comando
(case "FORALL (t: term, fsp: SPP(t1), fse: finseq[rewrite_rule] |
(FORALL (i: below[fse‘length]): member(fse‘seq(i), E)),
fss: finseq[Sub]):
(fsp‘length = fse‘length & fsp‘length = fss‘length &
(FORALL (i: below[fsp‘length]): positionsOF(t)(fsp‘seq(i))
& subtermOF(t1, fsp‘seq(i))
= ext(fss‘seq(i))(lhs(fse‘seq(i)))
& subtermOF(t, fsp‘seq(i))
= ext(fss‘seq(i))(lhs(fse‘seq(i)))) &
t2 = replace_par_pos(t, fsp, fse, fss))
=> RTC(reduction?(E))(t, t2)")
De fato, quando expandimos a definic¸a˜o de parallel reduction?, supo˜e-se a
existeˆncia de sequeˆncias de posic¸o˜es, regras e substituic¸o˜es que cumprem as hipo´teses
do caso acima. Enta˜o, skolemizamos essa definic¸a˜o com as sequeˆncias fsp!1, fse!1 e
fss!1 e podemos instanciar o caso quantificado universalmente com o termo t1 e as
sequeˆncias obtidas. Da´ı, obtemos o resultado trivialmente, pois a tese do caso e´ igual a`
tese do sequente (RTC(reduction?(E))(t, t2)).
Por outro lado, temos o caso quantificado universalmente como tese. Assim, podemos
aplicar induc¸a˜o sobre o comprimento da sequeˆncia fsp de posic¸o˜es atrave´s do comando
(measure-induct+ "fsp‘length" "fsp"), que skolemiza a sequeˆncia com o nome x!1.
Primeiramente, supomos o caso em que o comprimento de x!1 e´ igual a zero e escondemos
as proposic¸o˜es desnecessa´rias aqui.
parallel_reduction.2.2.1.1 :
[-1] length(x!1) = 0
[-2] x!1‘length = fse!1‘length
[-3] x!1‘length = fss!1‘length
[-4] t2 = replace_par_pos(t!1, x!1, fse!1, fss!1)
|-------
[1] RTC(reduction?(E))(t!1, t2)
Sec¸a˜o 3.1 • RTC(reduction?(E)) = RTC(parallel reduction?(E)) 47
Expandindo a definic¸a˜o de replace par pos, temos que t2 = t!1. Por outro lado,
expandindo RTC, precisamos mostrar que existe um nu´mero de iterac¸o˜es de reduction?(E)
em que t!1 atinge t2. Isso e´ trivial, pois t!1 atinge t2 em 0 passos.
Agora, temos o oposto: a sequeˆncia x!1 de posic¸o˜es na˜o tem comprimento zero. O
objetivo e´ provar que a propriedade vale para x!1 supondo que a propriedade vale para
uma sequeˆncia com comprimento menor que o de x!1.
parallel_reduction.2.2.1.2 :
[-1] FORALL (y: SPP[variable, symbol, arity](t1)):
FORALL (t: term,
fse: finseq[rewrite_rule]
| (FORALL (i: below[fse‘length]):
member(fse‘seq(i), E)),
fss: finseq[Sub]):
y‘length < x!1‘length IMPLIES
(y‘length = fse‘length &
y‘length = fss‘length &
(FORALL (i: below[y‘length]):
positionsOF(t)(y‘seq(i)) &
subtermOF(t1, y‘seq(i)) =
ext(fss‘seq(i))(lhs(fse‘seq(i)))
&
subtermOF(t, y‘seq(i)) =
ext(fss‘seq(i))(lhs(fse‘seq(i))))
& t2 = replace_par_pos(t, y, fse, fss))
=> RTC(reduction?(E))(t, t2)
[-2] x!1‘length = fse!1‘length
[-3] x!1‘length = fss!1‘length
[-4] FORALL (i: below[x!1‘length]):
positionsOF(t!1)(x!1‘seq(i)) &
subtermOF(t1, x!1‘seq(i)) = ext(fss!1‘seq(i))(lhs(fse!1‘seq(i))) &
subtermOF(t!1, x!1‘seq(i)) = ext(fss!1‘seq(i))(lhs(fse!1‘seq(i)))
[-5] t2 = replace_par_pos(t!1, x!1, fse!1, fss!1)
|-------
[1] length(x!1) = 0
[2] RTC(reduction?(E))(t!1, t2)
Enta˜o, instanciamos [-1] com rest(x!1), replaceTerm(t!1, ext(fss!1‘seq(0))
(rhs(fse!1‘seq(0))), x!1‘seq(0)), rest(fse!1) e rest(fss!1) e aplicamos o
comando (prop) que quebrara´ a prova em va´rios casos, sendo o primeiro supondo a tese
Sec¸a˜o 3.1 • RTC(reduction?(E)) = RTC(parallel reduction?(E)) 48
RTC(reduction?(E))(replaceTerm(t!1, ext(fss!1‘seq(0)) (rhs(fse!1‘seq(0))),
x!1‘seq(0)), t2) e os outros sa˜o as premissas da proposic¸a˜o [-1]. As
propriedades principais que precisamos provar e´ que a composic¸a˜o reduction?(E) o
RTC(reduction?(E)) e´ igual a RTC(reduction?(E)) e que replaceTerm comuta com
replace par pos desde que as posic¸o˜es de trocas sejam paralelas.
Enta˜o, no´s concluimos a prova anterior e partimos para a pro´xima, que e´ provar a
equivaleˆncia propriamente dita entre os fechos reflexivo transitivos de reduction?(E!1)
e de parallel reduction?(E!1).
parallel_reduction_RTC :
|-------
{1} RTC(reduction?(E!1)) = RTC(parallel_reduction?(E!1))
Para provarmos essa equivaleˆncia, na verdade precisamos mostrar que ela vale para
qualquer par de termos. Assim, no´s podemos introduzir um par de termos arbitra´rios
para que se possa provar a igualdade atrave´s do comando (decompose-equality).
Da´ı, ter´ıamos a igualdade de proposic¸o˜es RTC(reduction?(E!1))(x!1, x!2) =
RTC(parallel reduction?(E!1))(x!1, x!2), que quer dizer que uma so´ acontece se,
e somente se, a outra acontece. Enta˜o, podemos transformar a igualdade no conectivo
lo´gico IFF atrave´s do comando (iff). Depois disso, podemos quebrar a prova em dois
casos principais com (split), demonstrando as duas implicac¸o˜es.
parallel_reduction_RTC.1 :
{-1} RTC(reduction?(E!1))(x!1, x!2)
|-------
{1} RTC(parallel_reduction?(E!1))(x!1, x!2)
Sabemos que RTC supo˜e a existeˆncia de um nu´mero de iterac¸o˜es da relac¸a˜o
correspondente em que o primeiro termo atinge o segundo. O nosso objetivo e´ fazer
uma prova indutiva, mas como no outro lema, a quantificac¸a˜o existencial nos impede de
assim o fazer. Logo, assumimos um caso onde o nu´mero de passos esteja quantificado
universalmente e pelo qual seja o´bvio atingir a nossa prova.
Nesse primeiro ramo, o caso assumido e´ (case
"FORALL (t1, t2: term, i: nat): iterate(reduction?(E!1), i)(t1, t2) =>
RTC(parallel reduction?(E!1))(t1, t2)"). Aplicamos, enta˜o, induc¸a˜o sobre i.
Sec¸a˜o 3.1 • RTC(reduction?(E)) = RTC(parallel reduction?(E)) 49
[-1] iterate(reduction?(E!1), 0)(t1, t2)
|-------
[1] RTC(parallel_reduction?(E!1))(t1, t2)
Na base de induc¸a˜o, no´s temos que provar que um termo t1 que atinge t2 em zero
passos de reduction?(E!1) deve atingir t2 tambe´m em algum nu´mero de passos de
parallel reduction?(E!1). Mas isso e´ fa´cil de provar pois [-1] mostra que t1 = t2 e,
assim, t1 atinge t2 em zero passos de parallel reduction?(E!1).
parallel_reduction_RTC.1.2.2 :
[-1] FORALL (t1, t2: term):
iterate(reduction?(E!1), j)(t1, t2) =>
RTC(parallel_reduction?(E!1))(t1, t2)
{-2} iterate(reduction?(E!1), j + 1)(t1, t2)
|-------
{1} RTC(parallel_reduction?(E!1))(t1, t2)
Assumimos que podemos atingir RTC(parallel reduction?(E!1)) com j iterac¸o˜es
de reduction?(E!1) e precisamos provar que o mesmo e´ conseguido com j + 1 passos.
Primeiramente, utilizamos o lema iterate add one que quebra a iterac¸a˜o de {-2} no
primeiro passo de reduction?(E!1) concatenado com os outros j passos da relac¸a˜o. Isso
significa que expusemos um termo y!1 na cadeia entre t1 e t2. Ale´m disso, agora podemos
utilizar a hipo´tese de induc¸a˜o e temos RTC(parallel reduction?(E!1))(y!1, t2).
parallel_reduction_RTC.1.2.2 :
{-1} iterate(reduction?(E!1), j)(y!1, t2) =>
RTC(parallel_reduction?(E!1))(y!1, t2)
[-2] reduction?(E!1)(t1, y!1)
[-3] iterate(reduction?(E!1), j)(y!1, t2)
|-------
[1] RTC(parallel_reduction?(E!1))(t1, t2)
No entanto, ainda na˜o temos a propriedade para o par de termos (t1, t2). O que
no´s podemos fazer e´ utilizar o lema parallel reduction, que provamos anteriormente,
e obter parallel reduction?(E!1)(t1, y!1)) de {-2}. Da´ı, utilizamos outro lema da
biblioteca ars que mostra que um passo de uma relac¸a˜o composto com RTC da relac¸a˜o
equivale ao RTC da relac¸a˜o.
Sec¸a˜o 3.2 • Orthogonal implies confluent 50
Por outro lado, ao provar RTC(parallel reduction?(E!1))(x!1, x!2) IMPLIES
RTC(reduction?(E!1))(x!1, x!2), nos utilizamos da mesma estrate´gia de supor um
caso onde o nu´mero de iterac¸o˜es de parallel reduction?(E!1) aparece instanciado
universalmente. Usamos esse caso para fechar esse ramo da prova, mas temos de provar
que ele e´ verdadeiro. Para tanto, aplicamos induc¸a˜o sobre esse nu´mero de iterac¸o˜es e
obtemos o seguinte sequente:
parallel_reduction_RTC.2.2.2 :
[-1] FORALL (t1, t2: term):
iterate(parallel_reduction?(E!1), j)(t1, t2) =>
RTC(reduction?(E!1))(t1, t2)
{-2} iterate(parallel_reduction?(E!1), j + 1)(t1, t2)
|-------
{1} RTC(reduction?(E!1))(t1, t2)
Novamente, no´s podemos explicitar o termo intermedia´rio y!1 que ocorre na cadeia
de reduc¸o˜es entre os termos t1 e t2. Assim, utilizando o lema iterate add one
como no primeiro ramo da prova, no´s obtemos parallel reduction?(E!1)(t1, y!1)
e iterate(parallel reduction?(E!1), j)(y!1, t2). Atrave´s do lema anterior,
sabemos que RTC(reduction?(E!1))(t1, y!1). Ale´m disso, utilizando a hipo´tese de
induc¸a˜o em [-1], sabemos que RTC(reduction?(E!1))(y!1, t2). Finalmente, pela
transitividade de RTC(reduction?(E!1)), conclu´ımos que RTC(reduction?(E!1))(t1,
t2).
Dessa forma, alcanc¸amos o resultado que espera´vamos de equivaleˆncia entre o fecho
reflexivo transitivo das duas relac¸o˜es.
3.2 Orthogonal implies confluent
Na verdade, esse teorema e´ um corola´rio dos dois lemas anteriores e de um terceiro
cuja prova sera´ mostrada posteriormente (a reduc¸a˜o em paralelo tem a propriedade do
diamante).
A prova segue como no teorema 1.2.3.
Orthogonal_implies_confluent: LEMMA
FORALL (E : Orthogonal) :
LET RRE = reduction?(E) IN
confluent?(RRE)
Sec¸a˜o 3.3 • parallel reduction is DP 51
De fato, expandindo a definic¸a˜o de confluent?, no´s temos que provar o seguinte
sequente:
Orthogonal_implies_confluent :
[-1] RTC(reduction?(E!1))(x, y)
[-2] RTC(reduction?(E!1))(x, z)
|-------
{1} EXISTS (z_1: term[variable, symbol, arity]): RTC(reduction?(E!1))(y, z_1)
& RTC(reduction?(E!1))(z, z_1)
No´s usamos o lema parallel reduction RTC e obtemos que RTC(reduction?(E!1))
= RTC(parallel reduction?(E!1)). Da´ı, provar a existeˆncia de tal termo z 1 para a
relac¸a˜o reduction?(E!1) equivale a prova´-la para parallel reduction?(E!1).
No´s invocamos o lema parallel reduction is DP em
que a relac¸a˜o parallel reduction?(E!1) tem a propriedade do diamante sempre que
E!1 for ortogonal.
No arcabouc¸o encontrado em [1], ja´ t´ınhamos os resultados DP implies StC
e Strong Confl implies Confl, ou seja, a propriedade do diamante implica em
parallel reduction?(E!1) fortemente confluente e isso implica em conflueˆncia, como
quer´ıamos.
Orthogonal_implies_confluent :
{-1} RTC(parallel_reduction?(E!1))(y, z!1)
{-2} RTC(parallel_reduction?(E!1))(z, z!1)
[-3] strong_confluent?(parallel_reduction?(E!1))
[-4] diamond_property?(parallel_reduction?(E!1))
[-5] RTC(reduction?(E!1)) = RTC(parallel_reduction?(E!1))
[-6] RTC(reduction?(E!1))(x, y)
[-7] RTC(reduction?(E!1))(x, z)
|-------
[1] RTC(reduction?(E!1))(y, z!1) & RTC(reduction?(E!1))(z, z!1)
Expandindo a definic¸a˜o de conflueˆncia novamente, encontramos um termo z!1 para o
qual vale a propriedade e encerramos a prova com o comando (assert).
3.3 parallel reduction is DP
Se no´s desejamos provar que a reduc¸a˜o em paralelo tem a propriedade diamante,
como vimos na sec¸a˜o 1.2.1, precisamos mostrar que, para uma dada divergeˆncia
Sec¸a˜o 3.3 • parallel reduction is DP 52
parallel reduction?(E)(s,t1) & parallel reduction?(E)(s,t2), onde s, t1 e
t2 sa˜o termos, existe um termo u tal que parallel reduction?(E)(t1,u) &
parallel reduction?(E)(t2,u). Da´ı, para provar que, de fato, a reduc¸a˜o em paralelo
acontece, devemos fornecer sequeˆncias de posic¸o˜es, de regras e de substituic¸o˜es tais como
na sec¸a˜o 2.10.
O teorema 1.2.4 mostra qual a estrutura desse termo u. Ou seja, ao final, precisamos
apresentar um termo em que todos os triaˆngulos coloridos vazados foram trocados por
triaˆngulos preenchidos.
As sequeˆncias fsp!1, fse!1 e fss!1 de posic¸o˜es, regras e substituic¸o˜es que aparecem
a seguir sa˜o referentes a` reduc¸a˜o de s a t1. Da mesma forma, fsp!2, fse!2 e fss!2 sa˜o
as sequeˆncias da reduc¸a˜o de s a t2. O termo a seguir e´ o que no´s buscamos.
replace_par_pos(t1, Pos_Over(fsp!2,fsp!1) o
Compo_pos_var(left_rewrite_rules(choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fse!1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fse!1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp!1,fsp!2),
choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fss!1),
choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fse!1),
fsp!2,fse!2,fss!2),
Pos_Over(fsp!1,fsp!2),fsp!2),
choose_seq(Pos_Over(fsp!2,fsp!1),fsp!2,fse!2)
o Compo_rr_var(left_rewrite_rules(choose_seq(Pos_Over(fsp!1,fsp!2),
fsp!1,fse!1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp!1,fsp!2),
fsp!1,fse!1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp!1,fsp!2),
choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fss!1),
choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fse!1),
fsp!2,fse!2,fss!2),
Pos_Over(fsp!1,fsp!2),fsp!2,fse!2),
SIGMA_multi(Pos_Over(fsp!2,fsp!1),
choose_seq(Pos_Over(fsp!2,fsp!1),fsp!2,fss!2),
SEQ_VAR_multi(E,s,Pos_Over(fsp!2,fsp!1),
choose_seq(Pos_Over(fsp!2,fsp!1),fsp!2,fss!2),
choose_seq(Pos_Over(fsp!2,fsp!1),fsp!2,fse!2),
fsp!1,fse!1,fss!1),
choose_seq(Pos_Over(fsp!2,fsp!1),fsp!2,fse!2),
Subs_right_rr(fse!1,fss!1),fsp!1)
o Compo_Sub_var(left_rewrite_rules(choose_seq(Pos_Over(fsp!1,fsp!2),
fsp!1,fse!1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp!1,fsp!2),
fsp!1,fse!1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp!1,fsp!2),
Sec¸a˜o 3.3 • parallel reduction is DP 53
choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fss!1),
choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fse!1),
fsp!2,fse!2,fss!2),
Pos_Over(fsp!1,fsp!2),fsp!2,fss!2))
O termo e´ constru´ıdo a partir da aplicac¸a˜o de replace par pos sobre o termo t1 e as
treˆs sequeˆncias de posic¸o˜es, de regras e de substituic¸o˜es.
Ao instanciarmos a prova com o termo acima algumas propriedades sobre essas
sequeˆncias devem ser demonstradas para que fechemos o resultado. Os ramos de prova sa˜o
automaticamente gerados pelo PVS ao fazer a instanciac¸a˜o. Algumas dessas propriedades
ja´ foram demonstradas em outros lemas e outras permanecem em aberto em conjecturas
separadas. Dos resultados em aberto, quase todos seguem o tipo de prova realizada em
resultados ja´ fechados. Apenas o u´ltimo resultado da Sec¸a˜o 3.3.2 devera´ ter um tratamento
diferenciado e tambe´m se desdobrara´ em alguns outros lemas.
3.3.1 Resultados demonstrados
Em relac¸a˜o a` aplicac¸a˜o choose seq, no´s precisamos provar a conservac¸a˜o do
comprimento das sequeˆncias e a preservac¸a˜o do ı´ndice. Abaixo no´s temos alguns
resultados, mas podemos considerar tambe´m as propriedades espelhadas, ou seja, trocar
fsp!1 por fsp!2, fse!1 por fse!2 e fss!1 por fss!2 e vice-versa. Precisamos considerar
tambe´m que Pos Over seleciona uma subsequeˆncia.
- Pos_Over(fsp!1, fsp!2)‘length =
choose_seq(Pos_Over(fsp!1, fsp!2), fsp!1, fse!1)‘length
- FORALL (i:below[choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fse!2)‘length]):
E(choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fse!2)‘seq(i))
- FORALL (i:below[choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fse!2)‘length]):
subtermOF(x, Pos_Over(fsp!2, fsp!1)‘seq(i)) =
ext(choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fss!2)‘seq(i))
(lhs(choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fse!2)‘seq(i)))
- FORALL (i: below[Pos_Over(fsp!1, fsp!2)‘length]):
mem_seq(Pos_Over(fsp!1, fsp!2)‘seq(i), fsp!1)
As aplicac¸o˜es SEQ VAR multi, SIGMA multi, left rewrite rules e Subs right rr
tambe´m preservam comprimento.
- Pos_Over(fsp!1, fsp!2)‘length
= SEQ_VAR_multi(E, s, Pos_Over(fsp!1, fsp!2),
choose_seq(Pos_Over(fsp!1, fsp!2), fsp!1, fss!1),
Sec¸a˜o 3.3 • parallel reduction is DP 54
choose_seq(Pos_Over(fsp!1, fsp!2), fsp!1, fse!1),
fsp!2, fse!2, fss!2)‘length
- Pos_Over(fsp!2, fsp!1)‘length
= SIGMA_multi(Pos_Over(fsp!2, fsp!1),
choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fss!2),
SEQ_VAR_multi(E, s, Pos_Over(fsp!2, fsp!1),
choose_seq(Pos_Over(fsp!2, fsp!1),fsp!2,fss!2),
choose_seq(Pos_Over(fsp!2, fsp!1),fsp!2,fse!2),
fsp!1, fse!1, fss!1),
choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fse!2),
Subs_right_rr(fse!1, fss!1), fsp!1)‘length
- Pos_Over(fsp!1, fsp!2)‘length =
left_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2), fsp!1, fse!1))‘length
- fsp!2‘length = Subs_right_rr(fse!2, fss!2)‘length
Ja´ o comprimento de Compo pos var e´ preservado por Compo rr var e Compo Sub var.
- Compo_pos_var(left_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1)),
SEQ_VAR_multi(E, s, Pos_Over(fsp!1, fsp!2),
choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fss!1),
choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1),
fsp!2, fse!2, fss!2),
Pos_Over(fsp!1, fsp!2), fsp!2)‘length =
Compo_rr_var(left_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1)),
SEQ_VAR_multi(E, s, Pos_Over(fsp!1, fsp!2),
choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fss!1),
choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1),
fsp!2, fse!2, fss!2),
Pos_Over(fsp!1, fsp!2), fsp!2, fse!2)‘length =
Compo_Sub_var(left_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1)),
SEQ_VAR_multi(E, s, Pos_Over(fsp!1, fsp!2),
choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fss!1),
choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1),
fsp!2, fse!2, fss!2),
Pos_Over(fsp!1, fsp!2), fsp!2, fss!2)‘length
Temos que Pos seq var conserva o comprimento de SEQ VAR multi. Isso quer dizer
muito, pois temos de usar a linearidade da regra da posic¸a˜o em Pos Over(fsp1,fsp2)
e a na˜o ambiguidade do sistema E, provando que set var (presente na definic¸a˜o de
SEQ VAR multi) e´ um conjunto unita´rio.
Sec¸a˜o 3.3 • parallel reduction is DP 55
- Pos_seq_var(lhs(choose_seq(Pos_Over(fsp1, fsp2), fsp1, fse1)‘seq(i)),
SEQ_VAR_multi(E, s, Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2, fse2, fss2)‘seq(i))‘length =
(SEQ_VAR_multi(E, s, Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fss1),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fse1),
fsp2, fse2, fss2)‘seq(i))‘length
Sabemos que as varia´veis que ocorrem em uma determinada sequeˆncia dentro de
SEQ VAR multi sa˜o todas diferentes. Isso e´ extremamente importante considerando a
definic¸a˜o de SIGMA multi na sec¸a˜o 2.15, que exige essa na˜o repetic¸a˜o de varia´veis na
sequeˆncia.
- (SEQ_VAR_multi(E, s, Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fss1),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fse1),
fsp2, fse2, fss2)‘seq(i))‘seq(m) /=
(SEQ_VAR_multi(E, s, Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fss1),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fse1),
fsp2, fse2, fss2)‘seq(i))‘seq(n)
Tambe´m destacamos que a func¸a˜o replace par pos, que realiza a reduc¸a˜o em paralelo
propriamente dita, possui uma independeˆncia na ordem em que se tomam as posic¸o˜es
a serem reduzidas. Pela definic¸a˜o, ela toma primeiramente a posic¸a˜o com ı´ndice 0. No
entanto, como podemos ver no resultado seguinte, caso fsp seja uma sequeˆncia de posic¸o˜es
paralelas, podemos tomar um outro ı´ndice n qualquer da sequeˆncia, continuar reduzindo
nas posic¸o˜es restantes e ainda assim obter o mesmo termo final.
- replace_par_pos(replaceTerm(s, ext(fss(n))(rhs(fse(n))), fsp(n)),
delete(fsp,n), delete(fse,n), delete(fss,n))
= replace_par_pos(s,fsp,fse,fss)
Esse u´ltimo lema e´ extremamente importante considerando que tomamos posic¸o˜es
espec´ıficas ao construir o termo de juntabilidade para o problema.
Sec¸a˜o 3.3 • parallel reduction is DP 56
3.3.2 Resultados axiomatizados
O primeiro resultado em aberto e´ que, nas posic¸o˜es em que fsp!2 esta´ por cima de
fsp!1, o subtermo de t1 e´ a mesma regra de fse!2 que se tinha originalmente instanciada
com a substituic¸a˜o atualizada por SIGMAP.
- subtermOF(t1, Pos_Over(fsp2,fsp1)‘seq(i)) =
ext(SIGMAP(choose_seq(Pos_Over(fsp2,fsp1),fsp2,fss2)‘seq(i),
seq_var_par(E, s, Pos_Over(fsp2,fsp1)‘seq(i),
choose_seq(Pos_Over(fsp2,fsp1),fsp2,fss2)‘seq(i),
choose_seq(Pos_Over(fsp2,fsp1),fsp2,fse2)‘seq(i),
sub_pos(fsp1,Pos_Over(fsp2,fsp1)‘seq(i)),
choose_seq(sub_pos(fsp1,Pos_Over(fsp2,fsp1)‘seq(i)),fsp1,fse1),
choose_seq(sub_pos(fsp1,Pos_Over(fsp2,fsp1)‘seq(i)),fsp1,fss1)),
Pos_seq_var(lhs(choose_seq(Pos_Over(fsp2,fsp1),fsp2,fse2)‘seq(i)),
seq_var_par(E,s,Pos_Over(fsp2,fsp1)‘seq(i),
choose_seq(Pos_Over(fsp2,fsp1),fsp2,fss2)‘seq(i),
choose_seq(Pos_Over(fsp2,fsp1),fsp2,fse2)‘seq(i),
sub_pos(fsp1,Pos_Over(fsp2,fsp1)‘seq(i)),
choose_seq(sub_pos(fsp1,Pos_Over(fsp2,fsp1)‘seq(i)),
fsp1,fse1),
choose_seq(sub_pos(fsp1,Pos_Over(fsp2,fsp1)‘seq(i)),
fsp1,fss1))),
choose_seq(sub_pos(fsp1,Pos_Over(fsp2,fsp1)‘seq(i)),
fsp1,Subs_right_rr(fse1, fss1)),
complement_pos(Pos_Over(fsp2,fsp1)‘seq(i), fsp1)))
(lhs(choose_seq(Pos_Over(fsp2,fsp1),fsp2,fse2)‘seq(i)))
Tomemos agora um subtermo numa posic¸a˜o em que fsp!1 esta´ por cima de fsp!2, ou
seja, e´ prefixo de alguma posic¸a˜o em fsp!2. Quando reduzimos s para t1, sabemos que
as regras de fse!2 instanciadas com fss!2 que esta˜o por baixo desse termo mudaram de
posic¸a˜o devido ao movimento das varia´veis durante a reescrita. Vimos que essas novas
posic¸o˜es sa˜o descritas por Compo pos var e as regras e substituic¸o˜es que a acompanham
por Compo rr var e Compo Sub var respectivamente. Precisamos provar que, de fato,
essas duas u´ltimas preservam o ı´ndice da primeira, mostrando que os subtermos de t1 nas
posic¸o˜es de Compo pos var sa˜o o lado esquerdo das regras em Compo rr var instanciadas
com Compo Sub var. Tambe´m devemos provar que as regras em Compo rr var continuam
sendo as regras do sistema ortogonal E.
- subtermOF(t1,Compo_pos_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),
fsp1,fse1)),
Sec¸a˜o 3.3 • parallel reduction is DP 57
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),
fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2), fsp2)‘seq(i)) =
ext(Compo_Sub_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2), fsp2, fss2)‘seq(i))
(lhs(Compo_rr_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),
fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),
fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2), fsp2, fse2)‘seq(i)))
- E(Compo_rr_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
SEQ_VAR_multi(E, s, Pos_Over(fsp1,fsp2),
choose_seq(Pos_Over(fsp1,fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1,fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1,fsp2),fsp2,fse2)‘seq(i))
A relac¸a˜o de paralelismo e´ mantida por Compo pos var. Pore´m, mais do que isso,
a composic¸a˜o desta sequeˆncia com Pos Over(fsp2, fsp1) permanece sendo de posic¸o˜es
paralelas do termo t1.
- SPP?(t1)(Pos_Over(fsp2, fsp1) o
Compo_pos_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2), fsp2))
Sec¸a˜o 3.3 • parallel reduction is DP 58
Outro resultado importante e´ provar que o construtor SIGMAP de fato define uma
substituic¸a˜o. Observando a ac¸a˜o dele e´ fa´cil ver que a sua ac¸a˜o se restringe a varia´veis,
pois ele toma como base uma outra substituic¸a˜o e modifica a ac¸a˜o sobre um nu´mero finito
de varia´veis espec´ıficas. Como podemos ver na sec¸a˜o 2.6, uma substituic¸a˜o deve ser uma
aplicac¸a˜o que leva varia´veis em termos e que tem o domı´nio finito. Assim, a afirmac¸a˜o
acima justifica esse resultado. Abaixo, no´s colocamos sigma, fsv, fsp1, fst e fsp2 como
argumentos arbitra´rios que satisfazem as condic¸o˜es na sec¸a˜o 2.15.
- Sub?(SIGMAP(sigma,fsv,fsp1,fst,fsp2))
Finalmente, precisamos provar que essas sequeˆncias de posic¸o˜es, regras e substituic¸o˜es
realmente levam t1 e t2 ao mesmo termo. Observemos abaixo que as sequeˆncias
responsa´veis por reescrever t2 sa˜o um espelho das sequeˆncias que reduzem t1, isto e´,
trocamos simplesmente fsp1 por fsp2, fse1 por fse2, fss1 por fss2 e vice-versa, como
falamos anteriormente.
- replace_par_pos(t1,
Pos_Over(fsp2, fsp1) o
Compo_pos_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2),fsp2),
choose_seq(Pos_Over(fsp2, fsp1), fsp2, fse2) o
Compo_rr_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2),fsp2,fse2),
SIGMA_multi(Pos_Over(fsp2, fsp1),choose_seq(Pos_Over(fsp2, fsp1),fsp2,fss2),
SEQ_VAR_multi(E,s,Pos_Over(fsp2, fsp1),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fss2),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2),
fsp1,fse1,fss1),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2),
Subs_right_rr(fse1, fss1), fsp1) o
Sec¸a˜o 3.3 • parallel reduction is DP 59
Compo_Sub_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2),fsp2,fss2)) =
replace_par_pos(t2, Pos_Over(fsp1, fsp2) o
Compo_pos_var(left_rewrite_rules(choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2)),
right_rewrite_rules(choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2)),
SEQ_VAR_multi(E,s,Pos_Over(fsp2, fsp1),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fss2),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2),
fsp1,fse1,fss1),
Pos_Over(fsp2, fsp1),fsp1),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fse1) o
Compo_rr_var(left_rewrite_rules(choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2)),
right_rewrite_rules(choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2)),
SEQ_VAR_multi(E,s,Pos_Over(fsp2, fsp1),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fss2),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2),
fsp1,fse1,fss1),
Pos_Over(fsp2, fsp1),fsp1,fse1),
SIGMA_multi(Pos_Over(fsp1, fsp2),choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
Subs_right_rr(fse2, fss2), fsp2) o
Compo_Sub_var(left_rewrite_rules(choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2)),
right_rewrite_rules(choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2)),
SEQ_VAR_multi(E,s,Pos_Over(fsp2, fsp1),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fss2),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2),
fsp1,fse1,fss1),
Pos_Over(fsp2, fsp1),fsp1,fss1))
O u´ltimo resultado da sec¸a˜o anterior sera´ fundamental na formalizac¸a˜o desta igualdade,
por ditar a independeˆncia da ordem das posic¸o˜es a serem reduzidas por replace par pos,
desde que sejam paralelas, o que e´ o nosso caso.
Cap´ıtulo
4
Conclusa˜o
4.1 Considerac¸o˜es Finais
Durante o desenvolvimento do presente trabalho, foi proposta a teoria orthogonality
como uma expansa˜o para a teoria trs, sendo esta u´ltima apresentada em [2, 6, 7] e
dispon´ıvel em [1]. Pode-se observar os passos de especificac¸a˜o e formalizac¸a˜o desenvolvidos
com o objetivo de provar o teorema de que TRS’s ortogonais teˆm a propriedade de
conflueˆncia.
No trabalho apresentado em [10], o crite´rio de ortogonalidade fraca e´ utilizado para
garatir conflueˆncia aplicando a ferramenta de certificac¸a˜o Certified Termination Analysis
(CeTA). Este crite´rio diz respeito a` ortogonalidade incluindo a possibilidade de pares
cr´ıticos triviais, ou seja, ha´ a sobreposic¸a˜o de regras, mas elas divergem para o mesmo
termo. Embora este resultado implique na conflueˆncia de sistemas ortogonais, o que foi
apresentado na˜o se trata de formalizac¸a˜o, mas de certificac¸a˜o. Ate´ onde se sabe na˜o
ha´ trabalhos apresentados que mencionem o objetivo de formalizar tal teorema em um
assistente de prova de ordem superior, o que e´ o nosso caso.
A especificac¸a˜o e formalizac¸a˜o constru´ıdas seguem a ideia proposta na prova anal´ıtica,
o que torna a prova bastante diagrama´tica. A estrate´gia de prova foi adotada visando
reduzir o problema da existeˆncia de um termo de juntabilidade para o Teorema 1.2.4
simplesmente para a verificac¸a˜o de propriedades sobre as func¸o˜es recursivas criadas na
Sec¸a˜o 2.2, o que gerou uma se´rie de resultados cujas provas sa˜o indutivas, sendo a maior
parte ja´ formalizada e algums lemas ainda permanecem axiomatizados, como mencionado
no final da sec¸a˜o anterior.
De fato, trabalhar com teoremas de existeˆncia indutivamente pode tornar-se
extremamente complicado uma vez que a hipo´tese de induc¸a˜o nos da´ um termo de
juntabilidade cujas peculiaridades de comprimento das sequeˆncias necessa´rias (posic¸o˜es,
regras e substituic¸o˜es) e da localizac¸a˜o das posic¸o˜es reduzidas sa˜o desconhecidas e na˜o
Sec¸a˜o 4.1 • Considerac¸o˜es Finais 61
conseguimos proceder ao passo indutivo por esse caminho diretamente. Por isso, optamos
por descrever exatamente o termo de juntabilidade do lema parallel reduction is DP
conforme apresentado na Sec¸a˜o 3.3. Na˜o queremos dizer que a abordagem indutiva
diretamente dentro dessa prova principal na˜o seja uma opc¸a˜o, mas exige um estudo
diferenciado para que o passo indutivo possa ser efetivado.
Poˆde-se experimentar va´rias estrate´gias de prova como, por exemplo, por induc¸a˜o
sobre a medida de sequeˆncias, por absurdo, definicionais e outras. Obteve-se a construc¸a˜o
de va´rios conceitos na˜o triviais, ale´m da formalizac¸a˜o de lemas sobre eles. Houve
tambe´m a boa integrac¸a˜o entre a teoria principal orthogonality e as subteorias com
tipos polimo´rficos que nos da˜o as ferramentas chose seq, power, seq2set e mem seq,
amplamente utilizadas. Isso pode ser afirmado uma vez que a grande maioria das
definic¸o˜es que utilizam os conceitos das subteorias importadas tiveram as obrigac¸o˜es de
prova geradas pelo PVS formalizadas, excluindo unicamente a prova de que o construtor
SIGMAP da Sec¸a˜o 2.15 gera, de fato, uma substituic¸a˜o, o que ja´ discutimos ser verdade
quando estudamos o domı´nio da func¸a˜o gerada.
Um enfraquecimento do teorema principal foi realizado acrescentando a hipo´tese de
linearidade a` direita, o que significa que na˜o ambiguidade e linearidade (tanto a` direita
quanto a` esquerda) geram um TRS confluente. A prova fora mais simples e foi um bom
objeto de estudo para nos familiarizarmos com a demonstrac¸a˜o do teorema de conflueˆncia
dos sistemas ortogonais. Este resultado fora formalizado completamente em 2010 e foi
apresentado em [9].
Atualmente o desenvolvimento completo consiste em 40 definic¸o˜es, 84 lemas
formalizados e 8 axiomas distribu´ıdos em cerca 1300 linhas de especificac¸a˜o e,
adicionalmente, 46000 linhas de provas. Dos 8 axiomas assumidos, 7 devem ser lemas
fechados com uma relativa facilidade devido a` semelhanc¸a semaˆntica com outros resultados
ja´ demonstrados. A prova do u´ltimo resultado apresentado na Sec¸a˜o 3, que trata da
equivaleˆncia da ac¸a˜o da func¸a˜o replace par pos atrave´s de dois conjuntos de argumentos
espec´ıficos, e´ o nosso objetivo mais desafiador e ainda deve se desdobrar em alguns outros
lemas intermedia´rios.
O PVS, sendo um assistente de prova com lo´gica de ordem superior, foi a ferramenta
escolhida por tratar esses resultados sobre relac¸o˜es de reescrita quaisquer de um modo
natural, lidando assim com objetos de segunda ordem. Isso implica consequentemente que
o PVS da´ um bom suporte para tratar corretude, completude e restric¸o˜es de integridade
das especificac¸o˜es de objetos computacionais especificados atrave´s de regras de reescrita.
Dos lemas formalizados, destacamos treˆs resultados importantes dentro da teoria
orthogonality:
• primeiramente, provamos a equivaleˆncia entre o fecho reflexivo transitivo da reescrita
usual e o da reescrita em paralelo. Isso foi realizado provando a inclusa˜o da
Sec¸a˜o 4.2 • Sugesto˜es para Pesquisas Futuras 62
reescrita usual na reescrita em paralelo, o que e´ trivial, e da reescrita em paralelo
no fecho reflexivo transitivo da reescrita usual, fazendo uma prova indutiva sobre o
comprimento da sequeˆncia de posic¸o˜es responsa´vel pela reescrita em paralelo.
• demonstrou-se tambe´m a propriedade do diamante para a reescrita em paralelo
num TRSs ortogonal. Esse resultado necessitou de uma se´rie de lemas auxiliares
te´cnicos para mostrar que o termo de juntabilidade fornecido atende a`s condic¸o˜es
necessa´rias. Todo o ferramental utilizado esta´ descrito na Sec¸a˜o 2.2, e as principais
condic¸o˜es exigidas na prova esta˜o na Sec¸a˜o 3.3. Alguns dos lemas auxiliares foram
axiomatizados. Citamos, por exemplo, que necessita-se mostrar que as aplicac¸o˜es
compo pos var, compo rr var e compo Sub var preservam ordem entre si. No
entanto, a maior parte dos lemas foi formalizada como, por exemplo, a preservac¸a˜o
de comprimento e ordem por choose seq e a independeˆncia da ordem de reduc¸a˜o
por replace par pos.
• por u´ltimo, reuniram-se dois lemas da teoria ars aos dois itens anteriores para
mostrar que ortogonalidade implica em conflueˆncia. Sabe-se que a propriedade do
diamante acarreta na propriedade Church-Rosser, que e´ equivalente a` conflueˆncia.
Assim, mostramos que a reescrita em paralelo e´ confluente a partir do item anterior
e isso e´ igual a` conflueˆncia da reescrita usual, pelo primeiro item.
4.2 Sugesto˜es para Pesquisas Futuras
Para que o teorema de conflueˆncia para TRS’s ortogonais seja, de fato, certificado, e´
necessa´rio apresentar as demonstrac¸o˜es para os resultados axiomatizados. Assim, sugere-
se como trabalho futuro:
• a conclusa˜o da formalizac¸a˜o da forma como foi apresentada (demonstrac¸a˜o dos lemas
axiomatizados);
• o estudo de um caminho alternativo para tratar a prova de
parallel reduction is DP de forma indutiva diretamente;
• a formalizac¸a˜o de outras condic¸o˜es para conflueˆncia e/ou terminac¸a˜o no contexto
de TRS’s;
• partir para outros contextos computacionais importantes como a Teoria de Tipos e
realizar um trabalho semelhante a` das teorias trs e ars, que formam um arcabouc¸o
robusto para a formalizac¸a˜o de teoremas relevantes.
Refereˆncias Bibliogra´ficas
[1] Theory trs, (consulted January 2012): Available in the NASA LaRC PVS library,
http://shemesh.larc.nasa.gov/fm/ftp/larc/PVS-library/pvslib.html. 1, 19,
51, 60
[2] A. B. Avelar, F. L. C. de Moura, A. L. Galdino, and M. Ayala-Rinco´n, Verification
of the completeness of unification algorithms a` la robinson, WoLLIC 2010, 2010,
pp. 110–124. 1, 19, 60
[3] Franz Baader and Tobias Nipkow, Term rewriting and All That, Cambridge
University Press, 1998. 2, 13
[4] M. Bezem, J.W. Klop, and R. de Vrijer, Term rewriting systems by TeReSe,
Cambridge Tracts in Theoretical Computer Science, no. 55, Cambridge University
Press, 2003. 2, 13
[5] A. L. Galdino and M. Ayala-Rinco´n, A formalization of newman’s and yokouchi
lemmas in a higher-order language, Journal of Automated Reasonning 1 (2008),
no. 1, 39–50. 1, 2
[6] , A PVS theory for term rewriting systems, Electronic Notes in Theoretical
Computer Science 247 (2009), 67–83, Third Workshop on Logical and Semantic
Frameworks, with Applications - LSFA 2008. 1, 2, 19, 27, 60
[7] , A formalization of the Knut-Bendix(-Huet) critical pair theorem, Journal of
Automated Reasonning 45 (2010), no. 3, 301–325. 1, 19, 27, 60
[8] A.L. Galdino and M. Ayala-Rinco´n, A Theory for Abstract Rewriting Systems in
PVS, Proc. XXXIII CLEI, 2007, pp. 1–16. 2, 27
[9] A. C. R. Oliveira and M. Ayala-Rinco´n, On the formalization of confluence of
orthogonal rewriting systems in PVS, EBL 2011, 2011, p. 15. 1, 2, 61
REFEREˆNCIAS BIBLIOGRA´FICAS 64
[10] R. Thiemann, Certification of confluence proofs using CeTA, First International
Workshop on Confluence (IWC 2012), 2012, p. 45. 60
