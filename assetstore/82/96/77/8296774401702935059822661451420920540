Universidade de BrasÂ´Ä±lia
Instituto de CieË†ncias Exatas
Departamento de MatemaÂ´tica
FormalizacÂ¸aËœo da conflueË†ncia para
sistemas de reescrita ortogonais
por
Ana Cristina Rocha Oliveira
BrasÂ´Ä±lia
2012
Universidade de BrasÂ´Ä±lia
Instituto de CieË†ncias Exatas
Departamento de MatemaÂ´tica
FormalizacÂ¸aËœo da conflueË†ncia para
sistemas de reescrita ortogonais
por
Ana Cristina Rocha Oliveira âˆ—
DissertacÂ¸aËœo apresentada ao Departamento de MatemaÂ´tica da Universidade de BrasÂ´Ä±lia
como parte dos requisitos necessaÂ´rios para obtencÂ¸aËœo do grau de
MESTRE EM MATEMAÂ´TICA
agosto de 2012
ComissaËœo Examinadora:
Prof. Dr. Mauricio Ayala-RincoÂ´n - UnB - Orientador
Prof. Dr. AndreÂ´ Luiz Galdino - UFG - Membro
Prof. Dr. Edward Hermann Haeusler - PUC-Rio - Membro
âˆ—A autora foi bolsista do CNPq durante a elaboracÂ¸aËœo deste trabalho.
DedicatoÂ´ria
A Jesus
porque dele, por ele e para ele
saËœo todas as coisas.
GloÂ´ria, pois, a ele eternamente.
i
Agradecimentos
A Deus, primeiramente, por todas as portas abertas e consolo quando as coisas
pareciam nebulosas e difÂ´Ä±ceis de enfrentar.
Aos meus pais Francisco de Assis e Sebastiana e ao meu irmaËœo Bruno pelo carinho e
amor em qualquer situacÂ¸aËœo. VoceË†s foram meu grande exemplo de forcÂ¸a e disposicÂ¸aËœo em
fazer o melhor.
Ao meu marido e grande amor Ricardo pelo cuidado e palavras de incentivo, a quem
tambeÂ´m dispenso o meu cuidado e afeto eternamente.
Aos meus amigos e colegas de mestrado e graduacÂ¸aËœo Mayra, Gabriella, AristoÂ´teles,
Dhiego, AngeÂ´lica, GetuÂ´lio, JoaËœo Paulo, Robson e Linniker que me acompanharam sempre,
seja na hora dos passeios e diversaËœo, seja nas muitas horas de estudo para as provas de
qualificacÂ¸aËœo.
Aos meus amigos e colegas do Grupo de Teoria da ComputacÂ¸aËœo AndreÂ´ia, Thaynara,
Daniel e Kaliana por me receberem no grupo e darem todo o suporte necessaÂ´rio. Obrigada
pela amizade. AgradecÂ¸o especialmente a` AndreÂ´ia pela pacieË†ncia em sanar as minhas
muitas duÂ´vidas neste longo processo.
Ao meu querido orientador Mauricio, que suportou toda a minha temosia e orientou-
me por tantos anos com a perseverancÂ¸a de quem ensina a uma filha.
Aos membros da banca examinadora Edward Hermann Haeusler, FlaÂ´vio Leonardo
Cavalcanti de Moura e AndreÂ´ Luiz Galdino por aceitarem o convite de compor a banca,
aleÂ´m das crÂ´Ä±ticas e sugestoËœes que enriquecem este trabalho. AgradecÂ¸o particularmente ao
AndreÂ´, a quem recorri muitas vezes para sanar duÂ´vidas, pela prontidaËœo em me atender
sempre.
Ao professor Celius, pelas horas de boa conversa e incentivo, aleÂ´m da disposicÂ¸aËœo em
ajudar em qualquer dificuldade. VoceË† eÂ´ um grande amigo!
Aos funcionaÂ´rios do MAT pela gentileza e carinho dispensados. Obrigada
especialmente a` ClaÂ´udia e D. Irene pelas boas conversas no subsolo.
Ao CNPq pelo apoio financeiro.
Novamente, a Jesus, que eÂ´ o inÂ´Ä±cio e fim de todas as coisas. A minha vida e trabalho
saËœo teus, Senhor!
ii
Resumo
Ortogonalidade eÂ´ uma caracterÂ´Ä±stica da programacÂ¸aËœo que consiste, de uma maneira
sintaÂ´tica, em garantir o determinismo de especificacÂ¸oËœes funcionais. Essencialmente, a
ortogonalidade naËœo permite, por um lado, a ambiguidade inerente do naËœo determinismo,
isto eÂ´, a existeË†ncia de diferentes regras que especificam a mesma funcÂ¸aËœo e que podem ser
aplicadas simultaneamente (naËœo ambiguidade) e, por outro, tambeÂ´m proÂ´Ä±be a repeticÂ¸aËœo
de variaÂ´veis no lado esquerdo dessas regras (linearidade a` esquerda). Na teoria dos
Sistemas de Reescrita de Termos (TRSs), determinismo eÂ´ identificado pela renomada
propriedade de conflueË†ncia, que basicamente afirma que sempre que houver possibilidades
de simplificacÂ¸oËœes ou computacÂ¸oËœes diferentes de um termo, as respostas computadas
ou os termos reduzidos obtidos devem coincidir. Embora a prova seja tecnicamente
elaborada, conflueË†ncia eÂ´ bem conhecida como uma consequeË†ncia da ortogonalidade.
Dessa forma, ortogonalidade eÂ´ uma importante caracterÂ´Ä±stica matemaÂ´tica intrÂ´Ä±nseca a`
especificacÂ¸aËœo de funcÂ¸oËœes recursivas, sendo naturalmente aplicada em programacÂ¸aËœo e
especificacÂ¸aËœo funcionais. A comecÂ¸ar pela formalizacÂ¸aËœo da teoria de TRSs no assistente
de provas PVS, esse trabalho descreve como a conflueË†ncia de TRSs ortogonais estaÂ´ sendo
formalizada utilizando essa ferramenta. Progressos substanciais foram constatados nessa
pesquisa, obtendo-se ateÂ´ o presente momento formalizacÂ¸oËœes completas para propriedades
similares, poreÂ´m com restricÂ¸oËœes, tais como a formalizacÂ¸aËœo completa para a propriedade
de conflueË†ncia de TRSâ€™s naËœo ambÂ´Ä±guos e lineares (a` esquerda e a` direita).
Palavras-chave: TRS, ortogonalidade, conflueË†ncia, PVS, formalizacÂ¸aËœo.
iii
Abstract
Orthogonality is a discipline of programming that in a syntactic manner guarantees
determinism of functional specifications. Essentially, orthogonality avoids, on the one
side, the inherent ambiguity of non determinism, prohibiting the existence of different
rules that specify the same function and that may apply simultaneously (non-ambiguity),
and, on the other side, it eliminates the possibility of occurrence of repetitions of variables
in the left-hand side of these rules (left linearity). In the theory of term rewriting
systems (TRSs) determinism is captured by the well-known property of confluence, that
basically states that whenever different computations or simplifications from a term are
possible, the computed answers or the obtained reduced terms should coincide. Although
the proof is technically elaborated, confluence is well-known to be a consequence of
orthogonality. Thus, orthogonality is an important mathematical discipline intrinsic to the
specification of recursive functions that is naturally applied in functional programming and
specification. Starting from a formalization of the theory of TRSs in the proof assistant
PVS, this work describes how confluence of orthogonal TRSs is being formalized in this
proof assistant. Substantial progress has been done in this research, obtaining until now
complete formalizations for some similar, but restricted properties, such as a complete
formalization for the property of confluence of non ambiguous and (left and right) linear
TRSs.
Keywords: TRS, orthogonality, confluence, PVS, formalization.
iv
SumaÂ´rio
IntroducÂ¸aËœo 1
0.1 ConsideracÂ¸oËœes Preliminares . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
0.2 Objetivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
0.3 ContribuicÂ¸oËœes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
0.4 OrganizacÂ¸aËœo do Trabalho . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1 Fundamentos 4
1.1 CaÂ´lculo de Sequentes no PVS . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.1.1 Regras estruturais . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.1.2 Regra de Corte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.1.3 Axiomas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.1.4 Regras Condicionais . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.1.5 Regras de Igualdade . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.1.6 Regras de Extensionalidade . . . . . . . . . . . . . . . . . . . . . . 7
1.1.7 Regra de ApresentacÂ¸aËœo de Tipo . . . . . . . . . . . . . . . . . . . . 8
1.2 Teoria de Reescrita . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.2.1 Sistemas Abstratos de Reescrita . . . . . . . . . . . . . . . . . . . . 8
1.2.2 Sistema de Reescrita de Termos . . . . . . . . . . . . . . . . . . . . 9
1.2.3 Principais Teoremas . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2 EspecificacÂ¸aËœo 19
2.1 Sistemas Abstratos de Reescrita . . . . . . . . . . . . . . . . . . . . . . . . 19
2.2 Sistemas de Reescrita de Termos . . . . . . . . . . . . . . . . . . . . . . . 20
2.3 PosicÂ¸oËœes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.4 SequeË†ncias finitas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.5 Subtermos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.6 SubstituicÂ¸oËœes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.7 ReducÂ¸aËœo simples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
2.8 Ortogonalidade . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
2.9 DefinicÂ¸oËœes auxiliares . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
2.10 ReducÂ¸aËœo em paralelo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.11 Comparadores de sequeË†ncias de posicÂ¸oËœes . . . . . . . . . . . . . . . . . . . 30
2.12 SequeË†ncias de variaÂ´veis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2.13 Tratamento de sequeË†ncias de posicÂ¸oËœes . . . . . . . . . . . . . . . . . . . . . 34
2.14 SequeË†ncias de termos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
2.15 SequeË†ncias de substituicÂ¸oËœes . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
v
3 FormalizacÂ¸aËœo 42
3.1 RTC(reduction?(E)) = RTC(parallel reduction?(E)) . . . . . . . . . . . 43
3.2 Orthogonal implies confluent . . . . . . . . . . . . . . . . . . . . . . . 50
3.3 parallel reduction is DP . . . . . . . . . . . . . . . . . . . . . . . . . . 51
3.3.1 Resultados demonstrados . . . . . . . . . . . . . . . . . . . . . . . . 53
3.3.2 Resultados axiomatizados . . . . . . . . . . . . . . . . . . . . . . . 56
4 ConclusaËœo 60
4.1 ConsideracÂ¸oËœes Finais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
4.2 SugestoËœes para Pesquisas Futuras . . . . . . . . . . . . . . . . . . . . . . . 62
RefereË†ncias BibliograÂ´ficas 63
IntroducÂ¸aËœo
0.1 ConsideracÂ¸oËœes Preliminares
A programacÂ¸aËœo funcional, muito explorada no meio acadeË†mico, tem rompido fronteiras
e, atualmente, eÂ´ inclusive utilizada em sistemas comerciais. Nesse contexto, a reescrita
tambeÂ´m tem se estabelecido como efetivo modo de programar. Nos uÂ´ltimos anos, alguns
trabalhos relacionados a` formalizacÂ¸aËœo de vaÂ´rias propriedades de Sistemas de Reescrita
de Termos (TRSâ€™s) foram desenvolvidos em [2, 5â€“7] e disponibilizados em [1]. Esse tipo
de desenvolvimento, com natureza semelhante a` do trabalho que se segue, eÂ´ de grande
relevaË†ncia uma vez que garante caracterÂ´Ä±sticas importantes, desejaÂ´veis e nem sempre
oÂ´bvias a partir de outras que saËœo facilmente detectaÂ´veis computacionalmente.
Assim, o resultado que nos propusemos a formalizar eÂ´ o de que TRSâ€™s ortogonais
saËœo confluentes. Ortogonalidade diz respeito a programas cujas regras naËœo entram em
conflito, isto eÂ´, que naËœo se sobrepoËœem e tambeÂ´m tais que as premissas de cada regra de
reescrita saËœo lineares (naËœo haÂ´ repeticÂ¸aËœo de variaÂ´veis do lado esquerdo das regras). JaÂ´
a conflueË†ncia diz respeito a` independeË†ncia de caminhos tomados, sendo que, para cada
duas rotas divergentes, existem dois caminhos que levam a` computacÂ¸aËœo de um resultado
comum.
Portanto, assim como a terminacÂ¸aËœo eÂ´ uma caracterÂ´Ä±stica fundamental e muitas vezes
buscada por obrigar a existeË†ncia de formas normais (termos irredutÂ´Ä±veis dentro de um
programa), a conflueË†ncia eÂ´ desejada em muitos sistemas computacionais uma vez que
garante a unicidade de resposta, independentemente do caminho tomado dentro do
programa.
Ortogonalidade eÂ´ apenas uma das propriedades capazes de garantir conflueË†ncia.
Anteriormente, um dos resultados que nos propusemos a formalizar foi o de que TRSâ€™s
naËœo ambÂ´Ä±guos (sem sobreposicÂ¸aËœo de regras) e lineares (sem repeticÂ¸aËœo de variaÂ´veis tanto
a` direita quanto a` esquerda das regras) saËœo confluentes. Esse eÂ´ um enfraquecimento do
teorema que temos como objetivo e sua formalizacÂ¸aËœo jaÂ´ foi mencionada em [9] tendo sua
conclusaËœo ocorrida durante o tempo de decorreË†ncia do presente trabalho.
SecÂ¸aËœo 0.2 â€¢ Objetivo 2
O Lema de Newman eÂ´ outro resultado que garante conflueË†ncia, mostrando que
terminacÂ¸aËœo e conflueË†ncia local tambeÂ´m implicam em conflueË†ncia. A formalizacÂ¸aËœo deste
uÂ´ltimo lema estaÂ´ disponÂ´Ä±vel em [5] e depende exclusivamente da teoria ars, que trata
dos Sistemas Abstratos de Reescrita (ARSâ€™s). Lemas como esses envolvendo apenas
ARSâ€™s saËœo interessantes em formalizacÂ¸oËœes sobre TRSâ€™s pois eÂ´ muito mais simples provar
propriedades locais como conflueË†ncia local, conflueË†ncia forte e propriedade diamante do
que a conflueË†ncia. Isso ocorre devido ao tratamento da divergeË†ncia em um nuÂ´mero
qualquer de passos nesta uÂ´ltima propriedade, enquanto que naquelas treË†s primeiras
tratam-se divergeË†ncias em um uÂ´nico passo. Portanto, provando propriedades locais
obtemos a conflueË†ncia atraveÂ´s desse tipo de lema.
0.2 Objetivo
O objetivo principal do presente trabalho eÂ´ apresentar o que se tem desenvolvido
no sentido de formalizar o teorema de conflueË†ncia para TRSâ€™s ortogonais no assistente
de provas Prototype Verification System (PVS). Para tanto, mostraremos a prova
analÂ´Ä±tica do teorema principal apresentando os pontos chave da demonstracÂ¸aËœo e como
usamos esses pontos no sentido de especificar e formalizar o nosso resultado. TambeÂ´m
apresentaremos a formalizacÂ¸aËœo de alguns dos lemas auxiliares que foram usados no
caminho da demonstracÂ¸aËœo.
0.3 ContribuicÂ¸oËœes
A teoria orthogonality, criada para tratar a formalizacÂ¸aËœo do teorema sobre
conflueË†ncia de TRSâ€™s ortogonais, eÂ´ uma extensaËœo das teorias ars (em [8]) e trs (em [6]),
sendo os resultados destas teorias a base completa para o trabalho que fizemos. Esse
arcaboucÂ¸o constitui-se da formalizacÂ¸aËœo de questoËœes e propriedades apresentadas nos livros-
texto ( [3, 4]) envolvendo conflueË†ncia, noetherianidade e TRSâ€™s em geral.
Um resultado importante, que utilizou esse arcaboucÂ¸o sobre ARSâ€™s e TRSâ€™s no PVS,
foi o de que que TRSâ€™s naËœo ambÂ´Ä±guos e lineares saËœo confluentes, tratando-se de uma
formalizacÂ¸aËœo um pouco menos complexa do que a do teorema de conflueË†ncia para TRSâ€™s
ortogonais. Esse resultado foi apresentado em [9] com sua formalizacÂ¸aËœo completa desde
2010.
Para provar que ortogonalidade implica em conflueË†ncia foi necessaÂ´rio especificar
a reducÂ¸aËœo em paralelo (denota-se esta como â‡’ e a reducÂ¸aËœo simples como â†’) e
demonstraram-se alguns lemas importantes sobre â‡’ como, por exemplo:
1. â†’âŠ†â‡’;
2. â‡’âŠ†â†’âˆ—, onde â†’âˆ— eÂ´ o fecho reflexivo-transitivo da relacÂ¸aËœo;
SecÂ¸aËœo 0.4 â€¢ OrganizacÂ¸aËœo do Trabalho 3
3. â‡’âˆ—=â†’âˆ—;
4. â‡’ tem a propriedade diamante, o que implica que tambeÂ´m eÂ´ confluente;
5. finalmente, â†’ eÂ´ confluente.
Para provar os itens 2 e 3, utilizamos muito do que jaÂ´ tÂ´Ä±nhamos da teoria sobre TRSâ€™s
e foi necessaÂ´rio criar vaÂ´rios outros lemas teÂ´cnicos jaÂ´ que â‡’ ainda naËœo havia sido tratada
pela teoria trs.
Logo, destacamos que as principais contribuicÂ¸oËœes deste trabalho saËœo as formalizacÂ¸oËœes
em PVS do lema de conflueË†ncia para TRSâ€™s naËœo ambÂ´Ä±guos e lineares, do teorema de
conflueË†ncia de TRSâ€™s ortogonais e dos lemas auxiliares utilizados. TambeÂ´m destacamos a
descricÂ¸aËœo construtiva do termo de juntabilidade necessaÂ´rio a` prova, como veremos.
0.4 OrganizacÂ¸aËœo do Trabalho
ComecÂ¸aremos o trabalho mencionando as principais regras do caÂ´lculo de sequentes
dentro da Teoria de Prova, o qual eÂ´ base para o assistente de prova PVS. Em seguida,
estaremos a par das definicÂ¸oËœes necessaÂ´rias ao entendimento da Teoria de Reescrita
considerada aqui, levando-se em conta propriedades dos Sistemas Abstratos de Reescrita
e, mais especificamente, dos Sistemas de Reescrita de Termos. Tendo bem conhecidos
os conceitos utilizados, demonstraremos analiticamente os resultados chave. Por fim,
entraremos na parte voltada ao desenvolvimento da teoria no assistente de prova PVS,
tratando primeiramente da especificacÂ¸aËœo e, em seguida, da formalizacÂ¸aËœo e meÂ´todos
utilizados.
CapÂ´Ä±tulo
1
Fundamentos
A intencÂ¸aËœo deste capÂ´Ä±tulo eÂ´ apresentar os conceitos, as principais demonstracÂ¸oËœes
analÂ´Ä±ticas e os mecanismos de prova utilizados durante a formalizacÂ¸aËœo do teorema de
conflueË†ncia de Sistemas de Reescrita de Termos (TRSâ€™s) ortogonais.
1.1 CaÂ´lculo de Sequentes no PVS
O caÂ´lculo de sequentes foi proposto na deÂ´cada de 30 por Gentzen dentro da Teoria
de Prova com o objetivo de provar a consisteË†ncia da aritmeÂ´tica de Peano, uma vez que
enfrentava dificuldades com o meÂ´todo de deducÂ¸aËœo natural (tambeÂ´m desenvolvido por
Gentzen). Esse caÂ´lculo eÂ´ utilizado na construcÂ¸aËœo de provas e, apesar de ser pouco natural,
torna as demonstracÂ¸oËœes mais simples tecnicamente.
Um sequente eÂ´ uma estrutura da forma Î£ `Î“ Î›, onde Î£ eÂ´ o conjunto de foÂ´rmulas
antecedentes, Î› eÂ´ o conjunto de foÂ´rmulas consequentes e Î“ eÂ´ o contexto. NoÂ´s assumimos
a conjuncÂ¸aËœo das foÂ´rmulas em Î£, implicando na disjuncÂ¸aËœo das foÂ´rmulas em Î›.
Para construir provas, noÂ´s utilizamos as regras de infereË†ncia, sendo o nosso objetivo
encontrar sequentes onde eÂ´ possÂ´Ä±vel aplicar as regras axiomaÂ´ticas que trataremos a seguir.
A forma de apresentacÂ¸aËœo das regras eÂ´
premissa
conclusaËœo
nome da regra
Neste trabalho, as formalizacÂ¸oËœes foram todas feitas no Prototype Verification System
(PVS), um assistente de prova semiautomaÂ´tico que permite especificar teorias e
demonstrar teoremas. O PVS estaÂ´ baseado numa loÂ´gica de ordem superior, isto eÂ´, que
possibilita que funcÂ¸oËœes sejam aplicadas a indivÂ´Ä±duos tanto quanto a funcÂ¸oËœes, levando-se em
conta determinadas restricÂ¸oËœes para que naËœo haja contradicÂ¸oËœes. A semaË†ntica da loÂ´gica de
ordem superior eÂ´ dada pelo mapeamento de tipos bem formados da loÂ´gica em conjuntos
e de termos bem formados da loÂ´gica em elementos dos conjuntos representantes dos seus
SecÂ¸aËœo 1.1 â€¢ CaÂ´lculo de Sequentes no PVS 5
tipos.
No PVS, abre-se cada teorema num ambiente de demonstracÂ¸aËœo que organiza as
proposicÂ¸oËœes como negativas quando as tomamos como premissas e positivas quando saËœo
teses. Assim, os sequentes no PVS saËœo apresentados da seguinte forma:
[-1] p1
[-2] p2
[-3] p3
...
|-------
[1] t1
[2] t2
[3] t3
...
Dessa forma, assume-se a conjuncÂ¸aËœo dos itens negativos e busca-se provar a disjuncÂ¸aËœo
da parte positiva, ou seja, assumindo todas as premissas, precisa-se provar alguma tese.
A seguir, noÂ´s mostraremos algumas regras de infereË†ncia do caÂ´lculo de sequentes e sua
correspondeË†ncia com os comandos de prova de PVS. EÂ´ importante ressaltar que o caÂ´lculo
de sequentes sofreu alteracÂ¸oËœes desde a sua concepcÂ¸aËœo por Gentzen. Os sequentes em PVS
seraËœo mais explorados posteriormente no CapÂ´Ä±tulo 3, onde seraËœo mostrados alguns passos
da formalizacÂ¸aËœo.
1.1.1 Regras estruturais
As regras estruturais permitem ao sequente ser rearranjado ou enfraquecido pela
introducÂ¸aËœo de novas foÂ´rmulas tanto em meio a`s antecedentes quanto nas consequentes. A
primeira regra eÂ´ a de enfraquecimento e as outras saËœo, de certa forma, casos particulares
dessa.
Î£1 `Î“ Î›1
Î£2 `Î“ Î›2 W se Î£1 âŠ† Î£2 e Î›1 âŠ† Î›2
Isso significa que, se conseguimos provar alguma foÂ´rmula em Î›1 atraveÂ´s das foÂ´rmulas
em Î£1, continuaremos provando com Î›2 e Î£2 devido a`s inclusoËœes.
No entanto, o comando de prova do PVS correspondente eÂ´ o (hide), que esconde as
foÂ´rmulas desnecessaÂ´rias para a prova. Assim, conseguindo uma prova de um sequente
mais forte, o mais fraco seraÂ´ trivial e teremos a prova do nosso objetivo inicial. Dessa
forma, todos os comando do PVS trabalharaËœo no sentido de baixo para cima em relacÂ¸aËœo
a essas regras de infereË†ncia, com o objetivo de alcancÂ¸ar axiomas.
As regras de contracÂ¸aËœo (C) e de comutatividade (X) saËœo casos particulares do
enfraquecimento, pois vale a relacÂ¸aËœo de inclusaËœo requerida no caso anterior.
SecÂ¸aËœo 1.1 â€¢ CaÂ´lculo de Sequentes no PVS 6
a, a,Î£ `Î“ Î›
a,Î£ `Î“ Î› C
Î£ `Î“ a, a,Î›
Î£ `Î“ a,Î› C
O comando de prova correspondente a C eÂ´ (copy).
Î£1, b, a,Î£2 `Î“ Î›
Î£1, a, b,Î£2 `Î“ Î› X
Î£ `Î“ Î›1, b, a,Î›2
Î£ `Î“ Î›1, a, b,Î›2 X
Por outro lado, a regra de troca de ordem das proposicÂ¸oËœes (X) naËœo foi utilizada em
PVS durante a elaboracÂ¸aËœo da formalizacÂ¸aËœo.
1.1.2 Regra de Corte
A regra de corte representa no PVS a consideracÂ¸aËœo de um caso atraveÂ´s do comando
(case). A prova se divide em duas partes em que uma foÂ´rmula a eÂ´ introduzida em meio
a`s antecedentes e, na outra, nas consequentes o que quer dizer que podemos considerar a
desde que provemos a. Outra forma de ver eÂ´ que vale a ou Â¬a.
(Ï„(Î“)(a) âˆ¼ bool)Î“ Î£, a `Î“ Î› Î£ `Î“ a,Î›
Î£ `Î“ Î› Cut
1.1.3 Axiomas
A regra axiomaÂ´tica (Ax) faz com que o programa se deË† conta de que a segue de a.
Assim, com o comando (assert), conseguimos fechar um ramo de prova do PVS.
Î£, a `Î“ a,Î› Ax
Outras duas regras axiomaÂ´ticas do caÂ´lculo de sequentes saËœo FALSE`, em que alguma
foÂ´rmula antecedente eÂ´ falsa, e `TRUE, em que uma foÂ´rmula consequente eÂ´ verdadeira.
Î£, FALSE `Î“ Î› FALSE` Î£ `Î“ TRUE,Î› `TRUE
1.1.4 Regras Condicionais
Como trabalhou-se com vaÂ´rias definicÂ¸oËœes recursivas (veremos isso mais a` frente), eÂ´
interessante verificar a regra que controla a eliminacÂ¸aËœo de IF-THEN-ELSE em uma prova.
Consideremos IF(a, b, c) como sendo IF a THEN b ELSE c. EntaËœo, utilizando comandos
como (prop), podemos dividir a prova nos casos em que vale a (com valor booleano) e
em que naËœo vale a.
Î£, a, b `Î“,a Î› Î£, c `Î“,Â¬a a,Î›
Î£, IF(a, b, c) `Î“ Î› IF`
Î£, a `Î“,a b,Î› Î£ `Î“,Â¬a a, c,Î›
Î£ `Î“ IF(a, b, c),Î› `IF
Caso os valores de a, b e c naËœo sejam booleanos, noÂ´s podemos aplicar o comando
(lift-if) para que IF-THEN-ELSE seja colocado mais exteriormente na foÂ´rmula.
SecÂ¸aËœo 1.1 â€¢ CaÂ´lculo de Sequentes no PVS 7
1.1.5 Regras de Igualdade
A notacÂ¸aËœo a[e] utilizada nas regras abaixo marca uma ou mais ocorreË†ncias de e em a
tal que naËœo haja variaÂ´veis livres em e. O mesmo vale para o conjunto de foÂ´rmulas Î›[e].
Î£ `Î“ a = a,Î› Refl
a = b,Î£[b] `Î“ Î›[b]
a = b,Î£[a] `Î“ Î›[a] Repl
Para utilizacÂ¸aËœo da regra Repl utilizamos o comando (replace i), onde i eÂ´ o Ä±Â´ndice
da foÂ´rmula a = b no sequente do PVS.
NoÂ´s temos alguns casos especiais para replace em que uma foÂ´rmula a antecedente pode
ser tratada como a =TRUE e, quando a eÂ´ uma foÂ´rmula consequente, pode ser tratada como
a =FALSE.
Î£[TRUE], a `Î“ Î›[TRUE]
Î£[a], a `Î“ Î›[a] Repl TRUE
Î£[FALSE], a `Î“ Î›[FALSE]
Î£[a] `Î“ a,Î›[a] Repl FALSE
Por fim, temos a regra TRUE-FALSE que daÂ´ conta que TRUE e FALSE teË†m valores
distintos.
Î£, TRUE = FALSE `Î“ Î› TRUE-FALSE
1.1.6 Regras de Extensionalidade
As regras de extensionalidade saËœo tambeÂ´m regras de igualdade para estabalecer a
equivaleË†ncia entre duas expressoËœes de funcÂ¸oËœes ou produtos. A regra FunExt introduz uma
constante de skolemizacÂ¸aËœo s (s naËœo pertencente ao contexto Î“, isto eÂ´, Î“(s) eÂ´ indefinido)
para determinar que duas funcÂ¸oËœes f e g saËœo equivalentes sempre que a aplicacÂ¸aËœo das duas
a um argumento arbitraÂ´rio s produz resultados iguais.
Î£ `Î“,s:A (f s) =B[s/x] (g s),Î›
Î£ `Î“ f =[x:Aâ†’B] g,Î› FunExt Î“(s) eÂ´ indefinido
Assim, vemos que uma igualdade entre funcÂ¸oËœes de tipo A â†’ B se transforma numa
igualdade entre elementos de tipo B.
A regra TupExt daÂ´ conta que dois produtos saËœo iguais se suas projecÂ¸oËœes
correspondentes o saËœo.
Î£ `Î“ p1(a) =T1 p1(b),Î› Î£ `Î“ p2(a) =T2[(p1a)/x] p2(b),Î›
Î£ `Î“ a =[x:T1T2] b,Î›
TupExt
O comando do PVS correspondente a essas regras eÂ´ o (decompose-equality).
SecÂ¸aËœo 1.2 â€¢ Teoria de Reescrita 8
1.1.7 Regra de ApresentacÂ¸aËœo de Tipo
A regra Typepred eÂ´ responsaÂ´vel por introduzir uma foÂ´rmula mostrando que um
determinado elemento tem tipo A no constexto Î“.
Ï„(Î“)(a) = A pi(A)(a),Î£ `Î“ Î›
Î£ `Î“ Î› Typepred
De fato, analisando a primeira linha da regra, vemos que eÂ´ extraÂ´Ä±do do contexto Î“ que
a tem tipo A (Ï„(Î“)(a) = A) e acrescenta-se a proposicÂ¸aËœo correspondente nas premissas
do sequente (pi(A)(a),Î£ `Î“ Î›).
Nesse caso, o comando do PVS responsaÂ´vel pela aplicacÂ¸aËœo dessa regra eÂ´ o proÂ´prio
(typepred a).
1.2 Teoria de Reescrita
A teoria de reescrita, tomada como importante paradigma dentro da programacÂ¸aËœo
funcional, pode apresentar diversas peculiaridades, desde que exibam sempre pares de
elementos relacionados num determinado contexto. Nesse sentido, voltamos o nosso
olhar para os Sistemas de Reescrita de Termos (TRSâ€™s), mas antes veremos como tratar
caracterÂ´Ä±sticas comuns a quaisquer sistemas de reescrita.
1.2.1 Sistemas Abstratos de Reescrita
Sistemas Abstratos de Reescrita (ARSâ€™s) saËœo formados basicamente por um
conjunto A com uma relacÂ¸aËœo binaÂ´ria â†’R sobre o conjunto, sendo denotado por (A,â†’R).
Dizemos que, se a, b âˆˆ A e aâ†’R b, a estaÂ´ relacionado com b porâ†’R, ou a reescreve para
b por â†’R, ou a reduz para b por â†’R. Esse conceito traz ferramentas necessaÂ´rias para
trabalhar mais genericamente propriedades dos Sistemas de Reescrita de Termos (TRSâ€™s)
que trataremos na proÂ´xima secÂ¸aËœo.
Para simplificar o nosso trabalho, considere a seguinte notacÂ¸aËœo:
â€¢ Râ† denota a relacÂ¸aËœo inversa.
â€¢ â†’=R denota o fecho reflexivo da relacÂ¸aËœo, ou seja, 1 ou 0 passos.
â€¢ â†’+R denota o fecho transitivo, ou seja, 1 ou mais passos da relacÂ¸aËœo.
â€¢ â†’âˆ—R denota o fecho reflexivo transitivo, isto eÂ´, 0 ou mais passos da relacÂ¸aËœo.
â€¢ =Râ†, +Râ†, âˆ—Râ† denotam, respectivamente, os fechos reflexivo, transitivo e reflexivo
transitivo da relacÂ¸aËœo inversa.
Quando o contexto for oÂ´bvio, usaremos apenas â†’ ao inveÂ´s de â†’R.
SecÂ¸aËœo 1.2 â€¢ Teoria de Reescrita 9
Considere, por exemplo, o sistema (N,â†’D), onde
aâ†’D b se, e somente se, b|a âˆ€a, b âˆˆ N.
Assim, temos que 36 â†’D 12 â†’D 6 â†’D . . . . No entanto, tambeÂ´m sabemos que
36 â†’D 9 â†’D . . . . Assim, observamos uma divergeË†ncia 6 Dâ† 12 Dâ† 36 â†’D 9. PoreÂ´m,
podemos encontrar um elemento que junta 6 e 9 uma vez que 6 â†’D 3 Dâ† 9. Observe o
diagrama:
36
D}}||
||
||
||
D @
@@
@@
@@
@
12
D~~
~~
~~
~~
9
D
~~}}
}}
}}
}}
}}
}}
}}
}}
}}
}
6
D @
@@
@@
@@
@
3
Num ARS (A,â†’), para quaisquer b, c âˆˆ A, b e c saËœo juntaÂ´veis sempre que existe
d âˆˆ A tal que b â†’âˆ— d âˆ—â† c. Assim, (A,â†’) eÂ´ um sistema confluente sempre que
âˆ€a, b, c âˆˆ A, b âˆ—â† aâ†’âˆ— c implica em b e c juntaÂ´veis.
Outra definicÂ¸aËœo importante eÂ´ a de propriedade diamante. Um sistema ter tal
propriedade significa que qualquer divergeË†ncia em um passo eÂ´ juntaÂ´vel em um passo, isto
eÂ´, num sistema (A,â†’), âˆ€a, b, c âˆˆ A, se bâ† aâ†’ c, entaËœo existe d âˆˆ A tal que bâ†’ dâ† c.
a
âˆ—
wwppp
ppp
ppp
ppp
pp
âˆ—
''NN
NNN
NNN
NNN
NNN
b
âˆ—
&&N
NN
NN
NN ConflueË†ncia c
âˆ—
xxp p
p p
p p
p
d
a
vvmmm
mmm
mmm
mmm
mmm
m
((QQ
QQQ
QQQ
QQQ
QQQ
QQ
b
((P
PP
PP
PP
PP Propr. Diamante c
vvn n
n n
n n
n n
n
d
Logo, o sistema (N,â†’D) eÂ´ confluente e tem a propriedade diamante, pois para qualquer
divergeË†ncia, o elemento 1 eÂ´ um elemento de juntabilidade uma vez que divide qualquer
nuÂ´mero natural.
1.2.2 Sistema de Reescrita de Termos
Termos saËœo estruturas definidas indutivamente a partir de um conjunto de constantes
e funcÂ¸oËœes Î£ e outro conjunto infinito enumeraÂ´vel de variaÂ´veis V , de modo que Î£ âˆ© V = âˆ…
e:
1. variaÂ´veis saËœo termos;
SecÂ¸aËœo 1.2 â€¢ Teoria de Reescrita 10
2. constantes saËœo termos;
3. f(t1, t2, . . . , tn) eÂ´ um termo sempre que f /âˆˆ V eÂ´ uma funcÂ¸aËœo n-aÂ´ria e, âˆ€i = 1, . . . , n,
temos que ti eÂ´ um termo.
O conjunto de termos formados a partir de Î£ e de V eÂ´ denotado por T (Î£, V ). De
fato, as constantes podem ser vistas como funcÂ¸oËœes com aridade 0. O subtermo t de um
termo s em uma posicÂ¸aËœo p pode ser escrito como t = s|p e denotamos por s[p â† t1] o
termo resultante da troca do subtermo da posicÂ¸ao p em s por t1, ou seja, eÂ´ o termo s a
menos da posicÂ¸aËœo p, onde fizemos a troca.
As posicÂ¸oËœes de um termo t tambeÂ´m saËœo descritas indutivamente como sequeË†ncias de
naturais, sendo que:
1.  eÂ´ a posicÂ¸aËœo raiz e qualquer termo a tem como posicÂ¸aËœo;
2. se t eÂ´ uma variaÂ´vel, entaËœo sua uÂ´nica posicÂ¸aËœo eÂ´ ;
3. se t = f(t1, . . . , tn) eÂ´ um termo funcional, entaËœo âˆ€i = 1, . . . , n, i concatenado com
uma posicÂ¸aËœo de ti eÂ´ uma posicÂ¸aËœo de t.
Veja alguns exemplos:
t = f(g(x, a, h(y, a))) e t|1.3 = h(y, a)
f
g
  
  
  
  
NNN
NNN
NNN
NNN
NN
x a h
  
  
  
 
>>
>>
>>
>>
y a
s = g(f(a), h(b, f(y)), x) e s|2.2 = f(y)
g
ppp
ppp
ppp
ppp
pp
NNN
NNN
NNN
NNN
NN
f h




<<
<<
<<
<<
x
a b f
y
TambeÂ´m dizemos que duas posicÂ¸oËœes p e q saËœo paralelas sempre que naËœo houver prefixo
comum entre elas aleÂ´m da posicÂ¸aËœo raiz. Por exemplo, as posicÂ¸oËœes 2.3.1 e 2.3.5 naËœo saËœo
paralelas, pois teË†m como prefixo comum a posicÂ¸aËœo 2.3. Por outro lado, as posicÂ¸oËœes 1.3.3
e 2.3 saËœo paralelas pois naËœo possuem prefixo comum, uma vez que o primeiro natural de
uma posicÂ¸aËœo eÂ´ diferente do primeiro natural da outra.
Sistemas de Reescrita de Termos (TRSâ€™s) saËœo programas com um nuÂ´mero finito
de regras de reescrita. Uma regra eÂ´ basicamente um par de termos, que pode ser
representado por ã€ˆl, rã€‰ ou por l âˆ’â†’ r, sendo esta uÂ´ltima a mais comum, de modo que o
lado esquerdo l estaÂ´ relacionado com o lado direito r. Como tanto o lado esquerdo quanto
SecÂ¸aËœo 1.2 â€¢ Teoria de Reescrita 11
o lado direito de uma regra saËœo termos, ambos devem assumir a estrutura apresentada
para tais. No entanto, existem algumas restricÂ¸oËœes que devem ser observadas. O lado
esquerdo l naËœo deve ser uma variaÂ´vel e qualquer variaÂ´vel que ocorrer do lado direito r
necessariamente deveraÂ´ ocorrer em l tambeÂ´m. Exemplo:
S : f(a) âˆ’â†’ g(b)
h(x, y) âˆ’â†’ f(g(x))
Uma regra de reescrita eÂ´ dita linear a` esquerda quando o termo que ocorre ao lado
esquerdo da referida regra possui no maÂ´ximo uma ocorreË†ncia de determinada variaÂ´vel,
ou seja, se uma variaÂ´vel aparecer, ela soÂ´ ocorreraÂ´ uma vez. Um sistema eÂ´ dito linear a`
esquerda se todas as suas regras saËœo lineares a` esquerda. O mesmo conceito de linearidade
vale para o lado direito. Assim, um sistema seraÂ´ linear se for tanto linear a` esquerda
quanto linear a` direita.
Linear a` esquerda Linear a` direita Linear
S : f(0, x) âˆ’â†’ f(x, g(x)) R : 1 âˆ’â†’ 2 E : g(x) âˆ’â†’ f(x, 0)
h(y, x, 1) âˆ’â†’ g(f(x, y)) h(x, x, y) âˆ’â†’ h(x, y, 1) h(1, x, y) âˆ’â†’ f(y, x)
g(1) âˆ’â†’ 0 g(f(y, y)) âˆ’â†’ f(a, b) h(0, 0, 1) âˆ’â†’ g(1)
Uma substituicÂ¸aËœo Ïƒ eÂ´ uma aplicacÂ¸aËœo Ïƒ : V âˆ’â†’ T (Î£, V ), ou seja, leva variaÂ´veis em
termos. AleÂ´m disso, Ïƒ somente deixa de fixar um nuÂ´mero finito de variaÂ´veis; assim, o
domÄ±Â´nio de Ïƒ, Dom(Ïƒ), conjunto das variaÂ´veis que naËœo saËœo mapeadas nelas mesmas, eÂ´
finito. A substituicÂ¸aËœo Ïƒ pode ser extendida ao conjunto de termos; para tÏƒ, por exemplo,
basta trocar a ocorreË†ncia de cada variaÂ´vel do termo t pela sua respectiva imagem em
Ïƒ. Uma substituicÂ¸aËœo Ï eÂ´ um renomeamento se a imagem de qualquer variaÂ´vel eÂ´ uma
variaÂ´vel.
Dois termos t e s saËœo ditos unificaÂ´veis se existe uma substituicÂ¸aËœo Î³ tal que tÎ³ = sÎ³.
Nesse caso, Î³ eÂ´ chamado um unificador de t e s.
Em TRSâ€™s, o conceito de reescrita toma uma outra dimensaËœo. Acrescentaremos
alguns detalhes que tornaraËœo o processo mais preciso em relacÂ¸aËœo ao modo como podemos
trabalhar, poreÂ´m todos os outros conceitos que vimos e resultados que obteremos saËœo
ainda aplicaÂ´veis aqui. Dizemos que, num sistema E de regras, para t, s âˆˆ T (Î£, V ), t
reescreve ou reduz para s (denotamos t âˆ’â†’E s ou t âˆ’â†’ s quando o sistema for oÂ´bvio
no contexto) sempre que existir uma regra e = ã€ˆl, rã€‰ âˆˆ E tal que, em alguma posicÂ¸aËœo p
de t, t|p = lÏƒ e s = t[pâ† rÏƒ].
E : h(x, y) âˆ’â†’ g(x, x)
g(x, f(y)) âˆ’â†’ h(y, y)
SecÂ¸aËœo 1.2 â€¢ Teoria de Reescrita 12
A partir do sistema E, eÂ´ possÂ´Ä±vel proceder com a sequeË†ncia
de reducÂ¸oËœes h(f(a), h(f(b), b)) âˆ’â†’E h(f(a), g(f(b), f(b))) âˆ’â†’E h(f(a), h(b, b)) âˆ’â†’E
g(f(a), f(a)) âˆ’â†’E h(a, a) âˆ’â†’E g(a, a). De fato, observemos a primeira reducÂ¸aËœo. O
subtermo de t = h(f(a), h(f(b), b)) na posicÂ¸aËœo 2 eÂ´ exatamente o lado esquerdo da primeira
regra l1 = h(x, y) instanciado com a substituicÂ¸aËœo Ïƒ = {x/f(b), y/b} (leva x em f(b) e y em
b), isto eÂ´, t|2 = l1Ïƒ. AleÂ´m disso, o termo resultante s = h(f(a), g(f(b), f(b))) eÂ´ o termo
t, trocando o subtermo da posicÂ¸aËœo 2 pelo lado direito da primeira regra r1 = g(x, x)
instanciado tambeÂ´m por Ïƒ, ou seja, s = t[2â† r1Ïƒ].
Outro conceito importante eÂ´ o de par crÂ´Ä±tico. Para que dois termos t e s sejam um
par crÂ´Ä±tico, eÂ´ necessaÂ´ria a existeË†ncia de duas regras de reescrita e1 = ã€ˆl1, r1ã€‰ e e2 = ã€ˆl2, r2ã€‰
tais que os conjuntos de variaÂ´veis dos termos l1 e l2 sejam disjuntos (se naËœo forem, basta
renomear de forma que sejam), o subtermo de l1 numa posicÂ¸aËœo p, l1|p, naËœo seja uma
variaÂ´vel e l1|p e l2 sejam unificaÂ´veis com um unificador Î³. DaÂ´Ä±, devemos ter que t = r1Î³
e s = l1Î³[p â† r2Î³] eÂ´ o par crÂ´Ä±tico considerado. Em outras palavras, para que haja um
par crÂ´Ä±tico, eÂ´ necessaÂ´rio que o lado esquerdo de uma regra seja unificaÂ´vel com o subtermo
do lado esquerdo de outra regra numa posicÂ¸aËœo que naËœo seja de variaÂ´vel. O par crÂ´Ä±tico eÂ´ o
produto da divergeË†ncia dessas duas regras que se sobrepoËœem. Considere, por exemplo, o
seguinte sistema:
A : f(x, g(y)) âˆ’â†’ h(y)
g(h(a)) âˆ’â†’ f(a, a)
Î³ = {y/h(a)} eÂ´ um unificador para g(y) e g(h(a)),
pois (g(y))Î³ = g(h(a)) e Î³ naËœo altera g(h(a)),
uma vez que naËœo haÂ´ variaÂ´veis neste termo.
Assim, temos um par crÂ´Ä±tico, que eÂ´ basicamente uma divergeË†ncia a partir das regras
onde ocorreu matching.
f(x, g(h(a)))
wwooo
ooo
ooo
oo
((QQ
QQQ
QQQ
QQQ
Q
h(h(a)) f(x, f(a, a))
Quando ocorre um par crÂ´Ä±tico, noÂ´s dizemos que o sistema de regras eÂ´ ambÂ´Ä±guo. Na
verdade, o que nos interessa principalmente saËœo os sistemas naËœo ambÂ´Ä±guos, onde naËœo haÂ´
par crÂ´Ä±tico, e que sejam lineares a` esquerda. Tais sistemas saËœo chamados ortogonais.
1.2.3 Principais Teoremas
Nesta secÂ¸aËœo, veremos alguns resultados fundamentais ateÂ´ desenvolvermos a prova de
que TRSâ€™s ortogonais saËœo confluentes. Em alguns teoremas, veremos a ideia principal
para a prova, sem apresentar todos os detalhes teÂ´cnicos.
SecÂ¸aËœo 1.2 â€¢ Teoria de Reescrita 13
Teorema 1.2.1 Todo sistema de reescrita que tem a propriedade do diamante eÂ´
confluente.
DemonstracÂ¸aËœo: Seja o ARS (A,â†’) e a, b, c âˆˆ A tais que b âˆ—â† a â†’âˆ— c. Precisamos
provar que existe d âˆˆ A tal que b â†’âˆ— d âˆ—â† c. Faremos a prova por inducÂ¸aËœo sobre o
nuÂ´mero de passos m em que a atinge b e sobre o nuÂ´mero de passos n em que a atinge c
(b mâ† aâ†’n c).
Base de inducÂ¸aËœo (BI) sobre m: se m = 0, entaËœo naËœo haÂ´ divergeË†ncia, pois aâ†’0 b
implica que a = b. Assim, jaÂ´ sabemos que b = a â†’âˆ— c 0â† c. Logo, c eÂ´ o nosso
elemento de juntabilidade.
Passo indutivo (PI) sobre m: se m â‰¥ 1, entaËœo sabemos que existe bâ€² âˆˆ A tal que
aâ†’ bâ€² â†’mâˆ’1 b.
BI sobre n: se n = 0, entaËœo naËœo haÂ´ divergeË†ncia e b eÂ´ o termo de juntabilidade,
pois temos que bâ†’0 b âˆ—â† c = a.
PI sobre n: se n â‰¥ 1, entaËœo sabemos que existe câ€² âˆˆ A tal que aâ†’ câ€² â†’nâˆ’1 c.
Como temos a divergeË†ncia em um passo bâ€² â† a â†’ câ€², pela hipoÂ´tese da
propriedade do diamante, existe e âˆˆ A tal que bâ€² â†’ e â† câ€². Agora,
temos a divergeË†ncia b mâˆ’1â† bâ€² â†’ e e, pela hipoÂ´tese de inducÂ¸aËœo (HI) sobre
m, existe dâ€² âˆˆ A tal que b â†’âˆ— dâ€² âˆ—â† e. Finalmente, temos a divergeË†ncia
dâ€² âˆ—â† e â† câ€² â†’nâˆ’1 c. Pela HI sobre n, existe d âˆˆ A tal que dâ€² â†’âˆ— d âˆ—â† c. Pela
transitividade do fecho reflexivo transitivo, bâ†’âˆ— dâ€² â†’âˆ— d implica bâ†’âˆ— d âˆ—â† c,
como querÂ´Ä±amos demonstrar. 
A estrateÂ´gia de prova utilizada em [3, 4] para a prova de que TRSâ€™s ortogonais saËœo
confluentes utiliza o fato de que uma segunda relacÂ¸aËœo entre termos chamada reducÂ¸aËœo ou
reescrita em paralelo tem a propriedade diamante. DaÂ´Ä±, pelo teorema anterior, temos
a conflueË†ncia para a reducÂ¸aËœo em paralelo, que equivale a` conflueË†ncia para a reescrita
simples, uma vez que o fecho reflexivo transitivo da primeira corresponde ao fecho reflexivo
transitivo da segunda.
NoÂ´s definimos a reescrita em paralelo de modo semelhante ao da reescrita simples,
sendo que a reducÂ¸aËœo pode ocorrer em vaÂ´rias posicÂ¸oËœes paralelas dentro do termo
original. Denotaremos a reescrita em paralelo sobre as regras de um sistema E por
â‡’E. Assim, quando dizemos que t1 â‡’E t2, estamos afirmando que haÂ´ uma sequeË†ncia
(possivelmente vazia) Î  = (pi0, . . . , pin) de posicÂ¸oËœes paralelas do termo t1, uma sequeË†ncia
 = (ã€ˆl0, r0ã€‰, . . . , ã€ˆln, rnã€‰) de regras em E e uma sequeË†ncia Î“ = (Î³0, . . . , Î³n) de substituicÂ¸oËœes,
tais que, âˆ€i = 0, . . . , n (n = |Î | âˆ’ 1), temos:
SecÂ¸aËœo 1.2 â€¢ Teoria de Reescrita 14
1. t1|pii = liÎ³i;
2. t2|pii = riÎ³i e as diferencÂ¸as entre t1 e t2 ocorrem somente nessas posicÂ¸oËœes.
Teorema 1.2.2 t1 â‡’âˆ—E t2 se, e somente se, t1 â†’âˆ—E t2.
DemonstracÂ¸aËœo:
(â‡’) De fato, como para cada passo deâ‡’E noÂ´s temos vaÂ´rios passos deâ†’E, entaËœo t1 â‡’âˆ—E t2
corresponde a t1(â†’âˆ—E)âˆ—t2. Mas isso corresponde a t1 â†’âˆ—E t2 e temos o que querÂ´Ä±amos.
(â‡) NoÂ´s podemos considerar que cada passo de â†’E corresponde a um passo de â‡’E.
EÂ´ soÂ´ tomar a sequeË†ncia unitaÂ´ria de posicÂ¸aËœo, de regra e de substituicÂ¸aËœo. Assim, jaÂ´
temos diretamente que t1 â†’âˆ—E t2 implica que t1 â‡’âˆ—E t2. 
Para provar o teorema seguinte, consideraremos verdadeiro que a relacÂ¸aËœo â‡’E tem a
propriedade diamante no caso em que E seja ortogonal e, posteriormente, faremos um
esbocÂ¸o da demonstracÂ¸aËœo da afirmacÂ¸aËœo.
Teorema 1.2.3 Seja E um sistema de regras de reescrita ortogonal. EntaËœo, a relacÂ¸aËœo
â†’E eÂ´ confluente.
DemonstracÂ¸aËœo: Assumiremos queâ‡’E tem a propriedade diamante. Pelo teorema 1.2.1,
sabemos entaËœo que â‡’E eÂ´ confluente, o que quer dizer que, âˆ€s, t1, t2 âˆˆ T (Î£, V ) tais que
t1
âˆ—â‡” tâ‡’âˆ— t2 implica que âˆƒu âˆˆ T (Î£, V ) tal que t1 â‡’âˆ— u âˆ—â‡” t2.
Como temos a equivaleË†ncia entre â†’âˆ—E e â‡’âˆ—E, segue que â†’E eÂ´ confluente. 
Teorema 1.2.4 Seja E um sistema de regras de reescrita ortogonal. EntaËœo, a relacÂ¸aËœo
â‡’E tem a propriedade diamante.
EsbocÂ¸o da prova: Sejam s, t1, t2 âˆˆ T (Î£, V ) tais que t1 â‡” sâ‡’ t2. EntaËœo, existem duas
sequeË†ncias Î 1 e Î 2 de posicÂ¸oËœes paralelas de s onde ocorrem as reducÂ¸oËœes. No entanto, essas
posicÂ¸oËœes podem naËœo ser paralelas quando se considera as posicÂ¸oËœes das duas sequeË†ncias
juntas.
Consideraremos as posicÂ¸oËœes onde ocorreraËœo as reducÂ¸oËœes como sendo o veÂ´rtice superior
dos triaË†ngulos coloridos na Figura 1.1. Os triaË†ngulos vermelhos e o roxo representam
os subtermos de s que seraËœo modificados para atingir o termo t1 em um uÂ´nico passo de
reescrita em paralelo; os triaË†ngulos azuis e o roxo representam os subtermos de s que
seraËœo modificados para atingir o termo t2.
Como esses subtermos seraËœo reescritos, isso significa que fazem matching com alguma
instanciacÂ¸aËœo do lado esquerdo de regras que estaËœo no sistema ortogonal E. Chamaremos
de 1 e Î“1 as sequeË†ncias de regras e de substituicÂ¸oËœes, respectivamente, responsaÂ´veis pela
SecÂ¸aËœo 1.2 â€¢ Teoria de Reescrita 15
s
Figura 1.1: Termo inicial
reescrita para t1 e de 2 e Î“2 as sequeË†ncias de regras e substituicÂ¸oËœes, respectivamente,
responsaÂ´veis pela reescrita para t2.
Assim, como a Figura 1.1 mostra, de fato haÂ´ a possibilidade de encontrarmos o lado
esquerdo de regras em 1 instanciado com as substituicÂ¸oËœes de Î“1 dentro do lado esquerdo de
regras em 2 instanciado com as substituicÂ¸oËœes em Î“2 e vice-versa. Note que haÂ´ pentaÂ´gonos
interpostos entre os triaË†ngulos sempre que haÂ´ â€œsobreposicÂ¸aËœoâ€ de regras. De fato, naËœo
haÂ´ sobreposicÂ¸aËœo, pois esses pentaÂ´gonos representam variaÂ´veis cuja instanciacÂ¸aËœo pelas
substituicÂ¸oËœes correspondentes ao termo colorido maior conteÂ´m os subtermos coloridos.
A existeË†ncia dessas variaÂ´veis eÂ´ devida a` naËœo ambiguidade das regras em E. No caso do
subtermo roxo, como as posicÂ¸oËœes coincidem, tambeÂ´m pela naËœo ambiguidade jaÂ´ sabemos
que eÂ´ uma uÂ´nica regra que faz a reducÂ¸aËœo para o termo t1 e para t2.
DaÂ´Ä±, temos a seguinte divergeË†ncia quando acontecem as reescritas em paralelo:
Os triaË†ngulos preenchidos representam o lado direito das regras, ou seja, onde jaÂ´
ocorreram as modificacÂ¸oËœes, mas ainda assim pode haver triaË†ngulos vazados no seu interior.
Isso acontece porque as variaÂ´veis que conteË†m o lado esquerdo de algumas regras podem
ocorrer tambeÂ´m do lado direito de uma regra; mais que isso, as variaÂ´veis podem se replicar
no lado direito. De fato, quando noÂ´s falamos de ortogonalidade, falamos de linearidade a`
esquerda, mas a` direita naËœo haÂ´ restricÂ¸oËœes quanto ao nuÂ´mero de ocorreË†ncias de uma dada
variaÂ´vel.
Note ainda que as posicÂ¸oËœes das variaÂ´veis podem ser modificadas dentro do termo
colorido maior. Assim, os subtermos coloridos das variaÂ´veis tambeÂ´m assumiraËœo novas
posicÂ¸oËœes, podendo se replicar.
O nosso objetivo eÂ´ obter um termo u que satisfacÂ¸a o que acontece na figura seguinte:
Para tanto, vamos analisar o que deve ocorrer para que t1 â‡’E u. Entendendo como
isso ocorre, sabemos que t2 â‡’E u eÂ´ um caso simeÂ´trico a este.
Como falamos anteriormente, o termo de contorno roxo naËœo seraÂ´ modificado de t1 para
u, pois naËœo haÂ´ diferencÂ¸a entre t1 e t2 nessa posicÂ¸aËœo.
SecÂ¸aËœo 1.2 â€¢ Teoria de Reescrita 16
E E
s
t t1 2
Figura 1.2: DivergeË†ncia em um passo de reescrita em paralelo
E E
E E
s
t t
u
1 2
Figura 1.3: Termo de juntabilidade
SecÂ¸aËœo 1.2 â€¢ Teoria de Reescrita 17
t1s
E E
u
Figura 1.4: Cadeia de reducÂ¸oËœes passando por t1
Os subtermos vazados azuis que estaËœo dentro do triaË†ngulo vermelho preenchido
precisam ficar preenchidos tambeÂ´m. A uÂ´nica observacÂ¸aËœo ao se reduzir esses termos eÂ´
que precisamos atualizar as posicÂ¸oËœes, uma vez que as variaÂ´veis que os conteË†m trocam as
posicÂ¸oËœes no triaË†ngulo preenchido, isto eÂ´, quando o triaË†ngulo vermelho deixa de ser lado
esquerdo para ser lado direito da regra instanciada. Nesse caso, as regras que utilizaremos
saËœo as de 2 e as substituicÂ¸oËœes de Î“2 que as acompanham.
Em relacÂ¸aËœo ao triaË†ngulo azul vazado grande em t1, haÂ´ que se tomar cuidado. Observe
que a substituicÂ¸aËœo que instanciava essa regra em s naËœo serve mais, pois o termo foi
modificado em suas â€œsubposicÂ¸oËœesâ€. No entanto, a mesma substituicÂ¸aËœo pode ser alterada
de forma que a mesma regra facÂ¸a matching com esse termo em t1. Nesse momento, eÂ´
importante lembrar que as substituicÂ¸oËœes agem somente sobre variaÂ´veis. Mas as alteracÂ¸oËœes
que o termo do triaË†ngulo azul grande sofreu ocorreram justamente dentro das instanciacÂ¸oËœes
de variaÂ´veis, ou seja, dentro dos pentaÂ´gonos. Assim, criamos uma nova substituicÂ¸aËœo que
age exatamente como a de antes, mas onde aparecem as nossas variaÂ´veis de interesse,
trocam-se os triaË†ngulos vermelhos vazados (como em s) pelos triaË†ngulos vermelhos
preenchidos (como em t1).
Logo, chegamos ao fim do nosso esbocÂ¸o pois encontramos as posicÂ¸oËœes, as regras e as
substituicÂ¸oËœes que precisaÂ´vamos encontrar para fazer a reducÂ¸aËœo em paralelo de t1 para u.
O outro caso, eÂ´ anaÂ´logo. 
A mesma ideia apresentada aqui seraÂ´ utilizada para a formalizacÂ¸aËœo do teorma em
um assistente de prova: primeiramente descrevemos quem eÂ´ o termo de juntabilidade e,
depois, nos damos conta de que existem sequeË†ncias de posicÂ¸oËœes, regras e substituicÂ¸oËœes que
satisfazem as condicÂ¸oËœes para reducÂ¸aËœo em paralelo.
A naËœo ambiguidade eÂ´ fundamental nessa prova uma vez que eÂ´ dela que sacamos a
existeË†ncia das variaÂ´veis onde podemos agir para criar novas substituicÂ¸oËœes. Por outro
lado, a linearidade a` esquerda eÂ´ importante pois a reescrita em paralelo age em posicÂ¸oËœes
especÂ´Ä±ficas enquanto que a substituicÂ¸aËœo age em todas as ocorreË†ncias das variaÂ´veis em seu
domÄ±Â´nio. Isso acarretaria diferencÂ¸as no termo final. Para entendermos essa diferencÂ¸a,
acompanhemos o exemplo que temos a seguir.
SecÂ¸aËœo 1.2 â€¢ Teoria de Reescrita 18
Considere o sistema T naËœo ambÂ´Ä±guo, poreÂ´m naËœo linear a` esquerda.
T : f(x, g(x)) âˆ’â†’ g(b)
h(a, x) âˆ’â†’ g(a)
a âˆ’â†’ c
Acompanhe a divergeË†ncia que ocorre a partir do termo s = f(h(a, y), g(h(a, y))).
f(h(a, y), g(h(a, y)))
T
rz nnn
nnn
nnn
nnn
n
nnn
nnn
nnn
nnn
n
T &.TT
TTTT
TTTT
TTTT
T
TTTT
TTTT
TTTT
TTT
g(b) f(g(a), g(h(c, y)))
Assim, naËœo existe substituicÂ¸aËœo capaz de instanciar a primeira regra de tal forma que
ocorra o matching do lado esquerdo com o termo f(g(a), g(h(c, y))), pois a imagem de x
teria que ser g(a) e h(c, y) ao mesmo tempo.
Agora, vamos fazer uma pequena modificacÂ¸aËœo em T e criar o sistema ortogonal TËœ .
TËœ : f(x, g(y)) âˆ’â†’ g(b)
h(a, x) âˆ’â†’ g(a)
a âˆ’â†’ c
Novamente, noÂ´s temos a mesma divergeË†ncia a partir do termo s.
f(h(a, y), g(h(a, y)))
TËœ
v~ vv
vv
vv
vv
vv
vv
vv
vv
TËœ
#+N
NNN
NNN
NNN
NNN
NNN
NNN
NN
NNN
NNN
NNN
NNN
NNN
NNN
NNN
g(b) f(g(a), g(h(c, y)))
TËœ
ks
No entanto, a divergeË†ncia eÂ´ juntaÂ´vel. Quando fizemos f(h(a, y), g(h(a, y))) â‡’TËœ g(b),
utilizamos a primeira regra e a substituicÂ¸aËœo Ïƒ = {x/h(a, y) , y/h(a, y)}. Finalmente,
para fazer f(g(a), g(h(c, y))) â‡’TËœ g(b), utilizamos a mesma regra e a substituicÂ¸aËœo
Ïƒâ€² = {x/g(a), y/h(c, y)}.
CapÂ´Ä±tulo
2
EspecificacÂ¸aËœo
Toda a teoria apresentada aqui tem se especificado com o objetivo de formalizaÂ´-la em
um assistente de prova semi-automaÂ´tico. O assistente utilizado no trabalho eÂ´ o Prototype
Verification System (PVS) na versaËœo 5.0, provador baseado numa loÂ´gica de ordem superior.
O nome da teoria desenvolvida eÂ´ orthogonality e utiliza grande parte das teorias ars
e trs desenvolvidas pelo Grupo de Teoria da ComputacÂ¸aËœo (GTC/UnB), disponÂ´Ä±veis em [1],
na forma dos proÂ´prios arquivos de formalizacÂ¸aËœo, e em [2, 6, 7], como artigos apresentados
pelos desenvolvedores do GTC/UnB.
2.1 Sistemas Abstratos de Reescrita
Algumas definicÂ¸oËœes tratadas nesses trabalhos nos daraËœo base para entender a
especificacÂ¸aËœo desenvolvida aqui. Apresentamos primeiramente as que se relacionam aos
ARSâ€™s. Esses conceitos estaËœo disponÂ´Ä±veis na teoria ars como mencionado acima.
RC(R): reflexive = union(R, =)
iterate(f, n)(x): RECURSIVE T =
IF n = 0 THEN x ELSE f(iterate(f, n-1)(x)) ENDIF
MEASURE n
TC(R): transitive = IUnion(LAMBDA (p:posnat): iterate(R, p))
RTC(R): reflexive_transitive = IUnion(LAMBDA (n:nat): iterate(R, n))
joinable?(R)(x,y): bool = EXISTS z: RTC(R)(x,z) & RTC(R)(y, z)
confluent?(R): bool = FORALL x, y, z: RTC(R)(x,y) & RTC(R)(x,z) =>
joinable?(R)(y,z)
SecÂ¸aËœo 2.2 â€¢ Sistemas de Reescrita de Termos 20
diamond_property?(R): bool = FORALL x, y, z: R(x,y) & R(x,z) =>
EXISTS r: R(y,r) & R(z,r)
Note que R eÂ´ uma relacÂ¸aËœo de reescrita. AteÂ´ este momento, ainda estamos trabalhando
somente as definicÂ¸oËœes relacionadas aos ARSâ€™s. Temos que RC (reflexive closure) nos daÂ´
o fecho reflexivo da relacÂ¸aËœo R, isto eÂ´, se temos RC(R)(x,y), entaËœo R(x,y) ou x=y. JaÂ´ a
funcÂ¸aËœo iterate faz a funcÂ¸aËœo f agir sobre x por n vezes, sendo definida recursivamente,
nos resultando numa multi-composicÂ¸aËœo da mesma funcÂ¸aËœo. O fecho transitivo da relacÂ¸aËœo
R eÂ´ denotado por TC(R) e eÂ´ definido como a uniaËœo de todas as composicÂ¸oËœes de R por um
nuÂ´mero p natural positivo de vezes (pâ‰¥ 1). O fecho reflexivo transitivo de R, denotado
por RTC(R), eÂ´ definido da mesma forma, mas para n natural qualquer, ou seja, haÂ´ a
possibilidade de que naËœo haja iteracÂ¸aËœo alguma de R se n=0.
JaÂ´ a nocÂ¸aËœo de juntabilidade de dois elementos x e y atraveÂ´s da relacÂ¸aËœo R eÂ´ dada pelo
predicado joinable?, onde joinable?(R)(x,y) significa que haÂ´ um elemento z tal que
x e y atingem z atraveÂ´s de RTC(R), ou seja, existe uma cadeia de reducÂ¸aËœo de x a z
com 0 ou mais passos e outra cadeia de reducÂ¸aËœo tambeÂ´m em 0 ou mais passos de y a
z. O predicado confluent? aponta que uma determinada relacÂ¸aËœo R eÂ´ confluente, isto
eÂ´, para qualquer divergeË†ncia a partir de um elemento x, RTC(R)(x,y) e RTC(R)(x,z),
esses elementos y e z saËœo juntaÂ´veis. A propriedade diamante eÂ´ expressa pelo predicado
diamond property? que avalia se uma relacÂ¸aËœo R tem ou naËœo tal propriedade o que quer
dizer que, se diamond property?(R) eÂ´ verdadeira, qualquer divergeË†ncia em um passo
para cada lado (R(x,y) e R(x,z)) implica na existeË†ncia de um elemento de juntabilidade
r que pode ser alcancÂ¸ado em um passo de cada lado (R(y,r) e R(z,r)).
2.2 Sistemas de Reescrita de Termos
Outras definicÂ¸oËœes chave para a compreensaËœo do coÂ´digo saËœo os conceitos relacionados
aos TRSâ€™s, tratados anteriormente ao presente trabalho e disponÂ´Ä±veis na teoria trs. SaËœo
estes:
term: TYPE
vars?, app?: [term -> boolean]
V: set[term] = {x: term | vars?(x)}
vars: [variable -> (vars?)]
app:
[[f: symbol,
SecÂ¸aËœo 2.2 â€¢ Sistemas de Reescrita de Termos 21
{args: finite_sequence[term] | argsâ€˜length = arity(f)}] ->
(app?)]
v: [(vars?) -> variable]
f: [(app?) -> symbol]
args:
[d: (app?) ->
{args: finite_sequence[term] | argsâ€˜length = arity(f(d))}]
term_v_vars: AXIOM
FORALL (vars1_var: variable): v(vars(vars1_var)) = vars1_var;
term_f_app: AXIOM
FORALL (app1_var: symbol,
app2_var:
{args: finite_sequence[term] |
argsâ€˜length = arity(app1_var)}):
f(app(app1_var, app2_var)) = app1_var;
term_args_app: AXIOM
FORALL (app1_var: symbol,
app2_var:
{args: finite_sequence[term] |
argsâ€˜length = arity(app1_var)}):
args(app(app1_var, app2_var)) = app2_var
term_inclusive: AXIOM
FORALL (term_var: term): vars?(term_var) OR app?(term_var)
Foi criado o tipo term cujos elementos podem ser avaliados pelos predicados vars?
(que julga se um dado termo eÂ´ uma variaÂ´vel) e app? (diz se eÂ´ um termo funcional).
V eÂ´ definido como o conjunto de todas as variaÂ´veis. A funcÂ¸aËœo vars toma qualquer
variaÂ´vel e lhe daÂ´ o valor de verdade como variaÂ´vel pelo predicado vars? e a funcÂ¸aËœo
app faz o correspondente em relacÂ¸aËœo a`s aplicacÂ¸oËœes, termos funcionais com um sÂ´Ä±mbolo f
e uma sequeË†ncia de termos args aplicados como argumentos em cada posicÂ¸aËœo de f cujo
comprimento coincide com a aridade do sÂ´Ä±mbolo.
As funcÂ¸oËœes v, f e args fazem o oposto, tomando o que tem valor de verdade como
variaÂ´vel no caso de v ou aplicacÂ¸aËœo no caso de f/args, retornando a variaÂ´vel avaliada por
vars?, ou ainda, para o termo avaliado como funcional por app?, o sÂ´Ä±mbolo de funcÂ¸aËœo
ou os argumentos do termo, respectivamente. Vale mencionar que essa parte eÂ´ gerada
automaticamente pelo PVS quando definimos um datatype. Os axiomas term v vars,
SecÂ¸aËœo 2.3 â€¢ PosicÂ¸oËœes 22
term f app e term args app mostram justamente essas propriedades descritas acima. O
axioma term inclusive restringe as opcÂ¸oËœes de caracterizacÂ¸aËœo de um termo, que soÂ´ pode
ser uma variaÂ´vel ou uma aplicacÂ¸aËœo.
2.3 PosicÂ¸oËœes
position: TYPE = finseq[posnat]
positions: TYPE = set[position]
positionsOF(t: term): RECURSIVE positions =
(CASES t OF
vars(t): only_empty_seq,
app(f, st): IF length(st) = 0
THEN
only_empty_seq
ELSE
union(only_empty_seq,
IUnion((LAMBDA (i: upto?(length(st))):
catenate(i, positionsOF(st(i-1)) ))))
ENDIF
ENDCASES)
MEASURE t BY <<
Como tratamos antes, cada posicÂ¸aËœo, denotada por position, eÂ´ uma sequeË†ncia
finita de naturais naËœo nulos (finseq[posnat]) e positions eÂ´ um conjunto de posicÂ¸oËœes
(set[position]). O conjunto de posicÂ¸oËœes de um termo t, denotado por positionsOF(t),
eÂ´ definido recursivamente onde, se t eÂ´ uma variaÂ´vel, entaËœo o conjunto seraÂ´ only empty seq,
ou seja, a uÂ´nica posicÂ¸aËœo de t eÂ´ empty seq, a posicÂ¸aËœo raiz; senaËœo, t eÂ´ uma aplicacÂ¸aËœo
app(f,st) e, caso a sequeË†ncia de argumentos st aplicados a f tenha comprimento nulo,
entaËœo temos novamente only empty seq e, caso contraÂ´rio, temos que positionsOF(t)
seraÂ´ a uniaËœo de only empty seq e as posicÂ¸oËœes formadas pela acÂ¸aËœo de concatenar cada
Ä±Â´ndice i da sequeË†ncia st adicionando 1, isto eÂ´, i+1, com as posicÂ¸oËœes do termo dentro
do argumento na posicÂ¸aËœo i da sequeË†ncia (eÂ´ somado 1 ao Ä±Â´ndice, pois trabalhamos com
posnat em relacÂ¸aËœo a`s posicÂ¸oËœes de termos, enquanto que utilizamos nat nos Ä±Â´ndices de uma
sequeË†ncia finita).
p, q: VAR position
fsp: VAR finseq[position]
t: VAR term
SecÂ¸aËœo 2.4 â€¢ SequeË†ncias finitas 23
<=(p, q): bool = (EXISTS (p1: position): q = p o p1)
parallel(p, q): bool = (NOT p <= q) & (NOT q <= p)
PP?(fsp): bool = IF fspâ€˜length < 2
THEN true
ELSE
FORALL (i, j: below[length(fsp)]): i /= j =>
parallel(fsp(i), fsp(j))
ENDIF
SP?(t)(fsp): bool = FORALL (i: below[length(fsp)]):
positionsOF(t)(fsp(i))
SPP?(t)(fsp): bool = PP?(fsp) & SP?(t)(fsp)
Temos que a posicÂ¸aËœo p eÂ´ prefixo de q sempre que existir uma posicÂ¸aËœo complemento
p1, ou seja, q eÂ´ p concatenada com p1. Por exemplo, se p= 3.2 e q= 3.2.2.4.5, entaËœo
temos que p<=q, pois q=p o p1, onde p1= 2.4.5. Agora, vale parallel(p,q) se naËœo vale
a relacÂ¸aËœo binaÂ´ria <= em nenhum dos dois sentidos. Sendo assim, algumas propriedades
saËœo extraÂ´Ä±das facilmente como, por exemplo, a comutatividade de parallel, que vem
diretamente da comutatividade do conectivo loÂ´gico &. O predicado PP? aplicado a uma
sequeË†ncia de posicÂ¸oËœes fsp compara todas as posicÂ¸oËœes da sequeË†ncia e verifica se todas
saËœo paralelas duas a duas. JaÂ´ SP?(t)(fsp) eÂ´ verdade se todas as posicÂ¸oËœes de fsp saËœo
posicÂ¸oËœes do termo t e vale SPP?(t)(fsp) se valem as duas proposicÂ¸oËœes acima (PP?(fsp)
e SP?(t)(fsp)).
2.4 SequeË†ncias finitas
Antes de continuar, vale a pena trazer alguns conceitos sobre sequeË†ncias finitas
(finseqâ€™s) que daraËœo base a vaÂ´rias definicÂ¸oËœes daqui para frente. EÂ´ importante dizer
que a teoria que trata esses conceitos finite sequences extras[T: TYPE] trabalha com
um tipo arbitraÂ´rio T, sendo que a teoria pode ser importada e instanciada tranquilamente
por qualquer outro tipo existente, o que faremos extensamente durante a especificacÂ¸aËœo.
Esse modelo de tipagem eÂ´ chamado polimorfismo.
first(seq: not_empty_seq): T = seq(0)
rest(seq): finseq = IF seqâ€˜length = 0
THEN seq
ELSE ^(seq,(1, seqâ€˜length - 1))
SecÂ¸aËœo 2.4 â€¢ SequeË†ncias finitas 24
ENDIF
delete(seq, (n: below[length(seq)])): finseq =
(IF seqâ€˜length = 0
THEN seq
ELSE (# length := seqâ€˜length - 1,
seq := (LAMBDA (i: below[seqâ€˜length - 1]):
(IF i < n THEN seq(i)
ELSE seq(i + 1)
ENDIF)) #)
ENDIF)
insert?(x, seq, (n: upto[length(seq)])): finseq =
(# length := seqâ€˜length + 1,
seq := (LAMBDA (i: below[seqâ€˜length + 1]):
(IF i < n THEN seq(i)
ELSIF i = n THEN x
ELSE seq(i - 1) ENDIF)) #)
add_first(x, seq): finseq = insert?(x, seq, 0)
replace(x, seq, (n: below[length(seq)])): finseq =
(IF seqâ€˜length = 0 THEN seq
ELSE
(# length := seqâ€˜length,
seq := (LAMBDA (i: below[seqâ€˜length]):
(IF i < n THEN seq(i)
ELSIF i = n THEN x
ELSE seq(i) ENDIF)) #)
ENDIF)
A funcÂ¸aËœo first pode ser aplicada a uma finseq naËœo vazia seq e retorna o primeiro
elemento da sequeË†ncia seq(0) de tipo T. Por outro lado, rest pode ser aplicada a qualquer
sequeË†ncia finita e retorna outra finseq, que eÂ´ o resto da sequeË†ncia (retira o primeiro
elemento, se houver). A funcÂ¸aËœo delete que tem como argumentos uma sequeË†ncia seq e
um natural n menor que o comprimento da sequeË†ncia, retorna seq a menos do elemento
seq(n), que eÂ´ retirado, e os Ä±Â´ndices posteriores a n saËœo ajustados. Quando insert? eÂ´
aplicado a um elemento x de tipo T, a seq, que eÂ´ uma finseq[T], e a n natural menor
ou igual ao comprimento de seq, temos que eÂ´ acrescentado a seq o elemento x na posicÂ¸aËœo
de Ä±Â´ndice n, ajustando-se os Ä±Â´ndices posteriores. A aplicacÂ¸aËœo add first utiliza insert?
para inserir o elemento x na primeira posicÂ¸aËœo da sequeË†ncia seq, ou seja, a de Ä±Â´ndice 0.
Por uÂ´ltimo, temos a funcÂ¸aËœo replace que toma em seq o elemento seq(n), que estaÂ´ na
posicÂ¸aËœo n+1-eÂ´sima, e o troca por x.
SecÂ¸aËœo 2.5 â€¢ Subtermos 25
2.5 Subtermos
Voltamos a tratar dos conceitos dentro dos TRSâ€™s. Repare a ocorreË†ncia das notacÂ¸oËœes
apresentadas para finseq[T], sendo que temos agora o tipo T instanciado com position
e term, por exemplo, e vaÂ´rios outros tipos que precisaremos mais a` frente.
subtermOF(t: term, (p: positions?(t))): RECURSIVE term =
(IF length(p) = 0
THEN
t
ELSE
LET st = args(t),
i = first(p),
q = rest(p) IN
subtermOF(st(i-1), q)
ENDIF)
MEASURE length(p)
Vars(t): set[(V)] = {x: (V) | EXISTS (p: positions?(t)): subtermOF(t, p) = x}
Pos_var(t, x): positions = {p: positions?(t) | subtermOF(t,p) = x}
A aplicacÂ¸aËœo subtermOF nos daÂ´ o subtermo de t na posicÂ¸aËœo p, onde p pertence ao
conjunto de posicÂ¸oËœes de t. O algoritmo trabalha recursivamente atraveÂ´s do comprimento
de p. Enquanto o comprimento da posicÂ¸aËœo que noÂ´s trabalhamos naËœo for 0, entaËœo t eÂ´ um
termo funcional e noÂ´s podemos tomar o argumento i-eÂ´simo (de Ä±Â´ndice i-1 na sequeË†ncia),
onde i eÂ´ o primeiro posnat na formacÂ¸aËœo de p, e noÂ´s aplicamos novamente subtermOF
a esse argumento e a` posicÂ¸aËœo rest(p). Assim, o comprimento da posicÂ¸aËœo sempre vai
diminuindo, uma vez que aplicamos rest a` posicÂ¸aËœo anterior em cada passo. Quando
obtivermos p=empty seq, isto eÂ´, length(p)=0, entaËœo podemos parar e retornar o proÂ´prio
termo aplicado naquele passo. O conjunto Vars(t) engloba todas as variaÂ´veis que ocorrem
em t baseado na existeË†ncia de posicÂ¸oËœes desse termo cujos subtermos sejam variaÂ´veis. JaÂ´
o conjunto Pos var(t,x) abarca as posicÂ¸oËœes de t onde ocorre uma dada variaÂ´vel x.
2.6 SubstituicÂ¸oËœes
sigma: VAR [(V) -> term]
Dom(sigma): set[(V)] = {x: (V) | sigma(x) /= x}
SecÂ¸aËœo 2.7 â€¢ ReducÂ¸aËœo simples 26
Ran(sigma): set[term] =
{y: term | EXISTS (x: (V)): member(x, Dom(sigma)) & y = sigma(x)}
Sub?(sigma): bool = is_finite(Dom(sigma))
ext(sigma)(t): RECURSIVE term =
CASES t OF
vars(t): sigma(t),
app(f, st): IF length(st) = 0
THEN t
ELSE
LET
sst = (# length := stâ€˜length,
seq := (LAMBDA (n: below[stâ€˜length]):
ext(sigma)(st(n)))#)
IN
app(f, sst)
ENDIF
ENDCASES
MEASURE t BY <<
Declaramos sigma como uma aplicacÂ¸aËœo que leva variaÂ´veis em termos e definimos o
domÄ±Â´nio de sigma, Dom(sigma), como o conjunto das variaÂ´veis cuja imagem por sigma
naËœo saËœo elas mesmas. JaÂ´ Ran(sig) eÂ´ o conjunto imagem de sigma sobre Dom(sigma)
exclusivamente. NoÂ´s dizemos que sigma eÂ´ uma substituicÂ¸aËœo (denotado por Sub?(sigma))
sempre que Dom(sigma) eÂ´ finito. NoÂ´s tambeÂ´m estendemos a aplicacÂ¸aËœo sigma a qualquer
termo t homomorficamente, ou seja, fazemos ext(sigma)(t), sendo que, se t for
funcional, entaËœo aplicamos a extensaËœo da substituicÂ¸aËœo novamente a cada argumento do
termo.
2.7 ReducÂ¸aËœo simples
replaceTerm(s: term, t: term, (p: positions?(s))): RECURSIVE term =
(IF length(p) = 0
THEN
t
ELSE
LET st = args(s),
i = first(p),
q = rest(p),
rst = replace(replaceTerm(st(i-1), t, q), st,i-1) IN
app(f(s), rst)
SecÂ¸aËœo 2.8 â€¢ Ortogonalidade 27
ENDIF)
MEASURE length(p)
O algoritmo replaceTerm(s,t,p) toma o termo s e troca o subtermo da posicÂ¸aËœo
p pelo termo t. Como em subtermOF, replaceTerm trabalha sobre o comprimento de
p. Se p for a posicÂ¸aËœo raiz, entaËœo basta trocar s por t. SenaËœo, s eÂ´ funcional. EntaËœo,
noÂ´s atualizamos um dos argumentos que saËœo aplicados ao sÂ´Ä±mbolo de s e continuamos
trabalhando com o rest(p). A troca feita na sequeË†ncia de argumentos em cada passo eÂ´
realizada por replace.
rewrite_rule?(l,r): bool = (NOT vars?(l)) & subset?(Vars(r), Vars(l))
reduction?(E)(s,t): bool =
EXISTS ( (e | member(e, E)), sigma, (p: positions?(s))):
subtermOF(s, p) = ext(sigma)(lhs(e)) &
t = replaceTerm(s, ext(sigma)(rhs(e)), p)
Temos tambeÂ´m o predicado rewrite rule? que avalia que um par de termos (l,r)
eÂ´ uma regra de reescrita sempre que l naËœo for uma variaÂ´vel e Vars(r) estiver contido em
Vars(l). Enfim, noÂ´s dizemos que reduction?(E)(s,t) sempre que o termo s reduzir
para t com as regras do TRS E, isto eÂ´, se houver uma posicÂ¸aËœo p de s, uma substituicÂ¸aËœo
sigma e uma regra e em E tais que o subtermo de s em p eÂ´ ext(sigma)(lhs(e)) e o
termo resultante t eÂ´ replaceTerm(s, ext(sigma)(rhs(e)), p), onde lhs e rhs saËœo o
lado esquerdo e direito de uma regra respectivamente.
2.8 Ortogonalidade
Essas foram as principais definicÂ¸oËœes utilizadas daquilo que jaÂ´ havia sido realizado
em [6â€“8]. Passamos agora a introduzir o que foi produzido durante o presente trabalho.
O nome da teoria criada para tratar os nossos conceitos e resultados eÂ´ orthogonality.
O teorema que motivou o desenvolvimento da teoria foi o seguinte:
Orthogonal_implies_confluent: LEMMA
FORALL (E : Orthogonal) :
LET RRE = reduction?(E) IN
confluent?(RRE)
No entanto, ainda nos cabe mostrar como definimos o conceito de Orthogonal que
aparece aqui.
SecÂ¸aËœo 2.9 â€¢ DefinicÂ¸oËœes auxiliares 28
Ambiguous?(E): bool = EXISTS (t1, t2) : CP?(E)(t1,t2)
linear?(t): bool = FORALL (x | member(x,Vars(t))) : Card[position](Pos_var(t,x)) = 1
Left_Linear?(E): bool = FORALL (e | member(e, E)) : linear?(lhs(e))
Orthogonal?(E): bool = Left_Linear?(E) & NOT Ambiguous?(E)
Orthogonal: TYPE = (Orthogonal?)
A nocÂ¸aËœo de ambiguidade (Ambiguous?) sobre um sistema de reescrita E dita a
existeË†ncia de dois termos que formem um par crÂ´Ä±tico nesse sistema, como indicamos na
secÂ¸aËœo 1.2. O predicado linear? avalia um termo t quanto a` ocorreË†ncia de suas variaÂ´veis,
tomando cada variaÂ´vel x em Vars(t) e conferindo se a cardinalidade de Pos var(t,x) eÂ´
1. Assim, um sistema eÂ´ dito Left Linear? se o termo do lado esquerdo de cada regra
lhs(e) for linear?. Finalmente, temos que um sistema eÂ´ tido como Orthogonal? se
for Left Linear? e naËœo for Ambiguous?. Orthogonal eÂ´ o tipo de todo sistema que seja
Orthogonal?.
2.9 DefinicÂ¸oËœes auxiliares
Durante a prova do teorema principal, noÂ´s precisamos criar algumas definicÂ¸oËœes que nos
auxiliaraËœo. Elas saËœo mais baÂ´sicas e tratam sequeË†ncias finitas de tipo T instanciaÂ´vel. Como
estamos tratando de tipos polimoÂ´rficos mais uma vez, como na subsecÂ¸aËœo 2.4, precisamos
criar subteorias para tratar conceitos que envolvem um tipo arbitraÂ´rio T. Tal tipo poderaÂ´
ser instanciado como termo, posicÂ¸aËœo, substituicÂ¸aËœo, regra de reescrita e outros, conforme
a convenieË†ncia.
mem_seq(x, seq): RECURSIVE bool =
IF length(seq) = 0 THEN false
ELSIF x = seq(0) THEN true
ELSE mem_seq(x, rest(seq))
ENDIF
MEASURE length(seq)
seq2set(seq): RECURSIVE set[T] =
IF seqâ€˜length = 0 THEN emptyset
ELSE add(seq(0), seq2set(rest(seq)))
ENDIF
MEASURE length(seq)
power(seq,n):
SecÂ¸aËœo 2.10 â€¢ ReducÂ¸aËœo em paralelo 29
RECURSIVE finseq[T] = IF n=0 THEN empty_seq
ELSE seq o power(seq,n-1)
ENDIF MEASURE n
index(seq,x): RECURSIVE nat =
IF seqâ€˜length=0 THEN 0
ELSIF x = seqâ€˜seq(0)
THEN 0
ELSE 1+index(rest(seq),x)
ENDIF MEASURE(seqâ€˜length)
choose_seq(seq:PP, seq1:PP, (seq2 | seq1â€˜length=seq2â€˜length)):
RECURSIVE finseq[T] =
IF length(seq1)=0 THEN empty_seq
ELSIF mem_seq(seq1(0),seq)
THEN add_first(seq2(0),choose_seq(seq,rest(seq1),rest(seq2)))
ELSE choose_seq(seq,rest(seq1),rest(seq2))
ENDIF
MEASURE(length(seq1))
Temos o predicado mem seq, que eÂ´ aplicado a um objeto x de tipo T e uma sequeË†ncia
seq, julgando se x ocorre em seq. A funcÂ¸aËœo power toma a sequeË†ncia seq e a replica n
vezes. JaÂ´ o algoritmo seq2set toma a sequeË†ncia finita seq e a leva no conjunto formado
pelos seus argumentos. O recurso index eÂ´ utilizado para extrair o primeiro Ä±Â´ndice da
sequeË†ncia seq onde ocorre o elemento x. Por outro lado, se x naËœo ocorre em seq, entaËœo
index(seq,x)=length(seq), que naËœo eÂ´ um Ä±Â´ndice de seq.
A funcÂ¸aËœo choose seq por sua vez, toma duas sequeË†ncias finitas de posicÂ¸oËœes paralelas
seq e seq1, aleÂ´m de outra sequeË†ncia seq2 com elementos de tipo T que tenha o
mesmo comprimento de seq1. DaÂ´Ä±, choose seq retorna como saÂ´Ä±da uma sequeË†ncia cujos
argumentos ocorrem em seq2 com os mesmos Ä±Â´ndices dos argumentos de seq1 que ocorrem
em seq, ou seja, verifica-se se cada termo de seq1 ocorre em seq e, quando isso acontecer,
selecionamos o elemento de seq2 com Ä±Â´ndice correspondente a` posicÂ¸aËœo em seq1. EÂ´
interessante perceber que choose seq preserva ordem e, se seq for uma subsequeË†ncia
de seq1, tambeÂ´m preserva comprimento de seq.
2.10 ReducÂ¸aËœo em paralelo
replace_par_pos(s,(fsp:SPP(s)),fse|fseâ€˜length=fspâ€˜length,fss|fssâ€˜length=fspâ€˜length):
RECURSIVE term =
IF length(fsp) = 0
THEN s
SecÂ¸aËœo 2.11 â€¢ Comparadores de sequeË†ncias de posicÂ¸oËœes 30
ELSE replace_par_pos(replaceTerm(s,ext(fss(0))(rhs(fse(0))),fsp(0)),
rest(fsp),rest(fse),rest(fss))
ENDIF
MEASURE length(fsp)
parallel_reduction?(E)(s,t): bool =
EXISTS (fsp: SPP(s),fse|(FORALL(i:below[fseâ€˜length]):member(fseâ€˜seq(i),E)),fss):
fspâ€˜length = fseâ€˜length AND fspâ€˜length = fssâ€˜length
AND (FORALL (i:below[fspâ€˜length]):subtermOF(s,fsp(i))=ext(fss(i))(lhs(fse(i))))
AND t=replace_par_pos(s,fsp,fse,fss)
Esta aplicacÂ¸aËœo replace par pos faz algo parecido com replaceTerm, mas a acÂ¸aËœo se
realiza em vaÂ´rias posicÂ¸oËœes paralelas do mesmo termo e de uma forma mais especÂ´Ä±fica.
Nesse caso, temos uma sequeË†ncia fsp de posicÂ¸oËœes paralelas de s, uma de regras de
reescrita fse e uma de substituicÂ¸oËœes fss, sendo que as treË†s teË†m o mesmo comprimento.
Assim, replace par pos troca o subtermo de s em cada posicÂ¸aËœo de fsp pelo termo que
fica do lado direito de cada regra em fse instanciado com as substituicÂ¸oËœes de fss. As
trocas comecÂ¸am pelo primeiro argumento de cada uma das sequeË†ncias e o passo recursivo
continua trabalhando com o rest. Todo esse trabalho eÂ´ feito para construir a reducÂ¸aËœo
em paralelo que vimos na secÂ¸aËœo 1.2.3. Aqui, ela se chamaraÂ´ parallel reduction?. O
sistema E e os termos relacionados s e t saËœo dados, enquanto que parallel reduction?
deduz a existeË†ncia das sequeË†ncias de posicÂ¸oËœes, de regras e de substituicÂ¸oËœes tais que o lado
esquerdo das regras ocorram em s nas posicÂ¸oËœes correspondentes descritas pela sequeË†ncia
de posicÂ¸oËœes sendo instanciado pelas respectivas substituicÂ¸oËœes, e o termo t seja fruto de
aplicarmos replace par pos a s com essas treË†s sequeË†ncias.
2.11 Comparadores de sequeË†ncias de posicÂ¸oËœes
Ainda que estejamos sempre tratando de sequeË†ncias de posicÂ¸oËœes paralelas, quando
tomamos duas dessas sequeË†ncias, naËœo temos mais a garantia de que as posicÂ¸oËœes
permanecem paralelas. DaÂ´Ä±, podemos particionar as posicÂ¸oËœes de uma dada sequeË†ncia
em relacÂ¸aËœo a outra de acordo com as seguintes aplicacÂ¸oËœes:
sub_pos((fsp : PP), p):
RECURSIVE finseq[position] =
IF length(fsp) = 0 THEN empty_seq[position]
ELSIF p <= fsp(0) AND p /= fsp(0)
THEN add_first(fsp(0), sub_pos(rest(fsp), p))
ELSE sub_pos(rest(fsp), p)
ENDIF
MEASURE length(fsp)
SecÂ¸aËœo 2.11 â€¢ Comparadores de sequeË†ncias de posicÂ¸oËœes 31
Pos_Over((fsp1 : PP), (fsp2 : PP)):
RECURSIVE finseq[position] =
IF length(fsp1) = 0
THEN empty_seq
ELSIF length(sub_pos(fsp2, fsp1(0))) > 0
OR PP?(add_first(fsp1(0), fsp2))
THEN add_first(fsp1(0), Pos_Over(rest(fsp1), fsp2))
ELSE Pos_Over(rest(fsp1), fsp2)
ENDIF
MEASURE length(fsp1)
Pos_Under((fsp1 : PP), (fsp2 : PP)):
RECURSIVE finseq[position] =
IF length(fsp2)=0
THEN empty_seq
ELSE sub_pos(fsp1, fsp2(0)) o Pos_Under(fsp1,rest(fsp2))
ENDIF
MEASURE length(fsp2)
Pos_Equal((fsp1 : PP), (fsp2 : PP)):
RECURSIVE finseq[position] =
IF length(fsp1) = 0 THEN empty_seq
ELSIF mem_seq(fsp1(0),fsp2)
THEN add_first(fsp1(0),Pos_Equal(rest(fsp1),fsp2))
ELSE Pos_Equal(rest(fsp1), fsp2)
ENDIF
MEASURE length(fsp1)
Cada um desses quatro construtores nos daËœo como produto sequeË†ncias de posicÂ¸oËœes
paralelas. Para a funcÂ¸aËœo sub pos, temos como argumentos uma posicÂ¸aËœo p e uma sequeË†ncia
de posicÂ¸oËœes paralelas fsp; para as outras treË†s, temos duas sequeË†ncias de posicÂ¸oËœes paralelas
fsp1 e fsp2 em cada uma. A aplicacÂ¸aËœo sub pos constroÂ´i uma sequeË†ncia com as posicÂ¸oËœes
de fsp que estejam por baixo de p, ou seja, tais que p lhes seja prefixo sem coincidir. A
partir dela, as funcÂ¸oËœes Pos Over e Pos Under comparam as posicÂ¸oËœes das sequeË†ncias fsp1
e fsp2. No caso de Pos Over, seleciona-se as posicÂ¸oËœes de fsp1 tais que sejam paralelas a
todas as posicÂ¸oËœes de fsp2 ou que a sequeË†ncia formada pelo sub pos dessas posicÂ¸oËœes em
fsp1 sobre fsp2 naËœo seja vazia, isto eÂ´, as que estejam por cima de alguma posicÂ¸aËœo de
fsp2. Por outro lado, Pos Under seleciona as posicÂ¸oËœes de fsp1 que estejam por baixo de
cada posicÂ¸aËœo de fsp2. Por fim, temos a aplicacÂ¸aËœo Pos Equal que seleciona as posicÂ¸oËœes de
fsp1 que ocorram em fsp2.
SecÂ¸aËœo 2.12 â€¢ SequeË†ncias de variaÂ´veis 32
2.12 SequeË†ncias de variaÂ´veis
Se noÂ´s temos duas regras num sistema naËœo ambÂ´Ä±guo cujo lado esquerdo estaËœo em
posicÂ¸oËœes naËœo paralelas, noÂ´s sabemos da existeË†ncia de uma variaÂ´vel que se interpoËœe da
forma que seraÂ´ apresentada aqui.
PoreÂ´m, mais do que isso, noÂ´s temos duas sequeË†ncias de regras. HaÂ´ a possibilidade
de que o lado esquerdo de vaÂ´rias regras ocorram no lado esquerdo de outra. Assim,
precisamos organizar as muitas variaÂ´veis, fruto das muitas sobreposicÂ¸oËœes, em uma
sequeË†ncia. As quatro aplicacÂ¸oËœes a seguir nos ajudaraËœo nisso.
set_var(sigma,e,t): set[(V)] =
{x:(V)| subterm(t,sigma(x)) AND Vars(lhs(e))(x)}
seq_var(E:Orthogonal,s,(p:positions?(s)),sigma,
(e|member(e,E) & subtermOF(s,p)=ext(sigma)(lhs(e))),
(fsp:SPP(s)|(FORALL(i:below[fspâ€˜length]):p<=fspâ€˜seq(i))),
fse|fspâ€˜length=fseâ€˜length & (FORALL (i:below[length(fse)]) :
member(fse(i),E)), fss|fspâ€˜length=fssâ€˜length &
(FORALL (i:below[length(fss)]) :
subtermOF(s,fspâ€˜seq(i))=ext(fssâ€˜seq(i))(lhs(fseâ€˜seq(i))))):
RECURSIVE finseq[(V)] =
IF length(fsp)=0 THEN empty_seq
ELSIF nonempty?(set_var(sigma,e,ext(fssâ€˜seq(0))(lhs(fseâ€˜seq(0)))))
THEN add_first(choose(set_var(sigma,e,ext(fssâ€˜seq(0))(lhs(fseâ€˜seq(0))))),
seq_var(E,s,p,sigma,e,rest(fsp),rest(fse),rest(fss)))
ELSE seq_var(E,s,p,sigma,e,rest(fsp),rest(fse),rest(fss))
ENDIF
MEASURE(length(fsp))
O conjunto set var(sigma,e,t) conteÂ´m as variaÂ´veis tais que t seja um subtermo da
instanciacÂ¸aËœo dessas variaÂ´veis pela substituicÂ¸aËœo sigma e tais que ocorram dentro do lado
esquerdo da regra e. Resumindo, caso o termo t seja subtermo de lhs(e), queremos
selecionar as variaÂ´veis cuja instanciacÂ¸aËœo por uma substituicÂ¸aËœo predefinida esteja numa
posicÂ¸aËœo intermediaÂ´ria entre os dois termos. No nosso caso, como as regras trabalhadas
saËœo lineares a` esquerda, se o conjunto formado for naËœo vazio, entaËœo seraÂ´ unitaÂ´rio.
O conceito anterior eÂ´ importante para trabalharmos a definicÂ¸aËœo de seq var, que
eÂ´ muito mais complexa e as condicÂ¸oËœes sobre os argumentos estaËœo mais amarradas.
Primeiramente, consideremos cada entrada dessa funcÂ¸aËœo: um conjunto de regras
ortogonais E; um termo s; uma posicÂ¸aËœo p de s; uma substituicÂ¸aËœo sigma; uma regra
eâˆˆE tal que o subtermo de s em p eÂ´ a instaciacÂ¸aËœo do lado esquerdo de e por sigma;
uma sequeË†ncia fsp de posicÂ¸oËœes paralelas de s, tais que as posicÂ¸oËœes teË†m p como prefixo
SecÂ¸aËœo 2.12 â€¢ SequeË†ncias de variaÂ´veis 33
(estaËœo por baixo de p); uma sequeË†ncia fse de regras em E com o mesmo comprimento
de fsp; uma sequeË†ncia fss de substituicÂ¸oËœes com o mesmo comprimento de fsp tal que,
para cada Ä±Â´ndice da sequeË†ncia, o subtermo de s na posicÂ¸aËœo em fsp eÂ´ uma instanciacÂ¸aËœo
do lado esquerdo da regra em fse pela substituicÂ¸aËœo em fss. A ideia desse construtor eÂ´
a de que, para cada subtermo formado por fss e fse nas posicÂ¸oËœes em fsp, toma-se uma
variaÂ´vel tirada do conjunto set var com argumentos sigma, e e cada subtermo. Sabemos
que esses conjuntos saËœo naËœo vazios, pois todas as regras tratadas pertencem ao sistema
naËœo ambÂ´Ä±guo E. Por outro lado, a sequeË†ncia seq var eÂ´ unicamente determinada pois cada
um desses conjuntos eÂ´ unitaÂ´rio, uma vez que a regra e eÂ´ linear a` esquerda.
seq_var_par(E:Orthogonal,s,(p:positions?(s)),sigma,
(e|member(e,E) & subtermOF(s,p)=ext(sigma)(lhs(e))),
(fsp:SPP(s)|FORALL(i:below[fspâ€˜length]):p<=fspâ€˜seq(i)),
fse|fspâ€˜length=fseâ€˜length & (FORALL (i:below[length(fse)]) :
member(fse(i),E)), fss|fspâ€˜length=fssâ€˜length &
(FORALL (i:below[length(fss)]) :
subtermOF(s,fspâ€˜seq(i))=ext(fssâ€˜seq(i))(lhs(fseâ€˜seq(i))))):
RECURSIVE finseq[(V)] =
IF length(fsp)=0 THEN empty_seq
ELSIF (FORALL (i: below[length(fsp)]):
i/=0 & seq_var(E,s,p,sigma,e,fsp,fse,fss)â€˜seq(0)/=
seq_var(E,s,p,sigma,e,fsp,fse,fss)â€˜seq(i))
THEN add_first(seq_var(E,s,p,sigma,e,fsp,fse,fss)â€˜seq(0),
seq_var_par(E,s,p,sigma,e,rest(fsp),rest(fse),rest(fss)))
ELSE seq_var_par(E,s,p,sigma,e,rest(fsp),rest(fse),rest(fss))
ENDIF
MEASURE(length(fsp))
seq var par utiliza os mesmos argumentos que seq var e teraÂ´ como resultado uma
sequeË†ncia com as mesmas variaÂ´veis que resultam da outra, diferindo pelo fato de eliminar
repeticÂ¸oËœes de variaÂ´veis.
SEQ_VAR_multi(E:Orthogonal,s,(fsp1:SPP(s)),fss1|fss1â€˜length=fsp1â€˜length,
(fse1|FORALL(i:below[fse1â€˜length]):member(fse1â€˜seq(i),E)
& subtermOF(s,fsp1â€˜seq(i))=ext(fss1â€˜seq(i))(lhs(fse1â€˜seq(i)))),
(fsp2:SPP(s)),fse2|fsp2â€˜length=fse2â€˜length &
(FORALL (i:below[length(fse2)]) :
member(fse2(i),E)), fss2|fsp2â€˜length=fss2â€˜length &
(FORALL (i:below[length(fss2)]) :
subtermOF(s,fsp2â€˜seq(i))=ext(fss2â€˜seq(i))(lhs(fse2â€˜seq(i))))):
RECURSIVE finseq[finseq[(V)]] =
IF length(fsp1)=0 THEN empty_seq
SecÂ¸aËœo 2.13 â€¢ Tratamento de sequeË†ncias de posicÂ¸oËœes 34
ELSE add_first(seq_var_par(E,s,fsp1â€˜seq(0),fss1â€˜seq(0),fse1â€˜seq(0),
sub_pos(fsp2,fsp1â€˜seq(0)),
choose_seq(sub_pos(fsp2,fsp1â€˜seq(0)),fsp2,fse2),
choose_seq(sub_pos(fsp2,fsp1â€˜seq(0)),fsp2,fss2)),
SEQ_VAR_multi(E,s,rest(fsp1),rest(fss1),rest(fse1),
fsp2,fse2,fss2))
ENDIF
MEASURE(length(fsp1))
O algoritmo SEQ VAR multi cria uma sequeË†ncia de sequeË†ncias de variaÂ´veis. Toma-
se o primeiro argumento das sequeË†ncias fsp1 de posicÂ¸oËœes, fss1 de substituicÂ¸oËœes e fse1
de regras e aplica-se a seq var par (fsp1â€™seq(0) como a posicÂ¸aËœo, fse1â€™seq(0) como a
regra e fss1â€™seq(0) como a substituicÂ¸aËœo) de forma que se cumpram as condicÂ¸oËœes exigidas
anteriormente. Para que a condicÂ¸aËœo de subtermo seja cumprida tambeÂ´m, como sequeË†ncia
de posicÂ¸oËœes a aplicar-se a seq var par, tomamos sub pos(fsp2,fsp1â€˜seq(0)) e, para
as sequeË†ncias de regras e substituicÂ¸oËœes, utilizamos choose seq para ajustar fse2 e fss2
a sub pos.
2.13 Tratamento de sequeË†ncias de posicÂ¸oËœes
Quando lidamos com duas reducÂ¸oËœes em paralelo sobre o mesmo termo, formando uma
divergeË†ncia, algumas posicÂ¸oËœes de uma das sequeË†ncias de posicÂ¸oËœes podem estar por baixo
de posicÂ¸oËœes da outra sequeË†ncia. Como em cada posicÂ¸aËœo, noÂ´s temos um termo que faz
matching com o lado esquerdo de uma regra dentro de um sistema ortogonal, mesmo
que instanciado por uma substituicÂ¸aËœo, pela secÂ¸aËœo anterior sabemos que existem variaÂ´veis
que se interpoËœem se estiverem em posicÂ¸oËœes naËœo paralelas. No entanto, apoÂ´s a reescrita, as
variaÂ´veis podem assumir diferentes posicÂ¸oËœes no lado direito da regra que a conteÂ´m. Assim,
os subtermos das variaÂ´veis tambeÂ´m se deslocaraËœo.
Os proÂ´ximos construtores tratam as posicÂ¸oËœes dessas sequeË†ncias desmembrando as
posicÂ¸oËœes de variaÂ´veis e concatenando com as novas no lado direito das regras. Vejamos
como isso acontece passo a passo.
complement_pos_set(p1,p): set[position] =
IF p1 <= p & p1 /= p
THEN {p2 | p=p1 o p2}
ELSE emptyset
ENDIF
complement_pos(p,(fsp:PP)):
RECURSIVE finseq[position] =
IF length(fsp)=0 THEN empty_seq
SecÂ¸aËœo 2.13 â€¢ Tratamento de sequeË†ncias de posicÂ¸oËœes 35
ELSIF nonempty?(complement_pos_set(p,fspâ€˜seq(0)))
THEN add_first(choose(complement_pos_set(p,fspâ€˜seq(0))),
complement_pos(p,rest(fsp)))
ELSE complement_pos(p,rest(fsp))
ENDIF
MEASURE(length(fsp))
Temos aqui o conjunto complement pos set(p1,p), que seleciona o complemento de
p1 ateÂ´ p, caso p1 seja prefixo de p e as duas posicÂ¸oËœes naËœo coincidam. Obviamente, se estas
duas condicÂ¸oËœes saËœo atendidas, o conjunto seraÂ´ unitaÂ´rio; caso contraÂ´rio, seraÂ´ vazio. JaÂ´ a
sequeË†ncia complement pos(p,fsp) eÂ´ formada pelo complemento das posicÂ¸oËœes de fsp em
relacÂ¸aËœo a p, caso eles existam. Assim, complement pos eÂ´ o nosso instrumento para cortar
posicÂ¸oËœes.
compo_pos(p,(fsp:PP)): RECURSIVE finseq[position] =
IF length(fsp)=0 THEN empty_seq
ELSE add_first(p o fspâ€˜seq(0),compo_pos(p,rest(fsp)))
ENDIF
MEASURE(length(fsp))
compo_pos_multi(fsp1,fsp2:PP): RECURSIVE finseq[position] =
IF length(fsp1)=0 THEN empty_seq
ELSE compo_pos(fsp1â€˜seq(0),fsp2) o
compo_pos_multi(rest(fsp1),fsp2)
ENDIF
MEASURE(length(fsp1))
compo pos faraÂ´ o contraÂ´rio, concatenando a posicÂ¸aËœo p a cada uma em fsp. Esse
procedimento eÂ´ repetidamente realizado em compo pos multi, que concatena cada posicÂ¸aËœo
de fsp1 a todas as posicÂ¸oËœes de fsp2.
compo_pos_var(s,t,fsv,p,(fsp:PP)): RECURSIVE finseq[position] =
IF length(fsv)=0 THEN empty_seq
ELSIF nonempty?(Pos_var(s,fsvâ€˜seq(0)))
THEN compo_pos(p,compo_pos_multi(set2seq(Pos_var(t,fsvâ€˜seq(0))),
complement_pos(choose(Pos_var(s,fsvâ€˜seq(0))),
complement_pos(p,fsp)))) o
compo_pos_var(s,t,rest(fsv),p,fsp)
ELSE compo_pos_var(s,t,rest(fsv),p,fsp)
ENDIF
MEASURE(length(fsv))
SecÂ¸aËœo 2.13 â€¢ Tratamento de sequeË†ncias de posicÂ¸oËœes 36
Compo_pos_var(fst1:finseq[term],(fst2:finseq[term]|fst1â€˜length=fst2â€˜length),
FSV:finseq[finseq[(V)]]|fst1â€˜length=FSVâ€˜length,
fsp1:PP|fsp1â€˜length=fst1â€˜length,
(fsp2:PP)):
RECURSIVE finseq[position] =
IF length(fsp1)=0 THEN empty_seq
ELSE add_first(compo_pos_var(fst1â€˜seq(0),fst2â€˜seq(0),FSVâ€˜seq(0),
fsp1â€˜seq(0),fsp2),
Compo_pos_var(rest(fst1),rest(fst2),rest(FSV),
rest(fsp1),rest(fsp2)))
ENDIF
MEASURE(length(fsp1))
Nesse momento, os dois tipos de operacÂ¸oËœes saËœo realizadas: o corte e a composicÂ¸aËœo de
posicÂ¸oËœes. Para cada variaÂ´vel na sequeË†ncia fsv, caso esta ocorra no termo s, a funcÂ¸aËœo
compo pos var toma o complemento de uma posicÂ¸aËœo da variaÂ´vel em s ateÂ´ o complemento
de p a uma sequeË†ncia de posicÂ¸oËœes paralelas fsp. Teremos em maËœos o complemento das
posicÂ¸oËœes de fsp dentro da variaÂ´vel. Depois disso, concatenaremos essas posicÂ¸oËœes curtas a`s
posicÂ¸oËœes da variaÂ´vel no outro termo t e, por fim, compomos com a posicÂ¸aËœo p novamente.
compo_rr_var(s,t,fsv,p,(fsp:PP),fse|length(fsp)=length(fse)):
RECURSIVE finseq[rewrite_rule] =
IF length(fsv)=0 THEN empty_seq
ELSIF nonempty?(Pos_var(s,fsvâ€˜seq(0)))
THEN power(choose_seq(sub_pos(fsp,
compo_pos(p,set2seq(Pos_var(s,fsvâ€˜seq(0))))â€˜seq(0)),
fsp,fse),
card(Pos_var(t,fsvâ€˜seq(0))))
o compo_rr_var(s,t,rest(fsv),p,fsp,fse)
ELSE compo_rr_var(s,t,rest(fsv),p,fsp,fse)
ENDIF
MEASURE(length(fsv))
compo_Sub_var(s,t,fsv,p,(fsp:PP),fss|length(fsp)=length(fss)):
RECURSIVE finseq[Sub] =
IF length(fsv)=0 THEN empty_seq
ELSIF nonempty?(Pos_var(s,fsvâ€˜seq(0)))
THEN power(choose_seq(sub_pos(fsp,
compo_pos(p,set2seq(Pos_var(s,fsvâ€˜seq(0))))â€˜seq(0)),
fsp,fss),
card(Pos_var(t,fsvâ€˜seq(0))))
o compo_Sub_var(s,t,rest(fsv),p,fsp,fss)
SecÂ¸aËœo 2.13 â€¢ Tratamento de sequeË†ncias de posicÂ¸oËœes 37
ELSE compo_Sub_var(s,t,rest(fsv),p,fsp,fss)
ENDIF
MEASURE(length(fsv))
Quando noÂ´s tomamos sequeË†ncias de posicÂ¸oËœes formadas por construtores como
Pos Over ou sub pos, que apenas selecionam posicÂ¸oËœes especÂ´Ä±ficas dentro das originais,
eÂ´ faÂ´cil ajustar as sequeË†ncias de substituicÂ¸oËœes e regras que as acompanham atraveÂ´s de
choose seq. PoreÂ´m, isso naËœo vale para compo pos var, pois as posicÂ¸oËœes na sequeË†ncia
resultante saËœo diferentes do que tÂ´Ä±nhamos nas originais. Assim, criamos as aplicacÂ¸oËœes
compo rr var e compo sub var que fazem o ajuste necessaÂ´rio para este tipo especÂ´Ä±fico
de sequeË†ncia de posicÂ¸oËœes, fazendo com que as sequeË†ncias de regras e substituicÂ¸oËœes criadas
pelos respectivos construtores acompanhem os Ä±Â´ndices da sequeË†ncia de posicÂ¸oËœes criada por
compo pos var.
NoÂ´s temos os mesmos argumentos de compo pos var acrescidos de uma sequeË†ncia fse
de regras de reescrita para o caso de compo rr var e fss de substituicÂ¸oËœes para o caso de
compo Sub var, em ambos os casos com o mesmo comprimento da sequeË†ncia de posicÂ¸oËœes
fsp.
NoÂ´s sabemos que complement pos(p,fsp) e sub pos(fsp,p) selecionam as mesmas
posicÂ¸oËœes, com a diferencÂ¸a que o primeiro as quebra e o segundo naËœo. Isso faraÂ´ toda
a diferencÂ¸a, pois usando sub pos, poderemos nos utilizar de choose seq pelos motivos
supra mencionados.
Para cada variaÂ´vel em fsv, tomamos as subposicÂ¸oËœes de fsp em relacÂ¸aËœo a` uma
posicÂ¸aËœo da variaÂ´vel em s. DaÂ´Ä±, ajustamos as regras/substituicÂ¸oËœes que acompanham
essas subposicÂ¸oËœes atraveÂ´s de choose seq. Depois, noÂ´s replicamos essa sequeË†ncia de
regras/substituicÂ¸oËœes pelo nuÂ´mero de ocorreË†ncia da variaÂ´vel no termo t usando a aplicacÂ¸aËœo
power.
Compo_rr_var(fst1,(fst2|fst1â€˜length=fst2â€˜length),
FSV|fst1â€˜length=FSVâ€˜length,fsp1:PP|fsp1â€˜length=fst1â€˜length,
(fsp2:PP),fse|length(fsp2)=length(fse)):
RECURSIVE finseq[rewrite_rule] =
IF length(fsp1)=0 THEN empty_seq
ELSE compo_rr_var(fst1â€˜seq(0),fst2â€˜seq(0),
FSVâ€˜seq(0),fsp1â€˜seq(0),fsp2,fse)
o Compo_rr_var(rest(fst1),rest(fst2),
rest(FSV),rest(fsp1),fsp2,fse)
ENDIF
MEASURE(length(fsp1))
Compo_Sub_var(fst1,(fst2|fst1â€˜length=fst2â€˜length),
SecÂ¸aËœo 2.14 â€¢ SequeË†ncias de termos 38
FSV|fst1â€˜length=FSVâ€˜length,fsp1:PP|fsp1â€˜length=fst1â€˜length,
(fsp2:PP),fss|length(fsp2)=length(fss)):
RECURSIVE finseq[Sub] =
IF length(fsp1)=0 THEN empty_seq
ELSE compo_Sub_var(fst1â€˜seq(0),fst2â€˜seq(0),
FSVâ€˜seq(0),fsp1â€˜seq(0),fsp2,fss)
o Compo_Sub_var(rest(fst1),rest(fst2),
rest(FSV),rest(fsp1),fsp2,fss)
ENDIF
MEASURE(length(fsp1))
As funcÂ¸oËœes Compo rr var e Compo Sub var fazem o mesmo que Compo pos var,
aplicando respectivamente compo rr var e compo Sub var, aos termos da sequeË†ncia fst1
como primeiro termo, os da sequeË†ncia fst2 como segundo termo e a cada sequeË†ncia de
variaÂ´veis dentro de FSV.
Pos_seq_var(s,fsv): RECURSIVE finseq[position]=
IF length(fsv)=0 THEN empty_seq
ELSE set2seq(Pos_var(s,fsvâ€˜seq(0))) o
Pos_seq_var(s,rest(fsv))
ENDIF
MEASURE(length(fsv))
Durante a prova seraÂ´ importante considerar as posicÂ¸oËœes onde variaÂ´veis ocorrem, naËœo
uma a uma (pois jaÂ´ temos o recurso Pos var), mas de todas ao mesmo tempo. Para tanto,
temos Pos seq var(s, fsv), que nos daÂ´ a sequeË†ncia formada pelas posicÂ¸oËœes onde cada
variaÂ´vel da sequeË†ncia fsv ocorre no termo s.
2.14 SequeË†ncias de termos
Ao longo da especificacÂ¸aËœo noÂ´s abordamos e ainda abordaremos sequeË†ncias de termos
como argumento nas nossas funcÂ¸oËœes. No entanto, quando tratamos de reducÂ¸aËœo em paralelo,
as uÂ´nicas sequeË†ncias que surgem saËœo as de posicÂ¸oËœes, substituicÂ¸oËœes e regras de reescrita.
Torna-se fundamental, entaËœo, construir tais sequeË†ncias de termos para que as nossas
ferramentas criadas ateÂ´ agora se tornem uÂ´teis.
left_rewrite_rules(fse): RECURSIVE finseq[term]=
IF length(fse)=0 THEN empty_seq
ELSE add_first(lhs(fseâ€˜seq(0)),left_rewrite_rules(rest(fse)))
ENDIF
MEASURE(length(fse))
SecÂ¸aËœo 2.15 â€¢ SequeË†ncias de substituicÂ¸oËœes 39
right_rewrite_rules(fse): RECURSIVE finseq[term]=
IF length(fse)=0 THEN empty_seq
ELSE add_first(rhs(fseâ€˜seq(0)),right_rewrite_rules(rest(fse)))
ENDIF
MEASURE(length(fse))
Subs_right_rr(fse,(fss|fseâ€˜length=fssâ€˜length)): RECURSIVE finseq[term]=
IF length(fse)=0 THEN empty_seq
ELSE add_first(ext(fssâ€˜seq(0))(rhs(fseâ€˜seq(0))),
Subs_right_rr(rest(fse),rest(fss)))
ENDIF
MEASURE(length(fse))
Os nossos construtores aqui saËœo extremamente simples. O primeiro eÂ´
left rewrite rules, que eÂ´ aplicado a uma sequeË†ncia de regras de reescrita e retorna
uma sequeË†ncia com o termo do lado esquerdo de cada uma. Do mesmo modo,
right rewrite rules retorna o lado direito das regras. JaÂ´ a aplicacÂ¸aËœo Subs right rr
eÂ´ aplicado a duas sequeË†ncias: uma de regras e outra de substituicÂ¸oËœes, as duas com o
mesmo comprimento. Toma-se o termo do lado direito de cada regra e instancia-se com
a substituicÂ¸aËœo correspondente.
2.15 SequeË†ncias de substituicÂ¸oËœes
Quando noÂ´s realizamos uma reducÂ¸aËœo em paralelo, existem sequeË†ncias de posicÂ¸oËœes,
regras e substituicÂ¸oËœes associadas entre si. Mas, quando noÂ´s consideramos duas reducÂ¸oËœes em
paralelo sobre o mesmo termo, pode existir a sobreposicÂ¸aËœo das posicÂ¸oËœes trabalhadas, sendo
que existem regras instanciadas cujo lado esquerdo estaÂ´ dentro do lado esquerdo de uma
outra regra instanciada. Depois que a reescrita eÂ´ feita nas subposicÂ¸oËœes, eÂ´ necessaÂ´rio realizar
a reescrita sobre a regra que as conteÂ´m (o termo maior). Todavia, a antiga substituicÂ¸aËœo
que a instanciava antes naËœo serve mais, pois alguns subtermos foram modificados. Assim,
precisamos criar uma nova substituicÂ¸aËœo que deË† conta de criar o matching do termo maior
com o lado esquerdo da regra instanciada com essa substituicÂ¸aËœo atualizada.
Vamos agora considerar como viabilizaremos isso.
replace_terms(s,fst,(fsp:SPP(s)|fspâ€˜length=fstâ€˜length)): RECURSIVE term =
IF length(fst)=0 THEN s
ELSE replace_terms(replaceTerm(s,fstâ€˜seq(0),fspâ€˜seq(0)),rest(fst),rest(fsp))
ENDIF
MEASURE(fstâ€˜length)
SecÂ¸aËœo 2.15 â€¢ SequeË†ncias de substituicÂ¸oËœes 40
SIGMA(sigma, x, fst, (fsp:SPP(sigma(x))|length(fsp)=length(fst)))(y:(V)):
term = IF length(fst)=0 OR y/=x
THEN sigma(y)
ELSE replace_terms(sigma(x),fst,fsp)
ENDIF
O recurso replace terms nos permite trocar todos os subtermos de s nas posicÂ¸oËœes
paralelas em fsp pelos termos da sequeË†ncia fst. A aplicacÂ¸aËœo SIGMA utilizaraÂ´ o uÂ´ltimo meio
de forma que, quando aplicamos SIGMA(sigma,x,fst,fsp) a uma variaÂ´vel y, teremos a
mesma acÂ¸aËœo de sigma a menos que y seja igual a x. Nesse caso, trocamos todos os
subtermos de sigma(x) nas posicÂ¸oËœes em fsp pelos termos em fst.
SIGMAP(sigma,fsv,(fsp1:PP|fsp1â€˜length=fsvâ€˜length),
fst,(fsp2:PP|fsp2â€˜length=fstâ€˜length))(y:(V)):
RECURSIVE term=
IF length(fsv)=0 THEN sigma(y)
ELSIF y=fsvâ€˜seq(0) &
SP?(sigma(fsvâ€˜seq(0)))(complement_pos(fsp1â€˜seq(0),fsp2))
THEN SIGMA(sigma,fsvâ€˜seq(0),
choose_seq(sub_pos(fsp2,fsp1â€˜seq(0)),fsp2,fst),
complement_pos(fsp1â€˜seq(0),fsp2))(y)
ELSE SIGMAP(sigma,rest(fsv),rest(fsp1),fst,fsp2)(y)
ENDIF
MEASURE(length(fsv))
SIGMAP faz o trabalho de SIGMA em cada variaÂ´vel da sequeË†ncia fsv. Para ajustar as
condicÂ¸oËœes sobre a sequeË†ncia de posicÂ¸oËœes para que estejam dentro da sigma-instanciacÂ¸aËœo
de cada variaÂ´vel, tomamos as posicÂ¸oËœes de fsp2 que tenham complemento em relacÂ¸aËœo a`s
posicÂ¸oËœes em fsp1. A ideia eÂ´ que cada entrada em fsp1 seja posicÂ¸aËœo da variaÂ´vel em um
termo maior. Por enquanto, essa situacÂ¸aËœo naËœo estaÂ´ explÂ´Ä±cita, mas quando estivermos
formalizando as provas, seraÂ´ necessaÂ´rio ter as condicÂ¸oËœes requeridas nos argumentos de
SIGMA.
SIGMA_multi(fsp1:PP,(fss1|fsp1â€˜length=fss1â€˜length),
(FSV:finseq[finseq[(V)]]|fsp1â€˜length=FSVâ€˜length &
FORALL(i:below[FSVâ€˜length]):
FORALL(m,n:below[(FSVâ€˜seq(i))â€˜length]):m/=n
IMPLIES (FSVâ€˜seq(i))â€˜seq(m)/=(FSVâ€˜seq(i))â€˜seq(n)),
(fse1|fsp1â€˜length=fse1â€˜length & (FORALL(i:below[fse1â€˜length]):
Pos_seq_var(lhs(fse1â€˜seq(i)),FSVâ€˜seq(i))â€˜length=(FSVâ€˜seq(i))â€˜length)),
SecÂ¸aËœo 2.15 â€¢ SequeË†ncias de substituicÂ¸oËœes 41
fst,(fsp2:PP|fsp2â€˜length=fstâ€˜length)):
RECURSIVE finseq[Sub]=
IF length(fsp1)=0 THEN empty_seq
ELSE add_first(SIGMAP(fss1â€˜seq(0),FSVâ€˜seq(0),
Pos_seq_var(lhs(fse1â€˜seq(0)),FSVâ€˜seq(0)),
choose_seq(sub_pos(fsp2,fsp1â€˜seq(0)),fsp2,fst),
complement_pos(fsp1â€˜seq(0),fsp2)),
SIGMA_multi(rest(fsp1),rest(fss1),
rest(FSV),rest(fse1),fst,fsp2))
ENDIF
MEASURE(length(fsp1))
Agora temos uma sequeË†ncia de substituicÂ¸oËœes criada por SIGMA multi. Esse construtor
ordenaraÂ´ a aplicacÂ¸aËœo de SIGMAP sobre as substituicÂ¸oËœes em fss1, as sequeË†ncias de variaÂ´veis
em FSV e as posicÂ¸oËœes dessas sequeË†ncias de variaÂ´veis dentro do lado esquerdo de cada regra
em fse1.
Isso completa a nossa especificacÂ¸aËœo das definicÂ¸oËœes que seraËœo nossas ferramentas na
formalizacÂ¸aËœo que desenvolveremos no proÂ´ximo capÂ´Ä±tulo.
CapÂ´Ä±tulo
3
FormalizacÂ¸aËœo
O assistente de provas PVS pode ser utilizado atraveÂ´s dos comandos de prova
apresentados na secÂ¸aËœo 1.1. Abre-se cada teorema num ambiente de demonstracÂ¸aËœo que
organiza as proposicÂ¸oËœes como negativas quando as tomamos como premissas e positivas
quando saËœo teses, da formada apresentada a seguir:
[-1] x=9
[-2] f(x,a) <= 0
[-3] ...
...
|-------
[1] 4 > 9
[2] f(9,a) = 0
[3] ...
...
Como vimos anteriormente, assume-se a conjuncÂ¸aËœo dos itens negativos e busca-se
provar a disjuncÂ¸aËœo da parte positiva, ou seja, assumindo todas as premissas, precisa-se
provar alguma tese. Isso eÂ´ obtido quando podemos aplicar uma regra axiomaÂ´tica, isto eÂ´,
quando ocorre um dos cinco casos:
1. uma premissa coincide com uma tese.
Ex: [-2] x + 3 = 9
|---
[1] x = 6
2. uma premissa eÂ´ obviamente falsa.
Ex: [-1] 0 > 3
3. as premissas se contradizem
Ex: [-1] a <= 8
SecÂ¸aËœo 3.1 â€¢ RTC(reduction?(E)) = RTC(parallel reduction?(E)) 43
[-2] a = b
[-3] b > 12
4. uma tese eÂ´ obviamente verdadeira
Ex: [3] 12 <= 12
5. a uniaËœo de duas ou mais teses englobam todas as possibilidades para um dado objeto
Ex: [1] n <= 1
[2] 2 <= n
Isso nos deixa prontos para falar a respeito da formalizacÂ¸aËœo do teorema que mostra
que TRSâ€™s ortogonais saËœo confluentes. Aqui seguiremos a estrateÂ´gia apresentada na secÂ¸aËœo
1.2.3. Como vimos, a ideia principal eÂ´ provar a propriedade do diamante para a reducÂ¸aËœo
em paralelo (parallel reduction?(E)) para um sistema ortogonal. Como a conflueË†ncia
eÂ´ inferida da propriedade diamante, provando a equivaleË†ncia entre o fecho reflexivo
transitivo da reducÂ¸aËœo em paralelo e da reducÂ¸aËœo usual, temos a prova que procuraÂ´vamos.
3.1 RTC(reduction?(E)) = RTC(parallel reduction?(E))
Para demonstrar a enquivaleË†ncia entre as relacÂ¸oËœes RTC(reduction?(E)) e
RTC(parallel reduction?(E), vamos demonstrar primeiramente as inclusoËœes de
reduction?(E) em parallel reduction?(E) e desta em RTC(reduction?(E)). Isso eÂ´
expressado pelo lema abaixo, que diz que, para quaisquer dois termos t1 e t2 valem as
inclusoËœes mencionadas.
parallel_reduction: LEMMA
(reduction?(E)(t1, t2) => parallel_reduction?(E)(t1, t2))
& (parallel_reduction?(E)(t1, t2) => RTC(reduction?(E))(t1, t2))
A prova quebra-se em duas partes atraveÂ´s do comando split para que se prove cada
uma das inclusoËœes. A primeira eÂ´ mais tranquila de ser provada, como veremos. De fato,
noÂ´s temos:
parallel_reduction.1 :
{-1} reduction?(E)(t1, t2)
|-------
{1} parallel_reduction?(E)(t1, t2)
SecÂ¸aËœo 3.1 â€¢ RTC(reduction?(E)) = RTC(parallel reduction?(E)) 44
Expandindo-se a definicÂ¸aËœo de reduction?(E) com o comando expand noÂ´s inferimos a
existeË†ncia de uma posicÂ¸aËœo, uma regra e uma substituicÂ¸aËœo com as quais se realiza a reducÂ¸aËœo
de t1 para t2. Por outro lado, ao expandirmos a definicÂ¸aËœo de parallel reduction?(E),
precisamos fornecer uma sequeË†ncia de posicÂ¸oËœes, uma de regras e uma de substituicÂ¸oËœes que
realizam a reducÂ¸aËœo dos mesmos termos. EntaËœo, noÂ´s temos:
parallel_reduction.1 :
{-1} EXISTS ((e: rewrite_rule[variable, symbol, arity] | member(e, E)),
sigma: Sub[variable, symbol, arity],
(p: positions?[variable, symbol, arity](t1))):
subtermOF(t1, p) = ext(sigma)(lhs(e)) &
t2 = replaceTerm(t1, ext(sigma)(rhs(e)), p)
|-------
{1} EXISTS (fsp: SPP(t1),
fse: finseq[rewrite_rule]
| FORALL (i: below[fseâ€˜length]): member(fseâ€˜seq(i), E),
fss):
fspâ€˜length = fseâ€˜length AND
fspâ€˜length = fssâ€˜length AND
(FORALL (i: below[fspâ€˜length]):
subtermOF(t1,
finseq_appl[position[variable, symbol, arity]]
(fsp)(i))
=
ext(finseq_appl[Sub[variable, symbol, arity]](fss)(i))
(lhs(finseq_appl[rewrite_rule[variable, symbol, arity]]
(fse)(i))))
AND t2 = replace_par_pos(t1, fsp, fse, fss)
Depois aplicamos o comando skosimp que substitui as variaÂ´veis quantificadas
existencialmente por constantes em {-1} com a regra e!1, a substituicÂ¸aËœo sigma!1 e a
posicÂ¸aËœo p!1. DaÂ´Ä± podemos instanciar {1} com a sequeË†ncia unitaÂ´ria de posicÂ¸aËœo (# length
:= 1, seq := (LAMBDA (n: below[1]): p!1) #) (de comprimento 1 e termos iguais
a p!1), de regra (# length := 1, seq := (LAMBDA (n: below[1]): e!1) #) e de
substituicÂ¸aËœo (# length := 1, seq := (LAMBDA (n: below[1]): sigma!1) #).
No entanto, ao instanciarmos com essas sequeË†ncias, devemos estar certos de que elas
cumprem as condicÂ¸oËœes para a reducÂ¸aËœo em paralelo. DaÂ´Ä± a prova se divide em dois casos
o primeiro onde assumimos que a sequeË†ncia unitaÂ´ria de posicÂ¸aËœo eÂ´ de posicÂ¸oËœes paralelas
do termo t1 e o segundo onde provamos essa tal propriedade. No primeiro caso, temos a
seguinte situacÂ¸aËœo:
SecÂ¸aËœo 3.1 â€¢ RTC(reduction?(E)) = RTC(parallel reduction?(E)) 45
parallel_reduction.1.1 :
[-1] subtermOF(t1, p!1) = ext(sigma!1)(lhs(e!1))
[-2] t2 = replaceTerm(t1, ext(sigma!1)(rhs(e!1)), p!1)
|-------
{1} (FORALL (i: below[1]):
subtermOF(t1,
finseq_appl[position[variable, symbol, arity]]
((# length := 1,
seq := (LAMBDA (n: below[1]): p!1) #))
(i))
=
ext(finseq_appl[Sub[variable, symbol, arity]]
((# length := 1,
seq := (LAMBDA (n: below[1]): sigma!1) #))
(i))
(lhs(finseq_appl[rewrite_rule[variable, symbol, arity]]
((# length := 1,
seq := (LAMBDA (n: below[1]): e!1) #))
(i))))
AND
t2 =
replace_par_pos(t1,
(# length := 1,
seq := (LAMBDA (n: below[1]): p!1) #),
(# length := 1,
seq := (LAMBDA (n: below[1]): e!1) #),
(# length := 1,
seq := (LAMBDA (n: below[1]): sigma!1) #))
Este caso se resolve trivialmente usando o comando grind, que substitui as variaÂ´veis
quantificadas existencialmente por constantes e expande as definicÂ¸oËœes necessaÂ´rias. DaÂ´Ä±,
ele se daÂ´ conta que a uÂ´nica posicÂ¸aËœo a se considerar eÂ´ p!1, a uÂ´nica regra eÂ´ e!1 e a
uÂ´nica substituicÂ¸aËœo eÂ´ sigma!1, aleÂ´m do fato que replace par pos equivale a replaceTerm
quando as sequeË†ncias saËœo unitaÂ´rias. Vamos ao segundo caso.
parallel_reduction.2 :
{-1} parallel_reduction?(E)(t1, t2)
|-------
{1} RTC(reduction?(E))(t1, t2)
SecÂ¸aËœo 3.1 â€¢ RTC(reduction?(E)) = RTC(parallel reduction?(E)) 46
Como parallel reduction? utiliza a aplicacÂ¸aËœo replace par pos, que eÂ´ construÂ´Ä±da
recursivamente sobre o comprimento de uma sequeË†ncia fsp de posicÂ¸oËœes, desejamos
fazer uma prova por inducÂ¸aËœo sobre essa medida. No entanto, quando expandimos a
definicÂ¸aËœo de parallel reduction? apresentada na SecÂ¸aËœo 2.10, fsp aparece quantificada
existencialmente. Isso nos impede de aplicarmos o meÂ´todo de inducÂ¸aËœo diretamente. Assim,
supomos uma proposicÂ¸aËœo onde fsp aparece quantificada universalmente, a partir da qual
seja trivial obtermos a nossa prova. Assim, utilizamos o comando
(case "FORALL (t: term, fsp: SPP(t1), fse: finseq[rewrite_rule] |
(FORALL (i: below[fseâ€˜length]): member(fseâ€˜seq(i), E)),
fss: finseq[Sub]):
(fspâ€˜length = fseâ€˜length & fspâ€˜length = fssâ€˜length &
(FORALL (i: below[fspâ€˜length]): positionsOF(t)(fspâ€˜seq(i))
& subtermOF(t1, fspâ€˜seq(i))
= ext(fssâ€˜seq(i))(lhs(fseâ€˜seq(i)))
& subtermOF(t, fspâ€˜seq(i))
= ext(fssâ€˜seq(i))(lhs(fseâ€˜seq(i)))) &
t2 = replace_par_pos(t, fsp, fse, fss))
=> RTC(reduction?(E))(t, t2)")
De fato, quando expandimos a definicÂ¸aËœo de parallel reduction?, supoËœe-se a
existeË†ncia de sequeË†ncias de posicÂ¸oËœes, regras e substituicÂ¸oËœes que cumprem as hipoÂ´teses
do caso acima. EntaËœo, skolemizamos essa definicÂ¸aËœo com as sequeË†ncias fsp!1, fse!1 e
fss!1 e podemos instanciar o caso quantificado universalmente com o termo t1 e as
sequeË†ncias obtidas. DaÂ´Ä±, obtemos o resultado trivialmente, pois a tese do caso eÂ´ igual a`
tese do sequente (RTC(reduction?(E))(t, t2)).
Por outro lado, temos o caso quantificado universalmente como tese. Assim, podemos
aplicar inducÂ¸aËœo sobre o comprimento da sequeË†ncia fsp de posicÂ¸oËœes atraveÂ´s do comando
(measure-induct+ "fspâ€˜length" "fsp"), que skolemiza a sequeË†ncia com o nome x!1.
Primeiramente, supomos o caso em que o comprimento de x!1 eÂ´ igual a zero e escondemos
as proposicÂ¸oËœes desnecessaÂ´rias aqui.
parallel_reduction.2.2.1.1 :
[-1] length(x!1) = 0
[-2] x!1â€˜length = fse!1â€˜length
[-3] x!1â€˜length = fss!1â€˜length
[-4] t2 = replace_par_pos(t!1, x!1, fse!1, fss!1)
|-------
[1] RTC(reduction?(E))(t!1, t2)
SecÂ¸aËœo 3.1 â€¢ RTC(reduction?(E)) = RTC(parallel reduction?(E)) 47
Expandindo a definicÂ¸aËœo de replace par pos, temos que t2 = t!1. Por outro lado,
expandindo RTC, precisamos mostrar que existe um nuÂ´mero de iteracÂ¸oËœes de reduction?(E)
em que t!1 atinge t2. Isso eÂ´ trivial, pois t!1 atinge t2 em 0 passos.
Agora, temos o oposto: a sequeË†ncia x!1 de posicÂ¸oËœes naËœo tem comprimento zero. O
objetivo eÂ´ provar que a propriedade vale para x!1 supondo que a propriedade vale para
uma sequeË†ncia com comprimento menor que o de x!1.
parallel_reduction.2.2.1.2 :
[-1] FORALL (y: SPP[variable, symbol, arity](t1)):
FORALL (t: term,
fse: finseq[rewrite_rule]
| (FORALL (i: below[fseâ€˜length]):
member(fseâ€˜seq(i), E)),
fss: finseq[Sub]):
yâ€˜length < x!1â€˜length IMPLIES
(yâ€˜length = fseâ€˜length &
yâ€˜length = fssâ€˜length &
(FORALL (i: below[yâ€˜length]):
positionsOF(t)(yâ€˜seq(i)) &
subtermOF(t1, yâ€˜seq(i)) =
ext(fssâ€˜seq(i))(lhs(fseâ€˜seq(i)))
&
subtermOF(t, yâ€˜seq(i)) =
ext(fssâ€˜seq(i))(lhs(fseâ€˜seq(i))))
& t2 = replace_par_pos(t, y, fse, fss))
=> RTC(reduction?(E))(t, t2)
[-2] x!1â€˜length = fse!1â€˜length
[-3] x!1â€˜length = fss!1â€˜length
[-4] FORALL (i: below[x!1â€˜length]):
positionsOF(t!1)(x!1â€˜seq(i)) &
subtermOF(t1, x!1â€˜seq(i)) = ext(fss!1â€˜seq(i))(lhs(fse!1â€˜seq(i))) &
subtermOF(t!1, x!1â€˜seq(i)) = ext(fss!1â€˜seq(i))(lhs(fse!1â€˜seq(i)))
[-5] t2 = replace_par_pos(t!1, x!1, fse!1, fss!1)
|-------
[1] length(x!1) = 0
[2] RTC(reduction?(E))(t!1, t2)
EntaËœo, instanciamos [-1] com rest(x!1), replaceTerm(t!1, ext(fss!1â€˜seq(0))
(rhs(fse!1â€˜seq(0))), x!1â€˜seq(0)), rest(fse!1) e rest(fss!1) e aplicamos o
comando (prop) que quebraraÂ´ a prova em vaÂ´rios casos, sendo o primeiro supondo a tese
SecÂ¸aËœo 3.1 â€¢ RTC(reduction?(E)) = RTC(parallel reduction?(E)) 48
RTC(reduction?(E))(replaceTerm(t!1, ext(fss!1â€˜seq(0)) (rhs(fse!1â€˜seq(0))),
x!1â€˜seq(0)), t2) e os outros saËœo as premissas da proposicÂ¸aËœo [-1]. As
propriedades principais que precisamos provar eÂ´ que a composicÂ¸aËœo reduction?(E) o
RTC(reduction?(E)) eÂ´ igual a RTC(reduction?(E)) e que replaceTerm comuta com
replace par pos desde que as posicÂ¸oËœes de trocas sejam paralelas.
EntaËœo, noÂ´s concluimos a prova anterior e partimos para a proÂ´xima, que eÂ´ provar a
equivaleË†ncia propriamente dita entre os fechos reflexivo transitivos de reduction?(E!1)
e de parallel reduction?(E!1).
parallel_reduction_RTC :
|-------
{1} RTC(reduction?(E!1)) = RTC(parallel_reduction?(E!1))
Para provarmos essa equivaleË†ncia, na verdade precisamos mostrar que ela vale para
qualquer par de termos. Assim, noÂ´s podemos introduzir um par de termos arbitraÂ´rios
para que se possa provar a igualdade atraveÂ´s do comando (decompose-equality).
DaÂ´Ä±, terÂ´Ä±amos a igualdade de proposicÂ¸oËœes RTC(reduction?(E!1))(x!1, x!2) =
RTC(parallel reduction?(E!1))(x!1, x!2), que quer dizer que uma soÂ´ acontece se,
e somente se, a outra acontece. EntaËœo, podemos transformar a igualdade no conectivo
loÂ´gico IFF atraveÂ´s do comando (iff). Depois disso, podemos quebrar a prova em dois
casos principais com (split), demonstrando as duas implicacÂ¸oËœes.
parallel_reduction_RTC.1 :
{-1} RTC(reduction?(E!1))(x!1, x!2)
|-------
{1} RTC(parallel_reduction?(E!1))(x!1, x!2)
Sabemos que RTC supoËœe a existeË†ncia de um nuÂ´mero de iteracÂ¸oËœes da relacÂ¸aËœo
correspondente em que o primeiro termo atinge o segundo. O nosso objetivo eÂ´ fazer
uma prova indutiva, mas como no outro lema, a quantificacÂ¸aËœo existencial nos impede de
assim o fazer. Logo, assumimos um caso onde o nuÂ´mero de passos esteja quantificado
universalmente e pelo qual seja oÂ´bvio atingir a nossa prova.
Nesse primeiro ramo, o caso assumido eÂ´ (case
"FORALL (t1, t2: term, i: nat): iterate(reduction?(E!1), i)(t1, t2) =>
RTC(parallel reduction?(E!1))(t1, t2)"). Aplicamos, entaËœo, inducÂ¸aËœo sobre i.
SecÂ¸aËœo 3.1 â€¢ RTC(reduction?(E)) = RTC(parallel reduction?(E)) 49
[-1] iterate(reduction?(E!1), 0)(t1, t2)
|-------
[1] RTC(parallel_reduction?(E!1))(t1, t2)
Na base de inducÂ¸aËœo, noÂ´s temos que provar que um termo t1 que atinge t2 em zero
passos de reduction?(E!1) deve atingir t2 tambeÂ´m em algum nuÂ´mero de passos de
parallel reduction?(E!1). Mas isso eÂ´ faÂ´cil de provar pois [-1] mostra que t1 = t2 e,
assim, t1 atinge t2 em zero passos de parallel reduction?(E!1).
parallel_reduction_RTC.1.2.2 :
[-1] FORALL (t1, t2: term):
iterate(reduction?(E!1), j)(t1, t2) =>
RTC(parallel_reduction?(E!1))(t1, t2)
{-2} iterate(reduction?(E!1), j + 1)(t1, t2)
|-------
{1} RTC(parallel_reduction?(E!1))(t1, t2)
Assumimos que podemos atingir RTC(parallel reduction?(E!1)) com j iteracÂ¸oËœes
de reduction?(E!1) e precisamos provar que o mesmo eÂ´ conseguido com j + 1 passos.
Primeiramente, utilizamos o lema iterate add one que quebra a iteracÂ¸aËœo de {-2} no
primeiro passo de reduction?(E!1) concatenado com os outros j passos da relacÂ¸aËœo. Isso
significa que expusemos um termo y!1 na cadeia entre t1 e t2. AleÂ´m disso, agora podemos
utilizar a hipoÂ´tese de inducÂ¸aËœo e temos RTC(parallel reduction?(E!1))(y!1, t2).
parallel_reduction_RTC.1.2.2 :
{-1} iterate(reduction?(E!1), j)(y!1, t2) =>
RTC(parallel_reduction?(E!1))(y!1, t2)
[-2] reduction?(E!1)(t1, y!1)
[-3] iterate(reduction?(E!1), j)(y!1, t2)
|-------
[1] RTC(parallel_reduction?(E!1))(t1, t2)
No entanto, ainda naËœo temos a propriedade para o par de termos (t1, t2). O que
noÂ´s podemos fazer eÂ´ utilizar o lema parallel reduction, que provamos anteriormente,
e obter parallel reduction?(E!1)(t1, y!1)) de {-2}. DaÂ´Ä±, utilizamos outro lema da
biblioteca ars que mostra que um passo de uma relacÂ¸aËœo composto com RTC da relacÂ¸aËœo
equivale ao RTC da relacÂ¸aËœo.
SecÂ¸aËœo 3.2 â€¢ Orthogonal implies confluent 50
Por outro lado, ao provar RTC(parallel reduction?(E!1))(x!1, x!2) IMPLIES
RTC(reduction?(E!1))(x!1, x!2), nos utilizamos da mesma estrateÂ´gia de supor um
caso onde o nuÂ´mero de iteracÂ¸oËœes de parallel reduction?(E!1) aparece instanciado
universalmente. Usamos esse caso para fechar esse ramo da prova, mas temos de provar
que ele eÂ´ verdadeiro. Para tanto, aplicamos inducÂ¸aËœo sobre esse nuÂ´mero de iteracÂ¸oËœes e
obtemos o seguinte sequente:
parallel_reduction_RTC.2.2.2 :
[-1] FORALL (t1, t2: term):
iterate(parallel_reduction?(E!1), j)(t1, t2) =>
RTC(reduction?(E!1))(t1, t2)
{-2} iterate(parallel_reduction?(E!1), j + 1)(t1, t2)
|-------
{1} RTC(reduction?(E!1))(t1, t2)
Novamente, noÂ´s podemos explicitar o termo intermediaÂ´rio y!1 que ocorre na cadeia
de reducÂ¸oËœes entre os termos t1 e t2. Assim, utilizando o lema iterate add one
como no primeiro ramo da prova, noÂ´s obtemos parallel reduction?(E!1)(t1, y!1)
e iterate(parallel reduction?(E!1), j)(y!1, t2). AtraveÂ´s do lema anterior,
sabemos que RTC(reduction?(E!1))(t1, y!1). AleÂ´m disso, utilizando a hipoÂ´tese de
inducÂ¸aËœo em [-1], sabemos que RTC(reduction?(E!1))(y!1, t2). Finalmente, pela
transitividade de RTC(reduction?(E!1)), concluÂ´Ä±mos que RTC(reduction?(E!1))(t1,
t2).
Dessa forma, alcancÂ¸amos o resultado que esperaÂ´vamos de equivaleË†ncia entre o fecho
reflexivo transitivo das duas relacÂ¸oËœes.
3.2 Orthogonal implies confluent
Na verdade, esse teorema eÂ´ um corolaÂ´rio dos dois lemas anteriores e de um terceiro
cuja prova seraÂ´ mostrada posteriormente (a reducÂ¸aËœo em paralelo tem a propriedade do
diamante).
A prova segue como no teorema 1.2.3.
Orthogonal_implies_confluent: LEMMA
FORALL (E : Orthogonal) :
LET RRE = reduction?(E) IN
confluent?(RRE)
SecÂ¸aËœo 3.3 â€¢ parallel reduction is DP 51
De fato, expandindo a definicÂ¸aËœo de confluent?, noÂ´s temos que provar o seguinte
sequente:
Orthogonal_implies_confluent :
[-1] RTC(reduction?(E!1))(x, y)
[-2] RTC(reduction?(E!1))(x, z)
|-------
{1} EXISTS (z_1: term[variable, symbol, arity]): RTC(reduction?(E!1))(y, z_1)
& RTC(reduction?(E!1))(z, z_1)
NoÂ´s usamos o lema parallel reduction RTC e obtemos que RTC(reduction?(E!1))
= RTC(parallel reduction?(E!1)). DaÂ´Ä±, provar a existeË†ncia de tal termo z 1 para a
relacÂ¸aËœo reduction?(E!1) equivale a provaÂ´-la para parallel reduction?(E!1).
NoÂ´s invocamos o lema parallel reduction is DP em
que a relacÂ¸aËœo parallel reduction?(E!1) tem a propriedade do diamante sempre que
E!1 for ortogonal.
No arcaboucÂ¸o encontrado em [1], jaÂ´ tÂ´Ä±nhamos os resultados DP implies StC
e Strong Confl implies Confl, ou seja, a propriedade do diamante implica em
parallel reduction?(E!1) fortemente confluente e isso implica em conflueË†ncia, como
querÂ´Ä±amos.
Orthogonal_implies_confluent :
{-1} RTC(parallel_reduction?(E!1))(y, z!1)
{-2} RTC(parallel_reduction?(E!1))(z, z!1)
[-3] strong_confluent?(parallel_reduction?(E!1))
[-4] diamond_property?(parallel_reduction?(E!1))
[-5] RTC(reduction?(E!1)) = RTC(parallel_reduction?(E!1))
[-6] RTC(reduction?(E!1))(x, y)
[-7] RTC(reduction?(E!1))(x, z)
|-------
[1] RTC(reduction?(E!1))(y, z!1) & RTC(reduction?(E!1))(z, z!1)
Expandindo a definicÂ¸aËœo de conflueË†ncia novamente, encontramos um termo z!1 para o
qual vale a propriedade e encerramos a prova com o comando (assert).
3.3 parallel reduction is DP
Se noÂ´s desejamos provar que a reducÂ¸aËœo em paralelo tem a propriedade diamante,
como vimos na secÂ¸aËœo 1.2.1, precisamos mostrar que, para uma dada divergeË†ncia
SecÂ¸aËœo 3.3 â€¢ parallel reduction is DP 52
parallel reduction?(E)(s,t1) & parallel reduction?(E)(s,t2), onde s, t1 e
t2 saËœo termos, existe um termo u tal que parallel reduction?(E)(t1,u) &
parallel reduction?(E)(t2,u). DaÂ´Ä±, para provar que, de fato, a reducÂ¸aËœo em paralelo
acontece, devemos fornecer sequeË†ncias de posicÂ¸oËœes, de regras e de substituicÂ¸oËœes tais como
na secÂ¸aËœo 2.10.
O teorema 1.2.4 mostra qual a estrutura desse termo u. Ou seja, ao final, precisamos
apresentar um termo em que todos os triaË†ngulos coloridos vazados foram trocados por
triaË†ngulos preenchidos.
As sequeË†ncias fsp!1, fse!1 e fss!1 de posicÂ¸oËœes, regras e substituicÂ¸oËœes que aparecem
a seguir saËœo referentes a` reducÂ¸aËœo de s a t1. Da mesma forma, fsp!2, fse!2 e fss!2 saËœo
as sequeË†ncias da reducÂ¸aËœo de s a t2. O termo a seguir eÂ´ o que noÂ´s buscamos.
replace_par_pos(t1, Pos_Over(fsp!2,fsp!1) o
Compo_pos_var(left_rewrite_rules(choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fse!1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fse!1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp!1,fsp!2),
choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fss!1),
choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fse!1),
fsp!2,fse!2,fss!2),
Pos_Over(fsp!1,fsp!2),fsp!2),
choose_seq(Pos_Over(fsp!2,fsp!1),fsp!2,fse!2)
o Compo_rr_var(left_rewrite_rules(choose_seq(Pos_Over(fsp!1,fsp!2),
fsp!1,fse!1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp!1,fsp!2),
fsp!1,fse!1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp!1,fsp!2),
choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fss!1),
choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fse!1),
fsp!2,fse!2,fss!2),
Pos_Over(fsp!1,fsp!2),fsp!2,fse!2),
SIGMA_multi(Pos_Over(fsp!2,fsp!1),
choose_seq(Pos_Over(fsp!2,fsp!1),fsp!2,fss!2),
SEQ_VAR_multi(E,s,Pos_Over(fsp!2,fsp!1),
choose_seq(Pos_Over(fsp!2,fsp!1),fsp!2,fss!2),
choose_seq(Pos_Over(fsp!2,fsp!1),fsp!2,fse!2),
fsp!1,fse!1,fss!1),
choose_seq(Pos_Over(fsp!2,fsp!1),fsp!2,fse!2),
Subs_right_rr(fse!1,fss!1),fsp!1)
o Compo_Sub_var(left_rewrite_rules(choose_seq(Pos_Over(fsp!1,fsp!2),
fsp!1,fse!1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp!1,fsp!2),
fsp!1,fse!1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp!1,fsp!2),
SecÂ¸aËœo 3.3 â€¢ parallel reduction is DP 53
choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fss!1),
choose_seq(Pos_Over(fsp!1,fsp!2),fsp!1,fse!1),
fsp!2,fse!2,fss!2),
Pos_Over(fsp!1,fsp!2),fsp!2,fss!2))
O termo eÂ´ construÂ´Ä±do a partir da aplicacÂ¸aËœo de replace par pos sobre o termo t1 e as
treË†s sequeË†ncias de posicÂ¸oËœes, de regras e de substituicÂ¸oËœes.
Ao instanciarmos a prova com o termo acima algumas propriedades sobre essas
sequeË†ncias devem ser demonstradas para que fechemos o resultado. Os ramos de prova saËœo
automaticamente gerados pelo PVS ao fazer a instanciacÂ¸aËœo. Algumas dessas propriedades
jaÂ´ foram demonstradas em outros lemas e outras permanecem em aberto em conjecturas
separadas. Dos resultados em aberto, quase todos seguem o tipo de prova realizada em
resultados jaÂ´ fechados. Apenas o uÂ´ltimo resultado da SecÂ¸aËœo 3.3.2 deveraÂ´ ter um tratamento
diferenciado e tambeÂ´m se desdobraraÂ´ em alguns outros lemas.
3.3.1 Resultados demonstrados
Em relacÂ¸aËœo a` aplicacÂ¸aËœo choose seq, noÂ´s precisamos provar a conservacÂ¸aËœo do
comprimento das sequeË†ncias e a preservacÂ¸aËœo do Ä±Â´ndice. Abaixo noÂ´s temos alguns
resultados, mas podemos considerar tambeÂ´m as propriedades espelhadas, ou seja, trocar
fsp!1 por fsp!2, fse!1 por fse!2 e fss!1 por fss!2 e vice-versa. Precisamos considerar
tambeÂ´m que Pos Over seleciona uma subsequeË†ncia.
- Pos_Over(fsp!1, fsp!2)â€˜length =
choose_seq(Pos_Over(fsp!1, fsp!2), fsp!1, fse!1)â€˜length
- FORALL (i:below[choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fse!2)â€˜length]):
E(choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fse!2)â€˜seq(i))
- FORALL (i:below[choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fse!2)â€˜length]):
subtermOF(x, Pos_Over(fsp!2, fsp!1)â€˜seq(i)) =
ext(choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fss!2)â€˜seq(i))
(lhs(choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fse!2)â€˜seq(i)))
- FORALL (i: below[Pos_Over(fsp!1, fsp!2)â€˜length]):
mem_seq(Pos_Over(fsp!1, fsp!2)â€˜seq(i), fsp!1)
As aplicacÂ¸oËœes SEQ VAR multi, SIGMA multi, left rewrite rules e Subs right rr
tambeÂ´m preservam comprimento.
- Pos_Over(fsp!1, fsp!2)â€˜length
= SEQ_VAR_multi(E, s, Pos_Over(fsp!1, fsp!2),
choose_seq(Pos_Over(fsp!1, fsp!2), fsp!1, fss!1),
SecÂ¸aËœo 3.3 â€¢ parallel reduction is DP 54
choose_seq(Pos_Over(fsp!1, fsp!2), fsp!1, fse!1),
fsp!2, fse!2, fss!2)â€˜length
- Pos_Over(fsp!2, fsp!1)â€˜length
= SIGMA_multi(Pos_Over(fsp!2, fsp!1),
choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fss!2),
SEQ_VAR_multi(E, s, Pos_Over(fsp!2, fsp!1),
choose_seq(Pos_Over(fsp!2, fsp!1),fsp!2,fss!2),
choose_seq(Pos_Over(fsp!2, fsp!1),fsp!2,fse!2),
fsp!1, fse!1, fss!1),
choose_seq(Pos_Over(fsp!2, fsp!1), fsp!2, fse!2),
Subs_right_rr(fse!1, fss!1), fsp!1)â€˜length
- Pos_Over(fsp!1, fsp!2)â€˜length =
left_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2), fsp!1, fse!1))â€˜length
- fsp!2â€˜length = Subs_right_rr(fse!2, fss!2)â€˜length
JaÂ´ o comprimento de Compo pos var eÂ´ preservado por Compo rr var e Compo Sub var.
- Compo_pos_var(left_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1)),
SEQ_VAR_multi(E, s, Pos_Over(fsp!1, fsp!2),
choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fss!1),
choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1),
fsp!2, fse!2, fss!2),
Pos_Over(fsp!1, fsp!2), fsp!2)â€˜length =
Compo_rr_var(left_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1)),
SEQ_VAR_multi(E, s, Pos_Over(fsp!1, fsp!2),
choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fss!1),
choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1),
fsp!2, fse!2, fss!2),
Pos_Over(fsp!1, fsp!2), fsp!2, fse!2)â€˜length =
Compo_Sub_var(left_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1)),
SEQ_VAR_multi(E, s, Pos_Over(fsp!1, fsp!2),
choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fss!1),
choose_seq(Pos_Over(fsp!1, fsp!2),fsp!1,fse!1),
fsp!2, fse!2, fss!2),
Pos_Over(fsp!1, fsp!2), fsp!2, fss!2)â€˜length
Temos que Pos seq var conserva o comprimento de SEQ VAR multi. Isso quer dizer
muito, pois temos de usar a linearidade da regra da posicÂ¸aËœo em Pos Over(fsp1,fsp2)
e a naËœo ambiguidade do sistema E, provando que set var (presente na definicÂ¸aËœo de
SEQ VAR multi) eÂ´ um conjunto unitaÂ´rio.
SecÂ¸aËœo 3.3 â€¢ parallel reduction is DP 55
- Pos_seq_var(lhs(choose_seq(Pos_Over(fsp1, fsp2), fsp1, fse1)â€˜seq(i)),
SEQ_VAR_multi(E, s, Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2, fse2, fss2)â€˜seq(i))â€˜length =
(SEQ_VAR_multi(E, s, Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fss1),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fse1),
fsp2, fse2, fss2)â€˜seq(i))â€˜length
Sabemos que as variaÂ´veis que ocorrem em uma determinada sequeË†ncia dentro de
SEQ VAR multi saËœo todas diferentes. Isso eÂ´ extremamente importante considerando a
definicÂ¸aËœo de SIGMA multi na secÂ¸aËœo 2.15, que exige essa naËœo repeticÂ¸aËœo de variaÂ´veis na
sequeË†ncia.
- (SEQ_VAR_multi(E, s, Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fss1),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fse1),
fsp2, fse2, fss2)â€˜seq(i))â€˜seq(m) /=
(SEQ_VAR_multi(E, s, Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fss1),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fse1),
fsp2, fse2, fss2)â€˜seq(i))â€˜seq(n)
TambeÂ´m destacamos que a funcÂ¸aËœo replace par pos, que realiza a reducÂ¸aËœo em paralelo
propriamente dita, possui uma independeË†ncia na ordem em que se tomam as posicÂ¸oËœes
a serem reduzidas. Pela definicÂ¸aËœo, ela toma primeiramente a posicÂ¸aËœo com Ä±Â´ndice 0. No
entanto, como podemos ver no resultado seguinte, caso fsp seja uma sequeË†ncia de posicÂ¸oËœes
paralelas, podemos tomar um outro Ä±Â´ndice n qualquer da sequeË†ncia, continuar reduzindo
nas posicÂ¸oËœes restantes e ainda assim obter o mesmo termo final.
- replace_par_pos(replaceTerm(s, ext(fss(n))(rhs(fse(n))), fsp(n)),
delete(fsp,n), delete(fse,n), delete(fss,n))
= replace_par_pos(s,fsp,fse,fss)
Esse uÂ´ltimo lema eÂ´ extremamente importante considerando que tomamos posicÂ¸oËœes
especÂ´Ä±ficas ao construir o termo de juntabilidade para o problema.
SecÂ¸aËœo 3.3 â€¢ parallel reduction is DP 56
3.3.2 Resultados axiomatizados
O primeiro resultado em aberto eÂ´ que, nas posicÂ¸oËœes em que fsp!2 estaÂ´ por cima de
fsp!1, o subtermo de t1 eÂ´ a mesma regra de fse!2 que se tinha originalmente instanciada
com a substituicÂ¸aËœo atualizada por SIGMAP.
- subtermOF(t1, Pos_Over(fsp2,fsp1)â€˜seq(i)) =
ext(SIGMAP(choose_seq(Pos_Over(fsp2,fsp1),fsp2,fss2)â€˜seq(i),
seq_var_par(E, s, Pos_Over(fsp2,fsp1)â€˜seq(i),
choose_seq(Pos_Over(fsp2,fsp1),fsp2,fss2)â€˜seq(i),
choose_seq(Pos_Over(fsp2,fsp1),fsp2,fse2)â€˜seq(i),
sub_pos(fsp1,Pos_Over(fsp2,fsp1)â€˜seq(i)),
choose_seq(sub_pos(fsp1,Pos_Over(fsp2,fsp1)â€˜seq(i)),fsp1,fse1),
choose_seq(sub_pos(fsp1,Pos_Over(fsp2,fsp1)â€˜seq(i)),fsp1,fss1)),
Pos_seq_var(lhs(choose_seq(Pos_Over(fsp2,fsp1),fsp2,fse2)â€˜seq(i)),
seq_var_par(E,s,Pos_Over(fsp2,fsp1)â€˜seq(i),
choose_seq(Pos_Over(fsp2,fsp1),fsp2,fss2)â€˜seq(i),
choose_seq(Pos_Over(fsp2,fsp1),fsp2,fse2)â€˜seq(i),
sub_pos(fsp1,Pos_Over(fsp2,fsp1)â€˜seq(i)),
choose_seq(sub_pos(fsp1,Pos_Over(fsp2,fsp1)â€˜seq(i)),
fsp1,fse1),
choose_seq(sub_pos(fsp1,Pos_Over(fsp2,fsp1)â€˜seq(i)),
fsp1,fss1))),
choose_seq(sub_pos(fsp1,Pos_Over(fsp2,fsp1)â€˜seq(i)),
fsp1,Subs_right_rr(fse1, fss1)),
complement_pos(Pos_Over(fsp2,fsp1)â€˜seq(i), fsp1)))
(lhs(choose_seq(Pos_Over(fsp2,fsp1),fsp2,fse2)â€˜seq(i)))
Tomemos agora um subtermo numa posicÂ¸aËœo em que fsp!1 estaÂ´ por cima de fsp!2, ou
seja, eÂ´ prefixo de alguma posicÂ¸aËœo em fsp!2. Quando reduzimos s para t1, sabemos que
as regras de fse!2 instanciadas com fss!2 que estaËœo por baixo desse termo mudaram de
posicÂ¸aËœo devido ao movimento das variaÂ´veis durante a reescrita. Vimos que essas novas
posicÂ¸oËœes saËœo descritas por Compo pos var e as regras e substituicÂ¸oËœes que a acompanham
por Compo rr var e Compo Sub var respectivamente. Precisamos provar que, de fato,
essas duas uÂ´ltimas preservam o Ä±Â´ndice da primeira, mostrando que os subtermos de t1 nas
posicÂ¸oËœes de Compo pos var saËœo o lado esquerdo das regras em Compo rr var instanciadas
com Compo Sub var. TambeÂ´m devemos provar que as regras em Compo rr var continuam
sendo as regras do sistema ortogonal E.
- subtermOF(t1,Compo_pos_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),
fsp1,fse1)),
SecÂ¸aËœo 3.3 â€¢ parallel reduction is DP 57
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),
fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2), fsp2)â€˜seq(i)) =
ext(Compo_Sub_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2), fsp2, fss2)â€˜seq(i))
(lhs(Compo_rr_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),
fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),
fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2), fsp2, fse2)â€˜seq(i)))
- E(Compo_rr_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
SEQ_VAR_multi(E, s, Pos_Over(fsp1,fsp2),
choose_seq(Pos_Over(fsp1,fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1,fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1,fsp2),fsp2,fse2)â€˜seq(i))
A relacÂ¸aËœo de paralelismo eÂ´ mantida por Compo pos var. PoreÂ´m, mais do que isso,
a composicÂ¸aËœo desta sequeË†ncia com Pos Over(fsp2, fsp1) permanece sendo de posicÂ¸oËœes
paralelas do termo t1.
- SPP?(t1)(Pos_Over(fsp2, fsp1) o
Compo_pos_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2), fsp2))
SecÂ¸aËœo 3.3 â€¢ parallel reduction is DP 58
Outro resultado importante eÂ´ provar que o construtor SIGMAP de fato define uma
substituicÂ¸aËœo. Observando a acÂ¸aËœo dele eÂ´ faÂ´cil ver que a sua acÂ¸aËœo se restringe a variaÂ´veis,
pois ele toma como base uma outra substituicÂ¸aËœo e modifica a acÂ¸aËœo sobre um nuÂ´mero finito
de variaÂ´veis especÂ´Ä±ficas. Como podemos ver na secÂ¸aËœo 2.6, uma substituicÂ¸aËœo deve ser uma
aplicacÂ¸aËœo que leva variaÂ´veis em termos e que tem o domÄ±Â´nio finito. Assim, a afirmacÂ¸aËœo
acima justifica esse resultado. Abaixo, noÂ´s colocamos sigma, fsv, fsp1, fst e fsp2 como
argumentos arbitraÂ´rios que satisfazem as condicÂ¸oËœes na secÂ¸aËœo 2.15.
- Sub?(SIGMAP(sigma,fsv,fsp1,fst,fsp2))
Finalmente, precisamos provar que essas sequeË†ncias de posicÂ¸oËœes, regras e substituicÂ¸oËœes
realmente levam t1 e t2 ao mesmo termo. Observemos abaixo que as sequeË†ncias
responsaÂ´veis por reescrever t2 saËœo um espelho das sequeË†ncias que reduzem t1, isto eÂ´,
trocamos simplesmente fsp1 por fsp2, fse1 por fse2, fss1 por fss2 e vice-versa, como
falamos anteriormente.
- replace_par_pos(t1,
Pos_Over(fsp2, fsp1) o
Compo_pos_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2),fsp2),
choose_seq(Pos_Over(fsp2, fsp1), fsp2, fse2) o
Compo_rr_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2),fsp2,fse2),
SIGMA_multi(Pos_Over(fsp2, fsp1),choose_seq(Pos_Over(fsp2, fsp1),fsp2,fss2),
SEQ_VAR_multi(E,s,Pos_Over(fsp2, fsp1),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fss2),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2),
fsp1,fse1,fss1),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2),
Subs_right_rr(fse1, fss1), fsp1) o
SecÂ¸aËœo 3.3 â€¢ parallel reduction is DP 59
Compo_Sub_var(left_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
right_rewrite_rules(choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1)),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
Pos_Over(fsp1, fsp2),fsp2,fss2)) =
replace_par_pos(t2, Pos_Over(fsp1, fsp2) o
Compo_pos_var(left_rewrite_rules(choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2)),
right_rewrite_rules(choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2)),
SEQ_VAR_multi(E,s,Pos_Over(fsp2, fsp1),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fss2),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2),
fsp1,fse1,fss1),
Pos_Over(fsp2, fsp1),fsp1),
choose_seq(Pos_Over(fsp1, fsp2), fsp1, fse1) o
Compo_rr_var(left_rewrite_rules(choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2)),
right_rewrite_rules(choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2)),
SEQ_VAR_multi(E,s,Pos_Over(fsp2, fsp1),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fss2),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2),
fsp1,fse1,fss1),
Pos_Over(fsp2, fsp1),fsp1,fse1),
SIGMA_multi(Pos_Over(fsp1, fsp2),choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
SEQ_VAR_multi(E,s,Pos_Over(fsp1, fsp2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fss1),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
fsp2,fse2,fss2),
choose_seq(Pos_Over(fsp1, fsp2),fsp1,fse1),
Subs_right_rr(fse2, fss2), fsp2) o
Compo_Sub_var(left_rewrite_rules(choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2)),
right_rewrite_rules(choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2)),
SEQ_VAR_multi(E,s,Pos_Over(fsp2, fsp1),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fss2),
choose_seq(Pos_Over(fsp2, fsp1),fsp2,fse2),
fsp1,fse1,fss1),
Pos_Over(fsp2, fsp1),fsp1,fss1))
O uÂ´ltimo resultado da secÂ¸aËœo anterior seraÂ´ fundamental na formalizacÂ¸aËœo desta igualdade,
por ditar a independeË†ncia da ordem das posicÂ¸oËœes a serem reduzidas por replace par pos,
desde que sejam paralelas, o que eÂ´ o nosso caso.
CapÂ´Ä±tulo
4
ConclusaËœo
4.1 ConsideracÂ¸oËœes Finais
Durante o desenvolvimento do presente trabalho, foi proposta a teoria orthogonality
como uma expansaËœo para a teoria trs, sendo esta uÂ´ltima apresentada em [2, 6, 7] e
disponÂ´Ä±vel em [1]. Pode-se observar os passos de especificacÂ¸aËœo e formalizacÂ¸aËœo desenvolvidos
com o objetivo de provar o teorema de que TRSâ€™s ortogonais teË†m a propriedade de
conflueË†ncia.
No trabalho apresentado em [10], o criteÂ´rio de ortogonalidade fraca eÂ´ utilizado para
garatir conflueË†ncia aplicando a ferramenta de certificacÂ¸aËœo Certified Termination Analysis
(CeTA). Este criteÂ´rio diz respeito a` ortogonalidade incluindo a possibilidade de pares
crÂ´Ä±ticos triviais, ou seja, haÂ´ a sobreposicÂ¸aËœo de regras, mas elas divergem para o mesmo
termo. Embora este resultado implique na conflueË†ncia de sistemas ortogonais, o que foi
apresentado naËœo se trata de formalizacÂ¸aËœo, mas de certificacÂ¸aËœo. AteÂ´ onde se sabe naËœo
haÂ´ trabalhos apresentados que mencionem o objetivo de formalizar tal teorema em um
assistente de prova de ordem superior, o que eÂ´ o nosso caso.
A especificacÂ¸aËœo e formalizacÂ¸aËœo construÂ´Ä±das seguem a ideia proposta na prova analÂ´Ä±tica,
o que torna a prova bastante diagramaÂ´tica. A estrateÂ´gia de prova foi adotada visando
reduzir o problema da existeË†ncia de um termo de juntabilidade para o Teorema 1.2.4
simplesmente para a verificacÂ¸aËœo de propriedades sobre as funcÂ¸oËœes recursivas criadas na
SecÂ¸aËœo 2.2, o que gerou uma seÂ´rie de resultados cujas provas saËœo indutivas, sendo a maior
parte jaÂ´ formalizada e algums lemas ainda permanecem axiomatizados, como mencionado
no final da secÂ¸aËœo anterior.
De fato, trabalhar com teoremas de existeË†ncia indutivamente pode tornar-se
extremamente complicado uma vez que a hipoÂ´tese de inducÂ¸aËœo nos daÂ´ um termo de
juntabilidade cujas peculiaridades de comprimento das sequeË†ncias necessaÂ´rias (posicÂ¸oËœes,
regras e substituicÂ¸oËœes) e da localizacÂ¸aËœo das posicÂ¸oËœes reduzidas saËœo desconhecidas e naËœo
SecÂ¸aËœo 4.1 â€¢ ConsideracÂ¸oËœes Finais 61
conseguimos proceder ao passo indutivo por esse caminho diretamente. Por isso, optamos
por descrever exatamente o termo de juntabilidade do lema parallel reduction is DP
conforme apresentado na SecÂ¸aËœo 3.3. NaËœo queremos dizer que a abordagem indutiva
diretamente dentro dessa prova principal naËœo seja uma opcÂ¸aËœo, mas exige um estudo
diferenciado para que o passo indutivo possa ser efetivado.
PoË†de-se experimentar vaÂ´rias estrateÂ´gias de prova como, por exemplo, por inducÂ¸aËœo
sobre a medida de sequeË†ncias, por absurdo, definicionais e outras. Obteve-se a construcÂ¸aËœo
de vaÂ´rios conceitos naËœo triviais, aleÂ´m da formalizacÂ¸aËœo de lemas sobre eles. Houve
tambeÂ´m a boa integracÂ¸aËœo entre a teoria principal orthogonality e as subteorias com
tipos polimoÂ´rficos que nos daËœo as ferramentas chose seq, power, seq2set e mem seq,
amplamente utilizadas. Isso pode ser afirmado uma vez que a grande maioria das
definicÂ¸oËœes que utilizam os conceitos das subteorias importadas tiveram as obrigacÂ¸oËœes de
prova geradas pelo PVS formalizadas, excluindo unicamente a prova de que o construtor
SIGMAP da SecÂ¸aËœo 2.15 gera, de fato, uma substituicÂ¸aËœo, o que jaÂ´ discutimos ser verdade
quando estudamos o domÄ±Â´nio da funcÂ¸aËœo gerada.
Um enfraquecimento do teorema principal foi realizado acrescentando a hipoÂ´tese de
linearidade a` direita, o que significa que naËœo ambiguidade e linearidade (tanto a` direita
quanto a` esquerda) geram um TRS confluente. A prova fora mais simples e foi um bom
objeto de estudo para nos familiarizarmos com a demonstracÂ¸aËœo do teorema de conflueË†ncia
dos sistemas ortogonais. Este resultado fora formalizado completamente em 2010 e foi
apresentado em [9].
Atualmente o desenvolvimento completo consiste em 40 definicÂ¸oËœes, 84 lemas
formalizados e 8 axiomas distribuÂ´Ä±dos em cerca 1300 linhas de especificacÂ¸aËœo e,
adicionalmente, 46000 linhas de provas. Dos 8 axiomas assumidos, 7 devem ser lemas
fechados com uma relativa facilidade devido a` semelhancÂ¸a semaË†ntica com outros resultados
jaÂ´ demonstrados. A prova do uÂ´ltimo resultado apresentado na SecÂ¸aËœo 3, que trata da
equivaleË†ncia da acÂ¸aËœo da funcÂ¸aËœo replace par pos atraveÂ´s de dois conjuntos de argumentos
especÂ´Ä±ficos, eÂ´ o nosso objetivo mais desafiador e ainda deve se desdobrar em alguns outros
lemas intermediaÂ´rios.
O PVS, sendo um assistente de prova com loÂ´gica de ordem superior, foi a ferramenta
escolhida por tratar esses resultados sobre relacÂ¸oËœes de reescrita quaisquer de um modo
natural, lidando assim com objetos de segunda ordem. Isso implica consequentemente que
o PVS daÂ´ um bom suporte para tratar corretude, completude e restricÂ¸oËœes de integridade
das especificacÂ¸oËœes de objetos computacionais especificados atraveÂ´s de regras de reescrita.
Dos lemas formalizados, destacamos treË†s resultados importantes dentro da teoria
orthogonality:
â€¢ primeiramente, provamos a equivaleË†ncia entre o fecho reflexivo transitivo da reescrita
usual e o da reescrita em paralelo. Isso foi realizado provando a inclusaËœo da
SecÂ¸aËœo 4.2 â€¢ SugestoËœes para Pesquisas Futuras 62
reescrita usual na reescrita em paralelo, o que eÂ´ trivial, e da reescrita em paralelo
no fecho reflexivo transitivo da reescrita usual, fazendo uma prova indutiva sobre o
comprimento da sequeË†ncia de posicÂ¸oËœes responsaÂ´vel pela reescrita em paralelo.
â€¢ demonstrou-se tambeÂ´m a propriedade do diamante para a reescrita em paralelo
num TRSs ortogonal. Esse resultado necessitou de uma seÂ´rie de lemas auxiliares
teÂ´cnicos para mostrar que o termo de juntabilidade fornecido atende a`s condicÂ¸oËœes
necessaÂ´rias. Todo o ferramental utilizado estaÂ´ descrito na SecÂ¸aËœo 2.2, e as principais
condicÂ¸oËœes exigidas na prova estaËœo na SecÂ¸aËœo 3.3. Alguns dos lemas auxiliares foram
axiomatizados. Citamos, por exemplo, que necessita-se mostrar que as aplicacÂ¸oËœes
compo pos var, compo rr var e compo Sub var preservam ordem entre si. No
entanto, a maior parte dos lemas foi formalizada como, por exemplo, a preservacÂ¸aËœo
de comprimento e ordem por choose seq e a independeË†ncia da ordem de reducÂ¸aËœo
por replace par pos.
â€¢ por uÂ´ltimo, reuniram-se dois lemas da teoria ars aos dois itens anteriores para
mostrar que ortogonalidade implica em conflueË†ncia. Sabe-se que a propriedade do
diamante acarreta na propriedade Church-Rosser, que eÂ´ equivalente a` conflueË†ncia.
Assim, mostramos que a reescrita em paralelo eÂ´ confluente a partir do item anterior
e isso eÂ´ igual a` conflueË†ncia da reescrita usual, pelo primeiro item.
4.2 SugestoËœes para Pesquisas Futuras
Para que o teorema de conflueË†ncia para TRSâ€™s ortogonais seja, de fato, certificado, eÂ´
necessaÂ´rio apresentar as demonstracÂ¸oËœes para os resultados axiomatizados. Assim, sugere-
se como trabalho futuro:
â€¢ a conclusaËœo da formalizacÂ¸aËœo da forma como foi apresentada (demonstracÂ¸aËœo dos lemas
axiomatizados);
â€¢ o estudo de um caminho alternativo para tratar a prova de
parallel reduction is DP de forma indutiva diretamente;
â€¢ a formalizacÂ¸aËœo de outras condicÂ¸oËœes para conflueË†ncia e/ou terminacÂ¸aËœo no contexto
de TRSâ€™s;
â€¢ partir para outros contextos computacionais importantes como a Teoria de Tipos e
realizar um trabalho semelhante a` das teorias trs e ars, que formam um arcaboucÂ¸o
robusto para a formalizacÂ¸aËœo de teoremas relevantes.
RefereË†ncias BibliograÂ´ficas
[1] Theory trs, (consulted January 2012): Available in the NASA LaRC PVS library,
http://shemesh.larc.nasa.gov/fm/ftp/larc/PVS-library/pvslib.html. 1, 19,
51, 60
[2] A. B. Avelar, F. L. C. de Moura, A. L. Galdino, and M. Ayala-RincoÂ´n, Verification
of the completeness of unification algorithms a` la robinson, WoLLIC 2010, 2010,
pp. 110â€“124. 1, 19, 60
[3] Franz Baader and Tobias Nipkow, Term rewriting and All That, Cambridge
University Press, 1998. 2, 13
[4] M. Bezem, J.W. Klop, and R. de Vrijer, Term rewriting systems by TeReSe,
Cambridge Tracts in Theoretical Computer Science, no. 55, Cambridge University
Press, 2003. 2, 13
[5] A. L. Galdino and M. Ayala-RincoÂ´n, A formalization of newmanâ€™s and yokouchi
lemmas in a higher-order language, Journal of Automated Reasonning 1 (2008),
no. 1, 39â€“50. 1, 2
[6] , A PVS theory for term rewriting systems, Electronic Notes in Theoretical
Computer Science 247 (2009), 67â€“83, Third Workshop on Logical and Semantic
Frameworks, with Applications - LSFA 2008. 1, 2, 19, 27, 60
[7] , A formalization of the Knut-Bendix(-Huet) critical pair theorem, Journal of
Automated Reasonning 45 (2010), no. 3, 301â€“325. 1, 19, 27, 60
[8] A.L. Galdino and M. Ayala-RincoÂ´n, A Theory for Abstract Rewriting Systems in
PVS, Proc. XXXIII CLEI, 2007, pp. 1â€“16. 2, 27
[9] A. C. R. Oliveira and M. Ayala-RincoÂ´n, On the formalization of confluence of
orthogonal rewriting systems in PVS, EBL 2011, 2011, p. 15. 1, 2, 61
REFEREË†NCIAS BIBLIOGRAÂ´FICAS 64
[10] R. Thiemann, Certification of confluence proofs using CeTA, First International
Workshop on Confluence (IWC 2012), 2012, p. 45. 60
