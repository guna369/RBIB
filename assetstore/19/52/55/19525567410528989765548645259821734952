Theoretical Computer Science 121 (1993) 145-167 
Elsevier 
145 
An of Biihm’s theorem 
GCrard Huet 
Dom. de Voluceau-Rocquencourt, INRIA, B.P. 105. F-78153 Le Chesnay Cedex, France 
Abstract 
Huet, G., An analysis of Biihm’s theorem, Theoretical Computer Science 121 (1993) 145-167. 
In this article we present a detailed analysis of Biihm’s theorem, explained completely constructively 
as an algorithmic development in the functional language ML. 
1. Introduction 
In this article we analyse an important result of I-calculus, the separability theorem, 
first proved by Biihm in 1968 [2]. The descriptive formalism used is not the usual 
meta-language of Mathematics, but an actual programming language of the ML 
family, more specifically CAML V3.1, developed in Project Formel at INRIA Roc- 
quencourt [7]. This has the advantages of being more rigorous, more constructive and 
of allowing better understanding by the reader who may interactively execute all 
definitions and examples. This article is adapted from the notes for a graduate course 
taught at UniversitC Paris VII [9]. 
This paper may be considered an implementation of the following suggestion, 
quoted from Biihm’s original paper [2]: “I1 metodo di dimostrazione per il teorema 1 e’ 
costruttivo, percio’ suggerisce di per se’ un algoritmo per la costruzione delle formule”. 
I .I. I-calculus: abstract syntax 
We give here our notations for pure A-calculus. In the usual presentation of 
A-expressions, there are three constructors: variables such as x, applications of an 
expression el to an expression e2, written (el es), and finally functional abstraction 
of an expression ex over a variable x considered as its formal parameter, traditionally 
Correspondence to: G. Huet, Dom. de Voluceau-Rocquencourt, INRIA, B.P. 105, F-78153 Le Chesnay 
Cedex, France. Email: Gerard.Huet@mirsa.inria.fr. 
0304-3975/93/$06.00 0 1993-Elsevier Science Publishers B.V. All rights reserved 
146 G. Huet 
written Ax. ex, but for which we shall use the notation [x] ex. This notation stands for 
the algorithm which computes the value of expression ex, given an input argument x. 
We shall use this notation for our concrete syntax, for instance to present examples. 
But we avoid the difficulties of renaming, such as cc-conversion, by considering an 
abstract syntax of terms, where variables are not represented as actual identifier 
strings, but rather as reference indexes identifying canonically their binding abstrac- 
tor, in the spirit of de Bruijn’s representation [S]: 
#type term= 
# Ref of int (* variables as reference depth *) 
# 1 Abs of term (* abstraction [x] M *) 
# 1 App of term* term (* application (MN) *);; 
Type term is defined 
Let us comment on the three constructors of type term. App (M, N) represents the 
application of function M to argument N. If M is an expression containing a free 
variable x, then the function which associates M to its formal argument x, noted [x] M 
in concrete syntax, is represented abstractly as Abs(M). Finally, a Ref(n) construct 
designates an occurrence of the variable declared in the nth Abs binder above it. 
Every term M is meaningful in a minimum context depth min_context 
-depth(M): 
#let min-context-depth M=min_rec 0 M 
# where ret min_rec n=function 
# Ref(m) + m-n+ 1 
# 1 Abs(M) + min_rec (n+ 1) M 
# 1 App(M,N) -+ max (min_rec n M) (min_rec n N);; 
Value min_context_depth is (fun) : term + int 
We say that term M is closed if its minimum context depth is 0. We shall also call 
combinator a closed term. The closure of a term M is the closed term closure(M) 
defined as follows: 
#let closure M=iterate abstract (min_context-depth M) M 
# where abstract M = Abs (M);; 
Value closure is (fun) : term + term. 
We assume that a parser of closed il-expressions has been defined. This permits the 
translation of a concrete syntax expression, enclosed between quotation marks 
(( and)), into an abstract syntax ML value of type term: 
#<[Xl (x CYI (XY))>K 
(Abs (App ((Ref 0), (Abs (App ((Ref l), (Ref 0))))))) : term 
Analysis of Bdhm’s theorem 
We also assume an ERROR routine which raises a qualified exception. 
#let ERROR message= raise failure (message);; 
Value ERROR is (fun) : string + ‘a 
147 
Let us give as examples a few standard combinators following: 
##let I=<[xlx> (* Identity *) 
#and (* Constant generator *) 
#andS=Ux,~,xl composition *) 
#andA=<[f,xl(fx)> Application *) 
(lxl(f(xx)) 
projection *) 
#and FaIse=<Cx,yly>> projection *) 
#and Pair=<Cx,y,pl(pxy)> conditional *) 
#and Omega=~([xl(xx)[xl(xx>>>>;; (* Undefined *) 
Value I is (Abs (Ref 0)) : term 
Value K is (Abs (Abs (Ref 1))) : term 
Value S is . . : term 
. . . 
1.2. Substitution 
L-calculus is a calculus of substitutions. The fundamental computation primitive 
consists in replacing a position of some redex App(Abs(M), N) by the result of 
substituting N to the first free variable of M, defined as (subst NM) as follows. This 
operation consists of two steps. We need to recursively explore M in order to find 
occurrences of the substituted variable. Then, for each such occurrence, we need to 
copy N, suitably adjusted so that its own free variables are correctly bound. This task 
is performed by function (lift n), which recomputes references of global variables 
across n extra levels of abstraction. 
#let lift n=lift_rec 0 
#where ret lift_rec k=lift_k 
#where ret lift_k=function 
# Ref(i) + if i< k then Ref(i) (* bound variables are invariant *) 
# else Ref(n+ i) (* free variables are relocated by n *) 
# 1 Abs(M) --t Abs(lift_rec (k+ 1) M) 
# I APPWN) + App(lift_k M, lift-k N);; 
Value lift is (fun) : int -i term + term 
148 G. Huet 
For instance: 
#lift 1 (Abs (App(Ref 0, Ref 1)));; 
(Abs (App ((Ref 0), (Fief 2)))): term 
Here is the inverse of (lift 1): 
# exception OCCURS-FREE ;; 
Exception OCCURS-FREE is defined 
#let unliftl =unlift_check 0 
# where ret unlift_check n=function 
# Ref(i) + if i= n then raise OCCURS-FREE 
# else if i<n then Ref(i) else Ref(i- 1) 
# I Abs(W + Abs (unlift_check (n-c 1) M) 
# 1 App(M,N) -+App(unlift_check n M, unlift_check n N);; 
Value unliftl is (fun) : term-+term 
Thus unliftl (lift 1 M) ) = M for every term M. 
We now give the substitution function. We substitute N for Ref(0) in M by (subst 
NM). The typical case is the P-redex ([ x]M N), which reduces to (subst NM). 
#let subst N= subst_NO 
#where ret subst_N n= function 
# Ref(k) + ifk=nthenliftnN (* substituted variable *) 
# else if k< n then Ref (k) (* bound variables *) 
# else Ref(pred(k)) (* free variables *) 
# 1 Abs(M) + Abs(subst_N (n+ 1) M) 
# I APP(M,M’) + App (subst_N n M, subst_N nM’);; 
Value subst is (fun) : term + term + term 
For instance, we get: 
#subst (Abs(Ref 0)) (Abs(App(Ref 0,Ref 1)));; 
(Abs(App((Ref 0), (Abs(Ref 0))))):term 
Now that substitution problems are understood, we shall generally deal in our 
examples with concrete syntax. Thus, from now on, we ask ML to pretty-print values 
of type term with a printer which prints such values as I-expressions. The above 
example now yields: 
# let (Abs M) = (( [x, y](y x)> in subst I M;; 
[x0] (x0 [x11x1) : term 
Analysis of Biihm’s theorem 149 
1.3. /J-reduction 
The main computation rule of A-calculus, called /?-reduction, consists in replacing 
a redex, i.e. a subexpression of the form ( [x]M N), by subst N M. Thus, one step of 
P-reduction of term M at redex position u is obtained by beta-reduce M u). 
We need first to define the datatype of positions. Positions are lists of the successive 
directions along the path leading to the position. The directions are F which indicates 
that we traverse an abstraction, and A(L) (resp. A(R)) which indicates that we 
traverse an application to the left (resp. to the right). 
#type sibling= L 1 R 
#and direction= F 1 A of sibling 
# and position= direction list;; 
Type sibling is defined 
Type direction is defined 
Type position is defined 
The subterm of term M at position u is computed as subterm (M, u): 
#let ret subterm= function 
# (s, [I> +e 
# 1 (Abs(e), F::u) + subterm (8, u) 
# 1 (App(e,_), A(L)::u) + subterm (e,u) 
# I (App(_, e), A(R) ::u) +subterm (e,u) 
# I- +ERROR “Position not in domain” ;; 
Value subterm is (fun) : term * position + term 
Similarly, the result of replacing the subterm at position u of term M by term N is 
replace N (M, u): 
#let replace N= rep_rec 
#where ret rep_rec = function 
# (-9 [I> +N 
# 1 (Abs(e), F::u) +Abs (rep_rec (e,u)) 
# I (App(l,r), A(L)::u) -App (rep-ret (l,u),r) 
# 1 (App(l,r), A(R)::u) -APP (1, rep-ret (r,u)) 
# l- -ERROR “Position not in domain” ;; 
Value replace is (fun) : term -+ term * position --t term 
We are now ready to define the result of reducing the fi-redex at position u in term M: 
#let beta-reduce M u=match subterm (M,u) with 
# App (Abs(body), arg) -+replace (subst arg body) (M,u) 
+I I- + ERROR “Position not a beta redex” ;; 
Value reduce is (fun) : term -+ position + term 
150 G. Huet 
1.4. Head normal form 
A head normal form is any term M of the form [xl, . . . , xn] (x Ml . . . Mp), with 
n, p 2 0. Note that if M reduces to N by B-reduction, then N is of the form [xl, . . . , xn] 
(x Nl . . . Np). Thus n, x and p are invariant by /?-reduction. 
Remark 1.1. Every term is either a head normal form, or of the form: [xl, . . . ,xn] 
@Ml... Mp), with R a redex. In this last case R is called the head redex of the term. 
We now reduce a A-term to its head normal form, when it has one, with the function 
hnf below. It uses the normal order of evaluation, which reduces redexes in the 
leftmost-outermost order. 
#let ret hnf=function 
# Ref(n) + Ref(n) 
# 1 Abs(M) +Abs(bnfM) 
# 1 App(Ml,M2) -+ match hnf(M1) with 
# Abs(N) + hnf(subst M2 N) 
# I h + &w(h, M2);; 
Value hnf is (fun) : term + term 
For instance: 
#hnf< ( [Xl[Yl(X(Y x)) l-ul(uu) [vl[wl v)>;; 
[x0] (xOxO):term 
We say that a I-term M is dejined iff hnf(M) terminates. Since hnfuses the normal 
order of evaluation, if (M N) is defined, so is M. Similarly, if [x] M is defined, so is M. 
Furthermore, when M is defined, the normal reduction issued from M has an initial 
sequence which reduces M to N= hnf(M) and N is the first head normal form in this 
reduction sequence. 
1 S. Normal form 
A normalform is a term which is not reducible. The normalizable terms are those for 
which the normal reduction procedure nf below terminates. This results from the 
standardization theorem. 
# let ret nf= function 
# Ref(n) + Ref(n) 
# 1 Abs(M) + Abs(nf M) 
# I App(M1, M2) + match hnf(M1) with 
# Abs(N) + nf (subst M2 N) 
# I h -+ App (nf h, nf MZ);; 
Value nf is (fun) : term -+ term 
Analysis of Biihm’s theorem 151 
1.6. Extensionality: q-conversion 
The rule of q-conversion is a syntactic version of the property of extensionality. It is 
consistent with the interpretation of I-terms as denoting functions. v-conversion is 
explained as the congruence closure of a second reduction rule, traditionally called 
q-reduction. 
An q-redex is a subterm of the form [x](N x), with x not appearing free in N. 
q-reduction consists in replacing this subterm by N. In abstract form, we replace 
Abs(App(lift 1 N, Ref 0)) by N. The symmetric relation is called q-expansion. 
Finally, q-conversion is the congruence closure of q-reduction. 
#let eta-reduce Id u= match subterm (M, u) with 
# Abs(App(N,Ref(O))) -(try replace (unliftl N) (M,u) 
# with OCCURS_FREE + ERROR “Position not an eta redex”) 
# I- + ERROR “Position not an eta redex” ;; 
Value eta-reduce is (fun) : term -+ position + term 
1.7. Biihm trees 
We shall now see how to compute progressively successive approximations of 
a term, in a potentially infinite partial structure called the Biihm tree of the A-term, 
which represents the limit of all /?-reductions issued from a given term. It consists of 
layers of approximations, each approximation corresponding to a head-normal form. 
First of all we shall profit from the additional structure of head normal forms to 
represent variables in a better way. Every variable is represented by a double key 
Index (k, i), where k addresses upwards the hnf layer where the variable is declared, 
while i indexes in the corresponding list of bound variables in a left-to-right fashion. 
Thus in [xl, x2,. . . , xn] xi (. .) the head variable xi is represented as Index (0, i). 
Note that this representation of head variables is invariant by head q-expansion. 
#type v&r = Index of int * int;; 
Type var is defined 
We now define the type of Bijhm tree approximants. 
#type bohm= Hnf of int * v&r * bohm list 
# 1 Future of term;; 
Type bohm is defined 
There are two kinds of nodes in a BGhm tree approximant: Hnfnodes, where an hnf 
approximation has been computed, and Future nodes, containing a A-term waiting to 
be examined. When this term is undefined the tree cannot be grown further in this 
direction. Thus, Future(M) plays the role of a syntactic “bottom” meaning “not yet 
152 G. Huet 
defined”. Any term may be transformed into a Biihm tree approximant by “delaying” 
it with the constructor Future: 
#let delay M = Future (M);; 
Value delay is (fun) : term + bohm 
We now compute one level of approximation, evaluating a (defined) term into an 
Hnf form. The extra argument display of function approx contains a stack of natural 
numbers intended to hold the successive arities along a Biihm tree branch. The 
auxiliary function lookup translates a Ref index m into an Index var, using a display. 
#let lookup m display= look (0, m) display 
#where ret look (k, j) = function 
# [I + ERROR “Variable not in scope of display” 
# 1 n::rest + if j> =n then look (k+l, j-n) rest 
# else Index (k, n-j);; 
Value lookup is (fun) : int + int list -+ var 
# let approx display M = apx (0, [I) M 
# (* n counts the outside abstractions, args stacks the applicands *) 
# where ret apx (n, args) = function 
# Ref(m) -+ Hnf (n, lookup m (n:: display), map delay args) 
# 1 Abs(M) + (match args with 
# Cl -+ apx (n+ 1, [I> M 
# ( N::rest -, apx (n, rest) (subst NM) 
# 1 App(M,N) --f apx(n,N::args) M;; 
Value approx is (fun) : int list + term -P bohm 
# let approximate = approx [I;; 
Value approximate is (fun) : term + bohm 
We get a tree in Hnf form by function evaluate, given a display: 
#let evaluate display= function 
# Future(M) --f approx display M 
# In -+ h;; 
Value evaluate is (fun) : int list -+ bohm + bohm 
Examples 1.2. Let us consider the Loop combinator, defined as the application of 
combinator Y to the term [x, y] (yx); The symbol n below is anti-quotation: it allows 
a previously defined term, bound to an ML identifier xxx, to be inserted in a concrete 
expression as Axxx. 
#let Loop=<(^Y [el[xl(x e))>>;; 
Value Loop is 
([x0] ([xl] (x0 (xl xl)) [xl] (x0 (xl xl))) [xO,xl](xl xO)):term 
Analysis of Biihm’s theorem 153 
#let BTl = approximate Loop;; 
Value BTl is 
Hnf( 1, (Index (0, l)), 
[Future [x0]([x1,x2](x2 xl) (x0 x0)) [x0] ([x1,x2] (x2 xl) 
(xOxO))]):bohm 
#let BT2=let (Hnf (n,_, [(Future M)]))=BTl in approx [n] M 
# in BTl = BT2;; 
true : boo1 
Here Loop has the infinite Bijhm tree solution of B= [x1(x B). Similarly, the 
combinators Y and T admit the same infinite Biihm tree [x1(x B), with B solution of 
the equation B= (x B). 
Now, let us consider the combinator J: 
#let J=<( -Y Cu,x,yl(x (uY)))>;; 
Value J is 
([x0]([x1](x0 (xl xl)) [xl](xO (xl xl))) [x0, x1,x21 
(xl (x0 x2))) : term 
Let us look at the approximants of J: 
#let BTl = approximate J,; 
Value BTl is (Hnf (2, (Index (0, l)), [(F’uture 
([x0]([x1,x2,x3](x2 (xl x3)) (x0 x0)) 
[xO]([xl,x2,x3](x2 (xl x3)) (x0 x0)) uO))])):bohm 
#let BT2=let (Hnf (2,_, [(Future M)]))=BTl in approx [2] M;; 
Value BT2 is (Hnf (1, (Index (1,2>), [(Future 
([x01( [x1,x2,x31(x2 (xl x3)) (x0 x0)) 
[xO]([xl,x2,x3](x2 (xl x3)) (x0 x0)) uO))])):bohm 
#letBT3=let(Hnf(l,_, [(FutureM)]))=BT2inapprox[1;2]M 
# in BT3 = BTS;; 
true : boo1 
The combinator J has thus the infinite Biihm tree: 
[x1,x21(x1 [x31(x2 [x41(x3 . [xn](xn- 1 . )))). It may be considered as an 
infinite q-expansion of combinator I. 
2. Separability 
We now have all the conceptual tools to study separability. 
154 G. Huet 
2.1. Biihm’s theorem 
Definition 2.1. We say that lb-terms M and N are separable iff there exist combinators 
Cl, . . . , Cn such that nf( (closure M) Cl . . . Cn)= True and nf( (closure N) 
Cl . . . Cn)=False. 
The aim of this paper is to prove the following theorem. 
BGhm’s theorem. Any two normal forms are either q-convertible or separable. 
We shall now develop additional notions which are needed for the proof of this 
theorem. 
2.2. Accessibility in Biihm trees 
Definition 2.2. A path of length s is a sequence of positive integers: P = Path [ kl ; . . . ks]. 
#type path= Path of int list;; 
Type path is defined 
Getting the i-th component of path P: 
#let get i (Path P) = nth P i;; 
Value get is (fun) : int + path -+ int 
A path denotes a position in a Bohm tree. At depth i, it indicates that we access its kt’S 
son, i.e. (get bi ki), or if this is not possible that we effect the necessary q-expansions. 
Definition 2.3. Let B be a Biihm tree in Hnf form, and P be a path. We say that P is 
accessible in B towards B’ modulo q-conversion iff (access_tree_top B P)= (B’, b, 
stack), for some b and stack with access_tree_top defined below. First we discuss 
a more general procedure access-tree. 
The function access-tree collects occurrences of the first bound variable x along 
the path, with its arity p, in argument stack: arities. The boolean b indicates whether 
the head variable of B’ is x or not. We allow q-expansions of the head normal forms 
represented by the layers of approximations, and thus a Biihm tree may be “stretched 
to the right” arbitrarily by q-expansions in order to accommodate a given path. 
#type arity= Absent 
# 1 Present of int 
# and arities == arity list;; 
Type arity is defined 
Type arities is defined 
Analysis of Biihm’s theorem 155 
Definition 2.4. Relevant variables refer to the outermost bound ones in the tree. 
#let relevant (i, level) = i= Index (level, 1);; 
Value relevant is (fun) : var * int + boo1 
The auxiliary procedure subeta below finds the kth son of a tree node of arity n in 
the list 1 of its p sons, possibly using q-expansion when k> p. 
#let subeta 1 k n p display= if k<= p then evaluate display (nth 1 k) 
# else Hnf (0, Index (1, n+ k- p), [I);; 
Value subeta is (fun) : bohm list + int -+ int -+ int + int list + bohm 
We are now ready to give the procedure that accesses a tree in Hnf form along 
a path. 
#let ret access-tree (display, level) stack (Hnf(n, i, args) as h) = 
# let b = relevant (i, level) in function 
# 
# ( F::P 
+ h, b, rev (stack) 
+ let p=list_length args 
# and display’ = n :: display 
# in let B’= subeta args k n p display’ 
# and inspect = if b then Present (p) else Absent 
# in access-tree (display’, level+ 1) (inspect :: stack) P B’;; 
Value access-tree is (fun): 
int list * int + arities -+ bohm -+ int list + bohm * boo1 * arities 
#let access_tree_top= access-tree ([I, 0) [I;; 
Value access_tree_top is (fun): 
bohm + int list 4 bohm * boo1 * arities 
Definition 2.5. Let M be a closed term, B a Bdhm tree. We say that path P is accessible 
in term M towards B modulo rpconversion iff (access M P) = (B, b, stack) for some 
b and stack, where 
#let access M (Path P)= access_tree_top (approximate M) P;; 
Value access is (fun) : term + path + bohm * boo1 * arities 
Example 2.6. 
#let M=< [x1(x [YI(x Y))>;; 
Value M is [x01(x0 [xl](xOxl)):term 
#access M (Path [I);; 
((Hnf (1, (Index (0, l)), [(Future [xO](uO x0))])), true, []):bohm*bool*arities 
#access M (Path [ 11);; 
156 G. Huet 
((Hnf (1, (Index (1, l)), [(Future uo)])), true, [(Present l)]):bohm*bool*arities 
#access M (Path [ 1; 11);; 
((Hnf(0, (Index (1, l)), [I)), false, [(Present 1); (Present l)]): 
bohm * boo1 * arities 
#access M (Path[l;2]);; 
((Hnf (0, (Index (1,2)), [I)), false, [(Present 1); (Present l)]): 
bohm * boo1 * arities 
Definition 2.7. The shape of a Btihm tree in Hnf form is the triple consisting of its 
arity, its head variable, and the number of its immediate subtrees: 
#let shape= function 
# Hnf(n,i,b) + (n,i,list_length b) 
# I- + ERROR “Not in Head Normal Form” ;; 
Value shape is (fun) : bohm + int * var * int 
Definition 2.8. Two Biihm trees in Hnf form are said to be similar if they have the 
same shape, up to y-conversion: 
# let similar ( B , B’ ) = 
# let (n,i,p) = shape B 
# and (n’, i’, p’) = shape B’ 
# in i=i’ & p+n’ =p’+n;; 
Value similar is (fun) : bohm * bohm + boo1 
Intuitively, this means that the two trees are defined, and that the corresponding 
top-level approximations may be made similar by q-conversion, in the sense that 
Hnf(n, i, 1) and Hnf(n, i, 1’) are similar when 1 1 1 = 1 1’ 1 : same binding prefix, 
same head variable, same number of immediate subtrees. 
Definition 2.9. Let M and M’ be two closed terms, and P be a path such that (access 
MP)=(B,_, _,) and (access M’P)=(B’, _, _). We say that Pdistinguishes Mand M’ 
iff B and B’ are not similar. 
Theorem 2.10 (Distinguishability entails separability). Zftwo (closed) terms are distin- 
guishable by some path, they are separable. 
The proof of this theorem will be given as correctness of the Biihm-out algorithm 
below, which exhibits the context which separates the two terms. 
Analysis of BGhm’s theorem 157 
2.3. A Biihm-out toolkit 
In this section we give a few parametric combinators needed in the following: 
#let Pair_ n=iterate Abs (n+ 1) (applist (range n)) 
# where ret applist = function 
# [I + Ref(0) 
# 1 n::l -App (applist 1, Ref(n));; 
Value Pair_ is (fun) : int + term 
#Pair_ 3=(([xl,x2,x3,x4] (~4x1~2~3)));; 
true : boo1 
# Pair = Pair _ 2;; 
true : boo1 
#let Pi k n= if n> = k then iterate Abs n (Ref (n- k)) else ERROR “Pi” ;; 
Value Pi is (fun) : int + int -+ term 
#Pi 5 7;; 
[xO,xl,x2,x3,x4,x5,x0]x4: term 
#(I=Pi 1 1) & (True=Pi 12) & (False=Pi 2 2);; 
true : boo1 
#let K_ n=Pi 1 (n+ 1);; 
Value K_ is (fun) : int -+ term 
#K_ 5;; 
[x0,xl,x2,x3,x4,x5]xO:term 
#K=K_ 1;; 
true : boo1 
The next function generates the combinator which, applied to any n arguments, 
evaluates to x. 
#let Cst x n= nf(App (K_ n, x));; 
Value Cst is (fun) : term + int -+ term 
#Cst K 3;; 
[x0, xl, x2, x3, x4] x3 : term 
#let ff = Cst False 
# and tt = Cst True 
# and ii= Cst I;; 
Value ff is (fun) : int -+ term 
Value tt is (fun) : int + term 
Value ii is (fun) : int + term 
Finally, the di generator builds lists of combinator I: 
#letrecdi=functionO-+[] 1 n+I::di(n-1);; 
Value di is (fun) : int + term list 
Thus, di3=[1;1;1] 
158 G. Huet 
2.4. Semi-separability 
We first start with an exercise, in order to understand the use of the combinators 
above as generalized projections. 
Consider the closed head normal form M= [x1,x2, . . . ,xn](xi Ml . Mp). 
Fact 2.11. There exist terms Cl, C2, . . . Cn such that nf(M Cl C2... Cn)=I. 
Proof. The list [Cl;C2; . . . . Cn] is computed by semi_sep(M) below. 
# let semi_sep M = let (n, Index (0, i), p) = shape (approximate M) 
# in identity (n, i- 1, p) 
# where identity(n,i,p)=di(i)@(ii(p)::di(n-i));; 
Value semi_sep is (fun> : term --f term list 
The next function projects a term M along a context [Nl; . ; Nn], by applying 
M successively to Nl, . . . , Nn and normalizing: 
#let project M context= nf(it_list (fun P Q + App(P, Q)) M context));; 
Value project is (fun) : term + term list + term 
For instance: 
#project Y (semi_sep Y);; 
[xO]xO : term 
Remark 2.12. In the usual terminology, we would say that defined terms are solvable. 
The reverse is immediate. This characterization of definedness by semi-separability 
was first remarked by Wadsworth. 
2.5. Separating nonsimilar approximations 
We first examine the base case of the theorem, when we deal with two nonsimilar 
approximations. There are two cases, dealt with by sepl and sep2 below. 
First, sepl separates two closed head normal forms with distinct head variables: 
[x1,x2, . . . ,xn](xi Ml . Mp) and 
[x1,x2, . . . ,xn’](xi’ Nl . . . Np’), with i#i’. 
#let sepl(i,i’,p,p’,n,n’)=(*Assumes i()i’ *) 
# let sep_base1 i i’ j k f g n=di(i- 1) @ (f(j) :: di(i’ -i- 1) @ (g(k) :: di(n-i’))) 
# inifn>=n’thenletk=p’+n-n’ 
# in if i< i’ then sep_base1 i i’ p k tt ff n 
# else sep_base1 i’ i k p ff tt n 
# else let k=p+n’-n 
Analysis of Bdhm’s theorem 159 
# in if ic i’ then sep_base1 i i’ k p’ tt ff n’ 
# else sep_base1 i’ i p’ k ff tt n’;; 
Value sep 1 is (fun) : int * int * int * int * int * int + term list 
This may be checked by case analysis, as an exercise in b-reduction. Similarly, sep2 
separates two closed head normal forms: [xl, x2, . , xn](xl Ml Mp) and 
[x1,x2 ,... ,xn’](xl Nl...Np’), with p+n’#p’+n. 
#let sep2 (p,p’,n,n’)=(* Assumes p+n’ () p’+n *) 
# let sep_base2 d k mfb=ii(k)::di(m-l)@ (f(d)::di(d-l)@ [b]) 
# and d=p-n-(p’-n’) 
# in if n> = n’ then if d> 0 then sep_base2 d p n tt False 
# else sep_base2 (-d) (p’+ n- n’) n ff True 
# else if d>O then sep_base2 d (p+n’-n) n’ tt False 
# else sep_base2 (-d) p’ n’ ff True;; 
Value sep2 is (fun) : int + int * int * int + term list 
Remark that more generally the two closed head normal forms: 
[x1,x2, ,xn](xi Ml . Mp) 
and 
[x1,x2, . . ,xn’](xi Nl . . Np’) 
with p+n’#p’+n, may be separated by the sequence di(i- l)@ sepS(p,p’,n,n’). 
2.6. The Biihm-out algorithm 
Let us first give the main idea. Let M and N be two closed terms, given with a path 
P leading to two nonsimilar positions in their respective Biihn trees. The Bohm-out 
algorithm computes as (separate (M, N) P) a list of combinators Cl, C2, . , Cn 
which separate M and N. 
We want to “bring to the top” the difference between the two terms by successive 
applications, until the resulting terms have nonsimilar Bohm trees. When this condi- 
tion is achieved, we apply algorithms sepl and sep2 above. When the two terms have 
similar BGhm trees, we consider the first bound variable, say x, in their head normal 
forms. We examine all occurrences of x as head variable along path P. There are three 
cases. 
First, if there is no such occurrence, we get rid of x simply by applying the two terms 
to any term, say Cl = I. If there is exactly one such occurrence in path P, we substitute 
to x the combinator Cl = Pi k p, for appropriate k and p. When there are several such 
occurrences, we linearise by substituting to x a pairing combinator Cl=Pair_maxp, 
160 G. Huet 
with maxp the maximum number of descendants of nodes with head variable x in 
path P. We thus replace every such occurrence of x by a distinct xi locally bound at its 
level. 
We have to be careful with other possible relevant occurrences of x: as heads of the 
nonsimilar subtrees at position P in the Bijhm trees of M and N. When this happens, 
we do the same as in the case of multiple occurrences, in order to preserve the property 
of the two subtrees to be nonsimilar, while replacing the global head x by a new local 
z. This completes the analysis of the different cases. In each case, we call ourselves 
recursively. The path P stays the same, except in the single-occurrence case, where it is 
shortened by skipping its i-th element, using the auxiliary function skip, which 
removes the i-th level of path P: 
#let skip i (Path P) = Path (coll_rec 1 P) 
# where ret coll_rec lev=function 
# Cl + ERROR “Out of range skip” 
# 1 dir::P + ifi=lev then P 
# else dir :: coll_rec (lev+ 1) P;; 
Value skip is (fun) : int + path -+ path 
The various cases of the analysis above form the constructors of type item: 
#type item = None 
# 1 Once of int * int (* level, p *) 
# 1 Several of int (* maxp *);; 
Type item is defined 
The next procedure collects occurrences of the first variable x as head variable 
along path P: 
# let analyse (n, n’, p, p’, b, b’) = anal 1 
#where ret anal lev= function 
# ([I, [I) -+ if b then if b’ then Several (max p p’) 
# else Several (if n’> n then p + n’- n else p) 
# else if b’ then Several (if n>n’ then p’+n-n’ else p’) 
# else None 
# 1 (Present (p) :: stl, Present ( p’) :: st2) + let pmax= max p p’ 
# in (match (anal (1ev-t 1) (stl, st2)) with 
# Several (maxp) + Several (max pmax maxp) 
# I Once (-, PI) + Several (max pmax pi) 
# 1 None + Once (lev, pmax)) 
# 1 (Absent::stl,Absent::st2)+anal (lev+l) (stl,st2) 
# I _ -+ ERROR “Non similarity along path”;; 
Value analyse is (fun) : 
int * int * int * int * boo1 * boo1 + arities * arities + item 
Analysis of Bdhm’s theorem 161 
We are now prepared to give the Bdhm-out algorithm. We assume the Bohm trees 
of closed terms M and N are accessible by path P, minimal leading to nonsimilar trees: 
#let ret separate (J.&N) P= 
# let (B, b, at) = access M P 
# and (B’, b’, st’)=access NP 
# in let (n, v, p)=shape(B) 
# and (n’, v’, p’ ) = shape (B’) 
# in if P= Path [] then (* The Bohm trees of M and N are not similar *) 
# let (i, i’) = match (v, v’ ) with 
# Index(0, i), Index(0, i’) + (i, i’) 
# 1 _ + ERROR “Non closed term” 
# in if i( )i’ then sepl (i, i’, p, p’, n, n’) 
# elseifp+n’()p’+nthendi(i-l)@sep2(p,p’,n,n’) 
# else ERROR “Similar trees” 
# else match (analyse (n, n’, p, p’, b, b’) (st, St’)) with 
# None + build-context I (* Any term would do *) (M, N) P 
# I Once (m,p> + (* head v&r appears just once on path *) 
# let k= get m P 
# in build-context (Pi k p) (M,N) (skip m P) 
# 1 Several (maxp) -+ build-context (Pair_maxp) (M,N) P 
#and build-context C (M, N) P= C :: separate (App (M, C), App (N, C)) P;; 
Value separate is (fun) : term * term + path + term list 
Value build-context is (fun) : term + term * term + path + term list 
Fact 2.13 (Well-foundedness of separate). The evaluation of separate (M, N) P al- 
ways terminates. 
Proof. By induction on triple (P) = (s, schi, nl), where s=length(P), schi is the 
number of variables bound at first level which are head variables at several levels, and 
nl is the number of first level variables. 0 
Remark 2.14. We use pairing operators to rename multiple occurrences of the first 
variable along the path, as collected by analyse. Actually this renaming is not always 
necessary; when analyse considers a set of occurrences (lev, p) in the path with same 
k at every level lev, we could directly apply (Pi k p), and get a shorter context. This 
renaming is necessary when the variable is schizophrenic, i.e. the path traverses two 
levels with x head variable, but distinct k’s. We call schizophreny of the situation the 
integer schi. 
# let separates context (M, N)= 
# (project M context=True) & (project N context=False);; 
Value separates is (fun) : term list + term * term + boo1 
162 G. Huet 
Examples 2.15. 
#let context= separate (I, Pair) (Path [I);; 
Value context is [ [xO,xl,x2,x3]x2; [xO]xO; [xO,xl,x2,x3]x3]:term list 
# separates context (I, Pair);; 
true : boo1 
#let M=(( [u](u^I (u-1 *I))>> 
#and N=(( [u](u*I (uu^I)))) 
#and P=Path[2; 11;; 
Value M is [x01(x0 [xl] xl (x0 [x11x1 [xl]xl)) :term 
Value N is [x01(x0 [x11x1 (x0 x0 [xl]xl)):term 
Value P is (Path[2; 11) : path 
# let context = separate (M, N) P;; 
Value context is 
[[x0,x1,x2](x2 x0 xl); [x0,x11x1; [x0,x11x0; 
[xO,xl,x2,x3]x2; [xO]xO; [xO,xl,x2,x3]x3] :term list 
# separates context (M, N);; 
true : boo1 
#let M=< [u,vl(v [wl(u WI>>> 
#and N=< [u,vl(v [wl(uu>>> 
#and P=Path[ 1; l] 
#in separate (M, N) P;; 
[[xO,xl](xl x0); [xO]xO; [xO,xl,x2](x2 x0 xl); [x01x0; 
[xO]xO; [xO,xl,x2,x3]x3; [x0,xl,x2,x3]x2]:term list 
#let M=(( [ul(uu)> 
#andN=CCul(u [v,wl(wv)>> 
#and P=Path[ l] 
# in separate (M, N) P;; 
[[x0,x1,x23(x2 x0 xl); [xO]xO; [x0,x1]x0; [xO]xO; 
[xO,x1,x2,x3]x3; [xO,xl,x2,x3]x2] : term list 
2.7. The separability theorem 
We now prove the Separability theorem above: 
Separability theorem. Distinguishable terms are separable. 
Analysis of Biihm’s theorem 163 
Proof. Let us assume that M and N are two closed terms distinguished by a path P. 
We proceed by induction on triple (P)= (s, schi, nl). When s= 0, we use the 
correctness of sep 1 and sep2, a mere exercise in P-reduction. When s > 0, we reason 
by cases on the number of times the outermost bound variable xl in the head normal 
forms of M and N occurs as head variable along path P. If it occurs just once at level 
m with arity p, and P goes through its k-th subtree, then (Pi k p), applied to M and N, 
respectively, will propagate by successive approximations into their respective Biihm 
trees until level q which it will collapse in such a way that (skip m P), of length s- 1, 
is a distinguishing path for them. The result follows by induction. If it occurs several 
times, with maxp its maximum arity along P, we linearise xl by substituting 
Cl=Pair_(maxp) to it. We check that P distinguishes (M Cl) and (N Cl), with 
decreased schizophreny schi-1. Finally, when it does not occur, we just eliminate xl 
by substituting I to it. We check that P distinguishes (M I) and (N I), with same 
schizophreny and nl- 1 outermost bound variables. As remarked above, we treat the 
case where xl appears as head variable of the tree accessed by P in M or N in the same 
way as a multiple occurrence (see the base case of analyse above). This simplifies the 
treatment, since it defers the substitution to these head variables to the end of the 
BGhm-out process, with P empty. This may create a separating context longer than 
necessary, but as remarked above we do not care here about minimizing the number 
of Ci’s. 0 
2.8. Searching for a separating path 
In this section we shall attempt to construct a path separating two A-terms. This is 
not decidable in general, and thus we can only hope for a semi-decision algorithm. In 
particular, we have to choose a subtree at every level in such a way that we avoid 
undefined ones. We shall ignore this problem here and thus look in the BGhm trees of 
the two terms in a leftmost-outermost manner. 
Searching for a path separating two trees. search-path searchs in a depth-first, 
left-to-right manner. 
#let ret search-path ((Hnf(n, _, l), Hnf(n’, _, 1’)) as trees) (dis, dis’) path= 
# if similar (trees) then 
# let p= list-length 1 and d= n:: dis 
# and p’= list-length 1’ and d’= n’ :: dis’ 
# in let check k= let h= subeta 1 k n p d 
# and h’= subeta 1’ k n’ p’ d’ 
# in search-path (h, h’) (d, d’) (k:: path) 
# in try try-find check (range (max p p’)) 
# with failure_ + ERROR “Not separable” 
# else rev(path);; 
Value search-path is (fun): 
bohm * bohm + int list * int list -+ int list -+ int list 
164 G. Huet 
Note: Similarity does not depend on the display. Further we do not need to keep 
track of q-expansions. This is an essential property of our representation of variables 
with constructor Index. 
Finding a path separating two terms. 
#let separ_path (M, N) = 
# Path(search_path (approximate M, approximate N) ( [I, [] ) [] );; 
Value separ -path is (fun) : term * term -+ path 
This procedure may loop because it looks depth-first, as for instance in 
separ_path ((( [x1(x *Omega x)>>, (( [x](x^Omega *I)>> ), or because the two 
terms are not separable, as for instance in separ_path (Y, T). For certain nonsepar- 
able pairs of terms, it actually fails, as for instance: 
# separ_path (I, A);; 
Evaluation Failed: failure “Not separable” 
Exercises. (1) Program a breadth-first version search-path-breadth of 
search-path, which will return a path separating two trees if it can be found in 
a breadth-first search left to right. Thus, search-path-breadth ought to succeed on 
the approximations of terms (( [x, y](x ^Y x) > and (( [x, y] (x *Y y)>. 
(2) The preceding procedure will still fail to find a path separating (( [x,y] (x 
*Omega x) > and (( [x, y] (x *Omega y)>, because it avoids looping on infinite 
branches, but still loops trying to find an approximation to undefined terms. Write 
a semi-decision procedure separ_path which will return a path separating two terms 
if one exists at all. This procedure must dove-tail single-step /!i-reductions from the two 
terms, without attempting to compute head-normal forms in one atomic step. It will 
still loop on pairs such as (Y,Y), of course. 
Remark 2.16. Combinators which are q-convertible, such as A and I, are not separ- 
able. Combinators which have the same Bohm tree, such as Y and T, are not separable 
either. Note also that the combinator I is not separable from J given above, even 
though their Biihm trees are different, and they are not q-convertible. 
2.9. Left Biihm separator 
Putting everything together, we get a left Bohm separator as: 
#let Bohm (M, N) = separate (M, N) (separ_path (M, N));; 
Value Bohm is (fun) : term *term + term list 
Annlysis of Biihm’s theorem 165 
For instance: 
# Bohm(1, Pair);; 
[[xO,x1,x2,x3]x2; [xO]xO; [xO,xl,x2,x3]x3]:termlist 
#Bohm(< Cs,zl@ (* Church(O) *I, C [s,zI(s z>>> (* Church(l) *>I;; 
[ [xO,xl,x2]x2; [xO,xl]xO] : term list 
#Bohm(I,Y);; 
[[xO,xl]xl; [xO,xl,x2]x2; [xO,xl]xO] :term list 
#Bonm(C [x1(x x>h < CXYKX Y Y>>>;; 
[[xO,xl,x2](x2 x0 xl); [xO,xl,x2,x3](x3 x0 xl x2); [xO,xl]xO; [xO]xO; 
[xO]xO; [xO,x1,x2,x3,x4]x3; [xO,xl,x2,x3,x4]x4l:term list 
#Bohm(< [ul(u^I (u ^ I ^ I>>>>, C [ul(u ^I (u u *I>>>>;; 
[[xo,xl,x2](x2 x0 xl); [xO,xl]xl; [x0,x11x0; [x0,x1,x2,x33x2; [xO]xO; 
[xO,xl,x2,x3]x3] : term list 
#Bohm(< [u,vl(v 1~1 (uw>>>>, < [u,vl(v Cwl(u u>>>>>;; 
[[x0,x1] (x1x0); [xO]xO; [x0,x1.x2] (x2x0x1); [xO]xO; [xO]xO; 
[xO,xl,x2,x3]x3; [xO,xl,x2,x3]x2]:termlist 
#Bohm(<[ul(u (uuu) u>>>, C[ I( ( u u uu [u,v,wl(wuv)) u)>>);; 
[[x0,x1,x2,x3] (~3x0~1~2); [xO]xO; [xO,xl,x2]xO; [xO]xO; [xO,xl,x2]xl; 
[xO]xO; [xO]xO; [xO,x1,x2,x3,x4]x4; [xO,xl,x2,x3,x4]x3l:termlist 
2.10. Application to normal forms 
Proposition 2.17. If M and N are two closed normal forms which are not q-convertible, 
they are distinguishable. 
Proof. By induction on the maximum height of the (finite) Bohm trees of M and N. Let 
M=[xl,x2 ,..., xn] (xiMl...Mp) and N=[xl,x2 ,... ,xn’] (xi’ Nl . ..Np’). If 
M and N are not similar, the empty path distinguishes them. Otherwise, we must have 
i=i’, and p+n’=p’+n Assume for instance n>n’:n=n’+d. The term N is q- 
convertible to [x1,x2, . . . ,xn] (xi Nl... Np), taking N(p’+j)=u(n’+j) for 1 <j<d 
Since M and N are not q-convertible, there must exist 1< kG p such that Mk is not 
q-convertible to Nk; by induction hypothesis these two terms are distinguishable by 
some path P, and thus M and N are distinguishable by path k :: P. 0 
Corollary 2.18. Btihm’s theorem. 
Proof. Note that two terms are v-convertible if and only if their closure is q- 
convertible. Apply the separability theorem. 
Corollary 2.19. If M and N are two closed normal forms which are not q-convertible, 
separ_path (M,N) succeeds and returns a path which distinguishes them. 
166 G. Huet 
Proof. separ_path (M,N) terminates with the shortest path in lexicographic order- 
ing which distinguishes M and N. 
Corollary 2.20. Zf M and N are two closed normal forms which are not rpconvertible, 
Bohm(M,N) terminates with a context C such that (project M C)=True and 
(project N C) = False. When M and N are q-convertible, Bohm (M, N) terminates with 
failure “Not separable”. 
Many extensions of Bohm’s theorem have been studied, for instance for the simultan- 
eous separation of n terms [S, 6,3]. The separability problem is a special case of 
solving equations in I-calculus [ 11,4, lo]. The notion of separability we have defined 
here is not the most general; it should rather be called separability without memory. If 
instead we define separability of M and N as the existence of a combinator X such that 
(X M) reduces to True and (X N) reduces to False, this allows X to be of the form 
[z] (z Cl . . . Cn), with the possibility of z occurring in the Ci’s as a memory of the 
separated term. 
3. Discussion 
The importance of Btihm’s theorem is that it gives a very strong requirement for 
a structure to be a model of i-calculus. Two normalizable terms are identifiable in 
a nontrivial model only if they are /Iv-convertible. This roughly fixes the three degrees 
of freedom of a model with respect to the completely syntactical one of Biihm trees: 
l It may be extensional (i.e. verify v], possibly identify I and J) or not 
l It may identify more or less the undefined terms 
l It may be more or less rich in non-definable points. 
In this paper, we have given a treatment of Bbhm’s theorem which attempted to be 
as constructive as possible. This was obtained by splitting the result into two phases. 
The Biihm-out technique is first explained as a total function taking as argument 
a distinguishing path in the two Biihm trees; computing a distinguishing path is only 
a semi-computable algorithm. We gave here a version which computes such a path 
when it can be found in a left-to-right fashion, a condition which suffices to the 
application to Bdhm’s theorem. 
Our notion of Biihm trees has the advantage of keeping all the possible information 
in the Future parts, which hold ordinary terms. This presents several advantages. 
First of all, the usual substitution and head normal form algorithms, for A-terms, 
suffice, there is no need to reduce Biihm trees. Then, this structure is well-suited to 
define a variety of models, where unsolvable subparts may be more or less identified, 
by suitable congruences (such as fl, or fir-conversion) defined on terms. 
Several minor details may be pointed out. First, the Index representation of 
variables, invariant by q-expansion. Then, the Bdhm-out technique uses only one 
operation on Biihm trees, equivalent to substitution by application of a term to the 
Analysis of B6hm’s theorem 161 
head variable. The bound variables on the discriminating path are eliminated in 
a left-to-right fashion. Finally, we remark that our formalization has not increased the 
size of the descriptive text. Indeed, the BGhm-out technique is completely described in 
less than a page of ML code (algorithms sepl, sep2, and separate). 
We consider such a constructive development as pre-formal. We leave as a challenge 
to mechanized proof systems the completely formal development (i.e. machine- 
checked proof) of Bdhm’s theorem. 
References 
[l] I$. Barendregt, The Lambda-Calculus: Its Syntax and Semantics (North-Holland, Amsterdam, 1980)._, 
, 
‘\J .1. 
[2 C. Biihm Alcune proprieta delle forme fi-q-normali nel I-K-calcolo, Pubblicazioni dell’Istituto per le 
Apphcaziom del Calcolo N. 696, Roma, 1968. 
[3] C. Biihm, M. Dezani-Ciancaglini, P. Peretti and S. Ronchi della Rocca, A discrimination algorithm 
inside I-~-calculus, Theoret. Comput. Sci. 8 (1979) 271-291. 
[4] C. Bohm, A. Piperno and E. Tronci, Solving equations in Lambda-Calculus, in: R. Ferro, C. Bonotto, 
S. Valentini and A. Zanardo, eds., Logic Colloquium’88 (North-Holland, Amsterdam, 1989). 
[S] N.G. de Bruijn, Lambda-calculus notation with nameless dummies, a tool for automatic formula 
manipulation, with application to the Church-Rosser theorem, Indag. Math. 34 (1972) 381-392. 
[6] M. Coppo, M. Dezani-Ciancaglini and S. Ronchi della Rocca, (Semi-)separability of finite sets of 
terms in Scott’s D, models of the I-calculus, in: G. Ausiello and C. Biihm, eds., Proc. 5th ICALP, 
ecture Notes in Computer Science, Vol. 62 (Springer, Berlin, 1978) 142-164. 
&%.C ousineau and G. Huet, The CAML Primer, Rapport Technique 122, INRIA, Sept. 1990. 
!+S] M. D ezani-Ciancaglini, Characterization of normal forms possessing inverses in the Q-n-calculus, 
Theoret. Comput. Sci. 2 (1976) 323-337. 
[9] G. Huet, Constructive Computation Theory, Part I. Notes de tours, DEA Informatique, 
Mathematiques et Applications, Paris, Oct. 1992. 
[lo] A. Piperno and E. Tronci, Regular systems of equations in the A-calculus, Int. J. Found. Theoret. 
Comput. Sci. 1, 3 (1990) 325-339. 
[ll] R. Statman, On sets of solutions to combinator equations, Theoret. Comput. Sci. 66 (1989) 99-104. 
