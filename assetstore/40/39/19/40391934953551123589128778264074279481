On -conversion in the -cube and the combination with
abbreviations
Fairouz Kamareddine Roel Bloo and Rob Nederpelt
University of Glasgow
Department of Computing Science
17 Lilybank Gardens
Glasgow G12 8QQ
Scotland
FAX: +44 141 330 4913
fairouz@dcs.gla.ac.uk
Mathematics and Computing Science
Eindhoven University of Technology
P.O.Box 513
5600 MB Eindhoven
The Netherlands
FAX: +31 40 2463992
fbloo, wsinrpng@win.tue.nl
Abstract
Typed -calculus uses two abstraction symbols ( and ) which are usually treated
in dierent ways: 
x:
:x has as type the abstraction 
x:
:, yet 
x:
: has type 2 rather
than an abstraction; moreover, (
x:A
:B)C is allowed and -reduction evaluates it, but
(
x:A
:B)C is rarely allowed. Furthermore, there is a general consensus that  and  are
dierent abstraction operators. While we agree with this general consensus, we nd it
nonetheless important to allow  to act as an abstraction operator. Moreover, experience
with AUTOMATH and the recent revivals of -reduction as in [KN 95b, PM 97], illustrate
the elegance of giving -redexes a status similar to -redexes. However, -reduction in
the -cube faces serious problems as shown in [KN 95b, PM 97]: it is not safe as regards
subject reduction, it does not satisfy type correctness, it loses the property that the type
of an expression is well-formed and it fails to make any expression that contains a -redex
well-formed.
In this paper, we propose a solution to all those problems. The solution is to use
a concept that is heavily present in most implementations of programming languages
and theorem provers: abbreviations (viz. by means of a denition) or let-expressions.
We will show that the -cube extended with -conversion and abbreviations satises all
the desirable properties of the cube and does not face any of the serious problems of
-reduction. We believe that this extension of the -cube is very useful: it gives a full
formal study of two concepts (-reduction and abbreviations) that are useful for theorem
proving and programming languages.
Keywords: -conversion, Abbreviations, Barendregt's cube, Subject Reduction,  versus .
1 Introduction
Both -reduction and the use of names to abbreviate large expressions, are useful for au-
tomating mathematics, for theorem proving and for programming languages. Evidence of
this is their presence in the various implementations of mathematics, theorem proving and
programming languages. In what follows, we explicit the advantages and/or problems of these
two concepts and we explain why combining them is even more useful.
1
1.1 On -reduction
Type theory has almost always been studied without -conversion (which is the analogue of
-conversion on product type level). That is, !

: (
x:A
:b)C !

b[x := C] is always assumed
but not !

: (
x:A
:B)C !

B[x := C]. The exceptions to this are: some AUTOMATH-
languages (see [NGV 94]), the -cube extended with -reduction in [KN 95b] and the in-
termediate language in compilers for source languages as in [PM 97]. We claim that !

is
desirable for the following reasons:
A.  is, in a sense, a kind of . In higher order type theory, arrow-types of the form
A ! B are replaced by dependent products 
x:A
:B, where x may be free in B, and thus B
depends on x. This means that abstraction can be over types: 
x:A
:B as well as over terms:

x:A
:b. But, once we allow abstraction over types, it would be nice to discuss the reduction
rules which govern these types. In fact,  is indeed a kind of  as regards the abstraction
over a variable and hence is eligible for an application.
B. Compatibility. Here are two important rules in the -cube:
(abstraction rule)
?:hx : Ai ` b : B ? ` 
x:A
:B : S
? ` 
x:A
:b : 
x:A
:B
(application rule)
? ` F : 
x:A
:B ? ` a : A
? ` Fa : B[x := a]
The (abstraction rule) may be regarded as the compatibility property for typing with
respect to abstraction. That is: b : B implies 
x:A
:b : 
x:A
:B.
The compatibility property for the typing with respect to application is lost however. In
fact, from the (application rule), one does not have: F : 
x:A
:B implies Fa : (
x:A
:B)a, but
instead F : 
x:A
:B implies Fa : B[x := a].
To get compatibility for typing with respect to application, one needs to add !

and to
change the (application rule) to:
(new application rule)
? ` F : 
x:A
:B ? ` a : A
? ` Fa : (
x:A
:B)a
C. The AUTOMATH experience. One might argue that implicit -reduction (as is the
case of the ordinary -cube with the (application rule) above) is closer to intuition in the most
usual applications. However, experiences with the AUTOMATH-languages ([NGV 94]), con-
taining explicit -reduction, demonstrated that there exists no formal or informal objection
against the use of this explicit -reduction in natural applications of type systems.
D. Preference types, higher degrees, conversion. In [KN 95b], -reduction was shown
to have various advantages which include the possibility of calculating the preference type
(?; A) of a term A in a context ?, the ability of incorporating dierent degrees of abstraction
(rather than just two,  and , as in the -cube) and the fact that the following rule of the
-cube is superuous:
(conversion rule)
? ` A : B ? ` B
0
: S B = B
0
? ` A : B
0
E. Programming languages. In programming language studies, a thriving area is that
of the use of richly-typed intermediate languages in sophisticated compilers for higher-order,
typed source languages ([PJ 96, SA 95, TMCSHL 96]). The recently developed language
2
[PM 97] aims at reducing the number of data types and the volume of code required in the
compiler, by avoiding duplications. To do this, [PM 97] uses the whole -cube extended with
-reduction and gives the following motivation:
 For reduction there is now only one set of rules =

.
 With the old application rule, matters get very complicated when one adds further
expressions (such as let and case).
 In a compiler, -reduction allows to separate the type nder from the evaluator since `
no longer mentions substitution. One rst extracts the type and only then evaluates it.
A : : : E above (especially B and D), can be viewed as syntactic motivations for -conversion.
There are also semantic motivations for -conversion. Of these, we mention:
A. Innite levels of abstractions One may abandon the two levels ( and ) as used in
the current type systems and reformulate all type theory using dierent levels of 's, where
say, 
0
is what we call , 
1
is the , etc. Then, one will be able to give every term 
n
x:A
:B
the type 
n+1
x:A
:C where C is a type of B, and the current type theory will be reproduced at
each level. This would be rather interesting to investigate.
B. Finding and evaluating types become two separate events -reduction allows to
separate the type nder from the evaluator since ` no longer mentions substitution. This
approach was presented in detail in [KN 95b] where the question ? ` A : B was split into
? ` A (A is typable in ?) and (?; A) =

B (B is convertible to the preference type of A).
All the above are reasons why it is interesting to study -conversion in the -cube. How-
ever, extending the -cube with -conversion is not a straightforward adding of (
x:A
:B)C !

B[x := C] and of the (new application rule) (see [KN 95b]). Changing the (application rule) in
the -cube to the (new application rule) as presented above results in the following problems:
1. Correctness of types no longer holds. With -reduction, one can have ? ` A : B
without B  2 or 9S :? ` B : S. For example, hz : i:hx : zi ` (
y:z
:y)x : (
y:z
:z)x yet
(
y:z
:z)x 6 2 and 8S : hz : i:hx : zi 6` (
y:z
:z)x : S. The problem arises because of
the new terms that contain -redexes (which did not exist in the -cube) and because
[KN 95b] showed that in the -cube extended with -reduction:
(") If ? ` A : B then neither ? nor A contain -redexes and if B contains a -redex,
then B is itself that -redex.
2. The system is no longer safe. More precisely, subject reduction (SR) fails. That is,
with -reduction and the (new application rule), ? ` A : B and A! A
0
may not imply
? ` A
0
: B. For example, hz : i:hx : zi ` (
y:z
:y)x : (
y:z
:z)x and (
y:z
:y)x ! x, but
one can't show hz : i:hx : zi ` x : (
y:z
:z)x. To show this last formula, one needs to use
the above (conversion rule) and for this, one needs that 9S:hz : i:hx : zi ` (
y:z
:z)x : S.
But (") in 1 above makes this impossible.
3. The type of an expression may not be well-formed. This is related to type
correctness above. We say that A is well-formed if A  2 or 9?; B : ? ` A : B. Now
consider hz : i:hx : zi ` (
y:z
:y)x : (
y:z
:z)x. The type (
y:z
:z)x of (
y:z
:y)x is not
well-formed by (").
3
4. -redexes are not well-formed.
From (") above follows that no expression that contains a -redex is well-formed.
Despite these shortcomings of -reduction, [PM 97] claims that its advantages are persuasive.
In this paper we will repair the shortcomings of -reduction. It is amazing that the way to
repair the problem is itself a very useful way in type theory: the use of abbreviations.
1.2 On abbreviations
In many type theories and lambda calculi, there is no formal possibility to use abbreviations,
i.e., to introduce names for large expressions which can be used several times in a program or a
proof. This possibility is essential for practical use, and indeed implementations of Pure Type
Systems such as Coq [Dow 91], Lego [LP 92] and Nuprl [Con 86] do provide this possibility.
Moreover, most implementations of programming languages (Haskell, ML, CAML, etc.) use
names for large expressions via a well-known programming language concept: let expressions.
Example 1.1 Let id : A! A be (
x:A
:x) in (
y:A!A
:id)id abbreviates the complex expres-
sion (
x:A
:x) as id in a more complex expression in which id occurs two times.
The intended meaning of \let x : A be a in b" is that a can be substituted for x in the
expression b. In a sense, the expression let x : A be a in b is similar to (
x:A
:b)a which -
reduces to b[x := a], i.e., b with all free occurrences of x replaced by a. In the let-expression,
however, it is not intended to necessarily replace all the occurrences of x in b by a. Nor is
it intended that such a let-expression is a part of our term. Rather, the let-expression will
live in the environment (or context) in which we evaluate or reason about the expression.
One of the advantages of the expression let x : A be a in b over the redex (
x:A
:b)a
is that it is convenient to have the freedom of substituting only some of the occurrences of
an expression in a given formula. Another advantage is eciency; one evaluates a in let
x : A be a in b only once, even in lazy languages.
1
A further advantage is that using x to
be a in b can be used to type b eciently, since the type A of a has to be calculated only
once.
2
Furthermore, practical experiences with type systems show that let-expressions are
absolutely indispensable for any realistic application. Without let-expressions, terms soon
become forbiddingly complicated. By using let-expressions one can avoid such an explosion
in complexity. This is, by the way, a very natural thing to do: the apparatus of mathematics,
for instance, is unimaginable without a form of let-expressions (viz. denitions).
1
Note that smart lazy languages will use explicit substitution or sharing techniques to evaluate a in b[x := a]
only once. Nevertheless, our extension with abbreviations as is considered here, is a straightforward extension
of the -calculus and hence has less machinery than is involved with sharing or explicit substitution. Moreover,
it may be that this simple concept of abbreviations as we introduce it can be used to formalise the notion of
sharing. In fact, the work already done in [AFMOW95, BLR96] to show that some formal systems of explicit
substitution or generalised reduction can formalise sharing, can be adapted to show that a formal system of
abbreviations can also be a successful model for sharing.
2
Here, in b[x := a], the type A of a is calculated many times. Of course with the presence of Subject
Reduction (SR), we we do not need to calculate the type of b[x := a]. Instead, we calculate the type of
(x : A:b)a (where the type of a is calculated only once) and we use subject reduction to derive the type of
b[x := a]. However, many programming languages (PLs) do not have a clear notion of SR. Similarly, although
in many PLs, sharing is used in order to calculate the type A of a only once in b[x := a], there can be no
escape from showing that this sharing technique of PLs is correct. Our system of denitions can be used to
formalize this sharing technique of PLs.
4
There exist already two formal studies of let-expressions in the -cube [BKN 96, SP 93]
where those let-expressions are called denitions. In this paper we dier from both accounts
and use the simplest way of renaming large expressions and describe such renaming as ab-
breviations. We dier from [SP 93] in that we do not introduce new terms (let-terms) into
our syntax and do not extend -reduction to deal with those new terms. We dier from
[BKN 96] in that we do not use nested denitions, which are needed for generalised reduction
in [BKN 96] but not for -reduction.
We write hx : Aia to describe that x of type A, abbreviates a. We include abbreviations
in contexts such that if an abbreviation occurs in a context then it can be used anywhere in
the term we are reasoning about in that context.
In this paper, we will use abbreviations to repair all the problems of -reduction men-
tioned in Subsection 1.1. In particular, we extend the -cube with both -reduction and
abbreviations and we show that this extension satises all the desirable properties (including
Subject Reduction).
1.3 On combining abbreviations and -reductions
We shall show in this paper that the -cube extended with both abbreviations and -reduction
(!

and the new application rule), preserves all its original properties (including safety,
correctness of types and well-formedness of the type of an expression) and allows a non-
limited occurrence of -redexes in the well-formed terms. This means that abbreviations
(being important on their own) have repaired the problems of -reduction in the -cube. Let
us here explain why the shortcomings of -reduction disappear with abbreviations:
Looking at the four problems of -reduction in Subsection 1.1, one sees that one needs
to be able to type -redexes. This is not possible if the -cube is simply extended with the
(new application rule) and !

as [KN 95b] showed. There are several routes to follow:
A. Innite levels of abstractions as discussed under the semantic motivations for -
conversion. This would be very interesting to investigate, but we feel it is a drastic change
from current type theory and we are not sure what complications or contradictions will arise
from dierent levels of 's. We leave it as a point for future research.
B. Abbreviations. One may introduce (- and -) redexes as a separate (compound) term,
which can be typed using abbreviations. In the type, the abbreviation is unfolded. The idea
is simple: extend contexts with abbreviations and add the following rule:
(abb rule)
?:hx : AiB ` C : D
? ` (
x:A
:C)B : D[x := B]
where  2 f;g
This rule says that if C : D can be typed using the abbreviation that x of type A is B, then
(
x:A
:C)B : D[x := B] can be typed without this abbreviation. This simple extension solves
all the problems of -reduction mentioned in Subsection 1.1. Here is how:
1. Correctness of types holds. We demonstrate this with the example of problem 1 of
Subsection 1.1. Recall that we have hz : i:hx : zi ` (
y:z
:y)x : (
y:z
:z)x and want that
for some S, hz : i:hx : zi ` (
y:z
:z)x : S. Here is how the latter formula now holds:
hz : i:hx : zi ` z :  (start and weakening)
hz : i:hx : zi:hy : zix ` z :  (weakening)
hz : i:hx : zi ` (
y:z
:z)x : [y := x]   (abb rule)
5
2. The system is now safe. We demonstrate this with the example of problem 2 of Sub-
section 1.1. Recall that we have hz : i:hx : zi ` (
y:z
:y)x : (
y:z
:z)x and (
y:z
:y)x!

x
and we need to show that hz : i:hx : zi ` x : (
y:z
:z)x. Here is how the latter formula
now holds:
a: hz : i:hx : zi ` x : z (start and weakening)
b: hz : i:hx : zi ` (
y:z
:z)x :  (from 1 above)
hz : i:hx : zi ` x : (
y:z
:z)x (conversion, a, b, and z =

(
y:z
:z)x)
3. The type of an expression is well-formed. We demonstrate this with the example
of problem 3 of Subsection 1.1. Recall that we have hz : i:hx : zi ` (
y:z
:y)x : (
y:z
:z)x
and we want to show that (
y:z
:z)x is typable (note that (
y:z
:z)x 6 2). By 1 above,
we have that hz : i:hx : zi ` (
y:z
:z)x : .
4. -redexes are well-formed. -redexes can now occur in contexts, terms, and types
and all the obtained -redexes are indeed well-formed.
Remark 4.2, Lemma 4.12 and Theorem 4.13 will show that indeed all the problems of -
reduction are solved. Intuitively, the reason is that abbreviations keep information in the
context about the dened values of variables.
We divide the paper as follows:
1. In Section 2, we set up the machinery for both abbreviations and -reduction.
2. In Section 3, we introduce the original relation of the -cube `

and the extended
relation `

as in [KN 95b]. We list the properties of both `

and `

.
3. In Section 4, we introduce `
ra
which is `
r
(for r =  or ) extended with abbreviations.
We show that all the properties of the -cube remain valid for `
ra
. This establishes that
extending the -cube with abbreviations or with both abbreviations and -reduction
results in a well-behaved system. Due to the uniformity of our presentation, we prove
almost all the results for `
ra
rather than separately prove them for `
a
and `
a
.
2 The Formal Machinery
The systems of the -cube (see [Ba 92]), are based on a set of pseudo-expressions or terms T
dened by the following abstract syntax:
T =  j2 j V j T T j 
V :T
:T
where  2 f;g, V is an innite collection of variables (; ; x; y; z; : : : range over V ),  and
2 are sorts (S; S
1
; S
2
; : : : range over f;2g). We let A;B; a; b : : : range over T .
Bound and free variables and substitution are dened as usual where the binding power
of  is similar to that of . We write BV (A) and FV (A) to represent the bound and
free variables of A respectively. We write A[x := B] to denote the term where all the free
occurrences of x in A have been replaced by B. Furthermore, we take terms to be equivalent
up to variable renaming and let  denote syntactic equality. For example, we take 
x:A
:x 

y:A
:y. We assume moreover, the Barendregt variable convention which is formally stated as
follows:
6
Convention 2.1 (BC: Barendregt's Convention)
Names of bound variables will always be chosen such that they dier from the free ones in a
term. Moreover, dierent abstraction operators have dierent variables as subscript. Hence,
we will not have (
x:A
:x)x, but (
y:A
:y)x instead.
We say that a rewrite relation r between terms is compatible, if for all terms A; B; C, it
holds that A r B implies AC r BC, CA r CB, 
x:A
:C r 
x:B
:C and 
x:C
:A r 
x:C
:B. For a
given set of rewrite rules r on terms, we dene the reduction relation !
r
as the compatible
closure of r. Furthermore, for a reduction relation !
r
, we dene !
r
and =
r
to be its
reexive transitive closure and its equivalence closure respectively. We take r 2 f; g
throughout and use the relations: !

and !

generated by: (
x:A
:B)C !

B[x := C], and
(
x:A
:B)C !

B[x := C] respectively.
In the following denition, declarations are familiar from the -cube. The relation 
0
enables `information-preserving' extensions of the pseudocontext. We let d; d
1
; d
2
; : : : range
over declarations and abbreviations and ?;;?
0
;?
1
;?
2
; : : : over pseudocontexts.
Denition 2.2 (declarations, abbreviations, pseudocontexts, 
0
)
1. A declaration d is of the form hx : Ai. We dene var(d)  x and type(d)  A.
2. An abbreviation d is of the form hx : AiB and introduces x of type A to abbreviate B.
We dene var(d), type(d) and ab(d) to be x, A, and B respectively.
3. A pseudocontext ? is a (possibly empty) concatenation of declarations and abbreviations
d
1
:d
2
:    :d
n
such that if i 6= j, then var(d
i
) 6 var(d
j
).
4. Dene dom(?) = fvar(d) j d 2 ?g, ?-decl = fd 2 ? j d is a declaration g and ?-abb =
fd 2 ? j d is an abbreviation g. Note that dom(?) = fvar(d) j d 2 ?-decl[ ?-abbg.
5. Dene 
0
between pseudocontexts as the least reexive transitive relation satisfying:
 ?: 
0
?:d: for d a declaration or an abbreviation.
 ?:hx : Ai: 
0
?:hx : AiB:
In the rest of this section, we let `
r
be a notion of derivability. The following is familiar (cf.
[Ba 92]):
Denition 2.3 Let ? be a pseudocontext.
1. A : B is called a statement. A and B are its subject and predicate respectively.
2. ? `
r
A : B is called a judgement, and ? `
r
A : B : C denotes ? `
r
A : B ^ ? `
r
B : C.
3. ? is called legal if 9A;B 2 T such that ? `
r
A : B.
4. A 2 T is called a ?-term if 9B 2 T [? `
r
A : B _ ? `
r
B : A].
5. A 2 T is called legal if 9?[A is a ?-term].
The following is needed in the conversion rule where we replace A =
r
B by ? `
r
A =
ab
B.
Denition 2.4 (Abbreviational r-equality) For all pseudocontexts ? we dene the binary re-
lation ? `
r
 =
ab
 to be the equivalence relation generated by
7
 if A =
r
B then ? `
r
A =
ab
B
 if d 2 ?-abb and A;B 2 T such that B arises from A by substituting one particular free
occurrence of var(d) in A by ab(d), then ? `
r
A =
ab
B.
Remark 2.5 If no abbreviations are present in ? then ? `
r
A =
ab
B is the same as A =
r
B.
The following denition groups some preconditions of some typing rules. For example, instead
of postulating for the start rule (in the case of a declaration) that ? ` type(d) : S and
var(d) 62 ?, we say ?  d. This becomes particularly useful in the case of abbreviations.
Denition 2.6 For d an abbreviation or declaration, we say ? admits d, notation ?  d, i
 ?:d is a pseudocontext
 ? `
r
type(d) : S for some sort S.
 if d is an abbreviation then ? `
r
ab(d) : type(d)
Finally, we extend the -cube notion ? ` d to deal with the case of d being either a declaration
or an abbreviation.
Denition 2.7 Let ? be a pseudocontext. Let d; d
1
; : : : ; d
n
be declarations and abbreviations.
We dene ? `
r
d and ? `
r
d
1
   d
n
as follows:
 If d is a declaration then ? `
r
d i ? `
r
var(d) : type(d). Otherwise, if d is an
abbreviation then ? `
r
d i ? `
r
var(d) : type(d) ^ ? `
r
ab(d) : type(d) ^ ? `
r
var(d) =
ab
ab(d).
 ? `
r
d
1
   d
n
i ? `
r
d
i
for all 1  i  n.
3 Extending the -cube with -reduction
First we introduce the -cube as presented in [Ba 92]. There the only declarations allowed
are of the form hx : Ai, hence there are no abbreviations in the contexts. Thus, ?  d is of the
form ?  hx : Ai and means that ? ` A : S for some S and that x is fresh in ?; A. Moreover,
recall that var(hx : Ai)  x and type(hx : Ai)  A and -reduction is not allowed.
8
Denition 3.1 (`

) Axioms and rules of the -cube; d is a declaration, =
ab
is =

:
(axiom) hi `

 : 2
(start rule)
?  d
?:d `

var(d) : type(d)
(weakening rule)
?  d ? `

D : E
?:d `

D : E
(formation rule)
? `

A : S
1
?:hx : Ai `

B : S
2
? `


x:A
:B : S
2
if (S
1
; S
2
) is a rule
(abstraction rule)
?:hx : Ai `

b : B ? `


x:A
:B : S
? `


x:A
:b : 
x:A
:B
(application rule)
? `

F : 
x:A
:B ? `

a : A
? `

Fa : B[x := a]
(conversion rule)
? `

A : B ? `

B
0
: S ? `

B =
ab
B
0
? `

A : B
0
Each of the eight systems of the -cube is obtained by taking the (S
1
; S
2
) rules allowed from
a subset of f(; ); (;2); (2; ); (2;2)g. These systems are given in the following table:
System Set of specic rules

!
(; )
2 (; ) (2; )
P (; ) (;2)
P2 (; ) (2; ) (;2)
! (; ) (2;2)
! (; ) (2; ) (2;2)
P! (; ) (;2) (2;2)
P! = C (; ) (2; ) (;2) (2;2)
[KN 95b] extended this -cube by changing!

to!

and by changing `

to `

(note
that ? `

B =
ab
B
0
is the same as B =

B
0
, as there are no abbreviations):
Denition 3.2 (`

)
`

is `

where  is replaced by  throughout, and the application rule changes to:
(new application rule)
? `

F : 
x:A
:B ? `

a : A
? `

Fa : (
x:A
:B)a
Now we list some properties of `

and `

without proofs (see [KN 95b]). These properties
(except of course the loss of type correctness, of SR and the non well-formedness of some
types and of -redexes) will be established for the -cube extended with either abbreviations
alone, or with both abbreviations and -reduction in Section 4.
Theorem 3.3 (The Church Rosser Theorem CR, for !
r
, r =  or )
If A!
r
B and A!
r
C then there exists D such that B !
r
D and C !
r
D 2
9
Lemma 3.4 (Start Lemma for `
r
for r =  or )
Let ? be a `
r
-legal context. Then ? `
r
 : 2 and 8d 2 ?[? `
r
d]. 2
Lemma 3.5 (Correctness of types for `

, not for `

)
For r = , but not for r =  we have:
If ? `
r
A : B then (B  2 or ? `
r
B : S for some sort S).
(cf. the counterexample of Subsection 1.1, Problem 1.) 2
Lemma 3.6 (Subject Reduction SR, for `

, not for `

)
For r = , but not for r =  we have:
If ? `
r
A : B and A!

A
0
then ? `
r
A
0
: B
(cf. Subsection 1.1, Problem 2.) 2
However, a weak form of SR holds for `

. First we need the following denition which
removes the outermost -redex of a `

-legal term:
Denition 3.7 For A `

-legal, let
^
A be C[x := D] if A  (
x:B
:C)D and A otherwise.
Lemma 3.8 (Weak Subject Reduction for `

and !

)
If ? `

A : B and A!

A
0
, then ? `

A
0
:
^
B 2
Lemma 3.9 (Well-formedness of types for `

, not for `

)
For r = , but not for r =  we have:
If ? `
r
A : B then B  2 or 9C : ? `
r
B : C.
(cf. Subsection 1.1, Problem 3.) 2
Lemma 3.10 (Non-well-formedness of -redexes)
For no ?, A, B and C there is D such that ? `

(
x:A
:B)C : D.
(cf. Subsection 1.1, Problem 4.) 2
Lemma 3.11 (Uniqueness of Types for `
r
and !
r
for r =  or )
If ? `
r
A : B
1
and ? `
r
A : B
2
, then B
1
=
r
B
2
2
Theorem 3.12 (Strong Normalisation with respect to `
r
and !
r
for r =  or )
If A is `
r
-legal then SN
!
r
(A); i.e. A is strongly normalising with respect to !
r
. 2
In the rest of the paper, we use the -cube to denote the -cube extended with -reduction
and with the new application rule. We write -cube for either the - or the -cube. Recall
that r 2 f; g and  2 f;g.
4 Extending the -cube with abbreviations
We shall extend the derivation rules of `
r
so that we can use abbreviations in the context.
The rules remain unchanged except for the following points:
 One rule, the (abb rule), is added.
 Not only declarations but also abbreviations are allowed in contexts.
10
 The use of ? ` B =
ab
B
0
in the conversion rule really has an eect, since =
ab
is now a
real extension of =
r
and ? may contain abbreviations necessary to establish B =
ab
B
0
.
Note that the intended scope of hx : Ai in ?:hx : AiB: `
r
C : D is ; C and D. This is
what should be expected since the scope of hx : Ai in ?:hx : Ai: `
r
C : D is the same.
Denition 4.1 (Axioms and rules of the -cube extended with abbreviations; d ranges over
declarations and abbreviations. Recall that r is either  or ; in the system where r = ,
we have  = ; if r = ,  can be  or .)
We extend the relation `
r
to `
ra
by adding the following abbreviation rule:
(abb rule)
?:hx : AiB `
ra
C : D
? `
ra
(
x:A
:C)B : D[x := B]
The (abb rule) says that if C : D can be deduced using an abbreviation d  hx : AiB, then
(
x:A
:C)B will be of type D where d has been unfolded in D.
Remark 4.2 (Well-Formedness of -redexes for `
a
)
From the (abb rule) and the (new application rule), if ? `
a
A : B then both A and B
may contain -redexes.
Remark 4.3 When considering an abbreviation in a term to be equivalent to a redex, the
(abb rule) is quite natural: for instance, deriving a type for (
x:
:x)y via abbreviating y to
be x gives the same type as the derivation via abstraction followed by ordinary application
(let ?  h : i:hy : i):
(abb rule)
?:hx : iy `
ra
x : 
? `
ra
(
x:
:x)y : [x := y]
(appl)
(abstr)
?:hx : i `
ra
x :  ? `
ra
(
x:
:) : 
? `
ra

x:
:x : 
x:
:
? `
ra
y : 
? `
ra
(
x:
:x)y : [x := y]
Let us now give an example which shows why abbreviations are useful:
Example 4.4 h : i:hy : i 6`
r
(
:
:(
x:
:x)y) : . We need y :  to be able to type
(
x:
:x)y. Looking carefully however, we nd that (
:
:(
x:
:x)y) is abbreviating  by
. So here is how the above derivation can be obtained using abbreviations (we present a
short-cut and do not mention all the steps, nor the names of the rules):
h : i:hy : i:h : i `
ra

x:
:x : 
x:
:
h : i:hy : i:h : i `
ra
y : 
h : i:hy : i:h : i `
ra
 =
ab

h : i:hy : i:h : i `
ra
y : 
h : i:hy : i:h : i `
ra
(
x:
:x)y : 
h : i:hy : i `
ra
(
:
:(
x:
:x)y) : [ := ]
h : i:hy : i `
ra
(
:
:(
x:
:x)y) : 
Remark 4.5 In [BKN 96], we introduced a notion of generalised denitions which, like abbre-
viations, bind a name to a complex expression. In [BKN 96], a generalisation of -reduction
was inspired by a special notation (see [KN 95a]). With that generalisation of reduction
(which may contract some redex r before other redexes upon which this r depends have been
11
contracted), denitions had to be nested to mirror this generalised reduction. Such nesting
is unnecessary for the reductions we are using in the present paper.
We now study ordinary (non-nested) denitions combined with -reduction. We note that
any abbreviation in the sense of the present paper is also a denition in the sense of [BKN 96]
when the notation is changed. Furthermore any type derivation with abbreviations in this
paper (not involving -reduction) is also a type derivation with denitions in [BKN 96]. That
is, if ? `
a
A : B then I(?) `
e
I(A) : I(B) where `
e
is the type derivation of [BKN 96] and
I translates terms to the notation of [KN 95a].
Now, we go through the usual properties of the -cube showing that they hold for `
ra
.
Lemma 4.6 (Free variable Lemma for `
ra
)
Let ? be a legal context such that ? `
ra
B : C. Then the following holds:
1. If d and d
0
are two dierent elements of ?-decl[ ?-abb, then var(d) 6 var(d
0
).
2. FV (B); FV (C)  dom(?).
3. If ?  ?
1
:d:?
2
then FV (d)  dom(?
1
).
Proof: All by induction on the derivation of ? `
ra
B : C. 2
Lemma 4.7 (Start Lemma for `
ra
)
If ? is legal, then ? `
ra
 : 2 and 8d 2 ?[? `
ra
d].
Proof: If ? is legal then for some terms B;C: ? `
ra
B : C; now use induction on the
derivation of ? `
ra
B : C. 2
Lemma 4.8 (Transitivity Lemma for `
ra
)
Let ? and  be legal contexts such that ? ` .
1. If  `
ra
A =
ab
B then ? `
ra
A =
ab
B.
2. If  `
ra
A : B then ? `
ra
A : B.
Proof:
1. For all d 2 , ? `
ra
var(d) =
ab
ab(d). If A
0
results from A by replacing one free
occurrence of var(d) in A by ab(d), then ? `
ra
A =
ab
A
0
by repeating the process of
proving ? `
ra
var(d) =
ab
ab(d) on the particular occurrence of var(d) in A.
2. Induction on the derivation  `
ra
A : B, using 1 in the case of the conversion rule. 2
Note in the following lemmas how denitions behave well in thinning and substitution.
Lemma 4.9 (Thinning Lemma for `
ra
)
1. If ?
1
:?
2
`
ra
A =
ab
B, ?
1
::?
2
is a legal context, then ?
1
::?
2
`
ra
A =
ab
B.
2. If ? and  are legal contexts such that ? 
0
 and if ? `
ra
A : B, then  `
ra
A : B.
Proof: 1. is by induction on the derivation ?
1
:?
2
`
ra
A =
ab
B. 2. is as follows:
 If ?: `
ra
A : B, ? `
ra
C : S, x is fresh, then also ?:hx : Ci: `
ra
A : B. We show
this by induction on the derivation ?: `
ra
A : B using 1. for conversion.
12
 If ?: `
ra
A : B, ? `
ra
C : D : S, x is fresh, then also ?:hx : DiC: `
ra
A : B. We
show this by induction on the derivation ?: `
ra
A : B.
 If ?:hx : Ai: `
ra
B : C, ? `
ra
D : A, then ?:hx : AiD: `
ra
B : C is shown by
induction on the derivation ?:hx : Ai: `
ra
B : C (for conversion, use 1.; note that
?:hx : Ai: `
ra
B
1
=
ab
B
2
is equivalent to ?: `
ra
B
1
=
ab
B
2
). 2
Lemma 4.10 (Substitution Lemma for `
ra
)
Let d = hx : CiD, 
d
= [x := D], A
d
= A[x := D] and B
d
= B[x := D].
1. If ?:d: `
ra
A =
ab
B, A and B are ?:d:-legal, then ?:
d
`
ra
A
d
=
ab
B
d
.
2. If B is a ?:d-legal term, then ?:d `
ra
B =
ab
B
d
.
3. If ?:d: `
ra
A : B, then ?:
d
`
ra
A
d
: B
d
.
4. If ?:hx : Ci: `
ra
A : B and ? `
ra
D : C, then ?:
d
`
ra
A
d
: B
d
.
Proof: 1. Induction on the generation of =
ab
. 2. Induction on the structure of B. 3.
Induction on the derivation rules, using 1., 2. and thinning. 4. Idem. 2
Lemma 4.11 (Generation Lemma for `
ra
)
1. If ? `
ra
S : C then S   and ? `
ra
C =
ab
2, furthermore if C 6 2 then ? `
ra
C :
S
0
for some sort S
0
.
2. If ? `
ra
x : A then for some d 2 ?, x  var(d), ? `
ra
A =
ab
type(d) and ? `
ra
A : S
for some sort S.
3. If ? `
ra

x:A
:B : C then for some D and sort S: ?:hx : Ai `
ra
B : D, ? `
ra

x:A
:D : S,
? `
ra

x:A
:D =
ab
C and if 
x:A
:D 6 C then ? `
ra
C : S
0
for some sort S
0
.
4. If ? `
ra

x:A
:B : C then for some sorts S
1
; S
2
: ? `
ra
A : S
1
, ?:hx : Ai `
ra
B : S
2
,
(S
1
; S
2
) is a rule, ? `
ra
C =
ab
S
2
and if S
2
6 C then ? `
ra
C : S for some sort S.
5. If ? `
ra
Fa : C, F 6 
x:A
:B, then for some D;E: ? `
ra
a : D, ? `
ra
F : 
x:D
:E,
? `
ra
T =
ab
C and if T 6 C then ? `
ra
C : S for some S, where T  (
x:D
:E)a if
r =  and T  E[x := a] if r = .
6. If ? `
ra
(
x:A
:D)B : C, then ?:hx : AiB `
ra
D : C
Proof: 1., 2., 3., 4. and 5. follow by induction on the derivations (use Thinning). As to 6.,
an easy induction on the derivation rules shows that one of the following holds:
 ?:hx : AiB `
ra
D : E;? `
ra
E[x := B] =
ab
C and E[x := B] 6 C ) 9S:? `
ra
C : S.
 ? `
ra
B : F , ? `
ra

x:A
:D : 
y:F
:G, ? `
ra
C =
ab
T and if T 6 C where T  (
y:F
:G)B
if r =  and T  G[y := B] if r = , then ? `
ra
C : S for some sort S.
In both cases use thinning and conversion; in the second case use also 3. 2
Now, recall that correctness of types fails for `

but holds for `

. Here we show it for `
ra
.
13
Lemma 4.12 (Correctness (and hence well-formedness) of Types for `
ra
)
If ? `
ra
A : B then B  2 or ? `
ra
B : S for some sort S.
Proof: By induction on the derivation rules. The interesting cases are:
 Abbreviation: If ? `
ra
(
x:A
:D)B : C[x := B] where ?:hx : AiB `
ra
D : C, then by IH,
C  2 or 9S;?:hx : AiB `
ra
C : S. If C  2 then C[x := B]  2; else, by Substitution
Lemma ? `
ra
C[x := B] : S[x := B]  S.
 Application: If ? `
a
Fa : (
x:A
:B)a where ? `
a
F : 
x:A
:B and ? `
a
a : A,
then by IH, 9S;? `
a

x:A
:B : S. By Generation ?:hx : Ai `
a
B : S. By Thinning
?:hx : Aia `
a
B : S and by the (abb rule) ? `
a
(
x:A
:B)a : S[x := a]  S. 2
From correctness of types for `
ra
, we can establish its subject reduction.
Theorem 4.13 (Subject Reduction for `
ra
and !
r
)
If ? `
ra
A : B and A!
r
A
0
then ? `
ra
A
0
: B.
Proof: We prove by simultaneous induction on the derivation rules:
1. If ? `
ra
A : B and ?
0
results from contracting one of the terms in the declarations and
abbreviations of ? by a one step r-reduction, then ?
0
`
ra
A : B
2. If ? `
ra
A : B and A!
r
A
0
then ? `
ra
A
0
: B
We will only treat the case r = . If the derivation rule is (axiom): easy. If it is (start
rule): we consider the case d  hx : AiB, A !

A
0
. The other cases are similar or easy.
We have: ?:hx : AiB `
a
x : A where ?  hx : AiB, i.e. ? `
a
B : A : S. By IH,
? `
a
A
0
: S. By conversion ? `
a
B : A
0
. Hence ?:hx : A
0
iB `
a
x : A
0
and again by
conversion ?:hx : A
0
iB `
a
x : A.
If the derivation rule is (weak), (formation), (conversion) or (abstraction): use IH (and
conversion for abstraction). Now we treat the rest:
 (abbreviation): ? `
a
(
x:A
:D)B : C[x := B] where ?:hx : AiB `
a
D : C.
Now ?
0
`
a
(
x:A
:D)B : C[x := B], ? `
a
(
x:A
:D
0
)B : C[x := B] and ? `
a
(
x:A
0
:D)B : C[x := B] by IH. Furthermore, if B !

B
0
then ? `
a
C[x := B] =
ab
C[x := B
0
] and by IH and the (abb rule) we get ? `
a
(
x:A
:D)B
0
: C[x := B
0
]. Now
by Lemma 4.12, applied to the judgement ?:hx : AiB `
a
D : C, we get: C  2
or 9S;?:hx : AiB `
a
C : S. If C  2 then C[x := B]  C  C[x := B
0
]. Else,
by the Substitution Lemma ? `
a
C[x := B] : S[x := B]  S, so by conversion
? `
a
(
x:A
:D)B
0
: C[x := B].
For the last possibility, (
x:A
:D)B !

D[x := B], we remark that by the Substitution
Lemma, ?:hx : AiB `
a
D : C leads to ? `
a
D[x := B] : C[x := B].
 (application): ? `
a
Fa : (
x:A
:B)a where ? `
a
F : 
x:A
:B and ? `
a
a : A. Then
?
0
`
a
Fa : (
x:A
:B)a and ? `
a
F
0
a : (
x:A
:B)a by IH, and ? `
a
Fa
0
: (
x:A
:B)a
because by IH ? `
a
Fa
0
: (
x:A
:B)a
0
, by Lemma 4.12 9S;? `
a
(
x:A
:B)a : S, so by
conversion ? `
a
Fa
0
: (
x:A
:B)a.
Now the crucial case: F  (
y:C
:D), Fa !

D[y := a]. Then ? `
a
(
y:C
:D)a :
(
x:A
:B)a so by Generation ?:hy : Cia `
a
D : (
x:A
:B)a, now by Substitution ? `
a
D[y := a] : ((
x:A
:B)a)[y := a], but by BC ((
x:A
:B)a)[y := a]  (
x:A
:B)a. 2
14
The proof of strong normalisation (SN) is based on SN of the -cube extended with abbre-
viations as in [BKN 96]. SN
!
r
(A) denotes that A is strongly normalising with respect to
!
r
.
Theorem 4.14 (Strong Normalisation for the -cube with respect to `
a
and !

)
If A is a `
a
-legal term then SN
!

(A).
Proof: By Remark 4.5, `
a
is a subset of `
e
of [BKN 96] in that if ? `
a
A : B then
? `
e
A : B (abstracting from the dierent notation). Now, SN for `
a
follows from that of
`
e
(see [BKN 96] for the lengthy but standard proof (similar to that of [Geu 95]) of SN for
`
e
which can be adapted to `
a
). 2
SN of `
a
is a consequence of that of `
a
. First we change -redexes into -redexes.
3
Denition 4.15
 For all pseudo-expressions A we dene
e
A to be the term A where in all -redexes the
-symbol has been changed into a -symbol, creating a -redex instead.
 For a context ?  d
1
:    :d
n
we dene
e
? to be
f
d
1
:    :
f
d
n
, where
g
hx : Ai  hx :
e
Ai and
g
hx : AiB  hx :
e
Ai
e
B.
Lemma 4.16 If ? `
a
A : B then
e
? `
a
e
A :
e
B.
Proof: Induction on the derivation rules of `
a
. All rules except the (new application
rule) are trivial since they are also rules in `
a
.
If ? `
a
Fa : (
x:A
:B)a results from ? `
a
F : 
x:A
:B and ? `
a
a : A. Then by IH
e
? `
a
e
F : 
x:
e
A
:
e
B and
e
? `
a
e
a :
e
A, so by application of `
a
,
e
? `
a
e
F
e
a :
e
B[x :=
e
a].
As
e
? `
a
e
F : 
x:
e
A
:
e
B, we also get
e
?:hx :
e
Ai `
a
e
B : S and hence by thinning and the (abb
rule) for `
a
,
e
? `
a
(
x:
e
A
:
e
B)
e
a : S, so by conversion
e
? `
a
e
F
e
a : (
x:
e
A
:
e
B)
e
a.
It remains to be shown that
e
F
e
a 
f
Fa, i.e., F is not a -term. Suppose towards a contra-
diction that F is a -term, then by generation on ? `
a
F : 
x:A
:B, ? `
a

x:A
:B =
ab
S
for some sort S. This is clearly a contradiction. 2
Theorem 4.17 (Strong Normalisation for the -cube with respect to `
a
and !

)
If A is a `
a
-legal term then SN
!

(A).
Proof: If A is `
a
-legal then
e
A is `
a
-legal by Lemma 4.16 and hence SN
!

(
e
A) (The-
orem 4.14). Due to Subject Reduction of `
a
, no -redexes can be created in the course of
!

-reduction of
e
A, therefore SN
!

(
e
A) implies SN
!

(A). 2
See [KN 95b, BKN 96] for other properties of the -cube with -reduction or abbreviations.
5 Conclusion
In type theory, abstraction is done via both  and  and one writes either 
x:A
:B or 
x:A
:B.
Reduction, however, is usually restricted to -redexes. Hence, one evaluates (
x:A
:B)C to
B[x := C], but usually one does not allow (
x:A
:B)C as a term which can be evaluated to
3
Note that in general this requires the level of the type system in the cube (i.e. abstractions that are allowed)
to be raised.
15
B[x := C]. An exception to this is the AUTOMATH notation where the distinction between
 and  is absent and one writes [x : A]B to express either 
x:A
:B or 
x:A
:B. In all type
systems however (including AUTOMATH and the system of this paper), there is a distinction
between  and . The various accounts dier in how large such a distinction is.
We believe that  and  can be treated similarly to a great extent, by the incorporation of
-reduction. As we have seen, applications of type systems use -reduction. AUTOMATH
did introduce -reduction, but its formal properties were only established for the rst time
in [KN 95b] and later the problems were reconsidered in [PM 97].
In this paper, we made  behave more like an abstraction operator and gave a -
abstraction the right to be applied to another term. We did not however allow a -abstraction
to be typed by another abstraction. Otherwise, one will need more abstraction operators than
 and  and this naturally leads to an innite level of abstraction operators as discussed in
Subsection 1.3. Our choice has been to express the type of a -term as a simple sort given by
the formation rule and to type a -redex using abbreviations. To do this, we typed (
x:A
:C)B
in context ? by typing C in context ?:hx : AiB. Our addition of abbreviations (which dier
in this paper from the existing notions of denitions in the literature), is simple and worth
studying. Furthermore, this addition enabled us to solve the problems of the -cube that
were left open in [KN 95b].
There are many arguments why -reduction and abbreviations must be considered and
why a system combining both, without losing any of the nice properties of the -cube, is
certainly worth considering. Moreover, we nd it intriguing that so far in the literature, ab-
breviations have been added for reasons of eciency of implementation and not because they
solve theoretical problems. In this paper, we have shown that abbreviations solve the prob-
lems of the -cube extended with -reduction. In [BKN 96], we have shown that denitions
solve the problem of subject reduction in the -cube extended with a notion of generalised re-
duction. The reason why abbreviations solve these problems is that they keep information in
the context about the dened values of some variables, thus preventing that this information
gets lost in a reduction process.
Hence, our paper contributes to other work on denitions not only in that it oers a simple
and attractive account of denitions or abbreviations which keeps all the original properties
of the -cube, but also because it shows that abbreviations are theoretically important and
should hence be introduced in the -cube. Figure 1 on page 17 summarizes our results in
this paper where we use the following notational conventions: CR, SN, SR and TC stand
for Church Rosser, strong normalisation, subject reduction and type correctness respectively;
WF stands for well-formedness of the type of an expression, 
abb
-cube is the -cube extended
with abbreviations for  =  or .
A question may now occur to the reader: \If our paper is concerned with abstractions via
 and , then why have another kind of abstraction in the contexts? Why write hx : Ai and
hx : AiB to describe the binding rather than use  and ?". We believe strongly that the
binding operators  and  should be used in the contexts as well and indeed in many of our
work we do so [KN 95b, BKN 96]. In this paper however, we refrain from this option because
we do not want to give the false impression that a binding in the context using either  or
 has anything to do with solving the problems of -reduction that we are tackling. If the
reader however is interested in using 's and 's in the context and hence in writing 
x:A
or

x:A
, for declarations and (
x:A
: )B or (
x:A
: )B for abbreviations, then he/she may like
16
-cube (CR, SN)

abb
-cube (CR, SN, SR, TC, WF)
-cube (CR, SN, SR, TC, WF)
@
@
@
@R
 
 
 
 	

abb
-cube (CR, SN, SR,TC,WF)
@
@
@
@R
 
 
 
 	
Figure 1: Properties of the -cube with various extensions
to know that with such an account and the following new version of the (abb rule):
(-abb rule)
?:(
x:A
: )B ` C : D
? ` (
x:A
:C)B : D[x := B]
where  2 f;g
one can show the following lemma, the proof of which is by a simple induction on the derivation
rules:
Lemma 5.1 (-exchanging) The following holds:
1. ?:
x:A
: `
a
C : D () ?:
x:A
: `
a
C : D
2. ?:(
x:A
: )B: `
a
C : D () ?:(
x:A
: )B: `
a
C : D
Note that, although  and  can be freely interchanged in contexts, it remains desirable to
keep a distinction between them as two abstractors in our terms. This is what we do in this
article. In fact, we don't distinguish them in the context (by writing hx : Ai instead of either

x:A
or 
x:A
). We do however distinguish them on the right hand side of `. For example,
from hx : i ` x :  using the formation rule (2;2), we get: ` 
x:
:x : 
x:
: and ` 
x:
: : 2.
Note also that ` 
x:
:x :  which shows that a -abstraction has a dierent type than a
-abstraction.
6 Acknowledgements
The authors are grateful to an anonymous referee for the useful comments and suggestions.
Kamareddine is grateful to Assaf Kfoury and Joe Wells for their hospitality while preparing
this article. Moreover, she is grateful to the Department of Mathematics and Computing
Science, Eindhoven University of Technology, for their nancial support and hospitality from
October 1991 to September 1992, and during various regular visits since then. She is, fur-
thermore, grateful to the Dutch organisation of research (NWO), to the British Council and
to the Action for Basic Research ESPRIT Project \Types for Proofs and Programs" for their
nancial support. Bloo has been supported by the Netherlands Computer Science Research
Foundation (SION) with nancial support from the Netherlands Organisation for Scientic
Research (NWO) and is grateful to the Department of Computing Science, Glasgow Univer-
sity, for their nancial support and hospitality during work on this subject.
17
References
[AFMOW95] Z. M. Ariola, M. Felleisen, J. Maraist, M. Odersky, and P. Wadler, A call-by-need lambda
calculus, In Conf. Rec. 22nd Ann. ACM Symp. Principles Programming Languages, 1995.
[Ba 84] H. Barendregt, Lambda Calculus: its Syntax and Semantics, North-Holland, 1984.
[Ba 92] H. Barendregt, Lambda calculi with types, Handbook of Logic in Computer Science, II, eds.
S. Abramsky, D.M. Gabbay, and T.S.E. Maibaum, Oxford University Press, 118-414, 1992.
[BLR96] Z. Benaissa, P. Lescanne, and K. Rose, Modeling Sharing and Recursion for Weak Reduc-
tion Strategies Using Explicit Substitution, PLILP96, Lecture Notes in Computer Science 1140,
Springer Verlag, 1996.
[BKN 96] R. Bloo, F. Kamareddine, and R.P. Nederpelt, The Barendregt Cube with Denitions and
Generalised Reduction, Information and Computation 126(2), 123-143, 1996.
[Con 86] R. Constable et al., Implementing Mathematics with the NUPRL Development System,
Prentice-Hall, 1986.
[Dow 91] G. Dowek, et al. The Coq proof assistant version 5.6, users guide, rapport de recherche 134,
INRIA, 1991.
[Geu 95] H. Geuvers, A short and exible proof of strong normalization for the Calculus of Construc-
tions, in Types for Proofs and Programs, eds. P. Dybjer, B. Nordstrom, and J. Smith, International
Workshop TYPES '94, LNCS 996, 14-38, Springer, 1995.
[LP 92] Z. Luo, and R. Pollack,, LEGO proof development system: User's manual, Technical report
ECS-LFCS-92-211, LFCS, University of Edinburgh, 1992.
[KN 95a] F. Kamareddine, and R.P. Nederpelt, Rening reduction in the -calculus, Functional Pro-
gramming 5 (4), 637-651, 1995.
[KN 95b] F. Kamareddine, and R.P. Nederpelt, Canonical Typing and -Conversion in the Barendregt
Cube, Functional Programming 6 (2), 245-267, 1996.
[NGV 94] R.P. Nederpelt, J.H. Geuvers, and R.C. de Vrijer, eds., Selected Papers on AUTOMATH ,
North-Holland, 1994.
[PJ 96] S. Peyton Jones, Compilation by transformation: a report from the trenches, in European
Symposium on programming (ESOP'96), Springer Verlag LNCS 1058, 1996.
[PM 97] S. Peyton Jones and E. Meijer, Henk: a typed intermediate language, Types In Compilations
Workshop, 1997.
[SA 95] Z. Shao and A.W. Appel, A type-based compiler for standard ML, in SIGPLAN Symposium
on Programming Language Design and Implementation (PLDI'95), La Jolla, ACM, 1995.
[SP 93] P. Severi, and E. Poll, Pure Type Systems with Denitions, Computing Science Note 93/24,
Department of Mathematics and Computing Science, Eindhoven University of Technology, 1993.
[TMCSHL 96] D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper and P. Lee, TIL: A Type-
Directed Optimizing Compiler for ML, in SIGPLAN Symposium on Programming Language De-
sign and Implementation (PLDI'96), Philadelphia, ACM, 1996.
18
