Lectures on the
Curry-Howard Isomorphism
Morten Heine B. Srensen
University of Copenhagen
Pawe l Urzyczyn
University of Warsaw
Preface
The Curry-Howard isomorphism states an amazing correspondence between
systems of formal logic as encountered in proof theory and computational
calculi as found in type theory. For instance, minimal propositional logic
corresponds to simply typed -calculus, rst-order logic corresponds to de-
pendent types, second-order logic corresponds to polymorphic types, etc.
The isomorphism has many aspects, even at the syntactic level: formulas
correspond to types, proofs correspond to terms, provability corresponds to
inhabitation, proof normalization corresponds to term reduction, etc.
But there is much more to the isomorphism than this. For instance,
it is an old idea|due to Brouwer, Kolmogorov, and Heyting, and later
formalized by Kleene's realizability interpretation|that a constructive proof
of an implication is a procedure that transforms proofs of the antecedent
into proofs of the succedent; the Curry-Howard isomorphism gives syntactic
representations of such procedures.
These notes give an introduction to parts of proof theory and related
aspects of type theory relevant for the Curry-Howard isomorphism.
Outline
Since most calculi found in type theory build on -calculus, the notes be-
gin, in Chapter 1, with an introduction to type-free -calculus. The intro-
duction derives the most rudimentary properties of -reduction including
the Church-Rosser theorem. It also presents Kleene's theorem stating that
all recursive functions are -denable and Church's theorem stating that
-equality is undecidable.
As explained above, an important part of the Curry-Howard isomor-
phism is the idea that a constructive proof of an implication is a certain
procedure. This calls for some elaboration of what is meant by constructive
proofs, and Chapter 2 therefore presents intuitionistic propositional logic.
The chapter presents a natural deduction formulation of minimal and intu-
itionistic propositional logic. The usual semantics in terms of Heyting alge-
bras and in terms of Kripke models are introduced|the former explained
i
ii Preface
on the basis of Boolean algebras|and the soundness and completeness re-
sults are then proved. An informal proof semantics, the so-called BHK-
interpretation, is also presented.
Chapter 3 presents the simply typed -calculus and its most fundamen-
tal properties up to the subject reduction property and the Church-Rosser
property. The distinction between simply typed -calculus a la Church and
a la Curry is introduced, and the uniqueness of types property|which fails
for the Curry system|is proved for the Church system. The equivalence
between the two systems, in a certain sense, is also established. The chapter
also proves the weak normalization property by the Turing-Prawitz method,
and ends with Schwichtenberg's theorem stating that the numeric functions
representable in simply typed -calculus are exactly the extended polyno-
mials.
This provides enough background material for our rst presentation of
the Curry-Howard isomorphism in Chapter 4, as it appears in the con-
text of natural deduction for minimal propositional logic and simpy typed
-calculus. The chapter presents another formulation of natural deduction,
which is often used in the proof theory literature, and which facilitates a ner
distinction between similar proofs. The exact correspondence between nat-
ural deduction for minimal propositional logic and simply typed -calculus
is then presented. The extension to product and sum types is also discussed.
After a brief part on proof-theoretical applications of the weak normaliza-
tion property, the chapter ends with a proof of strong normalization using
the Tait-Girard method, here phrased in terms of saturated sets.
Chapter 5 presents the variation of the Curry-Howard isomorphism in
which one replaces natural deduction by Hilbert style proofs and simply
typed -calculus by simply typed combinatory logic. After type-free com-
binators and weak reduction|and the Church-Rosser property|the usual
translations from -calculus to combinators, and vice versa, are introduced
and shown to preserve some of the desired properties pertaining to weak
reduction and -reduction. Then combinators with types are introduced,
and the translations studied in this setting. Finally Hilbert-style proofs
are introduced, and the connection to combinators with types proved. The
chapter ends with a part on subsystems of combinators in which relevance
and linearity play a role.
Having seen two logics or, equivalently, two calculi with types, Chapter 6
then studies decision problems in these calculi, mainly the type checking,
the type reconstruction, and the type inhabitation problem. The type re-
construction problem is shown to be P-complete by reduction to and from
unication (only the reduction to unication is given in detail). The type
inhabitation problem is shown to be PSPACE-complete by a reduction from
the satisability problem for classical second-order propositional formulas.
The chapter ends with Statman's theorem stating that equality on typed
terms is non-elementary.
Outline iii
After introducing natural deduction systems and Hilbert-style systems,
the notes introduce in Chapter 7 Gentzen's sequent calculus systems for
propositional logic. Both classical and intuitionistic variants are introduced.
In both cases a somewhat rare presentation|taken from Prawitz|with as-
sumptions as sets, not sequences, is adopted. For the intuitionistic system
the cut-elimination theorem is mentioned, and from this the subformula
property and decidability of the logic are inferred. Two aproaches to term
assignment for sequent calculus proofs are studied. In the rst approach,
the terms are those of the simply typed -calculus. For this approach, the
connection between normal forms and cut-free proofs is studied in some de-
tail. In the second approach, the terms are intended to mimic exactly the
rules of the calculus, and this assignment is used to prove the cut-elimination
theorem in a compact way.
The remaining chapters study variations of the Curry-Howard isomor-
phism for more expressive type systems and logics.
In Chapter 8 we consider the most elementary connections between nat-
ural deduction for classical propositional logic and simply typed -calculus
with control operators, in particular, the correspondence between classical
proof normalization and reduction of control operators. Kolmogorov's em-
bedding of classical logic into intuitionistic logic is shown to induce a con-
tinuation passing style translation which eliminates control operators.
Chapter 9 is about rst-order logic. After a presentation of the syntax
for quantiers, the proof systems and interpretations seen in earlier chapters
are generalized to the rst-order case.
Chapter 10 presents dependent types, as manifest in the calculus P.
The strong normalization property is proved by a translation to simply typed
-calculus. A variant of P a la Curry is introduced. By another translation
it is shown that a term is typable in P a la Curry i it is typable in simply
typed -calculus. While this shows that type reconstruction is no harder
than in simply typed -calculus, the type checking problem in P a la Curry
turns out to be undecidable. The last result of the chapter shows that rst-
order logic can be encoded in P.
In Chapter 11 we study arithmetic. The chapter introduces Peano Arith-
metic (PA) and briey recalls Godel's theorems and the usual result stating
that exactly the recursive functions can be represented in Peano Arithmetic.
The notion of a provably total recursive function is also introduced. Heyt-
ing arithmetic (HA) is then introduced and Kreisel's theorem stating that
provable totality in HA and PA coincide is presented. Then Kleene's real-
izability interpretation is introduced|as a way of formalizing the BHK-
interpretation|and used to prove consistency of HA. Godel's system T
is then introduced and proved to be strongly normalizing. The failure of
arithmetization of proofs of this property is mentioned. The result stating
that the functions denable in T are the functions provably total in Peano
Arithmetic is also presented. Finally, Godel's Dialectica interpretation is
iv Preface
presented and used to prove consistency of HA and to prove that all func-
tions provably total in Peano Arithmetic are denable in T.
Chapter 12 is about second-order logic and polymorphism. For the sake
of simplicity, only second-order propositional systems are considered. Natu-
ral deduction, Heyting algebras, and Kripke models are extended to the new
setting. The polymorphic -calculus is then presented, and the correspon-
dence with second-order logic developed. After a part about denability
of data types, a Curry version of the polymorphic -calculus is introduced,
and Wells' theorem stating that type reconstruction and type checking are
undecidable is mentioned. The strong normalization property is also proved.
The last chapter, Chapter 13, presents the -cube and pure type systems.
First Barendregt's cube is presented, and its systems shown equivalent to
previous formulations by means of a classication result. Then the cube is
geneneralized to pure type systems which are then developed in some detail.
About the notes
Each chapter is provided with a number of exercises. We recommend that
the reader try as many of these as possible. At the end of the notes, answers
and hints are provided to some of the exercises.
1
The notes cover material from the following sources:
 Girard, Lafont, Taylor: Proofs and Types, Cambridge Tracts in Theo-
retical Computer Science 7, 1989.
 Troelstra, Schwichtenberg: Basic Proof Theory, Cambridge Tracts in
Theoretical Computer Science 43, 1996.
 Hindley: Basic Simple Type Theory, Cambridge Tracts in Theoretical
Computer Science 42, 1997.
 Barendregt: Lambda Calculi with Types, pages 117{309 of Abram-
sky, S. and D.M. Gabbay and T.S.E. Maibaum, editors, Handbook of
Logic in Computer Science, Volume II, Oxford University Press, 1992.
Either of these sources make excellent supplementary reading.
The notes are largely self-contained, although a greater appreciation of
some parts can probably be obtained by readers familiar with mathemat-
ical logic, recursion theory and complexity. We recommend the following
textbooks as basic references for these areas:
 Mendelson: Introduction to Mathematical Logic, fourth edition, Chap-
man & Hall, London, 1997.
1
This part is quite incomplete due to the \work-in-progress" character of the notes.
About the notes v
 Jones: Computability and Complexity From a Programming Perspec-
tive, MIT Press, 1997.
The notes have been used for a one-semester graduate/Ph.D. course
at the Department of Computer Science at the University of Copenhagen
(DIKU). Roughly one chapter was presented at each lecture, sometimes
leaving material out.
The notes are still in progress and should not be conceived as having
been proof read carefully to the last detail. Nevertheless, we are grateful
to the students attending the course for pointing out numerous typos, for
spotting actual mistakes, and for suggesting improvements to the exposition.
This joint work was made possible thanks to the visiting position funded
by the University of Copenhagen, and held by the second author at DIKU
in the winter and summer semesters of the academic year 1997-8.
M.H.B.S. & P.U., May 1998
vi
Contents
Preface i
Outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . i
About the notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . iv
1 Type-free -calculus 1
1.1 -terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 Reduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
1.3 Informal interpretation . . . . . . . . . . . . . . . . . . . . . . 7
1.4 The Church-Rosser Theorem . . . . . . . . . . . . . . . . . . 8
1.5 Expressibility and undecidability . . . . . . . . . . . . . . . . 11
1.6 Historical remarks . . . . . . . . . . . . . . . . . . . . . . . . 19
1.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2 Intuitionistic logic 23
2.1 Intuitive semantics . . . . . . . . . . . . . . . . . . . . . . . . 24
2.2 Natural deduction . . . . . . . . . . . . . . . . . . . . . . . . 25
2.3 Algebraic semantics of classical logic . . . . . . . . . . . . . . 28
2.4 Heyting algebras . . . . . . . . . . . . . . . . . . . . . . . . . 30
2.5 Kripke semantics . . . . . . . . . . . . . . . . . . . . . . . . . 34
2.6 The implicational fragment . . . . . . . . . . . . . . . . . . . 36
2.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
3 Simply typed -calculus 41
3.1 Simply typed -calculus a la Curry . . . . . . . . . . . . . . . 41
3.2 Simply typed -calculus a la Church . . . . . . . . . . . . . . 45
3.3 Church versus Curry typing . . . . . . . . . . . . . . . . . . . 49
3.4 Normalization . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
3.5 Expressibility . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
3.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
vii
viii Contents
4 The Curry-Howard isomorphism 57
4.1 Natural deduction without contexts . . . . . . . . . . . . . . 57
4.2 The Curry-Howard isomorphism . . . . . . . . . . . . . . . . 63
4.3 Consistency from normalization . . . . . . . . . . . . . . . . . 68
4.4 Strong normalization . . . . . . . . . . . . . . . . . . . . . . . 68
4.5 Historical remarks . . . . . . . . . . . . . . . . . . . . . . . . 71
4.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
5 Proofs as combinators 75
5.1 Combinatory logic . . . . . . . . . . . . . . . . . . . . . . . . 75
5.2 Typed combinators . . . . . . . . . . . . . . . . . . . . . . . . 79
5.3 Hilbert-style proofs . . . . . . . . . . . . . . . . . . . . . . . . 81
5.4 Relevance and linearity . . . . . . . . . . . . . . . . . . . . . 83
5.5 Historical remarks . . . . . . . . . . . . . . . . . . . . . . . . 87
5.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
6 Type-checking and related problems 89
6.1 Hard and complete . . . . . . . . . . . . . . . . . . . . . . . . 90
6.2 The 12 variants . . . . . . . . . . . . . . . . . . . . . . . . . . 91
6.3 (First-order) unication . . . . . . . . . . . . . . . . . . . . . 92
6.4 Type reconstruction algorithm . . . . . . . . . . . . . . . . . 95
6.5 Eta-reductions . . . . . . . . . . . . . . . . . . . . . . . . . . 97
6.6 Type inhabitation . . . . . . . . . . . . . . . . . . . . . . . . 99
6.7 Equality of typed terms . . . . . . . . . . . . . . . . . . . . . 101
6.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
7 Sequent calculus 105
7.1 Classical sequent calculus . . . . . . . . . . . . . . . . . . . . 106
7.2 Intuitionistic sequent calculus . . . . . . . . . . . . . . . . . . 109
7.3 Cut elimination . . . . . . . . . . . . . . . . . . . . . . . . . . 113
7.4 Term assignment for sequent calculus . . . . . . . . . . . . . . 115
7.5 The general case . . . . . . . . . . . . . . . . . . . . . . . . . 118
7.6 Alternative term assignment . . . . . . . . . . . . . . . . . . . 121
7.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
8 Classical logic and control operators 127
8.1 Classical propositional logic, implicational fragment . . . . . 127
8.2 The full system . . . . . . . . . . . . . . . . . . . . . . . . . . 131
8.3 Terms for classical proofs . . . . . . . . . . . . . . . . . . . . 132
8.4 Classical proof normalization . . . . . . . . . . . . . . . . . . 133
8.5 Denability of pairs and sums . . . . . . . . . . . . . . . . . . 135
8.6 Embedding into intuitionistic propositional logic . . . . . . . 136
8.7 Control operators and CPS translations . . . . . . . . . . . . 138
8.8 Historical remarks . . . . . . . . . . . . . . . . . . . . . . . . 140
Contents ix
8.9 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
9 First-order logic 143
9.1 Syntax of rst-order logic . . . . . . . . . . . . . . . . . . . . 143
9.2 Intuitive semantics . . . . . . . . . . . . . . . . . . . . . . . . 145
9.3 Proof systems . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
9.4 Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
9.5 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
10 Dependent types 155
10.1 System P . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
10.2 Rules of P . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
10.3 Properties of P . . . . . . . . . . . . . . . . . . . . . . . . . 159
10.4 Dependent types a la Curry . . . . . . . . . . . . . . . . . . . 161
10.5 Existential quantication . . . . . . . . . . . . . . . . . . . . 162
10.6 Correspondence with rst-order logic . . . . . . . . . . . . . . 163
10.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
11 First-order arithmetic and Godel's T 169
11.1 The language of arithmetic . . . . . . . . . . . . . . . . . . . 169
11.2 Peano Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . 170
11.3 Representable and provably recursive functions . . . . . . . . 172
11.4 Heyting Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . 174
11.5 Kleene's realizability interpretation . . . . . . . . . . . . . . . 176
11.6 Godel's System T . . . . . . . . . . . . . . . . . . . . . . . . . 179
11.7 Godel's Dialectica interpretation . . . . . . . . . . . . . . . . 183
11.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
12 Second-order logic and polymorphism 191
12.1 Propositional second-order formulas . . . . . . . . . . . . . . 191
12.2 Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
12.3 Polymorphic lambda-calculus (System F) . . . . . . . . . . . 196
12.4 Expressive power . . . . . . . . . . . . . . . . . . . . . . . . . 199
12.5 Curry-style polymorphism . . . . . . . . . . . . . . . . . . . . 203
12.6 Strong normalization of second-order typed -calculus . . . . 205
12.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
13 The -cube and pure type systems 209
13.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
13.2 Barendregt's -cube . . . . . . . . . . . . . . . . . . . . . . . 211
13.3 Example derivations . . . . . . . . . . . . . . . . . . . . . . . 214
13.4 Classication and equivalence with previous formulations . . 217
13.5 Pure type systems . . . . . . . . . . . . . . . . . . . . . . . . 219
13.6 Examples of pure type systems . . . . . . . . . . . . . . . . . 221
x Contents
13.7 Properties of pure type systems . . . . . . . . . . . . . . . . . 222
13.8 The Barendregt-Geuvers-Klop conjecture . . . . . . . . . . . 225
14 Solutions and hints to selected exercises 227
CHAPTER 1
Type-free -calculus
The -calculus is a collection of formal theories of interest in, e.g., computer
science and logic. The -calculus and the related systems of combinatory
logic were originally proposed as a foundation of mathematics around 1930
by Church and Curry, but the proposed systems were subsequently shown
to be inconsistent by Church's students Kleene and Rosser in 1935.
However, a certain subsystem consisting of the -terms equipped with
so-called -reduction turned out to be useful for formalizing the intuitive
notion of eective computability and led to Church's thesis stating that
-denability is an appropriate formalization of the intuitive notion of eec-
tive computability. The study of this subsystem|which was proved to be
consistent by Church and Rosser in 1936|was a main inspiration for the
development of recursion theory.
With the invention of physical computers came also programming lan-
guages, and -calculus has proved to be a useful tool in the design, imple-
mentation, and theory of programming languages. For instance, -calculus
may be considered an idealized sublanguage of some programming languages
like LISP. Also, -calculus is useful for expressing semantics of program-
ming languages as done in denotational semantics. According to Hindley
and Seldin [55, p.43], \-calculus and combinatory logic are regarded as
`test-beds' in the study of higher-order programming languages: techniques
are tried out on these two simple languages, developed, and then applied to
other more `practical' languages."
The -calculus is sometimes called type-free or untyped to distinguish it
from variants in which types play a role; these variants will be introduced
in the next chapter.
1.1. -terms
The objects of study in -calculus are -terms. In order to introduce these,
it is convenient to introduce the notion of a pre-term.
1
2 Chapter 1. Type-free -calculus
1.1.1. Definition. Let
V = fv
0
; v
1
; : : : g
denote an innite alphabet. The set 
?
of pre-terms is the set of strings
dened by the grammar:

?
::= V j (
?

?
) j (V 
?
)
1.1.2. Example. The following are pre-terms.
(i) ((v
0
v
1
) v
2
) 2 
?
;
(ii) (v
0
(v
0
v
1
)) 2 
?
;
(iii) ((v
0
v
0
) v
1
) 2 
?
;
(iv) ((v
0
(v
0
v
0
)) (v
1
(v
1
v
1
))) 2 
?
.
1.1.3. Notation. We use uppercase letters, e.g., K;L;M;N; P;Q;R with or
without subscripts to denote arbitrary elements of 
?
and lowercase letters,
e.g., x; y; z with or without subscripts to denote arbitrary elements of V .
1.1.4. Terminology.
(i) A pre-term of form x (i.e., an element of V ) is called a variable;
(ii) A pre-term of form (xM) is called an abstraction (over x);
(iii) A pre-term of form (M N) is called an application (of M to N).
The heavy use of parentheses is rather cumbersome. We therefore intro-
duce the following, standard conventions for omitting parentheses without
introducing ambiguity. We shall make use of these conventions under a
no-compulsion/no-prohibition agreement|see Remark 1.1.10.
1.1.5. Notation. We use the shorthands
(i) (K L M) for ((K L) M);
(ii) (x y M) for (x (y M));
(iii) (xM N) for (x (M N));
(iv) (M xN) for (M (x N)).
We also omit outermost parentheses.
1.1.6. Remark. The two rst shorthands concern nested applications and
abstractions, respectively. The two next ones concern applications nested
inside abstractions and vice versa, respectively.
To remember the shorthands, think of application as associating to the
left, and think of abstractions as extending as far to the right as possible.
1.1. -terms 3
When abstracting over a number of variables, each variable must be
accompanied by an abstraction. It is therefore convenient to introduce the
following shorthand.
1.1.7. Notation. We write x
1
: : : x
n
:M for x
1
: : : x
n
M . As a special
case, we write x:M for xM .
1.1.8. Remark. Whereas abstractions are written with a , there is no cor-
responding symbol for applications; these are written simply by juxtaposi-
tion. Hence, there is no corresponding shorthand for applications.
1.1.9. Example. The pre-terms in Example 1.1.2 can be written as follows,
respectively:
(i) v
0
v
1
v
2
;
(ii) v
0
:v
0
v
1
;
(iii) (v
0
:v
0
) v
1
;
(iv) (v
0
:v
0
v
0
) v
1
:v
1
v
1
.
1.1.10. Remark. The conventions mentioned above are used in the remain-
der of these notes. However, we refrain from using them|wholly or partly|
when we nd this more convenient. For instance, we might prefer to write
(v
0
:v
0
v
0
) (v
1
:v
1
v
1
) for the last term in the above example.
1.1.11. Definition. ForM 2 
?
dene the set FV(M)  V of free variables
of M as follows.
FV(x) = fxg;
FV(x:P ) = FV(P )nfxg;
FV(P Q) = FV(P ) [ FV(Q):
If FV(M) = fg then M is called closed.
1.1.12. Example. Let x; y; z denote distinct variables. Then
(i) FV(x y z) = fx; y; zg;
(ii) FV(x:x y) = fyg;
(iii) FV((x:x x) y:y y) = fg.
1.1.13. Definition. For M;N 2 
?
and x 2 V , the substitution of N for x
in M , written M [x := N ] 2 
?
, is dened as follows, where x 6= y:
x[x := N ] =N ;
y[x := N ] = y;
(P Q)[x := N ] = P [x := N ] Q[x := N ];
(x:P )[x := N ] = x:P ;
(y:P )[x := N ] = y:P [x := N ]; if y 62 FV(N) or x 62 FV(P );
(y:P )[x := N ] = z:P [y := z][x := N ]; if y 2 FV(N) and x 2 FV(P ).
4 Chapter 1. Type-free -calculus
where z is chosen as the v
i
2 V with minimal i such that v
i
62 FV(P )[FV(N)
in the last clause.
1.1.14. Example. If x; y; z are distinct variables, then for a certain vari-
able u:
((x:x yz) (y:x y z) (z:x y z))[x := y] = (x:x yz) (u:y u z) (z:y y z)
1.1.15. Definition. Let -equivalence, written =

, be the smallest relation
on 
?
, such that
P =

P for all P ;
x:P =

y:P [x := y] if y 62 FV(P ),
and closed under the rules:
P =

P
0
) 8x 2 V : x:P =

x:P
0
;
P =

P
0
) 8Z 2 
?
: P Z =

P
0
Z;
P =

P
0
) 8Z 2 
?
: Z P =

Z P
0
;
P =

P
0
) P
0
=

P ;
P =

P
0
& P
0
=

P
00
) P =

P
00
:
1.1.16. Example. Let x; y; z denote dierent variables. Then
(i) x:x =

y:y;
(ii) x:x z =

y:y z;
(iii) x:y:x y =

y:x:y x;
(iv) x:x y 6=

x:x z.
1.1.17. Definition. Dene for any M 2 
?
, the equivalence class [M ]

by:
[M ]

= fN 2 
?
jM =

Ng
Then dene the set  of -terms by:
 = 
?
==

= f[M ]

jM 2 
?
g
1.1.18. Warning. The notion of a pre-term and the associated explicit dis-
tinction between pre-terms and -terms introduced above are not standard
in the literature. Rather, it is customary to call our pre-terms -terms, and
then informally remark that -equivalent -terms are \identied."
In the remainder of these notes we shall be almost exclusively concerned
with -terms, not pre-terms. Therefore, it is convenient to introduce the
following.
1.1. -terms 5
1.1.19. Notation. We write M instead of [M ]

in the remainder. This
leads to ambiguity: is M a pre-term or a -term? In the remainder of these
notes, M should always be construed as [M ]

2 , except when explicitly
stated otherwise.
We end this section with two denitions introducing the notions of free
variables and substitution on -terms (recall that, so far, these notions have
been introduced only for pre-terms). These two denitions provide the rst
example of how to rigorously understand denitions involving -terms.
1.1.20. Definition. For M 2  dene the set FV(M)  V of free variables
of M as follows.
FV(x) = fxg;
FV(x:P ) = FV(P )nfxg;
FV(P Q) = FV(P ) [ FV(Q):
If FV(M) = fg then M is called closed.
1.1.21. Remark. According to Notation 1.1.19, what we really mean by this
is that we dene FV as the map from  to subsets of V satisfying the rules:
FV([x]

) = fxg;
FV([x:P ]

) = FV([P ]

)nfxg;
FV([P Q]

) = FV([P ]

) [ FV([Q]

):
Strictly speaking we then have to demonstrate there there is at most one such
function (uniqueness) and that there is at least one such function (existence).
Uniqueness can be established by showing for any two functions FV
1
and
FV
2
satisfying the above equations, and any -term, that the results of FV
1
and FV
2
on the -term are the same. The proof proceeds by induction on
the number of symbols in any member of the equivalence class.
To demonstrate existence, consider the map that, given an equivalence
class, picks a member, and takes the free variables of that. Since any choice
of member yields the same set of variables, this latter map is well-dened,
and can easily be seen to satisfy the above rules.
In the rest of these notes such considerations will be left implicit.
1.1.22. Definition. For M;N 2  and x 2 V , the substitution of N for x
in M , written Mfx := Ng, is dened as follows:
x[x := N ] = N ;
y[x := N ] = y; if x 6=y;
(P Q)[x := N ] = P [x := N ] Q[x := N ];
(y:P )[x := N ] = y:P [x := N ]; if x 6=y, where y 62 FV(N).
1.1.23. Example.
(i) (x:x y)[x := z:z] = x:x y;
(ii) (x:x y)[y := z:z] = x:x z:z.
6 Chapter 1. Type-free -calculus
1.2. Reduction
Next we introduce reduction on -terms.
1.2.1. Definition. Let !

be the smallest relation on  such that
(x:P ) Q!

P [x := Q];
and closed under the rules:
P !

P
0
) 8x 2 V : x:P !

x:P
0
P !

P
0
) 8Z 2  : P Z !

P
0
Z
P !

P
0
) 8Z 2  : Z P !

Z P
0
A term of form (x:P ) Q is called a -redex, and P [x := Q] is called its
-contractum. A term M is a -normal form if there is no term N with
M !

N .
There are other notions of reduction than -reduction, but these will not
be considered in the present chapter. Therefore, we sometimes omit \-"
from the notions -redex, -reduction, etc.
1.2.2. Definition.
(i) The relation!

(multi-step -reduction) is the transitive-reexive clo-
sure of !

; that is, !

is the smallest relation closed under the rules:
P !

P
0
) P !

P
0
;
P !

P
0
& P
0
!

P
00
) P !

P
00
;
P !

P:
(ii) The relation =

(-equality) is the transitive-reexive-symmetric clo-
sure of !

; that is, =

is the smallest relation closed under the rules:
P !

P
0
) P =

P
0
;
P =

P
0
& P
0
=

P
00
) P =

P
00
;
P =

P ;
P =

P
0
) P
0
=

P:
1.2.3. Warning. In these notes, the symbol = without any qualication is
used to express the fact that two objects, e.g., pre-terms or -terms are
identical. This symbol is very often used in the literature for -equality.
1.2.4. Example.
(i) (x:x x) z:z !

(x x)[x := z:z] = (z:z) y:y;
(ii) (z:z) y:y !

z[z := y:y] = y:y;
(iii) (x:x x) z:z !

y:y;
(iv) (x:x) y z =

y ((x:x) z).
1.3. Informal interpretation 7
1.3. Informal interpretation
Informally, -terms express functions and applications of functions in a pure
form. For instance, the -term
I = x:x
intuitively denotes the function that maps any argument to itself, i.e., the
identity function. This is similar to the notation n 7! n employed in math-
ematics. However, x:x is a string over an alphabet with symbols , x, etc.
(or rather an equivalence class of such objects), whereas n 7! n is a function,
i.e., a certain set of pairs. The dierence is the same as that between a pro-
gram written in some language and the mathematical function it computes,
e.g., addition.
As in the notation n 7! n, the name of the abstracted variable x in x:x
is not signicant, and this is why we identify x:x with, e.g., y:y.
Another -term is
K

= y:x:x
which, intuitively, denotes the function that maps any argument to a func-
tion, namely the one that maps any argument to itself, i.e., the identity
function. This is similar to programming languages where a function may
return a function as a result. A related -term is
K = y:x:y
which, intuitively, denotes the function that maps any argument to the
function that, for any argument, returns the former argument.
Since -terms intuitively denote functions, there is a way to invoke one
-term on another; this is expressed by application. Thus, the -term
I K
expresses application of I to K. Since K intuitively denotes a function too,
I denotes a function which may have another function as argument. This is
similar to programming languages where a procedure may receive another
procedure as argument.
In mathematics we usually write application of a function, say f(n) = n
2
,
to an argument, say 4, with the argument in parentheses: f(4). In the
-calculus we would rather write this as (f 4), or just f 4, keeping Nota-
tion 1.1.5 in mind. Not all parentheses can be omitted, though; for instance,
(x:x) I x:x I
are not the same -term; the rst is I applied to I, whereas the second
expects an argument x which is applied to I.
8 Chapter 1. Type-free -calculus
Intuitively, if x:M denotes a function, and N denotes an argument,
then the the value of the function on the argument is denoted by the -term
that arises by substituting N for x in M . This latter -term is exactly the
term
M [x := N ]
This is similar to common practice in mathematics; if f is as above, then
f(4) = 4
2
, and we get from the application f(4) to the value 4
2
by substi-
tuting 4 for n in the body of the denition of f .
The process of calculating values is formalized by -reduction. Indeed,
M !

N if N arises from M by replacing a -redex, i.e., a part of form
(x:P ) Q
by its -contractum.
P [x := Q]
For instance,
I K = (x:x) K!

x[x := K] = K
Then the relation!

formalizes the process of computing the overall result.
Also, =

identies -terms that, intuitively, denote the same function.
Note that -calculus is a type-free formalism. Unlike common mathe-
matical practice, we do not insist that -terms denote functions from cer-
tain domains, e.g., the natural numbers, and that arguments be drawn from
these domains. In particular, we may have self-application as in the -term
! = x:x x
and we may apply this -term to itself as in the -term

 = ! !
The type-free nature of -calculus leads to some interesting phenomena;
for instance, a -term may reduce to itself as in

 = (x:x x) ! !

! ! = 

Therefore, there are also -terms with innite reduction sequences, like

!


!

: : :
1.4. The Church-Rosser Theorem
Since a -term M may contain several -redexes, i.e., several parts of form
(x:P ) Q, there may be several N such that M !

N . For instance,
K (I I)!

x:(I I)
1.4. The Church-Rosser Theorem 9
and also
K (I I)!

K I
However, the Church-Rosser theorem, proved below, states that if
M !

M
1
and
M !

M
2
then a single -term M
3
can be found with
M
1
!

M
3
and
M
2
!

M
3
In particular, if M
1
and M
2
are -normal forms, i.e., -terms that admit
no further -reductions, then they must be the same -term, since the -
reductions from M
1
and M
2
to M
3
must be in zero steps. This is similar to
the fact that when we calculate the value of an arithmetical expression, e.g.,
(4 + 2)  (3 + 7)  11
the end result is independent of the order in which we do the calculations.
1.4.1. Definition. A relation > on  satises the diamond property if, for
allM
1
;M
2
;M
3
2 , ifM
1
> M
2
andM
1
> M
3
, then there exists an M
4
2 
such that M
2
> M
4
and M
3
> M
4
.
1.4.2. Lemma. Let > be a relation on  and suppose that its transitive clo-
sure
1
is !

. If > satises the diamond property, then so does !

.
Proof. First show by induction on n that M
1
> N
1
and M
1
> : : : > M
n
implies that there are N
2
; : : : ; N
n
such that N
1
> N
2
> : : : > N
n
and
M
n
> N
n
.
Using this property, show by induction on m that if N
1
> : : : > N
m
and
N
1
>

M
1
then there are M
2
; : : : ;M
m
such that M
1
> M
2
> : : : > M
m
and
N
m
>

M
m
.
1
Let R be a relation on . The transitive closure of R is the least relation R

satisfying:
PRP
0
) PR

P
0
PR

P
0
& P
0
R

P
00
) PR

P
00
The reexive closure of R is the least relation R
=
satisfying:
PRP
0
) PR
=
P
0
PR
=
P
10 Chapter 1. Type-free -calculus
Now assume M
1
!

M
2
and M
1
!

M
3
. Since !

is the transitive
closure of > we have M
1
> : : : > M
2
and M
1
> : : : > M
3
. By what was
shown above, we can ndM
4
such that M
2
> : : : > M
4
andM
3
> : : : > M
4
.
Since!

is the transitive closure of >, alsoM
2
!

M
4
andM
3
!

M
4
. ut
1.4.3. Definition. Let !
l
be the relation on  dened by:
P !
l
P
P !
l
P
0
) x:P !
l
x:P
0
P !
l
P
0
& Q!
l
Q
0
) P Q!
l
P
0
Q
0
P !
l
P
0
& Q!
l
Q
0
) (x:P ) Q!
l
P
0
[x := Q
0
]
1.4.4. Lemma. M !
l
M
0
& N !
l
N
0
) M [x := N ]!
l
M
0
[x := N
0
].
Proof. By induction on the denition of M !
l
M
0
. In case M
0
is M ,
proceed by induction on M . ut
1.4.5. Lemma. !
l
satises the diamond property, i.e., for allM
1
;M
2
;M
3
2 ,
if M
1
!
l
M
2
and M
1
!
l
M
3
, then there exists an M
4
2  such that
M
2
!
l
M
4
and M
3
!
l
M
4
.
Proof. By induction on the denition of M
1
!
l
M
2
, using the above
lemma. ut
1.4.6. Lemma. !

is the transitive closure of !
l
.
Proof. Clearly
2
(!

)
=
!
l
!

Then
!

= ((!

)
=
)

!

l
 (!

)

=!

In particular, !

l
=!

. ut
1.4.7. Theorem (Church and Rosser, 1936). For every M
1
;M
2
;M
3
2 , if
M
1
!

M
2
and M
1
!

M
3
, then there exists an M
4
2  such that M
2
!

M
4
and M
3
!

M
4
.
Proof (Tait & Martin-Lof). By the above three lemmas. ut
1.4.8. Corollary. For all M;N 2 , if M =

N , then there exists an
L 2  such that M !

L and N !

L.
1.4.9. Corollary. For all M;N
1
; N
2
2 , if M !

N
1
and M !

N
2
and
both N
1
and N
2
are in -normal form, then N
1
= N
2
.
2
Recall the relations R

and R
=
dened earlier.
1.5. Expressibility and undecidability 11
1.4.10. Corollary. For all M;N 2 , if there are -normal forms L
1
and
L
2
such that M !

L
1
, N !

L
2
, and L
1
6= L
2
, then M 6=

N .
1.4.11. Example. x:x 6=

x:y:x.
1.4.12. Remark. One can consider the lambda calculus as an equational
theory, i.e., a formal theory with formulas of the form M =

N . The
preceding example establishes consistency of this theory, in the following
sense: there exists a formula P which cannot be proved.
This may seem to be a very weak property, compared to \one cannot
prove a contradiction" (where a suitable notion of \contradiction" in ordi-
nary logic is e.g., P ^ :P ). But note that in most formal theories, where a
notion of contradiction can be expressed, its provability implies provability
of all formulas. Thus, consistency can be equally well dened as \one cannot
prove everything".
1.5. Expressibility and undecidability
Although we have given an informal explanation of the meaning of -terms
it remains to explain in what sense -reduction more precisely can express
computation. In this section we show that -calculus can be seen as an
alternative formulation of recursion theory.
The following gives a way of representing numbers as -terms.
1.5.1. Definition.
(i) For any n 2 N and F;A 2  dene F
n
(A) (n-times iterated application
of F to A) by:
F
0
(A) = A
F
n+1
(A) = F (F
n
(A))
(ii) For any n 2 N, the Church numeral c
n
is the -term
c
n
= s:z:s
n
(z)
1.5.2. Example.
(i) c
0
= s:z:z;
(ii) c
1
= s:z:s z;
(iii) c
2
= s:z:s (s z);
(iv) c
3
= s:z:s (s (s z)).
1.5.3. Remark. c
n
is the number n represented inside the -calculus.
The following shows how to do arithmetic on Church numerals.
12 Chapter 1. Type-free -calculus
1.5.4. Proposition (Rosser). Let
A
+
= x:y:s:z:x s (y s z);
A

= x:y:s:x (y s);
A
e
= x:y:y x:
Then
A
+
c
n
c
m
= c
n+m
;
A

c
n
c
m
= c
nm
;
A
e
c
n
c
m
= c
n
m
if m > 0:
Proof. For any n 2 N,
c
n
s z = (f:x:f
n
(x)) s z
=

(x:s
n
(x)) z
=

s
n
(z)
Thus
A
+
c
n
c
m
= (x:y:s:z:x s (y s z)) c
n
c
m
=

s:z:c
n
s (c
m
s z)
=

s:z:c
n
s (s
m
(z))
=

s:z:s
n
(s
m
(z))
= s:z:s
n+m
(z)
= c
n+m
The similar properties for multiplication and exponentiation are left as ex-
ercises. ut
1.5.5. Remark. Recall that M =

N when, intuitively, M and N denote
the same object. For instance I I =

I since both terms, intuitively, denote
the identity function.
Now consider the two terms
A
s
= x:s:z:s (x s z)
A
0
s
= x:s:z:x s (s z)
It is easy to calculate that
A
s
c
n
=

c
n+1
A
0
s
c
n
=

c
n+1
So both terms denote, informally, the successor function on Church numer-
als, but the two terms are not -equal (why not?)
The following shows how to dene booleans and conditionals inside -
calculus.
1.5. Expressibility and undecidability 13
1.5.6. Proposition. Dene
true = x:y:x;
false = x:y:y;
if B then P else Q = B P Q:
Then
if true then P else Q =

P ;
if false then P else Q =

Q:
Proof. We have:
if true then P else Q = (x:y:x) P Q
=

(y:P ) Q
=

P:
The proof that if false then P else Q =

Q is similar. ut
We can also dene pairs in -calculus.
1.5.7. Proposition. Dene
[P;Q] = x:x P Q;

1
= x:y:x;

2
= x:y:y:
Then
[P;Q] 
1
=

P ;
[P;Q] 
2
=

Q:
Proof. We have:
[P;Q] 
1
= (x:x P Q) x:y:x
=

(x:y:x) P Q
=

(y:P ) Q
=

P:
The proof that [P;Q] 
2
=

Q is similar. ut
1.5.8. Remark. Note that we do not have [M 
1
;M 
2
] =

M for all
M 2 ; that is, our pairing operator is not surjective.
1.5.9. Remark. The construction is easily generalized to tuples [M
1
; : : : ;M
n
]
with projections 
i
where i 2 f1; : : : ; ng.
The following gives one way of expressing recursion in -calculus.
14 Chapter 1. Type-free -calculus
1.5.10. Theorem (Fixed point theorem). For all F there is an X such that
F X =

X
In fact, there is a -term Y such that, for all F :
F (Y F ) =

Y F
Proof. Put
Y = f:(x:f (x x)) x:f (x x)
Then
Y F = (f:(x:f (x x)) x:f (x x)) F
=

(x:F (x x)) x:F (x x)
=

F ((x:F (x x)) x:F (x x))
=

F ((f:(x:f (x x)) x:f (x x)) F )
= F (Y F )
as required. ut
1.5.11. Corollary. Given M 2  there is F 2  such that:
F =

M [f := F ]
Proof. Put
F = Y f:M
Then
F = Y f:M
=

(f:M) (Y f:M)
= (f:M) F
=

M [f := F ]
as required. ut
Corollary 1.5.11 allows us to write recursive denitions of -terms; that
is, we may dene F as a -term satisfying a xed point equation F =

x:M
where the term F occurs somewhere inside M . However, there may be
several terms F satisfying this equation (will these be -equal?).
1.5.12. Example. Let C be some -term which expresses a condition, i.e.,
let C c
n
=

true or C c
n
=

false, for all n 2 N. Let S dene the successor
function (see Remark 1.5.5). Suppose we want to compute in -calculus, for
any number, the smallest number greater than the given one that satises
the condition. This is expressed by the -term F :
H = f:x:if (C x) then x else f (S x)
F = Y H
1.5. Expressibility and undecidability 15
Indeed, for example
F c
4
= (Y H) c
4
=

H (Y H) c
4
= (f:x:if (C x) then x else f (S x)) (Y H) c
4
=

if (C c
4
) then c
4
else (Y H) (S c
4
)
= if (C c
4
) then c
4
else F (S c
4
)
So far we have been informal as to how -terms \express" certain func-
tions. This notion is made precise as follows.
1.5.13. Definition.
(i) A numeric function is a map
f : N
m
! N:
(ii) A numeric function f : N
m
! N is -denable if there is an F 2  such
that
F c
n
1
: : : c
n
m
=

c
f(n
1
;::: ;n
m
)
for all n
1
; : : : ; n
m
2 N.
1.5.14. Remark. By the Church-Rosser property, (ii) implies that, in fact,
F c
n
1
: : : c
n
m
!

c
f(n
1
;::: ;n
m
)
There are similar notions for partial functions|see [7].
We shall show that all recursive functions are -denable.
1.5.15. Definition. The class of recursive functions is the smallest class of
numeric functions containing the initial functions
(i) projections: U
m
i
(n
1
; : : : ; n
m
) = n
i
for all 1  i  m;
(ii) successor: S
+
(n) = n+ 1;
(iii) zero: Z(n) = 0.
and closed under composition, primitive recursion, and minimization:
(i) composition: if g : N
k
! N and h
1
; : : : ; h
k
: N
m
! N are recursive,
then so is f : N
m
! N dened by
f(n
1
; : : : ; n
m
) = g(h
1
(n
1
; : : : ; n
m
); : : : ; h
k
(n
1
; : : : ; n
m
)):
(ii) primitive recursion: if g : N
m
! N and h : N
m+2
! N are recursive,
then so is f : N
m+1
! N dened by
f(0; n
1
; : : : ; n
m
) = g(n
1
; : : : ; n
m
);
f(n+ 1; n
1
; : : : ; n
m
) = h(f(n; n
1
; : : : ; n
m
); n; n
1
; : : : ; n
m
):
16 Chapter 1. Type-free -calculus
(iii) minimization: if g : N
m+1
! N is recursive and for all n
1
; : : : ; n
m
there
is an n such that g(n; n
1
; : : : ; n
m
) = 0, then f : N
m
! N dened as
follows is also recursive
3
f(n
1
; : : : ; n
m
) = n:g(n; n
1
; : : : ; n
m
) = 0
1.5.16. Lemma. The initial functions are -denable.
Proof. With
U
m
i
= x
1
: : : : x
m
:x
i
S
+
= x:s:z:s (x s z)
Z = x:c
0
the necessary properties hold. ut
1.5.17. Lemma. The -denable functions are closed under composition.
Proof. If g : N
k
! N is -denable by G 2  and h
1
; : : : ; h
k
: N
m
! N
are -denable by some H
1
; : : : ;H
k
2 , then f : N
m
! N dened by
f(n
1
; : : : ; n
m
) = g(h
1
(n
1
; : : : ; n
m
); : : : ; h
k
(n
1
; : : : ; n
m
))
is -denable by
F = x
1
: : : : x
m
:G (H
1
x
1
: : : x
m
) : : : (H
k
x
1
: : : x
m
);
as is easy to verify. ut
1.5.18. Lemma. The -denable functions are closed under primitive recur-
sion.
Proof. If g : N
m
! N is -denable by some G 2  and h : N
m+2
! N is
-denable by some H 2 , then f : N
m+1
! N dened by
f(0; n
1
; : : : ; n
m
) = g(n
1
; : : : ; n
m
);
f(n+ 1; n
1
; : : : ; n
m
) = h(f(n; n
1
; : : : ; n
m
); n; n
1
; : : : ; n
m
);
is -denable by F 2  where
F = x:x
1
: : : : x
m
:x T [c
0
; G x
1
: : : x
n
] 
2
;
T = p:[S
+
(p 
1
);H (p 
2
) (p 
1
) x
1
: : : x
m
]:
Indeed, we have
F c
n
c
n
1
: : : c
n
m
=

c
n
T [c
0
; G c
n
1
: : : c
n
m
] 
2
=

T
n
([c
0
; G c
n
1
: : : c
n
m
]) 
2
3
n:g(n; n
1
; : : : ; n
m
) = 0 denotes the smallest number n satisfying the equation
g(n; n
1
; : : : ; n
m
) = 0.
1.5. Expressibility and undecidability 17
Also,
T [c
n
; c
f(n;n
1
;::: ;n
m
)
] =

[S
+
(c
n
);H c
f(n;n
1
;::: ;n
m
)
c
n
c
n
1
: : : c
n
m
]
=

[c
n+1
; c
h(f(n;n
1
;::: ;n
m
);n;n
1
;::: ;n
m
)
]
=

[c
n+1
; c
f(n+1;n
1
;::: ;n
m
)
]
So
T
n
([c
0
; G c
n
1
: : : c
n
m
]) =

[c
n
; c
f(n;n
1
;::: ;n
m
)
]
From this the required property follows. ut
1.5.19. Lemma. The -denable functions are closed under minimization.
Proof. If g : N
m+1
! N is -denable by G 2  and for all n
1
; : : : ; n
m
there is an n, such that g(n; n
1
; : : : ; n
m
) = 0, then f : N
m
! N dened by
f(n
1
; : : : ; n
m
) = m:g(n; n
1
; : : : ; n
m
) = 0
is -denable by F 2 , where
F = x
1
: : : : x
m
:H c
0
and where H 2  is such that
H =

y:if (zero? (G x
1
: : : x
m
y)) then y else H (S
+
y):
Here,
zero? = x:x (y:false) true
We leave it as an exercise to verify that the required properties hold. ut
The following can be seen as a form of completeness of the -calculus.
1.5.20. Theorem (Kleene). All recursive functions are -denable.
Proof. By the above lemmas. ut
The converse also holds, as one can show by a routine argument. Similar
results hold for partial functions as well|see [7].
1.5.21. Definition. Let h; i : N
2
! N be a bijective, recursive function.
The map # : 
?
! N is dened by:
#(v
i
) = h0; ii
#(x:M) = h2; h#(x);#(M)ii
#(M N) = h3; h#(M);#(N)ii
For M 2 , we take #(M) to be the least possible number #(M
0
) whereM
0
is an alpha-representative of M . Also, for M 2 , we dene dMe = c
#(M)
.
18 Chapter 1. Type-free -calculus
1.5.22. Definition. Let A  .
(i) A is closed under =

if
M 2 A & M =

N ) N 2 A
(ii) A is non-trival if
A 6= ; & A 6= 
(iii) A is recursive if
#A = f#(M) jM 2 Ag
is recursive.
1.5.23. Theorem (Curry, Scott). Let A be non-trivial and closed under =

.
Then A is not recursive.
Proof (J. Terlouw). Suppose A is recursive. Dene
B = fM jM dMe 2 Ag
There exists an F 2  with
M 2 B , F dMe =

c
0
;
M 62 B , F dMe =

c
1
:
Let M
0
2 A, M
1
2 nA, and let
G = x:if (zero? (F x)) then M
1
else M
0
Then
M 2 B , G dMe =

M
1
M 62 B , G dMe =

M
0
so
G 2 B , G dGe =

M
1
) G dGe 62 A ) G 62 B
G 62 B , G dGe =

M
0
) G dGe 2 A ) G 2 B
a contradiction. ut
1.5.24. Remark. The above theorem is analogous to Rice's theorem known
in recursion theory.
The following is a variant of the halting problem. Informally it states that
the formal theory of -equality mentioned in Remark 1.4.12 is undecidable.
1.5.25. Corollary (Church). fM 2  jM =

trueg is not recursive.
1.5.26. Corollary. The following set is not recursive:
fM 2  j 9N 2  :M !

N & N is a -normal form g:
One can also infer from these results the well-known theorem due to
Church stating that rst-order predicate calculus is undecidable.
1.6. Historical remarks 19
1.6. Historical remarks
For more on the history of -calculus, see e.g., [55] or [7]. First hand in-
formation may be obtained from Rosser and Kleene's eye witness state-
ments [94, 62], and from Curry and Feys' book [24] which contains a wealth
of historical information. Curry and Church's original aims have recently
become the subject of renewed attention|see, e.g., [9, 10] and [50].
1.7. Exercises
1.7.1. Exercise. Show, step by step, how application of the conventions in
Notation 1.1.5 allows us to express the pre-terms in Example 1.1.2 as done
in Example 1.1.9.
1.7.2. Exercise. Which of the following abbreviations are correct?
1. x:x y = (x:x) y;
2. x:x y = x:(x y);
3. x:y:z:x y z = (x:y:z:x) (y z);
4. x:y:z:x y z = ((x:y:z:x) y) z;
5. x:y:z:x y z = x:y:z:((x y) z).
1.7.3. Exercise. Which of the following identications are correct?
1. x:y:x = y:x:y;
2. (x:x) z = (z:z) x.
1.7.4. Exercise. Do the following terms have normal forms?
1. I, where x:x;
2. 
, i.e., ! !, where ! = x:x x;
3. K I 
 where K = x:y:x;
4. (x:K I (x x)) y:K I (y y);
5. (x:z (x x)) y:z (y y).
1.7.5. Exercise. A reduction path from a -term M is a nite or innite
sequence
M !

M
1
!

M
2
!

: : :
20 Chapter 1. Type-free -calculus
A term that has a normal form is also called weakly normalizing (or just
normalizing), since at least one of its reduction paths terminate in a nor-
mal form. A term is strongly normalizing if all its reduction paths even-
tually terminate in normal forms, i.e., if the term has no innite reduction
paths. Which of the ve terms in the preceding exercise are weakly/strongly
normalizing? In which cases do dierent reduction paths lead to dierent
normal forms?
1.7.6. Exercise. Which of the following are true?
1. (x:y:z:(x z) (y z)) u:u =

(v:v y:z:u:u) x:x;
2. (x:y:x z:z) a:a =

(y:y) b:z:z;
3. x:
 =


.
1.7.7. Exercise. Prove (without using the Church-Rosser Theorem) that
for all M
1
;M
2
;M
3
2 , if M
1
!

M
2
and M
1
!

M
3
, then there exists an
M
4
2  such that M
2
!

M
4
and M
3
!

M
4
.
Can you extend your proof technique to yield a proof of the Church-
Rosser theorem?
1.7.8. Exercise. Fill in the details of the proof Lemma 1.4.4.
1.7.9. Exercise. Fill in the details of the proof Lemma 1.4.5.
1.7.10. Exercise. Which of the following are true?
1. (I I) (I I)!
l
I I;
2. (I I) (I I)!
l
I;
3. I I I I!
l
I I I;
4. I I I I!
l
I;
1.7.11. Exercise. Show that the fourth clause in Denition 1.4.3 cannot be
replaced by
(x:P ) Q!
l
P [x := Q]:
That is, show that, if this is done, then !
l
does not satisfy the diamond
property.
1.7.12. Exercise. Prove Corollary 1.4.8{1.4.10.
1.7.13. Exercise. Write -terms (without using the notation s
n
(z)) whose
-normal forms are the Church numerals c
5
and c
100
.
1.7. Exercises 21
1.7.14. Exercise. Prove that A

and A
e
satisfy the equations stated in
Proposition 1.5.4.
1.7.15. Exercise. For each n 2 N, write a -term B
n
such that
B
n
c
i
Q
1
: : : Q
n
=

Q
i
;
for all Q
1
; : : : Q
n
2 .
1.7.16. Exercise. For each n 2 N, write -terms P
n
; 
1
; : : : ; 
n
, such that
for all Q
1
; : : : ; Q
n
2 :
(P
n
Q
1
: : : Q
n
) 
i
=

Q
i
:
1.7.17. Exercise (Klop, taken from [7]). Let x
1
x
2
: : : x
n
:M be an abbre-
viation for x
1
:x
2
: : : : x
n
:M . Let
? = abcdefghijklmnopqstuvwxyzr:r (thisisafixedpointcombinator);
$ = ??????????????????????????:
Show that $ is a xed point combinator, i.e., that $ F =

F ($ F ), holds for
all F 2 .
1.7.18. Exercise. Dene a -term neg such that
neg true =

false;
neg false =

true:
1.7.19. Exercise. Dene -terms O and E such that, for all n 2 N:
Oc
m
=


true if m is odd;
false otherwise,
and
Ec
m
=


true if m is even;
false otherwise.
1.7.20. Exercise. Dene a -term P such that
P c
n+1
=

c
n
Hint: use the same trick as in the proof that the -denable functions are
closed under primitive recursion. (Kleene got this idea during a visit at his
dentist.)
22 Chapter 1. Type-free -calculus
1.7.21. Exercise. Dene a -term eq? such that, for all n;m 2 N:
eq? c
n
c
m
=


true if m = n;
false otherwise.
Hint: use the xed point theorem to construct a -term H such that
H c
n
c
m
=

if (zero? c
n
)
then (if (zero? c
m
) then true else false)
else (if (zero? c
m
) then false else (H (P c
n
) (P c
m
)))
where P is as in the preceding exercise.
Can you prove the result using instead the construction in Lemma 1.5.18?
1.7.22. Exercise. Dene a -term H such that for all n 2 N:
H c
2n
=

c
n
1.7.23. Exercise. Dene a -term F such that for all n 2 N:
H c
n
2
=

c
n
1.7.24. Exercise. Prove Corollary 1.5.25.
CHAPTER 2
Intuitionistic logic
The classical understanding of logic is based on the notion of truth. The
truth of a statement is \absolute" and independent of any reasoning, un-
derstanding, or action. Statements are either true or false with no regard
to any \observer". Here \false" means the same as \not true", and this is
expressed by the tertium non datur principle that \p _ :p" must hold no
matter what the meaning of p is.
Needless to say, the information contained in the claim p _ :p is quite
limited. Take the following sentence as an example:
There is seven 7's in a row somewhere in the decimal represen-
tation of the number .
Note that it may very well happen that nobody ever will be able to determine
the truth of the above sentence. Yet we are forced to accept that one of the
cases must necessarily hold. Another well-known example is as follows:
There are two irrational numbers x and y, such that x
y
is ratio-
nal.
The proof of this fact is very simple: if
p
2
p
2
is a rational number then we
can take x = y =
p
2; otherwise take x =
p
2
p
2
and y =
p
2.
The problem with this proof is that we do not know which of the two
possibilities is the right one. Again, there is very little information in this
proof, because it is not constructive.
These examples demonstrate some of the drawbacks of classical logic,
and give hints on why intuitionistic (or constructive) logic is of interest.
Although the roots of constructivism in mathematics reach deeply into the
XIXth Century, the principles of intuitionistic logic are usually attributed
to the works of the Dutch mathematician and philosopher Luitzen Egber-
tus Jan Brouwer from the beginning of XXth Century. Brouwer is also the
inventor of the term \intuitionism", which was originally meant to denote a
23
24 Chapter 2. Intuitionistic logic
philosophical approach to the foundations of mathematics, being in opposi-
tion to Hilbert's \formalism".
Intuitionistic logic as a branch of formal logic was developed later around
the year 1930. The names to be quoted here are Heyting, Glivenko, Kol-
mogorov and Gentzen. To learn more about the history and motivations
see [26] and Chapter 1 of [107].
2.1. Intuitive semantics
In order to understand intuitionism, one should forget the classical, Platonic
notion of \truth". Now our judgements about statements are no longer based
on any predened value of that statement, but on the existence of a proof
or \construction" of that statement.
The following rules explain the informal constructive semantics of propo-
sitional connectives. These rules are sometimes called the BHK-interpretation
for Brouwer, Heyting and Kolmogorov. The algorithmic avor of this de-
nition will later lead us to the Curry-Howard isomorphism.
 A construction of '
1
^ '
2
consists of a construction of '
1
and a con-
struction of '
2
;
 A construction of '
1
_ '
2
consists of a number i 2 f1; 2g and a con-
struction of of '
i
;
 A construction of '
1
! '
2
is a method (function) transforming every
construction of '
1
into a construction of '
2
;
 There is no possible construction of ? (where ? denotes falsity).
Negation :' is best understood as an abbreviation of an implication '! ?.
That is, we assert :' when the assumption of ' leads to an absurd. It follows
that
 A construction of :' is a method that turns every construction of '
into a non-existent object.
Note that the equivalence between :' and ' ! ? holds also in classical
logic. But note also that the intuitionistic statement :' is much stronger
than just \there is no construction for '".
2.1.1. Example. Consider the following formulas:
1. ? ! p;
2. ((p! q)! p)! p;
3. p! ::p;
2.2. Natural deduction 25
4. ::p! p;
5. :::p! :p;
6. (:q ! :p)! (p! q);
7. (p! q)! (:q ! :p);
8. :(p ^ q)! (:p _ :q);
9. (:p _ :q)! :(p ^ q);
10. ((p$ q)$ r)$ (p$ (q $ r));
11. ((p ^ q)! r)$ (p! (q ! r));
12. (p! q)$ (:p _ q);
13. ::(p _ :p).
These formulas are all classical tautologies. Some of them can be easily
given a BHK-interpretation, but some of them cannot. For instance, a con-
struction for formula 3, which should be written as \p! ((p! ?)! ?)",
is as follows:
Given a proof of p, here is a proof of (p! ?)! ?: Take a proof
of p ! ?. It is a method to translate proofs of p into proofs
of ?. Since we have a proof of p, we can use this method to
obtain a proof of ?.
On the other hand, formula 4 does not seem to have such a construction.
(The classical symmetry between formula 3 and 4 disappears!)
2.2. Natural deduction
The language of intuitionistic propositional logic is the same as the language
of classical propositional logic. We assume an innite set PV of propositional
variables and we dene the set  of formulas by induction, represented by
the following grammar:
 ::= ? j PV j (! ) j ( _ ) j ( ^ ):
That is, our basic connectives are: implication !, disjunction _, conjunc-
tion ^, and the constant ? (false).
2.2.1. Convention. The connectives : and $ are abbreviations. That is,
 :' abbreviates '! ?;
26 Chapter 2. Intuitionistic logic
 '$  abbreviates ('!  ) ^ ( ! ').
2.2.2. Convention.
1. We sometimes use the convention that implication is right associative,
i.e., we write e.g. '!  ! # instead of '! ( ! #).
2. We assume that negation has the highest, and implication the lowest
priority, with no preference between _ and ^. That is, :p ^ q ! r
means ((:p) ^ q)! r.
3. And of course we forget about outermost parentheses.
In order to formalize the intuitionistic propositional calculus, we dene a
proof system, called natural deduction, which is motivated by the informal
semantics of 2.1.
2.2.3. Warning. What follows is a quite simplied presentation of natural
deduction, which is often convenient for technical reasons, but which is not
always adequate. To describe the relationship between various proofs in
ner detail, we shall consider a variant of the system in Chapter 4.
2.2.4. Definition.
(i) A context is a nite subset of . We use ?;, etc. to range over
contexts.
(ii) The relation ? ` ' is dened by the rules in Figure 2.1. We also write
`
N
for `.
(iii) We write ?; instead of ? [ , and ?; ' instead of ?; f'g. We also
write ` ' instead of fg ` '.
(iv) A formal proof of ? ` ' is a nite tree, whose nodes are labelled by
pairs of form (?
0
; '
0
), which will also be written ?
0
` '
0
, satisfying the
following conditions:
 The root label is ? ` ';
 All the leaves are labelled by axioms;
 The label of each father node is obtained from the labels of the
sons using one of the rules.
(v) For innite ? we dene ? ` ' to mean that ?
0
` ', for some nite
subset ?
0
of ?.
(vi) If ` ' then we say that ' is a theorem of the intuitionistic propositional
calculus.
2.2. Natural deduction 27
?; ' ` ' (Ax)
? ` ' ? `  
? ` ' ^  
(^I)
? ` ' ^  
? ` '
(^E)
? ` ' ^  
? `  
? ` '
? ` ' _  
(_I)
? `  
? ` ' _  
?; ' `  ?;  `  ? ` ' _  
? ` 
(_E)
?; ' `  
? ` '!  
(! I)
? ` '!  ? ` '
? `  
(! E)
? ` ?
? ` '
(?E)
Figure 2.1: Intuitionistic propositional calculus
The proof system consists of an axiom scheme, and rules. For each logical
connective (except ?) we have one or two introduction rules and one or two
elimination rules. An introduction rule for a connective  tells us how a
conclusion of the form '   can be derived. An elimination rule describes
the way in which '   can be used to derive other formulas. The intuitive
meaning of ? ` ' is that ' is a consequence of the assumptions in ?.
We give example proofs of our three favourite formulas:
2.2.5. Example. Let ? abbreviate f'! ( ! #); '!  ;'g.
(i)
' ` '
` '! '
(! I)
(ii)
'; ` '
' `  ! '
(! I)
` '! ( ! ')
(! I)
(iii)
(! E)
? ` '! ( ! #) ? ` '
? `  ! #
? ` '!  ? ` '
? `  
(! E)
? ` #
'! ( ! #); '!  ` '! #
(! I)
'! ( ! #) ` ('!  )! ('! #)
(! I)
` ('! ( ! #))! ('!  )! ('! #)
(! I)
(! E)
28 Chapter 2. Intuitionistic logic
2.2.6. Remark. Note the distinction between the relation `, and a formal
proof of ? ` '.
The following properties will be useful.
2.2.7. Lemma. Intuitionistic propositional logic is closed under weakening
and substitution, that is, ? ` ' implies ?;  ` ' and ?[p :=  ] ` '[p :=  ],
where [p :=  ] denotes a substitution of  for all occurrences of a proposi-
tional variable p.
Proof. Easy induction with respect to the size of proofs. ut
2.3. Algebraic semantics of classical logic
To understand better the algebraic semantics for intuitionistic logic let us
begin with classical logic. Usually, semantics of classical propositional for-
mulas is dened in terms of the two truth values, 0 and 1 as follows.
2.3.1. Definition. Let B = f0; 1g.
(i) A valuation in B is a map v : PV ! B ; such a map will also be called
a 0-1 valuation.
(ii) Given a 0-1 valuation v, dene the map [[]]
v
: ! B by:
[[p]]
v
= v(p); for p 2 PV ;
[[?]]
v
= 0;
[[' _  ]]
v
= maxf[[']]
v
; [[ ]]
v
g;
[[' ^  ]]
v
= minf[[']]
v
; [[ ]]
v
g;
[['!  ]]
v
= maxf1? [[']]
v
; [[ ]]
v
g:
We also write v(') for [[']]
v
.
(iii) A formula ' 2  is a tautology if v(') = 1 for all valuations in B .
Let us consider an alternative semantics, based on the analogy between
classical connectives and set-theoretic operations.
2.3.2. Definition. A eld of sets (over X) is a nonempty family R of sub-
sets of X, closed under unions, intersections and complement (to X).
It follows immediately that fg;X 2 R, for each eld of sets R over X.
Examples of elds of sets are:
(i) P (X);
(ii) ffg;Xg;
(iii) fA  X : A nite or ?A niteg (?A is the complement of A).
2.3. Algebraic semantics of classical logic 29
2.3.3. Definition. Let R be a eld of sets over X.
(i) A valuation in R is a map v : PV !R.
(ii) Given a valuation v in R, dene the map [[]]
v
: ! X by:
[[p]]
v
= v(p) for p 2 PV
[[?]]
v
= fg
[[' _  ]]
v
= [[']]
v
[ [[ ]]
v
[[' ^  ]]
v
= [[']]
v
\ [[ ]]
v
[['!  ]]
v
= (X ? [[']]
v
) [ [[ ]]
v
We also write v(') for [[']]
v
.
2.3.4. Proposition. The above two approaches to semantics are equivalent,
i.e., the following conditions are equivalent for each eld of subsets R over
a nonempty set X:
1. ' is a tautology;
2. v(') = X, for all valuations v in R.
Proof. (1) ) (2): Suppose that v(') 6= X. There is an element a 2 X
such that a 62 v('). Dene a 0-1 valuation w so that w(p) = 1 i a 2 v(p).
Prove by induction that for all formulas  
w( ) = 1 i a 2 v( ):
Then w(') 6= 1.
(2)) (1): A 0-1 valuation can be seen as a valuation in R that assigns only
X and fg to propositional variables. ut
2.3.5. Definition. A Boolean algebra is an algebraic system of the form
B = hB;[;\;?; 0; 1i, where:
 [;\ are associative and commutative;
 (a [ b) \ c = (a \ c) [ (b \ c) and (a \ b) [ c = (a [ c) \ (b [ c);
 a [ 0 = a and a \ 1 = a;
 ?a [ a = 1 and ?a \ a = 0.
The relation  dened by a  b i a [ b = b is a partial order
1
in every
Boolean algebra, and the operations \;[ are the glb and lub operations
w.r.t. this order.
1
A transitive, reexive and anti-symmetric relation.
30 Chapter 2. Intuitionistic logic
The notion of a Boolean algebra is a straightforward generalization of
the notion of a eld of sets. Another example of a Boolean algebra is the
algebra of truth values hB ;max;min;?; 0; 1i, where ?x is 1? x.
We can generalize the above set semantics to arbitrary Boolean algebras
by replacing valuations in a eld of sets by valuations in a Boolean algebra
in the obvious way. But in fact, every Boolean algebra is isomorphic to a
eld of sets, so this generalization does not change our semantics.
2.4. Heyting algebras
We will now develop a semantics for intuitionistic propositional logic.
Let  be the set of all propositional formulas, let ?   (in particular ?
may be empty) and let  be the following equivalence relation:
'   i ? ` '!  and ? `  ! ':
Let L
 
= =

= f[']

: ' 2 g, and dene a partial order  over L
 
by:
[']

 [ ]

i ? ` '!  :
That  is an equivalence relation and that  is a well-dened partial order
is a consequence of the following formulas being provable:
 '! ';
 ('!  )! (( ! #)! ('! #));
In addition, we can dene the following operations over L
 
:
[]

[ []

= [ _ ]

;
[]

\ []

= [ ^ ]

;
?[]

= [:]

:
These operations are well-dened, because the following formulas are prov-
able:
 ('! '
0
)! (:'
0
! :');
 ('! '
0
)! (( !  
0
)! ((' _  )! ('
0
_  
0
)));
 ('! '
0
)! (( !  
0
)! ((' ^  )! ('
0
^  
0
))).
We can go on and show that operations \ and [ are the glb and lub opera-
tions w.r.t. the relation , and that the distributivity laws
(a [ b) \ c = (a \ c) [ (b \ c) and (a \ b) [ c = (a [ c) \ (b [ c)
2.4. Heyting algebras 31
are satised.
2
The class [?]

is the least element 0 of L
 
, because ? ! '
is provable, and [>]

, where > = ? ! ?, is the top element 1. We have
[>]

= f' : ? ` 'g. However, there are (not unexpected) diculties with
the complement operation: We have ?a \ a = [?]

but not necessarily
?a [ a = [>]

.
The best we can assert about ?a is that it is the greatest element such
that ?a \ a = 0, and we can call it a pseudo-complement . Since negation
is a special kind of implication, the above calls for a generalization. An
element c is called a relative pseudo-complement of a with respect to b, i c
is the greatest element such that a\c  b. The relative pseudo-complement,
if it exists, is denoted a) b.
It is not dicult to nd out that in our algebra L
 
, often called a Lin-
denbaum algebra, we have [']

) [ ]

= ['!  ]

.
We have just discovered a new type of algebra, called Heyting algebra or
pseudo-Boolean algebra.
2.4.1. Definition. A Heyting algebra is an algebraic system of the form
H = hH;[;\;);?; 0; 1i, that satises the following conditions:
 [;\ are associative and commutative;
 (a [ b) \ c = (a \ c) [ (b \ c) and (a \ b) [ c = (a [ c) \ (b [ c);
 a [ 0 = a and a \ 1 = a;
 a [ a = a;
 a\ c  b is equivalent to c  a) b (where a  b stands for a[ b = b);
 ?a = a) 0.
The above conditions amount to as much as saying that H is a distributive
lattice with zero and relative pseudo-complement dened for each pair of
elements. In particular, each Boolean algebra is a Heyting algebra with
a) b dened as ?a[ b. The most prominent example of a Heyting algebra
which is not a Boolean algebra is the algebra of open sets of a topological
space, for instance the algebra of open subsets of the Euclidean plane R
2
.
2.4.2. Definition.
 The symbol %(a; b) denotes the distance between points a; b 2 R
2
;
 A subset A of R
2
is open i for every a 2 A there is an r > 0 with
fb 2 R
2
: %(a; b) < rg  A;
 If A is a subset of R
2
then Int(A) denotes the interior of A, i.e., the
union of all open subsets of A.
2
That is, L
 
is a distributive lattice.
32 Chapter 2. Intuitionistic logic
2.4.3. Proposition. Let H = hO(R
2
);[;\;);; 0; 1i, where
 O(R
2
) is the family of all open subsets of R
2
;
 the operations \, [ are set-theoretic;
 A) B := Int(?A [B), for arbitrary open sets A and B;
 0 = fg and 1 = R
2
.
  A = Int(?A), where ? is the set-theoretic complement.
Then H is a Heyting algebra.
Proof. Exercise 2.7.6. ut
In fact, every Heyting algebra is isomorphic to a subalgebra of the algebra
of open sets of a topological space. A comprehensive study of the algebraic
semantics for intuitionistic (and classical) logic is the book of Rasiowa and
Sikorski [88]. See also Chapter 13 of [108].
The semantics of intuitionistic propositional formulas is now dened as
follows.
2.4.4. Definition. Let H = hH;[;\;);?; 0; 1i be a Heyting algebra.
(i) A valuation v in a H is a map v : PV ! H.
(ii) Given a valuation v in H, dene the map [[]]
v
: ! H by:
[[p]]
v
= v(p) for p 2 PV
[[?]]
v
= 0
[[' _  ]]
v
= [[']]
v
[ [[ ]]
v
[[' ^  ]]
v
= [[']]
v
\ [[ ]]
v
[['!  ]]
v
= [[']]
v
) [[ ]]
v
As usual, we write v(') for [[']]
v
.
2.4.5. Notation. Let H = hH;[;\;);?; 0; 1i be a Heyting algebra. We
write:
 H; v j= ', whenever v(') = 1;
 H j= ', whenever H; v j= ', for all v;
 H; v j= ?, whenever H; v j= ', for all ' 2 ?;
 H j= ?, whenever H; v j= ?, for all v;
 j= ', whenever H; v j= ', for all H; v;
 ? j= ', whenever H; v j= ? implies H; v j= ', for all H and v.
2.4. Heyting algebras 33
We say that a formula ' such that j= ' is intuitionistically valid or is an
intuitionistic tautology. It follows from the following completeness theorem
that the notions of a theorem and a tautology coincide for intuitionistic
propositional calculus.
2.4.6. Theorem (Soundness and Completeness). The following conditions
are equivalent
1. ? ` ';
2. ? j= '.
Proof. (1)) (2): Verify that all provable formulas are valid in all Heyting
algebras (induction w.r.t. proofs).
(2) ) (1): This follows from our construction of the Lindenbaum algebra.
Indeed, suppose that ? j= ', but ? 6` '. Then ' 6 >, i.e., [']

6= 1 in L
 
.
Dene a valuation v by v(p) = [p]

in L
 
and prove by induction that
v( ) = [ ]

, for all formulas  . It follows that v(') 6= 1, a contradiction.
ut
2.4.7. Example. To see that Peirce's law ((p ! q) ! p) ! p is not intu-
itionistically valid, consider the algebra of open subsets of R
2
. Take v(p) to
be the whole space without one point, and v(q) = fg. (Note that a) b = 1
in a Heyting algebra i a  b.)
Intuitionistic logic is not nite-valued: There is no single nite Heyting
algebra H such that ` ' is equivalent to H j= '. Indeed, consider the
formula
W
fp
i
$ p
j
: i; j = 0; : : : ; n and i 6= jg. (Here the symbol
W
abbreviates the disjunction of all members of the set.) This formula is not
valid in general (Exercise 2.7.10), although it is valid in all Heyting algebras
of cardinality at most n.
But nite Heyting algebras are sucient for the semantics, as well as
one suciently \rich" innite algebra.
2.4.8. Theorem.
1. A formula ' of length n is valid i it is valid in all Heyting algebras
of cardinality at most 2
2
n
;
2. Let H be the algebra of all open subsets of a dense-in-itself
3
metric
space V (for instance the algebra of all open subsets of R
2
). Then
H j= ' i ' is valid.
3
Every point x is a limit of a sequence fx
n
g
n
, where x
n
6= x, for all n.
34 Chapter 2. Intuitionistic logic
We give only a sketch of the main ideas of the proof, for the most curious
reader. See [88] for details.
For (1), suppose H; v 6j= ', and let '
1
; : : : '
m
be all subformulas of '.
We construct a small model H
0
as a distributive sublattice of H, with 0
and 1, generated by the elements v('
1
); : : : ; v('
m
). This lattice is a Heyting
algebra (warning: this is not a Heyting subalgebra of H), and H
0
; v
0
6j= ',
for a suitable v
0
.
As for (2), every nite algebra can be embedded into the algebra of open
subsets of some open subset of V , and this algebra is a homomorphic image
of H. Thus, every valuation in a nite algebra can be translated into a
valuation in H.
From part (1) of the above theorem, it follows that intuitionistic propo-
sitional logic is decidable. But the upper bound obtained this way (double
exponential space) can be improved down to polynomial space, with help of
other methods, see [103].
2.5. Kripke semantics
We now introduce another semantics of intuitionistic propositional logic.
2.5.1. Definition. A Kripke model is dened as a tuple of the form C =
hC;;  i, where C is a non-empty set,  is a partial order in C and  is a
binary relation between elements of C (called states or possible worlds) and
propositional variables, that satises the following monotonicity condition:
If c  c
0
and c  p then c
0
 p:
The intuition is that elements of the model represent states of knowledge.
The relation  represents extending states by gaining more knowledge, and
the relation  tells which atomic formulas are known to be true in a given
state. We extend this relation to provide meaning for propositional formulas
as follows.
2.5.2. Definition. If C = hC;;  i is a Kripke model, then
 c  ' _  i c  ' or c   ;
 c  ' ^  i c  ' and c   ;
 c  '!  i c
0
  , for all c
0
such that c  c
0
and c
0
 ';
 c  ? never happens.
We use C  ' to mean that c  ', for all c 2 C.
Note that the above denition implies the following rule for negation:
2.5. Kripke semantics 35
 c  :' i c
0
1 ', for all c
0
 c.
and the following generalized monotonicity (proof by easy induction):
If c  c
0
and c  ' then c
0
 ':
We now want to show completeness of Kripke semantics. For this, we trans-
form every Heyting algebra into a Kripke model.
2.5.3. Definition. A lter in a Heyting algebra H = hH;[;\;);?; 0; 1i is
a nonempty subset F of H, such that
 a; b 2 F implies a \ b 2 F ;
 a 2 F and a  b implies b 2 F .
A lter F is proper i F 6= H. A proper lter F is prime i a [ b 2 F
implies that either a or b belongs to F .
2.5.4. Lemma. Let F be a proper lter in H and let a 62 F . There exists a
prime lter G such that F  G and a 62 G.
We only give a hint for the proof that can be found e.g., in [88]. Consider
the family of all lters G containing F and such that a 62 G, ordered by
inclusion. Apply Kuratowski-Zorn Lemma to show that this family has a
maximal element. This is a prime lter (Exercise 2.7.12) although it is not
necessarily a maximal proper lter.
2.5.5. Lemma. Let v be a valuation in a Heyting algebra H. There is a
Kripke model C = hC;;  i, such that H; v j= ' i C  ', for all formu-
las '.
Proof. We take C to be the set of all prime lters in H. The relation 
is inclusion, and we dene F  p i v(p) 2 F . By induction, we prove that,
for all formulas  ,
F   i v( ) 2 F: (2.1)
The only nontrivial case of this induction is when  =  
0
!  
00
. Assume
F   
0
!  
00
, and suppose that v( 
0
!  
00
) = v( 
0
) ) v( 
00
) 62 F . Take
the least lter G
0
containing F [ fv( 
0
)g. Then
G
0
= fb : b  f \ v( 
0
) for some f 2 Fg;
and we have v( 
00
) 62 G
0
, in particular G
0
is proper. Indeed, otherwise
v( 
00
)  f \ v( 
0
), for some f 2 F , and thus f  v( 
0
) ) v( 
00
) 2 F |
a contradiction.
36 Chapter 2. Intuitionistic logic
We extend G
0
to a prime lter G, not containing v( 
00
). By the induction
hypothesis, G   
0
. Since F   
0
!  
00
, it follows that G   
00
. That is,
v( 
00
) 2 G | a contradiction.
For the converse, assume that v( 
0
!  
00
) 2 F  G   
0
. From the
induction hypothesis we have v( 
0
) 2 G and since F  G we obtain v( 
0
))
v( 
00
) 2 G. Thus v( 
00
)  v( 
0
) \ (v( 
0
) ) v( 
00
)) 2 G, and from the
induction hypothesis we conclude G   
00
as desired.
The other cases are easy. Note that primality is essential for disjunction.
Having shown (2.1), assume that C  ' and H; v 6j= '. Then v(') 6= 1
and there exist a proper lter not containing v('). This lter extends to a
prime lter G such that v(') 62 G and thus G 1 '. On the other hand, if
H; v j= ', then v(') = 1 and 1 belongs to all lters in H. ut
2.5.6. Theorem. The sequent ? ` ' is provable i for all Kripke models C,
the condition C  ? implies C  '.
Proof. The left-to-right part is shown by induction (Exercise 2.7.13). For
the other direction assume ? 6` '. Then H; v j= ? but H; v 6j= ', for some
H; v. From the previous lemma we have a Kripke model C with C  ? and
C 1 '. ut
Here is a nice application of Kripke semantics.
2.5.7. Proposition. If ` ' _  then either ` ' or `  .
Proof. Assume 6` ' and 6`  . There are Kripke models C
1
= hC
1
;
1
; 
1
i
and C
2
= hC
2
;
2
; 
2
i and states c
1
2 C
1
and c
2
2 C
2
, such that c
1
1 '
and c
2
1  . Without loss of generality we can assume that c
1
and c
2
are least elements of C
1
and C
2
, respectively, and that C
1
\ C
2
= fg. Let
C = hC
1
[ C
2
[ fc
0
g;;  i, where c
0
62 C
1
[ C
2
, the order is the union of

1
and 
2
extended by c
0
taken as the least element, and  is the union
of 
1
and 
2
. That is,
c
0
1 p;
for all variables p. It is easy to see that this is a Kripke model. In addition
we have C; c
1
 # i C
1
; c
1
 #, for all formulas #, and a similar property
holds for c
2
.
Now suppose that ` '_ . By soundness, we have c
0
 '_ , and thus
either c
0
 ' or c
0
  , by denition of  . Then either c
1
 ' or c
2
  ,
because of monotonicity. ut
2.6. The implicational fragment
The most important logical conjective is the implication. Thus, it is mean-
ingful to study the fragment of propositional calculus with only one connec-
tive: the implication. This is the true minimal logic. The natural deduction
2.7. Exercises 37
system for the implicational fragment consists of the rules (! E), (! I) and
the axiom scheme.
2.6.1. Theorem. The implicational fragment of intuitionistic propositional
calculus is complete with respect to Kripke models, i.e., ? ` ' is provable i
for all Kripke models C, the condition C  ? implies C  '.
Proof. The implication from left to right follows from soundness of the full
natural deduction system, of which our minimal logic is a fragment. For the
proof in the other direction, let us assume that ? 6` '. We dene a Kripke
model C = hC;;  i, where
C = f : ?  ; and  is closed under `g:
That is,  2 C means that  `  implies  2 .
The relation  is inclusion and  is 2, that is,   p holds i p 2 ,
for all propositional variables p. By induction we show the following claim:
   i  2 ;
for all implicational formulas  and all states . The case of a variable is
immediate from the denition. Let  be  
1
!  
2
and let    . Take 
0
=
f# : ;  
1
` #g. Then  
1
2 
0
and, by the induction hypothesis, 
0
  
1
.
Thus 
0
  
2
and we get  
2
2 
0
, again by the induction hypothesis. Thus,
;  
1
`  
2
, and by (! I) we get what we want.
Now assume  2  (that is  `  ) and take 
0
  with 
0
  
1
.
Then  
1
2 
0
, i.e., 
0
`  
1
. But also 
0
`  
1
!  
2
, because   
0
. By
(! E) we can derive 
0
`  
2
, which means, by the induction hypothesis,
that 
0
  
2
. ut
The completeness theorem has a very important consequence: the con-
servativity of the full intuitionistic propositional calculus over its implica-
tional fragment.
2.6.2. Theorem. Let ' be an implicational formula, and let ? be a set of
implicational formulas. If ? ` ' can be derived in the intuitionistic proposi-
tional calculus then it can be derived in the implicational fragment.
Proof. Easy. But note that we use only one half from the two completeness
theorems 2.5.6 and 2.6.1: we need only soundness of the full logic and only
the other direction for the fragment. ut
2.7. Exercises
2.7.1. Exercise. Find constructions for formulas (1), (3), (5), (7), (9), (11)
and (13) of Example 2.1.1, and do not nd constructions for the other for-
mulas.
38 Chapter 2. Intuitionistic logic
2.7.2. Exercise. Prove Lemma 2.2.7.
2.7.3. Exercise. Give natural deduction proofs for the formulas of Exer-
cise 2.7.1.
2.7.4. Exercise. Show that the relation  dened in a Boolean algebra by
the condition a  b i a [ b = b is a partial order and that
 a \ b  a;
 the condition a  b is equivalent to a \ b = a;
 the operations [ and \ are respectively the upper and lower bound
wrt. ;
 the constants 0 and 1 are respectively the bottom and top element.
2.7.5. Exercise. Show that the relation  dened in a Heyting algebra by
the condition a  b i a [ b = b is a partial order and that
 ?a \ a = 0;
 (a [ b) \ a = a and a \ b  a;
 the condition a  b is equivalent to a \ b = a, and to a) b = 1;
 the operations [ and \ are respectively the upper and lower bound
wrt. ;
 the constants 0 and 1 are respectively the bottom and top element.
2.7.6. Exercise. Prove Proposition 2.4.3.
2.7.7. Exercise. Fill in the details of the proof that the Lindenbaum alge-
bra L
 
of 2.4 is indeed a Heyting algebra.
2.7.8. Exercise. Complete the proof of the completeness theorem 2.4.6.
2.7.9. Exercise. Show that the formulas (2), (4), (6), (8) and (10) are not
intuitionistically valid. (Use open subsets of R
2
or construct Kripke models.)
2.7.10. Exercise. Show that the formula
W
fp
i
$ p
j
: i; j = 0; : : : ; n and
i 6= jg is not intuitionistically valid.
2.7.11. Exercise. A lter is maximal i it is a maximal proper lter. Show
that each maximal lter is prime. Show also that in a Boolean algebra every
prime lter is maximal.
2.7.12. Exercise. Complete the proof of Lemma 2.5.4.
2.7. Exercises 39
2.7.13. Exercise. Complete the proof of Theorem 2.5.6, part ). (Hint:
choose a proper induction hypothesis.)
2.7.14. Exercise. Can the proof of Theorem 2.6.1 be generalized to the full
propositional calculus?
2.7.15. Exercise. A state c in a Kripke model C determines p i either
c  p or c  :p. Dene a 0-1 valuation v
c
by v
c
(p) = 1 i c  p. Show that
if c determines all propositional variables in ' then v
c
(') = 1 implies c  '.
2.7.16. Exercise. Let ' be a classical tautology such that all propositional
variables in ' are among p
1
; : : : ; p
n
. Show that the formula (p
1
_ :p
1
) !
   ! (p
n
_ :p
n
)! ' is intuitionistically valid.
2.7.17. Exercise. Prove the Glivenko theorem: A formula ' is a classical
tautology i ::' is an intuitionistic tautology.
2.7.18. Warning. The Glivenko theorem does not extend to rst-order logic.
40 Chapter 2. Intuitionistic logic
CHAPTER 3
Simply typed -calculus
Recall from the rst chapter that a -term, unlike the functions usually
considered in mathematics, does not have a xed domain and range. Thus,
whereas we would consider the function n 7! n
2
as a function from natural
numbers to natural numbers (or from integers to natural numbers, etc.)
there is no corresponding requirement in -calculus. Or, to be more precise,
there is no corresponding requirement in type-free -calculus.
Curry [23] and Church [18] also introduced versions of their systems with
types. These systems form the topic of the present chapter.
3.1. Simply typed -calculus a la Curry
We begin with the simply typed -calculus a la Curry.
3.1.1. Definition.
(i) Let U denote a denumerably innite alphabet whose members will be
called type variables. The set  of simple types is the set of strings
dened by the grammar:
 ::= U j (! )
We use ; ; : : : to denote arbitrary type variables, and ; ; : : : to de-
note arbitrary types. We omit outermost parentheses, and omit other
parentheses with the convention that ! associates to the right.
(ii) The set C of contexts is the set of all sets of pairs of the form
fx
1
: 
1
; : : : ; x
n
: 
n
g
with 
1
; : : : ; 
n
2, x
1
; : : : ; x
n
2V (variables of ) and x
i
6= x
j
for i 6=j.
41
42 Chapter 3. Simply typed -calculus
(iii) The domain of a context ? = fx
1
: 
1
; : : : ; x
n
: 
n
g is dened by:
dom(?) = fx
1
; : : : ; x
n
g
We write x :  for fx : g and ?;?
0
for ?[?
0
if dom(?)\dom(?
0
) = fg.
(iv) The range of a context ? = fx
1
: 
1
; : : : ; x
n
: 
n
g is dened by:
j?j = f 2  j (x : ) 2 ?; for some xg:
(v) The typability relation ` on C   is dened by:
?; x :  ` x : 
?; x :  ` M : 
? ` x:M :  ! 
? ` M :  !  ? ` N : 
? ` M N : 
where we require that x 62 dom(?) in the rst and second rule.
(vi) The simply typed -calculus ! is the triple (;;`). To distinguish
between this system and variants, the present one will also be called
simply typed -calculus a la Curry or just ! a la Curry.
3.1.2. Example. Let ; ;  be arbitrary types. Then:
(i) ` x:x :  ! ;
(ii) ` x:y:x :  !  ! ;
(iii) ` x:y:z:x z (y z) : ( !  ! )! ( ! )!  ! .
3.1.3. Definition. If ? ` M :  then we say that M has type  in ?. We
say that M 2  is typable if there are ? and  such that ? ` M : .
The set of typable terms is a subset|in fact, a proper subset|of the set
of all -terms. In this subset, restrictions are made regarding which -terms
may be applied to other -terms.
Very informally, the type variables denote some unspecied sets, and
 !  denotes the set of functions from  to  . Saying that M has type
 !  in ? then intuitively means that this set of functions contains the
particular function thatM informally denotes. For instance, ` x:x :  ! 
informally states that the identity function is a function from a certain set
to itself.
A context is an assumption that some elements x
1
; : : : ; x
n
have certain
types 
1
; : : : ; 
n
, respectively. Moreover, if x has type  and M has type 
then x:M has type  !  . This reects the intuition that if M denotes
an element of  for each x in , then x:M denotes a function from  to  .
In a similar vein, if M has type  !  and N has type , then M N has
type  .
3.1. Simply typed -calculus a la Curry 43
3.1.4. Warning. The idea that types denote sets should not be taken too
literally. For instance, if A and B are sets then the set of functions from
A to A is disjoint from the set of functions from B to B. In contrast, if 
and  are dierent simple types, then a single term may have both types,
at least in the version of simply typed -calculus presented above.
Just like -calculus provides a foundation of higher-order functional pro-
gramming languages like LISP and Scheme, various typed -calculi provide
a foundation of programming languages with types like Pascal, ML, and
Haskell. Typed -calculi are also of independent interest in proof theory as
we shall have frequent occasion to see in these notes.
We conclude this section with a brief review of some of the most funda-
mental properties of !. The survey follows [8].
The following shows that only types of free variables of a term matter
in the choice contexts.
3.1.5. Lemma (Free variables lemma). Assume that ? ` M : . Then:
(i) ?  ?
0
implies ?
0
` M : ;
(ii) FV(M)  dom(?);
(iii) ?
0
` M :  where dom(?
0
) = FV(M) and ?
0
 ?.
Proof. (i) by induction on the derivation of ? ` M : . As in [8] we
present the proof in some detail and omit such details in the remainder.
1. The derivation is
; x :  ` x : 
where ? = ; x : , x 62 dom() and M = x. Since ?  ?
0
and ?
0
is a context, ?
0
= 
0
; x :  for some 
0
with x 62 dom(
0
). Hence

0
; x :  ` x : , as required.
2. The derivation ends in
?; x : 
1
` P : 
2
? ` x:P : 
1
! 
2
where x 62 dom(?),  = 
1
! 
2
, and M = x:P . Without loss of
generality we can assume that x 62 dom(?
0
). Then ?; x : 
1
 ?
0
; x : 
1
so by the induction hypothesis ?
0
; x : 
1
` P : 
2
. Then we also have
? ` x:P : 
1
! 
2
, as required.
3. The derivation ends in
? ` P :  !  ? ` Q : 
? ` P Q : 
where M = P Q. By the induction hypothesis (twice) ?
0
` P :  ! 
and ?
0
` Q :  , and then ?
0
` P Q : , as required.
44 Chapter 3. Simply typed -calculus
(ii)-(iii) by induction on the derivation of ? ` M : . ut
The following shows how the type of some term must have been obtained
depending on the form of the term.
3.1.6. Lemma (Generation lemma).
(i) ? ` x :  implies x :  2 ?;
(ii) ? ` M N :  implies that there is a  such that ? ` M :  !  and
? ` N :  .
(iii) ? ` x:M :  implies that there are  and  such that ?; x :  ` M : 
and  =  ! .
Proof. By induction on the length of the derivation. ut
3.1.7. Definition. The substitution of type  for type variable  in type ,
written [ :=  ], is dened by:
[ :=  ] = 
[ :=  ] =  if  6= 
(
1
! 
2
)[ :=  ] = 
1
[ :=  ]! 
2
[ :=  ]
The notation ?[ :=  ] stands for the context f(x : [ :=  ]) j (x : ) 2 ?g.
The following shows that the type variables range over all types; this is a
limited form of polymorphism [90]; we will hear much more about polymor-
phism later. The proposition also shows, similarly, that free term variables
range over arbitrary terms.
3.1.8. Proposition (Substitution lemma).
(i) If ? ` M : , then ?[ :=  ] ` M : [ :=  ].
(ii) If ?; x :  ` M :  and ? ` N :  then ? ` M [x := N ] : .
Proof. By induction on the derivation of ? ` M :  and generation of
?; x :  ` M : , respectively. ut
The following shows that reduction preserves typing.
3.1.9. Proposition (Subject reduction). If ? ` M :  and M !

N , then
? ` N : .
Proof. By induction on the derivation of M !

N using the substitution
lemma and the generation lemma. ut
3.2. Simply typed -calculus a la Church 45
3.1.10. Remark. The similar property
? ` N :  & M !

N ) ? ` M : 
is called subject expansion and does not hold in !, see Exercise 3.6.2.
3.1.11. Corollary. If ? ` M :  and M !

N , then ? ` N : .
3.1.12. Theorem (Church-Rosser property for typable terms). Suppose that
? ` M : . If M !

N and M !

N
0
, then there exists an L such that
N !

L and N
0
!

L and ? ` L : .
Proof. By the Church-Rosser property for -terms and the subject reduc-
tion property. ut
3.2. Simply typed -calculus a la Church
As mentioned earlier, simply typed -calculus was introduced by Curry [23]
and Church [18]. More precisely, Curry considered types for combinatory
logic, but his formulation was later adapted to -calculus [24].
There were several other important dierences between the systems in-
troduced by Church and Curry.
In Curry's system the terms are those of type-free -calculus and the
typing relation selects among these the typable terms. For instance, x:x is
typable, whereas x:x x is not.
In Church's original system, the typing rules were built into the term
formation rules, as follows. Let V

denote a denumerable set of variables for
each  2 . Then dene the set 

of simply typed terms of type  by the
clauses:
x 2 V

) x 2 

M 2 
!
& N 2 

) M N 2 

M 2 

& x 2 

) x

:M 2 
!
The set of all simply typed terms is then taken as the union over all simple
types  of the simply typed terms of type .
Instead of assuming that the set of variables is partitioned into disjoint
sets indexed by the set of simple types, we can use contexts to decide the
types of variables as in the system a la Curry. Also, as in the system a
la Curry, we can select the typable terms among a larger set. This yields
the following, more common, formulation of simply typed -calculus a la
Church.
46 Chapter 3. Simply typed -calculus
3.2.1. Definition.
(i) The set 

of pseudo-terms is dened by the following grammar:


::= V j (x:  

) j (



)
where V is the set of (-term) variables and  is the set of simple
types.
1
We adopt the same terminology, notation, and conventions for
pseudo-terms as for -terms, see 1.3{1.10, mutatis mutandis.
(ii) The typability relation  on C  

 is dened by:
2
?; x :  `

x : 
?; x :  `

M : 
? `

x::M :  ! 
? `

M :  !  ? `

N : 
? `

M N : 
where we require that x 62 dom(?) in the rst and second rule.
(iii) The simply typed -calculus a la Church (! a la Church, for short)
is the triple (

;;).
(iv) If ? `

M :  then we say thatM has type  in ?. We say thatM 2 

is typable if there are ? and  such that ? `

M : .
3.2.2. Example. Let ; ;  be arbitrary simple types. Then:
(i) `

x::x :  ! ;
(ii) `

x::y::x :  !  ! ;
(iii) `

x:!!:y:!:z::(x z) y z : (!!)!(!)!!.
Even with the formulation of ! a la Church in Denition 3.2.1 an
important dierence with ! a la Curry remains: in Church's system ab-
stractions have domains, i.e. are of the form x: :M , whereas in Curry's
system abstractions have no domain, i.e. are of the form x:M . Thus, in
Church's system one writes
x::x :  ! ;
whereas in Curry's system one writes
x:x :  ! :
1
Strictly speaking, we should proceed as in the case of -terms and dene a notion of
pre-pseudo-terms, then dene substitution and -equivalence on these, and nally adopt
the convention that by M 2 

we always mean the -equivalence class, see 1.13{1.19.
We omit the details.
2
In this chapter it is useful to distinguish syntactically between typing in the system a
la Church and the system a la Curry, and therefore we use `

here. In later chapters we
shall also use ` for `

.
3.2. Simply typed -calculus a la Church 47
The two dierent systems|Curry's and Church's|represent two dier-
ent paradigms in programming languages. In Church's system the program-
mer has to explicitly write the types for all variables used in the program
as in, e.g., Pascal, whereas in Curry's approach the programmer merely
writes functions, and it is then the job of the compiler or the programming
environment to infer the types of variables, as e.g., in ML and Haskell.
Having introduced a new set of terms (pseudo-terms instead of -terms)
we are obliged to introduce the notions of substitution, reduction, etc., for
the new notion. This is carried out briey below. We reuse much notation
and terminology.
3.2.3. Definition. ForM 2 

dene the set FV(M) of free variables ofM
as follows.
FV(x) = fxg
FV(x::P ) = FV(P )nfxg
FV(P Q) = FV(P ) [ FV(Q)
If FV(M) = fg then M is called closed.
3.2.4. Definition. For M;N 2 

and x 2 V , the substitution of N for x
in M , written M [x := N ], is dened as follows:
x[x := N ] = N
y[x := N ] = y if x 6=y
(P Q)[x := N ] = P [x := N ] Q[x := N ]
(y::P )[x := N ] = y::P [x := N ] where x 6=y and y 62 FV(N)
3.2.5. Definition. Let !

be the smallest relation on 

closed under the
rules:
(x : : P ) Q!

P [x := Q]
P !

P
0
) 8x 2 V;  2  : x::P !

x::P
0
P !

P
0
) 8Z 2  : P Z !

P
0
Z
P !

P
0
) 8Z 2  : Z P !

Z P
0
A term of form (x :  : P ) Q is called a -redex, and P [x := Q] is called
its -contractum. A term M is a -normal form if there is no term N with
M !

N .
3.2.6. Definition.
(i) The relation!

(multi-step -reduction) is the transitive-reexive clo-
sure of !

;
(ii) The relation =

(-equality) is the transitive-reexive-symmetric clo-
sure of !

.
48 Chapter 3. Simply typed -calculus
We end the section by briey repeating the development in the preceding
subsection for simply typed -calculus a la Church.
3.2.7. Lemma (Free variables lemma). Let ? `

M : . Then:
(i) ?  ?
0
implies ?
0
`

M : ;
(ii) FV(M)  dom(?);
(iii) ?
0
`

M :  where dom(?
0
) = FV(M) and ?
0
 ?.
Proof. See the Exercises. ut
3.2.8. Lemma (Generation lemma).
(i) ? `

x :  implies x :  2 ?;
(ii) ? `

M N :  implies that there is a  such that ? `

M :  !  and
? `

N :  .
(iii) ? `

x: :M :  implies that there is a  such that ?; x :  `

M : 
and  =  ! .
Proof. See the Exercises. ut
3.2.9. Proposition (Substitution lemma).
(i) If ? `

M : , then ?[ :=  ] `

M : [ :=  ].
(ii) If ?; x :  `

M :  and ? `

N :  then ? `

M [x := N ] : .
Proof. See the Exercises. ut
3.2.10. Proposition (Subject reduction). If ? `

M :  and M !

N ,
then ? `

N : .
Proof. See the Exercises. ut
3.2.11. Theorem (Church-Rosser property). Suppose that ? `

M : . If
M !

N and M !

N
0
, then there exists an L such that N !

L and
N
0
!

L and ? `

L : .
Proof. One way to obtain this result is to repeat for 

an argument
similar to that we used for untyped terms, and then use the subject reduction
property. Another method, based on so called logical relations can be found
in [74]. ut
The following two properties of simply typed -calculus a la Church do
not hold for the Curry system. Note that (ii) implies the subject expansion
property|see Remark 3.1.10.
3.3. Church versus Curry typing 49
3.2.12. Proposition (Uniqueness of types).
(i) If ? `

M :  and ? `

M :  then  =  .
(ii) If ? `

M :  and ? `

N :  and M =

N , then  =  .
Proof.
(i) By induction on M .
(ii) IfM =

N then by the Church-Rosser property,M !

L andN !

L,
for some L. By subject reduction, ? `

L :  and ? `

L :  . Now
use (i). ut
It is easy to see that these properties fail in ! a la Curry. For instance,
` x:x : !  and ` x:x : (! )! (! ) by the derivations:
x :  ` x : 
` x:x : ! 
and
x : ! ` x : !
` x:x : (!)! (!)
Although these two derivations have the same structure, their conclusions
are dierent due to dierent type assumptions for x. In contrast, if the
Church term M has type  in ?, then there is exactly one derivation of this
fact, which is uniquely encoded by M .
This dierence leads to some interesting problems for the Curry system.
Given a term M which types can be assigned to M , if any? Is there a single
best type in some sense? Such problems are studied in type inference, which
we return to later.
Because of the above dierence, ! a la Curry and other similar systems
are often called type assignment systems, in contrast to ! a la Church and
similar systems which are called, e.g., typed systems.
3.3. Church versus Curry typing
Although the simply typed -calculus a la Curry and Church are dierent,
one has the feeling that essentially the same thing is going on. To some
extent this intuition is correct, as we now show.
Every pseudo-term induces a type-free -term by erasing the domains of
abstractions.
3.3.1. Definition. The erasure map j  j : 

!  is dened as follows:
jxj = x;
jM N j = jM j jN j;
jx::M j = x:jM j:
50 Chapter 3. Simply typed -calculus
Erasure preserves reduction and typing:
3.3.2. Proposition (Erasing). Let M;N 2 

.
(i) If M !

N then jM j !

jN j;
(ii) If ? `

M :  then ? ` jM j : .
Proof. (i) prove by induction on M that
jM [x := N ]j = jM j[x := jN j] ()
Then proceed by induction on the derivation of M !

N using ().
(ii) by induction on the derivation of ? `

M : . ut
Conversely, one can \lift" every Curry derivation to a Church one.
3.3.3. Proposition (Lifting). For all M;N 2 :
(i) If M !

N then for each M
0
2 

with jM
0
j = M there is N
0
2 

such that jN
0
j = N , and M
0
!

N
0
;
(ii) If ? `M :  then there is an M
0
2 

with jM
0
j =M and ? `

M
0
: .
Proof. By induction on the derivation of M !

N and ? ` M : ,
respectively. ut
3.3.4. Warning. The above two propositions allow one to derive certain
properties of Curry-style typable lambda-terms from analogous properties
of Church-style typed lambda-terms, or conversely. For instance, strong
normalization for one variant of ( !) easily implies strong normalization
for the other (Exercise 3.6.4).
However, one has to be very cautious with such proof methods, some-
times they do not work. A common mistake (cf. Exercise 3.6.5) is the
following attempt to derive the Church-Rosser property for Church-style
(!) from the Church-Rosser property for untyped lambda-terms:
Assume that M
0
!

M
1
and M
0
!

M
2
. Then, by Propo-
sition 3.3.2, we have jM
0
j !

jM
1
j and jM
0
j !

jM
2
j. By
Church-Rosser property for untyped lambda-terms, we have a
term P with jM
1
j !

P and jM
2
j !

P . In addition, by the
subject reduction property, P is typable into the desired type. It
remains to apply Proposition 3.3.3, to obtain a Church-style term
M
3
with jM
3
j = P , and such that M
2
!

M
3
and M
1
!

M
3
.
For an explanation why the gap in this argument cannot be easily xed, and
how it can be xed, see [74, pp. 269, 559].
In the remainder, when stating properties of simply typed -calculus it
must always be understood that the result applies to both ! a la Curry
and a la Church, except when explicitly stated otherwise.
3.4. Normalization 51
3.4. Normalization
In this section we are concerned with ! a la Church.
A simple type can be regarded as a nite binary tree|this is where
the alternative name \nite type" comes from|where all internal nodes are
labeled by arrows and all leaves are labeled by type variables. We shall
often refer to properties of types expressing them as properties of this tree
representation. For instance, the function h() dened below is just the
height of the corresponding tree.
3.4.1. Definition. Dene the function h : ! N by:
h() = 0
h( ! ) = 1 +max(h(); h())
It is often convenient to write Church style terms (typable pseudo-terms)
in such a way that types of some or all subterms are displayed by super-
scripts, as in e.g., (x::P

)
!
R

. Recall that a Church style term can be
typed in only one way, provided the context of free variables is known. Thus
our labelling is always determined by the term and the context. But the
labelling itself is not a part of syntax, just a meta-notation.
The following property is the rst non-trivial property of !.
3.4.2. Theorem (Weak normalization). Suppose ? `

M : . Then there
is a nite reduction M
1
!

M
2
!

: : :!

M
n
2 NF

.
Proof. We use a proof idea due independently to Turing and Prawitz.
Dene the height of a redex (x::P

)R to be h( ! ). For M 2 

with M 62 NF

dene
m(M) = (h(M); n)
where
h(M) = maxfh() j is a redex in Mg
and n is the number of redex occurrences inM of height h(M). If M 2 NF

we dene h(M) = (0; 0).
We show by induction on lexicographically ordered pairs m(M) that if
M is typable in ! a la Church, then M has a reduction to normal-form.
Let ? ` M : . If M 2 NF

the assertion is trivially true. If M 62 NF

,
let  be the rightmost redex in M of maximal height h (we determine the
position of a subterm by the position of its leftmost symbol, i.e., the right-
most redex means the redex which begins as much to the right as possible).
Let M
0
be obtained from M by reducing the redex . The term M
0
may in general have more redexes than M . But we claim that the number
of redexes of height h in M
0
is smaller than in M . Indeed, the redex  has
disappeared, and the reduction of  may only create new redexes of height
52 Chapter 3. Simply typed -calculus
less than h. To see this, note that the number of redexes can increase by
either copying existing redexes or by creating new ones. Now observe that
if a new redex is created then one of the following cases must hold:
1. The redex  is of the form (x:: : : : xP

: : : )(y

:Q

)

, where  =
 ! , and reduces to : : : (y

:Q

)P

: : : . There is a new redex
(y

:Q

)P

of height h() < h.
2. We have  = (x::y::R

)P

, occurring in the context 
!
Q

.
The reduction of  to y::R

1
, for some R
1
, creates a new redex
(y::R

1
)Q

of height h(! ) < h( ! ! ) = h.
3. The last case is when  = (x::x)(y

:P

), with  =  ! , and
it occurs in the context 

Q

. The reduction creates the new redex
(y

:P

)Q

of height h() < h.
The other possibility of adding redexes is by copying. If we have  =
(x::P

)Q

, and P contains more than one free occurrence of x, then all
redexes in Q are multiplied by the reduction. But we have chosen  to be
the rightmost redex of height h, and thus all redexes in Q must be of smaller
heights, because they are to the right of .
Thus, in all cases m(M) > m(M
0
), so by the induction hypothesis M
0
has a normal-form, and then M also has a normal-form. ut
In fact, an even stronger property than weak normalization holds: if
`

M : , then no innite reduction M
1
!

M
2
!

: : : exists. This
property is called strong normalization and will be proved later.
The subject reduction property together with the Church-Rosser prop-
erty and strong normalization imply that reduction of any typable -term
terminates in a normal form of the same type, where the normal form is
independent of the particular order of reduction chosen.
3.5. Expressibility
As we saw in the preceding section, every simply typable -term has a
normal-form. In fact, one can eectively nd this normal-form by repeated
reduction of the leftmost redex. (These results hold for both the a la Curry
and a la Church system.) Therefore one can easily gure out whether two
simply typable terms are -equal: just reduce the terms to their respective
normal-forms and compare them.
These results should suggest that there will be diculties in represent-
ing all the partial recursive functions and possibly also the total recursive
functions by simply typable -terms, as we shall now see. In the rest of this
section we are concerned with simply typed -calculus a la Curry.
3.5. Expressibility 53
3.5.1. Definition. Let
int = (! )! (! )
where  is an arbitrary type variable. A numeric function f : N
n
! N is
!-denable if there is an F 2  with ` F : int !    ! int ! int
(n+ 1 occurrences of int) such that
F c
n
1
: : : c
n
m
=

c
f(n
1
;::: ;n
m
)
for all n
1
; : : : ; n
m
2 N.
It is natural to investigate which of the constructions from Chapter 1
carry over to the typed setting. This is carried out below.
3.5.2. Lemma. The constant and projection functions are !-denable.
Proof. See the Exercises. ut
3.5.3. Lemma. The function sg : N ! N dened by sg(0) = 0; sg(m+1) = 1
is !-denable.
Proof. See the Exercises. ut
3.5.4. Lemma. Addition and multiplication are !-denable.
Proof. See the Exercises. ut
3.5.5. Definition. The class of extended polynomials is the smallest class
of numeric functions containing the
(i) projections: U
m
i
(n
1
; : : : ; n
m
) = n
i
for all 1  i  m;
(ii) constant functions: k(n) = k;
(iii) signum function: sg(0) = 0 and sg(m+ 1) = 1.
and closed under addition and multiplication:
(i) addition: if f : N
k
! N and g : N
l
! N are extended polynomials, then
so is (f + g) : N
k+l
! N
(f + g)(n
1
; : : : ; n
k
;m
1
; : : : ;m
l
) = f(n
1
; : : : ; n
k
) + g(m
1
; : : : ;m
l
)
(ii) multiplication: if f : N
k
! N and g : N
l
! N are extended polynomials,
then so is (f  g) : N
k+l
! N
(f  g)(n
1
; : : : ; n
k
;m
1
; : : : ;m
l
) = f(n
1
; : : : ; n
k
)  g(m
1
; : : : ;m
l
)
3.5.6. Theorem (Schwichtenberg). The !-denable functions are exactly
the extended polynomials.
The proof is omitted. One direction follows easily from what has been
said already; the other direction is proved in [97].
If one does not insist that numbers be uniformly represented as terms of
type int, more functions become !-denable|see [35].
54 Chapter 3. Simply typed -calculus
3.6. Exercises
3.6.1. Exercise. Show that the following -terms have no type in ! a la
Curry.
1. x:x x;
2. 

3. K I
;
4. Y;
5. c
2
K.
3.6.2. Exercise. Find terms M and M
0
and types ; 
0
such that ` M : ,
` M
0
: 
0
, M !

M
0
, and not ` M : 
0
.
3.6.3. Exercise. Is the following true? If M !

N (where M;N 2 ) and
M
0
; N
0
2 

are such that jM
0
j =M , jN
0
j = N then M
0
!

N
0
.
3.6.4. Exercise. Show that strong normalization for (!) a la Curry im-
plies strong normalization for (!) a la Church, and conversely.
3.6.5. Exercise. Find the bug in the example argument in Warning 3.3.4.
3.6.6. Exercise. Consider the proof of weak normalization. Assume that
a given term M is of length n including type annotations. Give a (rough)
upper bound (in terms of a function in n) for the length of the normalizing
sequence of reductions for M , obtained under the strategy dened in that
proof. Can your function be bounded by exp
k
(n), for some k? Can this be
done under the assumption that the height of redexes in M is bounded by
a given constant h? (Here, exp
0
(n) = n and exp
k+1
(n) = 2
exp
k
(n)
.)
3.6.7. Exercise. This exercise, and the next one, are based on [35]. Dene
the rank of a type  , denoted rk(), as follows:
rk() = 0
rk( ! ) = max(h() + 1; h())
Alternatively, we have
rk(
1
!    ! 
n
! ) = 1 +max(h(
1
); : : : ; h(
n
)):
The rank of a redex (x::P

)R is rk( ! ). Then dene the depth of a
term M , denoted d(M), by the conditions
d(x) = 0;
d(MN) = 1 +max(d(M); d(N));
d(x::M) = 1 + d(M):
3.6. Exercises 55
Let r be the maximum rank of a redex occurring in M , and let d(M) = d.
Show (by induction w.r.t M) that M can be reduced in at most 2
d
?1 steps
to a term M
1
such that the maximum rank of a redex occurring in M
1
is at
most r ? 1, and d(M
1
)  2
d
.
3.6.8. Exercise. Let r be the maximum rank of a redex occurring in M ,
and let d(M) = d. Use the previous exercise to prove that the normal form
of M is of depth at most exp
r
(d), and can be obtained in at most exp
r
(d)
reduction steps.
3.6.9. Exercise. Show that the constant functions and projection functions
are !-denable.
3.6.10. Exercise. Show that sg is !-denable.
3.6.11. Exercise. Show that addition and multiplication are !-denable.
56 Chapter 3. Simply typed -calculus
CHAPTER 4
The Curry-Howard isomorphism
Having met one formalism for expressing eective functions|-calculus|
and another formalism for expressing proofs|natural deduction for intu-
itionistic logic|we shall now demonstrate an amazing analogy between the
two formalisms, known as the Curry-Howard isomorphism.
We have already seen several hints that eective functions and proofs
should be intimately related. For instance, as mentioned in Chapter 2,
the BHK-interpretation [17, 53, 63] states that a proof of an implication
'
1
! '
2
is a \construction" which transforms any proof of '
1
into a proof
of '
2
. What is a construction? A possible answer is that it is some kind
of eective function. There are several ways to make this answer precise.
In this chapter we present one such way; another one is given by Kleene's
realizability interpretation, which we present later.
4.1. Natural deduction without contexts
Recall that Chapter 2 presented a so-called natural deduction formulation
of intuitionistic propositional logic. Such systems were originally introduced
by Gentzen [39]. More precisely, Gentzen introduced two kinds of systems,
nowadays called natural deduction systems and sequent calculus systems,
respectively. In this chapter we are concerned with the former kind; sequent
calculus systems will be introduced in the next chapter.
One of the most signicant studies of natural deduction systems after
Gentzen's work in the 1930s appears in Prawitz' classical book [85], which
is still very readable.
There is an informal way of writing natural deduction proofs. Instead of
maintaining explicitly in each node of a derivation the set of assumptions on
which the conclusion depends (the context), one writes all the assumptions
at the top of the derivation with a marker on those assumptions that have
been discharged by the implication introduction rule.
57
58 Chapter 4. The Curry-Howard isomorphism
Since this style is quite common in the proof theory literature|at least
until the Curry-Howard isomorphism became widely appreciated|we also
briey review that notation informally here. Another reason for doing so, is
that the notation displays certain interesting problems concerning assump-
tions that are hidden in our formulation of Chapter 2.
Consider the proof tree:
'
('!  ) ^ ('! )
'!  
 
'
('!  ) ^ ('! )
'! 

 ^ 
First note that, as always, the proof tree is written upside-down. The leaves
are the assumptions, and the root is the conclusion, so the proof tree demon-
strates that one can infer  ^  from ' and ('!  ) ^ ('! ).
As usual there is an !-introduction rule which discharges assumptions.
Thus we are able to infer '!  ^  from ('!  ) ^ ('! ). Notationally
this is done by putting brackets around the assumption in question which
is then called closed, as opposed to the other assumptions which are called
open:
[']
('!  ) ^ ('! )
'!  
 
[']
('!  ) ^ ('! )
'! 

 ^ 
'!  ^ 
Note that the above step discharges both occurrences of '. In general, in an
!-introduction step, we may discharge zero, one, or more occurrences of an
assumption.
Taking this one step further we get
[']
[('!  ) ^ ('! )]
'!  
 
[']
[('!  ) ^ ('! )]
'! 

 ^ 
'!  ^ 
('!  ) ^ ('! )! '!  ^ 
Since we may decide to discharge only some of the occurrences of an open
assumption in an!-introduction step, one sometimes adopts for readability
the convention of assigning numbers to assumptions, and one then indicates
in an !-introduction step which of the occurrences where discharged. In
the above example we thus might have the following sequence of proof trees.
4.1. Natural deduction without contexts 59
First:
'
(1)
('!  ) ^ ('! )
(2)
'!  
 
'
(1)
('!  ) ^ ('! )
(2)
'! 

 ^ 
Then by closing both occurrences of ':
[']
(1)
('!  ) ^ ('! )
(2)
'!  
 
[']
(1)
('!  ) ^ ('! )
(2)
'! 

 ^ 
'!  ^ 
(1)
And by closing both occurrences of ('!  ) ^ ('! ):
[']
(1)
[('!  ) ^ ('! )]
(2)
'!  
 
[']
(1)
[('!  ) ^ ('! )]
(2)
'! 

 ^ 
'!  ^ 
(1)
('!  ) ^ ('! )! '!  ^ 
(2)
It is interesting to note that the notation where we indicate which as-
sumption is discharged allows us to distinguish between certain very similar
proofs. For instance, in
[']
(1)
[('!  ) ^ ('! )]
(2)
'!  
 
[']
(1)
[('!  ) ^ ('! )]
(3)
'! 

 ^ 
'!  ^ 
(1)
('!  ) ^ ('! )! '!  ^ 
(2)
('!  ) ^ ('! )! ('!  ) ^ ('! )! '!  ^ 
(3)
and
[']
(1)
[('!  ) ^ ('! )]
(2)
'!  
 
[']
(1)
[('!  ) ^ ('! )]
(3)
'! 

 ^ 
'!  ^ 
(1)
('!  ) ^ ('! )! '!  ^ 
(3)
('!  ) ^ ('! )! ('!  ) ^ ('! )! '!  ^ 
(2)
60 Chapter 4. The Curry-Howard isomorphism
we discharge the two occurrences of (' !  ) ^ (' ! ) separately, but in
dierent orders.
Similarly,
[']
(1)
'! '
(1)
'! '! '
(2)
and
[']
(1)
'! '
(2)
'! '! '
(1)
are two dierent proofs of ' ! ' ! '. In the rst proof there is rst a
discharge step in which the single occurrence of ' is discharged, and then a
discharge step in which zero occurrences of ' are discharged. In the second
proof the order is reversed.
In order to avoid confusion with assumption numbers, we require that if
two assumptions ' and  have the same number, then ' and  are the same
formula. Also, when we discharge the assumptions with a given number (i),
we require that every assumption with this number actually occur on a
branch from the node where the discharging occurs.
In general, the rules for constructing the above proof trees look as follows.
'  
' ^  
' ^  
'
' ^  
 
'
' _  
 
' _  
' _  
[']
(i)
.
.
.

[ ]
(j)
.
.
.


(i;j)
[']
(i)
.
.
.
 
'!  
(i)
'!  '
 
?
'
For instance, the upper left rule (^-introduction) states that two proof
trees ending in roots ' and  , respectively, may be joined into a single proof
tree by addition of a new root '^ with the former roots as children. The
!-introduction rule states that one may infer an implication by discharging
the assumptions with the label indicated by the step.
4.1. Natural deduction without contexts 61
As we shall see later in this chapter, there is an interest in proofs of a
certain simple form. One arrives at such proofs from arbitrary proofs by
means of proof normalization rules that eliminate detours in a proof. More
concretely, consider the proof tree:
[']
(1)
'! '
(1)
[ ]
(2)
 !  
(2)
('! ') ^ ( !  )
'! '
The proof tree demonstrates that ' ! ' is derivable. However, it does
so by rst showing ' ! ', then inferring (' ! ') ^ ( !  ), and then,
nally, concluding ' ! '. A more direct proof tree, which does not make
an excursion via ('! ') ^ ( !  ) is:
[']
(1)
'! '
(1)
Note that the detour in the former proof tree is signied by an intro-
duction rule immediately followed by the corresponding elimination rule,
for example ^-introduction and ^-elimination. In fact, the above style of
detour-elimination is possible whenever an introduction rule is immediately
followed by the corresponding elimination rule.
As another example, consider the proof tree:
[']
(3)
'! '
(3)
['! ']
(1)
 ! '! '
(2)
('! ')!  ! '! '
(1)
 ! '! '
Here we infer  ! ' ! ' from ' ! ' and (' ! ') !  ! ' ! '.
The proof of the latter formula proceeds by inferring  ! ' ! ' from the
assumption ' ! '. Since we can prove this assumption, we could simply
take this proof and replace the assumption ' ! ' with the proof of this
formula:
[']
(3)
'! '
(3)
 ! '! '
(2)
In general one considers the following proof normalization rules (sym-
62 Chapter 4. The Curry-Howard isomorphism
metric cases omitted):

'

 
' ^  
' !

'

 
[ ]
(i)

'
 ! '
(i)
' !

 

'

'
' _  
[']
(i)


[ ]
(j)



(i;j)
!

'


The rst rule states that if we, somewhere in a proof, infer ' and  and then
use ^-introduction to infer ' ^  followed by ^-elimination to infer ', we
might as well avoid the detour and replace this proof simply by the subproof
of '.
The second rule states that if we have a proof of ' from assumption  
and we use this and !-introduction to get a proof of  ! ', and we have
a proof of  then, instead of inferring ' by !-elimination, we might as well
replace this proof by the original proof of ' where we plug in the proof of  
in all the places where the assumption  occurs.
The reading of the third rule is similar.
The process of eliminating proof detours of the above kind, is called
proof normalization, and a proof tree with no detours is said to be in normal
form. Another similar process, called cut elimination, eliminates detours in
sequent calculus proofs whereas proof normalization eliminates detours in
natural deduction proofs. Sequent calculus systems are introduced in the
next chapter.
Proof normalization and cut elimination were studied in the 1930s by
Gentzen, and his studies were continued by several researchers, perhaps most
importantly by Prawitz in [85]. Nowadays, proof theory is an independent
discipline of logic.
In these notes we shall not consider natural deduction proofs in the above
style any further.
4.2. The Curry-Howard isomorphism 63
4.2. The Curry-Howard isomorphism
We could introduce reductions a la those of the preceding section for the
natural deduction formulation of Chapter 2, but we shall not do so. The
rules for that formulation are rather tedious (try the rule for !!). It would
be more convenient to have each proof tree denoted by some 1-dimensional
expression and then state transformations on such expressions rather than
on proof trees. It happens that the terms of the simply typed -calculus are
ideal for this purpose, as we shall see in this section.
We show that any derivation in intuitionistic propositional logic corre-
sponds to a typable -term a la Church, and vice versa. More precisely we
show this for the implicational fragment of intuitionistic propositional logic.
Recall from Section 2.6 that the implicational fragment is the subsystem
in which the only connective is ! and in which the only rules are (! E)
and (! I). This fragment is denoted IPC(!). The whole system is denoted
IPC(!;^;_;?) or plainly IPC.
If we take PV (the set of propositional variables) equal to U (the set of
type variables), then  (the set of propositional formulas in the implicational
fragment of intuitionistic propositional logic) and  (the set of simply types)
are identical. This will be used implicitly below.
4.2.1. Proposition (Curry-Howard isomorphism).
(i) If ? ` M : ' then j?j ` '.
1
(ii) If ? ` ' then there exists M 2 

such that  ` M : ', where
 = f(x
'
: ') j ' 2 ?g.
Proof. (i): by induction on the derivation of ? ` M : '.
(ii): by induction on the derivation of ? ` '. Let  = fx
'
: ' j ' 2 ?g.
1. The derivation is
?; ' ` '
We consider two subcases:
(a) ' 2 ?. Then  ` x
'
: '.
(b) ' 62 ?. Then ; x
'
: ' ` x
'
: '.
2. The derivation ends in
? ` '!  ? ` '
? `  
By the induction hypothesis  ` M : ' !  and  ` N : ', and
then also  ` M N :  .
1
Recall that j?j denotes the range of ?.
64 Chapter 4. The Curry-Howard isomorphism
3. The derivation ends in
?; ' `  
? ` '!  
We consider two subcases:
(a) ' 2 ?. Then by the induction hypothesis  ` M :  . By
Weakening (Lemma 3.19(i)) ; x : ' ` M :  , where x 62
dom(). Then also  ` x :' : M : '!  .
(b) ' 62 ?. Then by the induction hypothesis ; x
'
: ' ` M :  and
then also  ` x
'
:' : M : '!  . ut
4.2.2. Remark. The correspondence displays certain interesting problems
with the natural deduction formulation of Chapter 2. For instance
x : '; y : ' ` x : '
x : ' ` y :' : x : '! '
` x :' : y :' : x : '! '! '
and
x : '; y : ' ` y : '
x : ' ` y :' : y : '! '
` x :' : y :' : y : '! '! '
are two dierent derivations in ! showing that both x :' : y :' : x and
x :' : y :' : y have type '! '! '.
Both of these derivations are projected to
' ` '
' ` '! '
` '! '! '
This reects the fact that, in the natural deduction system of Chapter 2, one
cannot distinguish proofs in which assumptions are discharged in dierent
orders. Indeed, ! can be viewed as an extension of IPC(!) in which
certain aspects such as this distinction are elaborated.
The correspondence between derivations in IPC(!) and ! can be
extended to the whole system IPC by extending the simply typed -calculus
with pairs and disjoint sums. One extends the language 

with clauses:


::= : : : j < 

;

> j 
1
(

) j 
2
(

)
j in
 _'
1
(

) j in
 _'
2
(

) j case(

;V:

;V:

)
4.2. The Curry-Howard isomorphism 65
and adds typing rules:
? ` M :  ? ` N : '
? `< M;N >:  ^ '
? ` M :  ^ '
? ` 
1
(M) :  
? ` M :  ^ '
? ` 
2
(M) : '
? ` M :  
? ` in
 _'
1
(M) :  _ '
? ` M : '
? ` in
 _'
2
(M) :  _ '
? ` L :  _ ' ?; x :  ` M :  ?; y : ' ` N : 
? ` case(L;x:M ; y:N) : 
and reduction rules:

1
(< M
1
;M
2
>) ! M
1

2
(< M
1
;M
2
>) ! M
2
case(in
'
1
(N);x:K; y:L) ! Kfx := Ng
case(in
'
2
(N);x:K; y:L) ! Lfy := Ng
Intuitively, ^ is a product type, so < M
1
;M
2
> is a pair, and 
1
(M)
is the rst projection. In type-free -calculus these could be dened in terms
of pure -terms (see Proposition 1.46), but this is not possible in !. This
is related to the fact that one cannot dene conjunction in IPC in terms of
implication (contrary to the situation in classical logic, as we shall see later).
In the same spirit,  _  is a sum (or \variant") type. A sum type is
a data type with two unary constructors. Compare this to the data type
\integer list", which is usually dened as a data type with two constructors:
the 0-ary constructor Nil and the 2-ary constructor Cons(; ) which takes a
number and a list of numbers. In a sum we have the two unary constructors
left and right injection.
Thus case(M ;x:K; y:L) is a case-expression which tests whether M has
form in
'
1
(N) (and then returns K with N for x) or in
2
(N) (and then re-
turns L with N for y), just like in a functional programming language
we could have a case-expression testing whether an expression is Nil or
Cons(n; ns).
Thus, uses of the axiom of intuitionistic propositional logic are reected
by variables in the term, uses of the !-elimination rule correspond to ap-
plications, and uses of the !-introduction rule correspond to abstractions.
In fact, we can view ! as a more elaborate formulation of IPC(!)
in which the terms \record" the rules it was necessary to apply to prove
the type of the term, when we view that type as a proposition. For in-
stance, x : ' : x has type ' ! ', signifying the fact that we can prove
' ! ' by rst using the axiom recorded by the variable x and then using
!-introduction, recorded by x : '. In short, in ! viewed as a logic,
the terms serve as a linear representation of proof trees, and are usually
66 Chapter 4. The Curry-Howard isomorphism
called constructions [58]. These are also constructions in the sense of the
BHK-interpretation: a construction of '!  is a -term x :' : M of type
'!  .
Two dierent propositions cannot have the same construction, since we
work with Church terms. In contrast, several constructions may correspond
to the same proposition. This is because the same proposition may be proven
in dierent ways.
Thus ! and IPC(!) may be viewed as dierent names for essentially
the same thing. This means that each of the concepts and properties con-
sidered in ! makes sense in IPC(!) and vice versa.
As mentioned, terms in ! correspond to constructions in IPC(!).
Types correspond to formulas, type constructors (sum and pair) to connec-
tives. Asking whether there exists a term of a given type (inhabitation),
corresponds to asking whether there exist a construction for a given propo-
sition (provability.) Asking whether there exists a type for a given term
(typability), corresponds to asking whether the construction is a construc-
tion of some formula.
What is a redex in a construction? Well, each introduction rule intro-
duces a constructor (a lambda, a pair, or an injection) in the construction,
and each elimination rule introduces a destructor (an application, a projec-
tion, or a case-expression). Now, a redex consists of a constructor imme-
diately surrounded by the corresponding destructor. Therefore a redex in
the construction represents a proof tree containing an application of an in-
troduction rule immediately followed by an application of the corresponding
elimination rule; this was what we called a detour in a proof tree. Therefore,
reduction on terms corresponds to normalization of constructions. A term
in normal form corresponds to a construction representing a proof tree in
normal form. The subject reduction proposition states that reducing a con-
struction of a formula yields a construction for the same formula. The
Church-Rosser Theorem states that the order of normalization is immate-
rial. Also, it states that we managed to identify essentially identical proofs
without identifying all proofs.
4.2. The Curry-Howard isomorphism 67
In summary:
! IPC(!)
term variable assumption
term construction (proof)
type variable propositional variable
type formula
type constructor connective
inhabitation provability
typable term construction for a proposition
redex construction representing proof tree with redundancy
reduction normalization
value normal construction
4.2.3. Example. Consider the following example deduction containing re-
dundancy. The original derivation with constructions is:
x : ' ` x : '
` x :' : x : '! '
The complicated proof with constructions is:
y :  ` y :  
` y : : y :  !  
x : ' ` x : '
` x :' : x : '! '
`< x :' : x; y : : y >: ('! ') ^ ( !  )
` 
1
(< x :' : x; y : : y >) : '! '
The construction of the latter proof tree in fact contains a redex which upon
reduction yields the construction of the former proof tree.
The perfect correspondence between reduction and normalization and
the related concepts, justies the name \isomorphism" rather than simply
\bijection." In fact, reduction has been studied extensively in the -calculus
literature, while normalization has been studied independently in proof the-
ory.
Since the \discovery" of the isomorphism, the two worlds have merged,
and some authors feel that it is exactly in the correspondence between reduc-
tion and normalization that the isomorphism is deepest and most fruitful.
This point of view is supported by the fact that some typed -calculi have
been introduced as means of studying normalization for logics, most notably
Girard's System F introduced in his work [44] from 1971. System F corre-
sponds to second order minimal propositional logic and will be discussed in
Chapter 12.
68 Chapter 4. The Curry-Howard isomorphism
As an appealing illustration of the isomorphism and an appropriate con-
clusion of this section, this system was independently invented at roughly
the same time in computer science by Reynolds [90] in his study of poly-
morphism in typed functional programming languages.
In the remainder of these notes the concepts corresponding to one an-
other under the isomorphism are used interchangeably. In particular, any
system as that of the preceding subsection will be called both a logic and a
-calculus depending on the aspects being emphasized.
4.3. Consistency from normalization
A number of properties regarding unprovability can be dicult to establish
directly, but more easy to establish by semantical methods as we saw in
Chapter 2. Often these semantical methods can be replaced by methods
involving the weak normalization property.
The following shows that IPC(!) is consistent.
4.3.1. Proposition. 6` ?.
Proof. Assume that ` ?. Then ` M : ? for some M 2 

. By the weak
normalization theorem and the subject reduction theorem there is then an
N 2 NF

such that ` N : ?.
Now, -terms in normal form have form x N
1
: : : N
m
(where N
1
; : : : ; N
n
are normal-forms) and x : : N
0
(where N
0
is in normal form). We cannot
have N of the rst form (then x 2 FV(N), but since ` N : ?, FV(N) = fg).
We also cannot have N of the second form (then ? =  !  for some ; 
which is patently false). ut
4.4. Strong normalization
As suggested by the application in the preceding section, the weak normal-
ization property of ! is a very useful tool in proof theory. In this section
we prove the strong normalization property of ! which is sometimes even
more useful.
The standard method of proving strong normalization of typed -calculi
was invented by Tait [104] for simply typed -calculus, generalized to second-
order typed -calculus by Girard [44], and subsequently simplied by Tait [105].
Our presentation follows [8]; we consider in this section terms a la Curry.
4.4.1. Definition.
(i) SN

= fM 2  jM is strongly normalizing g.
(ii) For A;B  , dene A! B = fF 2  j 8a 2 A : F a 2 Bg.
4.4. Strong normalization 69
(iii) For every simple type , dene [[]]   by:
[[]] = SN

[[ !  ]] = [[]]! [[ ]]
4.4.2. Definition.
(i) A set X  SN

is saturated if
1. For all n  0 and M
1
; : : : M
n
2 SN

:
x M
1
: : :M
n
2 X
2. For all n  1 and M
1
; : : : ;M
n
2 SN

:
M
0
fx := M
1
gM
2
: : :M
n
2 X ) (x:M
0
)M
1
M
2
: : :M
n
2 X
(ii) S= fX   jX is saturated g.
4.4.3. Lemma.
(i) SN

2 S;
(ii) A;B 2 S ) A! B 2 S;
(iii)  2  ) [[]] 2 S.
Proof. Exercise 4.6.3. ut
4.4.4. Definition.
(i) a valuation is a map  : V ! , where V is the set of term variables.
The valuation (x := N) is dened by
(x := N)(y) =

N if x  y
(y) otherwise
(ii) Let  be a valuation. Then [[M ]]

= Mfx
1
:= (x
1
); : : : ; x
n
:= (x
n
)g,
where FV(M) = fx
1
; : : : ; x
n
g.
(iii) Let  be a valuation. Then  j= M :  i [[M ]]

2 [[]]. Also,  j= ? i
(x) 2 [[]] for all x :  2 ?.
(iv) ? j= M :  i 8 :  j= ? )  j= M : .
4.4.5. Proposition (Soundness). ? ` M :  ) ? j= M : .
Proof. By induction on the derivation of ? ` M : .
1. The derivation is
? ` x :  x :  2 ?
If  j= ?, then [[x]]

= (x) 2 [[]].
70 Chapter 4. The Curry-Howard isomorphism
2. The derivation ends in
? ` M :  !  ? ` N : 
? ` M N : 
Suppose  j= ?. By the induction hypothesis ? j= M :  !  and
? j= N : , so  j= M :  !  and  j= N : , i.e., [[M ]]

2 [[]] ! [[ ]]
and [[N ]]

2 [[]]. Then [[M N ]]

= [[M ]]

[[N ]]

2 [[ ]], as required.
3. The derivation ends in
?; x :  ` M : 
? ` x:M :  ! 
Suppose  j= ?. Also, suppose N 2 [[]]. Then (x := N) j= ?; x : .
By the induction hypothesis ?; x :  j= M :  , so (x := N) j= M :  ,
i.e., [[M ]]
(x:=N)
2 [[ ]]. Now,
[[x:M ]]

N  (x:M) fy
1
:= (y
1
); : : : ; y
n
:= (y
n
)gN
!

Mfy
1
:= (y
1
); : : : ; y
n
:= (y
n
); x := Ng
 [[M ]]
(x:=N)
Since N 2 [[]]  SN

and [[M ]]
(x:=N)
2 [[ ]] 2 S, it follows that
[[x:M ]]

N 2 [[ ]]. Hence [[x:M ]]

2 [[ !  ]]. ut
4.4.6. Theorem. ? ` M :  ) M 2 SN

.
Proof. If ? ` M : , then ? j= M : . For each x :  2 ?, let
(x) = x. Then x 2 [[ ]] holds since [[ ]] 2 S. Then  j= ?, and we have
M = [[M ]]

2 [[]]  SN

. ut
The reader may think that the above proof is more complicated than the
weak normalization proof of the preceding chapter; in fact, this feeling can
be made into a technical property by noting that the latter proof involves
quantifying over sets, whereas the former does not.
The fact that the strong normalization property seems more dicult to
prove has led to some techniques that aim at inferring strong normalization
from weak normalization|see [102].
There are many applications of strong normalization, but many of these
applications can be obtained already by using the weak normalization theo-
rem. The following is a true application of strong normalization where weak
normalization does not suce.
4.4.7. Definition. Let ! be a binary relation on some set L, and write
M !M
0
if M =M
1
! : : :!M
n
=M
0
, where n  1. Then
1. ! satises CR i for all M
1
;M
2
;M
3
2 L, M
1
!M
2
and M
1
!M
3
implies that there is an M
4
2 L such that M
2
!M
4
and M
3
!M
4
.
4.5. Historical remarks 71
2. ! satises WCR i for all M
1
;M
2
;M
3
2 L, M
1
!M
2
and M
1
!M
3
implies that there is an M
4
2 L such that M
2
!M
4
and M
3
!M
4
.
3. ! satises SN i for all M 2 L, there is no innite reduction sequence
M !M
0
! : : : .
4. ! satises WN i for all M 2 L, there is a nite reduction sequence
M ! M
0
! : : : ! M
00
such that M
00
is a normal form (i.e., for all
N 2 L: M
00
6! N).
4.4.8. Proposition (Newman's lemma). Let ! be a binary relation satis-
fying SN. If ! satises WCR, then ! satises CR.
Proof. See the exercises. ut
The following shows that the assumption about strong normalization
cannot be replaced by weak normalization.
4.4.9. Proposition. There is a binary relation ! satisfying WN and WCR,
but not CR.
Proof. See the exercises. ut
4.4.10. Corollary. Let M
1
2  be typable in ! a la Church and assume
that M
1
!

M
2
and M
1
!

M
3
. Then there is an M
4
such that M
2
!

M
4
and M
3
!

M
4
.
Proof. See the exercises. ut
4.5. Historical remarks
The informal notion of a \construction" mentioned in the BHK-interpretation
was rst formalized in Kleene's recursive realizability interpretation [60, 61]
in which proofs in intuitionistic number theory are interpreted as numbers,
as we will see later in the notes. A proof of '
1
! '
2
is interpreted as the
Godel number of a partial recursive function mapping the interpretation of
any proof of '
1
to the interpretation of a proof of '
2
.
One can see the Curry-Howard isomorphism|the correspondence be-
tween systems of formal logic and functional calculi with types, mentioned
above|as a syntactic reection of this interpretation. It shows that a cer-
tain notation system for denoting certain recursive functions coincides with
a system for expressing proofs.
Curry [24] discovered that the provable formulas in a so-called Hilbert
formulation of IPC(!) coincide with the inhabited types of combinatory
logic, when one identies function type with implication. Moreover, every
proof in the logic corresponds to a term in the functional calculus, and
72 Chapter 4. The Curry-Howard isomorphism
vice versa. Curry also noted a similar correspondence between a natural
deduction formulation of IPC(!) and simply typed -calculus, and between
a sequent calculus formulation of IPC(!) and a sequent calculus version of
simply typed -calculus.
Gentzen's Hauptsatz [39] shows how one can transform a sequent cal-
culus proof into another proof with no applications of the cut rule. Curry
now proved a corresponding result for the sequent calculus version of simply
typed -calculus. He then formulated correspondences between sequent cal-
culus systems, natural deduction systems, and Hilbert systems (in terms of
the corresponding functional calculi) and used these to infer weak normal-
ization for -reduction in simply typed -calculus and for so-called strong
reduction in combinatory logic.
A more direct relation between reduction on terms and normalization
of proofs was given by Howard in a paper from 1968, published as [58].
Prawitz had studied reduction of natural deduction proofs extensively [85]|
seven years after Curry's book|and had proved weak normalization of this
notion of reduction. Howard now showed that reduction of a proof in the
natural deduction system for minimal implicational logic corresponds to -
reduction on the corresponding term in the simply typed -calculus. He also
extended this correspondence to rst order intuitionistic arithmetic and a
related typed -calculus.
Howard's correspondence and the weak normalization theorem give a
syntactic version of Kleene's interpretation, where one replaces recursive
functions by -terms in normal form. For instance, any proof of '
1
! '
2
reduces to a -abstraction which, when applied to a proof of '
1
, yields a
proof of '
2
.
Constable [19, 20] suggested that a type or proposition ' be viewed as a
specication, and any proofM of ' as a program satisfying the specication.
For instance, sorting can be specied by the formula
8x 9y : ordered(y) ^ permutation(x; y)
in predicate logic, and a proof of the formula will be a sorting algorithm.
There is a literature devoted to methods for nding ecient programs in
this way.
The Curry-Howard isomorphism has evolved with the invention of nu-
merous typed -calculi and corresponding natural deduction logics, see [87,
55, 8, 41]. Other names for the isomorphism include propositions-as-types,
formula-as-types, and proofs-as-programs.
4.6. Exercises
4.6.1. Exercise. Give derivations of the formulas (1),(3),(5),(7),(9),(11) from
Section 2.2 using the natural deduction style of Section 4.1.
4.6. Exercises 73
4.6.2. Exercise. Give -terms corresponding to the derivations from Exer-
cise 4.6.1. Use the following rule for -terms corresponding to the ex-falso
rule:
? ` M : ?
? ` "
'
(M) : ' :
4.6.3. Exercise. Prove Lemma 4.4.3.
4.6.4. Exercise.
1. Prove Newman's Lemma.
Hint: Prove by induction on the length of the longest reduction se-
quence from M that M ! M
1
and M ! M
2
implies that there is
an M
3
such that M
1
!M
3
and M
2
!M
3
.
2. Prove Proposition 4.4.9.
3. Infer from Newman's Lemma Corollary 4.4.10.
4.6.5. Exercise. Prove Proposition 4.2.1(i) in detail.
4.6.6. Exercise. A -reduction strategy is a map F :  !  such that
M !

F (M) if M 62 NF

, and F (M) = M otherwise. Informally, a reduc-
tion strategy selects from any term not in normal form a redex and reduces
that. For example, F
l
is the reduction strategy that always reduces the
left-most redex.
A reduction strategy F is normalizing if, for any weakly normalizing
term M , there is an i such that
2
M !

F (M)!

: : :!

F
i
(M) 2 NF

That is, if the term has a normal form, then repeated application of F
eventually ends in the normal form. A classical result due to Curry and
Feys states that F
l
is normalizing.
A reduction strategy F is perpetual if, for any term M which is not
strongly normalizing, there is no i such that
M !

F (M)!

: : :!

F
i
(M) 2 NF

That is, if the term has an innite reduction, then repeated application of F
yields an innite reduction sequence.
Dene F
1
:  !  as follows. If M 2 NF

then F
1
(M) = M ; other-
wise
3
F
1
(x
~
P Q
~
R) = x
~
P F
1
(Q)
~
R If
~
P 2 NF

; Q 62 NF

F
1
(x:P ) = x:F
1
(P )
F
1
((x:P ) Q
~
R) = Pfx := Qg
~
R If x 2 FV(P ) or Q 2 NF

F
1
((x:P ) Q
~
R) = (x:P ) F
1
(Q)
~
R If x 62 FV(P ) and Q 62 NF

2
As usual, F
0
(M) =M and F
i+1
(M) = F (F
i
(M)).
3
By
~
P we denote a nite, possibly empty, sequence of terms.
74 Chapter 4. The Curry-Howard isomorphism
Show that F
1
is perpetual.
Let 
I
be the set of all -termsM such that any part x:P ofM satises
x 2 FV(P ). For instance, I 2 
I
and 
 2 
I
but K = x:y:x 62 
I
. Show
that for any M 2 
I
: M 2WN

i M 2 SN

.
Hint: Compare being weakly normalizing with F
l
leading to a normal
form, and compare begin strongly normalizing with F
1
leading to a normal
form. What is the relation between F
l
and F
1
on M 2 
I
?
Since 
I
is a subset of , the elements of 
I
that have a type in !
(a la Curry) must correspond to a subset of all proofs in IPC(!). Which
proofs are these?
CHAPTER 5
Proofs as combinators
In the preceding chapters we have considered various systems of -calculi.
One rather disturbing aspect of these systems is the role played by bound
variables, especially in connection with substitution. In this chapter we
consider a system, combinatory logic, which is equivalent to -calculus in a
certain sense, and in which there are no bound variables.
The rst section introduces a version of combinatory logic analogous to
type-free -calculus. The second section presents simply typed combinatory
logic, analogous to simply typed -calculus.
Since simply typed -calculus corresponds to the natural deduction for-
mulation of intuitionistic propositional logic via the Curry-Howard isomor-
phism, and combinatory logic is a variant of -calculus, it is natural to ex-
pect that simply typed combinatory logic also corresponds to some variant of
intuitionistic propositional logic. This variant, traditionally called Hilbert-
style as opposed to natural deduction style, is introduced in the third section,
and the fourth section presents the Curry-Howard isomorphism between the
Hilbert-style intuitionistic propositional logic and combinatory logic.
The fth section studies special cases of the Curry-Howard isomorphism
by investigating how certain restrictions in the logic are reected by restric-
tions in the functional calculus.
5.1. Combinatory logic
Combinatory logic was invented by Schonnkel and Curry in the 1920's
shortly before Church introduced the lambda-calculus. The idea was to
build the foundations of logic on a formal system in which logical formulas
could be handled in a variable-free manner.
As mentioned in Chapter 1, the systems of combinatory logic and -
calculus that aimed at providing a foundations of mathematics and logic
turned out to be inconsistent, due to the presence of arbitrary xed-points|
see [7, App. B] or [55, Chap. 17]. Nevertheless, one may distinguish a useful
75
76 Chapter 5. Proofs as combinators
subsystem of the original system of combinators dealing only with pure
functions, and this system will be called combinatory logic below.
The objects of study in combinatory logic are the combinatory terms.
5.1.1. Definition. The set C of combinatory terms is dened by the gram-
mar:
C ::= V j K j S j (CC)
where V is the same set of variables as used in . The notational conventions
concerning parentheses are the same as for lambda-terms.
5.1.2. Definition. The reduction relation!
w
on combinatory terms, called
weak reduction is dened by the following rules:
 KFG!
w
F ;
 SFGH !
w
FH(GH);
 If F !
w
F
0
then FG!
w
F
0
G and GF !
w
GF
0
.
The symbol !
w
denotes the smallest reexive and transitive relation con-
taining !
w
, and =
w
denotes the least equivalence relation containing !
w
.
A w-normal form is a combinatory term F such that F 6!
w
G, for all
combinatory terms G.
5.1.3. Example.
 Let I = SKK. Then, for all F , we have IF !
w
KF (KF )!
w
F .
 The term SII(SII) reduces to itself.
 Let W = SS(KI). Then, for all F;G, we have WFG!
w
FGG.
 LetB = S(KS)K. Then, for all F;G;H, we haveBFGH !
w
F (GH).
 Let C = S(BBS)(KK). Then CFGH !
w
FHG, for all F;G;H.
 K, S, K S, S K, and S KK are w-normal forms.
The following gives the rst hint that combinatory logic is essentially
simpler than -calculus in some respects.
5.1.4. Definition. For F 2 C dene the set FV(F ) of free variables of F
by:
FV(x) = fxg;
FV(H G) = FV(H) [ FV(G);
FV(S) = fg;
FV(K) = fg:
5.1. Combinatory logic 77
For F;G 2 C and x 2 V dene substitution of G for x in F by:
xfx := Gg = G;
yfx := Gg = y if x 6= y;
(H E)fx := Gg = Hfx := Gg Efx := Gg;
Sfx := Gg = S;
Kfx := Gg = K:
Note that there are no bound variables, and no need for renaming in
substitutions.
The following is similar to the the Church-Rosser property for -calculus.
5.1.5. Theorem (Church-Rosser property). If F !
w
F
1
and F !
w
F
2
then F
1
!
w
G and F
2
!
w
G, for some G.
Proof. See the exercises. ut
One can then infer Corollaries similar to 1.35{37 in Chapter 1.
There is an obvious similarity between terms of lambda-calculus and
combinatory terms. A translation
( )

: C ! 
is easy to dene. We just identify K and S with the corresponding lambda-
terms:
5.1.6. Definition.
 (x)

= x, for x 2 V ;
 (K)

= xy:x;
 (S)

= xyz:xz(yz);
 (FG)

= (F )

(G)

.
5.1.7. Proposition. If F !
w
G then (F )

!

(G)

.
Proof. By induction on the derivation of F !
w
G. ut
5.1.8. Remark. It is not in general the case that (F )

!

(G)

implies
F !
w
G. Counter-example: (S (K I)K)

!

(K)

but S (K I)K 6!
w
K.
It is less obvious how to make a translation backward, because we have
to dene lambda abstraction without bound variables. One of the possible
methods is as follows.
5.1.9. Definition. For each F 2 C and each x 2 V we dene the term


x:F 2 C.
78 Chapter 5. Proofs as combinators
 

x:x = I;
 

x:F = KF , if x 62 FV(F );
 

x:FG = S(

x:F )(

x:G), otherwise.
The following shows that the denition of abstraction behaves (partly)
as expected.
5.1.10. Proposition. (

x:F )G!
w
Ffx := Gg
Proof. Exercise 5.6.3. ut
Using the operator 

x, we can dene a translation
( )
C
: ! C
as follows.
5.1.11. Definition.
 (x)
C
= x, for x 2 V ;
 (MN)
C
= (M)
C
(N)
C
;
 (x:M)
C
= 

x:(M)
C
.
5.1.12. Remark. It is natural to expect, dually to Proposition 5.1.7, that
one could use Proposition 5.1.10 to prove that
M !

N ) (M)
C
!
w
(N)
C
()
However, this property does not hold. For instance x:I I!

x:I, but
(x:I I)
C
= S (K I) (K I) 6!
w
K I = (x:I)
C
.
If one attempts to prove () by induction on the derivation of M !

N ,
one runs into diculties in the case M !

N ) x:M !

x:N . The
problem is that the corresponding principle
F !
w
G ) 

x:F !
w


x:G ()
fails. The references at the end of the chapter contain more information
about this problem.
The following shows that the translations between  and C are inverses in
a weak sense.
5.1.13. Proposition. For all M 2 , we have ((M)
C
)

=

M .
Proof. Exercise 5.6.4. ut
5.2. Typed combinators 79
Because of Propositions 5.1.7 and 5.1.13, we can think of ( )

as of a
homomorphic embedding of the combinatory logic into the lambda-calculus.
In what follows, we often abuse the notation by using the names S;K, etc. for
the -terms (K)

, (S)

, etc.
The following property is sometimes expressed by saying that K and S
make a basis for untyped -calculus.
5.1.14. Corollary. Every closed lambda term M is beta-equal to a term
obtained from K and S solely by application.
Proof. The desired term is ((M)
C
)

. ut
Unfortunately, the embedding ( )

: C !  is not an isomorphism. Put
dierently, the left inverse operator ( )
C
is only a projection (retraction).
Indeed, we have already seen that the statement dual to Proposition 5.1.7
fails, and the same holds for the statement dual to Proposition 5.1.13.
5.1.15. Example. ((K)

)
C
= S(KK)I 6=
w
K.
It follows that \weak" equality is actually a strong property!
5.2. Typed combinators
Since combinatory terms can be seen as a subset of lambda-terms, they can
also inherit the structure of simply-typed lambda-calculus. Of course, there
are two ways to do this.
5.2.1. Definition. Dene the typability relation ` on C  C  by:
?; x :  ` x : 
? ` K :  !  ! 
? ` S : ( !  ! )! ( ! )!  ! 
? ` M :  !  ? ` N : 
? ` M N : 
for all types ;  and  and arbitrary context ?.
The other formulation of simply typed combinatory logic uses combina-
tory terms a la Church.
80 Chapter 5. Proofs as combinators
5.2.2. Definition. Dene the set C

of combinatory terms a la Church by
the grammar:
C

::= V j K
;
j S
;;
j (C

C

)
Dene the typability relation ` on C  C

 by:
?; x :  ` x : 
? ` K
;
 !  ! 
? ` S
;;
: ( !  ! )! ( ! )!  ! 
? ` M :  !  ? ` N : 
? ` M N : 
Following the path of Chapter 3 we could derive the usual properties,
e.g., the free variables lemma, a version of the generation lemma, and so
on, for each of the two combinatory logics with types. In some cases, e.g.
the proof of subject reduction, the proof is simpler since reduction does not
entail any substitutions, in contrast to the case of -reduction. Moreover, we
might also prove an equivalence result analogous to Propositions 3.3.2{3.3.3.
However, for the sake of brevity, we shall not do so.
To distinguish between the typing relation for simply typed combinatory
logic and the one for simply typed -calculus, we shall use `
C
and `

for the
two, respectively. In the remainder of the notes it will be clear from context
whether the typing relations refer to a la Curry or a la Church systems, both
in connection with combinatory logic and -calculus.
It is not dicult to see that our embedding ( )

preserves types. In
addition, the same is true for the translation ( )
C
, but this requires the
following lemma:
5.2.3. Lemma. Let ?; x :  `
C
F :  . Then ? `
C


x:F : !  .
Proof. By induction on F . ut
5.2.4. Proposition.
1. If ? `
C
F :  then ? `

(F )

:  .
2. If ? `

M :  then ? `
C
(M)
C
:  .
Proof. (i): By induction on the derivation of ? `
C
F :  . (ii): By induction
on the derivation of ? `

M :  , using Lemma 5.2.3 ut
5.2.5. Corollary. The simply-typed version of the calculus of combinators
has the strong normalization property.
Proof. By strong normalization of simply typed -calculus and Proposi-
tion 5.1.7. ut
5.3. Hilbert-style proofs 81
5.3. Hilbert-style proofs
Recall from Chapter 2 and 4 that, so far, our formal proofs have been of the
natural deduction style. Apart from the sequent calculus style of presenta-
tion, which will be introduced later, there is yet another style of presentation
of logics, known as the Hilbert-style. In fact, this is the traditional approach
to the denition of a formal proof. A Hilbert-style proof system consists of
a set of axioms and only a few proof rules.
Below we describe such a system for the implicational fragment of propo-
sitional intuitionistic logic. This system has only one proof rule, calledmodus
ponens, which is sometimes translated to English as \detachment rule":
'; '!  
 
There will be two axiom schemes. That is, all formulas that t the patterns
below are considered axioms:
(A1) '!  ! ';
(A2) ('!  ! #)! ('!  )! '! #.
Note that there are in fact innitely many axioms. But this does not bother
us as long as they can be eectively described. Formal proofs in Hilbert-style
systems are traditionally dened as sequences of formulas.
5.3.1. Definition. A formal proof of a formula ' from a set ? of assump-
tions is a a nite sequence of formulas  
1
;  
2
; : : : ;  
n
, such that  
n
= ',
and for all i = 1; : : : ; n, one of the following cases takes place:
  
i
is an axiom, or
  
i
is an element of ?, or
 there are j; ` < i such that  
j
=  
`
!  
i
(i.e.,  
i
is obtained from  
j
,
 
`
using modus ponens).
We write ? `
H
' if such a proof exists. The notation `
H
obeys the usual
conventions.
5.3.2. Example. Here is a proof of '! ' from the empty set.
1. ('! ( ! ')! ')! (('! ( ! '))! ('! ')) (axiom A2);
2. '! ( ! ')! ' (axiom A1);
3. ('! ( ! '))! ('! ') (modus ponens: detach 2 from 1);
4. '! ( ! ') (axiom A1);
82 Chapter 5. Proofs as combinators
5. '! ' (modus ponens: detach 4 from 3);
5.3.3. Example. And here is a proof of # from f'!  ; ! #; 'g:
1. '!  (assumption);
2. ' (assumption);
3.  (modus ponens: detach 2 from 1);
4.  ! # (assumption);
5. # (modus ponens: detach 3 from 4).
The following important property of Hilbert-style proof systems is called
the Deduction Theorem.
5.3.4. Proposition (Herbrand, 1930). ?; ' `
H
 i ? `
H
'!  .
Proof. The proof from right to left requires one application of modus po-
nens and weakening. For the other direction, proceed by induction on the
size of the proof. ut
Note how easy the proof of ' ! ' becomes with the availability of the
deduction theorem, as compared to having to do the direct proof explicitly.
5.3.5. Proposition. For every ? and ': ? `
N
' i ? `
H
'.
Proof. The right to left part is an easy induction. The converse is also
easy, using the Deduction Theorem. ut
We conclude that our Hilbert-style system is complete in the sense of
both Heyting algebras and Kripke models.
5.3.6. Theorem. ? j= ' i ? `
H
'.
Proof. Immediate from the completeness for natural deduction and the
previous proposition. ut
5.3.7. Remark. By adding axioms to handle the other connectives, one can
obtain complete Hilbert-style proof systems for full propositional intuition-
istic logic and for classical propositional logic. It is perhaps interesting that
a complete proof systems for classical propositional calculus is obtained by
adding only the axiom schemes
 ? ! ';
 (('!  )! ')! '.
5.4. Relevance and linearity 83
(Recall that _ and ^ can be dened in classical logic by ! and ?.)
The following is a version of the Curry-Howard Isomorphism for Hilbert-
style proof systems and combinatory logics. We work with combinatory
terms a la Church.
5.3.8. Proposition.
(i) If ? `
C
F : ' then j?j `
H
'.
(ii) If ? `
H
' then there exists F 2 C such that  `
C
F : ', where
 = f(x
'
: ') j ' 2 ?g.
Proof. (i): by induction on the derivation of ? `
C
M : '.
(ii): by induction on the derivation of ? `
H
'. ut
The Curry-Howard isomorphism in the case of Hilbert-style proofs and
combinatory terms is realized by a correspondence between proofs and and
Church-style combinatory terms. Here we have the following pairs of equiv-
alent notions:
application modus ponens
variable assumption
constants K and S axioms
5.4. Relevance and linearity
Neither intuitionistic nor classical logic have any objections against the ax-
iom scheme ' !  ! ', which expresses the following rule of reasoning:
\an unnecessary assumption can be forgotten". This rule is however du-
bious when we are interested in the relevance of assumptions with respect
to the conclusion. Logicians and philosophers have studied various variants
of intuitionistic logic in which restrictions are made concerning the manip-
ulation of assumptions. The classical references here are [1] and [2], but
the idea of relevant logics dates back to early 50's. Hindley [54] attributes
the idea to Moh and Church. Just like no use of an assumptions may be
regarded as a dubious phenomenon, multiple use of an assumption may also
raise important doubts. The most ancient reference to a logic in which this
was taken into account, given by Hindley [54], is a work of Fitch from 1936.
With the Curry-Howard isomorphism at hand, we can easily identify
the corresponding fragments of (the implicational fragment of) intuitionis-
tic propositional logic, by characterizing lambda-terms with respect to the
number of occurrences of bound variables within their scopes.
84 Chapter 5. Proofs as combinators
5.4.1. Definition.
1. The set of I-terms is dened by the following induction:
 Every variable is a I-term;
 An applicationMN is a I-term i both M and N are I-terms;
 An abstraction x:M is a I-term iM is a I-term and x 2 FV(M).
2. The set of BCK-terms is dened as follows:
 Every variable is a BCK-term;
 An applicationMN is a BCK-term i bothM and N are BCK-
terms, and FV (M) \ FV(N) = fg;
 An abstraction x:M is a BCK-term i M is a BCK-term.
3. A term is called linear i it is both a I-term and a BCK-term.
Of course, I-terms correspond to reasoning where each assumption is used
at least once, but all assumptions are reusable. The BCK-terms represent
the idea of disposable assumptions that are thrown away after a use, so they
cannot be reused. A strict control over all assumptions, with each one being
used exactly once, is maintained in proofs corresponding to linear terms.
The three classes of lambda-terms determine three fragments of IPC(!):
Relevant logic I-terms
BCK-logic BCK-terms
BCI-logic linear terms
The above table can be taken as a formal denition of these three logics,
in that the -calculi simply are the logics. Below we give more traditional
Hilbert-style formulations of the logics.
5.4.2. Definition.
1. The relevant propositional calculus is a Hilbert-style proof system with
the modus ponens as the only rule, and the following axiom schemes:
A
S
) ('!  ! #)! ('!  )! '! #;
A
B
) ( ! #)! ('!  )! '! #;
A
C
) ('!  ! #)!  ! '! #;
A
I
) '! '.
5.4. Relevance and linearity 85
2. The BCK propositional calculus is a Hilbert-style proof system with
the modus ponens as the only rule, and the axiom schemes (A
B
) and
(A
C
) and
A
K
) '!  ! '.
3. The BCI propositional calculus is a Hilbert-style proof system with
the modus ponens as the only rule, and the axiom schemes (A
B
) and
(A
C
) and (A
I
).
5.4.3. Warning. The expression \linear logic" denotes a system which is a
strict extension of the BCI-logic. (But linear logic is based on the same
principle as BCI-logic: every assumption is used exactly once.)
Of course the axioms (A
K
) and (A
S
) are exactly our axioms (A1) and (A2)
of the full IPC(!). The other axioms can also be seen as types of combina-
tors (see Example 5.1.3). We have:
 B = xyz:x(yz) : ( ! #)! ('!  )! '! #;
 C = xyz:xzy : ('!  ! #)!  ! '! #.
Clearly, our three logics correspond to fragments of C generated by the
appropriate choices of combinators. This explains the abbreviations I,
BCK and BCI. The full untyped lambda-calculus is sometimes called K-
calculus.
We have still to justify that the above denitions are equivalent to those
obtained by appropriately restricting occurrences of variables in lambda-
terms. First we have the obvious part (remember that we identify combina-
tory terms with their translations via ( )

).
5.4.4. Lemma.
1. The combinators S, B, C, I are I-terms, and so are all terms obtained
from S, B, C, I by applications;
2. The combinators B, C, K are BCK-terms, and so are all terms ob-
tained from B, C, K by applications;
3. The combinators B, C, I are BCI-terms, and so are all terms obtained
from B, C, I by applications.
Thus, the embedding ( )

translates the appropriate fragments of C into
the appropriate fragments of . But the inverse translation ( )
C
cannot be
used anymore, as it requires S, and K to be available. We need rst to
redene the combinatory abstraction 

.
86 Chapter 5. Proofs as combinators
5.4.5. Definition.
1. For each term in C and each x 2 V we dene the term 

x:M 2 C.
 

x:x = I;
 

x:F = KF , whenever x 62 FV(F );
 

x:FG = S(

x:F )(

x:G), if x 2 FV(F ) \ FV(G);
 

x:FG = C(

x:F )G, if x 2 FV(F ) and x 62 FV(G);
 

x:FG = BF (

x:G), if x 62 FV(F ) and x 2 FV(G).
2. Now dene a translation [ ]
C
: ! C, as follows:
 [x]
C
= x, for x 2 V ;
 [MN ]
C
= [M ]
C
[N ]
C
;
 [x:M ]
C
= 

x:[M ]
C
.
The translation [ ]
C
: ! C has all the good properties of ( )
C
. That is,
Propositions 5.1.10, 5.1.13 and 5.2.4 remain true. (For the proof note rst
that (

x:F )

=

(

x:F )

.) In addition we have:
5.4.6. Proposition.
1. If M is a I-term, then [M ]
C
is built solely from the combinators S,
B, C and I.
2. If M is a BCK-term then [M ]
C
is built solely from the combinators
B, C and K.
3. If M is a linear term then [M ]
C
is built solely from the combinators
B, C and I.
Proof. Easy. Uses the following property: FV ([M ]
C
) = FV(M). ut
It follows that the translation [ ]
C
can be seen as an embedding of each
of the appropriate fragments of C into the corresponding fragment of simply
typed lambda calculus. We can conclude with the following summary:
5.4.7. Theorem.
 A formula ' is a theorem of relevant logic if and only if it is a type of
a I-term;
 A formula ' is a theorem of BCK-logic if and only if it is a type of a
BCK-term.
 A formula ' is a theorem of BCI-logic if and only if it is a type of a
linear term.
Proof. Immediate from Proposition 5.4.6, and the appropriate modica-
tions of Propositions 5.1.13 and 5.2.4. ut
5.5. Historical remarks 87
5.5. Historical remarks
Combinatory logic was introduced by Curry in some early papers [21, 22, 23]
and is also studied at length in some newer books [24, 25], which are still
very readable.
Hilbert-style proofs are often used in text books on logic that are not
concerned with proof normalization in particular, or proof theory in gen-
eral. It is interesting to note that the deduction theorem, which provides
a translation from natural deduction proofs to Hilbert-style proofs, and the
abstraction operator, which provides a translation from typed combinatory
terms to typed -terms, were discovered independently in work on Hilbert
systems and work on combinatory logic, although they are essentially the
same result. This is just one example of a number of results that have been
discovered independently in work on logical systems and functional calculi.
Incidentally, the correspondence between -equality and weak equality
is not as tight as one might hope for. However, if one adds a certain|
somewhat involved|set of rules, called A

, to the rules for weak equality,
the resulting relation is equivalent to -equality in the sense that the above
translations between  and C preserve equality and are each other's inverses.
In particular, the extended equality on combinators is closed under rule ().
The correspondence between -equality and weak equality is more ele-
gant in the extensional versions of these calculi. More precisely, if one adds
the principle of extensionality
P x =

P
0
x & x 62 FV(P P
0
) ) P =

P
0
(ext)

to =

and the similar principle (ext)
w
to weak equality, then the resulting
calculi are equivalent in the above sense.
Adding rule (ext) to =

is equivalent to adding so-called -equality (see
Chapter 6), and adding rule (ext) to =
w
is equivalent to adding a certain
set of equational axioms, called A

. More about all this can be found, e.g.,
in [7].
5.6. Exercises
5.6.1. Exercise. Find a combinator 2 2 C such that 2FA!
w
F (FA), for
all F and A in C.
5.6.2. Exercise. Prove the Church-Rosser property for weak reduction us-
ing the Tait & Martin-Lof method from Chapter 1. Note that the proof for
combinatory logic is somewhat simpler due to the fact that non-overlapping
redexes remain non-overlapping during reduction of other redexes.
5.6.3. Exercise. Prove Proposition 5.1.10.
88 Chapter 5. Proofs as combinators
5.6.4. Exercise. Prove Proposition 5.1.13.
5.6.5. Exercise. Give a Hilbert-style proof of the formula
('!  )! ( ! #)! '! #.
5.6.6. Exercise. Give a detailed proof of the Deduction Theorem. Use your
proof to give an abstraction operator, like 

.
5.6.7. Exercise. Describe a notion of reduction for Hilbert-style proofs,
corresponding to weak reduction on combinatory terms.
5.6.8. Exercise. Consider the following variant of the calculus of combina-
tors: there are typed constants K
;
, and S
;;
, with typing and reduction
rules as usual, and in addition, there are additional constants I

:  ! 
with the reduction rule I

F ! F . (The identity combinator cannot now be
dened as SKK because not all typed forms of S are available.) By em-
bedding into Church-style combinatory logic, show that this variant satises
subject reduction and strong normalization properties.
5.6.9. Exercise. (Based on [16]) Consider the terms : K = xy:x, S

=
ixyz:i(i((x(iz))(i(y(iz))))) and I = x:x. Show that these terms form a
basis for lambda-calculus in the sense of Corollary 5.1.14, but their types
(whatever choice is taken) do not make a complete Hilbert-style axiom sys-
tem for IPC(!).
Hint: One cannot derive the formula (p! p! q)! p! q.
5.6.10. Exercise. Adopt your solutions of Exercises 5.6.1 and 5.6.3 to the
case of the translation [ ]
C
of Section 5.4.
CHAPTER 6
Type-checking and related problems
In this chapter we discuss some decision problems related to simply-typed
lambda calculus and intuitionistic propositional logic. We are mostly inter-
ested in decision problems arising from the analysis of the ternary predicate
\? ` M : " in the Curry-style version of simply-typed lambda calculus.
But the following denition makes sense for every type-assignment system
deriving judgements of this form (including Church-style systems).
6.0.11. Definition.
1. The type checking problem is to decide whether ? ` M :  holds, for
a given context ?, a term M and a type  .
2. The type reconstruction problem, also called typability problem, is to
decide, for a given term M , whether there exist a context ? and a
type  , such that ? `M :  holds, i.e., whether M is typable.
3. The type inhabitation problem, also called type emptiness problem, is
to decide, for a given type  , whether there exists a closed term M ,
such that ` M :  holds. (Then we say that  is non-empty and has
an inhabitant M).
An obvious motivation to consider type-checking and type reconstruction
problems comes of course from programming language design, especially
related to the language ML, see [72, 27]. But there were earlier results
concerning this problem, due to Curry, Morris and Hindley. See [54, pp.
33{34], for historical notes.
If we look at the type reconstruction problem from the point of view
of the Curry-Howard isomorphism, it becomes a problem of determining
whether a given \proof skeleton" can be actually turned into a correct proof
by inserting the missing formulas. It may be surprising that this kind of
questions are sometimes motivated by proof-theoretic research. As noted
89
90 Chapter 6. Type-checking and related problems
in [54, pp. 103{104], the main ideas of a type-reconstruction algorithm can
be traced as far as the 20's.
1
See [114], for a fresh work, where the \skeleton
instantiation" problem is discussed, without any relation to types.
For the type inhabitation problem, the Curry-Howard isomorphism gives
an immediate translation into the language of logic:
6.0.12. Proposition. The type inhabitation problem for the simply-typed
lambda calculus is recursively equivalent to the validity problem in the im-
plicational fragment of intuitionistic propositional logic.
Proof. Obvious. ut
The above proposition remains true for other typed languages, for which the
Curry-Howard isomorphism makes sense.
From a programmer's point of view, the type inhabitation problem can
be seen as follows: An empty type (a type which cannot be assigned to any
term) means a specication that cannot be fullled by any program phrase.
Solving type inhabitation means (in the contexts of modular programming)
the ability to rule out such specications at compile time.
6.1. Hard and complete
This short section is to recall a few basic notions from complexity theory.
The reader is referred to standard textbooks, like [57], for a more compre-
hensive discussion.
6.1.1. Definition. The notation LOGSPACE, PSPACE and P, refers re-
spectively to the classes of languages (decision problems) solvable by de-
terministic Turing Machines in logarithmic space, polynomial space, and
polynomial time (measured w.r.t. the input size).
6.1.2. Definition. We say that a language L
1
is reducible to a language L
2
in logarithmic space (or LOGSPACE-reducible) i there is a TuringMachine,
that works in logarithmic space (we count only the work tapes, not the input
or output tapes) and computes a total function f , such that
w 2 L
1
i f(w) 2 L
2
;
for all inputs w. Two languages are LOGSPACE-equivalent i there are
LOGSPACE-reductions each way.
That is, to decide if w 2 L
1
one can ask if f(w) 2 L
2
, and the cost of the
translation is only shipping and handling. Note that a logarithmic space
reduction takes at most polynomial time, so this notion is slightly more
general than that of a polynomial time reduction.
1
The good old Polish school again : : :
6.2. The 12 variants 91
6.1.3. Definition. We say that a language L is hard for a complexity class
C, i every language L
0
2 C is reducible to L in logarithmic space. If we
have L 2 C in addition, then we say that L is complete in the class C, or
simply C-complete.
6.2. The 12 variants
The type reconstruction problem is often abbreviated by \? `M : ?", and
the type inhabitation problem is written as \ `M : ?". This notation nat-
urally suggests other related problems, as one can choose to replace various
parts of our ternary predicate by question marks, and choose the context
to be empty or not. A little combinatorics shows that we have actually 12
problems. Out of these 12 problems, four are completely trivial, since the
answer is always \yes":
 ? ` ? : ?;
 ? ` ? : ?;
 ` ? : ?;
 ? ` ? :  .
Thus we end up with eight non-trivial problems, as follows:
1) ? `M :  (type checking);
2) `M :  (type checking for closed terms);
3) ? `M :  (type checking without context);
4) ? `M : ? (type reconstruction);
5) `M : ? (type reconstruction for closed terms);
6) ? `M : ? (type reconstruction in a context);
7) ` ? :  (inhabitation);
8) ? ` ? :  (inhabitation in a context).
Most of these problems can easily be shown LOGSPACE-equivalent to one
of our three main problems: (1), (4) or (7). Some of these LOGSPACE
reductions are just inclusions. Indeed, problem (2) is a special case of (1)
and of (3), problem (5) is a special case of (4) and (6), and problem (7) is
a special case of (8). Others are the subject of Exercises 6.8.1 and 6.8.3.
An exception is problem (3). Problems (1), (2) and (4){(6) reduce to (3) in
logarithmic space, but we do not know of any simple LOGSPACE reduction
92 Chapter 6. Type-checking and related problems
the other way.
2
However, such reductions exists between all problems (1){
(6), because all they turn out to be P-complete.
Let us make one more remark here: On a rst look it might seem that
determining whether a given term has a given type in a given environment
could be easier than determining whether it has any type at all. This impres-
sion however is generally wrong, as type reconstruction is easily reducible to
type checking, see Exercise 6.8.1. This reduction is \generic", i.e., it works
for all reasonable typed calculi.
It is quite unlikely to have a reduction from (7) or (8) to any of (1){(6),
because the inhabitation problems are PSPACE-complete, and that would
imply P = PSPACE. We do not know about a simple reduction the other
way.
6.3. (First-order) unication
The following is a general denition of (rst-order) unication. In what
follows we will need only a special case, where the rst-order signature is
xed to consist of only one symbol: the binary function symbol \!".
6.3.1. Definition.
1. A rst-order signature is a nite family of function, relation and con-
stant symbols. Each function and relation symbol comes with a des-
ignated non-zero arity. (Constants are sometimes treated as zero-ary
functions.) In this section we consider only algebraic signatures, i.e.,
signatures without relation symbols.
2. An algebraic term over a signature , or just term is either a variable
or a constant in , or an expression of the form (ft
1
: : : t
n
), where f is
an n-ary function symbol, and t
1
; : : : ; t
n
are algebraic terms over .
3
We usually omit outermost parentheses.
The formal denition of an algebraic term involves a prex application of
function symbols. Of course, there is a tradition to write some binary func-
tion symbols in the inx style, and we normally do it this way. Our most
beloved signature is one that has the (inx) arrow as the only symbol. It is
not dicult to see that algebraic terms over this signature can be identied
with simple types, or with implicational formulas if you prefer.
In general, algebraic terms over  can be identied with nite labelled
trees satisfying the following conditions:
 Leaves are labelled by variables and constant symbols;
2
A solution was given by Henning Makholm, see Chapter 14, Exercise 6.8.3.
3
Do not confuse algebraic terms with lambda-terms.
6.3. (First-order) unication 93
 Internal nodes with n daughters are labelled by n-ary function sym-
bols.
6.3.2. Definition.
1. An equation is a pair of terms, written \t = u". A system of equations
is a nite set of equations. Variables occurring in a system of equations
are called unknowns.
2. A substitution is a function from variables to terms which is the iden-
tity almost everywhere. Such a function S is extended to a function
from terms to terms by S(ft
1
: : : t
n
) = fS(t
1
)   S(t
n
) and S(c) = c.
4
3. A substitution S is a solution of an equation \t = u" i S(t) = S(u)
(meaning that S(t) and S(u) is the same term). It is a solution of a
system E of equations i it is a solution of all equations in E.
Thus, for instance, the equation f(gxy)x = fz(fyy) has a solution S with
S(x) = fyy, S(y) = y and S(z) = g(fyy)y (and many other solutions
too), while the equation f(gxy)c = fz(fyy), where c is a constant, has no
solution. This is because no substitution can turn fyy into c. Another
example with no solution is f(gxy)x = fx(fyy), but this time the reason is
dierent: if S were a solution then S(x) would be a proper subterm of itself.
The problem of determining whether a given system of equations has a
solution is called the unication problem. It is not dicult to see that there
is no loss of generality in considering single equations rather than systems of
equations (Exercise 6.8.5). The unication algorithm (we say \the", because
all these algorithms are actually based on similar ideas, and dier only in
details) is due to J.A. Robinson [93], and was motivated by the rst-order
resolution rule. But, as pointed out by Hindley [54, pp. 43{44], there were
also earlier works. Discussions of unication algorithms can be found in
various textbooks, for instance in [74].
We choose to sketch a version of the algorithm that is \algebraic" in
style. For this, we need the folllowing denition.
6.3.3. Definition.
1. A system of equations is in a solved form i it has the following prop-
erties:
 All equations are of the form \x = t", where x is a variable;
 A variable that occurs at a left-hand side of an equation does not
occur at the right-hand side of any equation;
 A variable may occur in only one left-hand side.
4
Thus, a substitution is a valuation in the algebra of all terms over .
94 Chapter 6. Type-checking and related problems
A variable not occurring as a left-hand side of any equation is called
undened .
2. A system of equations is inconsistent i it contains an equation of
either of the forms:
 \gu
1
: : : u
p
= ft
1
: : : t
q
", where f and g are two dierent function
symbols;
 \c = ft
1
: : : t
q
", or \ft
1
: : : t
q
= c", where c is a constant symbol
and f is an n-ary function symbol;
 \c = d", where c and d are two dierent constant symbols;
 \x = ft
1
: : : t
q
", where x is a variable, f is an n-ary function
symbol, and x occurs in one of t
1
; : : : ; t
q
.
3. Two systems of equations are equivalent i they have the same solu-
tions.
It is easy to see that an inconsistent system has no solutions and that a
solved system E has a solution S
0
dened as follows:
 If a variable x is undened then S
0
(x) = x;
 If \x = t" is in E, then S
0
(x) = t.
The core of Robinson's algorithm can be seen as follows:
6.3.4. Lemma. For every system E of equations, there is an equivalent sys-
tem E
0
which is either inconsistent or in a solved form. In addition, the
system E
0
can be obtained by performing a nite number of the following
operations:
a) Replace \x = t" and \x = s" (where t is not a variable) by \x = t"
and \t = s";
b) Replace \t = x" by \x = t";
c) Replace \ft
1
: : : t
n
= fu
1
: : : u
n
" by \t
1
= u
1
", : : : , \t
n
= u
n
";
d) Replace \x = t" and \r = s" by \x = t" and \r[x := t] = s[x := t]";
e) Remove an equation of the form \t = t".
Proof. As long as our system is not solved, and not inconsistent, we can
always apply one of the operations (a){(d). We leave it as Exercise 6.8.8
to show that this process terminates (unless (b) or (d) is used in a silly
way). ut
6.4. Type reconstruction algorithm 95
6.3.5. Corollary. The unication problem is decidable. ut
In fact, the above algorithm can be optimized to work in polynomial time
(Exercise 6.8.10), provided we only need to check whether a solution exists,
and we do not need to write it down explicitly, cf. Exercise 6.8.6. The
following result is from Dwork et al [33].
6.3.6. Theorem. The unication problem is P-complete with respect to Log-
space reductions. ut
Suppose that we have a system of equations E, which is transformed to an
equivalent solved system E
0
. The solution S
0
of E
0
dened as above, is a
most general solution of E
0
and E, because every other solution must be a
specialization of S
0
. Formally we have the following denition.
6.3.7. Definition.
 If P and R are substitutions then P  R is a substitution dened by
(P  R)(x) = P (R(x)).
 We say that a substitution S is an instance of another substitution R
(written R  S) i S = P  R, for some substitution P .
 A solution R of a system E is principal i the following equivalence
holds for all substitutions S:
S is a solution of E i R  S:
6.3.8. Proposition. If a system of equations has a solution then it has a
principal one.
Proof. For a given system of equations E, let E
0
be an equivalent system
in a solved form, and let S
0
be as described above. Then S
0
is a principal
solution of E. ut
6.4. Type reconstruction algorithm
We now show how type-reconstruction can be reduced to unication. This
is a LOGSPACE-reduction, and it can easily be modied to work for all the
problems (1){(6) of Section 6.2. Since there is also a LOGSPACE-reduction
the other way, the main result of this section may be stated as:
6.4.1. Theorem. Type-reconstruction in simply-typed lambda calculus is P-
complete.
96 Chapter 6. Type-checking and related problems
The rst work where this result was explicitly stated was probably the M.Sc.
Thesis of Jurek Tyszkiewicz [110]. Our proof of the theorem consists of two
reductions. The rst one is from type-reconstruction to unication.
Let M be a lambda-term. Choose a representative of M so that no
bound variable occurs free in M and no bound variable is bound twice. In
what follows we work with this representative rather than with M as an
equivalence class. By induction on the construction of M , we dene:
 a system of equations E
M
(over the signature consisting only of the
binary function symbol !);
 a type 
M
.
Of course, the idea is as follows: E
M
will have a solution i M is typable,
and 
M
is (informally) a pattern of a type for M .
6.4.2. Definition.
 If M is a variable x, then E
M
= fg and 
M
= 
x
, where 
x
is a fresh
type variable.
 If M is an application PQ then 
M
= , where  is a fresh type
variable, and E
M
= E
P
[E
Q
[ f
P
= 
Q
! g.
 If M is an abstraction x:P , then E
M
= E
P
and 
M
= 
x
! 
P
.
It is not dicult to see that the above construction can be done in logarith-
mic space. The main property of our translation is as follows.
6.4.3. Lemma.
1. If ? ` M : , then there exists a solution S of E
M
, such that  =
S(
M
) and S(
x
) = ?(x), for all variables x 2 FV (M).
2. Let S be a solution of E
M
, and let ? be such that ?(x) = S(
x
), for
all x 2 FV (M). Then ? `M : S(
M
).
Proof. Induction with respect to M . ut
It follows that M is typable i E
M
has a solution. But E
M
has then a
principal solution, and this has the folllowing consequence. (Here, S(?) is a
context such that S(?)(x) = S(?(x)).)
6.4.4. Definition. A pair (?; ), consisting of a context (such that the do-
main of ? is FV (M)) and a type, is called the principal pair for a term M
i the following holds:
6.5. Eta-reductions 97
 ? `M :  ;
 If ?
0
`M : 
0
then ?
0
 S(?) and 
0
= S(), for some substitution S.
(Note that the rst condition implies S(?) ` M : S(), for all S.) If M is
closed (in which case ? is empty), we say that  is the principal type of M .
6.4.5. Corollary. If a term M is typable, then there exists a principal pair
for M . This principal pair is unique up to renaming of type variables.
Proof. Immediate from Proposition 6.3.8. ut
6.4.6. Example.
 The principal type of S is ( !  ! ) ! ( ! ) !  ! . The
type ( !  ! ) ! ( ! ) !  !  can also be assigned to S,
but it is not principal.
 The principal type of all the Church numerals is ( ! ) !  ! .
But the type (( ! ) !  ! ) ! ( ! ) !  !  can also be
assigned to each numeral.
To complete the proof of Theorem 6.4.1, we should also give the other re-
duction. We only give a brief hint of how this should be done. First we
reduce the general case of unication to our special arrow-only case (Exer-
cise 6.8.7) and one equation only (Exercise 6.8.5). Then, for a given equation
\ = ", we consider the term xy:x(yt

)(yt

), where x; y are new variables
and terms t

and t

are as in Exercise 6.8.2.
6.5. Eta-reductions
We cannot hide this from the reader any more|we nally have to con-
fess that other notions of reduction than beta-reduction are considered in
lambda-calculi. In particular, we have eta-reduction, based on the following
principle:
x:Mx!

M; whenever x 62 FV (M):
Formally, we have the following denition:
6.5.1. Definition. We dene the relation!

as the least relation satisfying
 If x 62 FV (M) then x:Mx!

M ;
 If P !

P
0
then x:P !

x:P
0
;
 If P !

P
0
then PQ!

P
0
Q and QP !

QP
0
.
The notation!

and =

has the expected meaning. We also use the symbols
!

, !

, =

to refer to reductions combining - and -reductions.
98 Chapter 6. Type-checking and related problems
The motivation for this notion of reduction (and equality) is as follows: Two
functions should be considered equal if and only if they return equal results
for equal arguments. Indeed, we have
6.5.2. Proposition. Let =
ext
be the least equivalence relation such that:
 If M =

N then M =
ext
N ;
 If Mx =
ext
Nx, and x 62 FV (M) [ FV (M) then M =
ext
N ;
 If P =
ext
P
0
then PQ =
ext
P
0
Q and QP =
ext
QP
0
.
Then =
ext
is identical to =

.
Proof. Exercise 6.8.15. Note that the above denition does not contain
the condition \If P =
ext
P
0
then x:P =
ext
x:P
0
". This is not a mistake,
because this property (called \rule ") follows from the others. ut
We do not take !

as our standard notion of reduction, because we do
not want our calculus of functions to be extensional. After all, we want to
be able to distinguish between two algorithms, even if their input-output
behaviour is the same.
The notions of eta- and beta-eta-reduction and equality have most of the
good properties of beta-reduction and equality. In particular, the Church-
Rosser theorem remains true, leftmost reductions are normalizing,
5
and on
the typed level we still have both subject reduction and strong normalization
properties. (Note that strong normalization for eta alone is immediate,
as each eta-reduction step reduces the length of a term.) Of course, eta-
reduction makes sense also for the Church-style typed terms.
6.5.3. Definition. We now dene the notion of a Church-style term in an
-long normal form (or just long normal form). Recall that we write M

as an informal way of saying that the Church-style term M has type  in
some xed context. The denition is by induction:
 If x is a variable of type 
1
!    ! 
n
! , and M

1
1
; : : : ;M

n
n
are
in -long normal form, then (xM
1
: : :M
n
)

is in -long normal form.
 IfM

is in -long normal form then (x : :M)
!
is in -long normal
form.
Thus a term in a long normal form is a term in normal form where all
function variables are \fully applied" to arguments.
6.5.4. Lemma. For every Church-style term M

in beta normal form there
exists a term M

1
in -long normal form, such that M

1
!

M .
Proof. Easy. ut
5
But the proof is somewhat more involved than for beta-reduction.
6.6. Type inhabitation 99
6.6. Type inhabitation
In this section we prove a result of Statman [103], that the inhabitation
problem for the nitely-typed lambda calculus is PSPACE-complete. In
particular it is decidable. An immediate consequence is that provability
in IPC(!) is also decidable and PSPACE-complete. The decidability was
already known to to Gentzen in 1935, and we will discuss his (syntactic)
proof in the next chapter. There are also semantic methods based on the
existence of nite models.
First observe that a type is inhabited if and only if there exists a closed
Church-style term of that type. Thus it suces to consider Church-style
terms. First we prove that our problem is in PSPACE.
6.6.1. Lemma. There is an alternating polynomial time algorithm (and thus
also a deterministic polynomial space algorithm) to determine whether a
given type  is inhabited in a given context ?.
Proof. If a type is inhabited then, by Lemma 6.5.4, it is inhabited by a
term in a long normal form. To determine whether there exists a term M
in a long normal form, satisfying ? `M :  , we proceed as follows:
 If  = 
1
! 
2
, then M must be an abstraction, M = x:
1
:M
0
. Thus,
we look for an M
0
satisfying ?; x:
1
`M
0
: 
2
.
 If  is a type variable, then M is an application of a variable to a
sequence of terms. We nondeterministically choose a variable z, de-
clared in ? to be of type 
1
!    ! 
n
!  . (If there is no such
variable, we reject.) If n = 0 then we accept. If n > 0, we answer in
parallel the questions if 
i
are inhabited in ?.
This alternating (or recursive) procedure is repeated as long as there are
new questions of the form ? ` ? :  . Note that if there are two variables
in ?, say x and y, declared to be of the same type , then each term M
can be replaced with M [x=y] with no change of type. This means that a
type  is inhabited in ? i it is inhabited in ? ? fy : g, and it suces to
consider contexts with all declared types being dierent. At each step of
our procedure, the context ? either stays the same or it expands. Thus the
number of steps (depth of recursion) does not exceed the squared number of
subformulas of types in ?;  , where ? ` ? :  is the initially posed question.
ut
To show PSPACE-hardness, we dene a reduction from the satisability
problem for classical second-order propositional formulas (QBF). We refer
the reader to [57] for details about this problem. (But do not use the Polish
translation.)
100 Chapter 6. Type-checking and related problems
Assume that a second-order propositional formula  is given. Without
loss of generality we may assume that the negation symbol : does not occur
in , except in the context :p, where p is a propositional variable.
Assume that all bound variables of  are dierent and that no variable
occurs both free and bound. For each propositional variable p, occurring
in  (free or bound), let 
p
and 
:p
be fresh type variables. Also, for each
subformula ' of , let 
'
be a fresh type variable. We construct a basis ?

from the following types:
 (
p
! 
 
) ! (
:p
! 
 
) ! 
'
, for each subformula ' of the
form 8p ;
 (
p
! 
 
)! 
'
and (
:p
! 
 
)! 
'
, for each subformula ' of the
form 9p ;
 
 
! 
#
! 
'
, for each subformula ' of the form  ^ #;
 
 
! 
'
and 
#
! 
'
, for each subformula ' of the form  _ #.
If v is a zero-one valuation of propositional variables, then ?
v
is ? extended
with the type variables
 
p
, when v(p) = 1;
 
:p
, when v(p) = 0.
The following lemma is proven by a routine induction w.r.t. the length of
formulas. Details are left to the reader.
6.6.2. Lemma. For every subformula ' of , and every valuation v, dened
on the free variables of ', the type 
'
is inhabited in ?
v
i v(') = 1.
Proof. Exercise 6.8.18. ut
From Lemma 6.6.2 we obtain PSPACE-hardness, since the reduction can be
performed in logarithmic space. This, together with Lemma 6.6.1 implies
the main result of this section.
6.6.3. Theorem. The inhabitation problem for simply-typed lambda-calculus
is complete for polynomial space. ut
6.7. Equality of typed terms 101
6.7. Equality of typed terms
As we have already observed, to verify whether two typable lambda-terms
are beta-equal or not, it suces to reduce them to normal form. One thing
that often is overlooked here is that the complexity of this decision procedure
depends on the size of particular type derivations (or Church-style terms)
and not directly on the size of the pure lambda-terms to be veried. In the
case of simply-typed lambda calculus, the cost of type-reconstruction is is a
minor fraction of the total cost, even if we insist on the possibly exponential
types to be written down. Indeed, we have the following theorem of Statman:
6.7.1. Theorem (R. Statman). The problem to decide whether two given
Church-style terms M and N of a given type  are beta-equal is of non-
elementary complexity. That is, for each r, the decision procedure takes
more than exp
r
(n) steps on inputs of size n. (Recall that exp
0
(n) = n and
exp
k+1
(n) = 2
exp
k
(n)
:)
The simplest known proof of this result is by H. Mairson [68]. This proof,
like the original proof of Statman, uses validity for a simple higher-order
logic as an intermediate step. It might be interesting to have a direct coding
of Turing Machines into lambda-terms.
6.8. Exercises
6.8.1. Exercise. Show that:
a) problem (4) reduces to problem (5);
b) problem (5) reduces to problem (1);
c) problem (1) reduces to problem (2);
d) problem (8) reduces to problem (7)
in logarithmic space.
6.8.2. Exercise. Assume a context ? consisting of type assumptions of the
form (x

: ). Dene terms t

such that ? ` t

:  holds if and only if
 = .
6.8.3. Exercise. Show that problem (6) reduces to problem (4) in logarith-
mic space. Hint: rst do Exercise 6.8.2.
6.8.4. Exercise. What's wrong with the following reduction of problem (3)
to problem (4)? To answer ? `M :  ask ? ` yz:y(zM)(zt

) : ?.
102 Chapter 6. Type-checking and related problems
6.8.5. Exercise. Show that for every system of equations there is an equiv-
alent single equation.
6.8.6. Exercise. Show that the size of a shortest possible solution of a
given system of equations may be exponential in the size of that system.
(Construct systems of equations of size O(n), such that all their solutions
are of size at least exponential in n.) Can a solution be always represented
in polynomial space?
6.8.7. Exercise. Prove that the general form of the unication problem
reduces in logarithmic space to unication over the signature consisting only
of an arrow.
6.8.8. Exercise. Complete the proof of Lemma 6.3.4.
6.8.9. Exercise. Show examples of loops in the unication algorithm that
may be caused by using rule (d) in a silly way, or removing the restriction
in rule (a) that t is not a variable.
6.8.10. Exercise. Design a polynomial time algorithm to decide whether a
given equation has a solution.
6.8.11. Exercise. Modify the algorithm of Section 6.4 to obtain an algo-
rithm for problem (3).
6.8.12. Exercise. Prove the following converse principal type theorem: If
' is a non-empty type, then there exists a closed term M such that ' is the
principal type of M . Hint: Use the technique of Exercise 6.8.2. (In fact, if
N is a closed term of type  , then we can require M to be beta-reducible
to N .)
6.8.13. Exercise. Show that every principal pair of a BCK-term in normal
form has the following properties:
 Each type variable occurs at most twice;
 If it does, then one occurrence is positive (to the left of an even number
of arrows) and the other negative.
Also show that if (?; ) is a principal pair of a BCK-term M in normal form
then M is an erasure of a Church style term in long normal form that has
the type  in ?.
6.8.14. Exercise. (S. Hirokawa [56])
Prove that for a given pair (?; ), there is at most one BCK-term M in
normal form such that (?; ) is its principal pair.
6.8. Exercises 103
6.8.15. Exercise. Prove Proposition 6.5.2.
6.8.16. Exercise. What is the natural deduction counterpart of eta-reduction?
6.8.17. Exercise. Show examples of types that have exactly n normal in-
habitants, for any number n 2 N [ f@
0
g.
6.8.18. Exercise. Prove Lemma 6.6.2
6.8.19. Exercise. (C.-B. Ben-Yelles)
Show that it is decidable whether a type has a nite or an innite number
of dierent normal inhabitants.
6.8.20. Exercise. Let ' = 
1
!    ! 
n
!  and let  be the only type
variable occurring in '. Prove (by induction) that ' is an inhabited type if
and only if at least one of the 
i
's is not inhabited.
6.8.21. Exercise. (R. Statman)
Let p be the only propositional variable, and let ! be the only connective
occurring in a classical propositional tautology '. Show that ' is intuition-
istically valid. Hint: First do Exercise 6.8.20.
6.8.22. Exercise. (T. Prucnal, W. Dekkers [30]) A proof rule of the form

1
; : : : ; 
n

is sound for IPC(!) i for every substitution S with S(
1
); : : : S(
n
) all
valid, also S() must be valid. Prove that if such a rule is sound then the
implication 
1
!    ! 
n
!  is valid.
104 Chapter 6. Type-checking and related problems
CHAPTER 7
Sequent calculus
We have seen two dierent formalisms for presenting systems of formal logic:
natural deduction and Hilbert-style. Each of these has its advantages. For
instance, in Hilbert-style proofs, there are no problems pertaining to the
management of assumptions, whereas in natural deduction, the proofs are
easier to discover, informally speaking.
As we have seen earlier, both classical and intuitionistic propositional
calculus are decidable; that is, there is an algorithm which decides, for any ',
whether or not ' is classically valid (according to the truth table semantics),
and similarly, there is an algorithm which decides, for any ', whether or not
' is intuitionistically valid (according to the Heyting algebra semantics or
Kripke models). By the soundness and completeness results, this result
means that there are algorithms that decide, for any ', whether or not '
is provable in our proof systems for classical and intuitionistic propositional
calculus, respectively.
This result suggests that we should be able to develop decision algorithms
that do not make an excursion via semantics; that is, we should be able to
read the inference rules bottom-up and turn this reading into algorithms
that decide whether formulas have proofs in the systems.
Anyone who has tried at least once to write down an actual Hilbert-style
proof for even a simple formula will understand why this approach is not
satisfactory in practice. If we want to prove a formula  , using the modus
ponens rule
'; '!  
 
the formula ' has to be somehow chosen or guessed. And there is no bound
for the space we make this choice from: the formula ' can be anything at
all. Any approach to automatic theorem proving based on this rule seems
doomed to failure.
The same problem appears in natural deduction proofs, since we also
have the modus ponens rule there. (In addition, we have another unpleasant
105
106 Chapter 7. Sequent calculus
property in the Hilbert-style system: formulas occurring in proofs are very
long, so even if we know what to choose, such proofs are still inconvenient.)
In this chapter we introduce a third kind of formalism, known as sequent
calculus, for presenting systems of formal logic. Sequent calculus was intro-
duced in the 1930's, by Gerhard Gentzen [39], who also introduced natural
deduction.
1
Despite similar syntax, sequent calculus and natural deduction are quite
dierent and serve dierent purposes. While natural deduction highlights
the most fundamental properties of connectives by its introduction and elim-
ination rule for each connective, sequent calculus is more \practically" ori-
ented: if one reads the rules of sequent calculus from bottom to top, the rules
simplify the process of proof construction. Instead of introduction and elimi-
nation rules, there are only introduction rules. Some of these rules introduce
connectives in the conclusion parts of judgements|in fact, these rules are
identical to the introduction rules from natural deduction. But there are
also rules introducing connectives in the assumption parts of judgements.
These rules replace the elimination rules of natural deduction.
The development of sequent calculus systems has been successful not
only for theoretical purposes: many practical approaches to automated the-
orem proving are based on some form of sequent calculi or their relatives.
In particular, the resolution rule can be seen as such a relative.
7.1. Classical sequent calculus
Although we are now mostly concerned with intuitionistic proof systems, we
introduce a classical version of sequent calculus rst. Intuitionistic sequent
calculus is obtained from the classical one by a restriction which sheds some
light on the relationship between these two equally fundamental logics.
As mentioned below, many variations on the denition of sequent calcu-
lus systems are possible; we use the systems studied by Prawitz [85, App. A],
since these minimize the noise in the relationship with natural deduction.
A number of variants can be found in, e.g., [109] and [38].
7.1.1. Definition. A (classical) sequent is a pair of sets of formulas, written
? ` , where the right-hand side is not empty.
2
A proof in the sequent
calculus is a tree labelled with sequents in such a way that mothers and
daughters match the proof rules below.
We write ? `
+
LC
 i ? `  has a proof, and we write ? `
LC
 i ? ` 
has a proof which does not use the rule Cut .
1
Stanis law Jaskowski independently introduced natural deduction systems|see
Prawitz' book [85], where more information about the origins of natural deduction and
sequent calculus systems can be found.
2
Sequents with empty right-hand sides are permitted in many presentations. The
meaning of an empty right-hand side is the same as of a right-hand side consisting only
of ?, so our restriction is not essential.
7.1. Classical sequent calculus 107
We use similar conventions as in the case of natural deduction. For
instance, we write ?; for ? [, and ' for f'g.
Axiom:
?; ' ` ';
Rules:
?; ' ` 
?; ' ^  ` 
(L^)
?;  ` 
?; ' ^  ` 
? ` '; ? `  ;
? ` ' ^  ;
(R^)
?; ' `  ?;  ` 
?; ' _  ` 
(L_)
? ` ';
? ` ' _  ;
(R_)
? `  ;
? ` ' _  ;
? ` '; ?;  ` 
?; '!  `  [ 
(L!)
?; ' `  ;
? ` '!  ;
(R!)
?;? ` 
(L?)
? ` '; ?; ' ` 
? `  [ 
(Cut)
The rule (L?) has no premise and may be regarded as an axiom. The
remaining rules, except the cut rule, are called logical rules since they dene
the meaning of the logical connectives ^, _, and!. The logical rules consists
of left and right introduction rules for every connective. The right rules are
identical to the introduction rules from natural deduction; the left rules will
play the role of the elimination rules from natural deduction.
The cut rule is the only one that is neither a left nor a right rule. The
formula ' in the cut rule is called the cut formula. One can recognize a
similarity between cut and modus ponens.
The intuitive meaning of ? `  is that the assumptions in ? imply one
of the conclusions in , i.e., that '
1
^ : : :^'
n
implies  
1
_ : : : _ 
m
, where
? = f'
1
; : : : ; '
n
g and  = f 
1
; : : : ;  
m
g. The rules for conjunction and
disjunction clearly reect this idea.
108 Chapter 7. Sequent calculus
7.1.2. Remark. In order to facilitate comparison with natural deduction
we have taken ? as primitive|as we have seen earlier, negation can then
be dened by :' = ' ! ?. One often nds in the literature : taken as
primitive instead. In this case, the rule (L?) is replaced by the two rules
? ` ; '
?;:' ` 
(L:)
?; ' ` 
? ` :';
(R:)
which are derived rules in the above system.
7.1.3. Warning. In many presentations of sequent calculus, sequents are
pairs of sequences (with possible repetitions) rather than sets. In such sys-
tems one must in addition to the axiom, the cut rule, and the logical rules,
adopt so-called structural rules, namely weakening rules that allow addition
of formulas to the left and right of `, contraction rules that allow contraction
of two identical formulas into one on the left and right of `, and exchange
rules that allow changing the order of two consecutive formulas on the left
or on the right of `. In this case one takes the axiom in the form ' ` '.
Such a system occurs, e.g., in [46].
One may also use multi-sets instead of sets and sequences. In this case,
the exchange rules are not needed.
7.1.4. Remark. It is not dicult to see that in the presence of weakening,
the rules (Cut) and (L!) could as well be written as follows:
? ` '; ?; ' ` 
? ` 
(Cut)
? ` '; ?;  ` 
?; '!  ` 
(L!)
We prefer the other presentation of these rules for uniformity with the intu-
itionistic fragment, to be dened in the next section.
The following shows that sequent calculus is complete with respect to
the ordinary semantics of classical logic.
7.1.5. Proposition. If  = f'
1
; : : : '
n
g then we have ? `
+
LC
 if and only
if the entailment ? j= '
1
_  _'
n
is classically valid.
3
In particular, `
+
LC

i '
1
_    _ '
n
is a classical tautology.
The proof is omitted. Gentzen [39] proved the completeness of the se-
quent calculus system by proving that the system is equivalent to another
logical system. For the purposes of that proof, the cut rule is very conve-
nient. Gentzen's Hauptsatz then states that the cut rule is a derived rule,
and hence the cut rule is in fact not necessary for completeness; that is,
every application of the cut rule can be eliminated from a given proof. This
results is also known as the Cut Elimination Theorem. We shall have more
to say about this result in the context of intuitionistic logic below.
3
That is, i each valuation satisfying all the formulas in ? must also satisfy '
1
_  _'
n
.
7.2. Intuitionistic sequent calculus 109
7.1.6. Example. Here is a sequent calculus proof of Peirce's law:
(R!)
(L!)
(R!)
p ` p; q
` p; p! q
p ` p
(p! q)! p ` p
` ((p! q)! p)! p
Note that we sometimes have two formulas at the right-hand side.
7.1.7. Example. And here is another example that uses only sequents with
one-element right-hand sides:
(L!)
p; p! q ` p
(L!)
p ` p p; q ` q
p; p! q ` q
p; p! q; r ` r
p; p! q; q ! r ` r
(L!)
(R!)
p; p! q; p! q ! r ` r
(R!)
p! q; p! q ! r ` p! r
(R!)
p! q ! r ` (p! q)! p! r
` (p! q ! r)! (p! q)! p! r
7.2. Intuitionistic sequent calculus
The intuitionistic sequent calculus is obtained from the classical system by
a simple syntactic restriction. We just require that only one formula occurs
at the right-hand side of a sequent. That is, the above classical rules are
modied so that
  has always exactly one element;
  is always empty.
7.2.1. Definition. An intuitionistic sequent is one of the form ? ` ',
where ' is a single formula. We write ? `
+
L
' i ? ` ' has a sequent
calculus proof using only intuitionistic sequents, i.e., using only the below
rules. We write ? `
L
' if there is such a proof that does not use the rule Cut .
110 Chapter 7. Sequent calculus
Axiom:
?; ' ` '
Rules:
?; ' ` 
?; ' ^  ` 
(L^)
?;  ` 
?; ' ^  ` 
? ` ' ? `  
? ` ' ^  
(R^)
?; ' `  ?;  ` 
?; ' _  ` 
(L_)
? ` '
? ` ' _  
(R_)
? `  
? ` ' _  
? ` ' ?;  ` 
?; '!  ` 
(L!)
?; ' `  
? ` '!  
(R!)
?;? ` 
(L?)
? ` ' ?; ' ` 
? ` 
(Cut)
The following shows that intuitionistic natural deduction and intuition-
istic sequent calculus are equivalent.
7.2.2. Proposition. ? `
+
L
' i ? `
N
'.
Proof. We prove each direction by induction on the derivation of the se-
quent.
For the left-to-right direction, the main problem is how to express the
left rules of sequent calculus in terms of the elimination rules of natural
deduction, and how to express the cut rule in terms of modus ponens.
1. The derivation of ? `
+
L
' is
?
0
; ' ` '
Then
?
0
; ' ` '
is also a derivation of ? `
N
'.
7.2. Intuitionistic sequent calculus 111
2. The derivation of ? `
+
L
' ends in
?
0
;  
1
` '
?
0
;  
1
^  
2
` '
By the induction hypothesis we have a natural deduction derivation of
?
0
;  
1
` '. By Lemma 2.6, ?
0
;  
1
^ 
2
;  
1
` ', so ?
0
;  
1
^ 
2
`  
1
! '.
Since also ?
0
;  
1
^  
2
`  
1
^  
2
, and hence ?
0
;  
1
^  
2
`  
1
, we get
?
0
;  
1
^  
2
` ', by modus ponens. Thus ? `
N
'.
3. The derivation of ? `
+
L
' ends in
?
0
;  
1
` ' ?
0
;  
2
` '
?
0
;  
1
_  
2
` '
By the induction hypothesis we have derivations in natural deduction
of ?
0
;  
1
` ' and ?
0
;  
2
` '. By Lemma 2.6, ?
0
;  
1
;  
1
_  
2
` '
and ?
0
;  
2
;  
1
_  
2
` '. Since also ?
0
;  
1
_  
2
`  
1
_  
2
, we get
?
0
;  
1
_  
2
` '. Thus ? `
N
'.
4. The derivation of ? `
+
L
' ends in
?
0
`  
1
?
0
;  
2
` '
?
0
;  
1
!  
2
` '
By the induction hypothesis we have derivations in natural deduction
?
0
`  
1
and ?
0
;  
2
` '. By Lemma 2.6, ?
0
;  
1
!  
2
`  
1
and
?
0
;  
1
!  
2
;  
2
` '. As before, ?
0
;  
1
!  
2
`  
1
!  
2
, so
?
0
;  
1
!  
2
`  
2
. Also ?
0
;  
1
!  
2
`  
2
! ', so ?
0
;  
1
!  
2
` '.
Thus ? `
N
'.
5. The derivation of ? `
+
L
' is
?
0
;? ` '
Then
?
0
;? ` ?
?
0
;? ` '
is a derivation of ? `
N
'.
6. The derivation of ? `
+
L
' ends in
? `  ?;  ` '
? ` '
By the induction hypothesis we have derivations in natural deduction
of ? `  and ?;  ` '. Then ? `  ! ', and then ? ` '. Thus
? `
N
'.
112 Chapter 7. Sequent calculus
The remaining cases|the right rules|are trivial.
For the right-to-left direction the problem is to express the elimination
rules of natural deduction in terms of the left rules of sequent calculus; the
cut rule turns out to be useful for this.
As above the cases where the derivation consists of a use of the axiom
or ends in an introduction rule are trivial.
1. The derivation of ? `
N
' ends in
? ` ' ^  
? ` '
By the induction hypothesis we have a sequent calculus derivation of
? ` '^ . By the axiom and the left rule for ^ we get ?; '^ ` '.
Then by the cut rule ? ` '. Thus ? `
+
L
'.
2. The derivation of ? `
N
' ends in
?;  
1
` ' ?;  
2
` ' ? `  
1
_  
2
? ` '
By the induction hypothesis we have sequent calculus derivations of
?;  
1
` ', of ?;  
2
` ', and of ? `  
1
_  
2
. By the left rule for _
we get ?;  
1
_  
2
` '. Then by the cut rule ? ` '. Thus ? `
+
L
'.
3. The derivation of ? `
N
' ends in
? `  ! ' ? `  
? ` '
By the induction hypothesis we have sequent calculus derivations of
? `  ! ' and ? `  . By the axiom ?; ' ` ', so by the left rule
for! we have that ?;  ! ' ` '. Then by the cut rule ? ` '. Thus
? `
+
L
'.
4. The derivation of ? `
N
' ends in
? ` ?
? ` '
By the induction hypothesis we have a sequent calculus derivation of
? ` ?. By the left rule for ? we have ?;? ` '. Then by the cut
rule ? ` '. Thus ? `
+
L
'. ut
7.3. Cut elimination 113
7.3. Cut elimination
In both directions of the proof of Proposition 7.2.2 we introduce detours. In
the left-to-right direction we express the left rule for, say ^, by a sequence of
rules in which a ^-introduction is immediately followed by a ^-elimination
(this is reected by a redex of form 
i
(< M
1
;M
2
>) in the -term corre-
sponding to the proof). In general we expressed each left rule of the sequent
calculus system by a natural deduction proof in which a sequent occurrence
was both the conclusion of an introduction rule and the major
4
premise of
the corresponding elimination rule (in general, such sequent occurrences are
reected by redexes in the -term corresponding to the proof).
In the right-to-left direction we used the cut rule to express elimination
rules in terms of left rules.
We know that we can get rid of the detours in the natural deduction
proofs; that is, we can transform any natural deduction proof into one in
which no sequent occurrence is both the conclusion of an introduction rule
and the major premise of the corresponding elimination rule. This corre-
sponds to the fact that, by the weak normalization theorem, we can eliminate
all redexes in a term of the simply typed -calculus with pairs and sums.
The following theorem states that we can also do without the cuts.
7.3.1. Theorem (Cut elimination). For all ' and ? the conditions ? `
+
L
'
and ? `
L
' are equivalent.
The proof is somewhat tedious, especially when presented in terms of
proof trees|see, e.g., [46] or [109]. Therefore we postpone the proof to
Section 7.6 where a more convenient notation for proofs is developed. Here
we merely reect on some of the more interesting aspects of the proof, and
consider some consequences of the theorem.
First observe that there is no uniform way to eliminate an application of
the cut rule, i.e., there is no xed sequence of other rules that is equivalent
to a cut. Each cut has to be eliminated dierently, and this depends on the
shape of the cut formula and the way it was constructed above the cut.
In addition, in an attempt to eliminate a cut with a complex cut formula,
i.e., one of the form '!  , we may actually create new cuts, as can be seen
from the following example. Consider a proof that ends with an application
of a cut rule of the form:
4
In _E, ! E, and ^E the major premise is the leftmost one, the rightmost one, and
the single one, respectively.
114 Chapter 7. Sequent calculus
(R!)
(1)
.
.
.
?; ' `  
? ` '!  
(2)
.
.
.
? ` '
(3)
.
.
.
?;  ` #
?; '!  ` #
(L!)
? ` #
(Cut)
We can eliminate this cut at the cost of introducing two new ones. This
makes sense, because the new cut formulas are simpler. The new proof is as
follows:
(Cut)
(2)
.
.
.
? ` '
(1)
.
.
.
?; ' `  
? `  
(3)
.
.
.
.
.
.
?;  ` #
? ` #
(Cut)
Note that in our example the cut formula '!  was introduced just before
the cut by the rules (R!) and (L!).
The strategy of the cut elimination proof is as follows. The main cases,
when the cut formula is introduced by the appropriate left and right rules
directly before cut, is treated as in our example: by replacing the cut by
new \simpler" cuts. Other cuts are \permuted upward" so that each cut is
eventually either applied to an axiom (an easy case), or another main case
is obtained. This requires an induction over two parameters: the depths of
cuts and the complexity of cut formulas.
5
7.3.2. Remark. The cut elimination theorem also holds for the classical
sequent calculus; that is, for all  and ? the conditions ? `
+
LC
 and ? `
LC

are equivalent.
7.3.3. Lemma (Subformula property). The cut-free sequent calculus `
L
has
the following property: Each formula occurring in a proof of ? ` ' is either
a subformula of ' or a subformula of a formula occurring in ?.
Proof. By induction on the derivation of ? ` '. ut
There are a number of consequences of the subformula property. One
is that nding a sequent calculus proof of a given formula (or nding out
that no such proof exists) is incomparably easier than nding such a proof
in the Hilbert, or natural deduction system. As we reconstruct the proof
5
The similarity between this approach and the proof method of weak normalization is
not at all incidental.
7.4. Term assignment for sequent calculus 115
by building the tree upward, the search space at each step is limited to
subformulas of the formulas occurring at the present stage. This process
cannot continue indenitely, as the number of available formulas is bounded,
and we will eventually repeat already considered sequents.
7.3.4. Corollary (Gentzen). It is decidable, for input ', whether `
+
L
'.
Another consequence is the conservativity of fragments of the calculus
determined by a choice of connectives. The subformula property implies
that a cut-free proof of a sequent can only mention connectives occurring
in that sequent. Thus, e.g., a formula ((p ^ q) ! r) $ (p ! (q ! r)) is
provable in a system containing only rules for implication and conjunction.
7.3.5. Corollary. IPC is conservative over its implicational fragment.
We end this section with another proof of the disjunction property
(Proposition 2.5.7).
7.3.6. Corollary. If `
+
L
' _  then either `
+
L
' or `
+
L
 .
Proof. If there is a proof of `
+
L
' _  , then there is a cut-free one. And a
cut-free proof of a disjunction must end up with an application of rule (_I).
Thus, either `
L
' or `
L
 must have been proved rst. ut
7.4. Term assignment for sequent calculus
Natural deduction proofs correspond to typed -terms and Hilbert-style
proofs correspond to typed combinators. What do sequent calculus proofs
correspond to?
There are several answers. The traditional one|see, e.g., [84, 118]|
is that we can assign lambda-terms to sequent calculus proofs; that is, we
can devise an alternative version of simply typed -calculus|with the same
term language, but with dierent typing rules|which is to sequent calculus
what the traditional formulation of simply typed -calculus is to natural
deduction.
This is carried out below. We begin with the implicational fragment.
7.4.1. Definition (Sequent calculus style !). The type and term language
of the sequent calculus style ! is as for ! (a la Curry). The typing rules
are as follows:
116 Chapter 7. Sequent calculus
Axiom:
?; x:' ` x : '
Rules:
? `M : ' ?; x: ` N : 
?; y:'!  ` N [x := yM ] : 
(L!)
?; x:' `M :  
? ` x:M : '!  
(R!)
? `M : ' ?; x:' ` N : 
? ` (x:N)M : 
(Cut)
We also write `
+
L
and `
L
for derivability in this system with and without
cut, respectively. We thus have binary and ternary version of both `
+
L
and
`
L
; the binary version refers to the sequent calculus formulation of IPC(!)
in Denition 7.2.1, and the ternary version refers to the present sequent
calculus style formulation of !.
As usual we have that the system with terms agrees with the system
without terms.
7.4.2. Proposition.
(i) If ? `
+
L
M : ' then j?j `
+
L
'.
(ii) If ? `
+
L
' then there exists M 2  such that  `
+
L
M : ', where
 = f(x
'
: ') j ' 2 ?g.
The above sequent calculus system assigns types to certain -terms. Are
these the same -terms as those that receive types by the usual simply typed
-calculus a la Curry? The answer is no! For instance, there is no way to
assign a type to (x:y:x) (z:z) (z:z) in the above system.
However, the proof of Proposition 7.2.2 implicitly denes a translation
from terms typable in simply typed -calculus (corresponding to natural
deduction proofs) to terms typable in the above system (corresponding to
sequent calculus proofs), and vice versa.
On the other hand, if we restrict attention to -terms in normal form,
then the set of terms typable in traditional simply typed -calculus coincides
with the set of terms typable in sequent calculus.
7.4.3. Proposition. For every term M in normal form, ? `
+
L
M : ' i
? ` M : ' in simply typed -calculus.
7.4. Term assignment for sequent calculus 117
Proof. First show that a term M is in normal form i either
 M is a variable, or
 M = x:N , where N is a normal form, or
 M = N [y := xP ], where N and P are normal forms.
Then the property follows easily. ut
In the correspondence between simply typed -calculus and natural de-
duction, -terms in normal form correspond to normal deductions (i.e., de-
ductions where no sequent is at the same time the conclusion of an intro-
duction rule and the major premise of the corresponding elimination rule).
In the sequent calculus variant of simply typed -calculus, -terms in
normal form correspond to cut-free proofs in sequent calculus.
7.4.4. Proposition. If ? `
+
L
M : ', then M is in normal form if and only
if ? `
L
M : '.
Proof. Obvious. ut
Thus simply typable -terms in normal form correspond to both nor-
mal proofs in natural deduction and cut-free sequent calculus proofs. We
therefore have the correspondence
Normal deductions () Cut-free proofs
However, note that a deduction may use the cut rule even if the cor-
responding -term is in normal form (cf. Exercise 7.7.5): the substitution
N [x := y M ] may delete the term M which may contain redexes. In this
case we just know that there is another typing that does not use the cut
rule of the same term.
7.4.5. Remark. As mentioned above, the proof of Proposition 7.2.2 implic-
itly denes a translation from terms typable in traditional simply typed
-calculus (corresponding to natural deduction proofs) to terms typable in
the above system (corresponding to sequent calculus proofs), and vice versa.
From what has been said above one might expect that the translations
map normal forms to normal forms. However this is not the case. The reason
for this is that in the proof of Proposition 7.2.2 we aimed at the simplest
possible way to get from natural deduction proofs to sequent calculus proofs;
in particular, we translated the left rules of sequent calculus into natural
deduction proofs containing detours, and we made use of the cut rule in
translating elimination rules into left rules.
118 Chapter 7. Sequent calculus
7.5. The general case
We briey show how the development of the preceding section can be gen-
eralized to the full propositional language.
Recall the extension of ! a la Curry with pairs and sums:
? ` M :  ? ` N : '
? `< M;N >:  ^ '
? ` M :  ^ '
? ` 
1
(M) :  
? ` M :  ^ '
? ` 
2
(M) : '
? ` M :  
? ` in
1
(M) :  _ '
? ` M : '
? ` in
2
(M) :  _ '
? ` L :  _ ' ?; x :  ` M :  ?; y : ' ` N : 
? ` case(L;x:M ; y:N) : 
For completeness, extend the language with an operator " for falsity, with
the following rule:
? `M : ?
? ` "(M) : 
and with no reduction rule (as there is no ?-introduction rule).
First we generalize the construction in the proof of Proposition 7.4.3
7.5.1. Lemma. A term M is in normal form i either
 M is a variable, or
 M = x:P , or
 M = P [y := xQ], or
 M =< P;Q >, or
 M = in
1
(P ), or
 M = in
2
(P ), or
 M = P [y := 
1
(x)], or
 M = P [y := 
2
(x)], or
 M = P [y := case(x; v:Q;w:R)], or
 M = "(P ),
where P , Q, and R are normal forms.
Proof. Easy. ut
7.5. The general case 119
7.5.2. Definition (Sequent calculus style ! for the full language). The se-
quent calculus style ! for the full propositional language is as for ! a la
Curry with pairs and sums. The typing rules are are those of Denition 7.4.1
and in addition the following:
(L^)
?; x:'
i
`M : 
?; y:'
1
^ '
2
`M [x := 
i
(y)] : 
? `M : ' ? ` N :  
? `< M;N >: ' ^  
(R^)
(L_)
?; x:' `M :  ?; y: ` N : 
?; z:' _  ` case(z;x:M ; y:N) : 
? `M : '
i
? ` in
i
(M) : '
1
_ '
2
(R_)
?; x:? ` "(x) : 
(L?)
It is a routine matter to verify that the generalized version of Proposi-
tion 7.4.2 holds.
We would like now to generalize Proposition 7.4.3, but there is a problem.
Some typable lambda-terms in normal form do not correspond to any terms
typable in the new system. For instance, if M , N , P and Q are normal
forms, then the term 
1
(case(z;x: < M;N >; y: < P;Q >)) is in normal
form. But it has no type in the above system, even if the term is typable in
! with pairs and sums (to see this, observe that no rule could possibly be
the last one used.)
One way to remedy this problem is to modify the term assignment for
the (Cut) rule to:
? `M : ' ?; x:' ` N : 
? ` N [x :=M ] : 
(Cut)
Then our example term can be typed, but only using the cut-rule, so the
correspondence between normal proofs and cut-free proofs has been lost.
Incidentally, this diculty does not occur for implication and conjunc-
tion, but only for the disjunction and falsity. The reason is that the elimina-
tion rules for these connectives are dierent. Recall that every elimination
rule has a main premise involving the eliminated connective. In case of
implication and conjunction, the conclusion of the elimination rule (more
precisely: the right-hand side of the conclusion) is a subformula of the main
premise. In case of disjunction and falsity this is not the case.
Our example term corresponds to the following sequence of proof steps:
conjunction introduction (pairing) followed by disjunction elimination (case),
followed by conjunction elimination (projection). Due to the \irregular" be-
haviour of disjunction elimination, the last projection should actually be
applied to the pair(s) created at the beginning. But the case instruction
120 Chapter 7. Sequent calculus
makes this impossible. It is a stranger who entered here by mistake due to
an improperly closed door (the \bad" elimination, as Girard calls it) and
does her own work quite unrelated to the form of the main premise. A so-
lution is either to ignore her or to open the door even more and let her go
out. Technically, these two alternatives mean that we should either relax the
existing reduction rules to allow for reduction of introduction/elimination
pairs, even if the latter does not immediately follow the former, or we should
introduce commuting conversions, i.e., reduction rules to permute elimina-
tions.
After Girard [46] we take the second option.
7.5.3. Definition. In ! with pairs and sums let !
c
denote the union
of !

, of the -reductions for pairs and sums (see Page 75), and of the
compatible closure of the relation dened by the following rules:
 
1
(case(M ;x:P ; y:Q)) ! case(M ;x:
1
(P ); y:
1
(Q));
 
2
(case(M ;x:P ; y:Q)) ! case(M ;x:
2
(P ); y:
2
(Q));
 (case(M ;x:P ; y:Q))N ! case(M ;x:PN ; y:QN);
 "(case(M ;x:P ; y:Q)) ! case(M ;x:"(P ); y:"(Q));
 case(case(M ;x:P ; y:Q); z:N ; v:R) !
case(M ;x:case(P ; z:N ; v:R); y:case(Q; z:N ; v:R));
 "(
1
(M))! "(M);
 "(
2
(M))! "(M);
 "("(M)) ! "(M);
 ("(M))N ! "(M);
 case("(M);x:P ; y:Q) ! "(M).
Also, let NF
c
denote the set of normal forms with respect to !
c
.
Now we can state a version of Proposition 7.4.3.
7.5.4. Proposition. For every M 2 NF
c
: ? `
+
L
M : ' i ? ` M : ' in !
with pairs and sums.
For the full system we also have
7.5.5. Proposition. For every deduction ? `
+
L
M : ', M is in c-normal
form if and only if ? `
L
M : '.
7.6. Alternative term assignment 121
Proof. Obvious. ut
7.5.6. Remark. The notion of -reduction is often understood as follows.
An elimination followed by an introduction of the same connective should
be ignored. We can write the following eta-rule for ^:
< 
1
(M); 
2
(M) >!

M:
The above rule, although looking very convincing, hides an unpleasant sur-
prise to be discovered in Exercise 7.7.6.
For function types, as we have already observed before, the meaning of
the eta rule is the postulate of extensionality for functions, In case of ^,
eta-reduction has the following meaning: Every object of a product type is
actually a pair.
This leads to the idea of the following \generalized extensionality" prin-
ciple: Every object should be assumed to be in a \canonical form". The
canonical form for an object of type  _  is a variant, i.e., it is either an
in
1
(M) or an in
2
(N). Thus suggest the following eta rule for disjunction:
case(M ;x:in
1
(x); y:in
2
(y))!M:
7.5.7. Warning. We use logical symbols _ and ^ to denote also the corre-
sponding types. Similar symbols are often used to denote intersection and
union types, which have quite a dierent meaning (see e.g. [6]). Our ^ is ac-
tually a product rather than intersection, and our _ is a variant type rather
than set-theoretic or lattice union.
7.6. Alternative term assignment
The sequent calculus systems with terms in the preceding two sections reveal
interesting connections about normal natural deduction proofs and cut-free
sequent calculus proofs.
However, for a ne-grained analysis of cut-elimination the term assign-
ment is not satisfactory. The problem is that dierent proofs correspond to
the same term so that reductions on proofs is not exactly mirrored by reduc-
tions on terms. In this section we follow another well-known approach|see,
e.g., [15, 116, 38]|and introduce another, more explicit, way of assigning
terms to sequent calculus proofs. We shall use the term assignment to prove
the Cut Elimination Theorem.
Yet another approach to term assignment appears in [52].
122 Chapter 7. Sequent calculus
7.6.1. Definition (Alternative term assignment to sequent calculus). We con-
sider the language of propositional formulas and the following term language:
M ::= x j in
1
(M) j in
2
(M) j x:M j < M;M
0
>
j "(x)
j case(x;x
0
:M
0
;x
00
:M
00
)
j let x = x
0
M in M
0
j let x = 
1
(x
0
) in M
0
j let x = 
2
(x
0
) in M
0
j let
'
x =M
0
in M
0
Note that in the rst three kinds of let-expression, the form of N in the
expression \let x = N in M" is restricted to certain forms.
The inference rules of the system are as follows:
Axiom:
?; x:' ` x : '
Rules:
(L!)
? `M : ' ?; x: ` N : 
?; y:'!  ` let x = y M in N : 
?; x:' `M :  
? ` x:M : '!  
(R!)
(L^)
?; x:'
i
`M : 
?; y:'
1
^ '
2
` let x = 
i
(y) in M : 
? `M : ' ? ` N :  
? `< M;N >: ' ^  
(R^)
(L_)
?; x:' `M :  ?; y: ` N : 
?; z:' _  ` case(z;x:M ; y:N) : 
? `M : '
i
? ` in
i
(M) : '
1
_ '
2
(R_)
?; x:? ` "(x) : 
(L?)
? `M : ' ?; x:' ` N : 
? ` let
'
x =M in N : 
(Cut)
In -terms with pairs and sums there are a number of constructors and
a number destructors. The constructors are < ;  >, in
i
(), and x:; these
build up values, informally speaking. The destructors are case(;x:M ;x
0
:M
0
),
 N , and 
i
(). These inspect and dissect values, informally speaking. In
the -calculus with pairs and sums one can freely apply a destructor to any
7.6. Alternative term assignment 123
term. The main dierence to the above term language is that now the com-
bination of destructors and constructors are expressed via an explicit rule,
namely cut.
This makes it very explicit where intermediate results, e.g. a pair of
which one takes a projection, are constructed. In functional programming
there are various techniques to eliminate intermediate data structures from
functional programs, notablyWadler's deforestation [115]. Marlow [69] stud-
ies deforestation of a functional programming language which is similar to
the term assignment for sequent calculus proofs.
The following rules remove cuts from sequent calculus proofs represented
by the alternative syntax of Denition 7.6.1.
7.6.2. Definition. On the term language introduced in Denition 7.6.1,
we introduce the relation !
a
as the transitive, reexive, compatible closure
of the relation dened by the following rules, which are divided into three
groups: main cases, absent constructor in left term, and absent constructor
in right term.
The main cases are:
let
'
1
^'
2
y =< M
1
;M
2
> in let x = 
i
(y) in M !
let
'
i
x =M
i
in M
let
'
1
_'
2
y = in
i
(M) in case(y;x
1
:M
1
;x
2
:M
2
) !
let
'
i
x
i
=M in M
i
let
'
1
!'
2
y = x:M in let z = y N in L !
let
'
1
x = N in let
'
2
z =M in L
Absent constructor from left hypothesis:
let
'
x = y in N ! Nfx := yg
let
'
x = let y = 
i
(z) in M in N ! let y = 
i
(z) in let
'
x =M in N
let
'
x = case(z; y
1
:M
1
; y
2
:M
2
) in N !
case(z; y
1
:let
'
x =M
1
in N ; y
2
:let
'
x =M
1
in N)
let
'
x = let y = z M in K in N ! let y = z M in let
'
x = K in N
let
'
x = let
 
y =M in K in N ! let
 
y =M in let
'
x = K in N
let
'
x = "(y) in N ! "(y)
Absent constructor from right hypothesis:
let
'
x = N in y ! yfx := Ng
let
'
x = N in < M
1
;M
2
> !
< let
'
x = N in M
1
; let
'
x = N in M
2
>
let
'
x = N in in
i
(M) ! in
i
(let
'
x = N in M)
let
'
x = N in y:M ! y:let
'
x = N in M
let
'
x = N in "(y) ! "(y)
let
'
x = N in let
 
y = K in L !
let
 
y = (let
'
x = N in K) in (let
'
x = N in L)
124 Chapter 7. Sequent calculus
7.6.3. Definition.
1. Dene the degree d(') of a formula ' by:
d(?) = d() = 0; for  2 PV ;
and
d(' ^  ) = d(' _  ) = d('!  ) = 1 +maxfd('); d( )g:
2. Dene the degree d(M) of a term M as the maximal degree of any '
in any let
'
x = K in L in M .
3. Dene the height h(M) of a term M as the height of M viewed as a
tree.
7.6.4. Lemma. Let d = d(') and assume
? `
+
L
let
'
x =M in N :  
where d(M) < d and d(N) < d. Then let
'
x = M in N !
a
P for some P
with ? `
+
L
P :  and d(P ) < d.
Proof. By induction on h(M) + h(N). Split into cases according to the
form of M and N . ut
7.6.5. Proposition. If ? `
+
L
M : ' and d(M) > 0 then M !
a
N for
some N with ? `
+
L
N : ' and d(M) > d(N).
Proof. By induction on M using the lemma. ut
7.6.6. Theorem (Gentzen). If ? `
+
L
M : ' then M !
a
N where ? `
+
L
N : '
and d(N) = 0, i.e., N represents a cut-free proof.
Proof. By induction on d(M) using the Proposition. ut
What does the system introduced above correspond to, computationally
speaking? The rules are similar to the rules that one nds in systems for
explicit substitution|see, e.g., [14]. It would be interesting to investigate
this in greater detail|this has been done recently [113].
7.7. Exercises 125
7.7. Exercises
7.7.1. Exercise. Give sequent calculus proofs for the formulas of Exam-
ple 2.2. To prove the odd-numbered formulas use only sequents with single
formulas at right-hand sides.
7.7.2. Exercise. Show that all cut-free proofs for the even-numbered for-
mulas of Example 2.2 must involve sequents with more than one formula at
the right-hand side.
7.7.3. Exercise. Design a sequent calculus allowing empty right-hand sides
of sequents. Does it make sense now to have a right rule for ??
7.7.4. Exercise. Prove Proposition 7.4.3. On the basis of this proof de-
scribe algorithms translating a normal deduction into a cut-free proof and
conversely.
7.7.5. Exercise. Give examples of cuts that are assigned terms in normal
form, according to the term assignment of Section 7.4.
7.7.6. Exercise. Show that the Curry-style variant of lambda-calculus with ^
does not have the subject reduction property for -reductions. Show that
the eta rule for _ has the subject reduction property.
7.7.7. Exercise. Design a Church-style calculus with ^ and _ and show
that subject reduction property holds for that calculus.
7.7.8. Exercise. Explain the dierence between the above two results.
7.7.9. Exercise. Can you design a reasonable eta-rule for disjunction aim-
ing at erasing elimination-introduction pairs? Why not?
7.7.10. Exercise. Dene an eta-rule for ?.
7.7.11. Exercise. Let A denote the term language of Denition 7.6.1, ex-
cept that in A, cut terms have the form let

x =M in N (the ' is omitted).
Let L denote the set of -terms with pairs and sums and ".
Let `
L
denote typability in ! with pairs and sums and ?, and let `
A
denote typability in the sense of Denition 7.6.1 with the obvious modica-
tion to the cut rule to accomodate the change in the syntax of cut terms.
Let !
A
denote the reduction relation from Denition 7.6.2, and let !
L
denote the transitive, reexive closure of !

plus the reductions on pairs
and sums. =
A
and =
L
are the obvious closures.
Use the proof of Proposition 7.2.2 to give translations t
L
: A ! L and
t
A
: L ! A between A and L. Note that these can also be viewed as
translations on type-free terms.
Which of the following properties hold for your translations?
126 Chapter 7. Sequent calculus
1. ? `
L
M : ' , ? `
A
t
A
(M) : ';
2. ? `
A
M : ' , ? `
L
t
L
(M) : ';
3. M !
L
N , t
A
(M)!
A
t
A
(N);
4. M !
A
N , t
L
(M)!
L
t
L
(N);
5. t
L
(t
A
(M)) =
L
M ;
6. t
A
(t
L
(M)) =
A
M .
What happens if you add commuting conversion to the relations !
L
, =
L
,
etc.?
CHAPTER 8
Classical logic and control operators
In the previous chapters we have encountered the Curry-Howard isomor-
phism in various incarnations; each of these state a correspondence between
some system of typed terms and a system of formal logic.
Until now these systems of formal logic have been constructive; that is,
in none of them have we found the principle of the excluded middle or the
double negation elimination principle that one nds in classical logics.
This is by no means a coincidence. Until around 1990 there was a
widespread consensus to the eect that \there is no Curry-Howard isomor-
phism for classical logic." However, at that time Tim Grin made a path-
breaking discovery which have convinced most critics that classical logics
have something to oer the Curry-Howard isomorphism.
In this chapter we introduce classical propositional logic, we study how
one can assign terms to classical proofs, and we present a system for classical
proof normalization. The connection between classical and intuitionistic
logic is also elaborated in some detail. Grin's discovery is then presented
at the end of the chapter.
8.1. Classical propositional logic, implicational fragment
Although the bulk of the previous chapters have been concerned with formu-
lations of intuitionistic propositional logic we have occasionally come across
classical propositional logic.
For instance, in Chapter 2, we briey studied the algebraic semantics of
classical logic, and in the preceding chapter, we introduced sequent calculus
for intuitionistic logic as the restriction of classical sequent calculus to one-
formula right hand sides.
In the case of natural deduction, there are several ways to obtain classi-
cal propositional logic from intuitionistic propositional logic. The following
gives one way of doing this for the implicational fragment.
127
128 Chapter 8. Classical logic and control operators
8.1.1. Remark. In order to avoid confusion and lengthy remarks it is con-
venient in this chapter to have available a systematic way of assigning names
to subsets of the language of propositions and to logical system and typed
-calculi.
In this chapter, L(!) denotes the set of implicational formulas, i.e., the
language generated by the grammar:
L(!) 3 ' ::= ? j  j '! '
0
The full propositional language L(!;_;^) is the language generated by
the grammar:
L(!;_;^) 3 ' ::= ? j  j '! '
0
j ' _ '
0
j ' ^ '
0
We shall occasionally be concerned with the set L
?
(!) of pure implica-
tional formulas, i.e., the language generated by
L
?
(!) 3 ' ::=  j '! '
0
Similarly, the pure full propositional language L
?
(!;_;^) is the lan-
guage generated by the grammar:
L
?
(!;_;^) 3 ' ::=  j '! '
0
j ' _ '
0
j ' ^ '
0
We will follow similar naming conventions for logical systems and typed
-calculi.
8.1.2. Definition (Classical propositional logic, implicational fragment). Let
'; range over implicational formulas, i.e., over L(!). As usual, ? and 
denote contexts for which we use the standard conventions.
The natural deduction presentation of the implicational fragment CPC(!)
of classical propositional logic is dened by the following axiom and rules:
Axiom:
?; ' ` '
Rules:
?; ' `  
? ` '!  
(! I)
? ` '!  ? ` '
? `  
(! E)
?; '! ? ` ?
? ` '
(::E)
8.1. Classical propositional logic, implicational fragment 129
8.1.3. Proposition. Let ' be an implicational formula. Then ? ` ' i
? j= ' according to the truth-table semantics. In particular ` ' i ' is a
tautology.
Proof. The proof is left as an exercise. ut
8.1.4. Remark. A small variation of the system is obtained by changing
rule (::E) to
? ` ('! ?)! ?
? ` '
(::E
0
)
It is an easy exercise to see that this change does not aect the set of
provable sequents, i.e., ? ` ' can be derived in the original system i ? ` '
can be derived in the modied system.
Since :' is dened as '! ? a shorter way to express the formula in the
hypothesis is ::', which explains the name double negation elimination.
8.1.5. Remark. In CPC(!) one can prove every formula that can be proved
in IPC(!), the implicational fragment of intuitionistic propositional logic.
The latter system contains the axiom and the rules (!I), (!E) and (?E),
so the only problem is to show that (?E) holds as a derived rule in CPC(!).
That is, that we have to show that in CPC(!),
? ` ? ) ? ` '
for any '. In fact, this is easy. If ? ` ? then also ?; '! ? ` ? by an easy
weakening lemma, and then ? ` ' by (::E).
8.1.6. Remark. Another way to dene CPC(!) is to consider the axiom
along with rules (!I) and (!E) and then the following two rules:
?; '!  ` '
? ` '
(P)
? ` ?
? ` '
(?E)
The left-most rule is called Peirce's law, and the right-most one is called
ex falso sequitur quod libet (from absurdity follows whatever you like).
An alternative is to consider instead the following two rules:
?; '! ? ` '
? ` '
(P?)
? ` ?
? ` '
(?E)
In other words, in the presence of (?E), Peirce's law and the special case
 = ? are equivalent.
It is an exercise to show that these two systems derive the same sequents
as the system introduced in Denition 8.1.2.
130 Chapter 8. Classical logic and control operators
8.1.7. Remark. In the case of Hilbert-style proofs there are also several
ways to obtain classical logic from intuitionistic logic. For instance, if one
takes absurdity as primitive, one can add to the two axioms (A1) and (A2)
of Section 5.3 the principle of double negation elimination:
(('! ?)! ?)! ':
Another possibility is to add Peirce's law in the form
(('!  )! ')! ';
together with ex-falso in the form:
? ! ':
8.1.8. Remark. If one takes negation as primitive in a Hilbert-style system,
one can add to the axioms (A1) and (A2) the third axiom:
(:'! : )! (:'!  )! ';
which is read: \if :' implies both  and : , then it is contradictory to
assume :', so ' holds."
In case negation is taken as primitive one cannot simply add
::'! ' ()
This may seem a bit strange since above we suggested to add exactly this
axiom when : is dened in terms of ?. The point is, however, that in
dening : in terms of ? we get certain extra axioms for free. For instance,
we have above the rule
('!  )! ('! ( ! ?))! ('! ?)
and the corresponding axiom
('!  )! ('! : )! :'
does not follow from axioms (A1) and (A2) and the double negation ax-
iom ().
Similar remarks apply to natural deduction systems in which negation
is taken as primitive.
Apart from classical propositional logic and intuitionistic propositional
logic, there are many other similar propositional logics, although none of
them are as fundamental as these two. One can show that classical propo-
sitional logic is a maximal logic in the sense that, for any axiom scheme ',
either ' is a theorem of classical propositional logic, or addition of ' to
classical propositional logic would render the system inconsistent. Such
properties are usually known as Hilbert-Post completeness.
8.2. The full system 131
8.2. The full system
In the previous section we were concerned with the implicational fragment
of classical propositional logic. What is required to obtain a denition of
the whole system with conjunction and disjunction?
One approach is to add to the language the two connectives ^ and _ and
adopt the introduction and elimination rules of the system of Section 2.2.
8.2.1. Definition (Classical propositional logic). Let '; range over for-
mulas in the full propositional language, i.e., over L(!;_;^). As usual, ?
and  denote contexts for which we use the standard conventions.
The natural deduction presentation of CPC(!;_;^), classical proposi-
tional logic, is dened by same rules as in Denition 8.1.2 with the addition
of the following well-known rules.
? ` ' ? `  
? ` ' ^  
(^I)
? ` ' ^  
? ` '
(^E)
? ` ' ^  
? `  
? ` '
? ` ' _  
(_I)
? `  
? ` ' _  
?; ' `  ?;  `  ? ` ' _  
? ` 
(_E)
The above addition does not change anything concerning implicational
formulas.
8.2.2. Proposition. If ' 2 L(!) and ` ' in CPC(!;_;^), then ` ' in
CPC(!).
Proof. Left as an exercise. ut
In other words, the full system is conservative over the implicational frag-
ment.
However, there is a more economical approach. In contrast to the sit-
uation in intuitionistic propositional logic, we may dene conjunction and
disjunction as derived connectives.
8.2.3. Definition. Let ' ^  and ' _  abbreviate the following formulas,
respectively:
' ^  = ('!  ! ?)! ?;
' _  = ('! ?)! ( ! ?)! ?:
8.2.4. Remark. The above denition of ' _  is not standard; one usually
takes '_ = ('! ?)!  . This denition lacks the double negation on  .
From a logical point of view this is of little importance, since in classical
logic we can pass back and forth between a formula and its double negation.
However, the abbreviations in Denition 8.2.3 are more systematic since
they arise as special case of a general scheme for representing data types in
typed -calculi, as we shall see later.
132 Chapter 8. Classical logic and control operators
The following states that our denition of ^ and _ have the intended
behaviour.
8.2.5. Proposition. Let ' 2 L(!;_;^) and and let '
0
2 L(!) be the
implicational formula obtained by replacing every occurrence of ^ and _ by
their dening formulas according to Denition 8.2.3. Then ? ` '
0
i ? j= '.
Proof. By completeness ? ` '
0
i ? j= '
0
. By elementary calculations
with truth tables, ? j= '
0
i ? j= '. ut
8.3. Terms for classical proofs
In what way can we extend the Curry-Howard isomorphism to classical
propositional logic? In one sense this is easy: we just add a new term
constructor x:M (or x:':M in the Church variant of the calculus) in the
conclusion of the double negation elimination rule.
8.3.1. Remark. It is convenient in this chapter to have available a system-
atic way of assigning names to subsets of the language of -terms with pairs,
etc.
Recall that  denotes the set of -terms, i.e., the language generated by
the grammar:
 3M ::= x j x:M jM M
0
The set of -terms, extended with pairs and sums, (
i
; in
i
) is the lan-
guage generated by the grammar:
(
i
; in
i
) 3M ::= x j x:M jM M
0
j < M;M
0
> j 
i
(M) j
in
i
(M) j case(M ;x
0
:M
0
;x
00
:M
00
)
We shall occasionally be concerned with the set 
"
generated by

"
3M ::= x j x:M jM M
0
j "(M)
Similarly, we have the language generated by the grammar:

"
(
i
; in
i
) 3M ::= x j x:M jM M
0
j < M;M
0
> j 
i
(M)
j in
i
(M) j case(M ;x
0
:M
0
;x
00
:M
00
) j "(M)
8.3.2. Definition (type-free and simply typed 

-calculus, 

(!)). The term
language 

of type-free 

-calculus is dened by the grammar:


3M ::= x j x:M jM M
0
jx:M
The simply typed 

-calculus has as type language the set L(!). The
inference system of simply typed 

-calculus arises from the system of sim-
ply typed -calculus a la Curry by addition of the rule
?; x : '! ? `M : ?
? ` x:M : '
8.4. Classical proof normalization 133
8.3.3. Remark. In the Church variant the obvious modications are made
to the term language and to the inference rules. In particular, the double
negation elimination rule becomes
?; x : '! ? `M : ?
? ` x:'! ?:M : '
We then have the usual correspondence (where binary ` means deriv-
ability in CPC(!) and ternary ` means typability in simply 

-calculus a
la Curry):
8.3.4. Proposition.
(i) If ? ` M : ' then j?j ` ', where j?j = f' j 9x : (x : ') 2 ?g.
(ii) If ? ` ' then there exists an M such that ?
0
` M : ', where
?
0
= fx
'
: ' j ' 2 ?g.
The assignment of x:M to the double negation elimination rule only
extends the Curry-Howard isomorphism to classical logic in a very naive
sense: we still have no idea what the computational signicance of  is.
However, we shall learn more about this in Section 8.7.
8.4. Classical proof normalization
As we have seen in previous chapters, reduction on proofs is a rather im-
portant concept in the proof theory of intuitionistic logic; for classical logic
the same is the case, and we now present certain reductions on classical,
propositional proofs that have appeared in the literature.
The following gives reductions on 

-terms a la Church. The corre-
sponding reductions on 

-terms a la Curry are obtained by erasing all
type annotations.
8.4.1. Definition. Dene the relation!

on 

a la Church as the small-
est compatible relation containing the following rules:
(x::('!  ):M) N !

z:: :Mfx := y :'!  : z (y N)g;
x::':x M !

M provided x 62 FV(M);
x::':x y::':N !

z::':Nfx; y := zg:
where f := g denotes substitution on 

-terms dened in the obvious way,
and the notion of compatibility is taken in the obvious way relative to the
set 

. We use the notation NF

etc with the usual meaning.
From the point of view of reduction on proofs, the rst of these rules
decreases the complexity of formulas to which we apply the double negation
elimination rule. The second rule may be regarded as a form of -rule for .
The third rule reduces applications of the double negation elimination rule
nested in a certain trivial way.
134 Chapter 8. Classical logic and control operators
8.4.2. Warning. The reader should be warned that one nds in the liter-
ature dierent typed -calculi corresponding to classical logic that are not
merely simple variations of the above one. This is in particular true for the
system studied by Parigot|see, e.g, [82]|which is one of the most widely
cited approaches.
Also, dierent authors use dierent symbols for the term corresponding
to variants of the double negation elimination rule, e.g.  (Parigot [79, 80,
82, 81], Ong [78]),  (Rezus [91, 92]), and C (Grin [49] and Murthy [75, 76]);
the  is taken from Rehof and Srensen [89].
8.4.3. Remark. In the literature one nds dierent sets of reduction rules
for classical proofs, although almost every set contains a variant of the rst
of the above rules.
The following gives a characterization of the normal forms of -reduction,
i.e., a characterization of classical proofs without detours.
8.4.4. Definition. Let N be the smallest class of 

-terms closed under
the rule: M
1
; : : : ;M
n
2 N ) x
1
: : : : x
n
:y
1
: : : :y
m
:z M
1
: : :M
n
2 N
where n;m  0 and z may be an x
i
, a y
j
, or some other variable.
8.4.5. Proposition. If ? `M : ' in simply typed 

-calculus, andM 2 NF

,
then M 2 N .
Proof. By induction on the derivation of ? `M : '. ut
The proposition states that any normal proof proceeds by rst making
certain assumptions (reected by the variable z), then decomposing those
assumptions into simpler formulas by elimination rules (reected by the
applications z M
1
: : : M
n
), then using on the resulting formulas some ap-
plications of the double negation elimination rule (reected by y
i
:), and
nally by building up from the result more complicated formulas again by
introduction rules (reected by the abstractions x
i
:).
The following shows that the reduction rules are suciently strong that
the characterization of their normal forms entails consistency of the system.
8.4.6. Corollary. 6` ?.
Proof. If ` ? then ` M : ? for some closed M . By the strong normal-
ization theorem|which will be proved later|we can assume that M is in
normal form. Then by induction on the derivation of M 2 N show that
`M : ? is impossible. ut
8.5. Denability of pairs and sums 135
8.5. Denability of pairs and sums
We saw in the second section above that one can dene conjunction and
disjunction in classical propositional logic. Intuitively speaking, at the level
of terms, this suggest that we should be able to dene pairs and sums. In
this section we show that this is indeed possible. For simplicity we work in
this section with 

-terms a la Curry.
First we introduce the extension that corresponds to the full system
CPC(!;_;^).
8.5.1. Definition. The term language 

(
i
; in
i
) of type-free 

-calculus
extended with pairs and sums is dened by the grammar:


(
i
; in
i
) 3M ::= x j x:M jM M
0
j < M;M
0
> j 
i
(M)
j in
i
(M) j case(M ;x
0
:M
0
;x
00
:M
00
) jx:M
The simply typed 

-calculus extended with pairs and sums, denoted by


(!;_;^), has as type language the set L(!;_;^). The inference system
of 

(!;_;^) arises from that of 

(!) by addition of the usual rules a
la Curry for typing pairs and sums.
The following shows how to dene pairs and sums.
8.5.2. Definition. Dene the following abbreviations.
< P;Q > = z:z P Q;

i
(P ) = k:P (x
1
:x
2
:k x
i
);
in
i
(P ) = y
1
:y
2
:y
i
P ;
case(P ;x
1
:Q
1
;x
2
:Q
2
) = k:P (x
1
:kQ
1
) (x
2
:kQ
2
):
By some elementary calculations, one can then prove the following.
8.5.3. Proposition. Let M 2 

(
i
; in
i
) and let M
0
2 

(
i
; in
i
) be the
term obtained by expansion according to the abbreviations in the preceding
denition. Let ' 2 L(!;_;^) and let '
0
2 L(!) be the formula obtained by
replacing every occurrence of ^ and _ by their dening formulas according
to Denition 8.2.3.
1. If ? `M : ' in simply typed 

-calculus extended with pairs and sums,
then ? `M
0
: '
0
in the simply 

-calculus.
2. If M !

N (using reductions for pairs and sums) then M
0
!

N
0
,
where N
0
is the expansion of N according to the preceding denition.
The denition of pairs is the standard one from type-free -calculus (see
Chapter 1), while the projection construction is dierent from that normally
employed in type-free -calculus, viz. M (x
1
:x
2
:x
i
). This latter denition
136 Chapter 8. Classical logic and control operators
does not work because x
1
:x
2
:x
i
has type '
1
! '
2
! '
i
instead of the type
'
1
! '
2
! ?, which M expects. Changing the denition of conjunctive
types to solve the problem is not possible; it leads to the type of a pair
being dependent on which component a surrounding projection picks.
1
The
operator  solves the problem by means of an application which turns the
type of x
i
into ? regardless of i. When the projection is calculated, the k
reaches its  and can be removed by the second reduction rule for :

1
(< M
1
;M
2
>)  k:(f:f M
1
M
2
) x
1
:x
2
:k x
1
!

k:(x
1
:x
2
:k x
1
)M
1
M
2
!

k:k M
1
!

M
1
As mentioned earlier, the denition for disjunctive formulas above is
not standard in logic. The standard denition is (' ! ?) !  instead
of (' ! ?) ! ( ! ?) ! ?. However, when one tries to prove the de-
rived inference rules for this translation it turns out that the corresponding
constructions for injection and case analysis are very dierent from those
dening pairs and projections. Specically, to have the desired reduction
rule hold derived one would need to add extra power to . The present
denition and corresponding dened constructions can be motivated by cor-
responding denition in second-order logic, which we will encounter in a
later chapter.
8.6. Embedding into intuitionistic propositional logic
In this section we shall show that classical logic can be embedded into intu-
itionistic logic in a certain sense.
Translations like the following have been studied since the 1930s by Kol-
mogorov, Gentzen, Godel, and Kuroda.
8.6.1. Definition. Dene the translation k from implicational formulas to
implicational formulas by:
k() = ::
k(?) = ::?
k('!  ) = ::(k(')! k( ))
We aim to show that if ' is classically provable, then k(') is intuition-
istically provable. We do this by giving a translation of classical proofs of
' into intuitionistic proofs of k('). More precisely, the translation is stated
on terms representing these proofs.
1
If one is willing to settle for a weaker notion of pairs where both component must
have the same type, then this problem vanishes. This shows that pairs with components
of the same type can be represented in the simply typed -calculus.
8.6. Embedding into intuitionistic propositional logic 137
8.6.2. Definition. Dene the translation t from 

-terms to -terms by:
t(x) = k:x k
t(x:M) = k:k x:t(M)
t(M N) = k:t(M) (m:m t(N) k)
t(x:M) = k:(x:t(M)) (h:h j:i:i (j k)) z:z
The following shows that k denes an embedding of classical logic into
intuitionistic logic.
8.6.3. Proposition. If ? `M : ' in simply typed 

-calculus, then k(?) `
t(M) : k(') in simply typed -calculus.
This gives another proof of consistency of classical propositional logic: if
classical logic is inconsistent, so is intuitionistic logic.
8.6.4. Proposition. 6` ? in classical propositional logic.
Proof. If ` M : ? in classical propositional logic, then ` t(M) : ::?
in intuitionistic logic, and then ` t(M) z:z : ? in intuitionistic logic, a
contradiction. ut
The above proof gives a conservativity result: if ? is provable in classical
logic, ? is provable already in intuitionistic logic. The construction can
be generalized to other formulas than ?; in fact, this way one can prove
that any formula of form 8x9y : P (x; y), where P is a primitive recursive
predicate, is provable in classical arithmetic (i.e., Peano Arithmetic) i it
is provable in intuitionistic arithmetic (i.e., Heyting Arithmetic). Formulas
of this form are quite important since they include, e.g., every assertion
that some algorithm terminates (\for any input x there is a terminating
computation y"). In other words, as concerns provability of termination of
algorithms there is no dierence between intuitionistic and classical logic.
On the one hand, this means that constructivists should raise no ob-
jection to the use of classical logic in this special case since any classical
proof can be converted into an intuitionistic one of the same formula. Con-
versely, classical logicians cannot claim that any logical strength is lost by
the restriction to intuitionistic logic.
The following shows that the translation t internalizes  conversion by
-conversion.
8.6.5. Proposition. If M =

N then t(M) =

t(N).
By analyzing the connection between  and  in some more detail, one
can prove:
8.6.6. Proposition. If M 2 1

then t(M) 2 1

.
138 Chapter 8. Classical logic and control operators
8.6.7. Corollary. The relation !

is strongly normalizing on typable
terms.
Proof. By the preceding proposition, Proposition 8.6.3, and strong nor-
malization of simply typed -calculus. ut
8.7. Control operators and CPS translations
So far we have not revealed what the computational meaning of  is; in this
section we nally release the suspension:  is a control operator!
Control operators appear in functional programming languages like Scheme
(Call/cc), ML (exceptions), Lisp (catch and throw).
Let us illustrate, by way of example, how control operators can be used to
program eciently and concisely. We shall consider the problem of writing
a function M which takes a binary tree of integer nodes and returns the
result of multiplying all the node values. Of course, this problem raises the
eciency issue of what to do when a node value of 0 is encountered.
Our example programs will be written in syntactically sugared SCHEME,
the sugar being that instead of (define M N) we write M = N and in-
stead of (lambda (x) M) we write : x.M , and for (letrec ([f t]) t')
we write (let f = t in t').
Our rst solution is the straightforward purely functional one which
trades eciency o for elegance. We suppose given auxiliary functions mt?
testing for the empty tree, num selecting the node value of the root node,
lson and rson returning the left and right subtrees.
8.7.1. Example. (Functional, elegant, inecient version)
M1 = : t.(if (mt? t)
1
(* (num t) (* (M1 (lson t)))(M1 (rson t)))))
One can optimize M1 so as to stop multiplying as soon as a node value of 0 is
encountered. This can be done in purely functional style, by means of tests.
Our next solution embodies that strategy. Here we assume a constructor
EX and a test function EX? such that (EX M) tags M with the marker EX,
and EX? tests for the presence of the tag. Furthermore, we assume a 0 test
function zero?. The reader will probably agree that elegance (or at the
least conciseness) has now been traded o for eciency.
8.7.2. Example. (Functional, inelegant, ecient version)
M2 = : t.(if (mt? t)
1
(if (zero? (num t))
(EX 0)
8.7. Control operators and CPS translations 139
(let ((l (M2 (lson t))))
(if (EX? l)
(let ((r (M2 (rson t))))
(if (EX? r)
r
(* (num t) (* l r))))))))
The function M2 will return an integer, the product of all the tree nodes, if
no node contains 0, or the value (EX 0) if any node contains 0. We may
see the EX tag as a kind of exception marker which is propagated explicitly
up the recursion tree. In this vein one could view the EX constructor as an
injection function taking an integer to an element of a sum type of the form
int _ ex. Now, the catch/throw mechanism is well suited to handle exactly
this kind of problem where an exceptional value is propagated. Eciency is
enhanced by catch and throw because all the propagation is done in a single
step (or jump, as we might say). This leaves us with a relatively elegant and
ecient but non functional version, as shown in the next example program.
8.7.3. Example. (Non functional, elegant, ecient version)
M3 = : t. catch j in
(let L = : t'.(if (mt? t')
1
(if (zero? (num t'))
(throw j 0)
(* (num t')
(* (L (lson t'))(L (rson t'))))))
in (L t))
It is an interesting fact that the mechanism used in Example 8.7.3 can be
internalized in the purely functional part of the language by the so-called
CPS-transformation technique. Applying that translation to the program
with catch and throw gives:
8.7.4. Example. (CPS version of M3)
M4 = : t. : k.
(if (mt? t)
(k 1)
(if (zero? (num t))
0
((M4 (lson t))
(: l.((M4 (rson t))
(: r.(k (* (num t) (* l r)))))))))
The non-functional program can be written as follows in the type-free


-calculus.
140 Chapter 8. Classical logic and control operators
M = t: j:j
(Y (f:t
0
: (if (mt? t
0
)
1
(if (zero? (num t
0
))
"(j 0)
(* (num t
0
)
(* (f (lson t
0
))(f (rson t
0
))))))) t),
whereY denotes Church's xpoint combinator and "(M) abbreviates x:M ,
for x 62 FV(M).
It is instructive to verify that, e.g., for T  <2,<0,nil,nil>,nil>, we
have MT = 0, noticing how an \exception" is raised as the node value 0 is
encountered.
In conclusion, the  may be regarded as a control operator similar to
call/cc of Scheme and exceptions of ML, and the double negation embedding
of classical logic into intuitionisitic logic corresponds to well-known CPS-
translations of terms with control operators into pure, control-operator-free
languages.
8.8. Historical remarks
Felleisen and his co-workers studied -calculi with control operators in an
untyped setting. Their aim was to provide a foundation of type-free func-
tional programming langauges with control operators similarly to the way
-calculus may be regarded as a foundation of type-free pure functional
programming languages.
Felleisen devised a control calculus, an extension of the -calculus, and
carried out what could aptly be called Plotkin's program (see [83]) for the
study of the relation between calculi and programming languages.
Grin discovered in 1990, in an attempt to incorporate control operators
into the world of typed -calculi, that Felleisen's C-operator could be typed
by the classical double negation elimination rule [49]. Using this rule does,
however, lead to certain diculties because typing is not in general preserved
under reduction (\Failure of Subject Reduction.") This defect was repaired
by Grin via a so-called computational simulation.
Later, Murthy overcame the same diculties by changing the type sys-
tem into a so-called pseudo-classical logic. Applying conservativity results
of classical logics over corresponding minimal logics Murthy showed in [75]
that for a certain class of classically provable formulas the Realizability In-
terpretation remains sound. This was done using CPS-translations of control
operator calculi into pure -calculi.
Since the seminal work of Grin and Murthy, numerous systems have
appeared that connect classical logic and control operators; indeed, the study
of classical logic in connection with the Curry-Howard isomorphism now
8.9. Exercises 141
constitutes a separate eld.
8.9. Exercises
8.9.1. Exercise. Prove Proposition 8.1.3.
8.9.2. Exercise.
1. Show that Peirce's law can be derived from the special case of Peirce's
law and ex-falso.
2. Show that double negation elimination can be derived from the special
case of Peirce's law and ex-falso.
3. Show that the special case of Peirce's law and ex-falso can both be
derived from double negation elimination.
8.9.3. Exercise. Prove that ? ` ' can be derived in the system of Deni-
tion 8.1.2 i ? ` ' can be derived in the system of Remark 8.1.4.
8.9.4. Exercise. Let ' be some implicational formula such that 6` ' in
CPC(!), and consider the system Z which arises from CPC(!) by adding
all instances (substituting implicational formulas for propositional variables)
of ' as axioms. Show that ` ? in Z.
8.9.5. Exercise. prove Proposition 8.2.2.
8.9.6. Exercise. Show that in CPC(!;_;^) one can derive `  _ :.
8.9.7. Exercise. The rule
(x::('!  ):M) N !

z:: :Mfx := y :'!  : z (y N)g
can only reduce 's inside an application. The following aggressive variant
does not wait for the application:
(x::('!  ):M)!

a :' : z:: :Mfx := y :'!  : z (y a)g
Corresponding to these two dierent rules, give reduction rules for the con-
structs 
i
(x::(' ^  ):M) and x::(' ^  ):M .
Can you give corresponding rules for disjunction?
8.9.8. Exercise. Show that!

on 

-terms a la Curry is Church-Rosser,
or show that !

on 

-terms a la Curry is not Church-Rosser.
Same question for !

on terms a la Church.
8.9.9. Exercise. Does the following hold? For any M 2 

, M 2 N i
M 2 NF

.
142 Chapter 8. Classical logic and control operators
CHAPTER 9
First-order logic
In this chapter we extend our consideration to formulas with quantiers and
generalize the proof systems and interpretations seen in earlier chapters to
the rst-order case.
9.1. Syntax of rst-order logic
The objects investigated by propositional logic are compound statements,
built from some atomic statements (represented by propositional variables)
by means of logical connectives. The goal is to understand relations be-
tween compound statements depending on their structure, rather than on
the actual \meaning" of the atoms occurring in these statements. But math-
ematics always involves reasoning about individual objects, and statements
about properties of objects can not always be adequately expressed in the
propositional language. The famous syllogism is an example:
All humans are mortal;
Socrates is a human;
Therefore Socrates is mortal.
To express this reasoning in the language of formal logic, we need to quantify
over individual objects (humans), and of course we need predicates (rela-
tions) on individual objects. The logical systems involving these two features
are known under the names \predicate logic", \predicate calculus", \quanti-
er calculus" or \rst-order logic". This section describes a variant of the
rst-order syntax. Such syntax is always dened with respect to a xed
rst-order signature , which is typically assumed to be nite. Recall from
Chapter 6 that a signature is a family of function, relation and constant
symbols, each with a xed arity. Also recall that algebraic terms over  are
individual variables, constants and expressions of the form (ft
1
: : : t
n
), where
f is an n-ary function symbol, and t
1
; : : : ; t
n
are algebraic terms over .
143
144 Chapter 9. First-order logic
9.1.1. Definition.
1. An atomic formula is an expression of the form (rt
1
: : : t
n
), where r is
an n-ary relation symbol, and t
1
; : : : ; t
n
are algebraic terms over .
2. The set 

of rst-order formulas over , is the least set such that:
 All atomic formulas and ? are in 

;
 If '; 2 

then ('!  ); (' _  ); (' ^  ) 2 

;
 If ' 2 

and x is an individual variable, then 8x';9x' 2 

.
3. As usual, we abbreviate (' ! ?) as :' and ((' !  ) ^ ( ! ')) as
('$  ).
4. A formula is open i it contains no quantiers.
9.1.2. Convention. The parentheses-avoiding conventions used for propo-
sitional formulas apply as well to rst-order formulas. However, there is no
general consensus about how quantiers should be written. One convention,
which is common in logic, is that a quantier is an operator of highest pri-
ority, so that \8x' !  " stands for \(8x') !  ". The other convention
seems to have originated in type theory and is that the quantier scope
extends as much to the right as possible. In order to avoid confusion, we
will sometimes use extra parentheses and sometimes we will use an explicit
dot notation. Namely, we will write \8x:' !  " for \8x(' !  )" and
\8x': !  " instead of \(8x') !  ". (Needless to say, authors sometimes
forget about such conventions. The reader should be warned that each of
the two authors has got used to a dierent style.)
9.1.3. Definition.
1. If t is an algebraic term then FV (t) stands for the set of all variables
occurring in t.
2. The set FV (') of free variables of a formula ' is dened by induction:
 FV (rt
1
: : : t
n
) = FV (t
1
) [ : : : [ FV (t
n
);
 FV ('!  ) = FV (' _  ) = FV (' ^  ) = FV (') [ FV ( );
 FV (8x') = FV (9x') = FV (') ? fxg.
3. A sentence, also called a closed formula, is a formula without free
variables.
9.1.4. Definition. The denition of a substitution of a term for an individ-
ual variable, denoted '[x := t], respects the quantiers as variable-binding
operators, and thus must involve variable renaming. Formally,
9.2. Intuitive semantics 145
x[x := t] = t;
y[x := t] = y; if y 6= x;
(ft
1
: : : t
n
)[x := t] = ft
1
[x := t] : : : t
n
[x := t];
(rt
1
: : : t
n
)[x := t] = rt
1
[x := t] : : : t
n
[x := t];
(8x')[x := t] = 8x';
(8y')[x := t] = 8y'[x := t], if y 6=x, and y 62 FV(t) or x 62 FV(');
(8y')[x := t] = 8z'[y := z][x := t], if y 6= x and y 2 FV(t) and x 2 FV(');
(9x')[x := t] = 9x';
(9y')[x := t] = 9y'[x := t] if y 6= x, and y 62 FV(t) or x 62 FV(');
(9y')[x := t] = 9z'[y := z][x := t] if y 6= x and y 2 FV(t) and x 2 FV(').
where z is a fresh variable.
The simultaneous substitution, written '[x
1
:= t
1
; : : : ; x
n
:= t
n
], is the
term
'[x
1
:=s
1
]    [x
n
:=s
n
][y
1
1
:=z
1
1
]    [y
1
m
1
:=z
1
m
1
]    [y
n
1
:=z
n
1
]    [y
n
m
n
:=z
n
m
n
];
where z
i
1
; : : : ; z
i
m
i
are all variables in t
i
, the variables y
i
j
are all fresh and
dierent, and s
i
= t
i
[z
i
1
:=y
i
1
]    [z
i
m
i
:=y
i
m
i
], for all i.
9.1.5. Convention. It is a common convention to write e.g., '(x; y; z) in-
stead of ', to stress that x; y; z may occur in '. In this case, the notation
like '(t; s; u) is used as a shorthand for '[x := t; y := s; z := u]. We will
also use this convention, but one should be aware that it is not a part of the
syntax.
It is not customary to introduce alpha-conversion on rst-order formu-
las. Typically, alpha-equivalent formulas are considered dierent, although
they are equivalent with respect to all reasonable semantics, and one can
be derived from another with all reasonable proof systems. However, for
uniformity of our presentation, we prefer to allow for the alpha-conversion
(dened in the obvious way) and identify alpha-convertible formulas from
now on.
9.2. Intuitive semantics
The Brouwer-Heyting-Kolmogorov interpretation of propositional formulas
(Chapter 2) extends to rst-order logic as follows:
 A construction of 8x'(x) is a method (function) transforming every
object a into a construction of '(a).
 A construction of 9x'(x) is a pair consisting of an object a and a
construction of '(a).
Note that the BHK-interpretation should be taken with respect to some do-
main of \objects". These objects are syntactically represented by algebraic
terms.
146 Chapter 9. First-order logic
9.2.1. Example. Consider the following formulas:
1. :9x':$ 8x:';
2. :8x':$ 9x:';
3. ( ! 8x'(x))$ 8x( ! '(x)), where x 62 FV ( );
4. ( ! 9x'(x))$ 9x( ! '(x)), where x 62 FV ( );
5. 8x('!  )! (9x':! 9x );
6. 8x( _ '(x))$  _ 8x'(x), where x 62 FV ( );
7. 8x('!  ):! (8x':! 8x );
8. (8x'(x):!  )! 9x('(x)!  ), where x 62 FV ( );
9. 8x'(x):! '(t);
10. ::8x(' _ :');
11.  ! 8x , where x 62 FV ( );
12. 9x(9y '(y):! '(x))
Although all these formulas are all classical rst-order tautologies,
1
one will
have diculties nding BHK-interpretations for some of them.
9.2.2. Remark. It should be no surprise when we say that universal quan-
tication is a generalization of conjunction. Indeed, the sentence \all cats
have tails" is quite like an innite conjunction of statements concerning each
individual cat separately. In quite the same spirit one can say that existen-
tial quantication is a generalized disjunction. This idea is reected by the
algebraic semantics, where we interpret quantiers as (possibly innite) joins
and meets, see Denitions 9.4.3 and 9.4.4.
But the BHK-interpretation as above hints for another correspondence:
between universal quantication and implication, because in both cases we
have a function as a construction. The analogy is so strong that in certain
systems with quantiers, implication is just syntactic sugar. We will see it
in Chapters 10 and 13.
9.3. Proof systems
The three main approaches: natural deduction, sequent calculus and the
Hilbert style extend to rst-order logic by adding suitable rules and axioms
to the rules and axiom schemes for propositional logic. The notation `
N
,
`
L
, etc., is the obvious modication from the propositional case.
1
We assume that the reader is familiar with classical rst-order logic. A suggested
textbook is e.g. [70].
9.3. Proof systems 147
Natural deduction
We extend the system of natural deduction with the following rules to in-
troduce and eliminate quantiers:
(8I)
? ` '
? ` 8x'
(x 62 FV (?)) (8E)
? ` 8x'
? ` '[x := t]
(9I)
? ` '[x := t]
? ` 9x'
(9E)
? ` 9x' ?; ' `  
? `  
(x 62 FV (?;  ))
The reader should be warned that our rules are such because we have agreed
on alpha-conversion of formulas. Otherwise, one has to modify rules (8I)
and (9E) to work for any alpha-variant of the quantier bindings. Similar
modications would have to be done on the other proof systems to follow.
Sequent calculus
Here are classical sequent calculus rules for quantiers. Note the symmetry
between the two quantiers.
(8L)
?; '[x := t] ` 
?;8x' ` 
(8R)
? ` ';
? ` 8x';
(x 62 FV (?;))
(9L)
?; ' ` 
?;9x' ` 
(x 62 FV (?;)) (9R)
? ` '[x := t];
? ` 9x';
To obtain intuitionistic sequent calculus we restrict ourselves to single for-
mulas at the right-hand sides ( consists of a single formula and  is always
empty).
(8L)
?; '[x := t] ` 
?;8x' ` 
(8R)
? ` '
? ` 8x'
(x 62 FV (?))
(9L)
?; ' ` 
?;9x' ` 
(x 62 FV (?; )) (9R)
? ` '[x := t]
? ` 9x'
9.3.1. Theorem (Cut elimination). For all ' and ?, if the sequent ? ` '
has a proof then it has a cut-free proof.
The following was probably rst shown by Rasiowa and Sikorski using
the topological space semantics, see [88].
9.3.2. Corollary (Existence property). If ` 9x' then there exists a term t
such that ` '[x := t].
148 Chapter 9. First-order logic
Proof. The last rule in a cut-free proof of ` 9x' must be (9R). ut
Note that if the signature consists of relation symbols only (and thus the
only terms are variables) then ` 9x' implies ` 8x' !
Hilbert-style proofs
It is dicult to nd two dierent authors who would give identical Hilbert-
style proof systems.
2
Our choice is as follows. We take as axioms all the
propositional axiom schemes, and in addition all formulas of the form:
 8x'(x):! '(t);
 '(t)! 9x'(x);
  ! 8x , where x 62 FV ( );
 9x :!  , where x 62 FV ( );
 8x('!  ):! (9x':! 9x );
 8x('!  ):! (8x':! 8x ).
As inference rules of our system we take modus ponens and the following
generalization rule:
'
8x'
The use of generalization requires some caution (corresponding to the side
conditions in rules (8I) and (8R)).
9.3.3. Definition. A formal proof of a formula ' from a set ? of assump-
tions is a a nite sequence of formulas  
1
;  
2
; : : : ;  
n
, such that  
n
= ',
and for all i = 1; : : : ; n, one of the following cases takes place:
  
i
is an axiom;
  
i
is an element of ?;
 there are j; ` < i such that  
j
=  
`
!  
i
(i.e.,  
i
is obtained from  
j
,
 
`
using modus ponens);
 there is j < i such that  
i
= 8x 
j
, for some x 62 FV (?) (i.e.,  
i
is
obtained from  
j
by generalization).
2
Unless they are co-authors, of course.
9.3. Proof systems 149
9.3.4. Warning. In many textbooks, the above denition of a proof does
not include the restriction on applicability of the generalization rule. This
does not matter as long as ? is a set of sentences (what is typically assumed).
In general however, this gives a dierent relation `

H
, such that
? `

H
' i ?

`
H
';
where ?

is obtained from ? by binding all free variables by universal quanti-
ers placed at the beginning of all formulas. For this relation, the deduction
theorem (see below) would only hold for ? consisting of sentences.
9.3.5. Lemma (Deduction Theorem).
The conditions ?; ' `
H
 and ? `
H
'!  are equivalent.
Proof. Easy. ut
9.3.6. Theorem. Natural deduction, sequent calculus, and the above Hilbert-
style proof system are all equivalent, i.e., ? `
N
' and ? `
L
' and ? `
H
'
are equivalent to each other for all ? and '.
Proof. Boring. ut
Translations from classical logic
Double negation translations from classical to intuitionistic logic can be ex-
tended to the rst-order case. We add the following clauses to the denition
of the Kolmogorov translation of Chapter 8:
 t(8x') := ::8x t(');
 t(9x') := ::9x t(').
and we still have the following result:
9.3.7. Theorem. A formula ' is a classical theorem i t(') is an intuition-
istic theorem.
Proof. Exercise 9.5.6 ut
Since classical provability reduces to intuitionistic provability, and classical
rst-order logic is undecidable, we obtain undecidability of intuitionistic
rst-order logic as a consequence.
9.3.8. Corollary. First-order intuitionistic logic is undecidable.
In fact, the undecidability result holds already for a very restricted frag-
ment of rst-order intuitionistic logic, with 8 and! as the only connectives
and with no function symbols. In particular, there is no need for negation
or falsity.
150 Chapter 9. First-order logic
9.4. Semantics
We begin with classical semantics. Assume that our signature  consists of
the function symbols f
1
; : : : ; f
n
, relation symbols r
1
; : : : ; r
m
and constant
symbols c
1
; : : : ; c
k
.
9.4.1. Definition. A structure or model for  is an algebraic system A =
hA; f
A
1
; : : : ; f
A
n
; r
A
1
; : : : ; r
A
m
; c
A
1
; : : : ; c
A
k
i, where the f
A
i
's and r
A
i
's are respec-
tively operations and relations over A (of appropriate arities) and the c
A
i
's
are distinguished elements of A.
9.4.2. Convention.
 Typical notational conventions are to forget about the superscript
A
in
e.g., f
A
, and to identify A and A. (Otherwise we may write A = jAj.)
 We think of relations in A as of functions ranging over the set f0; 1g
rather than of sets of tuples.
9.4.3. Definition.
1. Let t be a term with all free variables among ~x, and let ~a be a vector of
elements of A of the same length as ~x. We dene the value t
A
(~a) 2 A
by induction:
 (x
i
)
A
(~a) = a
i
;
 (ft
1
: : : t
n
)
A
(~a) = f
A
(t
A
1
(~a); : : : ; t
A
n
(~a)).
2. Let ' be a formula such that all free variables of ' are among ~x, and
let ~a be as before. We dene the value '
A
(~a) 2 f0; 1g, as follows
 ?
A
(~a) = 0;
 (rt
1
: : : t
n
)
A
(~a) = r
A
(t
A
1
(~a); : : : ; t
A
n
(~a));
 (' _  )
A
(~a) = '
A
(~a) [  
A
(~a);
 (' ^  )
A
(~a) = '
A
(~a) \  
A
(~a);
 ('!  )
A
(~a) = '
A
(~a))  
A
(~a);
 (8y '(y; ~x))
A
(~a) = inff'(y; ~x)
A
(b;~a) : b 2 Ag;
 (9y '(y; ~x))
A
(~a) = supf'(y; ~x)
A
(b;~a) : b 2 Ag,
where the operations [, \, ), inf and sup, and the constant 0 are in
the two-element Boolean algebra of truth values. (Of course, we have
a ) b = (1 ? a) [ b.) We write A;~a j= '(~x) i '
A
(~a) = 1, and we
write A j= '(~x) i A;~a j= '(~x), for all ~a. We write ? j= ' i for all A
and ~a with A;~a j=  , for all  2 ?, we also have A;~a j= '.
9.4. Semantics 151
The above denition can now be generalized so that values of formulas are
not necessarily in f0; 1g, but in the algebra P (X) of all subsets of a certain
set X. Relations over A may now be seen as functions ranging over P (X)
rather than f0; 1g, i.e., the notion of a structure is more general. One can go
further and postulate values of formulas in an arbitrary Boolean algebra B.
This will work as well, provided B is a complete algebra, i.e., all innite
sup's and inf's do exist in B. (Otherwise, values of some quantied formulas
could not be dened.)
One can show that these generalizations do not change the class of clas-
sically valid statements of the form ? j= ' (Exercise 9.5.7). We do not
investigate this further, since classical logic serves us as an illustration only.
Algebraic semantics
An obvious idea how to adopt the above approach to intuitionistic logic is
to replace complete Boolean algebras by complete Heyting algebras.
9.4.4. Definition.
1. An intuitionistic H-structure for  is a system
A = hA; f
A
1
; : : : ; f
A
n
; r
A
1
; : : : ; r
A
m
; c
A
1
; : : : ; c
A
k
i,
where the f
A
i
's and r
A
i
's and c
A
i
's are as before, and the r
A
i
's are
functions of appropriate arity from A to a complete Heyting algebraH.
2. The values of terms and formulas are dened as in Denition 9.4.3,
except that operations [, \, inf, sup and ) are in H.
3. The notation A;~a j= '(~x) and A j= '(~x) is as in Denition 9.4.3.
4. The notation ? j= ' should be understood as follows: \For all H
and all H-structures A and vectors ~a, with A;~a j= ?, we also have
A;~a j= '".
5. The symbol j=
K
is j= restricted to any given class K of complete Heyt-
ing algebras.
An example of a complete Heyting algebra is the algebra of open sets of a
topological space (in particular a metric space), where sup is set-theoretic
S
,
and
inffA
i
: i 2 Ig = Int(
T
fA
i
: i 2 Ig):
9.4.5. Theorem.
The following conditions are equivalent for the intuitionistic rst-order
logic:
1. ? ` ', where \`" is either \`
N
" or \`
L
" or \`
H
";
152 Chapter 9. First-order logic
2. ? j= ';
3. ? j=
K
', where K is the class of (algebras of open sets of) all metric
spaces.
It seems to be still an open problem whether the class of all metric spaces
can be replaced by a one-element class consisting only of R
2
. But it can
be shown that there exists a single metric space of this property, see [88].
(Note however that R
2
can still be used for counterexamples.)
Kripke semantics
An alternative way of relaxing the denition of classical semantics is to keep
the classical notion of a model, but think of models as of possible worlds.
9.4.6. Definition. A structureA = hA; f
A
1
; : : : ; f
A
n
; r
A
1
; : : : ; r
A
m
; c
A
1
; : : : ; c
A
k
i
is a substructure of B = hB; f
B
1
; : : : ; f
B
n
; r
B
1
; : : : ; r
B
m
; c
B
1
; : : : ; c
B
k
i i the follow-
ing hold:
 A  B;
 r
A
i
 r
B
i
, for all i;
 f
A
i
 f
B
i
, for all i;
 c
A
i
= c
B
i
, for all i.
Thus, B extends the possible world A by enriching the domain of available
objects and by adding more information about known objects. We write
A  B to express that A is a substructure of B.
9.4.7. Definition. A Kripke model for rst-order logic is a triple of the
form C = hC;; fA
c
: c 2 Cgi, where C is a non-empty set,  is a partial
order in C, and A
c
's are structures such that
if c  c
0
then A
c
 A
c
0
:
Let now ' be a formula such that all free variables of ' are among ~x, and
let ~a be a vector of elements of A
c
of the same length as ~x. We dene the
relation  by induction as follows:
 c;~a  rt
1
: : : t
n
i A
c
;~a j= rt
1
: : : t
n
(classically);
 c;~a 1 ?;
 c;~a  ' _  i c;~a  ' or c;~a   ;
 c;~a  ' ^  i c;~a  ' and c;~a   ;
9.5. Exercises 153
 c;~a  '!  i c
0
;~a   , for all c
0
such that c  c
0
and c
0
;~a  ';
 c;~a  9y '(y; ~x) i c; b;~a  '(y; ~x), for some b 2 A
c
;
 c;~a  8y '(y; ~x) i c
0
; b;~a  '(y; ~x), for all c
0
such that c  c
0
and
all b 2 A
c
0
.
The symbol  is now used in various contexts as usual, in particular ?  '
means that c;~a  ' whenever c;~a  ?.
9.4.8. Theorem. The conditions ?  ' and ? j= ' are equivalent.
More about semantics can be found in [88, 106, 107, 108].
9.5. Exercises
9.5.1. Exercise. Find constructions for formulas (1), (3), (5), (7), (9) and (11)
of Example 9.2.1, and do not nd constructions for the other formulas.
9.5.2. Exercise. A rst-order formula is in prenex normal form i it begins
with a sequence of quantiers followed by an open formula. Consider a
signature with no function symbols, and let ' be an intuitionistic theorem
in a prenex normal form. Show that there exists an open formula '
0
obtained
from ' by removing quantiers and by replacing some variables by constants,
and such that ` '
0
. Hint: Use the existence property (Corollary 9.3.2).
9.5.3. Exercise (V.P. Orevkov). Apply Exercise 9.5.2 to show that the prenex
fragment of intuitionistic rst-order logic over function-free signatures is
decidable. (In fact, this remains true even with function symbols in the
signature, but fails for logics with equality, see [29]).
9.5.4. Exercise. Prove that every rst-order formula is classically equiv-
alent to a formula in prenex normal form. Then prove that intuitionistic
rst-order logic does not have this property.
9.5.5. Exercise. Show that the existence property (Corollary 9.3.2) does
not hold for classical logic. Why does the proof break down in this case?
9.5.6. Exercise. Prove Theorem 9.3.7.
9.5.7. Exercise. Let X be an arbitrary set with more than one element.
Show that the semantics of classical logic where values of formulas are taken
in the family P (X) of all subsets ofX is equivalent to the ordinary semantics.
That is, the sets of tautologies are the same.
9.5.8. Exercise. Verify that the odd-numbered formulas of Example 9.2.1
are intuitionistically valid, while the even-numbered ones are not.
154 Chapter 9. First-order logic
9.5.9. Exercise. Show that the following classical rst-order tautologies are
not valid intuitionistically:
 9x('(x)! 8x'(x));
 9x('(0) _ '(1)! '(x));
 8x::'(x):$ ::8x'(x);
 9x::'(x):$ ::9x'(x).
9.5.10. Exercise. A Kripke model C = hC;; fA
c
: c 2 Cgi has constant
domains i all the A
c
are the same. Prove that the formula 8x( _'(x))$
 _ 8x'(x), where x 62 FV ( ) (formula (6) of Example 9.2.1) is valid in all
models with constant domains.
9.5.11. Exercise. Prove that the formula ::8x(' _ :') (formula (10) of
Example 9.2.1) is valid in all Kripke models with nite sets of states.
CHAPTER 10
Dependent types
Dependent types can probably be considered as old as the whole idea of
propositions-as-types. Explicitly, dependent types were perhaps rst used
in various systems aimed at constructing and verifying formal proofs. One of
the rst was the project AUTOMATH of de Bruijn, see [28]. Another such
system that gained much attention is the Edinburgh Logical Framework (LF)
of Harper, Honsell and Plotkin [51]. The expression \logical frameworks"
is now used as a generic name for various similar calculi, see [59]. Last but
not least, one should mention here Martin-Lof's type theory [77]. For more
references, see [108, 51, 8]. Our presentation of dependent types follows
essentially that of [8].
From a programmer's point of view, a dependent type is one that depends
on an object value. For instance, one may need to introduce a type string(n)
of all binary strings of length n.
1
This type depends on a choice of n : int .
The operator string makes a type from an integer, and corresponds, under
the Curry-Howard isomorphism, to a predicate over int . Such a predicate
is called a type constructor , or simply constructor . Of course, we have to
classify constructors according to their domains, and this leads to the notion
of a kind : we say that our constructor string is of kind int ) , where  is the
kind of all types. Of course, there is no reason to disallow binary predicates,
and so on, and thus the family of kinds should include 
1
)    
n
) .
A denition of an object of type string(n) may happen to be uniform
in n, i.e., we may have a generic procedure Onlyzeros that turns any n : int
into a string of zeros of length n. The type of such a procedure should be
written as (8x:int)string(x).
In general, a type of the form (8x:) is a type of a function applicable
to objects of type  and returning an object of type [x := a], for each
argument a :  . It is not dicult to see that this idea is more general than
the idea of a function type. Indeed, if x is not free in , then (8x:) behaves
1
Example from [74].
155
156 Chapter 10. Dependent types
exactly as  ! . Thus, in presence of dependent types there is no need to
introduce ! separately.
The set-theoretic counterpart of a dependent type is the product . Recall
that if fA
t
g
t2T
is an indexed family of sets (formally a function that assigns
the set A
t
to any t 2 T )
2
then the product of this family is the set:
Y
t2T
A
t
= ff 2 (
[
t2T
A
t
)
T
: f(t) 2 A
t
; for all t 2 Tg:
For f 2
Q
t2T
A
t
, the value of f(t) is in a set A
t
, perhaps dierent for each
argument, rather than in a single co-domain A. If all A
t
are equal to a xed
set A, we obtain the equality
Y
t2T
A
t
= A
T
;
corresponding to our previous observation about ! versus 8.
The logical counterpart of this should now be as follows: the implication
is a special case of universal quantication. And that is correct, because we
have already agreed to identify objects of type  with proofs of  . We only
have to agree that this way of thinking applies to individual objects as well,
so that, for instance, an integer can be seen as a proof of int .
10.1. System P
We will now dene the Church-style system P of dependent types. We
begin with a calculus without existantial quantication, as in [8]. Unfortu-
nately, even without existantial quantiers, the language of P is a broad
extension of the language of simply-typed lambda-calculus. We have three
sorts of expressions: object expressions (ranged over by M;N , etc.), con-
structors (ranged over by ; ', etc.) and kinds (ranged over by ;
0
, etc.).
There are object and constructor variables (ranged over by x, y, : : : and
; , : : : , respectively), and one kind constant . A type is treated as a
special case of a constructor, so we do not need extra syntax for types.
Contexts can no longer be arbitrary sets of assumptions. This is because
in order to declare a variable of type e.g., x, one has to know before that
the application is legal, i.e., that the type of x ts the kind of . Thus,
contexts in P are dened as sequences of assumptions. In addition, not
every sequence of declarations can be regarded as a valid context, and being
valid or not depends on derivability of certain judgements.
For similar reasons, being a constructor or a kind, also depends on deriv-
able judgements. Well-formed types, kinds and contexts are thus formally
dened by the rules of our system.
2
That is why we do not use here the set notation fA
t
: t 2 Tg.
10.1. System P 157
Unfortunately, we cannot stick to) as the only way to build kinds, and
we have to introduce a more general product operator also at the level of
kinds. To understand why, see Example 10.2.3(2).
10.1.1. Definition.
1. Raw expressions (raw contexts ?, raw kinds , raw constructors  and
raw lambda-terms M) are dened by the following grammar:
? ::= fg j ?; (x : ) j ?; ( : );
 ::=  j (x : );
 ::=  j (8x:) j (M);
M ::= x j (MM) j (x::M).
2. Beta reduction on raw terms is dened as follows:
 (x::M)N !

M [N := x];
 If  !


0
then x::M !

x:
0
:M ;
 If M !

M
0
then x::M !

x::M
0
and NM !

NM
0
and
MN !

M
0
N ;
 If  !


0
then (x : )!

(x : 
0
);
 If !


0
then (x : )!

(x : )
0
;
 If  !


0
then (8x:) !

(8x:
0
);
 If  !


0
then (8x:) !

(8x:)
0
;
 If '!

'
0
then 'M !

'
0
M ;
 If M !

M
0
then 'M !

'M
0
.
3. If (x : ) or ( : ) is in ? then we write ?(x) =  or ?() = ,
respectively. We also write Dom(?) for the set of all constructors and
object variables declared in ?.
4. We skip the obvious denition of free variables. Of course, there are
three binding operators now: lambda-abstraction, quantication and
the product of kinds. And we also omit the denition of substitution.
5. We use arrows as abbreviations: if x is not free in  then we write
 )  instead of (x : ). And if x is not free in  then (8x:) is
abbreviated by our good old implication  ! .
10.1.2. Remark. In order to spare the reader some additional noise, we
choose a non-standard presentation of P, namely we do not allow lambda
abstractions in constructors. Thus, every constructor must be of the form
(8x:
1
)    (8x:
n
)M
1
: : :M
n
. This restriction is not essential as long as our
primary interest is in types. Indeed, a dependent type in normal form always
obeys this pattern, and a term substitution may never create a constructor
redex.
158 Chapter 10. Dependent types
We will have three dierent sorts of judgements in our system:
 kind formation judgements of the form \? `  : 2";
 kinding judgements of the form \? ` ' : ";
 typing judgements of the form \? `M : ".
The meaning of \ : 2" is just that  is a well-formed kind, and 2 itself is
not a part of the language.
10.2. Rules of P
Kind formation rules:
`  : 2
?; x :  `  : 2
? ` (x:) : 2
Kinding rules:
? `  : 2
?;  :  `  : 
( 62 Dom(?))
? ` ' : (x:) ? `M : 
? ` 'M : [x :=M ]
?; x :  `  : 
? ` (8x:) : 
Typing rules:
? `  : 
?; x :  ` x : 
(x 62 Dom(?))
? ` N : (8x:) ? `M : 
? ` NM : [x :=M ]
?; x :  `M : 
? ` x::M : (8x:)
Note that there is no restriction \x 62 FV(?)" attached to the 8-introduction
rule. This restriction is unnecessary because otherwise ?; x :  would not be
a valid context, in which case the premise could not be derived.
Weakening rules:
There are six weakening rules, but all obey the same pattern: an additional
assumption does not hurt, as long as it is well-formed. We need explicit
wekening (rather than relaxed axioms) because of the sequential structure
of contexts we must respect.
? `  :  ? `  : 2
?; x :  `  : 2
(x 62 Dom(?))
? `  : 2 ? ` 
0
: 2
?;  :  ` 
0
: 2
( 62 Dom(?))
10.3. Properties of P 159
? `  :  ? ` ' : 
?; x :  ` ' : 
(x 62 Dom(?))
? `  : 2 ? ` ' : 
0
?;  :  ` ' : 
0
( 62 Dom(?))
? `  :  ? `M : 
?; x :  `M : 
(x 62 Dom(?))
? `  : 2 ? `M : 
?;  :  `M : 
( 62 Dom(?))
Conversion rules
These rules are necessary because of the terms occurring in types which do
not have to be in normal forms.
? ` ' :   =


0
? ` ' : 
0
? `M :   =


0
? `M : 
0
10.2.1. Remark. Note that type-checking in P is not a trivial task, even
if our language is Church-style. This is because the conversion rules. A
verication whether two types or kinds are equal may be as dicult as
checking equality of simply-typed lambda terms, and this decision problem
is non-elementary (Theorem 6.7.1).
10.2.2. Definition.
If ? `  :  then we say that  is a type in the context ?.
10.2.3. Example.
1. The lambda term y:(8x:0:x ! x):z:(8x:0:x):x:0:yx(zx) has
type (8x:0:x! x)! (8x:0:x)! 8x:0:x in the context consisting
of declarations  : 0)  and  : 0) .
2. Here is an example of a kind that cannot be expressed only with ):
 : 0)  ` (y:0)(y ) ) : 2
If we now declare a variable ' to be of this kind, we can consider types
of the form 'yx, where x is of type y.
10.3. Properties of P
System P has the Church-Rosser and strong normalization properties.
These facts follow from properties of simply typed terms, thanks to an
embedding M 7! M

, described in [51]. Certain variants of this embed-
ding (esp. the \forgetting map" M 7! M , which erases all dependencies)
were also discovered by V. Breazu-Tannen and Ch. Paulin, but apparently
R.O. Gandy was the rst to use this approach (see [108, p. 565]).
160 Chapter 10. Dependent types
10.3.1. Definition. We dene the dependency-erasure map on construc-
tors:
 = ;
(8x : ) =  ! ;
'M = '.
We write ? for the contexts obtained by applying the above operation to all
right-hand sides of declarations in ? of the form (x : ), and removing other
declarations.
10.3.2. Definition. The translations M 7! M

and  7! 

are dened
for both types and terms of P. Both terms and types are translated into
terms. Below, 0 stands for a xed type variable. Abusing the formalism a
little, we assume that we can use as many fresh term variables as we want.
(M
1
: : :M
n
)

= x

M

1
: : : M

n
, where x

is a fresh variable;
((8x:))

= x



(x: :

), where x

is a fresh variable;
x

= x;
(MN)

=M

N

;
(x::M)

= (y:0x: :M

)

, where y is a fresh variable.
10.3.3. Lemma.
1. If ? `  :  then ?
0
` 

: 0, for some extension ?
0
of ?.
2. If ? `M :  then ?
0
`M

:  , for some extension ?
0
of ?.
3. If ? `M :  and M !

M
1
then M

!

M

1
in at least one step.
Proof. Exercise 10.7.2. ut
10.3.4. Corollary (Strong normalization).
The system P has the strong normalization property.
Proof. By part (3) of Lemma 10.3.3, an innite reduction starting fromM
would be translated to an innite reduction in the simply-typed lambda
calculus. ut
10.3.5. Corollary. The system P has the Church-Rosser property.
Proof. Exercise 10.7.5. ut
10.4. Dependent types a la Curry 161
10.4. Dependent types a la Curry
10.4.1. Definition. We dene a type-erasure mapping j  j from terms of P
to pure lambda terms, as usual:
 jxj = x;
 jx::M j = x:jM j;
 jMN j = jM jjN j.
For a a pure lambda term N , we write ? `
P
N :  i N = jM j, for some
Church-style term M with ? ` M :  . We say that a pure lambda term N
is typable i ? `
P
N :  holds for some ?;  .
An alternative to the above denition is to dene a type assignment
system for pure lambda-terms, corresponding to P. Note that in this case
we must deal with dierent notion of a type, since types must depend on
pure lambda-terms rather than on Church-style terms. It follows that the
type-erasure mapping must be extended to types and kinds. Fortunately,
the notion of a typable term is the same with this approach as with our
simple denition, see [5].
10.4.2. Proposition. The Curry-style variant of P has the subject-reduction
property, that is if ? `
P
N :  and N !

N
0
then also ? `
P
N
0
:  .
Proof. Boring. See [5]. ut
Let us come back to the dependency-erasure map. We extend it to terms
as follows:
10.4.3. Definition.
x = x;
MN =M N ;
x::M = x: :M ;
We have the following result:
10.4.4. Lemma. If ? `M :  then ? `M :  (in !).
Proof. Exercise 10.7.3. ut
10.4.5. Proposition. A term is typable in P i it is simply-typable. In
particular, the type reconstruction problem for P is decidable in polynomial
time.
162 Chapter 10. Dependent types
Proof. Suppose that ? ` M :  in P. By Lemma 10.4.4, we have
? `M :  , in the simply typed lambda calculus. But it is easy to see that
jM j = jM j.
We have just shown that all pure terms typable in P are typable in
simple types. The converse is obvious, and thus type reconstruction in P
is the same as in simple types. ut
Here comes the surprise: it is not at all that easy with type checking!
10.4.6. Theorem (G. Dowek [31]). Type checking in the Curry-style ver-
sion of P is undecidable.
No Proof. We regret that we do not have enough time to present this nice
proof. But we recommend reading the original paper [31]. ut
10.5. Existential quantication
This section is a diggression. The system P, as most other typed lambda-
calculi, is normally studied with 8 and ! as the only basic connectives. Of
course, an extension of this system with _, ^ and ? can be dened in much
the same way as for the simply-typed lambda calculus. It remains to see
what is the lambda calculus counterpart of existential quantication. The
intuition suggests that (9x:)'(x) should be understood as a disjoint union
or coproduct of types '(a), for all objects a of type  . That is, objects of
type (9x:)'(x) are pairs consisting of an object a of type  and a proof M
of '(a). This may be syntactically written as: pack M;a to (9x:)'(x).
An elimination operator for type (9x:)'(x) takes such a pair and uses
it whenever an object of type '(x) can be used with an unspecied x. This
leads to the following deduction rules:
(9I)
? `M : '[x := N ] ? ` N : 
? ` pack M;N to (9x:)' : (9x:)'
(9E)
? `M : (9x:)' ?; x : ; z : ' ` N :  
? ` let z : ' be M : (9x:)' in N :  
(x 62 FV (?;  ))
Note that although  in (9E) cannot contain x free, this restriction does
not extend to the proof N . The variable x may thus be free in N , but it
should be considered bound in the let expression.
The reduction rule for sum types is as follows:
let z : ' be (pack M;N to (9x:)') in Q ?!

Q[x := N ][z :=M ]
Everything is ne with this rule, as long as we do not get seduced by the
temptation of making a Curry-style calculus with existential quantiers.
Look, how beautiful rules we may have:
10.6. Correspondence with rst-order logic 163
(9I)
? `M : '[x := N ] ? ` N : 
? `M : (9x:)'
(9E)
? `M : (9x:)' ?; z : ' ` N :  
? ` N [z := M ] :  
(x 62 FV (?;  ))
These rules are based on the idea of existential polymorphism: a term of
an existential type is like an object with some data being abstracted or
encapsulated or \private", and not available for external manipulations. It
seems very appealing that this sort of abstraction might be done with only
implicit typing discipline.
There are however some annoying little diculties when one attempts
to prove the subject reduction property for a type inference system `
9
with
rules as above. Some of these diculties can be eliminated by improving
the rules, but some cannot. The following example is based on an idea used
in [6] for union types (which cause similar problems).
10.5.1. Example. Consider a context ? with the following declarations:
0 : ;  : ;  : ;  : 0) ; x : 0;
X : x! x! ; Y :  ! (9x:0)x; Z : .
Then ? `
9
X(IY Z)(IY Z) : , but ? 6`
9
X(IY Z)(Y Z) : .
10.6. Correspondence with rst-order logic
The system P of dependent types is much stronger than is needed to provide
a term assignment for rst-order intuitionistic logic. In fact, rst-order logic
corresponds to a fairly weak fragment of P. This fragment is obtained by
restricting the syntax
3
so that each context must satisfy the following:
 There is only one type variable 0 (which should be regarded as a type
constant), representing the type of individuals;
 All kinds are of the form 0)    ) 0) ;
 There is a nite number of distinguished constructor variables, repre-
senting relation symbols in the signature (they must be of appropriate
kinds, depending on arity);
 Function symbols in the signature are represented by distinguished
object variables of types 0!    ! 0! 0, depending on arity;
 Constant symbols are represented by distinguished object variables of
type 0;
3
Of course one has to either add 9 to P, as in the previous section, or to consider only
universal quantication in formulas.
164 Chapter 10. Dependent types
 Other declarations in the context may only be of the form (x : 0), and
correspond to individual variables.
Clearly, algebraic terms are represented now by lambda terms of type 0
in normal form. Formulas are represented by types. Because of strong
normalization, we can restrict attention to formulas containing only terms
in normal form. It follows that an inhabited formula is a theorem and
conversely. The reader is invited to formally dene the syntax of the rst-
order fragment (Exercise 10.7.9).
In summary, we have the following pairs of corresponding items:
formulas  types
proofs  terms
domain of individuals  type constant 0
algebraic terms  terms of type 0
relations  constructors of kind
0) 0)    ) 0) 
atomic formula r(t
1
; : : : ; t
n
)  dependent type rt
1
: : : t
n
: 
universal formula  product type
proof by generalization  abstraction x : 0:M
'
proof by modus ponens  application M
8x:0'
N
0
10.6.1. Example. Consider the Hilbert-style axioms of Section 9.3 Each of
them corresponds to a type in P, extended by existential quantication as
in Section 10.5. These types are inhabited as follows. (We write types as
upper indices to improve readability.)
 Y
(8x:0)'(x)
:Y t : (8x:0)'(x):! '(t);
 X
'(t)
:pack X; t to (9x:0)'(x) : '(t)! (9x:0)'(x);
 Y
 
x
0
:Y :  ! (8x : 0) , where x 62 FV ( );
 Y
(9x:0) 
:let z: be Y :(9x:0) in z : (9x:0) :!  ,
where x 62 FV ( );
 X
(8x:0)('! )
Y
(9x:0)'
:let z
'
be Y :(9x:0)' in packXxz; x to (9x:0)' :
(8x:0)('!  ):! ((9x:0)':! (9x:0) );
 X
(8x:0)('! )
Y
(8x:0)'
z
0
:Xz(Y z) : (8x:0)(' !  ): ! ((8x:0)': !
(8x:0) ).
Out of the above six examples three do not use existential quantication.
If we apply the dependency-erasing translation M 7! M to the third and
sixth of the above terms, we obtain the typed combinators
 K :  ! 0!  and
10.7. Exercises 165
 S : (0! '!  )! (0! ')! 0!  .
This may be a suprise on the rst look that we obtain something so much
familiar. But it is fully justied by the fact that universal quantication is
a generalization of implication.
The rst example is a little less spectacular, as it erases to Y
0!'
:Y t :
(0! ')! ' (parameterized by t : 0).
The above embedding of rst-order logic into P can easily be generalized
to various extensions. For instance, many-sorted logic is handled just by
allowing more than one atomic type. Here are some examples of other
features that are not present in rst-order logic:
 There are sorts (types) for many domains for individuals, and also for
functions on the individuals;
 There is a function abstraction mechanism (we deal with lambda-terms
rather than algebraic terms);
 Quantication over functions is permitted; a quantier ranges over
arbitrary expressions of a given sort;
 Proofs are terms, so that properties of proofs can be expressed by
formulas.
The presence of quantication over objects of all nite types means that
P can express many higher-order languages (see [51]). We would how-
ever prefer not to use the expression \higher-order logic" here, as there is
no quantication over propositions. A more adequate statement about P
is that it provides a many-sorted rst-order representation of higher-order
logic.
Another issue is expressibility of rst-order theories in P. You can nd
more about this in [8, p. 202].
As we have already observed, rst-order intuitionistic logic is undecid-
able. Thus type inhabitation in the corresponding fragment of P must be
also undecidable. But P can be shown conservative over this fragment, and
it follows that type inhabitation for the whole system is also undecidable.
Another direct and simple proof can be found in [13].
10.6.2. Theorem. Type inhabitation in P is undecidable. ut
10.7. Exercises
10.7.1. Exercise. Let string(n) be the type of binary strings of length n.
Every such string w determines a record type with integer and boolean
elds corresponding to the digits in w. For example, for 01101 we take
166 Chapter 10. Dependent types
int ^ bool ^ bool ^ int ^ bool . Dene an appropriate context ? declaring
variables string and record so that record (n)(w) is a well-formed type, for
n : int and w : string(n).
10.7.2. Exercise. Prove Lemma 10.3.3. (First extend the translation to
kinds and dene ?
0
. A substitution lemma will also be necessary.)
10.7.3. Exercise. Prove Lemma 10.4.4. Also prove that ? ` M :  and
M !

M
0
implies M !

M
0
or M =M
0
.
10.7.4. Exercise. Consider the following attempt to prove strong normal-
ization for P:
Assume rst that a term M is such that no type occurring in M contains a lambda
term. In this case an innite reduction starting from M would be translated,
by Lemma 10.4.4, to an innite reduction in the simply-typed lambda calculus.
The general case follows from the following induction step: If all subterms of M
(including all terms occurring in types in M) are strongly normalizing then M
is strongly normalizing. To prove the induction step, we observe that an innite
reduction starting fromM translates to a sequence of pure terms N
i
, with N
i
= N
j
,
for all i; j > i
0
. Thus our innite reduction must, from some point on, consist
exclusively of reduction steps performed exclusively within types. But all terms
occurring in types are obtained from subterms of the original term M and thus
must strongly normalize by the induction hypothesis.
Find the bug in this proof. Can you x it?
4
10.7.5. Exercise. Prove the Church-Rosser property for P (Corollary 10.3.5).
Warning: do rst Exercise 10.7.6. Hint: Apply Newman's Lemma.
10.7.6. Exercise. Show an example of P terms M and M
0
of the same
type such that M =M
0
, but M 6=

M
0
.
10.7.7. Exercise. The proof technique that fails for Church-style P (Exer-
cise 10.7.4) works for the Curry-style terms. Prove strong normalization for
Curry-style P with help of the dependency-erasing translation M 7!M .
10.7.8. Exercise. Verify the correctness of Example 10.5.1.
10.7.9. Exercise. Dene formally the fragment of P corresponding to rst-
order logic over a xed signature.
10.7.10. Exercise. Consider the odd-numbered formulas of Example 9.2.1,
as types in an appropriate extension of P. Write lambda-terms inhabiting
these types. (If necessary use operators related to conjunction, disjunction,
and the existential quantier.)
4
We do not know how.
10.7. Exercises 167
10.7.11. Exercise. We know that types of K and S are sucient to ax-
iomatize the arrow-only fragment of propositional intuitionistic logic. These
types correspond to the third and sixth axiom of Section 9.3 (see Exam-
ple 10.6.1). One can thus conjecture that the rst axiom 8x'(x):! '(t),
which becomes (0 ! ') ! ' after erasing dependencies, can be eliminated
from the axiom system. Show that this conjecture is wrong: our formula
cannot be derived from the other two axiom schemes.
168 Chapter 10. Dependent types
CHAPTER 11
First-order arithmetic and Godel's T
Arithmetic is the core of almost all of mathematics. And expressing and
proving properties of integers always was one of the primary goals of math-
ematical logic. In this chapter, we will trace the Curry-Howard correspon-
dence back to the 40's and 50's, to discover it in some fundamental works of
Kleene and Godel. Both these works aimed at proving consistency of Peano
Arithmetic. For this purpose they give some fundamental insights on the
constructive contents of arithmetical proofs.
11.1. The language of arithmetic
The signature (cf. Denition 6.6) of rst-order arithmetic consists of two
binary function symbols + and , two constant symbols 0 and 1 and the sym-
bol = for equality.
1
The standard model of arithmetic is the set of integers
N with the ordinary understanding of these symbols, i.e., the structure:
N = hN ;+; ; 0; 1;=i:
Note that all elements of N can be given names in the language of arithmetic.
Let n denote the term 1 + 1 +   + 1, with exactly n copies of 1 (assuming
that 0 is 0).
By Th(A) we denote the set of all rst-order sentences that are classically
true in A (i.e., the set of all sentences ' such that A j= ', in the sense of
Section 9.4). The following classical result shows the limitation of rst-order
logic:
11.1.1. Theorem. There exists a nonstandard model of arithmetic, i.e., a
structure M = hM ;;
;0;1;=i, such that Th(M) = Th(N ), but M and
N are not isomorphic.
1
Another typical choice is to take a unary function symbol s for the successor function,
instead of 1.
169
170 Chapter 11. First-order arithmetic and Godel's T
The above fact is a consequence of compactness theorem, see [71].
However, the denitional strength of rst-order formulas over the stan-
dard model is quite nontrivial. Let us say that a k-ary relation r over N
is arithmetical i there exists a formula '(~x) with k free variables ~x, such
that, for every ~n 2 N
k
:
r(~n) holds i N j= '(~n):
A function is arithmetical i it is arithmetical as a relation. We have the
following theorem of Godel:
11.1.2. Theorem. All partial recursive functions (in particular all recursive
functions) are arithmetical.
In fact, partial recursive functions and relations are just the very beginning
of the \arithmetical hierarchy". The above theorem implies in paricular
that Th(N ) must be undecidable. Otherwise, membership in every r.e. set
would be also decidable.
11.2. Peano Arithmetic
Before Godel, people thought that it could be possible to axiomatize Th(N ),
i.e., to give a simple set of axioms A such that all sentences of Th(N )
would be consequences of A. Peano Arithmetic, abbreviated PA, is such an
attempt. The axioms of PA are the following formulas:
 8x (x = x);
 8x8y (x = y ! y = x);
 8x8y ('(x)! x = y ! '(y));
 8x:(x+ 1 = 0);
 8x8y (x+ 1 = y + 1! x = y);
 8x (x+ 0 = x);
 8x8y (x+ (y + 1) = (x+ y) + 1);
 8x (x  0 = 0);
 8x8y (x  (y + 1) = (x  y) + x);
 8x ('(x)! '(x+ 1)):! '(0)! 8x'(x)).
11.2. Peano Arithmetic 171
The third and the last items are actually axiom schemes, not single axioms.
Although the set of axioms is thus innite, it is still recursive, and thus the
set of theorems (derivable sentences) of PA is r.e. The last axiom scheme is
called the induction scheme.
A theory T (a set of sentences) is complete i for all sentences  of
the rst-order language of T , either T `  or T ` : . Godel's famous
incompleteness theorem asserts that PA is not a complete theory. This
statement is equivalent to PA 6= Th(N ), because every Th(A) is complete.
The importance of Godel's theorem is that it holds also for all extensions
of PA, as long as they are eectively axiomatizable. (A consequence of this
is of course that Th(N ) is not r.e.)
11.2.1. Theorem (Godel incompleteness). There is a sentence Z such that
neither PA ` Z nor PA ` :Z.
Proof. The proof of the theorem is so beautiful that we cannot resist the
temptation to sketch here the main idea, which is to express the \liar para-
dox"
2
in the language of arithmetic. This cannot be done in full, as it would
imply inconsistency of arithmetic, but a weaker property will do. Godel's
sentence Z expresses the property \Z has no proof in PA". More formally,
we have:
N j= Z i PA 6` Z:
Now if PA ` Z then N j= Z, because N is a model of PA, and thus PA 6` Z.
On the other hand, if PA ` :Z then N j= :Z, but also N j= Z, by the
property of Z. Thus Z can be neither proved nor disproved within PA.
The construction of Z is based on the idea of Godel numbering. Each
expression in the language gets a number, and we can write formulas express-
ing properties of expressions by referring to their numbers. In particular,
one can write a formula T (x; y), such that:
N j= T (n;m) i PA ` '
n
(m)
whenever n is a number of a formula '
n
(x) with one free variable x. The
formula :T (x; x) must also have a number, say :T (x; x) = '
k
(x). Thus
N j= '
k
(n) i PA 6` '
n
(n):
The formula Z that says \I have no proof!" can now be dened as '
k
(k):
N j= '
k
(k) i PA 6` '
k
(k):
ut
2
The sentence: \This sentence is false" cannot be true and cannot be false.
172 Chapter 11. First-order arithmetic and Godel's T
It was a popular opinion among mathematicians that Godel's theorem is of
little practical importance. Indeed, the formula Z is based on an articial
diagonalization, and everything one nds in number theory textbooks could
be formalized in PA. It is commonly assumed that the rst \natural" mathe-
matical problem independent from PA, was shown by Paris and Harrington,
see [11]. This problem concerns nite combinatorics and may indeed be
considered natural. But it is not a purely arithmetical problem, i.e., it has
to be coded into arithmetic. In addition, it was actually invented for the
purpose of being independent, rather than suggested by actual mathemat-
ical research. We will see later a strong normalization theorem (and these
denitely belong to the mathematical practice) independent from PA. This
theorem was obtained already by Godel, and thus is much older than the
Paris and Harrington example.
With the Godel numbers technique, one can express consistency of PA.
Indeed, let T (x) be a formula such that:
N j= T (n) i PA ` '
n
;
whenever n is a number of a sentence '
n
. Let k be the number of the
sentence \0 = 1" and let Con be the formula \:T (k)". Then Con expresses
consistency of PA:
N j= Con i PA is consistent.
The following theorem was also obtained by Godel, by a renement of tech-
niques used for the proof of Theorem 11.2.1.
11.2.2. Theorem (Non-provability of consistency). If PA is consistent then
PA 6` Con.
The conclusion is that to prove consistency of arithmetic, one must neces-
sarily use tools from outside the arithmetic.
11.3. Representable and provably recursive functions
We now consider two properties of functions that are stronger than being
arithmetical. We not only want our functions to be denable over the stan-
dard model, but we want to prove in PA (or some other theory) that the
appropriate formula actually denes a function.
In the denition below, the symbol 9! should be read as \there exists ex-
actly one". Formally, 9!x'(x) is an abbreviation for \9x'(x):^8y ('(y)!
x = y)".
11.3.1. Definition. We say that a k-ary total function f over N is repre-
sentable in PA i there exists a formula '(~x; y), with k + 1 free variables
~x; y, such that:
11.3. Representable and provably recursive functions 173
1) f(~n) = m implies PA ` '(~n;m), for all ~n;m;
2) PA ` 9!y '(~n; y); for all ~n 2 N
k
.
A function is strongly representable in PA, if (1) holds and
3) PA ` 8~x9!y '(~x; y).
Each representable function is in fact strongly representable (Exercise 11.8.3)
but proving that (2) implies (3) is a brutal application of tertium non datur.
Of course, each representable function is arithmetical. The converse is not
true, but we have the following stronger version of Theorem 11.1.2:
11.3.2. Theorem (Godel). A function is representable in PA if and only if
it is recursive.
The above theorem implies that the totality of every recursive function can
actually be proven in PA. However, the excluded middle trick used in Exer-
cise 11.8.3 suggests that such proofs are not necessarily constructive. Proofs
required by part (2) of Denition 11.3.1 are constructive, but non-uniform.
What we want, is a constructive and uniform proof of termination for all
arguments, such that we are able to actually compute the value m of f(~n)
from this proof. We should understand however that for this reason we
should be concerned with particular algorithms rather than extensionally
understood functions. This calls for a ner notion of provable totality.
Recall that, by Kleene's normal form theorem, every partial recursive
function f can be written as
f(~n) = 
2
(y:t
f
(~n; y) = 0);
where 
2
is a projection (second inverse to the pairing function) and t
f
is
primitive recursive. The function t
f
describes a particular algorithm com-
puting f . Termination of this particular algorithm can be expressed by a
formula of the form
8~x9y (t
f
(~x; y) = 0):
Fortunately, primitive recursive functions do not create any of the above
mentioned diculties. That is, proofs of totality for primitive recursive
functions are completely eective. In addition, every primitive recursive
function can be uniquely dened by means of equational axioms. Thus, we
can actually extend the language of PA by names and dening equations for
\as many primitive recursive functions as we wish"
3
without any unwanted
side-eects (i.e., this extension of PA is conservative.) It follows that as-
suming the above formula to be literally a formula of PA is as harmless as
it is convenient.
3
A quotation from [26].
174 Chapter 11. First-order arithmetic and Godel's T
11.3.3. Definition. A recursive function f is said to be provably total (or
provably recursive) in PA i
PA ` 8~x9y (t
f
(~x; y) = 0):
It is customary to talk about provably recursive functions, but what we
actually deal with is the notion of a provably recursive algorithm. A function
should be regarded provably total if one of its algorithms is provably total.
The class of functions provably total in PA is very large and includes
most of commonly considered functions, and much more, up to unbelievable
complexity. But there are recursive functions that are not provably total
in PA.
11.4. Heyting Arithmetic
The search for a constructive meaning of classical proof of totality of a recur-
sive function, leads of course to the notion of intuitionistic arithmetic. By
Heyting Arithmetic (HA), we mean a formal theory based on the following
axioms and rules:
 All axioms and rules of rst-order intuitionistic logic;
 All axioms of Peano Arithmetic;
 Dening equations for all primitive recursive functions.
This means that HA is a theory in the language of arithmetic, extended by
new function symbols for all primitive recursive functions. This extension is
not essential, because of conservativity, but is technically very useful.
Here are some interesting properties of HA. (More can be found in [107]
and [26].)
11.4.1. Theorem.
1. HA ` 8x8y (x = y _ :(x = y)).
2. If HA ` 9x'(x) for a closed formula 9x'(x) then HA ` '(k), for
some k 2 N .
3. HA ` (' _  )$ 9x ((x = 0! ') ^ (:(x = 0)!  )), for all '; .
4. If HA ` ' _  , for closed ' and  , then either HA ` ' or HA `  .
5. If HA ` 8x ('(x) _ :'(x)) and HA ` ::9x'(x) then HA ` 9x'(x).
(Markov's Principle)
11.4. Heyting Arithmetic 175
Proof.
1) Exercise 11.8.6.
2) See [26] for a semantical proof using Kripke models.
3) Follows from part 2.
4) Follows from parts 2 and 3.
5) From HA ` ::9x'(x) it follows that PA ` 9x'(x), and thus N j=
'(k), for some k. But we have HA ` '(k) _ :'(k) and thus, by (4),
either '(k) or :'(k) is a theorem of HA. In each case we conclude
that HA ` 9x'(x). (But note that this proof is classical.)
ut
11.4.2. Theorem (Kreisel (1958)). A recursive function is provably total in
Peano Arithmetic i it is provably total in Heyting Arithmetic.
Proof. The right-to-left part is immediate. We prove the other part.
Without loss of generality, we consider the case of a unary function. Let
PA ` 8x9y (t
f
(x; y) = 0). Thus also PA ` 9y (t
f
(x; y) = 0). One can show
that the Kolmogorov translation (see Chapter 8 and 9) works for arithmetic
(see e.g. [107]), so that we obtain HA ` ::9y (t
f
(x; y) = 0). From Theo-
rem 11.4.1(1), we have
HA ` 8x8y (t
f
(x; y) = 0 _ :t
f
(x; y) = 0):
We apply Markov's Principle (Theorem 11.4.1(5)) to obtain the desired re-
sult. ut
There is also a direct syntactic proof due to Friedman, which does not
require the whole power of Markov's Principle and carries over to second-
order arithmetic. See Exercise 11.8.8.
The proof of Kreisel's theorem works as well for any formula of the form
8x9yR(x; y), where R is a primitive recursive predicate. For instance, R
may be just ?, in which case the quantiers are redundant. We conclude
with the following result.
11.4.3. Corollary. HA is consistent if and only if PA is consistent. ut
Kreisel's theorem has the following consequence: classical termination
proofs can be made constructive.
11.4.4. Example. Consider a formula of the form 8x9y P (x; y) = 0 with
primitive recursive P . It can be seen as a specication for an input-output
relation of a program. A classical or intuitionistic proof of our formula
176 Chapter 11. First-order arithmetic and Godel's T
asserts that such a program (a recursive function) exists. A program com-
puting this function can actually be extracted from a constructive proof. For
this, let us assume that the signature of arithmetic (and perhaps a bit more)
has been added to P. Then a formula like 8n9m(n = 2 m_n = 2 m+1)
is inhabited by a proof, i.e., a lambda term. This lambda term M , applied
to any specic n, will evaluate to a normal form pack in
i
(N);m to : : : for
a specic value of m. Thus M is actually a program for dividing numbers
by 2.
The little missing point in the above example is the \bit more" to be added
to the lambda calculus. We have specic axioms in arithmetic, most notably
the induction scheme. And this has to be accounted for by extending the
lambda calculus by a primitive recursion operator.
11.5. Kleene's realizability interpretation
The BHK interpretation mentioned in previous chapters relies on the infor-
mal notion of a \construction." Kleene [60] proposed a way to make this
precise.
The idea is that a construction of a formula is a number encoding the
constructions of the subformulas of the formula. For instance, a construction
of a conjunction '
1
^'
2
is a number n encoding a pair of numbers n
1
and n
2
,
where n
1
and n
2
are constructions of '
1
and '
2
, respectively.
The main problematic parts of the BHK-interpretation is in the case
of implication and universal quantier. For instance, a construction of an
implication '!  is an eective procedure that maps any construction of '
into a construction of  . Having settled on N as the domain of constructions
it is now natural to require that a construction of an implication be a number
encoding a recursive function that maps any construction of the antecedent
to a construction of the succedent.
Below we carry this out in detail, following [61], showing that any formula
provable in intuitionistic arithmetic has a construction in this sense.
11.5.1. Definition. Let e 2 N and ' be a closed formula of arithmetic.
Then the circumstances under which e realizes ' are dened as follows.
1. e realizes A, where A is an atomic formula, if e = 0 and A is true;
2. e realizes '
1
^ '
2
if e = 2
a
 3
b
where a realizes '
1
and b realizes '
2
;
3. e realizes '
1
_ '
2
if e = 2
0
 3
a
and a realizes '
1
, or e = 2
1
 3
a
and a
realizes '
2
;
4. e realizes '
1
! '
2
if e is the Godel number of a partial recursive
function f of one argument such that, whenever a realizes '
1
, then
f(a) realizes '
2
;
11.5. Kleene's realizability interpretation 177
5. e realizes 9x'(x), where '(x) is a formula containing only x free, if
e = 2
n
 3
a
where a realizes '(n).
6. e realizes 8x'(x), where '(x) is a formula containing only x free, if e
is the Godel number of a general recursive function f of one argument
such that f(n) realizes '(n), for every n.
A closed formula ' is realizable if there exists a number e which re-
alizes '. A formula '(x
1
; : : : ; x
k
) containing only the distinct variables
x
1
; : : : ; x
k
(k  0) free is realizable if there exists a general recursive func-
tion f of k variables such that f(n
1
; : : : ; n
k
) realizes '(n
1
; : : : ; n
k
), for every
n
1
; : : : ; n
k
.
We shall prove below that every formula provable in HA is realizable. Be-
fore proceeding with the details it is convenient to introduce some notation
for partial recursive functions.
Let us recall again Kleene's normal form theorem, which we used in
Section 11.3. The predicate t
f
is in fact uniform in f , or more precisely
in the Godel number of f . That is, for every partial recursive function
f(x
1
; : : : ; x
n
) of n variables, there is a number e such that
f(x
1
; : : : ; x
n
) = 
2
(y: T
n
(e; x
1
; : : : ; x
n
; y));
where T
n
is a certain primitive recursive predicate. Informally speaking, T
n
states that e is an encoding of f , and y is an encoding of a computation of
the function encoded by e (i.e., f) on input x
1
; : : : ; x
n
. This encoding is a
pair, and the second component of this pair is the output. The projection 
2
extracts this output from y. The number e is called a Godel number of f .
We abbreviate 
2
(y: T
n
(e; x
1
; : : : ; x
n
; y)) by 
n
(e; x
1
; : : : ; x
n
).
Also recall that by Kleene's S
m
n
theorem, there is for every m;n  0 an
m+ 1-ary primitive recursive function S
m
n
(z; y
1
; : : : ; y
m
) such that, if e is a
Godel number of the m+ n-ary function f(y
1
; : : : ; y
m
; x
1
; : : : ; x
n
), then for
each m-tuple (k
1
; : : : ; k
m
) of numbers, S
m
n
(e; k
1
; : : : ; k
m
) is a Godel number
of the n-ary function f(k
1
; : : : ; k
m
; x
1
; : : : ; x
n
).
When f(y
1
; : : : ; y
n
; x
1
; : : : ; x
m
) is an n+m-ary partial recursive function
with Godel number e, we denote by
x
1
: : : x
m
:f(y
1
; : : : ; y
n
; x
1
; : : : ; x
m
)
the function S
m
n
(e; y
1
; : : : ; y
m
).
Thus, x
1
: : : x
n
:f(x
1
; : : : ; x
n
) denotes a Godel number of the function f
and x
1
: : : x
n
:f(y
1
; : : : ; y
m
; x
1
; : : : ; x
n
) denotes a primitve recursive func-
tion f(y
1
; : : : ; y
m
) whose value for each m-tuple (k
1
; : : : ; k
m
) of numbers is
a Godel number of the n-ary function f(k
1
; : : : ; k
m
; x
1
; : : : ; x
n
).
We also write fzg(x
1
; : : : ; x
n
) for 
n
(z; x
1
; : : : ; x
n
).
178 Chapter 11. First-order arithmetic and Godel's T
We then have for any n-tuple k
1
; : : : ; k
n
of numbers that
fx
1
: : : x
n
:f(y
1
; : : : ; y
m
; x
1
; : : : ; x
n
)g(k
1
; : : : ; k
n
)
 f(k
1
; : : : ; k
m
; x
1
; : : : ; x
n
)
where  means that the two functions have the same domain and have the
same results on same arguments inside the domain.
11.5.2. Theorem. If `
HA
' then ' is realizable.
Proof. We use a Hilbert-type formulation of HA: this amounts to the
Hilbert-type formulation of intuitionistic predicate calculus from Chapter 9,
together with the axioms for arithmetic in the rst section above.
The proof is by induction on the derivation of `
HA
'. (This requires
a generalized induction hypothesis that makes sense for formulas with free
variables.) We skip most of the proof, showing only two example cases. The
reader may nd the details in x82 of Kleene's classic [61].
1. Let the proof be an instance of the axiom A! B ! A for some A;B.
Then ' = A! B ! A. We dene
e = a:b:a
(does this look familiar?) To show that e realizes ', let a realize A.
We must show that fa:b:ag(a) i.e.b:a realizes B ! A. For this
end let b realize B, and we must show that fb:ag(b), i.e., a realizes A,
but this holds by assumption.
2. Let the proof be an instance of (A! B ! C)! (A! B)! A! C
for some A;B;C. Then:
e = p:q:a:ffpg(a)g(fqg(a))
ut
11.5.3. Corollary. HA is consistent.
Proof. There is no number realizing ?. ut
11.5.4. Corollary. PA is consistent.
Proof. Immediate from Corollaries 11.4.3 and 11.5.3. ut
The proof that all intuitionistically provable arithmetical statements
have realizers works by mapping proofs into realizers. These realizers are
numbers coding recursive functions.
Another similar approach would be to identify the proofs with -terms
in an appropriate extension of P. This would avoid the passing back and
11.6. Godel's System T 179
forth between functions and encoding of functions. And we would have a nice
example of a Curry-Howard correspondence. If we dene such an extension,
then consistency of arithmetic should be inferred from normalization: there
is no normal form of type ?.
In fact, it occurs that we do not need dependent types at all to perform
a similar construction. It was actually done by Godel at the simply-typed
(propositional) level, with help of his System T.
11.6. Godel's System T
We have seen that in !, the simply typed -calculus, very few functions can
be dened. For instance, among the numeric functions, only the extended
polynomials can be dened.
In this section we consider Godel's system T, which arises from ! by
addition of primitive types for numbers and booleans and by addition of
primitive recursion and conditionals for computing with these new types.
the exposition follows [46] to a large extent.
It will be seen that T is far more expressible than !. The system was
conceived and used by Godel to prove the consistency of arithmetic.
11.6.1. Definition. Godel's system T, denoted also by T, is dened as
follows.
1. T has the same set of types as simply typed -calculus !, with the
following additions:
 ::= : : : j int j bool
2. T has the same set of terms as simply typed -calculus ! a la
Curry, with the following additions:
M ::= : : : j z j s(M) j r(M;N;L) j t j f j d(M;N;L)
3. T has the same set of typing rules as simply typed -calculus ! a
la Curry, with the following additions:
? ` z : int
? ` M : int
? ` s(M) : int
? ` M :  & ? ` N :  ! int!  & ? ` L : int
? ` r(M;N;L) : 
? ` t : bool ? ` f : bool
? ` M :  & ? ` N :  & ? ` L : bool
? ` d(M;N;L) : 
180 Chapter 11. First-order arithmetic and Godel's T
4. T has the same set of reduction rules as simply typed -calculus !
a la Curry, with the following additions:
r(M;N; z) ! M
r(M;N; s(L)) ! N (r(M;N;L))L
d(M;N; t) ! M
d(M;N; f) ! N
By !
T
we denote the union of !

and the above reductions.
As mentioned above, int and bool denote types for integers and booleans,
respectively. The term formation operators z and s denote zero and succes-
sor, respectively, as one might imagine.
The two rst inference rules for int can be seen as introduction rules,
whereas the third rule for int is an elimination rule. Analogously, z and s are
constructors of type int and r is a destructor of type int. Similar remarks
apply to the inference rules and term formation operators for bool.
11.6.2. Remark. As always one can study a Church variant and one can
study a variant in which pairs are included.
The following two theorems show that the main properties of simply
typed -calculus are preserved. In particular, the extra expressibility does
not come at the expense of loosing strong normalization.
11.6.3. Theorem. The relation !
T
is Church-Rosser.
Proof. By the Tait{Martin-Lof technique. ut
11.6.4. Theorem. The relation !
T
is strongly normalizing.
Proof. By the method of Tait. ut
Recall that Tait's method (which applies to T with very few adjust-
ments) is based on a construction that assigns a set of terms to every type.
If we attempt to formalize Tait's proof, we necessarily must use expressions
of the form: \For all sets A of terms, satisfying : : : we have : : : ". We can
talk about terms using their numbers, but one cannot enumerate all possible
sets of terms, and expressions as the above cannot be coded into rst-order
arithmetic. One needs to quantify over sets of numbers.
Specically, Lemma 4.4.3(iii) asserts that for all types  the set [[]] is
saturated . If we could dene [[]] directly then we could write a formula 

(x)
expressing in arithmetic that x is a member of [[]]. Then, the statement of
our lemma could be expressed in the rst-order language. But the denition
of [[]] is by induction, and there is no single formula expressing the property
11.6. Godel's System T 181
of being a member of [[]]. The denition of [[]] can only be seen as a set of
postulates about a set (unary relation) variable X. Thus, Lemma 4.4.3(iii)
can only be formalized as follows: for all types  and all sets X, if X
satises the postulates on [[]] then X is saturated. And this involves the
quantier \8X".
Our rst normalization proofs were for simply typed -calculus. We
proved both weak normalization by the \simple" Turing-Prawitz technique
and strong normalization by the \nontrivial" technique due to Tait. There
are also \simple" proofs of the strong normalization theorem for !. The
dierence between simple and nontrivial can be given more precise mean-
ing: the \simple" techniques can be formalized in arithmetic, whereas the
\nontrivial" can not.
In the case of T the situation is dierent. The Tait proof can be adapted
to prove strong normalization for T, but the simple proofs mentioned above
do not work. In fact, any strong normalization proof for System T must be
\nontrivial". See Corollary 11.7.5.
However, if we restrict attention to nitely many types, the situation
is dierent. We no longer need to quantify over all sets, because we only
need nitely many of them, and these can be explicitely dened by formulas.
Thus, the whole proof carries over in rst-order arithmetic. This situation
occurs in particular when we deal with a single function f , denable by a
term F , see Proposition 11.6.10.
In T, one can compute with booleans.
11.6.5. Example. Dene
not(M) = d(f; t;M)
or(M;N) = d(t; N;M)
and(M;N) = d(N; f;M)
Then
not(t) !
T
f
not(f) !
T
t
and we similarly have the expected reductions for or and and.
We also have some more reductions. For instance,
or(t; N)!
T
t
However, we do not have
or(N; t)!
T
t
Indeed, one can show that there is no typable term G(x; y) such that both
G(t; N)!
T
t and G(N; t)!
T
t.
Above we have introduced int as a representation of integers. The fol-
lowing characterization of normal forms gives the precise interpretation of
that.
182 Chapter 11. First-order arithmetic and Godel's T
11.6.6. Proposition. Let M be a closed normal form and suppose ` M :  .
1. if  = int then M = m, for some m 2 N;
2. if  = bool then M = f or M = t;
3. if  = 
1
! 
2
then M = x:N .
In T one can also compute with integers.
11.6.7. Example. Dene for any number n 2 N:
n = s
n
(z)
Then we can dene
plus(M;N) = r(M;x:y:s(x); N)
Indeed,
plus(m; z) = r(m;x:y:s(x); z)
!
T
m
and
plus(m;n+ 1) = plus(m; s(n))
= r(m;x:y:s(x); s(n))
!
T
(x:y:s(x)) (r(m;x:y:s(x); n))n
!
T
s(r(m;x:y:s(x); n))
!
T
s(m+ n)
= m+ n+ 1
11.6.8. Definition. A function f : N
k
! N is denable in T by a term F
if
4
1. ` F : int
k
! int;
2. F (m
1
; : : : ;m
k
) =
T
f(m
1
; : : : ;m
k
).
It is an easy exercise to show that multiplication, exponential, predecessor,
etc.. are denable.
As long as  in the typing rules for the new constructs is restriced to
base types, i.e., bool and int, the functions that can be dened in this
way are primitive recursive. However, as the type  increases, more and
more functions become denable. In fact, one can show that Ackermann's
function is denable in T (Exercise 11.8.11).
The system T is also called the system of primitive recursive function-
als of nite type, because it makes a system of notation for higher-order
functions (i.e., functions on functions etc.) dened over the set of integers
by means of primitive recursion. (The \al" in \functionals" reects exactly
the point that we deal with higher-order objects.)
4
int
k
means int ! : : :! int (k arrows).
11.7. Godel's Dialectica interpretation 183
11.6.9. Remark. A construction related to the recursor r is the iterator i.
It has form i(M;N;L) with the typing rule
? ` M :  & ? ` N :  !  & ? ` L : int
? ` i(M;N;L) : 
and reduction rules
i(M;N; z) ! M
i(M;N; s(L)) ! N (i(M;N;L))
The predecessor function satisfying p(s(x)) !
T
x can be dened by the
recursor but not by the iterator. However, also the iterator can dene the
predecessor provided one only requires that p(m+ 1) !
T
m. In fact, one
can dene the recursor from the iterator and pairing, provided one only
requires reductions of this form.
The question arises exactly which functions can be dened in T. It is
not dicult to see that every primitive recursive function is denable. It is
also not dicult to see that not every recursive function can be denable.
Indeed, suppose otherwise. All terms of type int ! int can be eectively
enumerated, and each of these terms denes a total function (because of
strong normalization). Thus, we can enumerate all total recursive functions
of one argument: g
0
; g
1
; : : : . But the function h(x) = g
x
(x) is recursive and
cannot occur in the sequence. We can have even a tighter upper bound.
11.6.10. Proposition. All functions denable in T are provably total in PA.
Proof. If a function f is denable by a term F then this term describes an
algorithm to compute f . Thus, a predicate t
f
can be eectively computed
from F and conversely. Proving the formula 8x9y (t
f
(x; y) = 0) thus reduces
to proving that all applications of the form Fn are strongly normalizable.
One can do it (with Tait's technique) so that only nitely many types must
be considered. All this argument can be coded into arithmetic. ut
We will see later (Theorem 11.7.7) that the class of functions denable
in T coincides with the class of provably total functions of PA.
11.7. Godel's Dialectica interpretation
Godel introduced System T as a vehicle to prove consistency of PA. More
precisely, he translates each formula of arithmetic into a statement about
the primitive recursive functionals of nite type by the so-called Dialectica
interpretation. The original Godel's paper is [48]. We will only sketch the
main ideas here. More details can be found e.g. in [55, Ch.18].
184 Chapter 11. First-order arithmetic and Godel's T
The basis of the method is a translation of a formula ' in the language
of arithmetic into a term '
D
of type bool. Suppose rst that ' is an atomic
formula. Since all primitive recursive functions and predicates are denable
in T, we can dene '
D
so that
HA ` ' i '
D
=
T
t:
Here we do not require any additional information about the proof of ' to be
preserved by '
D
. (This is because primitive recursive statements are treated
as \observables". Compare this to 0 realizing all atomic formulas in Kleene's
approach.) For complex formulas, we want more. An ideal situation would
be as follows: '
D
has one free variable x, and
HA ` ' i '
D
[x := M ] =
T
t; for some M:
The term M would be the realizer, i.e., it would represent the proof. (Note
the distinction: '
D
is a syntactic translation, the computational contents is
in M .)
Life is not that easy, and we have to settle for something a little less
transparent and more complicated. But the essential idea remains the same.
Below we work in Church-style T, extended with product types for simplic-
ity. (This is a syntactic sugar that allows us to identify sequences of types
(variables etc.) with single types (variables, etc.) if we nd it convenient.)
11.7.1. Definition.
1. For a term M : bool, with FV(M) = fz

g, we write T j= M i
M [z := Z] =
T
t, for all closed Z : .
2. We dene a -formula as an expression of the form \9x

8y

D(x; y)",
where x; y are variables,  and  are arbitrary types, and D(x; y) has
type bool.
3. We write T j= 9x

8y

D i there exists a term X :  with y 62 FV(X),
such that T j= D[x := X].
5
The variables x and y in the above denition, part (2) may be of product
types, thus actually may represent sequences of variables.
11.7.2. Definition. For each formula ' in the language of arithmetic, we
dene a -formula '
D
= 9x8y '
D
by induction with respect to '.
 If ' is an atom (a primitive recursive relation) then '
D
= 9x
int
8y
int
'
D
,
where '
D
is a term which denes this relation in T, and x and y are
fresh variables.
5
The term X should be seen as parameterized by the free variables of D, except y.
11.7. Godel's Dialectica interpretation 185
Note that ? is a primitive recursive relation. Thus, as ?
D
we can take e.g.
the term f. Also note that the quantiers 9x
int
8y
int
are redundant and
introduced here just for uniformity.
Let now assume that '
D
= 9x

8y

'
D
(x; y) and  
D
= 9u

8v

 
D
(u; v).
Then:
 (' ^  )
D
= 9xu8yv('
D
(x; y) ^  
D
(u; v));
 (' _  )
D
= 9z
int
xu8yv((z = 0! '
D
) ^ (z 6= 0!  
D
));
 ('!  )
D
= 9u
1
!
y
1
!!
8xv('
D
(x; y
1
xv)!  
D
(u
1
x; v));
 (:')
D
= 9z
!
8x(:'
D
(x; zx));
And now take '
D
= 9x

8y

'
D
(x; y; z
int
). Then
 (9z ')
D
= 9zx8y '
D
(x; y; z);
 (8z ')
D
= 9x
1
int!
8yz'
D
(x
1
z; y; z)
11.7.3. Theorem (Godel). If HA ` ' then T j= '
D
.
Proof. The proof is by induction with respect to the proof of '. We omit
this proof, which can be found in [55, Ch.18]. ut
The proof of the above theorem is actually building a realizer X for a given
proof in HA. The computational contents of the proof in HA is preserved
by the realizer as we will see below. Here are some consequences of the
interpretation.
11.7.4. Corollary. HA is consistent.
Proof. Suppose HA ` ?. Then T j= ?
D
, i.e., we have f =
T
t. ut
11.7.5. Corollary. The strong normalization theorem for System T is a
statement independent from PA.
6
Proof. Otherwise, all the proof of SN would be formalizable in PA. This
contradicts Theorem 11.2.2. ut
The above result can be explained as follows. Godel's consistency proof
makes use of the normalization theorem for T, and every other part than
this latter result can be proved in PA itself, provided we go through the eort
of translating terms to numbers by some Godel-numbering. By Godel's the-
orem about the unprovability of consistency of arithmetic within arithmetic
6
SN is expressible in the language of arithmetic with help of Konig's Lemma: \For
each (Godel number of a) term M there is n such that all reduction paths from M (coded
by a Godel number) consist of at most n steps".
186 Chapter 11. First-order arithmetic and Godel's T
it follows that the normalization therem cannot be proved in PA|unless
PA is inconsistent.
Thus, in proving the normalization for T we must be using methods
which essentially transcend proof techniques that are formalizable in PA,
i.e., induction over natural numbers.
In normalization proof for simply typed -calculus we used induction
on lexicographically order triples, and similarly in the proof of Gentzen's
Hauptsatz (the cut-elimination theorem). Such inductions can be reduced
to nested inductions and are therefore still formalizable in PA.
One can also view induction on lexicographically ordered tuples as an
ordinal induction|induction up to !
n
|which happens to be formalizable
in PA. Gentzen discovered that by moving to larger ordinals, one could prove
a cut-elimination theorem for arithmetic. More specically he considers
induction up to 
0
. This is the rst ordinal that cannot be reached by
addition, multiplication, and exponentiation.
Also, one can show that the functions denable in T are the functions
which are denable by transnite recursion up to the ordinals which are
strictly smaller than 
0
, see [96]. This shows that the expressive power
of T is enormous.
11.7.6. Corollary. All functions provably total in rst-order arithmetic
are denable in T.
Proof. Without loss of generality we can consider a unary function. As-
sume PA ` 8x9y (t
f
(x; y) = 0), where t
f
is as in Denition 11.3.3. Recall
that t
f
(x; y) = 0 is primitive, and thus treated as an atomic formula. Thus,
the translation of the above formula (after removing redundant quantiers)
has the form
(8x9y (t
f
(x; y) = 0))
D
= 9y
int!int
1
8x
!
D(y
1
x; x);
where D represents the relation t
f
(x; y) = 0.
Since HA j= (8x9y (t
f
(x; y) = 0))
D
, we have a realizing term Y
1
, such
that D(Y
1
n; n) reduces to t. Let Y
1
n =
T
m. Then we have t
f
(n;m) = 0,
and thus f(n) = 
2
(m). Clearly, the projection is primitive recursive and
represented by some term 
2
. The conclusion is that the term x:
2
(Y
1
x)
represents f in System T. ut
Together with Proposition 11.6.10, this gives:
11.7.7. Theorem. The functions denable in T are exactly those that are
provably total in PA.
11.7.8. Remark. Let us now come back to the idea mentioned in Exam-
ple 11.4.4 of a variant of P corresponding to rst-order arithmetic. We
11.8. Exercises 187
shall argue that System T can be seen as a propositional counterpart of
such a calculus. Indeed, let us consider again the induction scheme
(8x:int)('(x)! '(x+ 1)):! '(0)! (8x:int)'(x):
In order to incorporate arithmetic into P one has to make sure that every
such type is inhabited. One way to do it is to introduce new constants R
'
of the above types. A proof by induction is now represented by a term
R
'
M
(8x:int)('(x)!'(x+1))
N
'
0 of type (8x:int)'(x).
The next question is what should be a reduction rule associated with R
'
.
Let n : int be a specic integer. The term R
'
MNn represents a proof
of '(n) obtained as follows: rst prove the general statement (8x:int)'(x)
by induction and then apply it to n. Such a proof can be seen as containing
a redundancy: an introduction of universal quantier by R
'
followed by
elimination of that quantier. We can avoid redundancy by applying M
to N exactly n times instead. This justies the reduction rules:
 R
'
MN0 !

N ;
 R
'
MN(n+ 1) !

Mn(R
'
MNn).
Now observe what happens to our constant under the dependency erasing
translation M 7!M . The type of R
'
becomes:
(int! '! ')! '! int! '(x);
which is, up to permutation, the same as the type of the recursor r. Also,
the reduction rules above dier from those of Denition 11.6.1(4) just in the
order of arguments.
11.8. Exercises
11.8.1. Exercise. Show that the following theorems are derivable in PA:
 8x (:(x = 0)! 9y(y = x+ 1));
 8x8y8z (x = y ! y = z ! x = z);
 8x8y8z ((x+ y) + z = x+ (y + z));
 8x8y (x+ y = y + x);
 2 + 2 = 4;
 8x9y (x = 2  y _ x = 2  y + 1);
 other common arithmetical properties.
188 Chapter 11. First-order arithmetic and Godel's T
11.8.2. Exercise. Check whether the axiom scheme 8x8y ('(x) ! x =
y ! '(y)) of PA can be replaced by 8x8y (x = y ! x + 1 = y + 1) and
8x8y8z (x = y ! y = z ! x = z).
11.8.3. Exercise. Show that every function representable in PA is strongly
representable (and conversely). Hint: Consider the formula:
(9!z '(~x; z): ^ '(~x; y)) _ (:9!z '(~x; z): ^ y = 0):
11.8.4. Exercise. Show that the condition (2) in Denition 11.3.1 can be
replaced by:
2') PA ` 9y '(~n; y); for all ~n 2 N
k
;
2") N j= '(~n;m) implies f(n) = m, for all ~n and m.
Hint: Consider the formula: '(~x; y) ^ 8z ('(~x; z)! y  z).
11.8.5. Exercise. Consider again the formulas of Exercise 11.8.1. Are they
provable in HA?
11.8.6. Exercise. Prove part 1 of Theorem 11.4.1.
11.8.7. Exercise. Let % be a xed formula. For any formula ', let '
%
be
obtained from ' by replacing every atomic subformula  by  _ '. Show
that if HA ` ' then also HA ` '
%
.
11.8.8. Exercise (H. Friedman). Prove Theorem 11.4.2, using Exercise 11.8.7
as a lemma. Hint: Take % to be 9y(t
f
(~x; y) = 0), and apply Exercise 11.8.7
to the formula ::9y(t
f
(~x; y) = 0).
11.8.9. Exercise. Show that multiplication, exponentiation, subtraction,
and all your favourite integer functions are denable in T.
11.8.10. Exercise. Here are our favourite integer functions: let f
0
be the
successor function, and dene f
k+1
(x) := f
x
k
(x) (apply f
k
to x exactly x
times). Show that all functions f
k
are denable i n T.
11.8.11. Exercise. TheAckermann function f
!
is dened by f
!
(x) = f
x
(x).
Prove that the Ackermann function is not primitive recursive. Hint: Show
that every primitive recursive function is majorized by one of the f
k
's.
11.8.12. Exercise. Show that the Ackermann function f
!
(Exercise 11.8.11)
is denable in T.
11.8.13. Exercise. Show that all functions f
!+k+1
(x) = f
x
!+k
(x) are den-
able in T, as well as the function f
!2
(x) = f
!+x
(x).
11.8. Exercises 189
11.8.14. Exercise. Go ahead, dene even faster growing functions, all de-
nable in T. Will this ever stop?
11.8.15. Exercise. Show that all functions denable in ! are denable
in T. Too easy? Do not use Schwichtenberg theorem.
11.8.16. Exercise. Show that Booleans make syntactic sugar in T, that
is, the class of integer functions denable in T without Booleans is the
same.
190 Chapter 11. First-order arithmetic and Godel's T
CHAPTER 12
Second-order logic and polymorphism
We often say that individuals are objects of order zero. Functions and
relations on individuals are of order one. Further, operations on objects of
order n will be themselves classied as being of order n+1. This terminology
is often used in the metalanguage, referring to problems, systems etc. For
instance, the unication problem discussed in Chapter 6, is often called
\rst-order unication". Note that the unied expressions (unknowns) are of
order zero, its the unication itself (an operation on terms) that is rst-order.
One can also consider second-order unication, with function unknowns and
so on.
We talk of \rst-order logic", because we have rst-order predicates, and
because quantication can be seen as an operator acting on individuals. So
what \second-order logic" should be? Typically, one adds to the language
variables ranging over predicates, sets or functions, and quantify over such
variables. Thus, second-order logic is usually an extension of rst-order
logic. However, in presence of second-order quantication, the rst-order
features become less important than one could expect, and many properties
of second-order logic can be studied in a simplied settings: propositional
second-order logic. This logic is obtained by adding second-order features di-
rectly to propositional calculus. That is, quantiers are now binding propo-
sitional variables.
12.1. Propositional second-order formulas
We extend the language of propositional logic by second-order quantiers,
i.e., quantiers over propositions. As before, we assume an innite set PV of
propositional variables and we dene the second-order propositional formulas
by induction, represented by the following grammar:
2 ::= ? j p j (2! 2) j (2 _ 2) j (2 ^ 2) j 8p 2 j 9p 2;
191
192 Chapter 12. Second-order logic and polymorphism
where p ranges over PV . The quantiers are meant to bind propositional
variables within their scope, so that e.g., FV(8p') = FV(') ? fpg. (We
skip the full denition of FV, leaving this pleasure to the reader, as well as
another one: to dene the operation of substitution '[p :=  ].) We identify
alpha-convertible formulas. Notational conventions are similar to those used
for propositional and rst-order logic.
The intended meaning of \8p'(p)" is that '(p) holds for all possible
meanings of p. The meaning of \9p'(p)" is that '(p) holds for some mean-
ing of p. Classically, there are just two possible such meanings: the two truth
values. Thus, the statement 8p'(p) is classically equivalent to '(>)^'(?),
and 9p'(p) is equivalent to '(>)_'(?). Therefore, every property express-
ible with quantiers can be also expressed without.
1
In fact, every function
over the two-element Boolean algebra f?;>g can be dened with help of
ordinary propositional connectives (this property is called functional com-
pleteness) and thus no extension at all of the propositional language can
increase its expressive power.
12.1.1. Warning. The above is no longer true when we add second-order
quantication to rst-order classical logic, and when the quantied predi-
cates may depend on individual terms. These are no longer just truth-values,
but rather truth-valued functions on individuals.
In the intuitionistic logic, there is no nite set of truth-values, and the
propositional quantiers should be regarded as ranging over some innite
space of predicates. (In fact, there is nothing like functional completeness:
Kreisel [64] and Goad [47] show predicates non-expressible in propositional
intuitionistic logic but denable with help of quantiers or innite opera-
tions.)
The intuitive meaning of quantied expressions is best explained by
means of the Brouwer-Heyting-Kolmogorov interpretation. Note that we
deal only with propositions expressible in our language. Indeed, to handle
the predicates in a constructive way, we must be able to refer to their proofs.
 A construction of 8p'(p) is a method (function) transforming every
construction of any proposition P into a proof of '(P).
 A construction of 9p'(p) consists of a proposition P, together with a
construction of P, and a construction of '(P).
Syntactically, predicatesPmust be themselves represented by formulas. The
class of formulas quantiers range over can be taken to be the full set 2, or
a proper subset of 2. We choose the rst option (called full comprehension)
so that the following schemes are valid (for every '):
1
But at a certain cost: compare the PSPACE-completeness of satisability of quantied
Boolean formulas to the NP-completeness of ordinary propositional formulas. It follows
that removing quantiers may cause an exponential increase of the size of a formula.
12.2. Semantics 193
 8p':! '[p :=  ];
 9p(p$ ').
One has to be aware that the full comprehension postulate has the follow-
ing side-eect, called impredicativity of second-order logic. The meaning of
a formula 8p' is determined by the meanings of all formulas '[p :=  ],
including the cases when  is either equal or more complex than 8p' it-
self. There is no well-founded hierarchy with respect to the semantics, in
particular many proof methods based on induction must fail.
On the other hand, the assumption that quantiers range over denable
propositions only is a sharp restriction compared to the ordinary understand-
ing of (full) second-order classical logic, as in Warning 12.1.1. However, from
a constructive point of view, a proof and not a model is the ultimate cri-
terium, and thus the syntactic approach should be given priority over the
semantic way of thinking. See also Remark 12.2.7.
12.1.2. Definition. Natural deduction.
The natural deduction system for second-order intuitionistic proposi-
tional logic consists of the ordinary rules for propositional connectives plus
the following rules for quantiers:
(8I)
? ` '
? ` 8p'
(p 62 FV (?)) (8E)
? ` 8p'
? ` '[p := #]
(9I)
? ` '[p := #]
? ` 9p'
(9E)
? ` 9p' ?; ' `  
? `  
(p 62 FV (?;  ))
In the above, the notation FV (?) is the union of all FV(%), for % 2 ?.
One can also dene other proof systems, most notably sequent calculus
for second-order propositional intuitionistic logic. Cut-elimination proofs
for this calculus were obtained independently by several authors; three of
them (by Girard, Martin-Lof and Prawitz) are published in the book [34].
12.2. Semantics
We begin, as usual, with the algebraic approach, based on Heyting algebras,
although, historically, second-order Kripke semantics was considered rst.
12.2.1. Definition. Let v : V !H be a valuation of propositional variables
in a complete Heyting algebra H. We extend v to arbitrary second-order
formulas as follows:
 v(' _  ) = v(') [ v( );
194 Chapter 12. Second-order logic and polymorphism
 v(' ^  ) = v(') \ v( );
 v('!  ) = v(')) v( );
 v(?) = 0;
 v(8p') = inffv
a
p
(') : a 2 Hg;
 v(9p') = supfv
a
p
(') : a 2 Hg.
where v
 
p
is a valuation dened by v
a
p
(p) = a, and v
a
p
(q) = v(q), for q 6= p.
We use the symbol j= in the obvious way, except that we deal now
exclusively with complete algebras. For instance, we write j= ' (and we
say that ' is a tautology) i ' has the value 1 under all valuations in all
complete Heyting algebras.
12.2.2. Theorem (Heyting completeness). The conditions ? j= ' and ? ` '
are equivalent.
Proof. Omitted.
2
See the paper [40] for details. ut
The paper of Geuvers [40] is suggested for reading, but algebraic semantics
for various second-order and higher-order intuitionistic logics was known
before Geuvers, cf. the work of Albert Dragalin [32].
Kripke semantics for second-order propositional formulas was considered
by several authors. There are various sorts of models and dierent variants
of the logics under consideration. One should begin with a reference to
Prawitz [86], who rst proved a completeness theorem for a class of Beth
models, structures similar in spirit to Kripke models. Then, Gabbay [36, 37]
showed completeness for a slight extension of our second-order logic for a
restricted class of Kripke models. This result was adjusted by Sobolev [100]
so that the Gabbay's axiom (see Remark 12.2.5) was no longer necessary.
We recommend the paper [99] of Skvorov for a survey of these results. Our
denition below follows the latter paper (up to syntactic sugar).
12.2.3. Definition.
1. A second-order Kripke model is a tuple of the form C = hC;; fD
c
:
c 2 Cgi, where C is a non-empty set,  is a partial order in C, and
the D
c
's are families of upward-closed
3
subsets of C, satisfying
if c  c
0
then D
c
 D
c
0
:
The intuition is that D
c
is the family of predicates meaningful at
state c.
2
A diculty in this proof is that the Lindenbaum algebra of second-order formulas is
not complete and has to be embedded into a complete one in such a way that the existing
joins and meets are preserved.
3
If c
0
2 x 2 D
c
and c
0
 c
00
then also c
00
2 x.
12.2. Semantics 195
2. A valuation in C assigns upward-closed subsets of C to propositional
variables. Such a valuation v is admissible for a state c i v(p) 2 D
c
,
for all propositional variables p. Clearly, a valuation admissible for c
is also admissible for all c
0
 c. We write v
x
p
for a valuation satisfying
v
x
p
(p) = x, and v
x
p
(q) = v(q), for q 6= p.
The forcing relation c; v  ' is dened (when v is admissible for c) as
follows:
 c; v  p i c 2 v(p);
 c; v  ' _  i c; v  ' or c; v   ;
 c; v  ' ^  i c; v  ' and c; v   ;
 c; v  '!  i c
0
; v   , for all c
0
 c with c
0
; v  ';
 c; v  ? never happens;
 c; v  9p' i c; v
x
p
 ', for some x 2 D
c
;
 c; v  8p' i c
0
; v
x
p
 ', for all c
0
 c, and all x 2 D
c
0
.
3. A Kripke model is complete i for every formula ', every c and v, the
set v(') = fc
0
: c
0
; v  'g is in D
c
, whenever v is admissible for c. (If
we understand the meaning of propositional variables free in ' then
we should understand the formula too.)
4. We write ?  ' i for every complete Kripke model C, every c 2 C
and every valuation v admissible for c, such that c; v forces all formulas
in ?, we also have c; v  '.
The completeness theorem for Kripke models in the form below should prob-
ably be attributed to Sobolev [100].
12.2.4. Theorem (Kripke completeness). The conditions ?  ' and ? ` '
are equivalent.
12.2.5. Remark. The additional axiom scheme used by Gabbbay is:
8p( _ '(p)):!  _ 8p'(p); where p 62 FV( ):
This is a classical second-order tautology, but not an intuitionistic tautology.
The class of models corresponding to propositional second-order intuition-
istic logic extended with Gabbay's axiom (called also Grzegorczyk schema)
is obtained by postulating that all D
c
are equal to each other (models with
constant domains).
12.2.6. Remark. Note that the postulate of completeness of Kripke models
reects the idea of impredicativity. Indeed, it guarantees that the range of
a quantied variable includes every denable predicate. In fact, if we do
not require completeness, the following tautology schemes (expressing full
comprehension) would be no longer valid:
196 Chapter 12. Second-order logic and polymorphism
 8p'! '[p :=  ];
 9p (p$ ').
Observe that completeness cannot be replaced by a modied denition of
forcing,
c; v  8p' i c
0
; v
v( )
p
 '; for all c
0
 c; and all formulas  ;
because such a denition would be circular. (Take  = 8p'.)
12.2.7. Remark. It is tempting to consider Kripke models with all D
c
equal
to the family of all upward-closed subsets of C (principal Kripke models).
Unfortunately, the class of all formulas valid in principal models is not re-
cursively enumerable, and thus non-axiomatizable in a nitary way. This
result is due to Skvorov [99] and independently to Kremer [65].
Of course the above mentioned results of Skvorov and Kremer imply
that the set of second-order sentences true in all principal models cannot
be decidable or even recursively enumerable. The set of provable sentences
of our second-order intuitionistic logic is of course recursively enumerable.
But it is undecidable.
12.2.8. Theorem.
It is undecidable whether a given formula ' 2 2 has a proof.
The rst proof of undecidability was given by Gabbay [36, 37]. But this proof
applies to the logic extended by Gabbay's axiom (see Remark 12.2.5), and
it does not extend automatically to the pure intuitionistc case. The proof is
using completeness theorem, for Kripke models with constant domains. The
paper [100] of Sobolev lled this gap, and allowed to infer Theorem 12.2.8 by
essentially the same method. In the meantime, M.H. Lob [67] has published
another proof of Theorem 12.2.8. The main result of [67] which implies
undecidability, is an eective translation from rst-order classical logic to
second-order intuitionistic logic. Unfortunately, Lob's paper is quite in-
comprehensible. It has been later slightly simplied by Arts [3] and Arts
and Dekkers [4], but the resulting presentations are still quite complicated.
A simpler, syntactic proof of Theorem 12.2.8 can be found in [112].
12.3. Polymorphic lambda-calculus (System F)
The polymorphic lambda-calculus 2, often referred to as \System F" is an
excellent example of a Curry-Howard correspondence and provides a surpris-
ing evidence for the relationships between logic and computer science. This
system was actually invented twice: by the logician Jean-Yves Girard [44]
and by the computer scientist John Reynolds [90]. The rst one's goal was
12.3. Polymorphic lambda-calculus (System F) 197
to design a proof notation needed for his work on second-order logic, the
other's idea was to build a type system for a polymorphic programming
language. The results (after dissolving the syntactic sugar) were essentially
the same.
For a treatment of System F extending the scope of the present notes,
one can consult the following books: [45, 66, 74].
12.3.1. Definition.
1. (Second-order) types are dened as follows:
 Type variables are types;
 If  and  are types then ( ! ) is a type;
 If  is a type and  is a type variable, then 8 is a type.
Thus, types coincide with second-order propositional formulas over !
and 8 only.
2. Well-typed lambda-terms (Church style) are dened by the type infer-
ence rules below. Every term is either a variable, an ordinary applica-
tion or abstraction, or it is
 a polymorphic abstraction, written :M , whereM is a term and
 is a type variable, or
 a type application, written (M), where M is a term and  is a
type.
The intuitive meaning of :M is that the term M (which may refer to a
free type variable ) is taken as a polymorphic procedure with a type param-
eter . Type application correspond to a call to such a generic procedure
with an actual type parameter. This is an explicit form of polymorphism
(type as parameter) as opposed to implicit polymorphism of ML.
12.3.2. Definition (Type inference rules). A context is again a nite set of
declarations (x : ), for dierent variables (i.e., nite partial function from
variables to types). The axiom and the rules for ! are as usual:
?; x: ` x : 
? ` N :  !  ? `M : 
? ` NM : 
?; x :  `M : 
? ` x::M :  ! 
and we also have rules for 8 corresponding to natural deduction rules (8I)
and (8E)
? `M : 
? ` (:M) : 8
( 62 FV (?))
? `M : 8
? `M : [ :=  ]
198 Chapter 12. Second-order logic and polymorphism
Let us recall that a Church-style term makes sense for us only within a con-
text that assigns types to free variables. We sometimes stress this fact by
placing (informally) an upper index, as for instance in x
8(!)
y
[:= ]
. In
fact, nding a proper decoration of free variables in a given term expres-
sion (to obtain a proper Church-style term) is, surprisingly, an undecidable
problem, see [95].
12.3.3. Convention. As in previous chapters, we sometimes write upper
indices to mark types of certain (sub)terms. Also, we sometimes write e.g.
x

:M , rather than x::M , to improve readability.
As should be now clear from the rules, the universal type 8() corre-
sponds to a product construction of the form
Q
2?
(). This answers very
well to the idea that a proof of 8() is a function translating proofs of 
into proofs of ().
From the programmer's point of view, 8 is a type of a polymorphic
procedure. Note that the restriction  62 FV (?) in the 8 introduction rule
(called also generalization rule) corresponds to that a type parameter must
be a local identier.
12.3.4. Example. Here are some well-typed Church-style terms:
 ` :(x
8(!)
:x( ! )(x) : 8(8(! ):!  ! );
 ` :f
!
x

:f(fx) : 8((! )! (! ));
 ` f
8(!!)
x

:f(!)(fx) : 8( !  ! ): ! 8( !
 !  ! ).
12.3.5. Theorem (Curry-Howard isomorphism). We have ? `M :  in the
polymorphic lambda calculus if and only if j?j `  has a proof in the f8;!g-
fragment of the second-order intuitionistic propositional logic.
12.3.6. Corollary. The inhabitation problem for the polymorphic lambda
calculus (\Given type  , is there a closed term of type ?") is undecidable.
Proof. Immediate from the above and Theorem 12.2.8. ut
12.3.7. Warning. We skip the detailed denition of free variables and sub-
stitution. The reader should be able to write this denition herself, provided
she remembers about the following:
 There are free object variables in terms as well as free type variables.
The latter occur in the lambda abstractions \x:" and in type appli-
cations. Thus we have to consider substitutions of the formM [x := N ]
and of the form M [ :=  ].
12.4. Expressive power 199
 There are two binding operators in terms: the big and the small
lambda. Substitutions must account for both. And note that the
term N in M [x := N ] may contain free type variables that are bound
in M . Thus, both sorts of renaming may be necessary.
 The denition of alpha conversion must account for the two sorts of
bindings.
 Binding an object variable x

does not mean binding type variables
in .
 The eect of substitution x[ :=  ] is of course x. But if we work
in a context containing a declaration (x : ), then one should better
understand it this way: x

[ :=  ] = x
[:= ]
. This is because what
we want is ?[ :=  ] `M [ :=  ] : [ :=  ] whenever ? `M : .
12.3.8. Definition (Beta reduction).
There are two sorts of beta reduction rules:
 Object reduction: (x::M)N ?!

M [x := N ];
 Type reduction: (:M) ?!

M [ :=  ].
This notion of reduction has the expected properties, in particular it is
Church-Rosser and preserves types.
12.4. Expressive power
In classical logic, the connectives :, _ and ^ can be dened by means of
? and !. The quantier 9 is also expressible via the De Morgan law, so
that ?, ! and 8 make a sucient set of operators. This is not the case in
intuitionistic logic, neither propositional nor rst-order. However, in second-
order propositional logic, this opportunity appears again. And we can even
get more: using ! and 8 one can express the other connectives and also
the constant ?. We have postponed these denitions until now, in order to
accompany them with term notation.
12.4.1. Definition (Absurdity). We dene
? := 8:
We have the following term assignment to rule (E?):
? `M : ?
? `M : 
200 Chapter 12. Second-order logic and polymorphism
It is easy to see that there is no closed term in normal form that can be
assigned type 8. It will follow from strong normalization that ? is an
empty type.
12.4.2. Definition (Conjunction (product)).
Let  be not free in  nor . Then
 ^  := 8(( !  ! )! ):
(Read this denition as:  ^ holds i everything holds that can be derived
from f; g.)
Lambda-terms related to conjunction are pairs and projections. We
dene them as follows:
 hP;Qi := z
!!
: zPQ;
 
1
(M
^
) :=M(x

y

: x);
 
2
(M
^
) :=M(x

y

: y).
It is left to the reader to check that the term assignment to the ^-related
rules of natural deduction, described in Section 4.2:
? ` M :  ? ` N : '
? `< M;N >:  ^ '
? ` M :  ^ '
? ` 
1
(M) :  
? ` M :  ^ '
? ` 
2
(M) : '
is correct, as well as the beta-reduction 
i
(hP
1
; P
2
i) !

P
i
is implemented
(but with !

replaced by !

). Note however that eta-conversion is not
implemented: if y
^
is a variable then h
1
(y); 
2
(y)i is a normal form.
12.4.3. Definition (Disjunction (variant)).
We dene the disjunction of  and  as their weakest common conse-
quence. That is,  _  holds i all common consequences of  and  hold.
Formally, for  62 FV() [ FV(), we take:
 _  := 8(( ! )! ( ! )! ):
We dene injections and case eliminator this way:
 in
1
(M

) := u
!
v
!
: uM ;
 in
2
(M

) := u
!
v
!
: vM ;
 case(L
_
; x

:M

; y

:N

) := L(x

:M)(y

:N).
12.4. Expressive power 201
The reader is invited to check the correctness of rules:
? ` M :  
? ` in
1
(M) :  _ '
? ` M : '
? ` in
2
(M) :  _ '
? ` L :  _ ' ?; x :  ` M :  ?; y : ' ` N : 
? ` case(L;x:M ; y:N) : 
as well as the correctness of beta reduction (Exercise 12.7.6).
Before we discuss the existential quantier, let us observe that various
data types can be implemented in System F. For instance, type Bool can
be interpreted as 8( !  ! ), with true = x

y

: x and false =
x

y

: y. Integers are represented by the type
! := 8((! )! ! );
with the polymorphic Church numerals
c
n
:= f
!
x

: f(   f(x)    )
representing numbers. We can now generalize the notion of a denable
integer function in the obvious way. Clearly, all functions denable in simple
types can also be dened in System F by simply adding some 's at the
beginning. For instance, we dene the successor function as:
succ := n
!
::f
!
x

: f(nfx):
But one can do much more, for instance the function n 7! n
n
can be dened
as follows:
Exp := n
!
: n(! )(n):
Note that this trick uses polymorphism in an essential way. We can general-
ize it to represent primitive recursion. Indeed, System T (as an equational
theory) can be embedded into System F.
12.4.4. Proposition. For a given type , dene r

:  ! ( ! ! ! ) !
! !  as the following term:
y

f
!!!
n
!
: 
1
(n(^!)(v
^!
: hf(
1
(v))(
2
(v)); succ(
2
(v))i)hy; c
0
i):
Then r

MN(c
0
) =

M and r

MN(succ(n)) =

N(r

MNn)n,
Proof. Exercise 12.7.8. ut
The reader is invited to dene representation of various other data types in
Exercise 12.7.7.
Let us now consider the existential quantier. We need a term assign-
ment the introduction and elimination rules. One possibility is as follows:
202 Chapter 12. Second-order logic and polymorphism
(9I)
? `M : [ :=  ]
? ` pack M;  to 9:  : 9: 
(9E)
? `M : 9:  ?; x :  ` N : 
? ` abstype  with x :  is M in N : 
( 62 FV (?; ))
As in the rst-order case, existential quantication corresponds to data ab-
straction. An existential type of the form 9 can be seen as a partial type
specication, where type  is \private" and not accessible for the user. For
instance, one can consider a type of push-down stores (with the push and
pop operations) dened as
!-pds := 9( ^ (! ! ! ) ^ (!  ^ !)):
A user can operate on such a pds without knowing the actual type used to
implement it. A generic pds type may now be dened this way:
generic-pds := 89( ^ ( ! ! ) ^ (!  ^ )):
The beta reduction rule for existential type constructors is as follows:
abstype  with x :  is pack M;  to 9:  in N ?!

N [ :=  ][x :=M ]:
This corresponds to using an abstract type in a context where an actual
implementation may be hidden from the user. More on existential types can
be found in Mitchell's book [74].
Existential quantication can be represented in System F as follows:
12.4.5. Definition. Assuming  62 FV(), we dene
9 := 8(8( ! ):! ):
The packing and unpacking terms are as follows:
 pack M;  to 9:  = :x
8(!)
: xM ;
 abstype  with x :  is M in N

=M(:x

:N).
Compare the above denition to Denition 12.4.3. We again have the weak-
est common consequence of all (), for arbitrary type . This supports
the understanding of existential quantier as innite disjunction. But note
also that there is a similarity to De Morgan's law here: take ? instead of 
and we obtain :8:. We leave to the reader the verication that beta
reduction is correctly implemented.
12.5. Curry-style polymorphism 203
12.5. Curry-style polymorphism
The Curry-style variant of System F is dened by the following type assign-
ment rules for pure lambda terms. These rules correspond exactly to these
in Denition 12.3.2. (The notion of a type and a context remains the same.)
?; x: ` x : 
? ` N :  !  ? `M : 
? ` NM : 
?; x :  `M : 
? ` x:M :  ! 
? `M : 
? `M : 8
( 62 FV (?))
? `M : 8
? `M : [ :=  ]
Rules for abstraction and application are the same as for the simply-typed
Curry-style lambda-calculus. Rules for introducing and eliminating the uni-
versal quantier (called respectively generalization and instantiation rules)
reect the idea of implicit polymorphism: to have the universal type 8 
means to have all possible instances of this type (all types  [ := ]).
12.5.1. Definition. The erasure map j  j from terms of Church-style Sys-
tem F to pure lambda terms, is dened by the following clauses:
jxj = x
jMN j = jM jjN j
jx::M j = x: jM j
j:M j = jM j
jM j = jM j
12.5.2. Proposition. For a pure lambda term M , we have ? `M :  if and
only if there is a Church-style termM
0
with jM
0
j =M , such that ? `M
0
:  .
Proof. Easy.
A Church-style term M
0
can be seen as a type derivation for a Curry-
style term jM
0
j. The following theorem follows from the fact that every
beta reduction performed in a typable pure lambda term corresponds to a
reduction in the corrsponding Church-style term.
12.5.3. Theorem (Subject reduction). Let ? ` M :  , for a pure lambda
term M . Then M !

M
0
implies ? `M
0
:  .
Proof. Omitted. ut
204 Chapter 12. Second-order logic and polymorphism
The above result is not as obvious as it can perhaps appear at the rst look.
To see this, consider the following example:
12.5.4. Example. We have the following correct type assignment:
x : ! 8 ( ! ) ` y: xy : !  ! ;
and the eta-reduction y: xy !

x. However,
x : ! 8 ( ! ) 6` x : !  ! :
Observe that the Church-style term corresponding to y: xy in our example
is y:: xy and is not an -redex. Thus, the reason why Curry-style Sys-
tem F is not closed under -reductions is that there are Curry-style -redexes
that do not correspond to any Church-style redex.
12.5.5. Remark. Closure under -reductions can be obtained (see Mitchell's
paper [73]) by adding to the system a certain subtyping relation  together
with a subsumption rule of the form
? `M : ;   
? `M : :
12.5.6. Remark. Adding existential quantication to Curry-style version of
System F results with the same problem as that described in Section 9.10.
See Exercise 12.7.10.
With polymorphism, one can assign types to many pure lambda terms
which are untypable in simple types. A prominent example is x: xx, and
another one is c
2
K. As we will see below, only strongly normalizable terms
can be typable, because of strong normalization. But there are strongly
normalizable terms, untypable in F. The rst such example
4
was given by
Simona Ronchi Della Rocca and Paola Giannini in the paper [43], and it is
the following term:
(zy: y(zI)(zK))(x: xx):
The essential thing here is that we cannot nd one type for (x: xx) that
could be applied to both I and K. Another example is:
c
2
c
2
K:
Compare the latter to the typable term c
2
(c
2
K).
It was long an open question whether the type reconstruction and type
checking problem for System F was decidable. Both were shown undecidable
by Joe Wells.
12.5.7. Theorem (Wells [117]). Type reconstruction and type checking in
the second-order -calculus are recursively equivalent and undecidable.
Proof. Too long. ut
4
apparently based on an idea of Furio Honsell.
12.6. Strong normalization of second-order typed -calculus 205
12.6. Strong normalization of second-order typed -calculus
We end the chapter by extending the proof of strong normalization of simply
typed -calculus from Chapter 4 to second-order typed -calculus a la Curry.
As mentioned earlier, the standard method of proving strong normaliza-
tion of typed -calculi was invented by Tait [104] for simply typed -calculus
and generalized to second-order typed -calculus by Girard [44].
Our presentation follows again [8].
12.6.1. Definition.
(i) The set of type variables is denoted U and the set of second-order types
is denoted by 
2
.
(ii) A valuation in S is a map
 : U ! S:
(iii) For a valuation , dene the valuation f := Xg by: dened by
f := Xg() =

X if  = 
() otherwise
(iv) For each valuation  in S and each  2 
2
the set [[]]

is dened by:
[[]]

= ()
[[ !  ]]

= [[]]

! [[ ]]

[[8:]]

=
T
X2S
[[]]
f:=Xg
12.6.2. Lemma. For each valuation  in S and  2 
2
, we have [[]]

2 S.
Proof. Similar to the corresponding proof for !. ut
12.6.3. Definition.
(i) Let  be a substitution (i.e., a map from term variables to ), and  be
a valuation in S. Then
;  j=M :  , [[M ]]

2 [[]]

(ii) Let  be a substitution and  be a valuation in S. Then
;  j= ?, ;  j= x : ; for all x :  in ?
(iii) Finally,
? j=M :  , 88[;  j= ?) ;  j=M : ]
12.6.4. Proposition (Soundness).
? ` M :  ) ? j=M : 
206 Chapter 12. Second-order logic and polymorphism
Proof. Similar to the proof for the corresponding property of !, i.e.,
by induction on the derivation of ? ` M : . There are two new cases
corresponding to the 8-rules.
If the derivation ends in
? ` M : 8:
? ` M : f := g
then by the induction hypothesis
? j=M : 8:
Now suppose ;  j= ?, and we are to show that ;  j= M : f := g. We
have
[[M ]]

2 [[8:]]

=
\
X2S
[[]]
f:=Xg
Hence
[[M ]]

2 [[]]
f:=[[ ]]

g
= [[f := g]]

:
If the derivation ends in
? ` M : 
? ` M : 8:
where  is not free in ?, then by the induction hypothesis,
? j=M : :
Suppose ;  j= ?, we are to show that ;  j= M : 8:. Since  is not free
in ?, we have for all X 2 S that ; f := Xg j= ?. Therefore,
[[M ]]

2 [[]]
f:=Xg
for all X 2 S. Hence also
[[M ]]

2 [[8:]]

as required. ut
12.6.5. Theorem (Strong normalization). If ? ` M :  then M is strongly
normalizing.
Proof. Similar to the corresponding proof for !. ut
The above proof diers in a very substantial way from Tait's strong
normalization proof for simple types or for System T. The dierence is that
a formalization of this argument necessarily requires quantication over sets
of sets of -terms.
12.7. Exercises 207
Indeed, let us compare the statement of Lemma 12.6.2 and Lemma 4.4.3
part (iii). As we have noticed in Chapter 11, the latter requires quantica-
tion over sets X satisfying the denition of [[]]. But then we could dene
a xed set [[]] for each  by induction. Because of impredicativity, such a
denition of [[]] would now become circular and we must consider various
candidates [[]]

for the position of [[]]. Each  gives a family of such candi-
dates (sets), and the quantication over  in the statement of Lemma 12.6.2
is equivalent to quantications over these families.
In other words, our proof cannot be formalized even in the second-order
language of arithmetic. In fact, we can repeat Godel's argument and obtain
a consistency proof for second-order Peano Arithmetic in this way. Thus,
strong normalization for System F makes an example of a statement inde-
pendent from second-order Peano Arithmetic.
But as long as we are only interested in strong normalization of a set
of terms involving only nitely many types, we can proceed within second-
order arithmetic. Indeed, in this case, the functions  are of nite domains
and can be handled as tuples of sets. Thus, if (an algorithm of) an integer
function is denable in F, then its totality can be shown within second-order
arithmetic. On the other hand, the Dialectica interpretation, generalized by
Girard for System F, allows one to derive a denition in F for every function
provably total in second-order arithmetic. We obtain the following result:
12.6.6. Theorem (Girard). The class of functions denable in F coincides
with the class of provably recursive functions of second-order Peano Arith-
metic.
12.7. Exercises
12.7.1. Exercise. Prove that Gabbay's axiom holds in all Kripke models
with constant domains, but not in all Kripke models.
12.7.2. Exercise. Can you simplify the denition of forcing of universal
formulas in models with constant domains? Hint: Yes, you can.
12.7.3. Exercise. Show that in complete Kripke models, the semantics of
the dened connectives (see Section 12.4) coincides with the semantics of
their denitions. Does this hold in non-complete models?
12.7.4. Exercise. Show that the type assignment rules for pairs and pro-
jections are correct under Denition 12.4.2 and that 
i
(hP
1
; P
2
i)!

P
i
.
12.7.5. Exercise. Show that the type assignment rules for injections and
case elimination are correct under Denition 12.4.3 and that beta-reduction
is properly implemented, i.e.,
case(in
i
(N

i
); x

1
1
:M

1
; x

2
2
:M

2
)!

M
i
[x
i
:= N ].
208 Chapter 12. Second-order logic and polymorphism
12.7.6. Exercise. Consider the eta reduction rule for disjunction, and the
commuting conversions of Denition 7.23. Are they correct with respect to
Denition 12.4.3?
12.7.7. Exercise. Dene an interpretetion in System F for the types of:
 words over a xed nite alphabet;
 nite binary trees;
 lists over a type  ,
with the appropriate basic operations on these types.
12.7.8. Exercise. Prove Proposition 12.4.4. Can you strenghten it by re-
placing =

by !

?
12.7.9. Exercise. Show that the denitions of abstype and pack in Sys-
tem F satisfy the beta reduction rule for existential types.
12.7.10. Exercise. Consider a Curry-style calculus with existential types,
analogous to the Curry-style calculus with rst-order existential quantica-
tion, as in Section 10.5. Show that it does not have the subject reduction
property.
12.7.11. Exercise. Verify the correctness of Example 12.5.4.
12.7.12. Exercise. Show that all terms in normal form are typable in Sys-
tem F.
12.7.13. Exercise. Show that (x: xx)(z: zyz) is typable in System F.
12.7.14. Exercise. Show an example of a pure lambda-term M , typable in
System F, and such that M !

M
0
, for some untypable M
0
. Warning: An
example known to the authors is the term
a: [yz: a((v: v(xy: yay))y)(zy)(z(x: xxx))]Y Z;
where Y is x:K(xx)(xaa) and Z is u: u(xy: a). A verication takes 5
handwritten pages.
12.7.15. Exercise. Prove that (x: xx)(x: xx) is untypable in System F,
without using the fact that typable terms can be normalized.
12.7.16. Exercise. Prove that the terms c
2
c
2
K and (zy: y(zI)(zK))(x: xx)
are untypable in System F.
12.7.17. Exercise. Show that the polymorphic type assignment has no prin-
cipal type property. (For instance show that x: xx has no principal type.)
12.7.18. Exercise. Assume strong normalization for Curry-style System F.
Derive strong normalization for Church-style System F.
CHAPTER 13
The -cube and pure type systems
In this chapter we introduce Barendregt's -cube which can be seen as a
generic typed -calculus with eight instances. Among these are !, 2,
and P seen earlier. We also present the generalization to pure type systems
which can be seen as a generic typed -calculus with innitely many typed
-calculi as instances|among these are the eight systems of the -cube.
We rst present some motivation for the study of the -cube and then
proceed to the actual denitions. A number of examples are given to illus-
trate various aspects of the -cube. We then argue that the new presenta-
tions of ! etc. are equivalent to the previous presentations, although we
do not settle this in all detail.
After this, we introduce pure type systems, give a number of examples,
and develop the most rudimentary theory of pure type systems.
The presentation follows [8].
13.1. Introduction
The previous chapters of the notes have presented several related typed -
calculi, e.g, the simply typed -calculus !, the system P of dependent
types, and the second-order typed -calculus 2.
1
The simplest of the systems is clearly simply typed -calculus; in this
system one can have a term x : : x of type  ! , in short
` x : : x :  ! :
Given a term M , we may form the new term x :  : M which expects a
term as argument; in other words, the term x : : M depends on a term.
Thus, in !, terms may depend on terms.
1
In this chapter we are exclusively concerned with typed -calculi a la Church.
209
210 Chapter 13. The -cube and pure type systems
In 2 one can have a term
2
:: x : : x of type 8:! , in short
` :: x : : x : 8:! :
Given a term M , we may form the new term  : : M which expects a
type  as argument; in other words, the term : : M depends on a type.
Thus, in 2 terms may depend on types.
Finally, in the system P , we can have an expression x : :  expecting
a term of type  as argument and returning the type  as result. Such
an expression is called a type constructor since it constructs a type when
provided with suitable arguments. To describe the input and output of a
term one uses types; a term has a certain type. Similarly, the input and
output of constructors are described by kinds. For instance, if  is a type,
then x : :  has kind ! , in short
 :  ` x : :  : ) ;
expressing the fact that the constructor expects a term of type  and con-
structs a member of , i.e., a type. If we apply this expression to a term of
type , then we get a type:
 : ; y :  ` (x : : ) y : :
In conclusion, given a type  we may form the type constructor x : : 
which expects a term of type  as argument; in other words, the type con-
structor x :  :  depends on a term. Thus, in P types may depend on
terms.
There is one combination we have not mentioned: we have seen terms
depending on terms, terms depending on types and types depending on
terms|what about types depending on types? Can we have expressions
like  :  :  ! ? This would again be a type constructor, but where
the argument is now a type rather than a term; such an expression would
have kind  ! . In fact, a system exists in which such expressions may be
formed, known as !.
The three systems 2, P , and ! each arise from ! by adding an-
other type of dependency than terms depending on terms; it is natural to
study also the combination of these dependencies, and systems exist in which
several dependencies are allowed, e.g., the system ! in which both terms
depending on types and types depending on types are allowed, and this will
also be done below.
Before proceeding with the details of such systems, it will be well worth
our eort to reconsider the style or presentation from previous chapters.
In all the -calculi presented in previous chapters, one or more forms of
2
The annotation \: " was not written in the preceding chapter. The informal meaning
of  :  is that  is a type.
13.2. Barendregt's -cube 211
abstraction are present, and dierent rules govern the typing of the various
forms of abstraction. For instance, in 2 we have both
?; x :  ` M : 
? ` x : : M :  ! 
and
? ` M : 
? ` :  :M : 8:
Similarly, we have several types of products, e.g.  !  and 8:.
It would be better if we could present the systems with a single notion of
abstraction parametrized over the permitted dependencies. This is exactly
what one does on the -cube.
This idea facilitates a more slick presentation of each of the systems
in the -cube, and also makes the connection between the various systems
more transparent. Moreover, properties about the various systems can be
developed once and for all by providing proofs that are parametric in the
permitted dependencies: if we can prove, e.g., subject reduction regardless
of which dependencies are permitted, then we do not have to prove the
property for all the systems individually.
13.2. Barendregt's -cube
We introduce Barendregt's -cube following [8].
13.2.1. Definition.
(i) The set S of sorts is dened by S = f;2g. We use s; s
0
; s
1
; s
2
, etc. to
range over sorts.
(ii) For each s 2 S, let V
s
denote a countably innite set of variables such
that V
s
\ V
s
0
= ; when s 6= s
0
, and let V =
S
s2S
V
s
.
(iii) The set E of expressions is given by the abstract syntax:
E = V j S j EE j V : E :E j V : E :E
As before, we assume familiarity with the subexpression relation, with
the set FV(M) of free variables ofM , and with substitutionMfx := Ng
for x 2 V andM;N 2 E . We writeA! B for d:A:B when d 62 FV(B).
We use = to denote syntactic identity modulo -conversion and adopt
the usual hygiene conventions.
(iv) The relation !

on E is the compatible closure of the rule
(x :A : M) N  Mfx := Ng
Also,!

and =

are the transitive, reexive closure and the transitive,
reexive, symmetric closure of !

, respectively.
212 Chapter 13. The -cube and pure type systems
(v) The set C of contexts is the set of all sequences
x
1
:A
1
; : : : ; x
n
:A
n
where x
1
; : : : ; x
n
2 V, A
1
; : : : ; A
n
2 E , and x
i
6= x
j
when i 6= j.
The empty sequence is [], and the concatenation of ? and  is ?;.
We write x : A 2 ? if ? = ?
1
; x : A;?
2
, for some ?
1
, ?
2
, and we
write ?   if, for every x : A 2 ?, also x : A 2 . For ? 2 C,
dom(?) = fx j x :A 2 ?; for some Ag.
(vi) For any set R  S  S of rules, the relation `  C  E  E is dened
in Figure 13.1. If ? ` M : A, then ? is legal and M , A are legal (in
?). We use the notation ? ` A : B : C meaning that ? ` A : B and
? ` B : C.
(axiom) [] `  : 2
(start)
? ` A : s
?; x :A ` x : A if x 2 V
s
& x 62 dom(?)
(weakening)
? ` A : B ? ` C : s
?; x :C ` A : B if x 2 V
s
& x 62 dom(?)
(product)
? ` A : s
1
?; x :A ` B : s
2
? ` (x:A: B) : s
2
if (s
1
; s
2
) 2 R
(application)
? ` F : (x:A: B) ? ` a : A
? ` F a : Bfx := ag
(abstraction)
?; x :A ` b : B ? ` (x:A: B) : s
? ` x :A : b : x:A: B
(conversion)
? ` A : B ? ` B
0
: s
? ` A : B
0
if B =

B
0
Figure 13.1: Inference rules of the -cube
(vii) The -cube consists of the eight -calculi obtained by taking the dier-
ent sets of rules f(; )g  R  f(; ); (2; ); (;2); (2;2)g specied
in the table in Figure 13.2.
13.2. Barendregt's -cube 213
! (; )
2 (; ) (2; )
! (; ) (2;2)
! = !2 (; ) (2; ) (2;2)
P (; ) (;2)
P2 (; ) (2; ) (;2)
P! (; ) (2;2) (;2)
C = P! (; ) (2; ) (2;2) (;2)
Figure 13.2: Rules of the -cube
13.2.2. Remark. The dierent rules in Figure 13.2 correspond to the de-
pendencies mentioned earlier:
(; ) : terms depending on terms
(;2) : terms depending on types
(2; ) : types depending on terms
(2;2) : types depending on types
Informally speaking, terms may also depend on types in !; for instance,
x :  : x is a term depending on the type . However, the crucial point
is that we may not abstract over  in the term. In contract, this form of
abstraction is permitted in 2.
The -cube is depicted diagrammatically in Figure 13.3.
!
//
C
2
??
//
P2
??
!
//
OO
P!
OO
!
OO
//
??
P
??
OO
Figure 13.3: The -cube
214 Chapter 13. The -cube and pure type systems
13.3. Example derivations
There are several subtle details in the previous denition. Some of these
are illustrated in the following examples, taken from [8], which the reader is
encouraged to work out in detail.
13.3.1. Example. In ! one can derive the following.
1.  :  ` x::  : . Being a member of  should be conceived as being
a type, so if  is a type, then so is x:: .
Here  is a variable from V
2
(type variables) and x is another variable
from V

(term variables). Hence x 62 FV(), so x: :  =  ! ,
using the abbreviation from Denition 13.2.1(iii).
This means that we may form expressions that map terms of type 
to terms of type  (terms may depend on terms).
Note that the type variable  must be declared in the context; the
only typing in the empty context in this formulation of ! is `  : 2!
2.  :  ` x :  : x : x : : . Using the abbreviation from Deni-
tion 13.2.1(iii), this means that we have  :  ` x : : x : ! .
Note that  :  ` x :  : x : x : :  does not follow from the
mere fact that  : ; x :  ` x :  alone; we also have to show that
 :  ` x:: : , which can be derived using the fact that (; ) 2 R.
3.  : ;  : ; y :  ` x : : y : x:: .
4.  : ; y :  ` (x : : x) y : .
5.  : ; y :  ` y : . We have
(x : : x) y !

y:
Note that typing is preserved under this particular reduction.
6.  : ;  : ; x : ; y :  ` (z :  : y) x : . Note how the weakening
rule is required to establish this.
7.  : ;  :  ` x : : y : : y : !  !  : .
13.3.2. Example. In 2 one can derive the following.
1.  :  ` x : : x : ! , just like in !.
2. `  : : x : : x : :: !  : .
To understand the relationship with the previous formulation of 2,
the reader should realize that  : :  is just a new way of writing
8: and that  : : M is just a new way of writing :: M .
13.3. Example derivations 215
This means that we may form expressions that map any type  to a
term of type !  (terms may depend on types).
The reader may be worried about the absence of the side condition
\where  is not free in the context" in the abstraction rule for second-
order generalization. How can we be sure that we do not move from
 : ; x :  ` M :  to x :  `  :  : M :  : : , where we
generalize over a variable which is free in the context? Interestingly,
this is ensured by the fact that contexts are sequences and that we
may discharge the rightmost assumption only.
This also shows why the weakening rule is necessary: without weaken-
ing, we could not derive something as elementary as  : ; x :  `  : .
3.  :  ` ( : : x : : x)  :  ! .
4.  : ; y :  ` ( : : x : : x)  y : . We have
( : : x : : x)  y !

(x : : x) y !

y
and each of these terms has type .
5. Let ? = ::. Then ` ( : : x :? : x ) : ::? ! . Via the
Curry-Howard isomorphism this type is a proposition in second-order
propositional logic which states that everything follows from absurdity;
the term is the constructive proof of the proposition.
13.3.3. Example. Let D =  :  :  ! . In ! one can derive the
following.
1. `  !  : 2. Being a member of 2 should be conceived as being a
kind, so  !  is a kind.
This means that we may form expressions that map types to types
(types may depend on types).
2. ` D :  ! .
3.  :  ` D  : .
4.  :  ` D (D ) : .
5.  :  ` x : (D ) : x : (D )! (D ).
6.  :  ` x : (D ) : x : D (D ). Note how the conversion rule is used
to derive this. We have
(D )! (D ) =

D (D )
and the conversion rule allows us to exchange the rst type with the
second.
216 Chapter 13. The -cube and pure type systems
13.3.4. Example. In P one can derive the following.
1.  :  ` !  : 2.
This means that we may form expressions that map a term of type 
to a type (types may depend on terms).
If we view  as a set and  as the universe of propositions, then a
member of  !  is a map from  to propositions, i.e., a predicate
on .
2.  : ; p :  ! ; x :  ` p x : . Again, if we view  as a set, p as a
predicate on , and x as an element of , then p x is a proposition.
3.  : ; p : ! !  ` x:: p x x : .
If  is a set and p is a binary predicate on , then x: : p x x is a
proposition.
4.  : ; p :  ! ; q :  !  ` x: : p x ! q x : . This proposition
states that every member of  which satises p also satises q.
5.  : ; p : !  ` x : : z :p x : z : x:: p x! p x.
6.  : ; x
0
: ; p : ! ; q :  `
z : (x:: p x! q) : y : (x:: p x) : (x a
0
) (y a
0
) :
(x:: p x! q)! (x:: p x)! q.
This proposition states that in every non-empty set A,
(8x 2 A : P x! Q)! (8x 2 A : P x)! Q:
13.3.5. Example. In !, the following can be derived.
1. Let & =  : : ( !  ! ) ! . Then  : ;  :  ` & : .
This is can also be derived in 2; it is the second-order denition of
conjunction.
2. Let AND =  :  :  :  : &. Then ` AND :  !  !  and
` AND : . Thus, AND is a uniform denition of conjunction over
all types|this cannot be done in 2.
3. Let 
i
= 
1
: : 
2
: : x
1
:
1
: x
2
:
2
: x
i
. Then
` 
i
: 
1
:: 
2
:: 
1
! 
2
! 
i
:
Also,
 : ;  :  ` x :AND   : x  (
1
 ) : AND   ! :
13.4. Classication and equivalence with previous formulations 217
13.3.6. Example. In P2 the following can be derived.
1.  : ; p : !  ` x : : p x! ? : !  Here the construction of ?
requires 2 and the construction of expressions !  requires P .
2.  : ; p : !  ` (x:: y:: p x y ! p y x! ?)! z:: p z z !
? : : This proposition states that an asymmetric binary relation is
irreexive.
13.3.7. Example. In P! the following can be derived.
1.  :  ` p :! !  : x : : p x x : (! ! )! (! ).
This constructor maps any predicate to its own \diagonalization."
Here the presence of  to the left and right of ! requires !, and the
construction of !  requires P .
2. `  : : p :! !  : x : : pxx : ::( ! ! )! (! ).
This constructor does the same uniformly in .
13.3.8. Example. In C the following can be derived.
1.  : : p :! ? : x : : p x! ? : :: ( ! ) ! (! ): This
constructor maps a type  and a predicate p on  to the negation of p.
Here the presence of  on both sides of ! requires !, and A ! 
requires P , and :: : : : requires 2.
13.4. Classication and equivalence with previous formula-
tions
The above presentation of ! etc. has several advantages, as mentioned
above. However, the presentation also has the disadvantage that in the case
of some of the simple systems (e.g. !) the presentation involves a certain
amount of redundancy. For instance, in case of ! the product x:A: B
mentioned in the product rule always has form A! B. Also, the distinction
between terms, types, and kinds, which is abandoned in the cube is, after
all, useful for understanding the details of the various systems.
In this section we therefore try to recover some of what has been lost by
showing that|to a certain extent|the traditional formulations of some of
the systems in the -cube are equivalent with the formulations in terms of
the -cube. More about this can be found in [12, 8, 41].
Below we show how terms belonging to systems in the -cube can be
classied according to the notions of object, constructors, and kinds.
218 Chapter 13. The -cube and pure type systems
13.4.1. Definition. Dene the sets O;T ;K of objects, constructors, and
kinds as follows:
O ::= V

j V

:T : O j O O j V
2
:K : O j O T
T ::= V
2
j V

:T : T j T O j V
2
:K : T j T T jV

:T : T jV
2
:K: T
K ::= V

:T : K j V
2
:K: K j 
Reading objects as terms, constructors as types, and kinds as|well|
kinds, this crystalizes the four forms of dependencies between terms and
types expressed by the four forms of abstractions, or the four forms of prod-
ucts.
The following selects among the above expressions those that are legal.
In the denition and the following proposition, ` refers to C.
13.4.2. Definition. Dene the sets O
+
;T
+
;K
+
as follows:
O
+
= fO 2 O j 9?; A :? ` O : Ag
T
+
= fT 2 T j 9?; A :? ` T : Ag
K
+
= fK 2 K j 9? :? ` K : 2g
13.4.3. Proposition (Classication of the -cube).
1. The sets O
+
;T
+
;K
+
and f2g are pairwise disjoint and closed under
reduction.
2. If ? ` A : B then exactly one of the following holds:
 (A;B) 2 O
+
 T
+
, or
 (A;B) 2 T
+
K
+
, or
 (A;B) 2 K
+
 f2g
One obtains similar classications for particular systems within the -cube:
1. For !,2,!, and ! omit the clauses V

: T : T , T O, and
V

:T : K;
2. For !,2,P2, and P omit the clauses V
2
: K : T , T T , and
V
2
:K: K;
3. For !,!,P!, and P omit the clauses V
2
: K : O, O T , and
V
2
:K: T .
One can use this to show, e.g., that in ! products x::  in fact always
have form ! , i.e., x 62 FV().
13.5. Pure type systems 219
13.5. Pure type systems
In this subsection we introduce pure type systems, as presented by Baren-
dregt, Geuvers, and Nederhof [8, 42, 41]. The main ideas in the step from
the -cube to pure type systems are the following:
1. One takes a set S as the set of sorts rather than just f;2g.
2. One takes a relation A  S  S as the set of axioms rather than the
single axiom ( : 2).
3. One takes a relation R  S S S as the set of rules rather than the
specic sets of rules from Figure 13.2.
4. The product rule is generalized so that products need not live in the
same universe as their range. That is, A! B does not necessarily live
in the same sort as B.
3
13.5.1. Definition. A pure type system (PTS ) is a triple (S;A;R) where
(i) S is a set of sorts;
(ii) A  S  S is a set of axioms;
(iii) R  S  S  S is a set of rules.
We write (s; s
0
) 2 R for (s; s
0
; s
0
) 2 R.
13.5.2. Definition. Let (S;A;R) be a PTS.
(i) For each s 2 S, let V
s
denote a countably innite set of variables such
that V
s
\ V
s
0
= ; when s 6= s
0
, and let V =
S
s2S
V
s
.
(ii) The set E of expressions is given by the abstract syntax:
E = V j S j EE j V : E :E j V : E :E
We assume familiarity with the subexpression relation , with the set
FV(M) of free variables of M , and with substitution Mfx := Ng for
x 2 V and M;N 2 E . We write A! B for d:A: B when d 62 FV(B).
We use = to denote syntactic identity modulo -conversion and adopt
the usual hygiene conventions|see [7].
(iii) The relation !

on E is smallest compatible relation satisfying
(x :A : M) N !

Mfx := Ng
Also,!

and =

are the transitive, reexive closure and the transitive,
reexive, symmetric closure of !

, respectively.
3
Notice the dierence in the side condition in the product rule in the -cube and the
product rule in pure type systems (see below): in the latter case we also have to specify
s
3
|the sort in which the product is to live.
220 Chapter 13. The -cube and pure type systems
(iv) The set C of contexts is the set of all sequences
x
1
:A
1
; : : : ; x
n
:A
n
where x
1
; : : : ; x
n
2 V, A
1
; : : : ; A
n
2 E , and x
i
6= x
j
when i 6= j.
The empty sequence is [], and the concatenation of ? and  is ?;.
We write x : A 2 ? if ? = ?
1
; x : A;?
2
, for some ?
1
, ?
2
, and we
write ?   if, for every x : A 2 ?, also x : A 2 . For ? 2 C,
dom(?) = fx j x :A 2 ?; for some Ag.
(v) The relation `  CEE is dened in Figure 13.4. If ? ` M : A, then
? is legal andM , A are legal (in ?). We use the notation ? ` A : B : C
meaning that ? ` A : B and ? ` B : C.
(axiom) [] ` s
1
: s
2
if (s
1
; s
2
) 2 A
(start)
? ` A : s
?; x :A ` x : A if x 2 V
s
& x 62 dom(?)
(weakening)
? ` A : B ? ` C : s
?; x :C ` A : B if x 2 V
s
& x 62 dom(?)
(product)
? ` A : s
1
?; x :A ` B : s
2
? ` (x:A: B) : s
3
if (s
1
; s
2
; s
3
) 2 R
(application)
? ` F : (x:A: B) ? ` a : A
? ` F a : Bfx := ag
(abstraction)
?; x :A ` b : B ? ` (x:A: B) : s
? ` x :A : b : x:A: B
(conversion)
? ` A : B ? ` B
0
: s
? ` A : B
0
if B =

B
0
Figure 13.4: Pure type systems
13.5.3. Convention. To save notation we often consider in the remainder a
PTS S and say, e.g., that s 2 S orM 2 E with the understanding that S =
(S;A;R) and that V, E , C, !

and ` are dened as in Denition 13.5.2.
13.6. Examples of pure type systems 221
13.6. Examples of pure type systems
13.6.1. Example. The -cube consists of the eight PTSs S, where
(i) S = f;2g;
(ii) A = f(;2)g;
(iii) f(; )g  R  f(; ); (2; ); (;2); (2;2)g.
The following systems extend ! with sort 4, axiom 2 : 4, and some
rules for the new sort. The system HOL is dened by:
(i) S = f;2;4g;
(ii) A = f(;2); (2;4)g;
(iii) R = f(; ); (2; ); (2;2)g.
The system U
?
is dened by:
(i) S = f;2;4g;
(ii) A = f(;2); (2;4)g;
(iii) R = f(; ); (2; ); (2;2); (4;2)g.
The system U is dened by:
(i) S = f;2;4g;
(ii) A = f(;2); (2;4)g;
(iii) R = f(; ); (2; ); (2;2); (4; ); (4;2)g.
13.6.2. Example. The system  is dened by:
(i) S = fg;
(ii) A = f(; )g;
(iii) R = f(; )g.
We end this section with an example of a somewhat dierent pure type
system.
13.6.3. Example. The system PRED is dened by:
(i) S = f
s
; 
p
; 
f
;2
s
;2
p
g;
(ii) A = f(
s
;2
s
); (
p
;2
p
)g;
(iii) R = f(
p
; 
p
); (
s
; 
p
); (
s
;2
p
); (
s
; 
s
; 
f
); (
s
; 
f
; 
f
)g.
This is another formulation of predicate logic as a PTS (other than P ).
The signicance of the sorts is as follows.
222 Chapter 13. The -cube and pure type systems
1. The sort 
s
is for sets.
2. The sort 
p
is for propositions.
3. The sort 
f
is for rst-order functions from sets to sets.
4. The sorts 2
s
and 2
p
contain 
s
and 
p
respectively. There is no
sort 2
f
. This means that we cannot have variables ranging over func-
tion spaces.
The signicance of the rules is as follows.
1. The rule (
p
; 
p
) allows the formation of implication between proposi-
tions.
' : 
p
;  : 
p
` '!  = x:':  : 
p
2. The rule (
s
; 
p
) allows quantication over sets.
 : 
s
; ' : 
p
` 8x 2 :' = x:: ' : 
p
3. The rule (
s
;2
p
) allows the formation of rst-order predicates.
 : 
s
` ! 
p
= x:: 
p
: 2
p
so
 : 
s
; p : ! 
p
; x :  ` p x : 
p
:
4. The rule (
s
; 
s
; 
f
) allows the formation of function spaces between
sets.
 : 
s
;  : 
s
` !  : 
f
:
5. The rule (
s
; 
f
; 
f
) allows the formation of curried multi-argument
function spaces between sets.
 : 
s
` ! (! ) : 
f
:
13.7. Properties of pure type systems
As mentioned in the introduction, one of the reasons for introducing the
-cube is the desire to facilitate proofs which apply to a number of systems
at the same time. For instance, it is better to prove the subject reduction
property in a generic way which applies to all the systems in the -cube,
regardless of the particular set R of rules, than it is to prove the property
for each system individually.
This idea is even more compelling in the case of pure type systems:
having shown that a property holds for all pure type systems we know
not only that the property holds for all the systems of the -cube, but
13.7. Properties of pure type systems 223
also for innitely many other systems, a number of which have appeared
independently in the literature.
In this section we develop the most rudimentary theory of pure type
systems. Throughout the section, S denotes an arbitrary pure type system.
13.7.1. Lemma (Properties of substitution).
1. Afx := Bgfy := Cg = Afy := Cgfx := Bfy := Cgg, if y 62 FV(B);
2. B =

C ) Afx := Bg =

Afx := Cg;
3. A =

B & C =

D ) Afx := Cg =

Bfx := Dg.
Proof. (1)-(2): By induction on A. (3): By induction on A =

B, using
(1)-(2). ut
13.7.2. Proposition (Church-Rosser). The relation !

on E is conuent.
Proof. By the technique of Tait and Martin-Lof|see e.g. [8]. ut
13.7.3. Lemma (Free variables). If x
1
:A
1
; : : : ; x
n
:A
n
` B : C then:
1. x
1
; : : : ; x
n
are distinct;
2. FV(B) [ FV(C)  fx
1
; : : : ; x
n
g;
3. FV(A
i
)  fx
1
; : : : ; x
i?1
g for 1  i  n.
Proof. By induction on the derivation of x
1
:A
1
; : : : ; x
n
:A
n
` B : C. ut
13.7.4. Lemma (Start). If ? is legal then:
1. (s
1
; s
2
) 2 A ) ? ` s
1
: s
2
;
2. x :A 2 ? ) ? ` x : A.
Proof. Since ? is legal ? ` B : C for some B;C. Proceed by induction
on the derivation of ? ` B : C. ut
13.7.5. Lemma (Transitivity). Let  be legal. If x
1
:A
1
: : : ; x
n
:A
n
` A : B
and  ` x
i
: A
i
for i = 1; : : : ; n then  ` A : B.
Proof. By induction on the derivation of x
1
: A
1
; : : : ; x
n
: A
n
` A : B
making use of the start lemma. ut
13.7.6. Lemma (Substitution). If ?; x :A; ` B : C and ? ` a : A, then
4
?;fx := ag ` Afx := ag : Bfx := ag.
4
Substitution (and any other map) is extended from expressions to contexts in the
usual way.
224 Chapter 13. The -cube and pure type systems
Proof. By induction on the derivation of ?; x :A; ` B : C using the free
variables lemma and properties of substitution. ut
13.7.7. Lemma (Thinning). If ? ` A : B,  is legal, and every (x :A) in ?
is also in , then  ` A : B.
Proof. This follows from the start lemma and the transitivity lemma. ut
13.7.8. Lemma (Generation). Suppose that ? ` M : C.
1. M = s ) 9(s; s
0
) 2 A: C =

s
0
2. M = x ) 9D 2 E : C =

D & x :D 2 ?.
3. M = x:Ab ) 9s2S; B 2 E : C =

x:A: B & ?;x :A ` b : B & ? `
x:A: B : s.
4. M = x:A: B ) 9(s
1
; s
2
; s
3
) 2 R: C =

s
3
& ? ` A : s
1
& ?; x :
A ` B : s
2
.
5. M = F a ) 9x2V; A;B 2 E : C =

Bfx := ag & ? ` F : x :
A: B & ? ` a : A.
Proof. By induction on the derivation of ? ` M : C. ut
13.7.9. Lemma (Correctness of types). If ? ` A : B then either B 2 S or
9s 2 S: ? ` B : s.
Proof. By induction on ? ` A : B, using the generation and substitution
lemmas. ut
13.7.10. Theorem (Subject reduction). If ? ` A : B and A !

A
0
then
? ` A
0
: B.
Proof. Prove by simultaneous induction on the derivation of ? ` A : B:
1. if ? ` A : B and A!

A
0
then ? ` A
0
: B;
2. if ? ` A : B and ?!

?
0
then ?
0
` A : B.
The proof uses the substitution lemma. ut
13.8. The Barendregt-Geuvers-Klop conjecture 225
13.8. The Barendregt-Geuvers-Klop conjecture
The following terminology should be well-known by now.
13.8.1. Definition. Let S be a PTS. A -reduction path from an expres-
sion M
0
is a (possibly innite) sequence M
0
!

M
1
!

M
2
!

: : : If the
sequence is nite, it ends in the last expression M
n
and has length n.
13.8.2. Definition. Let S be a PTS, and M an expression.
(i) M 2 1

, there is an innite -reduction path from M ;
(ii) M 2 NF

, there is no -reduction path of length 1 or more from M ;
(iii) M 2 SN

, all -reduction paths from M are nite;
(iv) M 2WN

, there is a -reduction from M ending in N 2 NF

.
Elements of NF

; SN

;WN

are -normal forms, -strongly normalizing, and
-weakly normalizing, respectively. We also write, e.g.,1

(M) forM 2 1

.
13.8.3. Definition. S is weakly normalizing if all legal expressions are
weakly normalizing, and strongly normalizing if all legal expressions are
strongly normalizing. In this case we write S j= WN

and S j= SN

,
respectively.
13.8.4. Example. All the systems of the -cube are strongly normalizing|
see, e.g., [12, 8, 42, 41]. The system  is the simplest PTS which is not
strongly normalizing. The system U is is a natural extension of ! which,
surprisingly, is not strongly normalizing. This result shows that, apparently,
the fact that  fails to be strongly normalizing is not merely a consequence
of the cyclicity in its axiom (; ).
We conclude the notes by mentioning an open problem in the eld|for
more on the problem see [101].
13.8.5. Conjecture (Barendregt, Geuvers, Klop). For every PTS S:
S j= WN

) S j= SN

226 Chapter 13. The -cube and pure type systems
CHAPTER 14
Solutions and hints to selected exercises
Some of the solutions below are based on actual homework done in L
A
T
E
X by
Henning Niss (1.7.7) and Henning Makholm (6.8.20 and 6.8.21). In one of
his homeworks, Henning Makholm has solved an apparently open problem
(Exercise 6.8.3).
Exercise 1.7.7
14.0.6. Lemma (Substitution Lemma). If x 6= y and x 62 FV(L) then
Mfx := Ngfy := Lg =Mfy := Lgfx := Nfy := Lgg
Proof. By induction on M .
Case M = x. Since x 6= y:
Mfx := Ngfy := Lg = xfx := Ngfy := Lg
= Nfy := Lg
= xfx := Nfy := Lgg
= xfy := Lgfx := Nfy := Lgg
= Mfy := Lgfx := Nfy := Lgg
The remaining cases are shown in less detail.
Case M = y. Since x 62 FV(L):
Mfx := Ngfy := Lg = L
Mfy := Lgfx := Nfy := Lgg
Case M = z where z 6= x and z 6= y. Then:
Mfx := Ngfy := Lg = z
= Mfy := Lgfx := Nfy := Lgg
Case M = z:P . Without loss of generality we may assume z 6= x and
227
228 Chapter 14. Solutions and hints to selected exercises
z 6= y. Then by the induction hypothesis:
Mfx := Ngfy := Lg = z:Pfx := Ngfy := Lg
= z:Pfy := Lgfx := Nfy := Lgg
= Mfy := Lgfx := Nfy := Lgg
Case M = P Q. Similar to the preceding case. ut
The following states that !

is compatible.
14.0.7. Lemma. Assume that P; P
0
2  are such that P !

P
0
. Then, for
all x 2 V and all Q 2 :
(i) x:P !

x:P
0
;
(ii) P Q !

P
0
Q;
(iii) Q P !

Q P
0
.
Proof. (i): By induction on the derivation of P !

P
0
.
Case P !

P
0
because P !

P . Then x:P !

x:P
0
. Therefore
also x:P !

x:P
0
.
Case P !

P
0
because P !

P
00
and P
00
!

P . By the induction
hypothesis, x:P !

x:P
00
and x:P
00
!

x:P
0
, so x:P !

x:P
0
.
Case P !

P
0
because P = P
0
. Then x:P = x:P
0
. Therefore also
x:P !

x:P
0
.
(ii)-(iii): induction on the denition of P !

P
0
ut
14.0.8. Lemma. For all P; P
0
; Q 2 , if
P !

P
0
then also
Pfx := Qg !

P
0
fx := Qg:
Proof. By induction on the derivation of P !

P
0
. The interesting case
is P = (y:P
1
) Q
1
!

P
1
fy := Q
1
g = P
0
. We have
((y:P
1
) Q
1
)fx := Qg = (y:P
1
fx := Qg) (Q
1
fx := Qg)
!

P
1
fx := Qgfy := Q
1
fx := Qgg
= P
1
fy := Q
1
gfx := Qg;
where the last equality follows from the Substitution Lemma (since y is not
free in Q). ut
229
14.0.9. Lemma. For all P;Q;Q
0
2 , if
Q !

Q
0
then also
Pfx := Qg !

Pfx := Q
0
g:
Proof. By induction on the structure of P .
Case P = x, then Pfx := Qg = Q!

Q
0
= Pfx := Q
0
g:
Case P = y, then Pfx := Qg = y !

y = Pfx := Q
0
g:
Case P = y:P
0
, then
(y:P
0
)fx := Qg = y:P
0
fx := Qg
!

y:P
0
fx := Q
0
g
= (y:P
0
)fx := Q
0
g
where !

follows from the induction hypothesis and compatibility of !

.
Case P = P
1
P
2
, then
(P
1
P
2
)fx := Qg = (P
1
fx := Qg) (P
2
fx := Qg)
!

(P
1
fx := Q
0
g) (P
2
fx := Qg)
!

(P
1
fx := Q
0
g) (P
2
fx := Q
0
g)
= (P
1
P
2
)fx := Q
0
g
where both!

-steps follow from the induction hypothesis and compatibility
of !

. ut
Now the proposition in the exercise (1.72) can be proved.
14.0.10. Proposition (Weak Church-Rosser). For all M
1
;M
2
;M
3
2 , if
M
1
!

M
2
and M
1
!

M
3
, then there exists an M
4
2  such that
M
2
!

M
4
and M
3
!

M
4
.
Proof. By induction on the derivation of M
1
!

M
2
.
Case M
1
= (x:P ) Q and M
2
= Pfx := Qg. Then either (1) M
3
=
(x:P
0
) Q for P
0
such that P !

P
0
, (2) M
3
= (x:P ) Q
0
for Q
0
such that
Q !

Q
0
, or M
3
= M
2
. In the last case we are done. In situation (1)
we have M
3
= (x:P
0
) Q !

P
0
fx := Qg and M
2
= Pfx := Qg !

P
0
fx := Qg by Lemma 14.0.8, i.e., M
4
= P
0
fx := Qg. Situation (2) is
similar using Lemma 14.0.9.
(1) (2)
(x:P )Q
||y y
y y
y y
y y
""E
EE
EE
EE
E
Pfx := Qg

(x:P
0
)Q

P
0
fx := Qg
=
P
0
fx := Qg
(x:P )Q
||y y
y y
y y
y y
""E
EE
EE
EE
E
Pfx := Qg

(x:P )Q
0

Pfx := Q
0
g
=
Pfx := Q
0
g
230 Chapter 14. Solutions and hints to selected exercises
Case M
1
= x:P and M
2
= x:P
0
because P !

P
0
. Then M
3
must
be x:Q for Q 2  such that P !

Q. By the induction hypothesis there
is a term M
0
such that P
0
!

M
0
and Q !

M
0
. Then since !

is
compatible we have M
2
= x:P
0
!

x:M
0
and M
3
= x:Q !

x:M
0
,
and M
4
= x:M
0
is the sought term.
x:P
 
 
 

9
99
99
99
x:P
0
 9
99
99
99
x:Q
 
 
 

x:M
0
Case M
1
= P Q and M
2
= P
0
Q because P !

P
0
. Then
(1) M
3
= P
00
Q for P
00
2  such that P !

P
00
, or
(2) M
3
= P Q
0
for Q
0
2  such that Q !

Q
0
.
In the former case by the induction hypothesis we obtain an M
0
such that
P
0
!

M
0
and P
00
!

M
0
and thus (again by compatibility of !

) that
M
2
= P
0
Q !

M
0
Q and M
3
= P
00
Q !

M
0
Q, i.e., M
4
=M
0
Q. In the
latter case we have that M
2
= P
0
Q !

P
0
Q
0
and M
3
= P Q
0
!

P
0
Q
0
(also by compatibility) and consequently M
4
= P Q
0
as desired.
(1) (2)
P Q
 
 
 

<
<<
<<
<<
P
0
Q
 ;
;;
;;
;;
P
00
Q
 
 
 

M
0
Q
P Q
 
 
 

:
::
::
::
P
0
Q

P Q
0

P
0
Q
0
=
P
0
Q
0
This completes the proof. ut
The proof does not extend directly to the full Church-Rosser property.
Let us say that a relation ! on a set S is weakly conuent if, whenever
s
1
! s
2
and s
1
! s
3
, there is an s
4
such that s
2
! : : :! s
4
and s
3
! : : :!
s
4
. Let us call ! conuent if, whenever s
1
! : : : ! s
2
and s
1
! : : : ! s
3
,
there is an s
4
such that s
2
! : : :! s
4
and s
3
! : : :! s
4
.
There are relations that are weakly conuent and not conuent. The
simplest example is when we have a four-element set S = fs
1
; s
2
; s
3
; s
4
g
s
1
 s
2
, and s
2
! s
3
, s
2
 s
3
, and s
3
! s
4
:
s
1
s
2
oo //
s
3
oo //
s
4
A relation ! on a set S is strongly normalizing if there are no innite
reduction sequences
s
1
! s
2
! : : :
231
of (not necessarily distinct) elements from S. Can you nd a weakly conu-
ent, strongly normalizing relation that is not conuent?
A diggression
How many details should a proof contain? Everybody should do a proof in
the style of Lemma 14.0.6 (induction on M 2 ) and a proof in the style of
Lemma 14.0.7 (induction on the denition of P !

P
0
) in every detail at
least once in their life.
However, having tried this, one can see that many details are completely
mechanical. In choosing a level of detail in a proof, one should leave out de-
tails that can be reconstructed mechanically with little eort by the reader.
In contrast, steps that require good ideas, even small good ideas, should
usually not be left out.
Thus, a complete proof of Lemma 14.0.6 would be \Induction onM" and
a complete proof of Lemma 14.0.7 would read \Induction on the denition
of P !

P
0
." A complete proof of Lemma 14.0.8 might be \Induction on
the denition of P !

P
0
," but since something interesting happens in the
case where P = (y:P
1
) Q
1
!

P
1
fy := Q
1
g = P
0
, one can also present
that case and refer to the substitution lemma.
If several cases in a proof are similar, but non-trivial, one can do the
rst example in detail and omit the remaining ones.
Exercise 1.7.17
14.0.11. Proposition (Klop). Let x
1
x
2
: : : x
n
:M be an abbreviation for the
-term x
1
:x
2
: : : : x
n
:M . Let
? = abcdefghijklmnopqstuvwxyzr:r (thisisafixedpointcombinator)
$ = ??????????????????????????
Then $ is a xed point combinator, i.e., for any F 2 : $ F =

F ($ F ).
Proof. We have:
$ F = ?????????????????????????? F
= (abcdefghijklmnopqstuvwxyzr:
r (thisisafixedpointcombinator))
????????????????????????? F
=

F (??????????????????????????F )
= F ($ F )
as required. ut
232 Chapter 14. Solutions and hints to selected exercises
Exercise 2.7.2
We only show the closure under weakening. The proof is by induction with
respect to the size of the proof of ? ` '. We proceed by cases depending
on the last rule used in this proof. Recall that the notation ?;  stands for
? [ f g, whether or not  2 ?. That's why e.g., Case 3 below works.
Case 1: The proof consists only of a single application of an axiom scheme,
that is ' is an element of ?. Then ?;  ` ' is also an axiom.
Case 2: The proof ends with an application of (^I). That is, ' has the
form '
1
^ '
2
and we have proven ? ` '
1
and ? ` '
2
. The proofs of
these judgements are contained in the proof of ? ` ', so we can apply the
induction hypothesis to obtain ?;  ` '
1
and ?;  ` '
2
. By an application
of (^I) we can derive ?;  ` '
1
^ '
2
.
Case 3: The proof ends with an application of (_E). That is, we have
? ` 
1
_ 
2
, for some formulas 
1
, 
2
, such that ?; 
1
` ' and ?; 
2
` '.
These proofs are all shorter, thus we can apply the induction hypothesis to
obtain ?;  ` 
1
_ 
2
and ?; 
1
;  ` ' and ?; 
2
;  ` '. It remains to use
rule (_E).
Other cases are similar.
Exercise 2.7.3
1) Begin with the axiom ? ` ?. Apply (?E), to derive ? ` ' and (!I)
to derive ` ? ! '.
3) Begin with p; p ! ? ` p and p; p ! ? ` p ! ?. Apply (!E) to get
p; p! ? ` ?, then twice (!I) to get ` p! (p! ?)! ?.
5) First show that :::p;:p; p ` ? (unfold the :'s). Thus, :::p; p `
:p ! ?, i.e., :::p; p ` ::p. But :::p = ::p ! ? and one can
derive :::p; p ` ?. It remains to use (!I).
7) First show that p! q; q ! ?; p ` ?. Then apply (!I) three times.
9) What we need is :p_:q; p^q ` ?. With help of (^E), derive separately
:p_:q;:p; p^ q ` ? and :p_:q;:q; p^ q ` ?. Apply (_E) to these
two judgements.
11) Remember that $ abbreviates a conjunction, so (^I) will be the last
rule. One part of this proof uses (^E), the other one uses (^I).
13) First derive (p_:p)! ?; p ` ?, using rules (_E) and (!E). By (!I)
obtain (p _ :p) ! ? ` :p. Then use (_E) and (!E) again to derive
(p _ :p)! ? ` ?.
233
Exercise 2.7.4
 First we show that a [ a = a, that is a  a holds for all a. This is
because a = 0[a = (?a\a)[a = (?a[a)\(a[a) = 1\(a[a) = a[a.
 The relation  is transitive because a [ b = b and b [ c = c implies
that c = b [ c = (a [ b) [ c = a [ (b [ c) = a [ c.
 The antisymmetry (a  b and b  a implies a = b) follows immediately
from the denition. To see that a [ b is the lub of a and b, assume
that a  c and b  c. Then (a [ b) [ c = a [ (b [ c) = a [ c = c, i.e.,
a [ b  c.
 The condition a \ b  a (that is (a \ b) [ a = a) is shown as follows:
(a\ b)[ a = (a\ b)[ (a\ 1) = (a\ b)[ (a\ (b[?b)) = (a\ b)[ (a\
b) [ (a \ ?b) = (a \ b) [ (a \ ?b) = a \ (b [ ?b) = a \ 1 = a.
 If a\ b = a then b = (a\ b)[ b = a[ b, i.e., a  b. On the other hand,
if a  b then (a\ b)[ a = (a[ a)\ (b[ a) = a\ b, and thus a  a\ b.
We conclude a = a \ b, by the previous item and antisymmetry.
Exercise 2.7.5
 The proof that the relation  is a partial order, and that [ is the lub,
is similar as for Exercise 2.7.4.
 Next we show that ?a\a = 0. We have ?a  ?a, i.e., a) 0  a) 0.
Thus, a \ (a ) 0)  0, and since 0 is obviously the least element, we
have a \ ?a = a \ (a) 0) = 0.
 Now we prove (a [ b) \ a = a, in a similar way as we proved the dual
law (a \ b) [ a = a for a Boolean algebra. (Note that now we use
b \ ?b = 0 instead of b [ ?b = 1.)
 We derive (a \ b) [ a = a from the above, because (a \ b) [ a =
(a[a)\(b[a) = a\(b[a). Note that we obtain here the idempotency
of \, since a \ a = a \ (a [ a) = a \ a.
 Then we proceed in a similar way as for Boolean algebra.
Exercise 2.7.6
The only property which is not immediate is the equivalence between A \
C  B and C  Int(?A [ B). First note that the condition A \ C  B
is equivalent to C  ?A [ B, for all A, B and C. For the left-to-right
implication observe that X  Y implies X  Int(Y ), whenever X is an
open set. The converse follows from Int(?A [B)  ?A [B.
234 Chapter 14. Solutions and hints to selected exercises
Exercise 2.7.8 (1))(2)
Let ? = f#
1
; : : : ; #
n
g, and let v be a valuation in a Heyting algebra H.
We write v(?) to denote v(#
1
) \    \ v(#
n
). By induction with respect to
derivations we prove the following statement: \If ? ` ' then v(?)  v('),
for all valuations in arbitrary Heyting algebras". The hypothesis follows
from the special case when v(?) = 1.
For instance, consider the case of (!I). To show v(?)  v(' !  )
recall that v(' !  ) = v(') ) v( ) and use the induction hypothesis
v(?) \ v(')  v( ). For the case of (_E) use the distributivity law.
Exercise 2.7.9
First we consider counterexamples with open sets. In what follows we use
the convention that v(p) = P , v(q) = Q, etc, and we write  A for Int(?A).
4) Take P to be the whole R
2
without one point. Then  P is empty
and  P is the full set R
2
. Thus  P ) P 6= 1.
6) Let P be an open disk, and Q be R
2
without one straight line crossing
the middle of the disk. Then P ) Q is the whole space without the
intersection of the disk and the line. The value of the right-hand side
is the whole space.
8) Take the interiors of two complementary halves of R
2
.
10) Take Q and R to be the half of R
2
where x < 0, and take P =
R
2
? f(0; 0)g. Then (P ) Q) \ (Q ) P ) is equal to Q and R. Thus
the value of (p$ q)$ r is R
2
6 P .
12) Take both P and Q to be the same open disk.
Here are counterexamples in Kripke models.
4) A two-element model with c < c
0
, where c 1 p and c
0
 p.
6) A two-element model with c < c
0
, where c; c
0
 p and c
0
 q and c 1 q.
8) A three-element model with c < c
0
; c
00
, where c
0
 p, c
00
 q and noth-
ing more happens.
10) A three-element model with c < c
0
< c
00
, where c
0
 p, c
00
 p; q; r and
nothing more happens.
12) A two-element model with c < c
0
, where c
0
 p; q and c forces nothing.
235
Exercise 2.7.10
Use n lines beginning in (0; 0) to divide the space R
2
into n disjoint angles
and take their interiors as values of p
i
. The point (0; 0) does not belong
to the interpretation of this formula. Or take a Kripke model with all sets
fc  c
0
: c  p
i
g dierent. Then c
0
does not force our formula.
Exercise 2.7.11
Let F be maximal and let a [ b 2 F , but a; b 62 F . We show that either
F [ fag or F [ fbg can be extended to a proper lter. First assume that
there are f
1
; f
2
2 F such that f
1
\ a = f
2
\ b = 0. Then (f
1
\ f
2
)\ (a[ b) =
(f
1
\ f
2
\ a) [ (f
1
\ f
2
\ b) = 0 [ 0 = 0, a contradiction. Thus either such
f
1
or such f
2
does not exist. Assume for instance that f \ a 6= 0, for all
f 2 F . Then the set F
a
= fx : x  f \ a for some f 2 Fg is a proper lter
extending F .
Let F be a prime lter in a Boolean algebra, and assume that F  F
0
,
with a 2 F
0
? F . Since a [ ?a = 1 2 F and F is prime, we have ?a 2 F
and 0 = a \ ?a 2 F
0
, a contradiction.
Exercise 2.7.12
The argument is similar to the rst part of Exercise 2.7.11. Assume that G
is our maximal element, and that c [ d 2 G, but c; d 62 G. The assumption
of g
1
; g
2
2 G with g
1
\ a  b and g
2
\ a  c leads to contradiction, and thus
either G[fbg or G[fcg can be extended to a proper lter, not containing a.
Exercise 2.7.13 ())
We need to prove a slightly more general statement, namely:
Let ? ` '. Then for every Kripke model C and every state c
of C, the condition c  ? implies c  '.
(An alternative of this generalization is to remember that for each state c,
the set of all c
0
with c  c
0
makes a Kripke model.) As an example consider
the induction step for rule (_E). Assume that we have derived ? ` ' from
the three assertions: ?;  ` ' and ?; # ` ' and ? `  _ #. Let c  ?. By
the induction hypothesis we have c   _#, and thus either c   or c  #.
Assume the rst case and we have c  ?;  . By induction hypothesis we get
c  '.
Exercise 2.7.14
The induction fails in the case of disjunction.
236 Chapter 14. Solutions and hints to selected exercises
Exercise 2.7.17
First do the previous two exercises. Now assume that ' is a classical tautol-
ogy (the other direction is obvious), but ::' is not valid intuitionistically.
This means that there is a Kripke model with a state c, such that c  :'.
Without loss of generality, we can assume that c determines all propositional
variables in '. Indeed, suppose that c does not determine a variable p. Then
there is a c
0
 c with c
0
 p, and we can take c
0
instead. From Exercise 2.7.16
we obtain that c  ', a contradiction.
Exercise 4.6.4
14.0.12. Lemma (Newman's Lemma). Let ! be a binary relation satisfying
SN. If ! satises WCR, then ! satises CR.
Proof. We give the proof in the case where ! satises FB, i.e., for all
M 2 L the set fN jM ! Ng is nite. [This was the case the hint aimed
at. See another proof at the end of the note.] Since ! satises FB and SN,
there is for any M an m so that any reduction sequence from M has length
at most m.
1
Assume! is SN and WCR. Given M
1
;M
2
;M
3
2 L where M
1
!M
2
and
M
1
!M
3
, we must nd M
4
2 L such that
M
1
}}}}{ {
{ {
{ {
{ {
!! !!C
CC
CC
CC
C
M
2
!! !!
M
3
}}}}
M
4
Since! is strongly normalizing, for every M 2 L there will be a longest
reduction starting in M . Let jM j 2 N denote the length of this reduction.
Assume M
1
;M
2
;M
3
2 L such that M
1
!M
2
and M
1
!M
3
. We proceed
by induction over jM
1
j:
Case jM
1
j = 0: Since the longest reduction has length 0, it must be the
case that M
1
=M
2
and M
1
=M
3
, and thus M
4
=M
1
is the desired term.
Case jM
1
j > 0: Assume for all N
1
2 L such that jN
1
j < jM
1
j, if N
1
!N
2
and N
2
!N
3
then there exists N
4
such that N
2
!N
4
and N
3
!N
4
.
1
How does this follow? Recall Konig's Lemma which states that if a tree|which is
nitely branching, i.e., each node has nitely many children|is innite, then it must have
an innite branch. Now, givenM , consider the tree where the root is labeled withM , and
for any node labeled with K, if K ! N then the node labeled K has a child labeled N .
Since ! satises SN, there is no innite branch. Also, there cannot be arbitrarily long
nite sequences, because then the tree would be innite, and then by Konig's Lemma
there would be an innite branch, contradicting SN.
237
If M
1
!M
2
has length 0 the desired term is M
3
:
M
1
{ {
{ {
{ {
{ {
{ {
{ {
{ {
{ {
!! !!C
CC
CC
CC
C
M
2
!! !!
M
3
{ {
{ {
{ {
{ {
{ {
{ {
{ {
{ {
M
3
Similarly if M
1
!M
3
has length 0.
Thus assume that M
1
! N
2
!M
2
and M
1
! N
3
!M
3
,
M
1
}}{ {
{ {
{ {
{ {
!!C
CC
CC
CC
C
N
2

N
3

M
2
M
3
Since ! is WCR from M
1
! N
2
and M
1
! N
3
we get a term N 2 L such
that N
2
!N and N
3
!N
M
1
}}{ {
{ {
{ {
{ {
!!C
CC
CC
CC
C
N
2
!! !!
N
3
}}}} 
M
2
N
M
3
Since M
1
! N
2
!N , jN
2
j < jM
1
j. Applying the induction hypothesis we
thus get a term M
0
4
2 L such that M
2
!M
0
4
and N !M
0
4
M
1
}}{ {
{ {
{ {
{ {
!!C
CC
CC
CC
C
N
2
!! !!C
CC
CC
CC
C

N
3
}}}}{ {
{ {
{ {
{ {

M
2
!! !!
N

M
3
M
0
4
238 Chapter 14. Solutions and hints to selected exercises
Then N
3
!M
0
4
and N
3
!M
3
and hence by the induction hypothesis we get
a term M
4
2 L such that M
0
4
!M
4
and M
3
!M
4
M
1
}}{ {
{ {
{ {
{ {
!!C
CC
CC
CC
C
N
2
!! !!C
CC
CC
CC
C

N
3
}}}}{ {
{ {
{ {
{ {

M
2
!! !!C
CC
CC
CC
C N

M
3

M
0
4

M
4
i.e., M
2
!M
4
and M
3
!M
4
. This concludes the proof. ut
14.0.13. Proposition. There is a binary relation satisfying WN and WCR,
but not CR.
Proof. Consider L = fM;M
NF
; N;N
NF
g and the relation ! given by
M

%%
Nee

M
NF
N
NF
The relation is not Church-Rosser: for M 2 L we have two reductions
M !M
NF
and M ! N ! N
NF
, but there is no term in L such that M
NF
and N
NF
both reduce to this term (because both are in \normal form").
The relation is Weak Church-Rosser: if M ! M
NF
and M ! N , then
M
NF
is a common reduct. Similarly for N .
Finally, we have that ! is weakly normalizing since any reduction can
always end in eitherM
NF
or N
NF
. (It is obviously not strongly normalizing
because we have an innite reduction M ! N !M !    .) ut
14.0.14. Corollary. Let M
1
2  be typable in ! a la Curry and assume
that M
1
!

M
2
and M
1
!

M
3
. Then there is an M
4
2  such that
M
2
!

M
4
and M
3
!

M
4
.
Proof. Let L = fM 2 j9: ` M : g and consider !=!

. By The-
orem 4.10 ! satises SN and by Exercise 1.72 ! satises WCR, thus by
Newman's Lemma ! satises CR, i.e., !

is Church-Rosser on L|the set
of Curry-typable terms. ut
239
How does one prove Newman's Lemma in case ! does not necessarily
satisfy FB? As follows.
Proof. Let ! be a relation on L satisfying SN and WCR. As usual, a
normal form is an M 2 L such that for all N 2 L, M 6! N .
Since ! satises SN, any M 2 L reduces to a normal form. Call M
ambiguous if M reduces to two distinct normal forms. It is easy to see that
! satises CR if there are no ambiguous terms.
Now, for any ambiguous M there is another ambiguous M
0
such that
M !M
0
. Indeed, suppose M !N
1
and M !N
2
. Both of these reductions
must make at least one step since N
1
and N
2
are distinct, so the reductions
have form M !M
1
!N
1
and M ! M
2
!N
2
. If M
1
= M
2
we can choose
M
0
= M
1
= M
2
. If M
1
6= M
2
we now by WCR that for some N
3
, M
1
!N
3
and M
2
! N
3
. We can assume that N
3
is a normal form. Since N
1
and N
2
are distinct, N
3
is dierent from N
1
or N
2
so we can choose M
0
= M
1
or
M
0
=M
2
.
Thus, M has an innite reduction sequence, contradicting SN. Hence,
there are no ambiguous terms. ut
Exercise 5.6.1
One possibility is S(S(KS)K)I.
Exercise 5.6.9
It should be easy to see that all types that can be assigned to K, I and S

must be respectively of the form:
  !  !  ;
  !  ;
 ( ! )! ( !  ! )! ( ! )!  !  .
We can take all instances of the above formulas as our Hilbert style axioms.
But we can easily simplify the the system, replacing the last axiom by:
 ( !  ! )! ( ! )!  !  .
A Hilbert style proof will now correspond to a combinatory term built from
the combinators of Exercise 5.6.8, and without loss of generality, we can
only deal with terms in normal forms.
Suppose we have a proof of (p ! p ! q) ! p ! q, where p and q are
propositional (type) variables. Let M be the corresponding combinatory
term in the language of Exercise 5.6.8, and assume that M is in a normal
form.
240 Chapter 14. Solutions and hints to selected exercises
Clearly, M is neither K
;
, nor S
;;
, nor I

. If M = K
;
N , then
N proves p ! q, which is not a valid tautology. Also M = S
;;
PQ or
M = S
;;
N is impossible, because types of these expressions do not match
(p! p! q)! p! q.
Exercise 6.8.1
a) To reduce ? ` M : ? to ` M : ?, observe that a term M with free
variables x
1
; : : : ; x
n
is typable if and only if x
1
: : : x
n
:M is typable.
b) In order to nd out if a closed termM is typable, ask if x :  ` KxM : .
Exercise 6.8.2
Of course t

= x

, and then we proceed by induction as follows: t
!
=
x:Kt

(zy:z(yx)(yt

)).
Exercise 6.8.3 (Author's hint)
Adopt the technique of Exercise 6.8.2 to write lambda-terms t
[x: ]
such that
x 2 FV (t
[x: ]
) and t
[x: ]
is typable in a context  if and only if (x) = S(),
for some S. (Use a fresh variable x

, for every type variable  occurring in  .)
Then reduce the problem of ? `M : ? with ? = f(x
1
: 
1
); : : : ; (x
n
: 
n
)g to
the problem ? `M
0
: ?, where M
0
= z:zMt
[x
1
:
1
]
: : : t
[x
n
:
n
]
.
Exercise 6.8.3 (Solution by Henning Makholm)
(This is a fragment of Henning's solution containing the reduction of prob-
lem (3) to problem (4).)
Definition. Let ?
0
denote a type environment of the form discussed in
exercise 6.29. That is, one that maps all variables to distinct type variables.
Definitions. I consider the following problems:
(3) ? `M :  ;
(4) ? `M : ?;
(5
1
2
) ?
0
`M : ?:
In each of the following reductions, x
1
up to x
n
will be understood to be the
free variables of the given M .
Reduction from (3) to (5
1
2
). To answer ? `M :  , ask
?
0
` x
1
   x
n
yz:y(zM)(zt

) : ?:
241
Reduction from (5
1
2
)to (4). This is the harder part. Without the ?
0
it is not trivial to design a subterm that is forced to have a primitive type
(one that cannot be destructed).
Solution with product types. One simple solution can be obtained if
we assume that we have product types at our disposal, together with pair
and projection operators. To answer ?
0
`M : ?, ask:
? `K ((x
1
   x
n
:M) hx
1
; x
1
i hx
2
; x
2
i : : : hx
n
; x
n
i)
((x
1
   x
n
:M)(y
1
:y
1
)(y
1
y
2
:y
1
) : : : (y
1
   y
n
:y
1
)) : ?
Clearly, if M has a typing in ?
0
then this complicated term is also typable.
For the other direction, I exploit the existence of unique principal types. If
the long term is typable, then x
1
   x
n
:M will have a principal type

1
!    ! 
n
! :
Since that principal type have instances where the 
i
's are arrow types as
well as where they are pair types, we conclude that the 
i
's must be type
variables. Furthermore, because y
1
   y
i
:y
1
and y
1
   y
j
:y
1
cannot have
equal type for i 6= j, the 
i
's must be dierent type variables. Thus, modulo
renaming of type variables we have ?
0
`M : .
Implicational solution. My solution is based on an \encoding"  of
types and terms
2
:
 = ;
 !  = ( ! )! ( ! );
x = x;
x:M = ex:e(e(M ));
MN = (e:e(MeN))(x:x):
Lemma.
 If ? `M :  then ? `M :  .
 If  `M :  then ? `M :  , for some ? and  with ? =  and  = .
The proof of the rst part is easy. The other part follows by induction with
respect to M . ut
2
Never mind that  is not LOGSPACE-computable because  can be exponentially
bigger than  . It is not used in the actual reduction, just in the argument for its correct-
ness. The important thing is that M is LOGSPACE-computable by having a treeless,
linear denition.
242 Chapter 14. Solutions and hints to selected exercises
Now, to answer ?
0
`M : ?, ask
? ` (x
1
   x
n
:M)(zy
1
:z)(xy
1
y
2
:z) : : : (zy
1
   y
n
:z) : ?:
It is easy to see that this holds whenever M is typable in ?
0
. Conversely,
assume that the massaged and wrapped M is typable. We know then that
M is typable and thus so is M . Let (?; ) be the principal pair of M .
What remains to be shown is that ? is ?
0
. We know that ?(x
i
) = ?(x
i
)
has an instance which is a type of zy
1
   y
i
:z. But by inspection of the
denition of  we see that this can only be the case when ?(x
i
) is a type
variable. (This is because all compound types are translated into types with
\symmetric" rst arguments.) Furthermore the type variables in ? have to
be dierent, because zy
1
   y
i
:z and zy
1
   y
j
:z do not have a common
type for i 6= j. Thus ? is a ?
0
which completes the reduction. ut
Exercise 6.8.6
Take the equations \
1
= 
2
! 
2
", \
2
= 
3
! 
3
",: : : , \
n?1
= 
n
! 
n
".
Exercise 6.8.7
Use non-uniable terms as dierent ags. Represent n-ary operators as
combinations of arrows, using ags to identify operators.
Exercise 6.8.8
Label all subterms occurring in the equations and keep labels unchanged in 
in steps (a) and (d). A variable x is called dened i there is an equation
of the form \x = t" or \t = x". The occurrence of x as a left-hand or a
right-hand side of such an equation is called main. Note that \x = y" has
two main occurrences.
Proceed by induction w.r.t. the following parameters: 1) number of la-
bels; 2) number of equations; 3) number of main occurrrences of dened
variables; 4) number of all occurrrences of dened variables. Each applica-
tion of rule (c) decreases (1) and does not increase the other parameters.
Rule (e) decreases (2) without aecting (1), and rule (a) decreases (3) with-
out increasing (1) or (2). Rule (d), used with caution (i.e., only when x
occurs in \r = s" and when t is not a dened variable), will not increase any
of the parameters (1){(3) and will decrease (4). Thus, after a nite number
of applications of rules (a), (c), (d) and (e) we obtain a system of equations,
that is not normal only for the following reasons: there may be some equa-
tions of the form \t = x" and there may be some equations between dened
variables. Use rules (b) and (d) for a clean-up.
243
Exercise 6.8.10
Use acyclic graphs instead of trees to represent algebraic terms. Proceed by
identifying nodes of these graphs as long as either a contradiction is found
(a loop or an attempt to place two dierent operation labels at a node) or
no more nodes need to be identied.
Exercise 6.8.11
Just add one more equation.
Exercise 6.8.12
Take the term (v:Kv(x

1
: : : x

n
:t
[v: ]
))N , where N is any inhabitant of  ,
and t
[v: ]
is as in Exercise 6.8.3.
Exercise 6.8.14
Let a pair (?; ) be called semi-principal i it has the properties mentioned in
Exercise 6.8.13. We show that if (?; ) is semi-principal then there is at most
one Church-style BCK-term M in long normal form such that ? ` M :  .
The proof is by induction w.r.t. the total number of arrows in (?; ). Assume
rst that  = 
1
! 
2
. Then M cannot be of the form xM
1
: : :M
n
, as it
would not be fully-applied (x has too few arguments). Thus, M = y:N ,
with fully applied N , and we apply the induction hypothesis to the pair
(? [ fy : 
1
g; 
2
).
The remaining case is when  is a type variable . There is at most one
variable x declared in ? to be of type 
1
!    ! 
p
! , since  occurs at
most twice. Thus M = xN
1
:::N
p
. Apply the induction hypothesis to pairs
(?
0
; 
j
), where ?
0
is ? without the declaration (x : 
1
!    ! 
p
! ).
Exercise 6.8.18
Modify the algorithm of Lemma 6.6.1 so that it searches for all inhabitants
rather than for only one. This process may loop by asking a question of the
form ? ` ? : , which has already been asked. We can eectively identify all
loop-free solutions and all loops. If we have a loop caused by a question that
has a loop-free solution, then the answer is: \innite". (Note the similarity
of this argument to the pumping lemma for CF-languages.)
Exercise 6.8.20
Assume all 
i
's are inhabited. We prove indirectly that then ' is not inhab-
ited. Assume ` N
i
: 
i
and ` M : '. Then ` M N
1
  N
n
: , which is a
contradiction because type variables are not inhabited.
244 Chapter 14. Solutions and hints to selected exercises
The proof that ' is inhabited if there is a 
i
that is not inhabited is by
induction on the size of '. Since  is the only type variable in ', type 
i
has
the form 
1
!    ! 
m
! . If any of the 
j
's were not inhabited then
by the induction hypothesis 
i
would be inhabited, but we know it is not.
Thus for some N
j
's we have ` N
j
: 
j
. Then ` x
1
   x
n
:x
i
N
1
: : : N
m
: '.
Exercise 6.8.21
The formula ' must have the form  
1
!    !  
n
! p. Classically, this
is equivalent to ( 
1
^    ^  
n
) ! p. For this to be a tautology, some  
i
must be false in a valuation that sets p to be false. Hence that  
i
is not
classically valid, so it cannot be intuitionistically valid either. That means
that  
i
is not inhabited when viewed as a type. Then ' is inhabited by
Exercise 6.8.20, and ' is thus intuitionistically valid.
Exercise 6.8.22
First reduce the general case to the case when  is a type variable . To prove
that 
1
; : : : ; 
n
` , consider a substitution S such that S() = 
1
!    !

n
! , and S() = , for  6= . Show that all formulas S(
1
); : : : ; S(
n
)
are valid, and conclude what you need.
Exercise 7.7.6
Consider the term M =< 
1
(FK); 
2
(FK) >, where F = x: < x; y:x >.
Then F can be assigned all instances of the type  ! ( ^ ( ! )), and
since K has both the types  !  !  and  ! ( ! ) ! , we can
derive that M : ( !  ! ) ^ ( !  ! ( ! ) ! ). But M !

FK,
and FK cannot be assigned this type.
Exercise 7.7.8
The example term in the above solution is an untyped -redex that is not
an erasure of a typed -redex. The Church-style version of that term uses
two dierent K's.
Exercise 7.7.9
The problem is that the conclusion of the elimination rule is not neces-
sarily identical to a premise of any of the introduction rules. Thus, in an
elimination-introduction pair, one eliminates and introduces possibly dier-
ent things.
245
Exercise 7.7.10
There is no canonical object of type ?, so one can argue that no eta rule
makes sense. By analogy to the eta rule for _ one may only postulate
that an \articial" use of ?-introduction should be avoided. This leads to
something like "
?
(M)!M , for M : ?.
Exercise 8.9.1 (Hint)
For the right-to-left direction, proceed as follows:
1. Show that ` ('!  )! (:'!  )!  .
2. Let 
1
; : : : ; 
n
be the propositional variables of '. Let  be a Boolean
valuation. Now let

0
i
=


i
if () = 1
:
i
if () = 0
Also, let
'
0
=

' if (') = 1
:' if (') = 0
where  is lifted to formulas according to the usual truth-table seman-
tics. Show that f
0
1
; : : : ; 
0
n
g ` '
0
.
3. Prove the right-to-left direction.
Exercise 9.5.2
The construction of '
0
is by induction w.r.t. the length of the quantier
prex of '. If ' is quantier-free then '
0
= '. If ' = 8x (x) then '
0
=
 
0
(x). If ' = 9x (x) then '
0
=  
0
(c), where c is a constant such that
`  (c). (Here we apply the induction hypothesis to  (c).)
Exercise 9.5.3
For a given formula there is a nite number of possible replacements of
existentially quantied variables by constants. To verify provability of a
prenex formula one checks provability of these replacements (provability of
open formulas is decidable, like for the propositional case).
Exercise 9.5.4 (Intuitionistic case)
The argument is of course as follows: if every intuitionistic rst-order for-
mula was equivalent to a prenex formula, then intuitionistic rst-order logic
would be decidable by the previous exercise. Note however that to apply
this argument one needs to know that the translation to prenex normal form
246 Chapter 14. Solutions and hints to selected exercises
must be eective, and we can assume only the existence of a prenex formula
equivalent to any given '. But one can eectively list all proofs until a
proof of '$  , for a prenex formula  is found, and this gives an eective
translation.
Exercise 9.5.5
Consider the formula 9x(P (0)_P (1) ! P (x)), where P is a unary predicate
symbol and 0 and 1 are constants. It should be clear that no formula of the
form P (0) _ P (1) ! P (t) is classically valid. The proof of Corollary 9.3.2
breaks down in the \obvious" and omitted part, and the confusion is cre-
ated by the principle of contraction (two occurrences of the same formula
in a sequent are treated as a single occurrence). In a sequent calculus with
explicit contraction rules, the last rule of our proof would be the right con-
traction rule. In our version of sequent-calculus, the contraction is implicit,
and the last rule must indeed be (9R). But the premise of this rule may be
for instance of the form:
` 9x(P (0) _ P (1)! P (x)); P (0) _ P (1)! P (1);
because a classical sequent may have two formulas at the right-hand side.
The second last rule is also (9R) with premise
` P (0) _ P (1)! P (0); P (0) _ P (1)! P (1);
a classical proof of which should be easy.
Exercise 9.5.7 (Hint)
The proof is similar to that of Proposition 2.3.4. Choose c 2 X. We trans-
form a model A where relations are valued over P (X) into an ordinary
model

A, by dening
(a
1
; : : : ; a
n
) 2 r

A
i c 2 r
A
(a
1
; : : : ; a
n
):
Both our models have a common domain A. Let v be a valuation in A. We
extend v to terms and formulas in the usual way (the values of formulas
range over P (X)). One proves by induction the following claim:
c 2 v(') i

A; v j= ';
for all '. (Note that the right-hand side makes sense, because v can also be
regarded as ordinary two-valued valuation in

A.) Note that in the right-to-
left direction in the case of 8, one uses the fact that lower bounds in P (X)
are actually intersections (if c belongs to all sets in a family then it belongs
to their glb).
3
Now if A; v 6j= ' then there is c 62 v('), and thus

A; v 6j= ' as well.
3
One has to use ultralters for the case of arbitrary Boolean algebras.
247
Exercise 9.5.8
Algebraic counterexamples, after [88]
The domain of individuals A is the set of all positive integers. The Heyting
algebra H is the set of all open sets of R
2
. We take ' and  as atomic
formulas p(x) and q(y), and we abbreviate p(x)
A
(n) by P (n) and q(y)
A
(m)
by Q (the latter will not depend on m). The symbol w
i
denotes the i-th
point with rational coecients, according to some xed order.
2) Take P (n) = R
2
? fw
n
g, a full space without one rational point. The
intersection of all sets P (n) is R
2
with all rational points deleted. This
set has an empty interior, and thus the value of the formula :8x p(x) is
the full space. On the other hand, the complement in H of every P (n)
is empty and the value of the formula at the right-hand side is the
union of empty sets.
4) Let Q be the whole space without the point (0; 0), and let P (n) be the
set of all points with distance from (0; 0) greater than
1
n
(full space
without a disk). The union of all P (n)'s is equal to Q, and the value
of the left-hand side is Q) Q = R
2
. But Q) P (n) = P (n), for all n,
and the union of these sets (the value of the right-hand side) does not
contain (0; 0).
6) Take Q as above and let P (n) be the open disk centered at (0; 0), with
radius equal to
1
n
. The value of the left-hand side is R
2
because each
set Q[P (n) covers the whole space. The value of the right-hand side
is Q because the glb in H of all sets P (n) is empty. (Their intersection
is a one-point set which is not open.)
8) Let Q be empty, and let P (n) be as in (2). The value of the left-hand
side is the full space, because the glb of all sets P (n) is empty. But
the value of the right-hand side is empty.
10) Let P (n) be as in (2) and (8). Then P (n) is empty and thus P (n)[
P (n) = P (n). The intersection of these sets has an empty interior,
thus the value of our formula is empty.
12) Take P (n) = A for even n and P (n) = B for odd n where A and B
are complementary open halves of the space. (Note that this formula
has a propositional counterpart: (p _ q ! p) _ (p _ q ! q), which is
also not valid.)
Counterexamples in Kripke models
2) Hint: adopt the solution of Exercise 2.7.9(8).
248 Chapter 14. Solutions and hints to selected exercises
4) Hint: rst make a counterexample for the propositional version of this
law: (p! q _ r)! (p! q) _ (p! r).
6) The model consists of two states c  d, with A
c
= f1g and A
d
=
f1; 2g. Let c; 1  '(x) and c 1  , and let d   and d; 1  '(x), but
d; 2 1 '(x). Then c  8x( _ '(x)), because d; 2   , but c 1  _
8x'(x), because d; 2 1 '(x).
8) Generalize (2).
10) The set of states is fc
n
: n 2 Ng, the domain for each state is the set of
integers, and c
i
; j  ' if and only if j > i. Then c
1
1 ::8x(' _ :').
Otherwise there would be c
i
with c
i
 8x(' _ :'), in particular
c
i
; i  ' _ :', and this does not hold.
12) The model consists of two states c  d, with A
c
= f1g and A
d
=
f1; 2g. Let c; 1 1 '(x), and let d; 1 1 '(x) and d; 2  '(x). Then
c 1 9x(9y '(y):! '(x)), as otherwise c; 1  9y '(y):! '(x), which
implies d; 1  '(x).
Exercise 9.5.9
 9x('(x)! 8x'(x))
Heyting counterexample as for Exercise 9.5.8(2). Kripke counterexample as
for Exercise 9.5.8(6).
 9x('(0) _ '(1)! '(x))
Similar to Exercise 9.5.8(12).
 8x::'(x):$ ::8x'(x)
Heyting counterexample as for Exercise 9.5.8(2). Kripke counterexample as
for Exercise 9.5.8(10).
 9x::'(x):$ ::9x'(x).
Heyting counterexample as for Exercise 9.5.8(12). A Kripke counterexample
consists of three states c  d; e (with d; e incomparable), all with domain
f1; 2g. The forcing relation consists only of d; 1  '(x) and e; 2  '(x).
Exercise 9.5.10
The implication from right to left is always valid, so we only consider the
implication 8x( _ '(x)) !  _ 8x'(x). Assume that A
c
= A for all c in
our model. Let c;~a  8x( _ '(x)), and suppose that c;~a 1  . Thus for
all b 2 A it must be that c; b;~a  '(x). By monotonicity, c
0
; b;~a  '(x),
for all c
0
 c. It follows that c;~a  8x'(x).
249
Exercise 9.5.11
First observe that c
00
; b;~a 1 ' _ :' always holds if c
00
is a maximal state.
Now suppose c;~a  ::8x('_:') in a nite Kripke model. There is c
0
 c
with c
0
;~a  :8x(' _ :'). Take a maximal state c
00
 c
0
and we obtain
c
00
; b;~a 1 ' _ :'.
Exercise 10.7.11
Consider a logic where all formulas of the form 8x' are equivalent to true.
Then the other two axioms remain sound but 8x'(x):! '(t) is not valid.
Exercise 11.8.1
 8x (:(x = 0)! 9y(x = y + 1))
We use induction scheme applied to the formula :(x = 0)! 9y(x = y+1).
This means we have to show that the following formulas are provable:
:(0 = 0)! 9y(0 = y + 1);
8x [(:(x = 0)! 9y(x = y + 1))! :(x+ 1 = 0)! 9y(x+ 1 = y + 1)],
and then it suces to apply modus ponens twice. The rst formula is proven
with help of the rst axiom, which can be generalized to 0 = 0. The second
formula is easily derived from 9y(x+ 1 = y + 1), and this is a consequence
of y + 1 = y + 1 (rst axiom).
 8x8y8z (x = y ! y = z ! x = z);
This is an instance of the third axiom.
 8x8y8z ((x+ y) + z = x+ (y + z))
We prove 8z ((x+y)+z = x+(y+z)) by induction and then generalize over
x and y. The rst step is (x+y)+0 = x+(y+0) and is an easy application
of the axiom 8x (x+ 0 = x) and the transitivity of equality. Then we must
derive (x+y)+(z+1) = x+(y+(z+1)) from (x+y)+z = x+(y+z). With
the axiom 8x8y (x+ (y + 1) = (x+ y) + 1) and the transitivity of equality,
we can formalize the calculation (x + y) + (z + 1) = ((x + y) + z) + 1 =
(x+ (y + z)) + 1 = x+ ((y + z) + 1) = x+ (y + (z + 1)).
 8x8y (x+ y = y + x)
Hint: First prove by induction that 8y (0 + y = y + 0). This is the base
of the main induction (with respect to x). The induction step is to derive
8y ((x + 1) + y = y + (x + 1)) from 8y (x + y = y + x). This also goes by
induction (with respect to y). Have fun!
250 Chapter 14. Solutions and hints to selected exercises
Exercise 11.8.3
Suppose a function f is representable by a formula '. Then f is strongly
representable by the formula
 (~x; y) = (9!z '(~x; z): ^ '(~x; y)) _ (:9!z '(~x; z): ^ y = 0):
We show PA ` 8~x9!y  (~x; y). (Then  implies ' and representability follows
easily.) Begin with PA ` #_:#, where # = 9!z '(~x; z). Then one can show
that PA ` # ! 9!y(# ^ '(~x; y)) and PA ` :# ! 9!y(:# ^ y = 0). Thus
PA ` 9!y(#^'(~x; y))_9!y(:#^y = 0) and it remains to permute _ with 9!y.
Exercise 11.8.8
By translation, we have HA ` ::% (note that t
f
(~x; y) = 0 is an atomic
formula), and thus HA ` (%
%
! %) ! %. Now, the formula %
%
is equivalent
to % (because ` 9y( _ 9y ) $ 9y ) and thus HA ` (% ! %) ! %. Then
HA ` %, because ` %! %.
Exercise 12.7.1 (Hint)
Cf. Exercise 9.5.10.
Exercise 12.7.2
For a model with a constant domain D we have
c; v  8p' i c; v
x
p
 '; for all x 2 D:
(One does not need to refer to c
0
 c because of monotonicity.)
Exercise 12.7.3
This exercise contains a little trap: the notion of a complete model refers
to all formulas, including those containing _, ^ and 9. But one can also
consider Kripke models for the language containing only! and 8, satisfying
the appropriate (weaker) notion of completeness. Then the semantics of the
formula
 +  := 8(( ! )! ( ! )! )
does not have to coincide with the expected semantics of  _ . Indeed,
consider a model of three states c
0
; c
1
and c
2
with a constant domain D =
ff g; fc
1
g; fc
2
g; fc
0
; c
1
; c
2
gg and with c
1
 p and c
2
 q, and no other forcing.
This model is complete with respect to ! and 8, and we have c
0
 p+ q.
The case of ^ is dierent: if a model is complete with respect to !
and 8, then c  8(( !  ! )! ) i c   and c  .
251
Exercise 12.7.13
In the context fy : ?; z : 8( !  ! )g one can derive zyz : . Now
consider the context fy : ?; x : 8(8( !  ! ): ! ) and derive
xx : ?. Thus our term has type 8(8( !  ! ): ! ): ! ? in the
context fy : ?g.
Exercise 12.7.15
Think of types as nite binary trees with leaves labeled by type variables
and internal nodes corresponding to arrows). Some of the internal nodes are
labeled by quantiers.
Suppose that xx is typable in an environment containing the declara-
tion (x : ). The type  must begin with one or more universal quantiers,
and one of these quantiers must bind a type variable occurring at the very
end of the leftmost path of the type. (Otherwise self-application is impossi-
ble.) Thus, a type assigned to x: xx must have the form (8~) !  with
one of the ~'s at the end of the leftmost path. This observation applies to
both copies of x: xx which results in that two dierent quantiers attempt
to bind the same variable | a contradiction.
Exercise 12.7.16 (After [111])
The type  assigned to K must have the form:
 = 8~( ! 8
~
(! 
0
));
where 
0
is an instance of  . The rightmost path of 
0
must be at least as
long as the rightmost path in  . In addition, one of the variables ~, say ,
must occur at the end of the rightmost path in  . The same  must remain
at the end of the rightmost path in the instance 
0
, at the same depth.
The type of the second c
2
in c
2
c
2
K must have the form 8~(
0
! %),
where  can be obtained from 
0
by instantiating ~. It begins with 8~ and
has occurrences of  at the same places as  does. In particular there is an
occurrence of  at some depth n at the rightmost path of the left subtree
of 
0
and at depth n + 1 at the rightmost path of the right subtree of 
0
.
Now, 
0
is the type of f in f(fx) and % is the type of x: f(fx). No matter
what is the type of x, we can note that the asymetry of 
0
is doubled in %,
and thus the rightmost path in % must be of length at least n+3. Although
8~(
0
! %) may still be a good type for c
2
, a term of this type cannot
be composed with itself, as the positions of  cannot be changed by just
instantiating ~.
Exercise 12.7.18(12.48)
An innite sequence of Church-style beta reductions M
i
!

M
i+1
erases to
an innite sequence of Curry-style terms jM
i
j, where at each step we either
252 Chapter 14. Solutions and hints to selected exercises
have jM
i
j !

jM
i+1
j or jM
i
j = jM
i+1
j. The latter case must hold for almost
all i, and is only possible when almost all steps M
i
!

M
i+1
are caused by
type reductions of the form (:M) ?!

M [ :=  ]. But each of these
steps decreases the number of 's in our term, so this process must also
terminate.
Bibliography
[1] A.R. Anderson and N.A. Belnap. Entailment. The Logic of Relevance
and Necessity, volume I. Princeton University Press, 1975.
[2] A.R. Anderson, N.A. Belnap, and J.M. Dunn. Entailment. The Logic
of Relevance and Necessity, volume II. Princeton University Press,
1992.
[3] T. Arts. Embedding rst order predicate logic in second order propo-
sitional logic. Master's thesis, Katholieke Universiteit Nijmegen, 1992.
[4] T. Arts and W. Dekkers. Embedding rst order predicate logic in
second order propositional logic. Technical Report 93-02, Katholieke
Universiteit Nijmegen, 1993.
[5] S. van Bakel, L. Liquori, S Ronchi della Rocca, and P. Urzyczyn.
Comparing cubes of typed and type assignment systems. Annals of
Pure and Applied Logic, 86:267{303, 1997.
[6] F. Barbanera, M. Dezani-Ciancaglini, and U. de' Liguoro. Intersection
and union types: syntax and semantics. Information and Computa-
tion, 119:202{230, 1995.
[7] H.P. Barendregt. The Lambda Calculus: Its Syntax and Semantics.
North-Holland, second, revised edition, 1984.
[8] H.P. Barendregt. Lambda calculi with types. In S. Abramsky, D.M.
Gabbay, and T.S.E. Maibaum, editors, Handbook of Logic in Computer
Science, volume II, pages 117{309. Oxford University Press, 1992.
[9] H.P. Barendregt, M. Bunder, and W. Dekkers. Completeness of some
systems of illative combinatory logic for rst-order propositional and
predicate calculus. To appear in Archive fur Mathematische Logik ,
1996.
[10] H.P. Barendregt, M. Bunder, and W. Dekkers. Completeness of the
propositions-as-types interpretation of intuitionistic logic into illative
combinatory logic. To appear in the Journal of Symbolic Logic, 1996.
253
254 Bibliography
[11] J. Barwise. Handbook of Mathematical Logic. North-Holland, 1977.
[12] S. Berardi. Type Dependence and Constructive Mathematics. PhD
thesis, Universita di Torino, 1990.
[13] M. Bezem and J. Springintveld. A simple proof of the undecidability
of inhabitation in P . Journal of Functional Programming, 6(5):757{
761, 1996.
[14] R. Bloo and K. Rose. Preservation of strong normalisation in named
lambda calculi with explicit substitution and garbage collection. In
CSN '95 - Computer Science in the Netherlands, pages 62{72, 1995.
[15] V. Breazu Tannen, D. Kesner, and L. Puel. A typed pattern calculus.
In Logic in Computer Science, pages 262{274, 1993.
[16] S. Broda and L. Damas. On principal types of stratied combinators.
Technical Report DCC-97-4, Departamento de Cincia de Computa-
dores, Universidade do Porto, 1997.
[17] L.E.J. Brouwer. Intutionistische splitsing van mathematische grond-
begrippen. Nederl. Akad. Wetensch. Verslagen, 32:877{880, 1923.
[18] A. Church. A formulation of the simple theory of types. Journal of
Symbolic Logic, 5:56{68, 1940.
[19] R. Constable. Constructive mathematics and automatic program writ-
ers. In Proceddings of the IFIP Congress, pages 229{233, Ljubljana,
1971.
[20] R. Constable. Programs as proofs: A synopsis. Information Processing
Letters, 16(3):105{112, 1983.
[21] H.B. Curry. Grundlagen der Kombinatorischen Logik. teil I. American
Journal of Mathematics, LII:509{536, 1930.
[22] H.B. Curry. Grundlagen der Kombinatorischen Logik. teil II. Ameri-
can Journal of Mathematics, LII:789{834, 1930.
[23] H.B. Curry. Functionality in combinatory logic. Proceedings of the
National Academy of Science USA, 20:584{590, 1934.
[24] H.B. Curry and R. Feys. Combinatory Logic. North-Holland, 1958.
[25] H.B. Curry, J.R. Hindley, and J.P. Seldin. Combinatory Logic II,
volume 65 of Studies in Logic and the Foundations of Mathematics.
North-Holland, 1972.
[26] D. van Dalen. Intuitionistic logic. In Handbook of Philosophical Logic,
volume III, pages 225{339. Reidel Publ. Co., 1986.
Bibliography 255
[27] L. Damas and R. Milner. Principal type schemes for functional pro-
grams. In Conference Record of the Annual ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages, pages 207{212,
Jan. 1982.
[28] N.G. de Bruijn. A survey of the project AUTOMATH. In Seldin and
Hindley [98], pages 579{606.
[29] A. Degtyarev and A. Voronkov. Decidability problems for the prenex
fragment of intuitionistic logic. In Logic in Computer Science, pages
503{512, 1996.
[30] W. Dekkers. Inhabitation of types in the simply typed -calculus.
Information and Computation, 119:14{17, 1995.
[31] G. Dowek. The undecidability of typability in the lambda-pi-calculus.
In M. Bezem and J.F. Groote, editors, Typed Lambda Calculus and
Applications, volume 664 of Lecture Notes in Computer Science, pages
139{145. Springer-Verlag, 1993.
[32] A. Dragalin. A completeness theorem for higher-order intuitionistic
logic. an intuitionistic proof. In D. Skordev, editor,Mathematical Logic
and its Applications, pages 107{124. Plenum Press, New York, 1987.
[33] C. Dwork, P.C. Kanellakis, and J.C. Mitchell. On the sequential nature
of unication. Journal of Logic Programming, 1:35{50, 1984.
[34] J.E. Fenstad, editor. Proc. Second Scandinavian Logic Symposium.
North-Holland, Amsterdam, 1971.
[35] S. Fortune, D. Leivant, and M. O'Donnell. The expresssiveness of
simple and second-order type structures. Journal of the Association
for Computing Machinery, 30:151{185, 1983.
[36] D.M. Gabbay. On 2nd order intuitionistic propositional calculus with
full comprehension. Archiv fur Mathematische Logik und Grundlagen-
forschung, 16:177{186, 1974.
[37] D.M. Gabbay. Semantical Investigations in Heyting's Intuitionistic
Logic. D. Reidel Publ. Co, 1981.
[38] J.H. Gallier. Constructive logics, part I: A tutorial on proof systems
and typed -calculi. Theoretical Computer Science, 110:249{339, 1993.
[39] G. Gentzen. Untersuchungen uber das logische Schliessen. Mathema-
tische Zeitschrift, 39:176{210, 405{431, 1935.
256 Bibliography
[40] J.H. Geuvers. Conservativity between logics and typed lambda-calculi.
In H. Barendregt and T. Nipkow, editors, Types for Proofs and Pro-
grams, volume 806 of Lecture Notes in Computer Science, pages 79{
107. Springer-Verlag, 1993.
[41] J.H. Geuvers. Logics and Type Systems. PhD thesis, University of
Nijmegen, 1993.
[42] J.H. Geuvers and M.J. Nederhof. A modular proof of strong nor-
malization for the calculus of constructions. Journal of Functional
Programming, 1(2):155{189, 1991.
[43] P. Giannini and S. Ronchi Della Rocca. Characterization of typings
in polymorphic type discipline. In Proc. Symp. on Logic in Computer
Sciene, pages 61{70. Computer Society Press, 1988.
[44] J.-Y. Girard. Interpretation fonctionelle et elimination des coupures
dans l'arithmetique d'ordre superieur. These d'

Etat, Universite Paris
VII, 1972.
[45] J.-Y. Girard. The system F of variable types, fteen years later. The-
oretical Computer Science, 45:159{192, 1986.
[46] J.-Y. Girard, Y. Lafont, and P. Taylor. Proofs and Types, volume 7
of Cambridge Tracts in Theoretical Computer Science. Cambridge
University Press, 1989.
[47] C.A. Goad. Monadic innitary propositional logic. Reports on Math-
ematical Logic, 10, 1978.
[48] K. Godel. uber eine bisher noch nicht benuntze erweiterung des niten
standpunktes. Dialectica, 12:280{287, 1980. (English translation: J.
Philos. Logic, 9:133{142, 1980.).
[49] T.G. Grin. A formulae-as-types notion of control. In Conference
Record of the Annual ACM SIGPLAN-SIGACT Symposium on Prin-
ciples of Programming Languages, pages 47{58. ACM Press, 1990.
[50] K. Grue. Map theory. Theoretical Computer Science, 102:1{133, 1992.
[51] R. Harper, F. Honsell, and F. Plotkin. A framework for dening logics.
Journal of the Association for Computing Machinery, 40(1):143{184,
1993.
[52] H. Herbelin. A -calculus structure isomorphic to Gentzen-style se-
quent calculus structure. In Computer Science Logic 1994, volume 933
of Lecture Notes in Computer Science, pages 61{75. Springer-Verlag,
1995.
Bibliography 257
[53] A. Heyting. Mathematische Grundlagenforschung. Intuitionismus. Be-
weisteorie. Springer, 1934.
[54] J.R. Hindley. Basic Simple Type Theory, volume 42 of Cambridge
Tracts in Theoretical Computer Science. Cambridge University Press,
1997.
[55] J.R. Hindley and J.P. Seldin. Introduction to Combinators and -
calculus. Cambridge University Press, 1986.
[56] S. Hirokawa. Principal types of BCK-lambda terms. Theoretical Com-
puter Science, 107:253{276, 1993.
[57] J. E. Hopcroft and J. D. Ullman. Introduction to Automata Theory,
Languages and Computation. Addison-Wesley, 1979.
[58] W. Howard. The formulae-as-types notion of construction. In Seldin
and Hindley [98], pages 479{490.
[59] G. Huet and G. Plotkin. Logical Frameworks. Cambridge University
Press, 1991.
[60] S.C. Kleene. On the interpretation of intuitionistic number theory.
Journal of Symbolic Logic, 10:109{124, 1945.
[61] S.C. Kleene. Introduction to Metamathematics. Van Nostrand, 1952.
[62] S.C. Kleene. Origins of recursive function theory. Annals of the History
of Computing, 3(1):52{67, 1981.
[63] A. Kolmogorov. Zur Deutung der intuitionistischen Logik. Mathema-
tische Zeitschrift, 35:58{65, 1932.
[64] G. Kreisel. Monadic operators dened by means of propositional quan-
tication in intuitionistic logic. Reports on Mathematical Logic, 12:9{
15, 1981.
[65] P. Kremer. On the complexity of propositional quantication in intu-
itionistic logic. Journal of Symbolic Logic, 62(2):529{544, 1997.
[66] J.-L. Krivine. Lambda-Calculus, Types and Models. Ellis Horwood Se-
ries in Computers and their Applications. Masson and Ellis Horwood,
English Edition, 1993.
[67] M. Lob. Embedding rst order predicate logic in fragments of intu-
itionistic logic. Journal of Symbolic Logic, 41(4):705{718, 1976.
[68] H.G. Mairson. A simple proof of a theorem of Statman. Theoretical
Computer Science, 103(2):387{394, 1992.
258 Bibliography
[69] S.D. Marlow. Deforestation for Higher-Order Functional Languages.
PhD thesis, University of Glasgow, 1996.
[70] E. Mendelson. Introduction to Mathematical Logic. Wadswoth &
Brooks/Cole Advanced Books and Software, third edition, 1987.
[71] E. Mendelson. Introduction to Mathematical Logic. Chapman & Hall,
London, fourth edition, 1997.
[72] R. Milner. A theory of type polymorphism in programming. Journal
of Computer and System Sciences, 17:348{375, 1978.
[73] J. Mitchell. Polymorphic type inference and containment. Information
and Control, 76:211{249, 1988.
[74] J.C. Mitchell. Foundations for Programming Languages. MIT Press,
Cambridge, 1996.
[75] C.R. Murthy. Extracting Constructive Contents from Classical Proofs.
PhD thesis, Cornell University, 1990.
[76] C.R. Murthy. Control operators, hierachies, and pseudo-classical type
systems: A-translation at work. In ACM SIGPLAN Workshop on
Continuations, 1992.
[77] B. Norstrom, K. Petersson, and J.M. Smith. Programming in Martin-
Lof's Type Theory, An Introduction. Oxford University Press, 1990.
[78] C.-H. L. Ong. A semantic view of classical proofs: Type-theoretic,
categorical, and denotational characterizations. In Logic in Computer
Science, pages 230{241, 1996.
[79] M. Parigot. Free deduction: An analysis of \computations" in classical
logic. In Second Russian Conference on Logic programming, volume
592 of Lecture Notes in Articial Intelligence, pages 361{380. Springer-
Verlag, 1991.
[80] M. Parigot. -calculus: An algorithmic interpretation of classical
natural deduction. In International Conference on Logic Programming
and Automated Reasoning, volume 624 of Lecture Notes in Computer
Science, pages 190{201. Springer-Verlag, 1992.
[81] M. Parigot. Classical proofs as programs. In Kurt Godel Colloquium,
volume 713 of Lecture Notes in Computer Science, pages 263{276.
Springer-Verlag, 1993.
[82] M. Parigot. Strong normalization for second order classical natural
deduction. In Logic in Computer Science, 1993.
Bibliography 259
[83] G. Plotkin. Call-by-name, call-by-value and the -calculus. Theoretical
Computer Science, 1:125{159, 1975.
[84] G. Pottinger. Normalization as a homomorphic image of cut-
elimination. Annals of Mathematical Logic, 12:323{357, 1977.
[85] D. Prawitz. Natural Deduction: A Proof Theoretical Study. Almquist
& Wiksell, 1965.
[86] D. Prawitz. Some results for intuitionistic logic with second order
quantication. pages 259{270. North-Holland, Amsterdam, 1970.
[87] D. Prawitz. Ideas and results of proof theory. In Fenstad [34], pages
235{307.
[88] H. Rasiowa and R. Sikorski. The Mathematics of Metamathematics.
PWN, Warsaw, 1963.
[89] N.J. Rehof and M.H. Srensen. The 

calculus. In M. Hagiya and
J. Mitchell, editors, Theoretical Aspects of Computer Software, volume
789 of Lecture Notes in Computer Science, pages 516{542. Springer-
Verlag, 1994.
[90] J. Reynolds. Towards a theory of type structure. In B Robinet, edi-
tor, Proceedings of the Programming Symposium, volume 19 of Lecture
Notes in Computer Science, pages 408{425. Springer-Verlag, 1974.
[91] A. Rezus. Classical proofs: Lambda calculus methods in elementary
proof theory, 1991. Manuscript.
[92] A. Rezus. Beyond BHK, 1993. Manuscript.
[93] J.A. Robinson. A machine-oriented logic based on the resolution prin-
ciple. Journal of the Association for Computing Machinery, 12(1):23{
41, 1965.
[94] J.B. Rosser. Highlights of the history of the lambda-calculus. Annals
of the History of Computing, 6(4):337{349, 1984.
[95] A. Schubert. Second-order unication and type inference for church-
style polymorphism. In Proc. 25th ACM Symposium on Principles of
Programming Languages, pages 233{244, January 1998.
[96] H. Schwichtenberg. Elimination of higher type levels in denitions of
primitive recursive function by means of transnite recursion. In H.E.
Rose, editor, Logic Colloquium '73, pages 279{303. North-Holland,
1975.
260 Bibliography
[97] H. Schwichtenberg. Denierbare Funktionen im Lambda-Kalkul mit
Typen. Archiv Logik Grundlagenforsch., 17:113{114, 1976.
[98] J.P. Seldin and J.R. Hindley, editors. To H.B. Curry: Essays on
Combinatory Logic, Lambda Calculus and Formalism. Academic Press
Limited, 1980.
[99] D. Skvortsov. Non-axiomatizable second-order intuitionistic proposi-
tional logic. Annals of Pure and Applied Logic, 86:33{46, 1997.
[100] S.K. Sobolev. On the intuitionistic propositional calculus with quan-
tiers (russian). Mat. Zamietki AN SSSR, 22(1):69{76, 1977.
[101] M.H. Srensen. Normalization in -Calculus and Type Theory. PhD
thesis, Department of Computer Science, University of Copenhagen,
1997.
[102] M.H. Srensen. Strong normalization from weak normalization in
typed -calculi. Information and Computation, 133(1):35{71, 1997.
[103] R. Statman. Intuitionistic propositional logic is polynomial-space com-
plete. Theoretical Computer Science, 9:67{72, 1979.
[104] W.W. Tait. Intensional interpretations of functionals of nite type I.
Journal of Symbolic Logic, 32(2):190{212, 1967.
[105] W.W. Tait. A realizability interpretation of the theory of species. In
R. Parikh, editor, Logic Colloquium, volume 453 of Lecture Notes in
Mathematics, pages 240{251. Springer-Verlag, 1975.
[106] A.S. Troelstra. Metamathematical Investigation of Intuitionistic Arith-
metic and Analysis, volume 344 of Lecture Notes in Mathematics.
Springer-Verlag, 1973.
[107] A.S. Troelstra and D. van Dalen. Constructivism in Mathematics,
An Introduction, Volume I, volume 121 of Studies in Logic and the
Foundations of Mathematics. North-Holland, 1988.
[108] A.S. Troelstra and D. van Dalen. Constructivism in Mathematics,
An Introduction, Volume II, volume 123 of Studies in Logic and the
Foundations of Mathematics. North-Holland, 1988.
[109] A.S. Troelstra and H. Schwichtenberg. Basic Proof Theory, volume 43
of Cambridge Tracts in Theoretical Computer Science. Cambridge
University Press, 1996.
[110] J. Tyszkiewicz. Z lo_zonosc problemu wyprowadzania typow w rachunku
lambda. Master's thesis, Warsaw, 1988.
Bibliography 261
[111] P. Urzyczyn. Positive recursive type assigment. In J. Wiedermann and
P. Hajek, editors, Mathematical Foundations of Computer Science,
volume 969 of Lecture Notes in Computer Science, pages 382{391.
Springer-Verlag, 1995.
[112] P. Urzyczyn. Type inhabitation in typed lambda calculi (a syntactic
approach). In de Groote P. and J.R. Hindley, editors, Typed Lambda
Calculus and Applications, volume 1210 of Lecture Notes in Computer
Science, pages 373{389. Springer-Verlag, 1995.
[113] R. Vestergaard. The cut rule and explicit substitutions. Manuscript,
1998.
[114] A. Voronkov. Proof search in intuitionistic logic with equality or back
to simultaneous rigid E-unication. In M.A. Mc Robbie and J.K.
Slaney, editors, CADE-13, volume 1104 of Lecture Notes in Computer
Science, pages 32{46. Springer-Verlag, 1996.
[115] P.L. Wadler. Deforestation: Transforming programs to eliminate in-
termediate trees. Theoretical Computer Science, 73:231{248, 1990.
[116] P.L. Wadler. A Curry-Howard isomorphism for sequent calculus.
Manuscript, 1993.
[117] J. Wells. Typability and type checking in the second-order -calculus
are equivalent and undecidable. In Proc. Symp. on Logic in Computer
Sciene, pages 176{185. IEEE, Computer Society, Computer Society
Press, 1994.
[118] J.I. Zucker. Correspondence between cut-elimination and normaliza-
tion. Annals of Mathematical Logic, 7:1{156, 1974.
