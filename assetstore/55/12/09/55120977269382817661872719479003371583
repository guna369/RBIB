Universidade de Bras´ılia
Instituto de Cieˆncias Exatas
Departamento de Cieˆncia da Computac¸a˜o
Especificac¸a˜o do Algoritmo da Transformada
Ra´pida de Fourier Implementada em um
Dispositivo Reconfigura´vel usando Lo´gica
Temporal:
Estudo de Caso
Guilherme Juscelino de Sousa Morato
Monografia apresentada como requisito parcial
para conclusa˜o do Bacharelado em Cieˆncia da Computac¸a˜o
Orientador
Prof. Dra.¯ Cla´udia Nalon
Bras´ılia
2011
Universidade de Bras´ılia – UnB
Instituto de Cieˆncias Exatas
Departamento de Cieˆncia da Computac¸a˜o
Curso de Bacharelado em Cieˆncia da Computac¸a˜o
Coordenador: Prof. Dr. Marcus Vinicius Lamar
Banca examinadora composta por:
Prof. Dra.¯ Cla´udia Nalon (Orientador) – CIC/UnB
Prof. Dr. Mauricio Ayala-Rinco´n – CIC/UnB
Prof. Dr. Ricardo Pezzuol Jacobi – CIC/UnB
CIP – Catalogac¸a˜o Internacional na Publicac¸a˜o
.
Especificac¸a˜o do Algoritmo da Transformada Ra´pida de Fourier Imple-
mentada em um Dispositivo Reconfigura´vel usando Lo´gica Temporal:
Estudo de Caso/ Guilherme Juscelino de Sousa Morato, . Bras´ılia : UnB,
2011.
46 p. : il. ; 29,5 cm.
Monografia (Graduac¸a˜o) – Universidade de Bras´ılia, Bras´ılia, 2011.
1. Lo´gica Computacional; FPGA; Sistemas Reconfigura´veis;
Transformada Discreta de Fourier; DFT; Transformada Ra´pida de
Fourier; FFT; Verificac¸a˜o de Hardware de Teoremas; Lo´gica
Proposicional Temporal
CDU 004
Enderec¸o: Universidade de Bras´ılia
Campus Universita´rio Darcy Ribeiro – Asa Norte
CEP 70910–900
Bras´ılia – DF – Brasil
Universidade de Bras´ılia
Instituto de Cieˆncias Exatas
Departamento de Cieˆncia da Computac¸a˜o
Especificac¸a˜o do Algoritmo da Transformada
Ra´pida de Fourier Implementada em um
Dispositivo Reconfigura´vel usando Lo´gica
Temporal:
Estudo de Caso
Guilherme Juscelino de Sousa Morato
Monografia apresentada como requisito parcial
para conclusa˜o do Bacharelado em Cieˆncia da Computac¸a˜o
Prof. Dra.¯ Cla´udia Nalon (Orientador)
CIC/UnB
Prof. Dr. Mauricio Ayala-Rinco´n Prof. Dr. Ricardo Pezzuol Jacobi
CIC/UnB CIC/UnB
Prof. Dr. Marcus Vinicius Lamar
Coordenador do Bacharelado em Cieˆncia da Computac¸a˜o
Bras´ılia, 11 de Julho de 2011
Agradecimentos
Agradec¸o primeiramente a Deus por estar sempre me capacitando a continuar
firme nessa missa˜o. Apesar de todas as dificuldades, todo sofrimento e todas as
mudanc¸as de percurso, tenho certeza que Deus esta´ me levando para o caminho
correto.
II Cor 4,1-12.16-17
1. Por isso na˜o desanimamos deste ministe´rio que nos foi conferido por mise-
rico´rdia.
2. Afastamos de no´s todo procedimento fingido e vergonhoso. Na˜o andamos com
astu´cia, nem falsificamos a palavra de Deus. Pela manifestac¸a˜o da verdade no´s
nos recomendamos a` conscieˆncia de todos os homens, diante de Deus.
3. Se o nosso Evangelho ainda estiver encoberto, esta´ encoberto para aqueles que
se perdem,
4. para os incre´dulos, cujas inteligeˆncias o deus deste mundo obcecou a tal ponto
que na˜o percebem a luz do Evangelho, onde resplandece a glo´ria de Cristo, que e´
a imagem de Deus.
5. De fato, na˜o nos pregamos, a no´s mesmos, mas a Jesus Cristo, o Senhor.
Quanto a no´s, consideramo-nos servos vossos por amor de Jesus.
6. Porque Deus que disse: Das trevas brilhe a luz, e´ tambe´m aquele que fez
brilhar a sua luz em nossos corac¸o˜es, para que irradia´ssemos o conhecimento do
esplendor de Deus, que se reflete na face de Cristo.
7. Pore´m, temos este tesouro em vasos de barro, para que transparec¸a claramente
que este poder extraordina´rio prove´m de Deus e na˜o de no´s.
8. Em tudo somos oprimidos, mas na˜o sucumbimos. Vivemos em completa
penu´ria, mas na˜o desesperamos.
9. Somos perseguidos, mas na˜o ficamos desamparados. Somos abatidos, mas na˜o
somos destru´ıdos.
10. Trazemos sempre em nosso corpo os trac¸os da morte de Jesus para que
tambe´m a vida de Jesus se manifeste em nosso corpo.
11. Estando embora vivos, somos a toda hora entregues a` morte por causa de
Jesus, para que tambe´m a vida de Jesus aparec¸a em nossa carne mortal.
12. Assim em no´s opera a morte, e em vo´s a vida.
16. E´ por isso que na˜o desfalecemos. Ainda que exteriormente se desconjunte
nosso homem exterior, nosso interior renova-se de dia para dia.
17. A nossa presente tribulac¸a˜o, momentaˆnea e ligeira, nos proporciona um peso
eterno de glo´ria incomensura´vel. Porque na˜o miramos as coisas que se veem, mas
sim as que na˜o se veem . Pois as coisas que se veem sa˜o temporais e as que na˜o
se veem sa˜o eternas.
Agradec¸o a minha ma˜e e ao meu pai por todo amor, apoio e pacieˆncia de-
dicados a mim, durante este per´ıodo. Agradec¸o aos meus irma˜os, avo´s, primos,
tios e amigos por estarem sempre ao meu lado me dando forc¸a. Agradec¸o imen-
samente a professora Cla´udia por todo apoio e direcionamento, desde que entrei
meio perdido no Curso de Cieˆncia da Computac¸a˜o.
5
Resumo
Este trabalho esta´ situado nas a´reas de Lo´gica Computacional e Engenharia
Eletroˆnica. O objetivo principal e´ especificar formalmente um algoritmo da Trans-
formada Ra´pida de Fourier em linguagem de descric¸a˜o de hardware e a definic¸a˜o
da Transformada Discreta de Fourier, ambos expressos na linguagem da Lo´gica
Proposicional Temporal, para que futuramente possa ser feito a verificac¸a˜o da
implementac¸a˜o atrave´s da comparac¸a˜o das duas especificac¸o˜es.
Palavras-chave: Lo´gica Computacional; FPGA; Sistemas Reconfigura´veis; Trans-
formada Discreta de Fourier; DFT; Transformada Ra´pida de Fourier; FFT; Veri-
ficac¸a˜o de Hardware de Teoremas; Lo´gica Proposicional Temporal
Abstract
This work refers to the areas of Computational Logic and Electronic Engineering.
The main goal is to specify an algorithm of Fast Fourier Transform on a reconfigu-
rable device and the definition of the Discrete Fourier Transform, both expressed
in the language of Propositional Temporal Logic, to help the verification of the
implementation by comparing the two specifications.
Keywords: Computational Logic; FPGA; Reconfigurable System; Discrete Fou-
rier Transform; DFT; Fast Fourier Transform; FFT; Hardware Verification; Pro-
positional Temporal Logic
Suma´rio
Cap´ıtulo 1 Introduc¸a˜o 11
1.1 Justificativa e Motivac¸a˜o . . . . . . . . . . . . . . . . . . . . . . . 11
1.2 Trabalhos Correlatos . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.3 Descric¸a˜o dos Cap´ıtulos . . . . . . . . . . . . . . . . . . . . . . . 12
Cap´ıtulo 2 Transformada de Fourier 13
2.1 Tipos de Transformadas . . . . . . . . . . . . . . . . . . . . . . . 13
2.2 Transformada Discreta de Fourier . . . . . . . . . . . . . . . . . . 14
2.2.1 Ca´lculo da Transformada Discreta de Fourier . . . . . . . . 19
2.3 Transformada Ra´pida de Fourier . . . . . . . . . . . . . . . . . . . 20
2.3.1 Algoritmo da DFT pela Transformada Ra´pida de Fourier . 21
Cap´ıtulo 3 A FFT em um FPGA 23
3.1 FPGA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.2 Arquitetura . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3.3 Implementac¸a˜o da FFT em um FPGA . . . . . . . . . . . . . . . 24
3.3.1 Algoritmo Implementado . . . . . . . . . . . . . . . . . . . 26
3.3.2 Exemplo . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
Cap´ıtulo 4 Lo´gica Temporal Proposicional 32
4.1 Sintaxe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
4.2 Semaˆntica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
4.3 Exemplo de Especificac¸a˜o . . . . . . . . . . . . . . . . . . . . . . 35
Cap´ıtulo 5 Especificac¸a˜o da DFT e do Algoritmo da FFT em um
Dispositivo Reprograma´vel 40
5.1 Descric¸a˜o da Definic¸a˜o da DFT . . . . . . . . . . . . . . . . . . . 41
5.2 Descric¸a˜o do Algoritmo da Implementac¸a˜o da FFT . . . . . . . . 42
Cap´ıtulo 6 Conclusa˜o 45
Refereˆncias 46
8
Lista de Figuras
2.1 Sinais de Entrada - Tipos de sinais e as correspondentes transfor-
madas que se aplicam . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.2 Exemplos de entradas e sa´ıdas de DFT real e complexa . . . . . . 15
2.3 Func¸o˜es base de uma DFT de 8 pontos . . . . . . . . . . . . . . . 18
3.1 Imagem de uma placa com um FPGA Ciclone R© II integrado . . . 24
3.2 Arquitetura de um no´ do circuito da FFT em um FPGA . . . . . 25
3.3 Circuito da FFT para N entradas . . . . . . . . . . . . . . . . . . 26
4.1 Uma sequeˆncia de estados temporais . . . . . . . . . . . . . . . . 34
Lista de Tabelas
3.1 Paraˆmetros da configurac¸a˜o inicial dos no´s da FFT para N = 8 . 27
3.2 Paraˆmetros da segunda reconfigurac¸a˜o dos No´s da FFT para N = 8 28
3.3 Paraˆmetros da terceira reconfigurac¸a˜o dos No´s da FFT para N = 8 28
3.4 Paraˆmetros da quarta reconfigurac¸a˜o dos No´s da FFT para N = 8 28
3.5 Sa´ıda da FFT para N = 8 . . . . . . . . . . . . . . . . . . . . . . 28
3.6 Exemplo de um domı´nio de tempo . . . . . . . . . . . . . . . . . 29
3.7 Exemplo de um domı´nio de tempo . . . . . . . . . . . . . . . . . 29
3.8 Valores da FFT apo´s a primeira reconfigurac¸a˜o . . . . . . . . . . 29
3.9 Valores da FFT apo´s a segunda reconfigurac¸a˜o . . . . . . . . . . . 30
3.10 Valores da FFT apo´s a terceira reconfigurac¸a˜o . . . . . . . . . . . 30
3.11 Valores da FFT apo´s a quarta reconfigurac¸a˜o . . . . . . . . . . . . 31
Lista de Equac¸o˜es
2.1 Onda cosseno de N pontos e k ciclos . . . . . . . . . . . . . . . . . . . 17
9
2.2 Onda seno de N pontos e k ciclos . . . . . . . . . . . . . . . . . . . . . 17
2.3 Equac¸a˜o da s´ıntese da DFT . . . . . . . . . . . . . . . . . . . . . . . . 17
2.4 Equac¸a˜o da DFT pelo me´todo de correlac¸a˜o . . . . . . . . . . . . . . . 19
3.1 Equac¸a˜o da DFT sem fator de normalizac¸a˜o . . . . . . . . . . . . . . . 25
10
Cap´ıtulo 1
Introduc¸a˜o
Para realizar a verificac¸a˜o formal de um sistema computacional, em geral pre-
cisamos descreveˆ-lo, ou prover sua especificac¸a˜o, com o aux´ılio de uma linguagem
formal; sa˜o caracterizadas, tambe´m com o aux´ılio de uma linguagem formal, as
propriedades que tal sistema deve ter para atender seus requisitos. Apo´s a carac-
terizac¸a˜o formal do problema e da soluc¸a˜o proposta, ferramentas de verificac¸a˜o
formal podem ser empregadas para fornecer uma prova de que o sistema, de fato,
apresenta soluc¸a˜o correta ao problema. O principal objetivo deste trabalho e´ re-
alizar o primeiro passo para a verificac¸a˜o do circuito proposto em [3], ou seja, a
especificac¸a˜o tanto do problema quanto da soluc¸a˜o implementada. A linguagem
de especificac¸a˜o e´ a da lo´gica proposicional temporal [1, 10], uma linguagem que
estende a lo´gica proposicional cla´ssica com operadores que permitem a descric¸a˜o
de sequeˆncias de eventos.
1.1 Justificativa e Motivac¸a˜o
O interesse em se desenvolver este projeto se deve a`s seguintes razo˜es:
• Conhecer melhor a a´rea de dispositivos reconfigura´veis, que se mostra como
uma soluc¸a˜o para uma poss´ıvel soluc¸a˜o para as limitac¸o˜es da arquitetura
de von Neumann [2].
• Aprofundar o conhecimento em lo´gica temporal linear proposicional, pois e´
uma linguagem interessante para expressar ac¸o˜es com variac¸o˜es no tempo,
e assim, nos auxiliar na representac¸a˜o e verificac¸a˜o de uma sequeˆncia de
eventos.
1.2 Trabalhos Correlatos
O artigo [3] e´ um estudo de caso de uma arquitetura de um dispositivo dina-
micamente reconfigura´vel para computar a Transformada Ra´pida de Fourier. A
computac¸a˜o reconfigura´vel e´ um a´rea da eletroˆnica digital que vem sendo cada
vez mais pesquisada, devido aos bons resultados obtidos, relativos a` performance,
quando comparados a soluc¸o˜es em software. Ale´m disso, apresenta flexibilidade
11
para a gerac¸a˜o de arquiteturas dedicadas para resoluc¸a˜o de problemas espec´ıficos,
com baixo custo quando comparada a processadores convencionais.
O livro [9] e´ um estudo de circuitos compostos de Flip-flops, apresentando a
especificac¸a˜o e a verificac¸a˜o do circuito baseado na Lo´gica Temporal Proposicio-
nal.
1.3 Descric¸a˜o dos Cap´ıtulos
Para o entendimento do escopo deste trabalho, e´ necessa´rio ter conhecimento
aprofundado de alguns conceitos situados na a´rea de lo´gica computacional, ma-
tema´tica e engenharia eletroˆnica. Esses conceitos sera˜o apresentados nos Cap´ıtulos
2, 3 e 4. Apo´s a introduc¸a˜o dos conceitos subjacentes, sera´ apresentada, no
Cap´ıtulo 5 a especificac¸a˜o da DFT e da implementac¸a˜o da mesma pela te´cnica
da Transformada Ra´pida de Fourier. A estrutura deste trabalho e´ detalhada a
seguir.
No Cap´ıtulo 2, e´ apresentada a definic¸a˜o da Transformada de Fourier. Houve
uma certa preocupac¸a˜o em detalhar cada propriedade desse conjunto de te´cnicas
matema´ticas, para facilitar a compreensa˜o do assunto. Sa˜o apresentados tambe´m
exemplos de te´cnicas para a aplicac¸a˜o da Transformada Discreta de Fourier. A
Transformada Ra´pida de Fourier e´ apresentada em mais detalhe, pois e´ o principal
alvo de estudo do projeto. O conteu´do deste cap´ıtulo e´ baseado em [11, 3],
para a apresentac¸a˜o da Transformada de Fourier, e em [8], para apresentac¸a˜o de
propriedades dos nu´meros complexos.
O cap´ıtulo seguinte apresenta informac¸o˜es ba´sicas sobre o dispositivo utili-
zado para a aplicac¸a˜o do algoritmo da Transformada Ra´pida de Fourier. Para
este cap´ıtulo, os manuais de instruc¸o˜es da Altera [6, 7, 5], empresa que fabrica um
tipo de dispositivo reconfigura´vel chamado de FPGA, abreviac¸a˜o para o termo
em Field Programmable Gate Arrays, modelo Ciclone R©, ajudaram a entender
melhor as caracter´ısticas do dispositivo e dos recursos que ele necessita para a
implementac¸a˜o de um algor´ıtimo. Tambe´m neste cap´ıtulo, e´ apresentada a im-
plementac¸a˜o do algoritmo de uma Transformada Ra´pida de Fourier em um dis-
positivo reconfigura´vel, estudo de caso desse projeto. Esse algoritmo foi estudado
a partir do artigo [3].
A lo´gica temporal e´ apresentada no Cap´ıtulo 4, onde sa˜o apresentadas as suas
principais caracter´ısticas, como a sintaxe e a semaˆntica da linguagem. Tambe´m
e´ apresentado um estudo de caso para exemplificar o uso da linguagem [1, 10].
No Cap´ıtulo 5, e´ apresentada a especificac¸a˜o do Algoritmo da Transformada
Ra´pida de Fourier implementado no dispositivo reconfigura´vel [3], utilizando o
conhecimento apresentado nos cap´ıtulos anteriores. A linguagem da Lo´gica Tem-
poral Proposicional e´ utilizada para a escrita do problema e da soluc¸a˜o imple-
mentada.
Por fim, no Cap´ıtulo 6, relatamos os resultados obtidos e a ana´lise dos mes-
mos. Tambe´m e´ apresentada uma visa˜o geral sobre os objetivos, o processo de
verificac¸a˜o e os resultados obtidos.
12
Cap´ıtulo 2
Transformada de Fourier
A ana´lise de Fourier e´ a aplicac¸a˜o de um conjunto de te´cnicas matema´ticas
utilizadas para transformar sinais de entrada do domı´nio de tempo para o domı´nio
de frequeˆncias. A decomposic¸a˜o de sinais tem o propo´sito de transformar sinais
primitivos, complexos de se analisar, em va´rias ondas seno e cosseno, que sa˜o
mais simples de analisar e manipular. A soma da multiplicac¸a˜o das amplitudes
armazenadas, pelas func¸o˜es sinusoidais sintetizam o sinal original, previamente
decomposto. Neste cap´ıtulo, revisaremos os conceitos ba´sicos e algoritmos para
decomposic¸a˜o de sinais, em conformidade com o apresentado em [11].
2.1 Tipos de Transformadas
Os sinais primitivos de entrada podem ser classificados em quatro categorias,
cada uma com duas propriedades espec´ıficas, conforme Figura 2.1. As categorias
sa˜o:
Aperio´dico e Cont´ınuo - Os sinais de entrada se estendem continuamente para
o infinito positivo e negativo, sem um padra˜o de repetic¸a˜o. A transformada
para essa categoria e´ chamada de Transformada de Fourier;
Perio´dico e Cont´ınuo - Os sinais de entrada se estendem continuamente para
o infinito positivo e negativo, possuindo um padra˜o regular de repetic¸a˜o.
Essa categoria de transformadas e´ chamada de Se´rie de Fourier;
Aperio´dico e Discreto - Os sinais de entrada sa˜o pontos discretos entre o in-
finito positivo e negativo, sem um padra˜o regular de repetic¸a˜o. Esse tipo
de transformada e´ chamada de Transformada de Fourier de Tempo
Discreto, ou DTFT, abreviac¸a˜o para Discrete Time Fourier Transform;
Perio´dico e Discreto - Os sinais de entrada sa˜o pontos discretos entre o infinito
positivo e negativo, com um padra˜o regular de repetic¸a˜o. Essa categoria de
transformadas e´ chamada de Transformada Discreta de Fourier, ou
DFT, abreviac¸a˜o para Discrete Fourier Transform.
Observe que na caracterizac¸a˜o acima todos os tipos de sinais sa˜o infinitos, uma
vez que ondas seno e cosseno sa˜o definidas sobre o cont´ınuo real. Obviamente, na˜o
13
Transformadade Fourier
Transformada Discreta de Fourier
Transformada de Fourier de Tempo Discreto
Série de Fourier
Figura 2.1: Sinais de Entrada - Tipos de sinais e as correspondentes transformadas
que se aplicam
e´ poss´ıvel trabalhar algoritmicamente com um nu´mero infinito de amostras de um
sinal. Tambe´m na˜o e´ poss´ıvel ter como entrada um sinal infinito para sintetizar
sinal de tamanho finito. Para resolver esse problema, os dados discretos de um
sinal sa˜o tratados de modo a parecerem infinitos. Um dos enfoques consiste em
se obter uma amostra e fazer com que seja atribu´ıdo zero a todos os pontos a`
esquerda e a` direita da amostra; neste caso, a amostra infinita resultante pode ser
caracterizada como um sinal aperio´dico, sendo tratado como na categoria DTFT.
Em outro enfoque, considera-se que a amostra se repete infinitamente a` esquerda
e a` direita; neste caso, o sinal considerado e´ tratado como perio´dico, na categoria
DFT.
Para sintetizar um sinal aperio´dico, e´ necessa´rio um nu´mero infinito de func¸o˜es
sinusoidais que o caracterizem, tornando imposs´ıvel calcular a Transformada de
Fourier de Tempo Discreto por um algoritmo computacional. Assim, a u´nica
transformada que, de fato, e´ utilizada no processamento digital de sinais e´ a
Transformada Discreta de Fourier, que discutiremos em mais detalhe na pro´xima
sec¸a˜o.
2.2 Transformada Discreta de Fourier
Todas as categorias apresentadas na Sec¸a˜o 2.1 podem ter como domı´nio os
nu´meros reais ou os complexos.
14
aaa
aaa
aaa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aaa
aaa
aaa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aaa
aaa
aaa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aaa
aaa
aaa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aaa
aaa
aaa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aaa
aaa
aaa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aaa
aaa
aaa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
aa
Domíniode Tempo
Domínio de Tempo
Domínio de Frequência
Domínio de Frequência
Parte Real
Parte Real
Parte Imaginária Parte Imaginária
Parte Real
Parte Imaginária
DFT Real
DFT Complexa
0 0 N/2
N/2
N-1
N-1 N/2
N/2 N-1
N-1
0
00
0
0
Figura 2.2: Exemplos de entradas e sa´ıdas de DFT real e complexa
A Transformada Discreta de Fourier processa sinais de entrada, rotulados
como domı´nio de tempo, em sinais de sa´ıda, rotulados como domı´nio de frequeˆn-
cias. Como esquematizado na Figura 2.2, a DFT Real transforma um domı´nio
de tempo de N pontos em dois domı´nios de N/2 + 1 pontos, sendo um deles a
parte real, e o outro, a parte imagina´ria. Esses dois domı´nios gerados constituem
o domı´nio de frequeˆncias e conte´m as amplitudes das ondas seno e ondas cosseno
contidas no sinal de entrada.
A DFT complexa transforma dois domı´nios de tempo de N pontos de entrada
em dois domı´nios de amplitudes, com N pontos cada um, constituindo o domı´nio
de frequeˆncias. Para se calcular a DFT real por um me´todo de DFT complexa,
cada amostra a ser analisada deve ser colocada na parte real de cada ponto do
domı´nio de tempo. Os N valores da parte imagina´ria no domı´nio de tempo de
entrada devem ser nulos. Ao aplicar a te´cnica, sa˜o gerados dois domı´nios de N
pontos, constituindo o domı´nio de frequeˆncia. O intervalo do ponto 0 ao ponto
N/2 dos dois vetores do domı´nio de frequeˆncia gerados correspondem ao resultado
da ana´lise dessa DFT real.
Apresentaremos a transformada levando em considerac¸a˜o sua representac¸a˜o
como nu´meros complexos, pois a implementac¸a˜o em estudo [3] utiliza este domı´nio.
Assim, levamos em considerac¸a˜o os N pontos gerados nos dois vetores do domı´nio
de frequeˆncia.
O domı´nio de tempo de entrada e o domı´nio de frequeˆncia de sa´ıda possuem
as seguintes caracter´ısticas:
Domı´nio de Tempo - O sinal de entrada e´ caracterizado por uma amostra-
gem de tamanho N sobre um dado intervalo de tempo. Utilizamos letras
15
minu´sculas para representar os vetores de amostras no domı´nio do tempo.
Por exemplo, se x representa um determinado sinal, enta˜o x[] e´ o vetor de
amostras deste sinal. Observa-se que se x[j] e´ o vetor de N amostras, os seus
elementos variam de j = 0 ate´ j = N − 1. Ao considerarmos representac¸o˜es
complexas de um sinal, x e´ caracterizado, na realidade, por dois vetores,
Rex[j] e Imx[j], contendo as partes real e imagina´ria de x[j], respectiva-
mente. Para o ca´lculo da DFT, normalmente considera-se o nu´mero de
amostras como sendo uma poteˆncia de dois, uma vez que o enderec¸amento
de dados e´ realizado a partir de tamanhos inteiros bina´rios e porque o algo-
ritmo mais eficiente para o ca´lculo da DFT, a Transformada Ra´pida de
Fourier, opera com estas poteˆncias.
Domı´nio de Frequeˆncia - O sinal de sa´ıda conte´m as amplitudes de ondas
seno e cosseno que podem sintetizar o sinal de entrada. Sa˜o usadas letras
maiu´sculas para representar as informac¸o˜es referentes a este domı´nio; por
exemplo, X[]. Considerando o sinal de entrada no domı´nio de tempo x[j]
com N valores, o sinal de sa´ıda e´ representado por X[k], com k variando de
k = 0 ate´ k = N − 1. A parte real desse vetor X[k] corresponde a ReX[k] e
descreve as amplitudes das ondas cosseno comN pontos. A parte imagina´ria
de X[k] e´ denotada por ImX[k] e corresponde aos valores das amplitudes
das ondas seno com N pontos. A varia´vel k representa a frequeˆncia das
ondas seno e cosseno que sera´ multiplicada pela amplitude armazenada no
vetor.
O processo de transformar o sinal do domı´nio de tempo no domı´nio de frequeˆn-
cias e´ chamado de DFT, decomposic¸a˜o ou ana´lise; o processo de transformar
o domı´nio de frequeˆncias no domı´nio de tempo e´ chamado de DFT inversa ou
s´ıntese.
Os ı´ndices do eixo horizontal do domı´nio de frequeˆncias X podem ser repre-
sentado de quatro maneiras distintas, detalhadas a seguir:
Taxa de Amostra - Os N ı´ndices de X[k] sa˜o representados diretamente pela
varia´vel k.
Frac¸a˜o da Taxa de Amostra - Os N ı´ndices de amplitudes, sa˜o representados
por f , sendo f a frac¸a˜o f = k/N . Assim podemos optar por eixo horizontal
variando de −1 a 0 para k variando de −(N − 1) a 0; ou variando de −0, 5
a 0, 5 com k variando de −N/2 a N/2; ou enta˜o variando de 0 a 1, com k
variando de 0 a N − 1.
Radianos - E´ semelhante a` Frac¸a˜o da Taxa de Amostra, mas os ı´ndices ω do eixo
horizontal sa˜o multiplicados por 2pi, obtendo ω = 2pik/N . Assim os ı´ndices
das amplitudes sa˜o representados como igualmente espac¸ados no intervalo
entre −2pi e 0, ou −pi e pi ou 0 e 2pi, dependendo da forma escolhida para
representar k.
Hertz - E´ usado para aplicac¸o˜es espec´ıficas. Considerando um sinal de taxa de
entrada igual a T Hz, a varia´vel independente esta´ no intervalo entre 0 e T .
16
Por exemplo, se temos 5000 amostras por segundos, o eixo horizontal seria
representado por T , variando de T = 0 ate´ T = 5 kHz.
As ondas seno e cosseno usadas na DFT sa˜o chamadas de func¸o˜es bases e sa˜o
geradas por:
Ck[j] = cos(
2pikj
N
) (2.1)
Sk[j] = sin(
2pikj
N
) (2.2)
onde Ck e´ a onda cosseno com N pontos, correspondente a` amplitude armazenada
em ReX[k]; e Sk e´ a onda seno com N pontos, correspondente a` amplitude
armazenada em ImX[k].
A Figura 2.3 apresenta um exemplo de todas as ondas cosseno e ondas seno
que podem estar presentes em uma DFT de 8 pontos. Para N = 8, k varia de 0 a
N − 1 gerando oito ondas cosseno e oito ondas seno. A varia´vel j assume valores
entre 0 e N − 1, representando os N pontos de amostra em cada onda. Assim,
para cada onda seno e onda cosseno, k representa quanto ciclos inteiros a onda
seno ou a onda cosseno completa para os N pontos de amostra.
As ondas representadas por S0 e SN/2 sempre apresentam todos os seus pontos
de amostra com valor igual a 0 pois sa˜o resultantes de ca´lculos de sin(0) e sin(j ·pi)
respectivamente, onde j e´ um nu´mero inteiro positivo, resultando em pontos nulos.
Como ImX[0] e ImX[N/2] representam as amplitudes de S0 e SN/2, sempre
possuem valores nulos e na˜o influenciam na s´ıntese de x[].
A s´ıntese de um ponto do domı´nio de tempo x[] pode ser obtida pela soma,
em todas as ondas cosseno e ondas seno, do produto do ponto desejado e da
amplitude correspondente a`quela frequeˆncia. A fo´rmula que caracteriza a s´ıntese
e´ dada por:
x[j] =
N−1∑
k=0
X[k] · (cos(2pikj
N
) + i · sin(2pikj
N
) (2.3)
A partir da equac¸a˜o 2.3, obtemos:
x[j] =
N−1∑
k=0
(ReX[k] · cos(2pikj
N
)− ImX · sin(2pikj
N
))
+i · (ReX[k] · sin(2pikj
N
) + ImX · cos(2pikj
N
))
Neste trabalho iremos focar na decomposic¸a˜o, portanto a s´ıntese na˜o sera´
aprofundada neste texto.
17
0 1 2 3 4 5 6 7 80 1 2 3 4 5 6 7 8
S [ ]4C [ ]4
1
0
-1
1
0
-1
0 1 2 3 4 5 6 7 80 1 2 3 4 5 6 7 8
S [ ]5C [ ]5
1
0
-1
1
0
-1
0 1 2 3 4 5 6 7 80 1 2 3 4 5 6 7 8
S [ ]6C [ ]6
1
0
-1
1
0
-1
0 1 2 3 4 5 6 7 80 1 2 3 4 5 6 7 8
S [ ]7C [ ]7
1
0
-1
1
0
-1
0 1 2 3 4 5 6 7 80 1 2 3 4 5 6 7 8
S [ ]3C [ ]3
1
0
-1
1
0
-1
0 1 2 3 4 5 6 7 80 1 2 3 4 5 6 7 8
S [ ]2C [ ]2
1
0
-1
1
0
-1
0 1 2 3 4 5 6 7 80 1 2 3 4 5 6 7 8
S [ ]1C [ ]1
1
0
-1
1
0
-1
0 1 2 3 4 5 6 7 80 1 2 3 4 5 6 7 8
S [ ]0C [ ]0
1
0
-1
1
0
-1
C [j] = sen(2pikj)
N
k
C [j] = cos(2pikj)
N
k
Figura 2.3: Func¸o˜es base de uma DFT de 8 pontos. Sa˜o 8 ondas cosseno e 8 seno
com N pontos de amostra
18
2.2.1 Ca´lculo da Transformada Discreta de Fourier
De acordo com [11], a DFT pode ser calculada de treˆs formas diferentes,
variando a eficieˆncia:
Equac¸o˜es Simultaˆneas - E´ bastante ineficiente na pra´tica, mas nos ajuda a
entender a DFT.
Correlac¸a˜o - E´ eficiente para DFT com menos de 32 pontos de amostra.
Transformada Ra´pida de Fourier - E´ extremamente eficiente e muito usada
no processamento digital de sinais.
Os treˆs me´todos produzem resultados ideˆnticos e sera˜o explicados nas sec¸o˜es
seguintes. Sera´ dada eˆnfase a` Transformada Ra´pida de Fourier pois e´ o
algoritmo usado na implementac¸a˜o baseada em reconfigurac¸a˜o dos dispositivos
que iremos analisar [3].
2.2.1.1 DFT por Equac¸o˜es Simultaˆneas
O ca´lculo da DFT por equac¸o˜es simultaˆneas e´ realizado a partir da definic¸a˜o
da Equac¸a˜o 2.3, que realiza a s´ıntese de um ponto do domı´nio de tempo. Consi-
derando um valor N de pontos de amostra do domı´nio de tempo, seria necessa´rio
obter N equac¸o˜es independentes para obter todas as amplitudes do domı´nio de
frequeˆncias, sendo N amplitudes de X[k].
O me´todo apresentado e´ simples e nos ajuda a entender melhor a DFT, mas
na˜o e´ muito utilizado devido ao grande nu´mero de passos necessa´rios para se
encontrar o domı´nio de frequeˆncias.
2.2.1.2 DFT por Correlac¸a˜o
Uma forma melhor que o me´todo de equac¸o˜es simultaˆneas para se calcular a
DFT e´ o me´todo da correlac¸a˜o. O conceito de correlac¸a˜o afirma que para saber
se um sinal conhecido, que neste caso sa˜o as ondas seno e cosseno, esta´ contido
em outro sinal, basta verificar a soma do produto de cada par de pontos dos
dois sinais. O resultado dessa operac¸a˜o corresponde ao peso em que uma onda
conte´m a outra. Assim, este valor resultante corresponde a` amplitude da onda
seno ou onda cosseno no domı´nio das frequeˆncias. A equac¸a˜o correspondente a
este procedimento e´:
X[k] =
1
N
·
N−1∑
j=0
x[j] · ωjkN para k = 0, 1, · · · , N − 1 (2.4)
onde
ωN = e
−i 2pi
N
e´ a primitiva da N -e´sima raiz complexa.
19
Para separar a fo´rmula nas partes real e imagina´ria do domı´nio de frequeˆncias,
e´ preciso realizar algumas operac¸o˜es em nu´meros complexos. Substituindo ω em
2.4, obtemos:
X[k] =
1
N
·
N−1∑
j=0
x[j] · e−i 2pijkN para k = 0, 1, · · · , N − 1. (2.5)
De acordo com a relac¸a˜o de Euler, ei·t = cos(t) + i sin(t). Fazendo a substi-
tuic¸a˜o em 2.5, temos que:
X[k] =
1
N
·
N−1∑
j=0
x[j] · (cos(2pijk
N
)− i sin(2pijk
N
)) para k = 0, 1, · · · , N − 1. (2.6)
Sabendo que a multiplicac¸a˜o de nu´meros complexos, (a+ bi) e (c+di), e´ dada
por (ac− bd) + (ad+ cb)i, a partir de 2.6, temos:
ReX[k] =
1
N
·
N−1∑
j=0
Rex[j] · cos(2pikj
N
) + Imx[j] · sin(2pikj
N
)
e
ImX[k] =
1
N
·
N−1∑
j=0
Rex[j] · − sin(2pikj
N
) + Imx[j] · cos(2pikj
N
).
Correlacionando o sinal de entrada com as func¸o˜es bases, podemos encontrar
os valores de ReX[k] e ImX[k] para k variando de 0 a N − 1. O valor de
X[k] = ReX[k] + i · ImX[k]
O ca´lculo da DFT utilizando correlac¸a˜o, em domı´nios de tempo, e´ simples.
Mas para domı´nios de tempo com nu´mero de pontos de amostra maior que
32, e´ mais eficiente usar a Transformada Ra´pida de Fourier, detalhada na
Sec¸a˜o 2.3.
2.3 Transformada Ra´pida de Fourier
Dos muitos me´todos para se calcular a DFT, a Transformada Ra´pida de
Fourier, ou FFT, abreviac¸a˜o para Fast Fourier Transform, e´ mais eficiente que
os outros, podendo reduzir o tempo de ca´lculo em centenas de vezes. A FFT na˜o e´
um tipo diferente de DFT, e sim uma te´cnica para se calcular a DFT. O algoritmo
foi proposto por J. W. Cooley e J. W. Tukey em [4]. A te´cnica ja´ havia sido
usada antes por Karl Friedrich Gauss (1777-1855), mas o trabalho foi abandonado
por na˜o existir na e´poca, a ferramenta apropriada para aplicar o algoritmo, o
computador. O algoritmo para a computac¸a˜o da DFT tem complexidade com
cota superior de O(n2) e o algoritmo da FFT proposto por Cooley-Tukey tem
cota superior de O(n lnn), conforme [11].
20
2.3.1 Algoritmo da DFT pela Transformada Ra´pida de
Fourier
A FFT e´ um algoritmo um pouco mais complicado que os outros apresentados
e utiliza nu´meros complexos como sinais de entrada. Como visto na Sec¸a˜o 2.2,
cada ponto de amostra, possui uma parte real e uma parte imagina´ria. Portanto,
quando nos referimos a uma amostra X[k] no domı´nio de frequeˆncias, estamos
nos referindo a combinac¸a˜o de ReX[k] e a ImX[k].
A FFT funciona decompondo esse domı´nio de tempo de N pontos complexos
em N domı´nios de tempo de apenas um ponto. Em seguida, e´ calculado o espec-
tro de frequeˆncias desses N domı´nios para enta˜o sintetizar esses N espectros de
frequeˆncias em apenas um domı´nio de frequeˆncias. Esse domı´nio de frequeˆncias
resultante corresponde a` Transformada Discreta de Fourier do sinal de entrada.
A decomposic¸a˜o do sinal de entrada e´ realizada atrave´s de uma se´rie de passos
ate´ que sejam obtidos os N domı´nios de tempo. Para que isso acontec¸a, em
cada um desses passos da decomposic¸a˜o, os domı´nios de tempo existentes sa˜o
divididos em dois domı´nios cada um. Esse padra˜o de divisa˜o e´ seguido ate´ que
cada um dos domı´nios possua apenas um ponto. Sa˜o necessa´rios log2N passos
nessa decomposic¸a˜o.
Em cada uma das diviso˜es dos domı´nios de tempo, os pontos sa˜o separados
de acordo com um padra˜o chamado Decomposic¸a˜o Entrelac¸ada. Esse padra˜o e´
necessa´rio para que ao final da decomposic¸a˜o, os domı´nios estejam ordenados con-
forme a te´cnica de ordenac¸a˜o chamada de Reversa˜o de Bit. A ideia desse padra˜o
e´ que no final da decomposic¸a˜o, a posic¸a˜o de cada ponto seja igual ao reverso
do nu´mero em bina´rio da posic¸a˜o que ele se encontrava antes da decomposic¸a˜o.
Para exemplificar essa ordenac¸a˜o, vamos analisar o sinal de entrada x[12] para
N = 16. O nu´mero 12 em bina´rio, corresponde a (1100). A reversa˜o desse nu´mero
corresponde a (0011), ou seja, o nu´mero 3. Assim, x[12] corresponderia ao quarto
domı´nio de tempo apo´s a decomposic¸a˜o.
Apo´s a decomposic¸a˜o, e´ preciso achar o espectro de frequeˆncia para cada um
dos domı´nios de um ponto. Claramente, o espectro de frequeˆncia de um domı´nio
com apenas um ponto corresponde a ele mesmo. Assim, decompondo o sinal de
entrada, e´ encontrado tambe´m o espectro de frequeˆncia. Portanto, para encontrar
a Transformada Discreta de Fourier, e´ preciso apenas sintetizar os N espectros
de frequeˆncia em apenas um domı´nio de frequeˆncias.
Para sintetizar esses domı´nios, e´ preciso combinar pares de espectro para que
formem um domı´nio com o dobro de seu tamanho original. Essas combinac¸o˜es
sa˜o repetidas, ate´ que se forme um u´nico domı´nio de frequeˆncias, correspondendo
a` DFT do sinal de entrada.
Antes de combinar dois domı´nios, como dito, e´ preciso dobra´-los de tamanho.
Isso e´ feito intercalando os pontos do espectro de frequeˆncias com zeros. Um
dos domı´nios mante´m o primeiro ponto e insere um zero apo´s cada ponto. O
outro domı´nio a ser combinado inicia com zero, deslocando cada ponto para uma
posic¸a˜o apo´s cada zero. Este deslocamento de uma casa por cada ponto feito
no segundo espectro corresponde a` multiplicac¸a˜o por uma func¸a˜o sinusoidal. A
cada combinac¸a˜o, um dos espectros de frequeˆncia e´ multiplicado por uma func¸a˜o
e, enta˜o, combinado com outro domı´nio, ate´ que um so´ domı´nio de frequeˆncias
21
seja gerado, obtendo assim a Transformada Discreta de Fourier, pela te´cnica da
Transformada Ra´pida de Fourier.
22
Cap´ıtulo 3
A FFT em um FPGA
Os dispositivos digitais na˜o reconfigura´veis nem sempre sa˜o ideais para as
aplicac¸o˜es que executam, ja´ que poderia haver uma melhora significativa se ar-
quiteturas espec´ıficas fossem desenvolvidas para cada uma dessas aplicac¸o˜es. Os
dispositivos reconfigura´veis se apresentam como uma alternativa para executar
aplicac¸o˜es comuns e como uma alternativa para executar soluc¸o˜es para aplicac¸o˜es
espec´ıficas com melhor desempenho, por meio de uma arquitetura dedicada a`
execuc¸a˜o desta soluc¸a˜o. O desenvolvimento desses dispositivos, combinados a
co´digos de programac¸a˜o, e o surgimento de FPGAs (do ingleˆs Field Programmable
Gate Arrays) facilitam, assim, o desenvolvimento de arquiteturas para finalidades
espec´ıficas. Os conceitos introduto´rios, apresentados a seguir, esta˜o baseados em
[6, 7, 5].
3.1 FPGA
Os FPGAs sa˜o dispositivos eletroˆnicos constitu´ıdos de blocos lo´gicos recon-
figura´veis interligados por circuitos de chaveamento. Estes blocos lo´gicos sa˜o
programados para realizar func¸o˜es espec´ıficas, de acordo com as necessidades
de cada projeto, como ocorre em qualquer outro tipo de circuito dedicado. FP-
GAs foram idealmente desenvolvidos visando aplicac¸o˜es de prototipac¸a˜o. O baixo
custo e o resumido tempo de implementac¸a˜o de soluc¸o˜es para aplicac¸o˜es trazem
grandes vantagens sobre a te´cnica tradicional, ja´ que alterac¸o˜es podem ser feitas
rapidamente e sem custos adicionais em caso de se encontrar erros ou se houver
necessidade de quaisquer outras modificac¸o˜es no projeto.
3.2 Arquitetura
Um FPGA e´ composto basicamente por treˆs tipos de componentes:
Blocos de entrada e sa´ıda (IOB) - Sa˜o circuitos responsa´veis pelo interfacea-
mento das sa´ıdas provenientes das sa´ıdas das combinac¸o˜es de blocos lo´gicos
configura´veis. Sa˜o basicamente buffers, que funcionara˜o como um pino bi-
direcional entrada e sa´ıda do FPGA.
23
Figura 3.1: Imagem de uma placa com um FPGA Ciclone R© II integrado
Blocos lo´gicos configura´veis (CLB) - Sa˜o circuitos ideˆnticos, constru´ıdos pela
reunia˜o de flip-flops (entre 2 e 4) e a utilizac¸a˜o de lo´gica combinacional.
Utilizando os CLBs, um usua´rio pode construir elementos funcionais lo´gicos.
Chaves de interconexa˜o (Switch Matrix) - Sa˜o as trilhas utilizadas para conec-
tar os CLBS e IOBS. Os recursos de interconexo˜es possuem trilhas para
conectar as entradas e sa´ıdas dos CLBs e IOBs para as redes apropria-
das. Geralmente, a configurac¸a˜o e´ estabelecida por programac¸a˜o interna
das ce´lulas de memo´ria esta´tica, que determinam func¸o˜es lo´gicas e conexo˜es
internas implementadas no FPGA entre os CLBs e os IOBs. O processo de
escolha das interconexo˜es e´ chamado de roteamento.
Os blocos lo´gicos sa˜o dispostos de forma bidimensional; as chaves de interco-
nexa˜o sa˜o dispostas em formas de trilhas verticais e horizontais entre as linhas e
as colunas dos blocos lo´gicos.
3.3 Implementac¸a˜o da FFT em um FPGA
A FFT e´ uma implementac¸a˜o da Transformada Discreta de Fourier, a DFT.
A transformada de Fourier F [n] × x, de um vetor de N nu´meros complexos
x = (x[0], ..., x[N − 1]), corresponde ao vetor de tamanho N dado por X =
(X[0], ..., X[N − 1]), como foi explicado no Cap´ıtulo 2, Equac¸a˜o 2.4.
Segundo [11], no processo de ana´lise e s´ıntese de sinais complexos, para que
um sinal seja reconstru´ıdo de forma ideˆntica ao sinal original, o fator 1/N tem
que ser aplicado em algum momento do processo. Em [11], esse fator e´ aplicado
24
na fo´rmula de ana´lise. Em [3], este fator na˜o esta´ presente na fo´rmula de ana´lise
apresentada, para que seja aplicado no processo de s´ıntese. Nos Cap´ıtulos 3 e 5,
consideraremos a Equac¸a˜o 3.1 apresentada em [3].
X[k] = ·
N−1∑
j=0
x[j] · ei 2pijkN para k = 0, 1, · · · , N − 1 (3.1)
Segundo [3], a implementac¸a˜o dessa transformada em um dispositivo recon-
figura´vel pode ser feita atrave´s da modelagem de uma arquitetura que executa
operac¸o˜es de adic¸a˜o, subtrac¸a˜o e multiplicac¸a˜o, conforme mostrado na Figura 3.2.
Essa arquitetura possui va´rios componentes, a saber:
• duas portas de entrada (P1 e P2);
• dois registradores (Ar1 e Ar2);
• uma constante (C1);
• dois operadores (Op1 e Op2);
• um registrador (R1); e
• um registrador (R2).
O nu´mero de circuitos necessa´rios depende do tamanho do vetor ao qual sera´
aplicado o ca´lculo. Se tivermos um vetor de tamanho N , sa˜o necessa´rios N
circuitos.
P2P1
Op1
Ar1
Op2
Ar2
R1
R2
C1
Figura 3.2: Arquitetura de um no´ do circuito da FFT em um FPGA
O ca´lculo da FFT e´ feito com uma primeira configurac¸a˜o e mais treˆs recon-
figurac¸o˜es da arquitetura. Essa configurac¸o˜es sa˜o indicadas pelos registradores
25
Ar1 e Ar2; pelos operadores Op1 e Op2; e pela constante C1. Os registradores
Ar1 e Ar2 indicam o que sera´ carregado nas portas de entradas. Caso a opc¸a˜o
seja I, sera˜o carregados na porta de entrada os coeficientes de um polinoˆmio, ja´
na ordem adequada para a execuc¸a˜o do algoritmo. Caso na˜o seja I, sera´ carre-
gado na porta, um nu´mero que indicara´ o registrador R2 de algum dos circuitos.
Os operadores Op1 e Op2 indicam qual operac¸a˜o sera´ realizada pelo circuito. A
primeira operac¸a˜o e´ feita entre as duas portas de entrada, P1 e P2. A segunda
operac¸a˜o e´ feita entre o resultado da primeira operac¸a˜o, em R1, e a constante C1.
Os dois operadores Op1 e Op2 podem ser reconfigurados para quaisquer operac¸o˜es
sobre nu´meros complexos. Para a FFT, usamos apenas as operac¸o˜es de adic¸a˜o,
subtrac¸a˜o e multiplicac¸a˜o.
3.3.1 Algoritmo Implementado
a
0
a
a
a
a
a
a
a
4
2
6
1
5
3
7
b
0
b
b
b
b
b
b
b
1
2
3
4
5
6
7
Figura 3.3: Circuito da FFT para N entradas
A Figura 3.3 mostra uma esquematizac¸a˜o sobre a implementac¸a˜o do circuito
que realiza o ca´lculo da FFT. Na figura, cada ponto representa um no´ do circuito.
Cada no´, armazena um valor. A passagem de uma coluna para outra representa
uma reconfigurac¸a˜o. Assim, o valor armazenado no no´, passa a ser a combinac¸a˜o
de dois no´s da coluna anterior. As linhas indicam quais no´s sera˜o combinados
por operac¸o˜es aritme´ticas, para gerar o resultado armazenado na pro´xima coluna.
26
No circuito, os registradores Ar1 e Ar2 sa˜o designados para fazer as indicac¸o˜es
representadas pelas linhas.
No primeiro momento, os registradores Ar1 e Ar2 selecionam o que sera´ car-
regado nas portas P1 e P2; no caso desta implementac¸a˜o, selecionam como en-
trada os coeficientes de um polinoˆmio, ou seja, os valores discretos que esta˜o no
domı´nio de tempo que sera´ decomposto (a0 a a7). Por isso, Ar1 e Ar2 apresentam
a opc¸a˜o I. Os valores externos de entrada, ja´ esta˜o na ordem desejada apo´s a
decomposic¸a˜o feita atrave´s da reversa˜o de bit, conforme explicado na Sec¸a˜o 2.3.1.
Dessa forma, conforme podemos ver na Figura 3.3, cada no´ recebe na configurac¸a˜o
inicial um valor discreto ja´ permutado e um zero, para que ao final da primeira
configurac¸a˜o, os valores externos de entrada estejam armazenados em R2. As-
sim, cada no´ fara´ a adic¸a˜o entre um coeficiente e um zero, cujo resultado sera´
armazenado em R1. Na segunda operac¸a˜o, e´ feita a multiplicac¸a˜o entre R1 e
1; o resultado e´ armazenado em R2. A Tabela 3.1 apresenta os paraˆmetros da
configurac¸a˜o inicial dos no´s.
0: I, I, +, 1, x 1: I, I, +, 1, x 2: I, I, +, 1, x 3: I, I, +, 1, x
4: I, I, +, 1, x 5: I, I, +, 1, x 6: I, I, +, 1, x 7: I, I, +, 1, x
Tabela 3.1: Paraˆmetros da configurac¸a˜o inicial dos no´s da FFT para N = 8
Dessa forma, ao final dessa etapa, teremos armazenado em cada R2 de cada
no´, os seguintes valores de X[k]:
X[0] x[0]
X[1] x[4]
X[2] x[2]
X[3] x[6]
X[4] x[1]
X[5] x[5]
X[6] x[3]
X[7] x[7]
Nesse momento, a execuc¸a˜o e´ interrompida para que os paraˆmetros da segunda
reconfigurac¸a˜o sejam carregados de acordo com a Tabela 3.2. De acordo com esta
tabela, cada no´ recebera´ como entrada o valor armazenado no registrador R2
da etapa anterior. Assim, na primeira reconfigurac¸a˜o, sa˜o apresentados dados
externos para os registradores de entrada P1 e P2. Nas reconfigurac¸o˜es subse-
quentes, as portas de entrada sa˜o carregadas com os valores armazenados em R2
na reconfigurac¸a˜o anterior. No caso espec´ıfico sob estudo, as ordens, operac¸o˜es
e constantes de cada reconfigurac¸a˜o sa˜o apresentadas nas Tabelas 3.1, 3.2, 3.3 e
3.4. As constantes carregadas em C1 sa˜o geradas a partir das ra´ızes complexas.
Tendo como entrada o vetor x[j] com j = 1 . . . N − 1, temos como sa´ıda
no domı´nio de frequeˆncias o vetor X[k], com k = 1 . . . N − 1, apresentado na
Tabela 3.5.
27
0: 0, 1, +, 1, x 1: 0, 1, -, 1, x 2: 2, 3, +, 1, x 3: 2, 3, -, i, x
4: 4, 5, +, 1, x 5: 4, 5, -, 1, x 6: 6, 7, +, 1, x 7: 6, 7, -, i, x
Tabela 3.2: Paraˆmetros da segunda reconfigurac¸a˜o dos No´s da FFT para N = 8
0: 0, 2, +, 1, x 1: 1, 3, +, 1, x 2: 0, 2, -, 1, x 3: 1, 3, -, 1, x
4: 4, 6, +, 1, x 5: 5, 7, +, 1+i√
2
, x 6: 4, 6, -, i, x 7: 5, 7, -, −1+i√
2
, x
Tabela 3.3: Paraˆmetros da terceira reconfigurac¸a˜o dos No´s da FFT para N = 8
0: 0, 4, +, 1, x 1: 1, 5, +, 1, x 2: 2, 6, +, 1, x 3: 3, 7, +, 1, x
4: 0, 4, -, 1, x 5: 1, 5, -, 1, x 6: 2, 6, -, 1, x 7: 3, 7, -, 1, x
Tabela 3.4: Paraˆmetros da quarta reconfigurac¸a˜o dos No´s da FFT para N = 8
X[0] (x[0] + x[4]) + (x[2] + x[6]) + (x[1] + x[5]) + (x[3] + x[7])
X[1] (x[0]− x[4]) + (x[2]− x[6])i+ ((x[1]− x[5]) + (x[3]− x[7])i)1+i√
2
X[2] (x[0] + x[4])− (x[2] + x[6]) + ((x[1] + x[5])− (x[3] + x[7]))i
X[3] (x[0]− x[4])− (x[2]− x[6])i+ ((x[1]− x[5])− (x[3]− x[7])i)−1+i√
2
X[4] (x[0] + x[4]) + (x[2] + x[6])− (x[1] + x[5]) + (x[3] + x[7])
X[5] (x[0]− x[4]) + (x[2]− x[6])i− ((x[1]− x[5]) + (x[3]− x[7])i)1+i√
2
X[6] (x[0] + x[4])− (x[2] + x[6])− ((x[1] + x[5])− (x[3] + x[7]))i
X[7] (x[0]− x[4])− (x[2]− x[6])i− ((x[1]− x[5])− (x[3] + x[7])i)−1+i√
2
Tabela 3.5: Sa´ıda da FFT para N = 8
Como estamos tratando nu´meros complexos, a parte real de cada entrada,
corresponde a` parte real do domı´nio de tempo e a parte real de cada valor de sa´ıda
corresponde a` parte real do domı´nio de frequeˆncias. Da mesma forma, a parte
imagina´ria de cada entrada corresponde a` parte imagina´ria do domı´nio de tempo e
a parte imagina´ria dos valores de sa´ıda corresponde a` parte imagina´ria do domı´nio
de frequeˆncias. Quando usamos apenas nu´meros reais, a parte imagina´ria do vetor
de entrada e´ nulo. O mesmo na˜o ocorre com a parte imagina´ria do domı´nio de
frequeˆncias, ja´ que este vetor corresponde a`s ondas seno que pertencem ao sinal
de entrada. Nesse caso de nu´mero reais de entrada, levamos em considerac¸a˜o
apenas os N
2
+ 1 valores do domı´nio de frequeˆncia.
3.3.2 Exemplo
Nesta sec¸a˜o, apresentaremos a aplicac¸a˜o do me´todo para analisar o domı´nio
de tempo x[] escolhido de forma aleato´ria, contido na Tabela 3.6, ou seja, calcu-
laremos X[] usando as reconfigurac¸o˜es do FPGA.
No primeiro instante, e´ necessa´rio fazer a permutac¸a˜o por reversa˜o de bits
para que os registradores Ar1 e Ar2 possam selecionar a entrada externa na
ordem correta, apo´s a decomposic¸a˜o do domı´nio de tempo x[]. Apresentamos a
reversa˜o de bits dos ı´ndices das amostras de entrada de 0 a 7, na Tabela 3.7.
28
Domı´nio de Tempo
x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7]
Amplitude (3, 0) (7, 0) (9, 0) (10, 0) (8, 0) (4, 0) (2, 0) (1, 0)
Tabela 3.6: Valores do domı´nio de tempo usado no exemplo de FFT.
I´ndice de Entrada Bina´rio Reversa˜o I´ndice de Sa´ıda
x[0] 000 000 x[0]
x[1] 001 100 x[4]
x[2] 010 010 x[2]
x[3] 011 110 x[6]
x[4] 100 001 x[1]
x[5] 101 101 x[5]
x[6] 110 011 x[3]
x[7] 111 111 x[7]
Tabela 3.7: Reversa˜o dos bits no exemplo da FFT.
Dessa forma, temos a nova sequeˆncia das nossas amostras discretas e apo´s a
primeira reconfigurac¸a˜o, temos armazenado em cada registrador R2 de cada no´
X[j] para j = 0 · · · 7 os valores apresentados na Tabela 3.8.
X[0] = (X[0] + 0) · 1 X[1] = (X[4] + 0) · 1
X[0] = ((3, 0) + (0, 0)) · (1, 0) X[1] = ((8, 0) + (0, 0)) · (1, 0)
X[0] = (3, 0) X[1] = (8, 0)
X[2] = (X[2] + 0) · 1 X[3] = (X[6] + 0) · 1
X[2] = ((9, 0) + (0, 0)) · (1, 0) X[3] = ((2, 0) + (0, 0)) · (1, 0)
X[2] = (9, 0) X[3] = (2, 0)
X[4] = (X[1] + 0) · 1 X[5] = (X[5] + 0) · 1
X[4] = ((7, 0) + (0, 0)) · (1, 0) X[5] = ((4, 0) + (0, 0)) · (1, 0)
X[4] = (7, 0) X[5] = (4, 0)
X[6] = (X[3] + 0) · 1 X[7] = (X[7] + 0) · 1
X[6] = ((10, 0) + (0, 0)) · (1, 0) X[7] = ((1, 0) + (0, 0)) · (1, 0)
X[6] = (10, 0) X[7] = (1, 0)
Tabela 3.8: Valores da FFT apo´s a primeira reconfigurac¸a˜o
Como pode ser observado, e´ preciso trabalhar com nu´meros complexos, apesar
do exemplo possuir apenas a parte real na˜o nula. Apo´s a segunda reconfigurac¸a˜o,
seguindo corretamente os paraˆmetros, obtemos os valores dados na Tabela 3.9.
29
X[0] = (X[0] +X[1]) · 1 X[1] = (X[0]−X[1]) · 1
X[0] = ((3, 0) + (8, 0)) · (1, 0) X[1] = ((3, 0)− (8, 0)) · (1, 0)
X[0] = (11, 0) X[1] = (−5, 0)
X[2] = (X[2] +X[3]) · 1 X[3] = (X[2]−X[3]) · i
X[2] = ((9, 0) + (2, 0)) · (1, 0) X[3] = ((9, 0)− (2, 0)) · (0, 1)
X[2] = (11, 0) X[3] = (0, 7)
X[4] = (X[4] +X[5]) · 1 X[5] = (X[4]−X[5]) · 1
X[4] = ((7, 0) + (4, 0)) · (1, 0) X[5] = ((7, 0)− (4, 0)) · (1, 0)
X[4] = (11, 0) X[5] = (3, 0)
X[6] = (X[6] +X[7]) · 1 X[7] = (X[6]−X[7]) · i
X[6] = ((10, 0) + (1, 0)) · (1, 0) X[7] = ((10, 0)− (1, 0)) · (0, 1)
X[6] = (11, 0) X[7] = (0, 9)
Tabela 3.9: Valores da FFT apo´s a segunda reconfigurac¸a˜o
X[0] = (X[0] +X[2]) · 1 X[1] = (X[1] +X[3]) · 1
X[0] = ((11, 0) + (11, 0)) · (1, 0) X[1] = ((−5, 0) + (0, 7)) · (1, 0)
X[0] = (22, 0) X[1] = (−5, 7)
X[2] = (X[0]−X[2]) · 1 X[3] = (X[1]−X[3]) · 1
X[2] = ((11, 0)− (11, 0)) · (1, 0) X[3] = ((−5, 0)− (0, 7)) · (0, 1)
X[2] = (0, 0) X[3] = (−5,−7)
X[4] = (X[4] +X[6]) · 1 X[5] = (X[5] +X[7]) · 1+i√
2
X[4] = ((11, 0) + (11, 0)) · (1, 0) X[5] = ((3, 0) + (0, 9)) · ( 1√
2
, 1√
2
)
X[4] = (22, 0) X[5] = (−3 · √2, 6 · √2)
X[6] = (X[4]−X[6]) · i X[7] = (X[5]−X[7]) · −1+i√
2
X[6] = ((11, 0)− (11, 0)) · (0, 1) X[7] = ((3, 0)− (0, 9)) · (−1√
2
, 1√
2
)
X[6] = (0, 0) X[7] = (3 · √2, 6 · √2)
Tabela 3.10: Valores da FFT apo´s a terceira reconfigurac¸a˜o
Apo´s a terceira reconfigurac¸a˜o, temos os seguintes resultados apresentados na
Tabela 3.10.
E finalmente, apo´s a quarta reconfigurac¸a˜o, chegamos ao resultado final de
nossa Transformada Ra´pida de Fourier, apresentado na Tabela 3.11.
Apo´s as quatro reconfigurac¸o˜es, obte´m-se o resultado da transformada dese-
jada. Como o algoritmo foi desenvolvido para ser aplicado em um dispositivo re-
configura´vel, houve uma certa complexidade nos ca´lculos feitos a` ma˜o. E´ poss´ıvel
perceber, pore´m, que esse algoritmo, aplicado em um dispositivo reconfigura´vel
conforme foi desenvolvido, e´ um eficiente me´todo para se calcular a Transformada
30
X[0] = (X[0] +X[4]) · 1 X[1] = (X[1] +X[5]) · 1
X[0] = ((22, 0) + (22, 0)) · (1, 0) X[1] = ((−5, 7) + (−3 · √2, 6 · √2)) · (1, 0)
X[0] = (44, 0) X[1] = (−5− 3 · √2, 7 + 6 · √2)
X[2] = (X[2] +X[6]) · 1 X[3] = (X[3] +X[7]) · 1
X[2] = ((0, 0) + (0, 0)) · (1, 0) X[3] = ((−5,−7) + (3 · √2, 6 · √2)) · (1, 0)
X[2] = (0, 0) X[3] = (−5 + 3 · √2,−7 + 6 · √2)
X[4] = (X[0]−X[4]) · 1 X[5] = (X[1]−X[5]) · 1
X[4] = ((22, 0)− (22, 0)) · (1, 0) X[5] = ((−5, 7)− (−3 · √2, 6 · √2)) · (1, 0)
X[4] = (0, 0) X[5] = (−5 + 3 · √2, 7− 6 · √2)
X[6] = (X[2]−X[6]) · 1 X[7] = (X[3]−X[7]) · 1
X[6] = ((0, 0)− (0, 0)) · (1, 0) X[7] = ((−5,−7)− (3 · √2, 6 · √2)) · (1, 0)
X[6] = (0, 0) X[7] = (−5− 3 · √2,−7− 6 · √2)
Tabela 3.11: Valores da FFT apo´s a quarta reconfigurac¸a˜o
de Fourier de um sinal discreto, por usar o me´todo da Transformada Ra´pida de
Fourier e tambe´m por haver a reutilizac¸a˜o de varia´veis armazenadas em registra-
dores.
31
Cap´ıtulo 4
Lo´gica Temporal Proposicional
A lo´gica temporal linear proposicional (PTL, do ingleˆs Propositional Temporal
Logic), que apresentaremos neste cap´ıtulo, tem por finalidade expressar fatos,
levando em considerac¸a˜o o tempo em que estes fatos ocorrem.
4.1 Sintaxe
A sintaxe de uma linguagem formal determina as regras de formac¸a˜o de sen-
tenc¸as de tal linguagem. No caso da linguagem da lo´gica temporal proposicio-
nal, ale´m dos elementos da linguagem cla´ssica proposicional (s´ımbolos proposi-
cionais, constantes, negac¸a˜o, conjunc¸a˜o, disjunc¸a˜o, implicac¸a˜o e bi-implicac¸a˜o),
temos tambe´m um conjunto de novos operadores para expressar as relac¸o˜es no
tempo. Para a apresentac¸a˜o da linguagem, primeiramente definiremos o conjunto
de s´ımbolos que podem ser empregados na construc¸a˜o de sentenc¸as.
Definic¸a˜o 1 A linguagem da PTL e´ composta por um conjunto enumera´vel de
s´ımbolos:
• um conjunto enumera´vel, P = {p, q, . . . , p0, q0, . . . , p1, q1, . . .}, de s´ımbolos
proposicionais;
• conectivos: ¬ (negac¸a˜o), ∧ (conjunc¸a˜o), ∨ (disjunc¸a˜o), → (implicac¸a˜o) e
↔ (bi-implicac¸a˜o);
• conectivos nula´rios (ou constantes): true e false;
• operadores modais:  (alguma vez no futuro), (sempre no futuro), h
(no pro´ximo momento no futuro), U (ate´ que), W (a na˜o ser que).
Utilizando os s´ımbolos acima definidos, podemos expressar fatos mais com-
plexos do que aqueles expressos pela Linguagem Proposicional. Por exemplo, se
quise´ssemos que expressar o fato dado pela orac¸a˜o:
“Joa˜o toca viola˜o, ate´ que arrebente a corda”
32
na logica proposicional, as informac¸o˜es sobre a sequeˆncia em que estes fatos ocor-
rem ficaria impl´ıcita na fo´rmula lo´gica. No entanto, podemos utilizar a linguagem
proposicional cla´ssica para representar os fatos. Seguindo o exemplo, poder´ıamos
representar por p o fato de que Joa˜o toca viola˜o; e por q o fato de arrebentar
a corda. Com o aux´ılio dos operadores modais da linguagem temporal, o fato
expresso no exemplo acima poderia ser escrito como:
pU q.
A definic¸a˜o abaixo nos diz exatamente quais sa˜o as sentenc¸as que podemos escre-
ver na linguagem lo´gica temporal:
Definic¸a˜o 2 Uma fo´rmula na PTL e bem-formada (FBFPTL) se as seguintes
condic¸o˜es sa˜o satisfeitas:
• os conectivos nula´rios pertencem a FBFPTL;
• p ∈ P, enta˜o p ∈ FBFPTL;
• se φ e ψ pertencem a FBFPTL, enta˜o ¬φ, (φ ∧ ψ), (φ ∨ ψ), (φ → ψ), (φ ↔
ψ),φ, φ, hφ, φW ψ, φU ψ pertencem a` FBFPTL.
Observe que na definic¸a˜o acima, “φ” e “ψ” sa˜o utilizados como s´ımbolos me-
talingu´ısticos, denotando quaisquer fo´rmulas da linguagem. No´s poder´ıamos res-
tringir o nu´mero de conectivos, usando somente os operadores ¬, ∧, h, U ,
utilizando as seguintes abreviac¸o˜es: φ = trueU ψ, φ = φU false e φW ψ =
(φW ψ) ∨ φ.
4.2 Semaˆntica
Um modelo de PTL e´ representado por uma sequeˆncia de estados que chama-
mos de mundos :
σ = S1, S2, S3, . . .
Cada estado (ou mundo) e´ caracterizado por um conjunto de literais, corres-
pondendo, portanto, a uma valorac¸a˜o proposicional. Por exemplo, seja σ o mo-
delo apresentado na Figura 4.1. O modelo σ mostra treˆs primeiros mundos, isto
e´, treˆs primeiros instantes distintos que sa˜o representados pela sequeˆncia de esta-
dos σ = S1, S2, S3, . . . Temos uma func¸a˜o que atribui valores booleanos, {V, F},
aos s´ımbolos proposicionais dentro desses mundos; essa func¸a˜o e´ pi(mundo), onde
mundo deve ser substitu´ıdo pelo ro´tulo do mundo. Caracterizamos, formalmente,
os mundos do modelo acima atrave´s de suas valorac¸o˜es:
pi(S1)(p) = V, pi(S1)(q) = V
pi(S2)(p) = V, pi(S2)(q) = F
pi(S3)(p) = V, pi(S3)(q) = F
pi(S3)(r) = V
33
&%
'$
&%
'$
&%
'$
- - -p q p ¬q p ¬q r . . .
Figura 4.1: Uma sequeˆncia de estados temporais
Segundo a atribuic¸a˜o de valores de verdade dada pela func¸a˜o pi em σ temos que
p e´ verdadeiro em todos os mundos e q e´ satisfeito apenas em S1. Outra forma
de representar a valorac¸a˜o de fo´rmulas proposicionais nos mundos e´ atraves da
noc¸a˜o de satisfac¸a˜o, denotada por “|=”. Considerando o exemplo, escrever´ıamos
(σ, 2) |= p para dizer que o estado de ı´ndice 2 satisfaz p. Observe que a relac¸a˜o
de satisfatibilidade e´ entre um par ordenado, contendo o modelo e o ı´ndice do
estado sobre o qual estamos falando, e uma fo´rmula. Ao escrevermos σ |= φ, onde
φ ∈ FBFPTL, queremos dizer que φ e´ satisfeita pelo estado inicial do modelo σ.
A notac¸a˜o |= φ, onde φ ∈ FBFPTL, diz que φ e´ satisfeita pelo estado inicial de
todos os modelos, ou seja, que φ e´ va´lida.
A caracterizac¸a˜o formal da semaˆntica e´ dada a seguir.
Definic¸a˜o 3 Seja φ e ψ pertencentes a` FBFPTL, σ um modelo, pi uma func¸a˜o
de valoraca˜o e i ∈ N um ı´ndice pertencente ao modelo.
• (σ, i) |= true;
• (σ, i) 6|= false;
• (σ, i) |= p se, e somente se, pi(Si)(p) = V, onde p ∈ P;
• (σ, i) |= ¬φ se, e somente se, (σ, i) 6|= φ;
• (σ, i) |= (φ ∧ ψ) se, e somente se, (σ, i) |= φ e (σ, i) |= ψ;
• (σ, i) |= (φ ∨ ψ) se, e somente se, (σ, i) |= φ ou (σ, i) |= ψ;
• (σ, i) |= (φ→ ψ) se, e somente se, (σ, i) |= ¬φ ou (σ, i) |= ψ;
• (σ, i) |= (φ↔ ψ) se, e somente se, (σ, i) |= (φ→ ψ) e (σ, i) |= (ψ → φ);
• (σ, i) |= hφ se, e somente se, (σ, i+ 1) |= φ;
• (σ, i) |= φ se, e somente se, existe um k, k ∈ N, k ≥ i enta˜o (σ, k) |= φ;
• (σ, i) |= φ se, e somente se, para todo k, k ∈ N, k ≥ i enta˜o (σ, k) |= φ;
• (σ, i) |= φU ψ se, e somente se, existe um k, k ∈ N, k ≥ i enta˜o (σ, k) |= ψ
e para todo j, j ∈ N, se i ≤ j < k, enta˜o (σ, j) |= φ;
• (σ, i) |= φW ψ se, e somente se, ou (σ, i) |= φU ψ ou (σ, i) |= φ;
34
4.3 Exemplo de Especificac¸a˜o
Como apresentado, a lo´gica temporal linear proposicional pode expressar fatos
complexos, levando em considerac¸a˜o situac¸o˜es que envolvem a variac¸a˜o de tempo.
Um caso ilustrativo do emprego da PTL e´ a especificac¸a˜o do funcionamento de
um elevador, pois seu funcionamento depende dos eventos ao longo do tempo,
como por exemplo, as instruc¸o˜es que recebe dos usua´rios. Nesta sec¸a˜o, iremos
apresentar tal especificac¸a˜o levando em considerac¸a˜o um elevador em um pre´dio
de dois andares. O problema a ser caracterizado com o aux´ılio da linguagem
lo´gica e´ dado a seguir:
O pre´dio possui dois andares e um te´rreo. Todos os pavimentos pos-
suem um bota˜o de chamada e uma porta de entrada.
Dentro do elevador existem treˆs boto˜es de chamada de andar, um
bota˜o que serve para abrir a porta e outro para fechar. Existe, na
porta do elevador, um sensor que detecta se existe algo obstruindo o
fechamento da porta.
O elevador se movimenta para cima e para baixo de acordo com o
comando recebido. Se o elevador esta´ subindo, ele atende a todas
as chamadas naquela direc¸a˜o, na ordem em que o elevador alcanc¸a o
pavimento. O mesmo acontece quando esta´ descendo.
Quando o elevador para em um pavimento, a porta e´ aberta. Caso
nada esteja obstruindo a porta do elevador, ela se fechara´ apo´s um
determinado tempo, ou se o bota˜o de fechamento de porta for pressi-
onado. Caso algo esteja obstruindo a porta, ela permanecera´ aberta.
Se um bota˜o de chamada for pressionado para o mesmo andar que o
elevador se encontra, a porta e´ aberta. Se o elevador estiver parado,
e na˜o houver nenhuma chamada de andar, ou solicitac¸a˜o de abrir a
porta, ele permanecera´ parado com a porta fechada. Em movimento,
o elevador na˜o abrira´ a porta, independente do comando recebido.
Para esquematizar o funcionamento desse elevador, foram utilizadas algumas
varia´veis proposicionais, descritas a seguir. Dessas varia´veis, existem cinco repre-
sentam os boto˜es:
b0 (Bota˜o 0) - Bota˜o existente no te´rreo e dentro do elevador. Ele solicita ao
elevador para se movimentar para o te´rreo, caso esteja em algum outro
pavimento, ou para que abra a porta, caso esteja parado no te´rreo. E´
acionado pelo usua´rio e e´ desligado ao abrir a porta no andar desejado.
b1 (Bota˜o 1) - Bota˜o existente no primeiro andar e dentro do elevador. Ele
solicita ao elevador para se movimentar para o primeiro andar, caso esteja
em algum outro pavimento, ou para que abra a porta, caso esteja parado
no primeiro andar. E´ acionado pelo usua´rio e e´ desligado ao abrir a porta
no andar desejado.
35
b2 (Bota˜o 2) - Bota˜o existente no segundo andar e dentro do elevador. Ele
solicita ao elevador para se movimentar para o segundo andar, caso esteja
em algum outro pavimento, ou para que abra a porta, caso esteja parado
no segundo andar. E´ acionado pelo usua´rio e e´ desligado ao abrir a porta
no andar desejado.
a (Bota˜o abre porta) Bota˜o existente dentro do elevador. Ele executa a abertura
da porta caso o elevador esteja parado com a porta fechada.
f (Bota˜o fecha porta) - Bota˜o existente dentro do elevador. Ele executa o
fechamento da porta caso esta esteja aberta e nada a esteja obstruindo.
Cinco varia´veis representam a localizac¸a˜o do elevador:
pav0 (Te´rreo) - Indica que o elevador esta´ no te´rreo.
pav1 (Primeiro andar) - Indica que o elevador esta´ no primeiro andar
pav2 (Segundo andar) - Indica que o elevador esta´ no segundo andar
mov1 (Entre o te´rreo e o primeiro andar) - Indica que o elevador esta´ se movi-
mentando entre o te´rreo e o primeiro andar.
mov2 (Entre o primeiro e o segundo andar) - Indica que o elevador esta´ se
movimentando entre o primeiro andar e o segundo andar.
Treˆs varia´veis referem-se ao status do elevador:
p (Porta) - p indica que a porta do elevador esta´ fechada; portanto, ¬p indica que
a porta do elevador esta´ aberta o que, conforme a descric¸a˜o do problema,
impede que o elevador entre em movimento.
s (Direc¸a˜o) - s indica que o elevador esta´ subindo; ¬s indica que o elevador esta´
descendo. E´ uma varia´vel que auxilia o controle do elevador a atender todas
as chamadas, de acordo com a direc¸a˜o em que esta´ se movimentando.
m (Movimento) m indica que o elevador entrou em movimento e na˜o abriu
a porta desde enta˜o. A negac¸a˜o, ¬m, indica que o elevador atendeu a
algum andar e pode se movimentar de novo quando a porta estiver fechada.
Essa varia´vel auxilia na especificac¸a˜o do controle da abertura da porta do
elevador.
Existe ainda uma varia´vel que representa o sinal de um sensor de obstruc¸a˜o:
ob (Obstruc¸a˜o) - ob significa que algo esta´ obstruindo a porta e que ela na˜o
podera´ ser fechada em hipo´tese alguma. ¬ob indica que a porta pode ser
fechada.
Por fim, existe uma varia´vel que armazena o sinal de um temporizador:
36
t (Tempo) - t significa que o tempo de porta aberta se esgotou e solicita que ela
seja fechada. ¬t significa que a porta deve ficar aberta para que os usua´rios
possam entrar e sair do elevador.
A partir da descric¸a˜o do funcionamento do elevador, em acordo com o sig-
nificado ja´ designado para cada varia´vel, podemos apresentar uma especificac¸a˜o
na linguagem da lo´gica temporal proposicional. Para cada estado em que o ele-
vador se encontra, existem comandos que fazem com que o elevador tome ac¸o˜es
diferentes.
Quando o elevador esta´ parado no te´rreo, com a porta fechada, as ac¸o˜es do
elevador podem ser expressas pelas sentenc¸as abaixo:
• (pav0 ∧ p ∧ (m ∨ a ∨ b0)→ h(¬p ∧ ¬b0 ∧ ¬m))
• pav0 ∧ pW b0 ∨ b1 ∨ b2 ∨m ∨ a
• (pav0 ∧ p ∧ (b1 ∨ b2)→ h(mov1 ∧m)
• (pav0 ∧ p→ s)
A sentenc¸a (pav0 ∧ p → s), por exemplo, diz que sempre que o elevador
esteja no te´rreo e a porta e´ fechada, ele ira´ subir. Ja´ as ac¸o˜es do elevador, quando
ele esta´ no te´rreo e com a porta aberta sa˜o expressas pelas seguintes sentenc¸as:
• pav0 ∧ ¬pW ¬ob ∧ (t ∨ f)
• (pav0 ∧ ¬p ∧ (b0 ∨ ob)→ h¬p ∧ ¬b0)
• (pav0 ∧ ¬p ∧ ¬ob ∧ (t ∨ f)→ hp)
O estado em que o elevador possui a maior possibilidades de ac¸o˜es e´ quando
ele esta´ parado no primeiro andar com a porta fechada. Isso acontece devido a`
possibilidade do elevador, desse estado, poder se dirigir ao te´rreo, ou ao segundo
andar. As ac¸o˜es desse estado podem ser expressas atrave´s das sentenc¸as abaixo:
• (pav1 ∧ p ∧ (m ∨ a ∨ b1)→ h(¬p ∧ ¬b1 ∧ ¬m))
• pav1 ∧ pW b0 ∨ b1 ∨ b2 ∨m ∨ a
• (pav1 ∧ p ∧ b0 ∧ ¬b2 ∧ s→ h(mov1 ∧m) ∧ ¬s)
• (pav1 ∧ p ∧ b2 ∧ ¬b0 ∧ ¬s→ h(mov2 ∧m) ∧ s)
• (pav1 ∧ p ∧ b0 ∧ ¬s→ h(mov1 ∧m))
• (pav1 ∧ p ∧ b2 ∧ s→ h(mov2 ∧m))
Os poss´ıveis movimentos do elevador, parado no primeiro andar, com a porta
aberta sa˜o expressos por:
• pav1 ∧ ¬pW ¬ob ∧ (t ∨ f)
37
• (pav1 ∧ ¬p ∧ (b1 ∨ ob)→ h¬p ∧ ¬b1)
• (pav1 ∧ ¬p ∧ ¬ob ∧ (t ∨ f)→ hp)
Ja´ as ac¸o˜es do segundo andar sa˜o bem parecidos com o te´rreo e podem ser
representadas pelas expresso˜es abaixo:
• (pav2 ∧ p ∧ (m ∨ a ∨ b2)→ h(¬p ∧ ¬b2 ∧ ¬m))
• pav2 ∧ pW b0 ∨ b1 ∨ b2 ∨m ∨ a
• (pav2 ∧ p ∧ (b0 ∨ b1)→ h(mov2 ∧m))
• (pav2 ∧ p→ ¬s)
• pav2 ∧ ¬pW ¬ob ∧ (t ∨ f)
• (pav2 ∧ ¬p ∧ (b2 ∨ ob)→ h¬p ∧ ¬b2)
• (pav2 ∧ ¬p ∧ ¬ob ∧ (t ∨ f)→ hp)
Finalmente, as expresso˜es abaixo representam as ac¸o˜es do elevador quando
este se encontra entre dois andares:
• (mov1 ∨mov2 → m)
• (mov1 ∧ b0 ∧ ¬s→ hpav0 ∧ p ∧ s)
• (mov1 ∧ b1 ∧ s→ hpav1 ∧ p)
• (mov1 ∧ b2 ∧ ¬b1 ∧ s→ h(mov2 ∧m))
• (mov2 ∧ b0 ∧ ¬b1 ∧ ¬s→ h(mov1) ∧m)
• (mov2 ∧ b1 ∧ ¬s→ hpav1 ∧ p)
• (mov2 ∧ b2 ∧ s→ hpav2 ∧ p ∧ ¬s)
Sempre que o elevador se encontra entre os dois andares, a varia´vel m se
tornara´ verdadeira. Quando chega a algum andar, a varia´vel m se tornara´ falsa.
As fo´rmulas que especificam a chegada do elevador a algum andar sa˜o:
• (pav0 ∧ p ∧ (m ∨ a ∨ b0)→ h(¬p ∧ ¬b0 ∧ ¬m))
• (pav1 ∧ p ∧ (m ∨ a ∨ b1)→ h(¬p ∧ ¬b1 ∧ ¬m))
• (pav2 ∧ p ∧ (m ∨ a ∨ b2)→ h(¬p ∧ ¬b2 ∧ ¬m))
38
Estas fo´rmulas tambe´m expressam as ac¸o˜es do elevador, caso ele esteja parado
no andar e receba alguma instruc¸a˜o.
Apesar da simplicidade do exemplo apresentado, e´ poss´ıvel verificar a fina-
lidade da linguagem da lo´gica temporal linear proposicional e sua utilidade na
expressa˜o de fatos, levando em considerac¸a˜o o tempo em que eles ocorrem.
O exemplo apresenta um caso espec´ıfico de um elevador de apenas dois anda-
res. Para a representac¸a˜o de um caso geral, para um elevador de N andares, seria
necessa´rio substituir os ı´ndices nume´ricos por uma varia´vel que representaria to-
dos os andares poss´ıveis. Tambe´m seria necessa´rio usar o operador modal U para
expressar todos os poss´ıveis valores para a varia´vel do ı´ndice. O uso desse ope-
rador, na representac¸a˜o de um problema, podera´ ser vista no Cap´ıtulo 5. Nele,
iremos empregar a linguagem lo´gica proposicional para descrever o ca´lculo da
FFT e da sua implementac¸a˜o em um FPGA.
39
Cap´ıtulo 5
Especificac¸a˜o da DFT e do
Algoritmo da FFT em um
Dispositivo Reprograma´vel
Iremos utilizar a lo´gica proposicional temporal para descrever a definic¸a˜o da
Transformada Ra´pida de Fourier e o algoritmo implementado na FPGA, conforme
Sec¸o˜es 2.3.1 e 3.3.1. Para as descric¸o˜es, usaremos as seguintes varia´veis:
x (Varia´vel do Domı´nio de Tempo) - Corresponde ao vetor x[], que conte´m os
valores do sinal de entrada.
X (Varia´vel do Domı´nio de Frequeˆncias) Corresponde ao vetor X[], que arma-
zena as amplitudes do sinal de sa´ıda.
R (Varia´vel Proviso´ria) Corresponde a um vetor que armazena as amplitudes
parciais do sinal de sa´ıda que sera´ armazenado em X[].
m (Momento) - Varia´vel de controle do algoritmo, que indica o que deve ser feito
de acordo com cada momento.
k (´Indice relativo ao Domı´nio de Frequeˆncias) - Valor que indica a varia´vel
de sa´ıda. No algoritmo, e´ uma das responsa´veis por controlar o loop dos
somato´rios.
j (´Indice relativo ao Domı´nio de Tempo) - Valor que indica a varia´vel de entrada.
No algoritmo, e´ uma das responsa´veis por controlar o loop dos somato´rios.
N (Nu´mero de pontos no sinal de entrada) - Varia´vel com o nu´mero de pontos
no sinal de entrada.
Primeiro, sera´ feita a especificac¸a˜o da definic¸a˜o da DFT conforme definida pela
Equac¸a˜o 3.1. Depois, sera´ apresentada a especificac¸a˜o da FFT pela sequeˆncia de
operac¸o˜es e configurac¸o˜es apresentadas na Sec¸a˜o 3.3.
40
5.1 Descric¸a˜o da Definic¸a˜o da DFT
No primeiro momento desse algoritmo, e´ necessa´rio zerar cada valor armaze-
nado no vetor X[]. Esse processo pode ser expresso pelas seguintes proposic¸o˜es:
• m0 → ¬m1 ∧ ¬m2 ∧ (k = 0) ∧ (j = 0)
A fo´rmula acima indica que se a varia´vel m0 e´ verdadeira, enta˜o as varia´veis m1
e m2 sa˜o falsas. Isso porque apenas uma dessas varia´veis pode ser verdadeira em
cada instante. Quando m0 for verdadeira, k = 0 e j = 0. Na lo´gica proposicional,
utilizamos varia´veis lo´gicas para construir as fo´rmulas. Portanto, expresso˜es como
k = 0, k + 1 na˜o deveriam existir. Mas nessa especificac¸a˜o, utilizaremos estes
termos, para facilitar a visualizac¸a˜o e compreensa˜o da especificac¸a˜o.
Seguindo a especificac¸a˜o, temos:
• (m0 → h(m1 ∧ ¬m0))
Essa fo´rmula expressa que quando a varia´vel m0 e´ verdadeira, no pro´ximo
momento ela sera´ falsa e m1 sera´ verdadeira. Assim fica claro que nesse pro´ximo
momento temos k = 0 e j = 0, ja´ que no momento anterior m0 era verdadeira.
• (m1 → ((Xk = 0) ∧ h(k + 1)U k ≥ N))
• (m1 ∧ (k ≥ N)→ h(m2) ∧ h(¬m1) ∧ h(k = 0))
As duas fo´rmulas acima expressam o loop de um somato´rio. Assim, quando
m1 e´ verdadeira, caso k seja menor que N , enta˜o Xk sera´ igual a 0. Caso k seja
maior ou igual a N , no pro´ximo momento m1 sera´ falsa e m2 sera´ verdadeira.
Em seguida, atrave´s de dois somato´rios, e´ especificado o ca´lculo do valor da
DFT para todo k maior ou igual a 0 e menor que N :
• (m2 ∧ (k < N) → ((Xk = Rk) ∧ h(Xk = Rk + x[j] · (cos(2pijkN ) +
i sin(2pijk
N
)) ∧ h h(j + 1)U j ≥ N))
• (m2 ∧ (j ≥ N → ( h(j = 0) ∧ h(k + 1)U k ≥ N))
Na fo´rmula acima, x[j] · (cos(2pijk
N
) + i sin(2pijk
N
) representa a fo´rmula da DFT
pelo me´todo de Correlac¸a˜o. Ao indicar os valores armazenados em X[], a seguinte
proposic¸a˜o encerra a especificac¸a˜o da definic¸a˜o da DFT.
• (m2 ∧ (k ≥ N)→ h(¬m2))
Atrave´s das proposic¸o˜es acima, todos os passos da definic¸a˜o da DFT foram
especificados.
41
5.2 Descric¸a˜o do Algoritmo da Implementac¸a˜o
da FFT
Antes de iniciar as reconfigurac¸o˜es que calculam a DFT pelo me´todo da FFT, e´
necessa´rio um processo para ordenac¸a˜o dos sinais de entrada, conforme explicado
na Subsec¸a˜o 2.3.1. Entretanto, no artigo [3] que estamos estudando, na˜o existe
nenhuma rotina na programac¸a˜o do FPGA, para executar essa ordenac¸a˜o. Como
o FPGA foi programado para executar a DFT para um nu´mero definido de pontos
de entrada, no caso 8, enta˜o os sinais de entrada foram atribu´ıdos aos registra-
dores de entrada, ja´ na ordem correta, sem nenhum processo de ordenac¸a˜o. Na
descric¸a˜o desse algoritmo na Lo´gica Proposicional Temporal, tambe´m foi omitida
uma rotina de ordenac¸a˜o, atribuindo os sinais de entrada a`s varia´veis, na ordem
correta para a aplicac¸a˜o do algoritmo.
Para um algoritmo de ordem N , seria necessa´rio implementar um algoritmo
para reversa˜o de bits. Para que a especificac¸a˜o de um algoritmo de ordem N
fosse feita, ale´m de especificar o algoritmo de reversa˜o de bits, seria necessa´rio
descobrir um padra˜o para os valores armazenados em C1, u´nica constante para a
qual na˜o foi considerada uma caracterizac¸a˜o gene´rica. No artigo [3], os valores da
constante C1 sa˜o atribu´ıdos ao registrador sem ca´lculo algum. Como no artigo
estudado, apresentaremos a especificac¸a˜o do algoritmo com 8 pontos no domı´nio
de tempo:
• m0 → ¬m1 ∧ ¬m2 ∧ ¬m3 ∧ ¬m4 ∧ ¬m5 ∧ (k = N) ∧ (R0 = x0) ∧ (R1 =
x4)∧ (R2 = x2)∧ (R3 = x6)∧ (R4 = x1)∧ (R5 = x5)∧ (R6 = x3)∧ (R7 = x7)
• ((k ≥ N) ∧ ¬m5 → h(k = 0) ∧m5)
Nessa primeira fo´rmula, e´ expresso que quando a varia´vel m0 e´ verdadeira,
todas as outras varia´veis que representam os passos do algoritmo, sa˜o falsas, com
excec¸a˜o de m5. Como m0 representa o primeiro estado do algoritmo, tambe´m e´
expresso que o vetor R[] tem armazenado os pontos do sinal de entrada.
A fo´rmula seguinte especifica o que acontece sempre que m5 e´ verdadeira e k
e´ menor que N .
• ((m5 → (Xk = Rk) ∧ h(k + 1))U (k ≥ N))
Essa fo´rmula expressa que, para k maior ou igual a 0 e menor que N , os valores
de Rk esta˜o armazenado em Xk. Isso acontece no in´ıcio do algoritmo e apo´s os
ca´lculos de cada reconfigurac¸a˜o, quando a varia´vel m5 e´ verdadeira.
Apo´s caracterizar que os valores de Xk sa˜o iguais aos de Rk, as seguintes
fo´rmulas expressam qual sera´ o pro´ximo estado.
• (m0 ∧m5 ∧ (k ≥ N)→ h(m1) ∧ h(¬m0) ∧ h(¬m5))
• (m1 ∧m5 ∧ (k ≥ N)→ h(m2) ∧ h(¬m1) ∧ h(¬m5))
• (m2 ∧m5 ∧ (k ≥ N)→ h(m3) ∧ h(¬m2) ∧ h(¬m5))
• (m3 ∧m5 ∧ (k ≥ N)→ h(¬m3) ∧ h(¬m5))
42
As treˆs primeiras fo´rmulas sa˜o semelhantes. Elas expressam que se m5 e´
verdadeira e mx e´ verdadeira, para x entre 0 e 3, no pro´ximo momento mx sera´
falsa e a varia´vel mx+1 sera´ verdadeira. Isso quer dizer que o algoritmo saira´ de
uma configurac¸a˜o, e entrara´ em outra.
A quarta fo´rmula e´ (m3 ∧ m5 ∧ (k ≥ N) → h(¬m3) ∧ h(¬m5)). Ela
expressa que apo´s a quarta reconfigurac¸a˜o, nada mais acontece. Assim, quando
(m3 ∧m5 ∧ (k ≥ N) e´ verdadeira, no pro´ximo momento todas as varia´veis mx,
para x igual a 1, 2, 3 ou 5 sera˜o falsas.
As seguintes fo´rmulas mostram o que acontece em cada reconfigurac¸a˜o:
• ((m1∧¬m5∧¬(k mod 4 = 3)→ (Rk = X k
2
·2 + (−1)k ·X( k
2
·2)+1)∧ h(k+
1))U k ≥ N)
• ((m1∧¬m5∧(k mod 4 = 3)→ (Rk = X k
2
·2 +(−1)k ·X( k
2
·2)+1) · i)∧ h(k+
1))U k ≥ N)
Se m1 e´ verdadeira e m5 e´ falsa, o que significa que estas fo´rmulas expressam a
segunda reconfigurac¸a˜o. A expressa˜o X k
2
·2 +(−1)k ·X( k
2
·2)+1 mostra qual operac¸a˜o
deve ser feita. Caso k mod 4 = 3 enta˜o o resultado da primeira operac¸a˜o deve ser
multiplicado por i. Caso contra´rio, a expressa˜o e´ multiplicada por 1, que resulta
na pro´pria expressa˜o.
Apo´s especificar as operac¸o˜es da segunda reconfigurac¸a˜o, as fo´rmulas abaixo
expressam o que acontece na terceira reconfigurac¸a˜o.
• ((m2 ∧¬m5 ∧ (k < 5)→ (Rk = (−1) k2 ·Xk +X
(−1) k2 ·((−1) k2 ·k+2))∧ h(k+
1))U k ≥ N)
• ((m2 ∧ ¬m5 ∧ (k = 5) → (Rk = (−1) k2 ·Xk + X
(−1) k2 ·((−1) k2 ·k+2)) ·
1+i√
2
) ∧h(k + 1))U k ≥ N)
• ((m2 ∧ ¬m5 ∧ (k = 6) → (Rk = (−1) k2 · Xk + X
(−1) k2 ·((−1) k2 ·k+2)) · i) ∧h(k + 1))U k ≥ N)
• ((m2 ∧ ¬m5 ∧ (k = 7)→ (Rk = (−1) k2 ·Xk +X
(−1) k2 ·((−1) k2 ·k+2)) ·
−1+i√
2
) ∧h(k + 1))U k ≥ N)
De forma semelhante a` segunda reconfigurac¸a˜o, quando m2 e´ verdadeira e m5 e´
falsa, o resultado das operac¸o˜es para k < 5 e´ igual a (−1) k2 ·Xk+X
(−1) k2 ·((−1) k2 ·k+2).
No caso de k = 5, k = 6 ou k = 7, o resultado da expressa˜o anterior deve ser
multiplicada por 1+i√
2
, i e −1+i√
2
, respectivamente.
A fo´rmula seguinte expressa o comportamento do algoritmo na quarta recon-
figurac¸a˜o:
• ((m3∧¬m5 → (Rk = Xk mod 4+(−1) k4 ·X(k mod 4)+4)∧ h(k+1))U k ≥ N)
Assim, sendo m3 verdadeira e m5 falsa, o resultado da FFT e´ igual a Rk =
Xk mod 4 + (−1) k4 ·X(k mod 4)+4.
A cada reconfigurac¸a˜o, quando m5 e´ falsa e k e´ maior ou igual a N , temos
esta u´ltima fo´rmula:
43
• ((¬m5) ∧ (k ≥ N)→ h(m5) ∧ h(k = 0))
que diz que quando m5 e´ falsa e k e´ maior ou igual a N , no pro´ximo momento,
m5 e´ verdadeira.
Atrave´s das proposic¸o˜es acima, todos os passos da implementac¸a˜o da FFT
foram descritos.
44
Cap´ıtulo 6
Conclusa˜o
O trabalho teve como objetivo especificar na linguagem da Lo´gica Temporal
Proposicional, a definic¸a˜o da Transformada Discreta de Fourier e a aplicac¸a˜o da
mesma pelo me´todo da Transformada Ra´pida de Fourier, atrave´s de um algoritmo
para um dispositivo reprograma´vel.
Assim foi feita uma revisa˜o teo´rica para que fosse poss´ıvel a compreensa˜o de
todos os passos ate´ a especificac¸a˜o da definic¸a˜o e do algoritmo implementado.
Foi apresentado detalhadamente no Cap´ıtulo 2, o que e´ a Transformada de
Fourier, para que serve e quais sa˜o os tipos existentes. Assim justificamos o
porqueˆ do uso da Transformada Discreta de Fourier na computac¸a˜o. Apresenta-
mos alguns exemplos de te´cnicas de se calcular a DFT.
Tambe´m foi explicado no Cap´ıtulo 3 o que e´ um dispositivo reprograma´vel e
como funciona. O assunto na˜o foi ta˜o aprofundado, pois na˜o era necessa´rio para
o desenvolvimento do projeto. Dentro da´ a´rea de dispositivos reprograma´veis, foi
abordado o algoritmo que seria especificado no trabalho.
No Cap´ıtulo 4, foi apresentada a linguagem da Lo´gica Temporal Proposicional,
utilizada para a descric¸a˜o da DFT. Para ser mais bem compreendida, foram
apresentados e explicados todos os s´ımbolos da linguagem, e explicado a sintaxe
e a semaˆntica da linguagem. A partir da apresentac¸a˜o da semaˆntica e sintaxe
da linguagem, tornou-se via´vel a especificac¸a˜o de um sistema usando a Lo´gica
Temporal Proposicional.
Finalmente, no Cap´ıtulo 5, foi feita a especificac¸a˜o da definic¸a˜o da DFT,
apresentada pela Fo´rmula 3.1 e do algoritmo implementado, apresentado na
Subsec¸a˜o 3.3.1, ambas na linguagem da Lo´gica Proposicional Temporal.
Nesse trabalho, foi feita uma boa revisa˜o teo´rica, com alguns exemplos nos
to´picos estudados, possibilitando a compreensa˜o do assunto abordado. Foi gasto
um bom tempo na compreensa˜o da DFT, criando um grande interesse em traba-
lhos na a´rea de processamento de sinais. O conhecimento adquirido na especi-
ficac¸a˜o nos mostrou a importaˆncia da Lo´gica Temporal Proposicional na especi-
ficac¸a˜o formal de linguagem de hardware e que a linguagem pode ser usada para
testar o algoritmo implementado, estudado em [3]. Assim, num trabalho futuro,
a verificac¸a˜o do algoritmo implementado em [3] podera´ ser feita atrave´s dessa
linguagem.
45
Refereˆncias
[1] Martin Abadi. Temporal-Logic Theorem Proving. PhD thesis, Stanford, CA,
March 1987.
[2] William Aspray. John von Neumann and the Origins of Modern Computing.
The MIT Press, December 7, 1990.
[3] Mauricio Ayala-Rinco´n, Rodrigo B. Nogueira, Carlos H. Llanos, Ricardo P.
Jacobi, and Reiner W. Hartestein. Modeling a reconfigurable system for
computing the fft in place via rewriting-logic. In IEEE CS Press Proc. 16th
Symposium on Integrated Circuits and System Design - SBCCI 03, pages
205–210, Sep 8-11, 2003.
[4] James W. Cooley and Jonh W. Tukey. An algorithm for machine calculation
of complex fourier series,. Mathematics Computation, 19:297–301, 1965.
[5] Altera Corporation. Cyclone II Device Family Data Sheet. Altera Corpora-
tion, volume 1 edition, Novembro 2004.
[6] Altera Corporation. Getting Started with Altera’s DE2 Board. Altera Cor-
poration, 2005.
[7] Altera Corporation. DE2 Development and Education Board User Manual.
Altera Corporation, version 1.3 edition, 2006.
[8] Carlos A. V. Heredia and Francisco Menegat. Matema´tica - Nu´meros Com-
plexos, Polinoˆmios e Equac¸o˜es Alge´bricas. Renascenc¸a, 5a Edic¸a˜o (1999).
[9] Thomas Kropf and Hans joachim Wunderlich. A common approach to test
generation and hardware verification based on temporal logic. Thomas Kropf,
Hans-Joachim Wunderlich, University of Karlsruhe, Institute of Computer
Design and Fault Tolerance, P.O. Box 6980, 7500 Karlsruhe, Germany, 1991.
[10] Fred Kro¨ger and Stephan Merz. Temporal Logic and State Systems. Springer-
Verlag Berlin and Heidelberg GmbH & Co. K, 2008.
[11] Steven W. Smith. The Scientist & Engineer’s Guide to Digital Signal Pro-
cessing. California Technical Publishing, San Diego, CA, 1st edition (1997).
46
