Faster Suffix Tree Construction with Missing Suffix Links
Richard Cole
Courant Institute, NYU
cole@cs.nyu.edu
Ramesh Hariharan
Indian Institute of Science
ramesh@csa.iisc.ernet.in
ABSTRACT
We onsider su√Üx tree onstrution for situations with miss-
ing su√Üx links. Two examples of suh situations are su√Üx
trees for parameterized strings and su√Üx trees for 2D arrays.
These trees also have the property that the node degrees
may be large. We add a new bak-propagation omponent to
MCreight's algorithm and also give a high probability per-
fet hashing sheme to ope with large degrees. We show
that these two features enable onstrution of su√Üx trees
for general situations with missing su√Üx links in O(n) time,
with high probability. This gives the rst randomized linear
time algorithm for onstruting su√Üx trees for parameter-
ized strings.
1. INTRODUCTION
The Su√Üx Tree of a given string of length n is the ompated
trie of all its su√Üxes. This tree has size O(n) and an be
onstruted in O(n) time [10; 14; 13‚ÑÑ. Su√Üx trees have
several appliations (see [7‚ÑÑ). One of the main appliations
of su√Üx trees is to preproess a text in linear time so as
to answer pattern ourrene queries in time proportional
to the length of the query and independent of the length of
the preproessed text. The preproessing involves building
the su√Üx tree for the text. Next, given a query pattern,
the unique path down the su√Üx tree traed by this pattern
is determined; eah leaf of the tree whih lies further down
from this path orresponds to an ourrene of the pattern.
Parameterized Su√Üx Trees. Baker [1‚ÑÑ generalized the
denition of su√Üx trees to parameterized strings, i.e., strings
having variable haraters or parameters in addition to the
usual xed symbols. The set of parameters and the set of
symbols are disjoint. Two parameterized strings are said to
math eah other if the parameters in one an be onsistently
replaed with the parameters in the other to make the two

This work was supported in part by NSF grants CCR-
9503309 and CCR-9800085.
string idential. Here, onsisteny demands that all our-
renes of a partiular parameter are replaed by the same
parameter and distint parameters are replaed by distint
parameters. Baker [1‚ÑÑ gave a denition of su√Üx trees for
parameterized text strings t so as to failitate answering
pattern ourrene queries in time independent of the text
length jtj.
2D Su√Üx Trees. Gianarlo [6‚ÑÑ generalized su√Üx trees to
two-dimensional texts t in order to answer pattern our-
rene queries (i.e., nd all ourrenes of a given square
array p in the square text t) in time independent of jtj.
Su√Üx Tree Constrution. There are several algorithms
for onstruting the su√Üx tree of a string drawn from a
onstant-sized alphabet set in O(n) time. These inlude the
algorithms by MCreight [10‚ÑÑ, Weiner [14‚ÑÑ and Ukkonen [13‚ÑÑ.
All these algorithms exploit an important property of su√Üx
trees, namely, eah node has an outgoing su√Üx link.
Farah [4‚ÑÑ showed how to onstrut su√Üx trees in O(n) time
even when the alphabet size was not onstant but some poly-
nomial in n. This algorithm diers from the others above in
that it is not sweep-based and seems to be less ritially de-
pendent on the existene of outgoing su√Üx links. However,
it requires renaming pairs of adjaent haraters to get a
string of size half that of the original string. The su√Üx tree
for this smaller string is built reursively; Farah shows how
the su√Üx tree of the original string an be obtained from
the su√Üx tree of this smaller string in O(n) time.
In ontrast to su√Üx trees for strings, su√Üx trees for both
parameterized strings and 2-D arrays lak the su√Üx link
property, i.e., there ould be nodes in the tree without an
outgoing su√Üx link dened. In addition, the node degrees in
these su√Üx trees need not be bounded by a onstant. Due
to these two problems, the best onstrutions known until
reently for su√Üx trees for parameterized strings [1‚ÑÑ and 2-D
arrays [6‚ÑÑ took O(n log n) time, where n is the size of the in-
put string/array. In eah ase, the problem of missing su√Üx
links was handled by using a dynami tree data struture
[12‚ÑÑ; this data struture is used to nd the insertion site
of the next su√Üx in O(log n) time. Further, the problem of
large node degrees was handled by the standard approah of
maintaining a binary searh tree, whih also gave a (log n)
overhead.
Reently, Kim and Park [9‚ÑÑ used the paradigm of Farah [4‚ÑÑ
to give an O(n) time algorithm for 2-D su√Üx tree onstru-
tion (for polynomially bounded alphabet size). However, it
is not lear how to apply this paradigm to the ase of pa-
rameterized strings. In partiular, it is not lear how the
renaming of pairs of adjaent haraters mentioned above
an be aomplished in suh a way that the su√Üx tree of
the given string an be obtained from the su√Üx tree of the
renamed string in O(n) time.
Our Contribution. We present two new tools in this pa-
per.
(i) The rst tool is aimed at takling the problem of miss-
ing su√Üx links. We augment MCreight's algorithm with a
new feature whih opies nodes bakwards (imagine su√Üx
links as going forwards), thus adding additional nodes and
su√Üx links to the su√Üx tree. Using a non-trivial aounting
proedure, we show that this bak-propagation adds only
O(n) extra nodes and aomplishes the onstrution of the
su√Üx tree in O(n) time even with missing su√Üx links. The
bak-propagation is similar to frational asading, as used
in many pointer based data strutures of bounded degree
(when viewed as graphs); the di√Üulty here is that the de-
grees are potentially unbounded, whih appears to neessi-
tate a quite dierent analysis.
(ii) The time analysis in (i) assumes that given a node x
and a harater a, the unique edge from x to a hild of x
starting with the harater a is omputable in O(1) time. To
enable this for high degree nodes x, we give an extension of
the dynami version of the Fredman-Komlos-Szemeredi per-
fet hashing sheme [5‚ÑÑ whih supports insertions of items
from a polynomial sized range in amortized onstant time
and linear spae, with high probability (as ompared to the
previous expeted time result of Dietzfelbinger et al. [2‚ÑÑ).
Searhing for an item requires worst ase onstant time. In
fat, the items being in a polynomial sized range is not nees-
sary for our hashing sheme; it su√Ües if they an be hashed
into a polynomial sized range in linear time.
The above two tools provide a unied framework from whih
randomized O(n) time algorithms for onstruting su√Üx
trees for regular strings, parameterized strings and 2-D ar-
rays are easily derived. These algorithms work with high
probability. This is the rst O(n) time randomized algo-
rithm for parameterized su√Üx tree onstrution; the pre-
vious best algorithm[1‚ÑÑ took O(n log n) deterministi time.
The su√Üx trees we onstrut also have the property that
the unique path in the tree orresponding to a given pat-
tern string p an be found in O(p) time, regardless of the
degrees of the nodes.
2. THE GENERAL SETTING
Before desribing our algorithm, we desribe the general set-
ting for whih our algorithm works. We need the following
denitions.
Compated Trie. A ompated trie is a tree data stru-
ture dened on a olletion of strings. This tree has one leaf
per string in this olletion, and eah internal node has at
least 2 hildren. Therefore, the number of nodes is linear in
the number of strings in the given olletion. Eah edge of
the tree is assoiated with (or labelled with) some substring
of one of the strings in the given olletion. The key prop-
erty is that for every pair of leaves, the string formed by
onatenating the edge labels on the path from the root to
the least ommon anestor of these two leaves is the longest
ommon prex of the strings assoiated with the two leaves.
In this paper, we are interested in ompated tries of ertain
kinds of string olletions.
Quasi-Su√Üx Colletions. An ordered olletion of strings
s
1
; s
2
; : : : ; s
n
is alled a quasi-su√Üx olletion if and only if
the following onditions hold. Let jsj denote the length of
string s.
1. js
1
j = n and js
i
j = js
i 1
j   1. Therefore, js
n
j = 1.
2. No s
i
is a prex of another s
j
.
3. Suppose strings s
i
and s
j
have a ommon prex of
length l > 0. Then s
i+1
and s
j+1
have a ommon
prex of length at least l  1.
We will assume that all the strings are drawn from an al-
phabet of size polynomial in n.
Charater Orales. Note that the total length of the
strings in a quasi-su√Üx olletion of n strings is O(n
2
), while
our aim is to ahieve O(n) time onstrution for the om-
pated trie. Therefore, we annot aord to read the ol-
letions expliitly. Instead, we will assume an orale whih
supplies the ith harater of the jth string of the olletion
on demand, in O(1) time.
Multiple Quasi-Su√Üx Colletions. Consider m distint
quasi-su√Üx olletions, eah olletion having at most n
strings. These m quasi-su√Üx olletions onstitute a multi-
ple quasi-su√Üx olletion if onditions 2 and 3 above hold for
any pair of strings s
i
; s
j
over all the m olletions (in other
words, these onditions hold for pairs within eah olletion
and for pairs drawn from distint olletions as well).
Our main result will be the following.
Theorem 1. Let  be any positive onstant. The om-
pated trie of a quasi-su√Üx olletion of n strings an be
onstruted in O(n) time and spae with failure probability
at most
O(logn)
2
(n
1 
= logn)
, given the above harater orale. Fur-
ther, the ompated trie of a multiple quasi-su√Üx olletion
omprising m quasi-su√Üx olletions of at most n strings
eah an be onstruted in O(nm) time and spae with fail-
ure probability at most
O(logmn)
2
((mn)
1 
= logmn)
,
2.1 Examples of Quasi-Suffix Collections
The signiane of the above theorem omes from the fol-
lowing examples of quasi-su√Üx olletions. The simplest
example is the olletion of all su√Üxes of a string s with
a speial end-of-string symbol. This is a quasi-su√Üx olle-
tion but with a stronger property, namely, ondition 3 in the
denition of quasi-su√Üx olletions is satised with equal-
ity. The ompated trie of these su√Üxes is the well-known
su√Üx tree of the string s. Next, we give two more signiant
examples, for whih equality need not hold in ondition 3.
2.1.1 Suffix Trees for Parameterized Strings
Reall from the introdution that a parameterized string
s has parameters and symbols. The alphabet from whih
parameters are derived is disjoint from the alphabet from
whih symbols are derived. Further, both alphabet sizes are
polynomial in n, the length of s. As is standard, assume
that s ends in a symbol $ whih does not our elsewhere
is s. From s, Baker [1‚ÑÑ dened the following olletion of
strings.
Eah su√Üx s
0
of s is mapped to a string num(s
0
) with pa-
rameters replaed by numbers and symbols retained as suh
(assume that symbols are not numbers). The replaement of
parameters is done as follows. The rst ourrene of eah
parameter in s
0
gets value 0 in num(s
0
). Subsequent our-
renes of a parameter get values equal to the distane from
the previous ourrene of the same parameter. Consider
the olletion of strings fnum(s
0
)js
0
su√Üx of sg in dereas-
ing length order. Baker [1‚ÑÑ dened the su√Üx tree of param-
eterized string s to be the ompated trie of this olletion.
That this olletion of strings is indeed a quasi-su√Üx olle-
tion an be seen as follows.
Condition 1 learly holds and ondition 2 follows from the
ourrene of the speial symbol $ at the end of s. Condition
3 is shown to hold next. Note that if s
0
i
and s
0
i+1
are two
onseutive su√Üxes of s, then num(s
0
i+1
) an be obtained
from num(s
0
i
) as follows: for eah well-dened index k > 0,
set num(s
0
i+1
)[k‚ÑÑ to num(s
0
i
)[k+1‚ÑÑ if num(s
0
i
)[k+1‚ÑÑ 6= k, and
set num(s
0
i+1
)[k‚ÑÑ to 0, otherwise. Next, onsider two su√Üxes
s
0
i
and s
0
j
of s. From the above observation, it follows that if
num(s
0
i
) and num(s
0
j
) have a ommon prex of length k+1,
then num(s
0
i+1
) and num(s
0
j+1
) have a ommon prex of
length k. Further, if num(s
0
i
) and num(s
0
j
) dier at loation
k+1, then num(s
0
i+1
) and num(s
0
j+1
) ould be idential at
loation k if one of num(s
0
i
)[k + 1‚ÑÑ; num(s
0
j
)[k + 1‚ÑÑ equals k
and the other equals 0. Condition 3 is now easily seen to
hold.
The harater orale for the above quasi-su√Üx olletion is
easily implemented in O(1) time, after the following preom-
putation: for eah ourrene of a parameter in s, determine
the previous ourrene, if any, of this parameter in s. This
preomputation is easily done in O(n) time.
2.1.2 Suffix Trees for 2-D Arrays
Consider a 2-D array s having size mn, m  n, and har-
aters drawn from some polynomial range. For eah square
subarray s
0
of s whih is maximal (i.e., touhes either the
right boundary or the bottom boundary or both boundaries
of s), Gianarlo [6‚ÑÑ dened a string num(s
0
) as follows.
Dening num(s
0
). Partition s
0
into L's as in [6‚ÑÑ (an L is
formed by taking a prex of a row and a prex of a ol-
umn, with the ommon point being at the bottom-right;
both prexes have equal lengths; the resulting shape is a-
tually the mirror image of the harater L). num(s
0
) will be
a sequene of numbers, one number for eah suh L; these
numbers are arranged in inreasing order of L sizes. The
number for a partiular L is obtained by reading this L as
a string and then mapping strings to integers in suh a way
that distint strings map to distint integers (by using, for
example, the Karp-Rabin ngerprinting sheme [8‚ÑÑ, whih
ensures this property with inverse polynomial failure prob-
ability). Finally, append a speial end-of-string symbol $ to
num(s
0
), as was done for parametrized strings.
The Quasi-Su√Üx Colletions. Consider a partiular top-
left to bottom-right diagonal and onsider all maximal square
subarrays of s with top-left point on this diagonal. The
num() strings orresponding to these subarrays are eas-
ily seen to form a quasi-su√Üx olletion. Thus eah top-
left to bottom-right diagonal gives a quasi-su√Üx olletion
of strings. Sine there are m + n   1 diagonals, we have
m + n   1 = O(m) distint quasi-su√Üx olletions in all.
It is easy to hek that these m + n   1 quasi-su√Üx olle-
tions together onstitute a multiple quasi-su√Üx olletion
(we will use distint end-of-string symbols for eah diagonal
to satisfy ondition 2 for pairs of strings drawn from dis-
tint olletions). Note that the number of strings in eah
olletion is at most n. Gianarlo [6‚ÑÑ dened the ommon
ompated trie of these m+n 1 olletions to be the su√Üx
tree of s.
The Charater Orale. A harater orale whih works
with inverse polynomial failure probability in O(1) time af-
ter O(mn) preproessing is easy to implement using the
Karp-Rabin ngerprinting sheme. The preproessing in-
volves omputing prex sums for eah row and olumn.
2.2 Proving Theorem 1
The rest of the paper is devoted to proving Theorem 1. First,
we will desribe how to onstrut the ompated trie of a
single quasi-su√Üx olletion of n strings in O(n) time with
high probability. This algorithm an be extended to multiple
quasi-su√Üx olletions (like those resulting from 2D arrays)
easily with an O(m) multipliative time and spae overhead
(assuming m olletions of at most n strings eah). This
extension is skethed briey in Setion 6.
Our algorithm for a single quasi-su√Üx olletion will have
two omponents. The rst omponent is a modiation of
MCreight's algorithm and is desribed in Setion 4 and
Setion 5. In these setions, we will assume that the unique
hild of any given node with edge label beginning with a
given harater an be determined in O(1) time. The seond
omponent, i.e., a dynami perfet hashing sheme desribed
below, will handle this problem.
Note that in all the above examples of quasi-su√Üx olle-
tions, the alphabet size is a polynomial in n. Thus to aess
the unique edge with a partiular starting harater from a
node, we need to perfetly hash O(n) pairs, where the rst
entry in the pair is a node number and the seond entry
is a harater from the alphabet. Eah suh pair an be
treated as a number from a range polynomial in n. We give
a dynami hashing sheme whih will perfetly hash an item
from a polynomial in n range in Setion 7.
Before giving our algorithms, we need an outline of M-
Creight's algorithm for onstruting the su√Üx tree of a string.
3. MCCREIGHT‚ÄôS ALGORITHM
The use of su√Üx links is ruial to this algorithm. Su√Üx
links are dened as follows.
Denition. For a node x, let str(x) denote the substring
assoiated with the path from the root of the tree to x. A
su√Üx link points from a node x to a node y suh that str(y)
is just str(x) with the rst harater removed. Let link(x)
denote this node y. Let par(x) denote the parent of x. For a
string u, dene node(u) to be that node x, if any, for whih
str(x) = u.
Sine ondition 3 in the denition of quasi-su√Üx olletions
is satised with equality for the olletion of su√Üxes of a
string, su√Üx links are dened for eah node x in the su√Üx
tree, i.e., for eah node x, a node y = link(x) with the above
desription exists.
MCreight's onstrution inserts su√Üxes into the su√Üx tree
one by one, in order of dereasing length. For eah suf-
x, one new leaf and possibly one new internal node are
inserted. This sequene of insertions an be divided into
phases. There are two kinds of phases, sanning and resan-
ning.
A sanning phase begins with a hitherto unread portion of
the input string being sanned and a portion of some path
down the su√Üx tree being traversed, ulminating in the in-
sertion of a new leaf as a hild of a new or existing internal
node x
1
. Portions of the su√Üx tree traversed in this sanning
step are alled sanned portions. Subsequent to this san-
ning, a resanning phase begins in whih a series of internal
nodes x
2
; : : : ; x
k
is inserted
1
, without the text being sanned
any further. x
i
's su√Üx link points to x
i+1
, 1  i  k   1;
further, x
k
's su√Üx link points to an already present node
x
k+1
. The next sanning phase begins by sanning the tree
downwards from x
k+1
.
The proess of inserting x
i+1
, following the insertion of x
i
,
1  i  k   1, is as follows. The tree is resanned down-
wards from link(par(x
i
)) until the right position for x
i+1
is found. Resanning requires determining that path down
the tree from link(par(x
i
)) whose edge labels form the same
substring as the label on the edge between par(x
i
) and x
i
.
Suh a path is guaranteed to exist by ondition 3 in the
denition of quasi-su√Üx olletions; further equality in this
ondition implies that the termination point of this path is
the right loation for x
i+1
. Sine the above path is guaran-
teed to exist, it su√Ües to examine just the rst harater on
eah edge to determine this path, as opposed to examining
all the haraters omprising the edge label; thus the term
resanning as opposed to sanning.
4. OUR ALGORITHM
As in MCreight's algorithm, we will insert the strings in
the given olletion s
1
; : : : ; s
n
in the ompated trie in de-
reasing order of length. Muh of the algorithm remains the
same; however, we make two key modiations. The rst in-
volves traversing the path up the tree from a newly inserted
node to nd an anestor with a su√Üx link. The seond in-
volves opying nodes bakwards while resanning down the
tree from the destination of the above su√Üx link. These
hanges aet only the resanning algorithm; the sanning
part remains unhanged. We desribe these hanges in de-
tail next.
Dening Su√Üx Links. For a node x, link(x) is now de-
ned to be that node y suh that if str(x) is a prex of
some s
i
then str(y) is a prex of s
i+1
; further jstr(y)j =
jstr(x)j   1. Note that sine ondition 3 in the denition of
quasi-su√Üx olletions need not be satised with equality,
link(x) need not be dened for every node x. Also note
that if link(x) exists then it is unique; this follows beause
if str(x) is a prex of s
i
and of s
j
then s
i+1
and s
j+1
agree
in the rst jstr(x)j   1 haraters.
Baking Up. Reall the proess of inserting x
i+1
, following
the insertion of x
i
, 1  i  k   1, from our desription
of MCreight's algorithm above. Now, sine link(par(x
i
))
need not be dened, we must traverse up the tree from x
i
until a node with a su√Üx link dened is found. We all this
node nan(x
i
) (nan stands for nearest anestor). Next, the
tree is resanned downwards from link(nan(x
i
)), as before.
See Figure 1.
Real and Imaginary Nodes. Reall from our desription
of MCreight's algorithm above that a resanning phase ter-
minates when it is found that the su√Üx link of x
k
points to
1
With eah of these internal nodes, a hild leaf orrespond-
ing to a new su√Üx is also inserted.
baking up to
nd su√Üx link
nan(x)
x
su√Üx link pointing forwards
Imaginary Node
Bak-propagated Node
Real Node
newly inserted node
with
resanning
bak-propagation
Figure 1: Baking up and Bak-propagation
str(x)
x
s
i
s
i 1
s
j 1
s
j
bak-propagated in diretion b
bak-propagated in diretion a
a
b
Figure 2: Diretion of Bak-propagation
an already existing node x
k+1
. In our situation, the ter-
mination ondition of a resanning phase is dierent. A
resanning phase ends when it is found that either:
1. x
k
's su√Üx link points to an already existing node x
k+1
,
or,
2. x
k
's su√Üx link is not dened, i.e., it points to the mid-
dle of an edge.
We introdue an imaginary node x
k+1
in the latter ase;
note that this imaginary node has only one hild and does
not have an outgoing su√Üx link. Internal nodes whih are
not imaginary will be alled real; so x
1
: : : x
k
are real and
have at least 2 hildren eah. The urrent resanning phase
ends at x
k+1
and a new sanning phase begins by sanning
downwards from x
k+1
.
Note that there are just O(n) real nodes and O(n) imaginary
nodes (at most one real internal node, one leaf, and one
imaginary node are inserted per su√Üx). Sine real nodes
have at least two hildren eah, imaginary nodes have just
one hild eah, and the number of leaves is n, the total
number of hildren over all real and imaginary nodes is O(n).
Also note that the total length of the sanned portions of
the tree in MCreight's algorithm in O(n) and this remains
the same for our algorithm. We state these fats below for
future referene.
Fat 1. (i) The number of real and imaginary nodes
together is O(n).
(ii) The total number of hildren of real and imaginary
nodes together is O(n).
(iii) The total length of the sanned portions of the tree
is O(n) (the length of a single sanned portion is the
number of haraters, not nodes, enountered in the
path sanned).
Bak-Propagated Nodes. Other than real and imaginary
nodes, our onstrution will involve internal nodes of a third
kind, alled bak-propagated nodes. Bak-propagated nodes
will always have su√Üx links and only one hild eah. They
are dened as follows. In the following, think of su√Üx links
as pointing forwards (see Figure 1).
Suppose our algorithm has just inserted a node x. When
the appropriate path starting an link(nan(x)) is resanned
in order to determine the node link(x), several nodes ould
be enountered in the proess. If more than 2 nodes are en-
ountered, then alternate nodes are propagated bak to the
path (nan(x); x) (i.e., new nodes with su√Üx links pointing
to the traversed nodes are set up on this path), taking are
that the rst and the last nodes traversed are not propagated
bak. The new nodes are alled bak-propagated nodes.
Diretion of Bak-Propagation. Note that a node ould
be bak-propagated in several dierent diretions, i.e., sev-
eral bak-propagated nodes ould have their su√Üx links point-
ing to this node. Further, a bak-propagated node ould
be propagated bakwards further, forming a hain of bak-
propagated nodes.
Denitions. For a node x, let prev(x) be a set of strings
dened as follows. For eah s
i
in the given quasi-su√Üx ol-
letion having prex str(x), prev(x) ontains the prex of
s
i 1
of length jstr(x)j + 1. Note that prev(x) is a set and
not a multiset; therefore all strings in it are distint. Dire-
tion a is said to be valid for node x if string a appears in
prev(x). Node x is said to be bak-propagated in diretion a
if there exists a string a in prev(x) suh that node(a) exists
and is a bak-propagated node (see Figure 2). Note that
the su√Üx link of node(a) points to x under these onditions,
i.e., link(node(a)) = x.
The following invariant is maintained by our algorithm by
virtue of the fat that only alternate nodes enountered are
bak-propagated and the rst and last nodes enountered
are not bak-propagated.
Invariant 1. If a node x is bak-propagated in diretion
a then its parent is not bak-propagated in diretion a
0
, where
a
0
is a prex of a.
5. TIME COMPLEXITY
There are two aspets to the time taken. The rst involves
baking-up from x to nan(x), subsequent to the insertion
of x. The seond involves resanning the appropriate path
down from link(nan(x)) until link(x) is loated. We a-
ount for these two aspets of the time separately.
We make a few remarks on the seond aspet here. Eah
step taken here involves one of the following:
1. Creating a new bak-propagated node.
2. Adding a su√Üx link to an already existing node. This
happens when one seeks to bak-propagate a node but
the site of this bak-propagation is already oupied
by some other node. For this to happen, the latter
node must not have a su√Üx link, i.e., it must be an
imaginary node. A su√Üx link is now added to this
imaginary node.
3. Creating a new real or imaginary node. This is the
node link(x).
Sine only one real or imaginary node is added when resan-
ning from link(nan(x)) to link(x), the time taken in this
resanning is proportional to O(1) plus the number of nodes
bak-propagated in this proess plus the number of imagi-
nary nodes for whih su√Üx links are set up in this proess.
Sine eah imaginary node an get only one su√Üx link dur-
ing the ourse of the entire algorithm, bounding the above
time boils down to bounding the number of bak-propagated
nodes by O(n).
5.1 Bounding Back-Propagated Nodes
This will use a harging argument, where eah bak-propagated
node will be harged to either some real/imaginary node, or
to some harater in the string s
1
. Eah real/imaginary
node and eah harater in s
1
will be harged O(1) in the
proess. The O(n) bound will follow from Fat 1. It may
be that a node reated by bak propagation subsequently
beomes real or imaginary. These nodes are not ounted;
only nodes that are not real or imaginary when the full tree
is built are ounted.
Note that a bak-propagation hain always starts at a real
or an imaginary node. We will dene a tree for eah real or
imaginary node x as follows.
Dening BP tree(x). All nodes in this tree other than the
root x are bak-propagated nodes. Those bak-propagated
nodes whih are bak-propagated from x (i.e., have su√Üx
links pointing to x) are hildren of x in this tree. Trees
rooted at these hildren are dened reursively, i.e., hildren
of a node are those whih are bak-propagated from that
node. The leaves of this tree are those nodes whih are not
bak-propagated at all.
Consider the forest of BP   Trees() rooted at the various
real/imaginary nodes that are bak-propagated. Eah bak-
propagated node appears in exatly one tree in this forest.
Deomposing BP  tree(x) into paths. We partition the
nodes of this tree into paths. The rst path is the minimal
path starting from the root x and ending on a node y with
the following property: either there exists a valid diretion a
suh that y has not been bak-propagated in this diretion
or there is no valid diretion for y. Clearly, suh a node
y must exist. But for the termination restrition, the path
starting at the root is hosen arbitrarily. One nodes in this
path are removed, the subtrees hanging o this path are
deomposed reursively.
Clearly, eah bak-propagated node will belong to exatly
one of the various paths formed above. Think of eah path
as going bakwards from its start node.
Aounting for long paths. We show that the sum of
the lengths of all the paths obtained above is proportional
to the number of suh paths plus O(n).
Consider any path obtained above. Let x be any node on
this path, other than its start node. link(x) is the node from
whih x was bak-propagated, in diretion, say a. Note that
link(x) will preede x in the path being onsidered.
By Invariant 1, the parent par(link(x)) of link(x) in the
ompated trie has not been bak-propagated in the dire-
tion a
0
, where a
0
is the prex of a suh that ja
0
j equals
jstr(par(link(x)))j+ 1; a
0
, of ourse, is a valid diretion for
par(link(x)) (beause a is valid for link(x) itself). It fol-
lows that either par(link(x)) is a real/imaginary node or
par(link(x)) is a bak-propagated node and the last node in
its path. In either ase, we harge par(link(x)) for x.
Clearly, eah real/imaginary node and eah bak-propagated
node whih is the last node in its respetive path will be
harged an amount equal to the number of its hildren, in
this proess. From Fat 1(ii), this harge sums to O(n)
for real/imaginary nodes. Note that bak-propagated nodes
have only one hild eah. Thus, it now su√Ües to bound the
total number of paths.
Bounding the total number of paths. We will extend
the above paths bakwards to form a olletion of extended
paths, as below.
Consider any one path, and let x be the last node on this
path. The extension to this path is performed as follows.
Start at x and follow that diretion bakwards along whih
x was not bak-propagated (there is at least one suh dire-
tion, unless there are no valid diretions for x). Next, repeat-
edly follow any arbitrarily hosen valid diretion bakwards.
This extension need not always enounter a node (in fat we
will stop when we hit a node); it is allowed to ut through
edges
2
. So if a partiular step of this extension leads to the
2
We have dened valid diretions only for nodes in the om-
pated trie. However, this denition an be extended for
points in the middle of an edge in the obvious way, i.e., by
imagining as if a node is present at that point.
middle of an edge e, take an arbitrary valid diretion bak
from that harater on e. Continue this extension until ei-
ther a node is reahed or there is no valid diretion left to
go further.
Thus an extended path onsists of an initial prex of nodes
(i.e., the path itself), followed by a walk whih uts through
edges, and possibly terminates on a node. Again, note that
we think of a path as going bakwards. We have the follow-
ing laims.
Lemma 1. Two distint extended paths annot interset
(i.e., they annot ut through the same point on some edge
or have a node in ommon), exept that the last node of one
an be the rst node of the other.
Proof. Sine forward diretions are always unique, two ex-
tended paths an interset otherwise only if the start node
of one path is ontained in the other path and is not the
last node on that path. This is a ontradition sine all the
unextended paths begin at nodes, the unextended paths are
node disjoint, and the extension of a path terminates as soon
as a node is reahed. 2
Lemma 2. If an extended path terminates by reahing a
node y (and not by running out of valid diretions), then y
annot be a bak-propagated node.
Proof. Let x be the last node of the path whose exten-
sion is under onsideration. Suppose y is a bak-propagated
node. Then learly, x must have been bak-propagated in
the diretion implied by y (note that there is a unique valid
diretion for x along whih it must be bak-propagated, a
unique valid diretion along whih the resulting node must
be bak-propagated, and so on, until y is reahed). But we
started the extension of this path by hoosing a diretion
along whih x was not bak-propagated, a ontradition. 2
Lemma 3. The total number of paths is O(n), and hene
the total number of bak-propagated nodes is O(n).
Proof. Consider a partiular extended path. If it ends at a
node without running out of valid diretions, this node must
be real/imaginary, by Lemma 2; the urrent path is then
harged to this node. By Lemma 1, eah real/imaginary
node is just harged one.
On the other hand, if this extended path ends beause all
further valid diretions bakwards are exhausted, then the
substring assoiated with the termination point is a prex
of s
1
. Further, by Lemma 1, dierent extended paths whih
end in this way are assoiated with distint prexes of s
1
.
Thus the number of paths is O(n).
The lemma follows from the argument given earlier that
the number of bak-propagated nodes is proportional to the
number of paths plus O(n). 2
5.2 Backing-up Time
It remains to aount for the time taken to determine nan(x)
after the insertion of x. Note that all suh nodes x for whih
nan(x) will be determined are distint real nodes (beause
eah imaginary node starts a new sanning phase).
This omputation requires traversing upwards from x un-
til the nearest node with a su√Üx link is found. All nodes
enountered on the way must be imaginary (real and bak-
propagated nodes have su√Üx links) and we need to aount
for the time taken to traverse these nodes.
The key laim is the following. Note that an imaginary
node y signals the beginning of a new sanning phase in
MCreight's algorithm, in whih the tree is sanned down-
wards starting at y, until a new leaf is inserted as a hild of
a new or existing internal node z.
Lemma 4. The total number of times imaginary node y
an be enountered while determining nan() over the en-
tire algorithm is at most jstr(z)j   jstr(y)j.
Proof. Note that z is a real node after the above sanning
phase starting at y nishes. y ould be enountered one
while setting up link(z). Subsequently, sine link(z) is in
plae, y will be enountered only when nding nan(z
0
),
where z
0
is real and on the path from y to z. There an be
at most jstr(z)j   jstr(y)j suh distint real nodes z
0
. 2.
Corollary 1. The total time taken in traversing imagi-
nary nodes while determining nan() is O(n).
Proof. Follows from Fat 1 and Lemma 4. 2
Theorem 1 now follows for quasi-su√Üx olletions, assuming
that the orret hild of a partiular node an be found
in O(1) time. The extension to quasi-su√Üx olletions is
skethed next.
6. ALGORITHM FOR MULTIPLE QUASI-
SUFFIX COLLECTIONS
We sketh how to extend the above algorithm to a multiple
quasi-su√Üx olletion omprising m quasi-su√Üx olletions
of O(n) strings eah. The time taken will be O(mn).
Su√Üx links and bak-propagation diretions need to be rede-
ned appropriately as follows. Let s
k
i
denote the ith string in
the kth quasi-su√Üx olletion under onsideration (assume
an arbitrary ordering on the m quasi-su√Üx olletions).
Su√Üx Links. For a node x, link(x) is now dened to be
that node y suh that if str(x) is a prex of some s
k
i
then
str(y) is a prex of s
k
i+1
; further jstr(y)j = jstr(x)j   1.
Note that sine ondition 3 in the denition of quasi-su√Üx
olletions need not be satised with equality, link(x) need
not be dened for every node x. Also note that if link(x)
exists then it is unique; this follows beause if str(x) is a
prex of s
k
i
and of s
k
0
j
then s
k
i+1
and s
k
0
j+1
agree in the rst
jstr(x)j   1 haraters.
Bak-Propagation Diretions. For a node x, let prev(x)
be a set of strings dened as follows. For eah s
k
i
having
prex str(x), prev(x) ontains the prex of s
k
i 1
of length
jstr(x)j+ 1. Note that prev(x) is a set and not a multiset;
therefore all strings in it are distint. Diretion a is said to
be valid for node x if string a appears in prev(x).
The Algorithm. The algorithm inserts eah olletion in
turn into the urrent ompated trie. The rst string of eah
quasi-su√Üx olletion starts a new resanning phase begin-
ning at the root of the ompated trie. The subsequent
strings in the olletion are inserted as in the previous al-
gorithm. Note that the size of the ompated trie will now
be (mn). Fat 1 ontinues to hold with O(n) replaed by
O(mn). The analysis is as before with the following two
hanges. All O(n) terms are replaed by O(mn). Further,
in Lemma 3, if an extended path ends beause all further
valid diretions bakwards are exhausted then the substring
assoiated with the termination point is a prex of the rst
string in one of the m quasi-su√Üx olletions being onsid-
ered.
7. THE HASHING SCHEME
Reall from Setion 2.2 that we need to perfetly hash O(n)
pairs, where the rst entry in eah pair is a node number and
the seond entry is a harater from the alphabet. Eah suh
pair an be treated as a number from a range polynomial in
n. We give a dynami hashing sheme whih will perfetly
hash an item from a polynomial in n range in O(n) time,
with high probability. The time taken to aess a partiular
item will be O(1) and the total spae is O(n).
Fredman-Komlos-Szemeredi [5‚ÑÑ showed how n items from
the range [0 : : : poly(n)‚ÑÑ an be hashed into the range [0 : : : s‚ÑÑ
without any ollisions, where s = (n). Their algorithm
takes O(n) time and spae and works by hoosing randomly
from a family of almost-universal hash funtions (assuming
onstant time arithmeti on O(log n) bits). It ensures no
ollisions with probability at least 1=2.
This was generalized by Dietzfelbinger et al. [2‚ÑÑ to the dy-
nami setting. The expeted amortized insertion/deletion
time for their algorithm is O(1); searhing takes O(1) worst
ase time. Our aim is to strengthen the above algorithm so
it works with high probability, not just with onstant prob-
ability. To this end, we modify the FKS perfet hashing
sheme to make it work with high probability, rst in the
stati setting, and then in the dynami setting.
First, we present the stati algorithm. The key idea is to
reate several perfet hashing subproblems and to apply the
FKS sheme on eah independently to obtain high suess
probability.
7.1 The Static Hashing Scheme
The following steps are performed. Let  be any positive
onstant. The time and spae taken by our data struture
will be linear, but with an
1

onstant fator. The failure
probability will derease as  gets loser to 0.
Step 1. Start with an imaginary array A of size n

, where
the n items to be hashed ome from the range 1 : : : n

. Eah
item indexes into an unique element in this array. Next,
repeatedly partition this array as in Step 2.
Step 2. Construt a partition tree as desribed below. Eah
node in this tree will have a subarray of A assoiated with
it. The depth of this tree will be a onstant and the number
of nodes will be O(n). The root of this tree is A itself. It
has n

hildren, eah assoiated with a distint subarray
of A of size n
 
obtained by partitioning A into n

disjoint
piees. Eah subarray with more than n

items is reursively
partitioned; the remaining subarrays beome leaves. Eah
leaf has at most n

items. Clearly, the number of levels in
this tree is O(


) = O(1) and the total size in O(n). The
total time taken to set up the tree is easily seen to be O(n).
Step 3. Next, we onsider eah leaf of the above tree in
turn, and the items in the subarray assoiated with this leaf.
We perfet-hash these items using the FKS perfet hashing
sheme. Sine this sheme sueeds only with probability
1/2, several trials may be required before these items are
perfetly hashed. We show that with high probability, the
total time taken in this proess over all leaves is O(n).
7.2 Time Complexity
We need to bound the time taken to perform several FKS
perfet-hashings, where the total sizes of all subproblems is
n, eah subproblem has size at most n

, and a subproblem is
performed suessfully in linear time with probability 1/2.
Size Categories. Divide the leaves into O(log n) quadru-
pling ategories by size (i.e., number of assoiated items).
Consider just leaves in any one size ategory, namely, the
ategory in whih leaf sizes are in the range
n

4
i+1
  
n

4
i
,
i  0. We will show that the time taken for this ate-
gory is proportional to the sum of the sizes of leaves in this
ategory plus O(
n
2
i
), with failure probability
O(logn)
2
(
2
i
n
1 
logn
)
. It
follows that the total time taken over all ategories is O(n),
with failure probability
O(logn)
2
(
n
1 
logn
)
.
A leaf is said to sueed when the items in it are perfetly
hashed. A round refers to one trial for eah of the relevant
leaves. The trials for the various leaves an be imagined
to have proeeded in rounds, with leaves sueeding in one
round dropping out of the subsequent rounds. We organize
the rounds into groups.
Grouping Rounds. The 0th group omprises rounds per-
formed before the number of unsuessful leaves in this size
ategory drops below
n
1 
2
i
log n
. For j  1, the jth group om-
prises rounds performed after the number of unsuessful
leaves in this size ategory drops below
n
1 
2
i
2
j 1
log n
but before
this number drops below
n
1 
2
i
2
j
log n
.
We show that group 0 has O(i+ log log n) rounds and that
eah group j  1 has O(2
j
) rounds, with failure probability
O(logn)
2
(
n
1 
2
i
log n
)
(over all groups). Further, we show that with
the same failure probability, every two onseutive rounds
in group 0 redue the number of unsuessful leaves by half.
The total time taken for rounds in group 0 is then propor-
tional to the sum of leaf sizes in this ategory. The time
taken for rounds in the other groups is
O(
(logn)
X
j=1
[2
j
n
1 
2
i
2
j 1
log n
n

4
i
‚ÑÑ) = O(
n
2
i
);
as required.
The Key Property. To show the above laims on the
number of rounds in eah group, we will need the follow-
ing property, obtained using the Cherno bound. If there
are #u unsuessful leaves at some instant of time, then
half these leaves sueed in the next 2k rounds, with failure
probability
1
2
(#uk)
.
Group 0. First, onsider group 0. If the number of un-
suessful leaves at some instant is at least
n
1 
2
i
log n
, then
two rounds will halve the number of unsuessful leaves,
with failure probability at most
1
2
(
n
1 
2
i
log n
)
(apply the above
property with k = 1 and #u 
n
1 
2
i
log n
). Note that the num-
ber of leaves in the size ategory being onsidered is at most
n
n

=4
i+1
= n
1 
4
i+1
, to begin with. It follows that group 0
has 2(i + 2 + log log n) rounds, and halving ours in eah
pair of onseutive rounds, with failure probability at most
(i+2+log log n)
2
(
n
1 
2
i
logn
)
=
O(logn)
2
(
n
1 
2
i
logn
)
.
Other Groups. Next, onsider group j, j  1. Apply-
ing the above property with k = 2
j
and #u 
n
1 
2
i
2
j
log n
, we
get that group j has 2:2
j
rounds with failure probability
1
2
(
n
1 
2
i
2
j
2
j
logn
)
=
1
2
(
n
1 
2
i
log n
)
. Finally, adding up the failure
probability over all O(log n) groups gives
O(logn)
2
(
n
1 
2
i
log n
)
, as re-
quired.
The total time and spae taken above is thusO(n), with high
probability. Searhing for an element requires following the
unique path down the partition tree to reah the relevant
perfet-hash table. These operations are easily seen to take
O(1) worst-ase time.
7.3 The Dynamic Hashing Scheme
The dynami version of the above stati sheme maintains
the partition tree desribed in Step 2 above at eah in-
stant (with the same parameters, i.e., A has size n

and
the branhing fator in n

; here n is the total number of
items whih will ever be inserted).
Initially the partition tree will have just an empty root node.
This tree will build up as insertions are made. The size of
the partition tree at any instant will be proportional to the
number of items in it. Further, at eah instant, the perfet-
hash struture at any leaf will have an assoiated apaity.
This apaity will be at least the number of items at that
leaf but no more than twie this quantity. It follows that
the total spae required at any instant will be proportional
to the number of items present.
The algorithm for an insertion is desribed next. Note that
our ompated tree appliation involves only insertions and
no deletions.
Insertions. On an insertion x, the path down this partition
tree to the appropriate leaf v is traed in O(1) time. Sub-
sequently, there are two ases depending upon how many
items are already present in this leaf v.
First, suppose v has more than n

items, inluding x. Then
the subarray assoiated with v is subdivided as in Step 2 of
the stati algorithm and the subtree rooted at v is developed.
Eah leaf in this tree will have at most n

elements in it. The
elements in eah of these leaves are then perfet-hashed.
Next, suppose v has at most n

items, inluding x, Then the
items already in v would have been perfet-hashed; further,
this perfet-hash struture will have a ertain apaity. If
this apaity is equaled by the insertion of x, then all the
items in v (inluding x) are rehashed into a perfet-hash
struture of twie the apaity. Otherwise, if this apaity
is not equaled, then v is perfet-hashed. If there is no ol-
lision, then v's insertion is omplete. Otherwise, if there is
a ollision, then all the items in v along with x are perfet-
hashed again.
Time Analysis. We will show that the total time taken
to perform n insertions is O(n) with failure probability at
most
O(logn)
2
(n
1 
= logn)
. To show the above, the following fats
need to be noted.
1. The height of the partition tree is O(1), therefore, the
time spent in developing leaves into subtrees on inser-
tion is just O(n) over all n insertions.
2. The perfet-hash struture at any leaf in the partition
tree begins with apaity whih is twie the number
of items urrently in the struture. Future insertions
inrease this number until it equals the apaity. Until
this happens, this perfet-hash struture stays in plae,
though it may have to be rebuilt as many times as
ollisions are aused by insertions. One the number of
items mathes the apaity, this perfet hash-struture
is abandoned and a new perfet-hash struture with
twie the apaity is put in plae.
3. The total apaities of all perfet-hash strutures whih
were ever in existene at any time during the n inser-
tions is O(n) (note that when a perfet-hash struture
at a leaf is replaed by a new struture with twie
the apaity, eah struture is ounted separately in
the above sum). This follows from the doubling of a-
paities at a leaf and from the onstant depth of the
partition tree.
4. When the apaity of a perfet-hash struture at a leaf
is doubled, the probability that this struture needs
rebuilding before the number of items in it equals the
new apaity is at most 1=2. Further, the time taken
for rebuilding a partiular perfet-hash struture is
proportional to its apaity.
Note the dierene from the stati ase, where a perfet-
hash trial sueeds on the items urrently present with
probability 1/2. Now, this is replaed by the fat
that a perfet-hash trial sueeds with probability 1/2
even on future insertions as long as the apaity is not
equaled.
Thus, to establish the total time bound above, it su√Ües to
bound the total time taken for rebuilding the perfet-hash
strutures at the various leaves. This in turn boils down
to the following question: what is the total time taken to
perform several FKS perfet-hashings, where the total sizes
of all subproblems is (n), eah subproblem has size at most
n

, and a subproblem is performed suessfully in linear time
with probability 1/2? The analysis is now idential to the
stati ase.
We onlude with two remarks on generalizing the above
sheme when the number of items is unknown and deletions
need to be performed as well. Neither of these is relevant to
our appliation of onstruting su√Üx trees.
Unknown Number of Items. Suppose the number of
items to be hashed is an unknown quantity m, with eah
item oming from the range 1 : : : n

. Then we start with
an initial estimate of 1, and double the estimate eah time
it is equaled by insertions. Suppose the urrent estimate is
2e, and the number of items inserted is e. We rst hash
these items into an imaginary array A of size (2e)

. No
ollisions our, with inverse polynomial (in e) failure prob-
ability (using families of almost-universal hash funtions).
Subsequently, we build the partition tree with degree (2e)

.
When the number of insertions equals 2e, we double our es-
timate to 4e and rebuild the entire struture. If the total
number of insertions is m, then the total time and spae re-
quired is O(m), with failure probability inverse polynomial
in m. This failure probability an be redued to
1
m
(logm)
by using a family of hash funtions dened by Siegel [11‚ÑÑ,
instead of a family of almost-universal hash funtions.
Deletions. Deletions an be easily handled as follows. A
deleted item is just marked as deleted, without ausing any
other hange to the data struture. Whenever the number of
items marked as deleted beomes a onstant fration of the
number of items urrently in the data struture the entire
struture is rebuilt on the undeleted items. The running
time remains O(m) for m insertions and deletions, with the
same failure probability as above. The spae at any instant
is proportional to the number of undeleted items.
8. REFERENCES
[1‚ÑÑ B. Baker. A theory of parameterized pattern mathing:
Algorithms and appliations. Proeedings of the 25th
ACM Symposium on Theory of Computing, 1993, 71{
80.
[2‚ÑÑ M. Dietzfelbinger, A. Karlin, K. Mehlhorn, F.M. auf
der Heide, H. Rohnert, and R.E. Tarjan. Dynami per-
fet hashing: Upper and lower bounds. SIAM Journal
on Computing, 23, 1994, 738{761.
[3‚ÑÑ M. Dietzfelbinger, F. M. auf der Heide. Dynami hash-
ing in real time. Pro. of the 17th International Col-
loquiua on Automata, Languages and Programming,
LNCS 443, Springer-Verlag, 1990, 6{19
[4‚ÑÑ M. Farah. Optimal su√Üx tree onstrution with large
alphabets, Proeedings of the 38th IEEE Annual Sym-
posium on Foundations of Computer Siene, 1997,
137{143.
[5‚ÑÑ M.L. Fredman, J. Komlos and E. Szemeredi. Storing a
sparse table with O(1) worst ase aess time, Journal
of the ACM, 31, 1984, 538{544.
[6‚ÑÑ R. Gianarlo. A generalization of su√Üx trees to square
matries with appliations, SIAM Journal of Comput-
ing, 1995, 520{562.
[7‚ÑÑ D. Guseld. Algorithms on strings, trees and se-
quenes. Cambridge University Press, 1997.
[8‚ÑÑ R. Karp and M. Rabin. E√Üient Randomized Pattern
Mathing, IBM Journal of Researh and Development,
1987.
[9‚ÑÑ D.K. Kim and K. Park. Linear time onstrution of
2-D su√Üx trees. Proeedings of the 26th International
Colloquium on Automata, Languages, and Program-
ming, 1999.
[10‚ÑÑ E.M. MCreight. A spae eonomial su√Üx tree on-
strution algorithm, Journal of the Assoiation of
Computing Mahinery, 2, 1976, 262{272.
[11‚ÑÑ A. Siegel. On universal lasses of fast high perfor-
mane hash funtions, their time spae trade-o, and
their appliations, Proeedings of the 30th IEEE An-
nual Symposium on Foundations of Computer Siene,
1989, 20{25.
[12‚ÑÑ D. Sleator, R. Tarjan. A Data Struture for Dynami
Trees, Journal of Computer and System Sienes, 26,
1983, 362{391.
[13‚ÑÑ E. Ukkonen. Construting su√Üx trees on-line in linear
time, Proeedings of the IFIP 12th World Computer
Congress, 1992, 484{492.
[14‚ÑÑ P. Weiner. Linear pattern mathing algorithms, Pro-
eedings of the 4th IEEE Annual Symposium on
Swithing and Automata Theory, 1973, 1{11.
