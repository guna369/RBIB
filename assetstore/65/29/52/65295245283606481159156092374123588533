Algorithmica (2014) 69:232â€“268
DOI 10.1007/s00453-012-9726-3
Efficient Fully-Compressed Sequence Representations
JÃ©rÃ©my Barbay Â· Francisco Claude Â· Travis Gagie Â·
Gonzalo Navarro Â· Yakov Nekrich
Received: 4 February 2012 / Accepted: 4 December 2012 / Published online: 15 December 2012
Â© Springer Science+Business Media New York 2012
Abstract We present a data structure that stores a sequence s[1..n] over alpha-
bet [1..Ïƒ ] in nH0(s) + o(n)(H0(s)+1) bits, where H0(s) is the zero-order entropy
of s. This structure supports the queries access, rank and select, which are funda-
mental building blocks for many other compressed data structures, in worst-case
time O(lg lgÏƒ) and average time O(lg H0(s)). The worst-case complexity matches
the best previous results, yet these had been achieved with data structures using
nH0(s) + o(n lgÏƒ) bits. On highly compressible sequences the o(n lgÏƒ) bits of the
redundancy may be significant compared to the nH0(s) bits that encode the data. Our
representation, instead, compresses the redundancy as well. Moreover, our average-
case complexity is unprecedented.
An early version of this article appeared in Proc. 21st Annual International Symposium on
Algorithms and Computation (ISAAC), part II, pp. 215â€“326, 2010. J. Barbay was funded in part by
Fondecyt grants 1-110066 and 1120054, Chile. F. Claude was funded in part by Google PhD
Fellowship Program. G. Navarro was funded in part by Fondecyt grant 1-110066, Chile. Work
partially done during Y. Nekrich stay at the University of Chile.
J. Barbay Â· G. Navarro ()
Department of Computer Science, University of Chile, Santiago, Chile
e-mail: gnavarro@dcc.uchile.cl
J. Barbay
e-mail: jbarbay@dcc.uchile.cl
F. Claude
David R. Cheriton School of Computer Science, University of Waterloo, Waterloo, Canada
e-mail: fclaude@cs.uwaterloo.ca
T. Gagie
Department of Computer Science, Aalto University, Helsinki, Finland
e-mail: travis.gagie@gmail.com
Y. Nekrich
Department of Electrical Engineering & Computer Science, University of Kansas, Kansas, USA
e-mail: yasha@dcc.uchile.cl
Algorithmica (2014) 69:232â€“268 233
Our technique is based on partitioning the alphabet into characters of similar fre-
quency. The subsequence corresponding to each group can then be encoded using fast
uncompressed representations without harming the overall compression ratios, even
in the redundancy.
The result also improves upon the best current compressed representations of sev-
eral other data structures. For example, we achieve (i) compressed redundancy, re-
taining the best time complexities, for the smallest existing full-text self-indexes;
(ii) compressed permutations Ï€ with times for Ï€() and Ï€âˆ’1() improved to logloga-
rithmic; and (iii) the first compressed representation of dynamic collections of dis-
joint sets. We also point out various applications to inverted indexes, suffix arrays,
binary relations, and data compressors.
Our structure is practical on large alphabets. Our experiments show that, as pre-
dicted by theory, it dominates the space/time tradeoff map of all the sequence repre-
sentations, both in synthetic and application scenarios.
Keywords Compressed sequence representations Â· Rank and select on sequences Â·
Compact data structures Â· Entropy-bounded structures Â· Compressed text indexing
1 Introduction
A growing number of important applications require data representations that are
space-efficient and at the same time support fast query operations. In particular, suit-
able representations of sequences supporting a small set of basic operations yield
space- and time-efficient implementations for many other data structures such as full-
text indexes [22, 28, 32, 48], labeled trees [3, 4, 20], binary relations [2, 4], permuta-
tions [6] and two-dimensional point sets [11, 41], to name a few.
Let s[1..n] be a sequence of characters belonging to alphabet [1..Ïƒ ]. In this article
we focus on the following set of operations, which is sufficient for many applica-
tions:
s.access(i) returns the ith character of sequence s, which we denote s[i];
s.ranka(i) returns the number of occurrences of character a up to position i in s;
and
s.selecta(i) returns the position of the ith occurrence of a in s.
Table 1 shows the best sequence representations and the complexities they achieve
for the three queries, where Hk(s) refers to the k-th order empirical entropy of s [43].
To implement the operations efficiently, the representations require some redundancy
space on top of the nH0(s) or nHk(s) bits needed to encode the data. For example,
multiary wavelet trees (row 1) represent s within zero-order entropy space plus just
o(n) bits of redundancy, and support queries in time O(1 + lgÏƒlg lgn ). This is very at-
tractive for relatively small alphabets, and even constant-time for polylog-sized ones.
For large Ïƒ , however, all the other representations in the table are exponentially faster,
and some even achieve high-order compression. However, their redundancy is higher,
o(n lgÏƒ) bits. While this is still asymptotically negligible compared to the size of a
plain representation of s, on highly compressible sequences such redundancy is not
always negligible compared to the space used to encode the compressed data. This
234 Algorithmica (2014) 69:232â€“268
Table 1 Best previous bounds and our new ones for data structures supporting access, rank and select.
The space bound of the form Hk(s) holds for any k = o(logÏƒ n), and those of the form (1 + ) hold for
any constant  > 0. On average lgÏƒ becomes H0(s) in our time complexities (see Corollary 3) and in row
1 [7, Theorem 5]
space (bits) access rank select
[29, Theorem 4] nH0(s) + o(n) O
(
1 + lgÏƒlg lgn
) O(1 + lgÏƒlg lgn
) O(1 + lgÏƒlg lgn
)
[4, Lemma 4.1] nH0(s) + o(n lgÏƒ) O(lg lgÏƒ) O(lg lgÏƒ) O(1)
[33, Corollary 2] nHk(s) + o(n lgÏƒ) O(1) O(lg lgÏƒ) O(lg lgÏƒ)
[28, Theorem 2.2] (1 + )n lgÏƒ O(1) O(lg lgÏƒ) O(1)
Theorem 2 nH0(s) + o(n)(H0(s) + 1) O(lg lgÏƒ) O(lg lgÏƒ) O(1)
Theorem 2 nH0(s) + o(n)(H0(s) + 1) O(1) O(lg lgÏƒ) O(lg lgÏƒ)
Corollary 4 (1 + )nH0(s) + o(n) O(1) O(lg lgÏƒ) O(1)
raises the challenge of retaining the efficient support for the queries while compress-
ing the index redundancy as well.
In this paper we solve this challenge in the case of zero-order entropy compres-
sion, that is, the redundancy of our data structure is asymptotically negligible com-
pared to the zero-order compressed text size (not only compared to the plain text
size), plus o(n) bits. The worst-case time our structure achieves is O(lg lgÏƒ), which
matches the best previous results for large Ïƒ . Moreover, the average time is logarith-
mic on the entropy of the sequence, O(lg H0(s)), under reasonable assumptions on
the query distribution. This average time complexity is also unprecedented: the only
previous entropy-adaptive time complexities we are aware of come from Huffman-
shaped wavelet trees [32], which have recently been shown capable of achieving
O(1 + H0(s)lg lgn ) query time with just o(n) bits of redundancy [7, Theorem 5].
Our technique is described in Sect. 3. It can be summarized as partitioning the
alphabet into sub-alphabets that group characters of similar frequency in s, storing
in a multiary wavelet tree [22] the sequence of sub-alphabet identifiers, and storing
separate sequences for each sub-alphabet, containing the subsequence of s formed
by the characters of that sub-alphabet. Golynski et al.â€™s [28] or Grossi et al.â€™s [33]
structures are used for these subsequences, depending on the tradeoff to be achieved.
We show that it is sufficient to achieve compression in the multiary wavelet tree,
while benefitting from fast operations on the representations of the subsequences.
The idea of alphabet partitioning is not new. It has been used in practical sce-
narios such as fax encoding, JPEG and MPEG formats [36, 52], and in other image
coding methods [51], with the aim of speeding up decompression: only the (short)
sub-alphabet identifier is encoded with a sophisticated (and slow) method, whereas
the sub-alphabet characters are encoded with a simple and fast encoder (even in plain
form). Said [59] gave a more formal treatment to this concept, and designed a dy-
namic programming algorithm to find the optimal partitioning given the desired num-
ber of sub-alphabets, that is, the one minimizing the redundancy with respect to the
zero-order entropy of the sequence. He proved that an optimal partitioning defines
sub-alphabets according to ranges of character frequencies, which reduces the cost of
Algorithmica (2014) 69:232â€“268 235
finding such partitioning to polynomial time and space (more precisely, quadratic on
the alphabet size).
Our contribution in this article is, on one hand, to show that a particular way to
define the sub-alphabets, according to a quantization of the logarithms of the inverse
probabilities of the characters, achieves o(H0(s) + 1) bits of redundancy per charac-
ter of the sequence s. This value, in particular, upper bounds the coding efficiency of
Saidâ€™s optimal partitioning method. On the other hand, we apply the idea to sequence
data structures supporting operations access/rank/select, thus achieving efficient sup-
port of indexed operations on the sequence, not only fast decoding.
We also consider various extensions and applications of our main result. In Sect. 4
we show how our result can be used to improve an existing text index that achieves
k-th order entropy [4, 22], so as to improve its redundancy and query times. In this
way we achieve the first self-index with space bounded by nHk(s)+o(n)(Hk(s)+1)
bits, for any k = o(logÏƒ n), able to count and locate pattern occurrences and extract
any segment of s within the time complexities achieved by its fastest predecessors.
We also achieve new space/time tradeoffs for inverted indexes and binary relations.
In Sects. 5 and 6 we show how to apply our data structure to store a compressed
permutation and a compressed function, respectively, supporting direct and inverse
applications and in some cases improving upon previous results [6, 7, 38, 47]. We
describe further applications to text indexes and binary relations. In particular, an ap-
plication of our structure on permutations, at the end of Sect. 5, achieves for the first
time compressed redundancy to store function Î¨ of text indexes [32, 35, 57]. Sec-
tion 7 shows how to maintain a dynamic collection of disjoint sets, while supporting
operations union and find, in compressed form. This is, to the best of our knowledge,
the first result of this kind.
2 Related Work
Sampling A basic attempt to provide rank and select functionality on a sequence
s[1..n] over alphabet [1..Ïƒ ] is to store s in plain form and the values s.ranka(k Â· i) for
all a âˆˆ [1..Ïƒ ] and i âˆˆ [1..n/k], where k âˆˆ [1..n] is a sampling parameter. This yields
constant-time access, O(k/ logÏƒ n) time rank, and O(k/ logÏƒ n + lg lgn) time select
if we process Î˜(logÏƒ n) characters of s in constant time using universal tables, and
organize the rank values for each character in predecessor data structures. The total
space is n lgÏƒ + O((n/k)Ïƒ lgn). For example, we can choose k = Ïƒ lgn to achieve
total space n lgÏƒ + O(n) (that is, the data plus the redundancy space). Within this
space we can achieve time complexity O(Ïƒ lgÏƒ) for rank and O(Ïƒ lgÏƒ + lg lgn) for
select.
Succinct Indexes The previous construction separates the sequence data from the
â€œindexâ€, that is, the extra data structures to provide fast rank and select. There are
much more sophisticated representations for the sequence data that offer constant-
time access to Î˜(logÏƒ n) consecutive characters of s (i.e., just as if s were stored
in plain form), yet achieving nHk(s) + o(n lgÏƒ) bits of space, for any k = o(logÏƒ n)
[23, 31, 58]. We recall that Hk(s) is the k-th order empirical entropy of s [43], a lower
bound to the space achieved by any statistical compressor that models the charac-
ter probabilities using the context of their k preceding characters, so 0 â‰¤ Hk(s) â‰¤
236 Algorithmica (2014) 69:232â€“268
Hkâˆ’1(s) â‰¤ H0(s) â‰¤ lgÏƒ . Combining such sequence representations with sophisti-
cated indexes that require o(n lgÏƒ) bits of redundancy [4, 33] (i.e., they are â€œsuc-
cinctâ€), we obtain results like row 3 of Table 1.
Bitmaps A different alternative is to maintain one bitmap ba[1..n] per character
a âˆˆ [1..Ïƒ ], marking with a 1 the positions i where s[i] = a. Then s.ranka(i) =
ba.rank1(i) and s.selecta(j) = ba.select1(j). The bitmaps can be represented in com-
pressed form using â€œFully Indexable Dictionariesâ€ (FIDs) [55], so that they oper-
ate in constant time and the total space is nH0(s) + O(n) + o(Ïƒn) bits. Even with
space-optimal FIDs [53, 54], this space is nH0(s)+ O(n)+ O( Ïƒnlgc n ) (and the time is
O(c)) for any constant c, which is acceptable only for polylog-sized alphabets, that
is, Ïƒ = O(polylog(n)). An alternative is to use weaker compressed bitmap represen-
tations [35, 50] that can support select1 in constant time and rank1 in time O(lgn),
and yield an overall space of nH0(s) + O(n) bits. This can be considered as a suc-
cinct index over a given sequence representation, or we can note that we can actually
solve s.access(i) by probing all the bitmaps ba.access(i). Although this takes at
least O(Ïƒ ) time, it is a simple illustration of another concept: rather than storing an
independent index on top of the data, the data is represented in a way that provides
access, rank and select operations with reasonable efficiency.
Wavelet Trees The wavelet tree [32] is a structure integrating data and index, that
provides more balanced time complexities. It is a balanced binary tree with one leaf
per alphabet character, and storing bitmaps in its internal nodes, where constant-
time rank and select operations are supported. By using FIDs [55] to represent those
bitmaps, wavelet trees achieve nH0(s) + O( n lgÏƒ lg lgnlgn ) bits of space and support all
three operations in time proportional to their height, O(lgÏƒ). Multiary wavelet trees
[22] replace the bitmaps by sequences over sublogarithmic-sized alphabets [1..Ïƒ â€²],
Ïƒ â€² = O(lg n) for 0 <  < 1, in order to reduce that height. The FID technique is
extended to alphabets of those sizes while retaining constant times. Multiary wavelet
trees obtain the same space as the binary ones, but their time complexities are re-
duced by an O(lg lgn) factor. Indeed, if Ïƒ is small enough, Ïƒ = O(polylog(n)), the
tree height is a constant and so are all the query times. Recently, the redundancy of
multiary (and binary) wavelet trees has been reduced to just o(n) [29], which yields
the results in the first row of Table 1.1
Huffman-Shaped Wavelet Trees Another alternative to obtain zero-order compres-
sion is to give Huffman shape to the wavelet tree [32]. This structure uses nH0(s) +
o(nH0(s)) + O(n) bits even if the internal nodes use a plain representation, using
|b| + o(|b|) bits [13, 46], for their bitmaps b. Limiting the height to O(lgÏƒ) retains
the worst-case times of the balanced version and also the given space [7]. In order to
reduce the time complexities by an O(lg lgn) factor, we can build multiary wavelet
1Because of these good results on polylog-sized alphabets, we focus on larger alphabets in this article, and
therefore do not distinguish between redundancies of the form o(n) lgÏƒ and no(lgÏƒ), writing o(n lgÏƒ) for
all. See also footnote 6 of Barbay et al. [4].
Algorithmica (2014) 69:232â€“268 237
trees over multiary Huffman trees [39]. This can be combined with the improved rep-
resentation for sequences over small alphabets [29] so as to retain the nH0(s)+ o(n)
bits of space and O(1 + lgÏƒlg lgn ) worst-case times of balanced multiary wavelet trees.
The interesting aspect of using Huffman-shaped trees is that, if the access queries dis-
tribute uniformly over the text positions, and the character arguments a to ranka and
selecta are chosen according to their frequency in s, then the average time complex-
ities are O(1 + H0(s)lg lgn ), the weighted leaf depth. This result [7, Theorem 5] improves
upon the multiary wavelet tree representation [29] in the average case. We note that
this result [7] involves O(Ïƒ lgn) extra bits of space redundancy, which is negligible
only for Ïƒ = o(n/ lgn).
Reducing to Permutations A totally different sequence representation [28] improves
the times to poly-loglogarithmic on Ïƒ , that is, exponentially faster than multiary
wavelet trees when Ïƒ is large enough. Yet, this representation requires again un-
compressed space, n lgÏƒ + O( n lgÏƒlg lgÏƒ ).2 It cuts the sequence into chunks of length Ïƒ
and represents each chunk using a permutation Ï€ (which acts as an inverted index of
the characters in the chunk). As both operations Ï€() and Ï€âˆ’1() are needed, a repre-
sentation [47] that stores the permutation within (1 + )Ïƒ lgÏƒ bits and computes Ï€()
in constant time and Ï€âˆ’1() in time O(1/) is used. Depending on whether Ï€ or Ï€âˆ’1
is represented explicitly, constant time is achieved for select or for access. Using a
constant value for  yields a slightly larger representation that solves both access
and select in constant time. Later, the space of this representation was reduced to
nH0(s) + o(n lgÏƒ) bits while retaining the time complexities of one of the variants
(constant-time select) [4]. In turn, the variant offering constant-time access was su-
perseded by the index of Grossi et al. [33], which achieves high-order compression
and also improves upon a slower alternative that takes the same space [4]. The best
current times are either constant or O(lg lgÏƒ). We summarize them in rows 2 to 4.
Our contribution, in rows 5 to 7 of Table 1, is to retain times loglogarithmic on Ïƒ ,
as in rows 2 to 4, while compressing the redundancy space. This is achieved only with
space H0(s), not Hk(s). We also achieve average times depending on H0(s) instead
of lgÏƒ .
3 Alphabet Partitioning
Let s[1..n] be a sequence over effective alphabet [1..Ïƒ ].3 We represent s using an
alphabet partitioning scheme. Our data structure has three components:
1. A character mapping m[1..Ïƒ ] that separates the alphabet into sub-alphabets. That
is, m is the sequence assigning to each character a âˆˆ [1..Ïƒ ] the sub-alphabet
m[a] = âŒˆlg(n/|s|a) lgn
âŒ‰
,
2The representation actually compresses to the k-th order entropy of a different sequence, not s (A. Golyn-
ski, personal communication).
3By effective we mean that every character appears in s, and thus Ïƒ â‰¤ n. In Sect. 3.3 we handle the case
of larger alphabets.
238 Algorithmica (2014) 69:232â€“268
where |s|a denotes the number of occurrences of character a in s; note that m[a] â‰¤
lg2 n for any a âˆˆ [1..Ïƒ ].
2. The sequence t[1..n] of the sub-alphabets assigned to each character in s. That is,
t is the sequence over [1..lg2 n] obtained from s by replacing each occurrence
of a by m[a], namely t[i] = m[s[i]].
3. The subsequences s[1..Ïƒ] of characters of each sub-alphabet. For 0 â‰¤  â‰¤
lg2 n, let Ïƒ = |m|, that is, the number of distinct characters of s replaced by 
in t . Then s[1..|t |] is the sequence over [1..Ïƒ] defined by
s
[
t.rank(i)
] = m.rank
(
s[i]),
for all 1 â‰¤ i â‰¤ n such that t[i] = .
Example 1 Let s = "alabar a la alabarda". Then n = 20 and |s|a = 9,
|s|l = |s|" = 3, |s|b = |s|r = 2, and |s|d = 1. Accordingly, we define the map-
ping as m[a] = 5, m[l] = m["] = 12, m[b] = m[r] = 15, and m[d] = 19. As
this is the effective alphabet, and assuming that the order is "",a,b,d,l,r",
we have m = (12,5,15,19,12,15). So the sequence of sub-alphabet identifiers
is t[1..20] = (5,12,5,15,5,15,12,5,12,12,5,12,5,12,5,15,5,15,19,5),
and the subsequences are s5 = (1,1,1,1,1,1,1,1,1), s12 = (2,1,1,2,1,2),
s15 = (1,2,1,2), and s19 = (1).
With these data structures we can implement the queries on s as follows:
s.access(i) = m.select
(
s.access
(
t.rank(i)
))
, where  = t.access(i);
s.ranka(i) = s.rankc
(
t.rank(i)
)
, where  = m.access(a) and c = m.rank(a);
s.selecta(i) = t.select
(
s.selectc(i)
)
, where  = m.access(a) and c = m.rank(a).
Example 2 In the representation of Example 1, we solve s.access(6) by first
computing  = t.access(6) = 15 and then m.select15(s15.access(t.rank15(6))) =
m.select15(s15.access(2)) = m.select15(2) = r. Similarly, to solve s.rankl(14)
we compute  = m.access(l) = 12 and c = m.rank12(l) = 2. Then we re-
turn s12.rank2(t.rank12(14)) = s12.rank2(6) = 3. Finally, to solve s.selectr(2), we
compute  = m.access(r) = 15 and c = m.rank15(r) = 2, and return
t.select15(s15.select2(2)) = t.select15(4) = 18.
3.1 Space Analysis
Recall that the zero-order entropy of s[1..n] is defined as
H0(s) =
âˆ‘
aâˆˆ[1..Ïƒ ]
|s|a
n
lg
n
|s|a . (1)
Recall also that, by convexity, nH0(s) â‰¥ (Ïƒ âˆ’ 1) lgn + (n âˆ’ Ïƒ + 1) lg nnâˆ’Ïƒ+1 . The
next lemma gives the key result for the space analysis.
Algorithmica (2014) 69:232â€“268 239
Lemma 1 Let s, t , Ïƒ and s be as defined above. Then nH0(t) + âˆ‘ |s| lgÏƒ âˆˆ
nH0(s) + o(n).
Proof First notice that, for any character 1 â‰¤  â‰¤ lg2 n it holds that
âˆ‘
c,=m[c]
|s|c = |s|. (2)
Now notice that, if m[a] = m[b] = , then
 = âŒˆlg(n/|s|a) lgn
âŒ‰ = âŒˆlg(n/|s|b) lgn
âŒ‰
,
therefore lg(n/|s|b) âˆ’ lg(n/|s|a) < 1/ lgn,
and so |s|a < 21/ lgn|s|b. (3)
Now, fix a, call  = m[a], and sum Eq. (3) over all those b such that m[b] = . The
second step uses Eq. (2):
âˆ‘
b,=m[b]
|s|a <
âˆ‘
b,=m[b]
21/ lgn|s|b,
Ïƒ|s|a < 21/ lgn|s|,
Ïƒ < 21/ lgn|s|/|s|a. (4)
Since
âˆ‘
a |s|a =
âˆ‘
 |s| = n, we have, using Eq. (1), (2), and (4),
nH0(t) +
âˆ‘

|s| lgÏƒ
=
âˆ‘

|s| lg(n/|s|) +
âˆ‘

âˆ‘
a,=m[a]
|s|a lgÏƒ
<
âˆ‘

âˆ‘
a,=m[a]
|s|a lg(n/|s|) +
âˆ‘

âˆ‘
a,=m[a]
|s|a lg
(
21/ lgn|s|/|s|a
)
=
âˆ‘

âˆ‘
a,=m[a]
|s|a lg(n/|s|a) +
âˆ‘

âˆ‘
a,=m[a]
|s|a/ lgn
=
âˆ‘
a
|s|a lg(n/|s|a) + n/ lgn
âˆˆ nH0(s) + o(n). 
In other words, if we represent t with H0(t) bits per character and each s with
lgÏƒ bits per character, we achieve a good overall compression. Thus we can obtain
a very compact representation of a sequence s by storing a compact representation of
t and storing each s as an â€œuncompressedâ€ sequence over an alphabet of size Ïƒ.
240 Algorithmica (2014) 69:232â€“268
3.2 Concrete Representation
We represent t and m as multiary wavelet trees [22]; we represent each s as either
a multiary wavelet tree or an instance of Golynski et al.â€™s [28, Theorem 2.2] ac-
cess/rank/select data structure, depending on whether Ïƒ â‰¤ lgn or not. The wavelet
tree for t uses at most nH0(t) + O( n(lg lgn)2lgn ) bits and operates in constant time,
because its alphabet size is polylogarithmic (i.e., lg2 n). If s is represented as a
wavelet tree, it uses at most |s|H0(s) + O( |s| lgÏƒ lg lgnlgn ) bits4 and again operates in
constant time because Ïƒ â‰¤ lgn; otherwise it uses at most |s| lgÏƒ + O( |s| lgÏƒlg lgÏƒ ) â‰¤
|s| lgÏƒ + O( |s| lgÏƒlg lg lgn ) bits (the latter because Ïƒ > lgn). Thus in either case the space
for s is bounded by |s| lgÏƒ + O( |s| lgÏƒlg lg lgn ) bits. Finally, since m is a sequence of
length Ïƒ over an alphabet of size lg2 n, the wavelet tree for m takes O(Ïƒ lg lgn)
bits and also operates in constant time. Because of the convexity property we re-
ferred to in the beginning of this section, nH0(s) â‰¥ (Ïƒ âˆ’ 1) lgn, the space for m is
O( n lg lgnlgn ) Â· H0(s).
Therefore we have nH0(t) + o(n) bits for t , âˆ‘ |s| lgÏƒ(1 + O( 1lg lg lgn )) bits
for the s sequences, and o(n)H0(s) bits for m. Using Lemma 1, this adds up to
nH0(s) + o(n)H0(s) + o(n), where the o(n) term is O( nlg lg lgn ).
Using the variant of Golynski et al.â€™s data structure [28, Theorem 4.2], that gives
constant-time select, and O(lg lgÏƒ) time for rank and access, we obtain our first
result in Table 1(row 4). To obtain our second result (row 5), we use instead Grossi et
al.â€™s result [33, Corollary 2], which gives constant-time access, and O(lg lgÏƒ) time
for rank and select. We note that their structure takes space |s|Hk(s)+ O( |s| lgÏƒlg lgÏƒ ),
yet we only need this to be at most |s| lgÏƒ + O( |s| lgÏƒlg lg lgn ).
Theorem 2 We can store s[1..n] over effective alphabet [1..Ïƒ ] in nH0(s) +
o(n)(H0(s) + 1) bits and support access, rank and select queries in O(lg lgÏƒ),
O(lg lgÏƒ), and O(1) time, respectively (variant (i)); or in O(1), O(lg lgÏƒ) and
O(lg lgÏƒ) time, respectively (variant (ii)).
We can refine the time complexity by noticing that the only non-constant times
are due to operating on some sequence s, where the alphabet is of size Ïƒ <
21/ lgn|s|/|s|a , where a is the character in question, thus lg lgÏƒ = O(lg lg(n/|s|a)).
If we assume that the characters a used in queries distribute with the same frequencies
as in sequence s (e.g., access queries refer to randomly chosen positions in s), then
the average query time becomes O(âˆ‘a |s|an lg lg n|s|a ) = O(lg H0(s)) by the log-sum
inequality.5
4This is achieved by using block sizes of length lgn2 and not
lg |s|
2 , at the price of storing universal tables
of size O(âˆšnpolylog(n)) = o(n) bits. Therefore all of our o(Â·) expressions involving n and other variables
will be asymptotic in n.
5Given Ïƒ pairs of numbers ai , bi > 0, it holds that
âˆ‘
ai lg
ai
bi
â‰¥ (âˆ‘ai ) lg
âˆ‘
aiâˆ‘
bi
. Use ai = |s|i /n and
bi = âˆ’ai lgai to obtain the result.
Algorithmica (2014) 69:232â€“268 241
Corollary 3 The O(lg lgÏƒ) time complexities in Theorem 2 are also O(lg lg(n/|s|a)),
where a stands for s[i] in the access query, and for the character argument in the
ranka and selecta queries. If these characters a distribute on queries with the same
frequencies as s, the average time complexity for those operations is O(lg H0(s)).
Finally, to obtain our last result in Table 1 we use again Golynski et al.â€™s repre-
sentation [28, Theorem 4.2]. Given |s| lgÏƒ extra space to store the inverse of a
permutation inside chunks, it answers select queries in time O(1) and access queries
in time O(1/) (these two complexities can be interchanged), and rank queries in
time O(lg lgÏƒ). While we initially considered 1/ = lg lgÏƒ to achieve the main
result, using a constant  yields constant-time select and access simultaneously.
Corollary 4 We can store s[1..n] over effective alphabet [1..Ïƒ ] in (1 + )nH0(s) +
o(n) bits, for any constant  > 0, and support access, ranka and select queries in
O(1/), O(lg lg min(Ïƒ,n/|s|a)), and O(1) time, respectively (variant (i)); or in O(1),
O(lg lg min(Ïƒ,n/|s|a)), and O(1/), respectively (variant (ii)).
3.3 Handling Arbitrary Alphabets
In the most general case, s is a sequence over an alphabet Î£ that is not an effective
alphabet, and Ïƒ characters from Î£ occur in s. Let Î£ â€² be the set of elements that
occur in s; we can map characters from Î£ â€² to elements of [1..Ïƒ ] by replacing each
a âˆˆ Î£ â€² with its rank in Î£ â€². All elements of Î£ â€² are stored in the â€œindexed dictionaryâ€
(ID) data structure described by Raman et al. [55], so that the following queries are
supported in constant time: for any a âˆˆ Î£ â€² its rank in Î£ â€² can be found (for any
a /âˆˆ Î£ â€² the answer is âˆ’1); and for any i âˆˆ [1..Ïƒ ] the i-th smallest element in Î£ â€² can
be found. The ID structure uses Ïƒ lg(eÎ¼/Ïƒ)+ o(Ïƒ )+ O(lg lgÎ¼) bits of space, where
e is the base of the natural logarithm and Î¼ is the maximal element in Î£ â€²; the value
of Î¼ can be specified with additional O(lgÎ¼) bits. We replace every element in s by
its rank in Î£ â€², and the resulting sequence is stored using Theorem 2. Hence, in the
general case the space usage is increased by Ïƒ lg(eÎ¼/Ïƒ) + o(Ïƒ ) + O(lgÎ¼) bits and
the asymptotic time complexity of queries remains unchanged. Since we are already
spending O(Ïƒ lg lgn) bits in our data structure, this increases the given space only by
O(Ïƒ lg(Î¼/Ïƒ)).
3.4 Application to Fast Encode/Decode
Given a sequence s to encode, we can build mapping m from its character frequencies
|s|a , and then encode each s[i] as the pair (m[s[i]],m.rankm[s[i]](s[i])). Lemma 1
(and some of the discussion that follows in Sect. 3.2) shows that the overall output
size is nH0(s)+ o(n) bits if we represent the sequence of pairs by partitioning it into
three sequences: (1) the left part of the pairs in one sequence, using Huffman coding
on chunks (see next); (2) the right part of the pairs corresponding to values where
Ïƒ < lgn in a second sequence, using Huffman coding on chunks; (3) the remaining
right parts of the pairs, using plain encoding in lgÏƒ bits (note Ïƒ = m.rank(Ïƒ )).
The Huffman coding on chunks groups lgn4 lg lgn characters, so that even in the case of
242 Algorithmica (2014) 69:232â€“268
the left parts, where the alphabet is of size lg2 n, the total length of a chunk is at
most lgn2 bits, and hence the Huffman coding table occupies just O(
âˆš
n lgn) bits. The
redundancy on top of H0(s) adds up to O( n lg lgnlgn ) bits in sequences (1) and (2) (one
bit of Huffman redundancy per chunk) and O( nlg lgn ) in sequence (3) (one bit, coming
from the ceil function, per lgÏƒ > lg lgn encoded bits).
The overall encoding time is O(n). A pair (, o) is decoded as s[i] = m.select(o),
where after reading  we can compute Ïƒ to determine whether o is encoded in se-
quence (2) or (3). Thus decoding also takes constant time if we can decode Huffman
codes in constant time. This can be achieved by using canonical codes and limiting
the height of the tree [24, 45].
This construction gives an interesting space/time tradeoff with respect to classi-
cal alternatives. Using just Huffman coding yields O(n) encoding/decoding time,
but only guarantees nH0(s) + O(n) bits of space. Using arithmetic coding achieves
nH0(s) + O(1) bits, but encoding/decoding is not linear-time. The tradeoff given by
our encoding, nH0(s)+ o(n) bits and linear-time decoding, is indeed the reason why
it is used in practice in various folklore applications, as mentioned in the Introduction.
In Sect. 8.2 we experimentally evaluate these ideas and show they are practical. Next,
we give more far-fetched applications of the rank/select capabilities of our structure,
which go much beyond the mere compression.
4 Applications to Text Indexing
Our main result can be readily carried over various types of indexes for text collec-
tions. These include self-indexes for general texts, and positional and non-positional
inverted indexes for natural language text collections.
4.1 Self-Indexes
A self-index represents a sequence and supports operations related to text searching
on it. A well-known self-index [22] achieves k-th order entropy space by partitioning
the Burrows-Wheeler transform [12] of the sequence and encoding each partition
to its zero-order entropy. Those partitions must support queries access and rank.
By using Theorem 2(i) to represent such partitions, we achieve the following result,
improving previous ones [4, 22, 28].
Theorem 5 Let s[1..n] be a sequence over effective alphabet [1..Ïƒ ]. Then we can
represent s using nHk(s) + o(n)(Hk(s) + 1) bits, for any k â‰¤ (Î´ logÏƒ n) âˆ’ 1 and
constant 0 < Î´ < 1, while supporting the following queries:
(i) count the number of occurrences of a pattern p[1..m] in s, in time O(m lg lgÏƒ);
(ii) locate any such occurrence in time O(lgn lg lg lgn lg lgÏƒ);
(iii) extract s[l, r] in time O((r âˆ’ l) lg lgÏƒ + lgn lg lg lgn lg lgÏƒ).
Proof To achieve nHk(s) space, the Burrows-Wheeler transformed text sbwt is par-
titioned into r â‰¤ Ïƒk sequences s1 Â· Â· Â· sr [22]. Since k â‰¤ (Î´ logÏƒ n) âˆ’ 1, it follows
Algorithmica (2014) 69:232â€“268 243
that Ïƒk+1 â‰¤ nÎ´ . The space our Theorem 2(i) achieves using such a partition is
âˆ‘
i |si |H0(si) + (H0(si) + 1) Â· O( |s
i |
lg lg lg |si | ). Let Î³ = (1 âˆ’ Î´)/2 (so 0 < Î´ + Î³ < 1
whenever 0 < Î´ < 1) and classify the sequences si according to whether |si | < nÎ³
(short sequences) or not (long sequences). The total space occupied by the short se-
quences can be bounded by r Â· O(nÎ³ lgÏƒ) = O(nÎ´+Î³ ) = o(n) bits. In turn, the space
occupied by the long sequences can be bounded by
âˆ‘
i (1 + clg lg lgn ) Â· |si |H0(si) +
d|si |
lg lg lgn bits, for some constants c, d . An argument very similar to the one used by
Ferragina et al. [22, Theorem 4.2] shows that these add up to (1+ clg lg lgn ) Â·nHk(s)+
dn
lg lg lgn . Thus the space is nHk(s) + o(n)(Hk(s) + 1). Other structures required by
the alphabet partitioning technique [22] add o(n) more bits if Ïƒk+1 â‰¤ nÎ´ .
The claimed time complexities stem from the rank and access times on the par-
titions. The partitioning scheme [22] adds just constant time overheads. Finally,
to achieve the claimed locating and extracting times we sample one out of every
lgn lg lg lgn text positions. This maintains our lower-order space term o(n) within
O( nlg lg lgn ). 
In case [1..Ïƒ ] is not the effective alphabet we proceed as described in Sect. 3.3.
Our main improvement compared to Theorem 4.2 of Barbay et al. [4] is that we
have compressed the redundancy from o(n lgÏƒ) to o(n)(Hk(s) + 1). Our improved
locating times, instead, just owe to the denser sampling, which Barbay et al. could
also use.
Note that, by using the zero-order representation of Golynski et al. [29, Theo-
rem 4], we could achieve even better space, nHk(s) + o(n) bits, and time complexi-
ties O(1 + lgÏƒlg lgn ) instead of O(lg lgÏƒ).6 Such complexities are convenient for not so
large alphabets.
4.2 Positional Inverted Indexes
These indexes retrieve the positions of any word in a text. They may store the text
compressed up to the zero-order entropy of the word sequence s[1..n], which allows
direct access to any word. In addition they store the list of the positions where each
distinct word occurs. These lists can be compressed up to a second zero-order entropy
space [48], so the overall space is at least 2nH0(s). By regarding s as a sequence over
an alphabet [1..Î½] (corresponding here to the vocabulary), Theorem 2 represents s
within nH0(s) + o(n)(H0(s) + 1) bits, which provides state-of-the-art compression
ratios. Variant (ii) supports constant-time access to any text word s[i], and access to
the j th entry of the list of any word a (s.selecta(j)) in time O(lg lgÎ½). These two time
complexities are exchanged in variant (i), or both can be made constant by spending
nH0(s) redundancy for any constant  > 0 (using Corollary 4). The length of the
inverted lists can be stored within O(Î½ lgn) bits (we also need at least this space to
store the sequence content of each word identifier).
6One can retain lg lgn in the denominator by using block sizes depending on n and not on |si |, as explained
in the footnote at the beginning of Sect. 3.2.
244 Algorithmica (2014) 69:232â€“268
Apart from supporting this basic access to the list of each word, this represen-
tation easily supports operations that are more complex to implement on explicit
inverted lists [5]. For example, we can find the phrases formed by two words w1
and w2, that appear n1 and n2 times, by finding the occurrences of one and verify-
ing the other in the text, in time O(min(n1, n2) lg lgÎ½). Other more sophisticated
intersection algorithms [5] can be implemented by supporting operations such as
â€œfind the position in the list of w2 that follows the j th occurrence of word w1â€
(s.rankw2(s.selectw1(j))+ 1, in time O(lg lgÎ½)) or â€œgive the list of word w restricted
to the range [x..y] in the collectionâ€ (s.selectw(s.rankw(x âˆ’ 1) + j), for j â‰¥ 1, until
exceeding y, in time O(lg lgÎ½) plus O(1) per retrieved occurrence). In Sect. 8.4 we
evaluate this representation in practice.
4.3 Binary Relations and Non-positional Inverted Indexes
Let R âŠ† LÃ—O , where L = [1..Î»] are called labels and O = [1..Îº] are called objects,
be a binary relation consisting of n pairs. Barbay et al. [3] represent the relation
as follows. Let li1 < li2 < Â· Â· Â· < lik be the labels related to an object o âˆˆ O . Then
we define sequence so = li1 li2 Â· Â· Â· lik . The representation for R is the concatenated
sequence s = s1 Â· s2 Â· Â· Â· sÎº , of length n, and the bitmap b = 10|s1|10|s2| Â· Â· Â·10|sÎº |1, of
length n + Îº + 1.
This representation allows one to efficiently support various queries [3]:
table_access: is l related to o?, s.rankl (b.rank0(b.select1(o + 1))) >
s.rankl(b.rank0(b.select1(o)));
object_select: the ith label related to an object o,
s.access(b.rank0(b.select1(o) + i));
object_nb: the number of labels an object o is related to, b.select1(o + 1) âˆ’
b.select1(o) âˆ’ 1;
object_rank: the number of labels < l an object o is related to, carried out with
a predecessor search in s[b.rank0(b.select1(o))..b.rank0(b.select1(o + 1))], an
area of length O(Î»). The predecessor data structure requires o(n) bits as it is
built over values sampled every lg2 Î» positions, and the query is completed with
a binary search;
label_select: the ith object related to a label l, b.rank1(b.select0(s.selectl (i)));
label_nb: the number of objects a label l is related to, s.rankl (n). It can also be
solved like object_nb, using a bitmap similar to b that traverses the table
label-wise;
label_rank: the number of objects <o a label l is related to,
s.rankl(b.rank0(b.select1(o))).
Bitmap b can be represented within O(Îº lg n
Îº
) = o(n) + O(Îº) bits and support all
the operations in constant time [55], and its label-wise variant needs o(n) + O(Î»)
bits. The rest of the space and time complexities depend on how we represent s.
Barbay et al. [3] used Golynski et al.â€™s representation for s [28], so they achieved
n lgÎ» + o(n lgÎ») bits of space, and the times at rows 2 or 3 in Table 1 for the op-
erations on s (later, Barbay et al. [4] achieved nHk(s) + o(n lgÎ») bits and slightly
worse times). By instead representing s using Theorem 2, we achieve compressed
redundancy and slightly improve the times.
Algorithmica (2014) 69:232â€“268 245
To summarize, we achieve nH0(s)+ o(n)(H0(s)+ 1)+ O(Îº + Î») bits, and solve
label_nb and object_nb in constant time, and table_access and la-
bel_rank in time O(lg lgÎ»). For label_select, object_select and ob-
ject_rank we achieve times O(1), O(lg lgÎ») and O((lg lgÎ»)2), respectively, or
O(lg lgÎ»), O(1) and O(lg lgÎ»), respectively. Corollary 4 yields a slightly larger
representation with improved times, and a multiary wavelet tree [29, Theorem 4]
achieves less space and different times; we leave the details to the reader.
A non-positional inverted index is a binary relation that associates each vocab-
ulary word with the documents where it appears. A typical representation of the
lists encodes the differences between consecutive values, achieving overall space
O(âˆ‘v nv lg nnv ), where word v appears in nv documents [61]. In our representation as
a binary relation, it turns out that H0(s) = âˆ‘v nv lg nnv , and thus the space achieved is
comparable to the classical schemes. Within this space, however, the representation
offers various interesting operations apart from accessing the ith element of a list
(using label_select), including support for various list intersection algorithms;
see Barbay et al. [3, 4] for more details.
5 Compressing Permutations
Barbay and Navarro [6] measured the compressibility of a permutation Ï€ in terms
of the entropy of the distribution of the lengths of runs of different kinds. Let Ï€ be
covered by Ï runs (using any of the previous definitions of runs [6, 40, 44]) of lengths
runs(Ï€) = ã€ˆn1, . . . , nÏã€‰. Then H(runs(Ï€)) = âˆ‘ nin lg nni â‰¤ lgÏ is called the entropy
of the runs (and, because ni â‰¥ 1, it also holds nH(runs(Ï€)) â‰¥ (Ï âˆ’ 1) lgn). In their
most recent variant [7] they were able to store Ï€ in 2nH(runs(Ï€))+o(n)+ O(Ï lgn)
bits for runs consisting of interleaved sequences of increasing or decreasing values,
and nH(runs(Ï€)) + o(n) + O(Ï lgn) bits for contiguous sequences of increasing or
decreasing values (or, alternatively, interleaved sequences of consecutive values). In
all cases they can compute Ï€() and Ï€âˆ’1() in O( lgÏlg lgn ) time, which on average drops
to O(1 + H(runs(Ï€))lg lgn ) if the queries are uniformly distributed in [1..n].
We now show how to use access/rank/select data structures to support the opera-
tions more efficiently while retaining compressed redundancy space. In general terms,
we exchange their O(Ï lgn) space term by o(n)H(runs(Ï€)), and improve their times
to O(lg lgÏ) in the worst case, and to O(lg H(runs(Ï€))) on average (again, this is an
improvement only if Ï is not too small).
We first consider interleaved sequences of increasing or decreasing values as first
defined by Levcopoulos and Petersson [40] for adaptive sorting, and later on for com-
pression [6], and then give improved results for more restricted classes of runs. In
both cases we first consider the application of the permutation Ï€() and its inverse,
Ï€âˆ’1(), and later show how to extend the support to the iterated application of the
permutation, Ï€k(), extending and improving previous results [47].
Theorem 6 Let Ï€ be a permutation on n elements that consists of Ï interleaved
increasing or decreasing runs, of lengths runs(Ï€). Suppose we have a data structure
that stores a sequence s[1..n] over effective alphabet [1..Ï] within Ïˆ(n,Ï, H0(s))
246 Algorithmica (2014) 69:232â€“268
bits, supporting queries access, rank, and select in time Ï„(n,Ï). Then, given its run
decomposition, we can store Ï€ in 2Ïˆ(n,Ï, H(runs(Ï€))) + Ï bits, and perform Ï€()
and Ï€âˆ’1() queries in time O(Ï„ (n,Ï)).
Proof We first replace all the elements of the r th run by r , for 1 â‰¤ r â‰¤ Ï. Let s be
the resulting sequence and let sâ€² be s permuted according to Ï€ , that is, sâ€²[Ï€(i)] =
s[i]. We store s and sâ€² using the given sequence representation, and also store Ï bits
indicating whether each run is increasing or decreasing. Note that H0(s) = H0(sâ€²) =
H(runs(Ï€)), which gives the claimed space.
Notice that an increasing run preserves the relative order of the elements of a
subsequence. Therefore, if Ï€(i) is part of an increasing run, then sâ€².ranks[i](Ï€(i)) =
s.ranks[i](i), so
Ï€(i) = sâ€².selects[i]
(
s.ranks[i](i)
)
.
If, instead, Ï€(i) is part of a decreasing run, then sâ€².ranks[i](Ï€(i)) = s.ranks[i](n) +
1 âˆ’ s.ranks[i](i), so
Ï€(i) = sâ€².selects[i]
(
s.ranks[i](n) + 1 âˆ’ s.ranks[i](i)
)
.
A Ï€âˆ’1() query is symmetric (exchange s and sâ€² in the formulas). Therefore we com-
pute Ï€() and Ï€âˆ’1 with O(1) calls to access, rank, and select on s or sâ€². 
Example 3 Let Ï€ = 1,8,9,3,6,10,5,4,11,7,2,12 be formed by three runs (indi-
cated by the different fonts). Then s = (1,2,3,1,2,3,1,2,3) and sâ€² = (1,2,1,2,1,
2,1,2,3,3,3,3).
By combining Theorem 6 with the representations in Theorem 2, we obtain a result
that improves upon previous work [6, 7] in time complexity. Note that if the queried
positions i are uniformly distributed in [1..n], then all the access, rank, and select
queries follow the same character distribution of the runs, and Corollary 3 applies.
Note also that the Ï bits are contained in o(n)H(runs(Ï€)) because nH(runs(Ï€)) â‰¥
(Ï âˆ’ 1) lgn.
Corollary 7 Let Ï€ be a permutation on n elements that consists of Ï interleaved
increasing or decreasing runs, of lengths runs(Ï€). Then, given its run decomposition,
we can store Ï€ in 2nH(runs(Ï€)) + o(n)(H(runs(Ï€)) + 1) bits and perform Ï€() and
Ï€âˆ’1() queries in O(lg lgÏ) time. On uniformly distributed queries the average times
are O(lg H(runs(Ï€))).
The case where the runs are contiguous is handled within around half the space,
as a simplification of Theorem 6.
Corollary 8 Let Ï€ be a permutation on n elements that consists of Ï con-
tiguous increasing or decreasing runs, of lengths runs(Ï€). Suppose we have a
data structure that stores a sequence s[1..n] over effective alphabet [1..Ï] within
Ïˆ(n,Ï, H0(s)) bits, supporting queries access and rank in time Ï„ar(n,Ï), and
Algorithmica (2014) 69:232â€“268 247
select in time Ï„s(n,Ï). Then, given its run decomposition, we can store Ï€ in
Ïˆ(n,Ï, H(runs(Ï€)))+ Ï lg n
Ï
+ O(Ï)+ o(n) bits of space, and perform Ï€() queries
in time O(Ï„s(n,Ï)) and Ï€âˆ’1() queries in time O(Ï„ar(n,Ï)).
Proof We proceed as in Theorem 6, yet now sequence s is of the form s =
1n12n2 Â· Â· Â·ÏnÏ , and therefore it can be represented as a bitmap b = 10n1âˆ’110n2âˆ’1 Â· Â· Â·
10nÏâˆ’11. The required operations are implemented as follows: s.access(i) =
b.rank1(i), s.ranks[i](i) = iâˆ’b.select1(s[i])+1, s.ranks[i](n) = b.select1(s[i]+1)âˆ’
b.select1(s[i]), and s.selecta(i) = b.select1(a) + i âˆ’ 1. Those operations are solved
in constant time using a representation for b that takes (Ï +1) lg(e(n+1)/(Ï +1))+
o(n) bits [55]. Added to the Ï bits that mark increasing or decreasing sequences, this
gives the claimed space. The claimed time complexities correspond to the operations
on sâ€², as those in s take constant time. 
Once again, by combining the corollary with representation (i) in Theorem 2,
we obtain results that improve upon previous work [6, 7]. The Ï lg n
Ï
bits are in
o(n)(H(runs(Ï€)) + 1) because they are o(n) as long as Ï = o(n), and otherwise
they are O(Ï) = o(Ï lgn), and (Ï âˆ’ 1) lgn â‰¤ nH(runs(Ï€)).
Corollary 9 Let Ï€ be a permutation on n elements that consists of Ï contiguous
increasing or decreasing runs, of lengths runs(Ï€). Then, given its run decomposition,
we can store Ï€ in nH(runs(Ï€))+o(n)(H(runs(Ï€))+1) bits and perform Ï€() queries
in time O(1) and Ï€âˆ’1() queries in time O(lg lgÏ) (and O(lg H(runs(Ï€))) on average
for uniformly distributed queries).
If Ï€ is formed by interleaved but strictly incrementing (+1) or decrementing (âˆ’1)
runs, then Ï€âˆ’1 is formed by contiguous runs, in the same number and length [6]. This
gives an immediate consequence of Corollary 8.
Corollary 10 Let Ï€ be a permutation on n elements that consists of Ï inter-
leaved strict increasing or decreasing runs, of lengths runs(Ï€). Suppose we have
a data structure that stores a sequence s[1..n] over effective alphabet [1..Ï] within
Ïˆ(n,Ï, H0(s)) bits, supporting queries access and rank in time Ï„ar(n,Ï), and
select in time Ï„s(n,Ï). Then, given its run decomposition, we can store Ï€ in
Ïˆ(n,Ï, H(runs(Ï€)))+ Ï lg n
Ï
+ O(Ï)+ o(n) bits of space, and perform Ï€() queries
in time O(Ï„ar(n,Ï)) and Ï€âˆ’1() queries in time O(Ï„s(n,Ï)).
For example we can achieve the same space of Corollary 9, yet with the times for
Ï€ and Ï€âˆ’1 reversed. Finally, if we consider runs for Ï€ that are both contiguous and
incrementing or decrementing, then so are the runs of Ï€âˆ’1. Corollary 8 can be further
simplified as both s and sâ€² can be represented with bitmaps.
Corollary 11 Let Ï€ be a permutation on n elements that consists of Ï contiguous
and strict increasing or decreasing runs, of lengths runs(Ï€). Then, given its run de-
composition, we can store Ï€ in 2Ï lg n
Ï
+ O(Ï) + o(n) bits, and perform Ï€() and
Ï€âˆ’1() in O(1) time.
248 Algorithmica (2014) 69:232â€“268
We now show how to achieve exponentiation, Ï€k(i) or Ï€âˆ’k(i), within compressed
space. Munro et al. [47] reduced the problem of supporting exponentiation on a per-
mutation Ï€ to the support of the direct and inverse application of another permutation,
related but with quite distinct runs than Ï€ . Combining it with any of our results does
yield compression, but one where the space depends on the lengths of both the runs
and cycles of Ï€ . The following construction, extending the technique by Munro et
al. [47], retains the compressibility in terms of the runs of Ï€ , which is more natural.
It builds an index that uses small additional space to support the exponentiation, thus
allowing the compression of the main data structure with any of our results.
Theorem 12 Suppose we have a representation of a permutation Ï€ on n elements
that supports queries Ï€() in time Ï„+ and queries Ï€âˆ’1() in time Ï„âˆ’. Then for
any t â‰¤ n, we can build a data structure that takes O((n/t) lgn) bits and, used
in conjunction with operation Ï€() or Ï€âˆ’1(), supports Ï€k() and Ï€âˆ’k() queries in
O(t min(Ï„+, Ï„âˆ’)) time.
Proof The key to computing iâ€² = Ï€k(i) is to discover that i is in a cycle of length
 and to assign it a position 0 â‰¤ j <  within its cycle (note j is arbitrary, yet we
must operate consistently once it is assigned). Then Ï€k(i) lies in the same cycle, at
position j â€² = (j + k mod), hence Ï€k(i) = Ï€j â€²âˆ’j (i) or Ï€j â€²+âˆ’j (i). Thus all we need
is to find out j and , compute j â€², and finally find the position iâ€² in Ï€ that corresponds
to the j â€²th element of the cycle. We decompose Ï€ into its cycles and, for every cycle
of length at least t , store the cycleâ€™s length  and an array containing the position
i in Ï€ of every t th element in the cycle. Those positions i are called â€˜markedâ€™. We
also store a binary sequence b[1..n], so that b[i] = 1 iff i is marked. For each marked
element i we record to which cycle i belongs and the position j of i in its cycle. To
compute Ï€k(i), we repeatedly apply Ï€() at most t times until we either loop or find a
marked element. In the first case, we have found , so we can assume j = 0, compute
j â€² <  â‰¤ t , and apply Ï€() at most t more times to find iâ€² = Ï€j â€²(i) = Ï€k(i) in the loop.
If we reach a marked element, instead, we have stored the cycle identifier to which i
belongs, as well as j and . Then we compute j â€² and know that the previous marked
position is jâˆ— = t Â· j â€²/t. The corresponding position iâˆ— is found at cell jâˆ—/t of the
array of positions of marked elements, and we finally move from iâˆ— to iâ€² by applying
j â€² âˆ’jâˆ— â‰¤ t times operation Ï€(), i = Ï€j â€²âˆ’jâˆ—(iâˆ—) = Ï€k(i). A Ï€âˆ’k query is similar (note
that it does not need to use Ï€âˆ’1() as we can always move forward). Moreover, we can
also proceed using Ï€âˆ’1() instead of Ï€(), whichever is faster, to compute both Ï€k()
and Ï€âˆ’k(). The space is O((n/t) lgn) both for the samples and for a compressed
representation of bitmap b. Note that we only compute rank at the positions i such
that b[i] = 1. Thus we can use the ID structure [55], which uses O((n/t) lg t) bits. 
5.1 Application to Self-Indexes
These results on permutations apply to a second family of self-indexes, which is
based on the representation of the so-called Î¨ function [32, 35, 57]. Given the suf-
fix array A[1..n] of sequence s[1..n] over alphabet [1..Ïƒ ], Î¨ is defined as Î¨ (i) =
Algorithmica (2014) 69:232â€“268 249
Aâˆ’1[(A[i]modn)+ 1]. Counting, locating, and extracting is carried out through per-
mutation Î¨ , which replaces s and A. It is known [35] that Î¨ contains Ïƒ contigu-
ous increasing runs so that H(runs(Î¨ )) = H0(s), which allows for its compression.
Grossi et al. [32] represented Î¨ within nHk(s) + O(n) bits, while supporting op-
eration Î¨ () in constant time, or within nHk(s) + o(n lgÏƒ) while supporting Î¨ ()
in time O(lgÏƒ). By using Corollary 9, we can achieve the unprecedented space
nH0(s) + o(n)(H0(s) + 1) and support Î¨ () in constant time. In addition we can
support the inverse Î¨ âˆ’1() in time O(lg lgÏƒ). Having both Î¨ () and Î¨ âˆ’1() allows for
bidirectional indexes [56], which can for example display a snippet around any oc-
currence found without the need for any extra space for sampling. Our construction
of Theorem 12 can be applied on top of any of those representations so as to support
operation Î¨ k(), which is useful for example to implement compressed suffix trees,
yet the particularities of Î¨ allow for sublogarithmic-time solutions [32]. Note also
that using Huffman-shaped wavelet trees to represent the permutation [7] yields even
less space, nH0(s)+o(n)+ O(Ïƒ lgn) bits, and the time complexities are relevant for
not so large alphabets.
6 Compressing Functions
Hreinsson, KrÃ¸yer and Pagh [38] recently showed how, given a domain X =
{x1, x2, . . . , xn} âŠ‚ N of numbers that fit in a machine word, they can represent any
f : X â†’ [1..Ïƒ ] in compressed form and provide constant-time evaluation. Let us
identify function f with the sequence of values f [1..n] = f (x1)f (x2) Â· Â· Â·f (xn).
Then their representation uses at most (1 + )nH0(f ) + O(n) + o(Ïƒ ) bits, for any
constant  > 0. We note that this bound holds even when Ïƒ is much larger than n.
In the special case where X = [1..n] and Ïƒ = o(n), we can achieve constant-time
evaluation and a better space bound using our sequence representations. Moreover,
we can support extra functionality such as computing the pre-image of an element.
A first simple result is obtained by representing f as a sequence.
Lemma 13 Let f : [1..n] â†’ [1..Ïƒ ] be a function. We can represent f using
nH0(f )+o(n)(H0(f )+1)+ O(Ïƒ ) bits and compute f (i) for any i âˆˆ [1..n] in O(1)
time, and any element of f âˆ’1(a) for any a âˆˆ [1..Ïƒ ] in time O(lg lgÏƒ), or vice versa.
Using more space, (1 + )H0(f )+ o(n) bits for any constant  > 0, we support both
queries in constant time. The size |f âˆ’1(a)| is always computed in O(1) time.
Proof We represent sequence f [1..n] using Theorem 2 or Corollary 4, so f (i) =
f.access(i) and the j th element of f âˆ’1(a) is f.selecta(j). To compute |f âˆ’1(a)| in
constant time we store a binary sequence b = 10|f âˆ’1(1)|10|fâˆ’1(2)|1 Â· Â· Â·10|f âˆ’1(Ïƒ )|1, so
that |f âˆ’1(a)| = b.select1(a + 1) âˆ’ b.select1(a) âˆ’ 1. The space is the one needed
to represent s plus O(Ïƒ lg n
Ïƒ
) bits to represent b using an ID [55]. This is o(n) if
Ïƒ = o(n), and otherwise it is O(Ïƒ ). This extra space is also necessary because [1..Ïƒ ]
may not be the effective alphabet of sequence f [1..n] (if f is not surjective). 
Another source of compressibility frequently arising in real-life functions is non-
decreasing or nonincreasing runs. Let us start by allowing interleaved runs. Note that
250 Algorithmica (2014) 69:232â€“268
in this case H(runs(f )) â‰¤ H0(f ), where equality is achieved if we form runs of equal
values only.
Theorem 14 Let f : [1..n] â†’ [1..Ïƒ ] be a function such that sequence f [1..n] con-
sists of Ï interleaved non-increasing or non-decreasing runs. Then, given its run de-
composition, we can represent f in 2nH(runs(f ))+ o(n)(H(runs(f ))+ 1)+ O(Ïƒ )
bits and compute f (i) for any i âˆˆ [1..n], and any element in f âˆ’1(a) for any
a âˆˆ [1..Ïƒ ], in time O(lg lgÏ). The size |f âˆ’1(a)| is computed in O(1) time.
Proof We store function f as a combination of the permutation Ï€ that stably sorts
the values f (i), plus the binary sequence b of Lemma 13. Therefore, it holds
f (i) = b.rank1
(
b.select0
(
Ï€âˆ’1(i)
))
.
Similarly, the j th element of f âˆ’1(a) is
Ï€
(
b.rank0
(
b.select1(a)
) + j).
Since Ï€âˆ’1 has the same runs as f (the runs in f can have equal values but those of
Ï€âˆ’1 cannot), we can represent Ï€âˆ’1 using Corollary 7 to obtain the claimed time and
space complexities. 
Example 4 Let f [1..9] = Ï€âˆ’1(1,3,2,5,4,9,8,9,8). The odd positions form an
increasing run (1,2,4,8,8) and the even positions form (3,5,9,9). The permu-
tation Ï€ sorting the values is (1,3,2,5,4,7,9,6,8), and its inverse is Ï€âˆ’1 =
(1,3,2,5,4,8,6,9,7). The bitmap b is 101010101011100100.
If we consider only contiguous runs in f , we obtain the following result by repre-
senting Ï€âˆ’1 with Corollary 9. Note the entropy of contiguous runs is no longer upper
bounded by H0(f ).
Corollary 15 Let f : [1..n] â†’ [1..Ïƒ ] be a function, where sequence f consists of Ï
contiguous non-increasing or non-decreasing runs. Then, given its run decomposi-
tion, we can represent f in nH(runs(f )) + o(n)(H(runs(f )) + 1) + O(Ïƒ ) bits, and
compute any f (i) in O(1) time, as well as retrieve any element in f âˆ’1(a) in time
O(lg lgÏ). The size |f âˆ’1(a)| can be computed in O(1) time.
In all the above results we can use Huffman-shaped wavelet trees [7] to obtain an
alternative space/time tradeoff. We leave the details to the reader.
6.1 Application to Binary Relations, Revisited
Recall Sect. 4.3, where we represent a binary relation in terms of a sequence s and a
bitmap b. By instead representing s as a function, we can capture another source of
compressibility, and achieve slightly different time complexities. Note that H0(s) cor-
responds to the distribution of the number oi of objects associated with a label i, let
us call it Hlab = H0(s) = âˆ‘ oin lg noi . On the other hand, if we regard the contiguous
Algorithmica (2014) 69:232â€“268 251
increasing runs of s, the entropy corresponds to the distribution of the number li of
labels associated with an object i, let us call it Hobj = H(runs(s)) = âˆ‘ lin lg nli . While
Sect. 4.3 compresses B in terms of Hlab = H0(s), we can use Corollary 15 to achieve
nHobj + o(n)(Hobj + 1) + O(Îº + Î») bits of space. Since f.access(i) = f (i) and
f.selecta(j) is the j th element of f âˆ’1(a), this representation solves label _nb,
object_nb and object _select in constant time, and label_select and
object_rank in time O(lg lgÎ»). Operations label_rank and table_access
require f.rank, which is not directly supported. The former can be solved in time
O(lg lgÎ» lg lgÎº) as a predecessor search in Ï€ (storing absolute samples every lg2 Îº
positions ), and the latter in time O(lg lgÎ») as the difference between two ob-
ject_rank queries. We can also achieve nHobj + o(n) + O(Îº + Î») bits using
Huffman-shaped wavelet trees; we leave the details to the reader.
7 Compressing Dynamic Collections of Disjoint Sets
Finally, we now give what is, to the best of our knowledge, the first result about
storing a compressed collection of disjoint sets while supporting operations union and
find [60]. The key point in the next theorem is that, as the sets in the collection C are
merged, our space bound shrinks with the zero-order entropy of the distribution of the
function s that assigns elements to sets in C. We define H(C) = âˆ‘ ni
n
lg n
ni
â‰¤ lg |C|,
where ni are the sizes of the sets, which add up to n.
Theorem 16 Let C be a collection of disjoint sets whose union is [1..n]. For any
 > 0, we can store C in (1+ )nH(C)+ O(|C| lgn)+o(n) bits and perform any se-
quence of r union and find operations in O(rÎ±(n) + (1/)n lg lgn) total time, where
Î±(n) is the inverse Ackermannâ€™s function.
Proof We first use Theorem 2 to store the sequence s[1..n] in which s[i] is the
representative of the set containing i. We then store the representatives in a stan-
dard disjoint-set data structure D [60]. Since H0(s) = H(C), our data structures
take nH(C) + o(n)(H(C) + 1) + O(|C| lgn) bits. We can perform a query find(i)
on C by performing D.find(s[i]), and perform a union(i, j) operation on C by per-
forming D.union(D.find(s[i]),D.find(s[j ])). As we only need access functionality
on s, we use a simple variant of Theorem 2. We support only rank and select on
the multiary wavelet tree that represents sequence t , and store the s subsequences
as plain arrays. The mapping m is of length |C|, so it can easily be represented in
plain form to support constant-time operations, within O(|C| lgn) bits. This yields
constant time access, and therefore the cost of the r union and find operations is
O(rÎ±(n)) [60]. For our data structure to shrink as we merge sets, we keep track of
H(C) and, whenever it shrinks by a factor of 1 + , we rebuild our entire data struc-
ture on the updated values s[i] â† find(s[i]). First, note that all those find operations
take O(n) time because of path-compression [60]: Only the first time one accesses a
node v âˆˆ D it may occur that the representative is not directly vâ€™s parent. Thus the
overall time can be split into O(n) time for the n instructions find(s[i]) plus O(n) for
the n times a node v âˆˆ D is visited for the first time. Reconstructing the structure of
252 Algorithmica (2014) 69:232â€“268
Theorem 2 also takes O(n) time. The plain structures for m and s are easily built
in linear time, and so is the multiary wavelet tree supporting rank and access [22],
as it requires just tables of sampled counters. Since H(C) is always less than lgn,
we rebuild only O(log1+ lgn) = O((1/) lg lgn) times. Thus the overall cost of re-
building is O((1/)n lg lgn). This completes our time complexity. Finally, the space
term o(n)H(C) is absorbed by H(C) by slightly adjusting , and this gives our final
space formula. 
8 Experimental Results
In this section we explore the performance of our structure in practice. We first intro-
duce, in Sect. 8.1, a simpler and more practical alphabet partitioning scheme we call
â€œdenseâ€, which experimentally performs better than the one we describe in Sect. 3,
although in theory has an O(n)-bit redundancy term in the space. Next, in Sect. 8.2
we study the performance of both alphabet partitioning methods, as well as the opti-
mal one [59], in terms of compression ratio and decompression performance. Given
the results of these experiments, we continue only with our dense partitioning for the
rest of the section. In Sect. 8.3 we compare our new sequence representation with the
state of the art, considering the tradeoff between space and time of operations rank,
select, and access. Then, Sects. 8.4, 8.5, and 8.6 compare the same data structures on
different real-life applications of sequence representations. In the first, the operations
are used to emulate an inverted index on the compressed sequence using (almost) no
extra space. In the second, they are used to emulate self-indexes for text [48]. In the
third, they provide access to direct and reverse neighbors on graphs represented with
adjacency lists. The machine used for the experiments has an IntelÂ® XeonÂ® E5620
at 2.40 GHz, 94 GB of RAM. We did not use multithreading in our implementa-
tions; times are measured using only one thread, and in RAM. The operating system
is Ubuntu 10.04, with kernel 2.6.32-33-server.x86_64. The code was compiled us-
ing GNU/GCC version 4.4.3 with optimization flags -O9. Our code is available in
LIBCDS version 1.0.10, downloadable from http://libcds.recoded.cl/.
8.1 Dense Alphabet Partitioning
Said [59] proved that an optimal assignment to sub-alphabets must group consecutive
symbols once sorted by frequency. A simple alternative to the partitioning scheme
presented in Sect. 3, and that follows this optimality principle, is to make mapping m
group elements into consecutive chunks of doubling size, that is, m[a] = lg r(a),
where r(a) is the rank of a according to its frequency. The rest of the scheme to
define t[1..n] and the sequences s[1..Ïƒ] is as in Sect. 3. The classes are in the
range 0 â‰¤  â‰¤ lgÏƒ, and each element in s is encoded in  bits. As we use all
the available bits of each symbol in sequences s (except possibly in the last one),
we call this scheme dense. We show that this scheme is not much worse than the
one proposed in Sect. 3 (which will be called sparse). First consider the total num-
ber of bits we use to encode the sequences s,
âˆ‘
 |s| =
âˆ‘
a |s|alg r(a). Since|s|a â‰¤ n/r(a) because the symbols are sorted by decreasing frequency, it holds that
Algorithmica (2014) 69:232â€“268 253
r(a) â‰¤ n/|s|a and âˆ‘ |s|alg r(a) â‰¤ âˆ‘ |s|a lg(n/|s|a) = nH0(s). Now consider the
number of bits we use to encode t = lg r(s[1]), . . . , lg r(s[n]). We could store
each element lg r(s[i]) of t in 2lg(lg r(s[i]) + 1) âˆ’ 1 bits using Î³ -codes
[61], and such encoding would be lower bounded by nH0(t). Thus nH0(t) â‰¤ 2âˆ‘
i lg lg(r(s[i]) + 1) â‰¤ 2
âˆ‘
a |s|a lg lg(n/|s|a + 1) = O(n(lg H0(s) + 1)) =
o(nH0(s)) + O(n) (recall Sect. 3.2). It follows that the total encoding length is
nH0(s) + O(n lg H0(s)) = nH0(s) + o(nH0(s)) + O(n) bits. Apart from the pretty
tight upper bound, it is not evident whether this scheme is more or less efficient than
the sparse encoding. Certainly the dense scheme uses the least possible number of
classes (which could allow storing t in plain form using lg lgÏƒ bits per symbol). On
the other hand, the sparse method uses in general more classes, which allows for
smaller sub-alphabets using fewer bits per symbol in sequences s. As we will see in
Sect. 8.2, the dense scheme uses less space than the sparse one for t , but more for the
sequences s.
Example 5 Consider the same sequence s = "alabar a la alabarda" of
Example 1. The dense partitioning will assign m[a] = 0, m[l] = m["] = 1,
m[b] = m[r] = m[d] = 2. So the sequence of sub-alphabet identifiers is t[1..20] =
(0,1,0,2,0,2,1,0,1,1,0,1,0,1,0,2,0,2,2,0), and the subsequences are
s0 = (1,1,1,1,1,1,1,1,1), s1 = (2,1,1,2,1,2), and s2 = (1,3,1,3,2). This
dense scheme uses 16 bits for the sequences s, and the zero-order compressed t
requires nH0(t) = 30.79 bits. The overall compression is 2.34 bits per symbol. The
sparse partitioning of Example 1 used 10 bits in the sequences s, and the zero-order
compressed t required nH0(t) = 34.40 bits. The total gives 2.22 bits per symbol. In
our real applications, the dense partitioning performs better.
Note that the question of space optimality is elusive in this scenario. Since the
encoding in t plus that in the corresponding sequence s forms a unique code per
symbol, the optimum is reached when we choose one sub-alphabet per symbol, so
that the sequences s require zero bits and all the space is in nH0(t) = nH0(s). The
alphabet partitioning always gives away some space, in exchange for faster decom-
pression (or, in our case, faster rank/select/access operations). Saidâ€™s optimal parti-
tioning [59] takes care of this problem by using a parameter k that is the maximum
number of sub-alphabets to use. We sort the alphabet by decreasing frequency and
call S(c, k) the total number of bits required to encode the symbols [c..Ïƒ ] of the al-
phabet using a partitioning into at most k sub-alphabets. In general, we can make a
sub-alphabet with the symbols [c..câ€²] and solve optimally the rest, but if k = 1 we
are forced to choose câ€² = Ïƒ . When we can choose, the optimization formula is as
follows:
S(c, k) = min
câ‰¤câ€²â‰¤Ïƒ
(
f lg
n
f
+ f âŒˆlg(câ€² âˆ’ c + 1)âŒ‰ + S(câ€² + 1, k âˆ’ 1)
)
,
where f is the total frequency of symbols c-th to câ€²-th in s. The first term of the
sum accounts for the increase in tH0(s), the second for the size in bits of the
new sequence s, and the third for the smaller subproblem, where it also holds
S(Ïƒ + 1, k) = 0 for any k. This dynamic programming algorithm requires O(kÏƒ )
space and O(Ïƒ 2) time. We call this partitioning method optimal.
254 Algorithmica (2014) 69:232â€“268
Example 6 The optimal partitioning using 3 classes just like the dense approach
in Example 5 leaves â€™aâ€™ in its own class, then groups â€™lâ€™, ", â€™bâ€™ and â€™râ€™ in
a second class, and finally leaves â€™dâ€™ alone in a third class. The overall space
nH0(t) + âˆ‘ |s|lgÏƒ is 2.23 bits per symbol, less than the 2.34 reached by the
dense partitioning. If, instead, we let it use four classes, it gives the same solution as
the sparse method in Example 1.
Finally, in Sect. 3 we represent the sequences s with small alphabets Ïƒ using
wavelet trees (just like t) instead of using the representation of Golynski et al. [28],
which is used for large Ïƒ > lgn. In theory, this is because Golynski et al.â€™s rep-
resentation does not ensure sublinearity on smaller alphabets when used inside our
scheme. While this may appear to be a theoretical issue, the implementation of such
data structure (e.g., in LIBCDS) is indeed unattractive for small alphabets. For this
reason, we also avoid using it on the chunks where Ïƒ is small (in our case, the first
ones). Note that using a wavelet tree for t and then another for the symbols in a se-
quence s is equivalent to replacing the wavelet tree leaf corresponding to  in t by
the whole wavelet tree of s. The space used by such an arrangement is worse than
the one obtained by building, from scratch, a wavelet tree for t where the symbols
t[i] =  are actually replaced by the corresponding symbol s[i].
In our dense representation we use a parameter min that controls the minimum 
value that is represented outside of t . All the symbols that would belong to s, for
 < min, are represented directly in t . Note that, by default, since Ïƒ0 = 1, we have
min = 1.
8.2 Compression Performance
For all the experiments in Sect. 8, except Sect. 8.6, we used real datasets extracted
from Wikipedia. We considered two large collections, Simple English and Spanish,
dated from 06/06/2011 and 03/02/2010, respectively. Both are regarded as sequences
of words, not characters. These collections contain several versions of each article.
Simple English, in addition, uses a reduced vocabulary. We collected a sample of
100,000 versions at random from all the documents of Simple English, which makes
a long and repetitive sequence over a small alphabet. For the Spanish collection,
which features a much richer vocabulary, we took the oldest version of each article,
which yields a sequence of similar size, but with a much larger alphabet.
We generated a single sequence containing the word identifiers of all the articles
concatenated, obtained after stemming the collections using Porter for English and
Snowball for Spanish. Table 2 shows some basic characteristics of the sequences
obtained.7
We measured the compression ratio achieved by the three partitioning schemes,
dense, sparse, and optimal. For dense we did not include any individual
symbols (other than the most frequent) in sequence t , i.e., we let min = 1. For op-
timal we allow 1 + lgÏƒ sub-alphabets, just like dense.
7The code for generating these sequences is available at https://github.com/fclaude/txtinvlists.
Algorithmica (2014) 69:232â€“268 255
Table 2 Main characteristics of the datasets used
Collection Articles Total words (n) Distinct words (Ïƒ ) Entropy (H0(s))
Simple English 100,000 766,968,140 664,194 11.60
Spanish 1,590,453 511,173,618 3,210,671 11.37
Fig. 1 Space versus decompression time for basic and alphabet-partitioned schemes. The vertical line
marks the zero-order entropy of the sequences. AC can slightly break the entropy barrier on Simple English
because it is adaptive
In all cases, the symbols in each s are represented using lgÏƒ bits. The sequence
of classes t , instead, is represented in three different forms: Plain uses a fixed num-
ber of bits per symbol, lg where  is the maximum class; Huff uses Huffman
coding of the symbols,8 and AC uses Arithmetic coding of the symbols.9 The former
encodings are faster, whereas the latter use less space. In addition we consider com-
pressing the original sequences using Huffman (Huffman) and Arithmetic coding
(Arith).
As explained, the main interest in using alphabet partitioning in a compressor is
to speed up decompression without sacrificing too much space. Figure 1 compares
all these alternatives in terms of space usage (percentage of the original sequence)
and decompression time per symbol. It can be seen that alphabet partitioning com-
bined with AC compression of t wastes almost no space due to the partitioning,
and speeds up considerably the decompression of the bare AC compression. How-
ever, bare Huffman also uses the same space and decompresses several times faster.
Therefore, alphabet partitioning combined with AC compression is not really inter-
esting. The other extreme is the combination with a Plain encoding of t . In the
best combinations, this alphabet partitioning wastes close to 10 % of space, and in
exchange decompresses around 30 % faster than bare Huffman. The intermediate
8We use G. Navarroâ€™s Huffman implementation; the code is available in LIBCDS.
9We use the code by J. Carpinelli, A. Moffat, R. Neal, W. Salamonsen, L. Stuiver, A. Turpin and I. Witten,
available at http://ww2.cs.mu.oz.au/~alistair/arith_coder/arith_coder-3.tar.gz. We modified the decompres-
sor to read the whole stream before timing decompression.
256 Algorithmica (2014) 69:232â€“268
Table 3 Breakdown, in bits per
symbol, of the space used in
sequence t versus the space used
in all the sequences s, for the
different combinations. The
third column in each collection
is the percentage of symbols that
lie in sequences s with alphabet
sizes Ïƒ = 1
Combination Simple English Spanish
t s % t s %
Plain-dense 4.96 7.74 6.67 4.76 7.72 11.70
Plain-sparse 9.97 3.79 19.01 9.79 4.08 32.91
Plain-optimal 4.96 7.66 10.21 4.76 7.61 16.88
Huff-dense 3.99 7.74 6.67 4.13 7.72 11.70
Huff-sparse 8.22 3.79 19.01 8.01 4.08 32.91
Huff-optimal 4.08 7.66 10.21 4.24 7.61 16.88
AC-dense 3.95 7.74 6.67 4.10 7.72 11.70
AC-sparse 8.18 3.79 19.01 7.99 4.08 32.91
AC-optimal 4.03 7.66 10.21 4.20 7.61 16.88
combination, Huff, wastes less than 1 % of space, while improving decompression
time by almost 25 % over bare Huffman.
Another interesting comparison is that of partitioning methods. In all cases, variant
dense performs better than sparse. The difference is larger when combined with
Plain, where sparse is penalized for the larger alphabet size of t , but still there
is a small difference when combined with AC, which shows that t has also (slightly)
lower entropy in variant dense. Table 3 gives a breakdown of the bits per symbol in
t versus the sequences s in all the methods. It can be seen that sparse leaves much
more information on sequence t than the alternatives, which makes it less appealing
since the operation of t is slower than that of the other sequences. However, this can
be counterweighted by the fact that sparse produces many more sequences with
alphabet size 1, which need no time for accessing. It is also confirmed that dense
leaves slightly less information on t than optimal, and that the difference in space
between the three alternatives is almost negligible (unless we use Plain to encode t ,
which is not interesting).
Finally, let us consider how the partitioning method affects decompression time,
given an encoding method for t . For method AC, sparse is significantly slower.
This is explained by the t component having many more bits, and the decompression
time being dominated by the processing of t by the (very slow) arithmetic decoder.
For method Plain, instead, sparse is slightly faster, despite the fact that it uses
more space. Since now the reads on t and s take about the same time, this difference
is attributable to the fact that sparse leaves more symbols on sequences s with
alphabets of size 1, where only one read in t is needed to decode the symbol (see
Table 3). For Huff all the times are very similar, and very close to the fastest one.
Therefore, for the rest of the experiments we use the variant Huff with dense
partitioning, which performs best in space/time.
8.3 Rank, Select and Access
We now consider the efficiency in the support for the operations rank, select, and
access. We compare our sequence representation with the state of the art, as imple-
mented in LIBCDS v1.0.10, a library of highly optimized implementations of com-
Algorithmica (2014) 69:232â€“268 257
pact data structures. As said, LIBCDS already includes the implementation of our new
structure.
We compare six data structures for representing sequences. Those based on
wavelet trees are obtained in LIBCDS by combining sequence representations
(WaveletTreeNoptrs, WaveletTree) with bitmap representations
(BitSequenceRG, BitSequenceRRR) for the data on wavelet tree nodes.
â€¢ WTNPRG: Wavelet tree without pointers, obtained as WaveletTreeNoptrs+
BitSequenceRG in LIBCDS. This corresponds to the basic balanced wavelet tree
structure [32], where all the bitmaps of a level are concatenated [41]. The bitmaps
are represented in plain form and their operations are implemented using a one-
level directory [30] (where rank is implemented in time proportional to a sampling
step and select uses a binary search on rank). The space is n lgÏƒ + o(n lgÏƒ) and
the times are O(lgÏƒ). In practice the absence of pointers yields a larger number of
operations to navigate in the wavelet tree, and also select operation on bitmaps is
much costlier than rank. A space/time tradeoff is obtained by varying the sampling
step of the bitmap rank directories.
â€¢ WTNPRRR: Wavelet tree without pointers with bitmap compression, obtained
in LIBCDS as WaveletTreeNoptrs+BitSequenceRRR. This is similar to
WTNPRG, but the bitmaps are represented in compressed form using the FID tech-
nique [55] (select is also implemented with binary search on rank). The space is
nH0(s) + o(n lgÏƒ) and the times are O(lgÏƒ). In practice the FID representation
makes it considerably slower than the version with plain bitmaps, yet select opera-
tion is less affected. A space/time tradeoff is obtained by varying the sampling step
of the bitmap rank directories.
â€¢ GMR: The representation proposed by Golysnki et al. [28], named SequenceGMR
in LIBCDS. The space is n lgÏƒ + o(n lgÏƒ), yet the lower-order term is sublinear
on Ïƒ , not n. The time is O(1) for select and O(lg lgÏƒ) for rank and access, al-
though on average rank is constant-time. A space/time tradeoff, which in practice
affects only the time for access, is obtained by varying the permutation sampling
inside the chunks [28].
â€¢ WTRG: Wavelet tree with pointers and Huffman shape, obtained as WaveletTree
+BitSequenceRG in LIBCDS. The space is nH0(s) + O(n) + o(nH0(s)) +
O(Ïƒ lgn). The time is O(lgÏƒ), but in our experiments it will be O(H0(s)) for
access, since the positions are chosen at random from the sequence and then we
navigate less frequently to deeper Huffman leaves.
â€¢ WTRRR: Wavelet tree with pointers, obtained with WaveletTree+
BitSequenceRRR in LIBCDS. The space is nH0(s) + o(nH0(s)) + O(Ïƒ lgn).
The time is as in the previous structure, except that in practice the FID representa-
tion is considerably slower.
â€¢ AP: Our new alphabet partitioned structure, named SequenceAlphPart in
LIBCDS. We use dense partitioning and include the 210 most frequent symbols
directly in t , min = 10. Sequence t is represented with a WTRG (since its alphabet
is small and the pointers pose no significant overhead), and the sequences Ïƒ are
represented with structures GMR. The space is nH0(s) + o(nH0(s)), although the
lower-order term is actually sublinear on Ïƒ (and only very slightly on n). The times
are as in GMR, although there is a small additive overhead due to the wavelet tree
258 Algorithmica (2014) 69:232â€“268
Fig. 2 Time for the three operations. The x axis starts at the entropy of the sequence
on t . A space/time tradeoff is obtained with the permutations sampling, just as in
GMR.
Figure 2 shows the results obtained for both text collections, giving the average
over 100,000 measures. The rank queries were generated by choosing a symbol from
[1..Ïƒ ] and a position from [1..n], both uniformly at random. For select we chose the
symbol a in the same way, and the other argument uniformly at random in [1..|s|a].
Finally, for access we generated the position uniformly at random in [1..n]. Note that
the latter choice favors Huffman-shaped wavelet trees, on which we descend to leaf a
Algorithmica (2014) 69:232â€“268 259
with probability |s|a/n, whereas for rank and select we descend to any leaf with the
same probability.
Let us first analyze the case of Simple English, where the alphabet is smaller. Since
Ïƒ is 1000 times smaller than n, the O(Ïƒ lgn) terms of Huffman-shaped wavelet trees
are not significant, and as a result the variant WTRRR reaches the least space, es-
sentially nH0(s)+ o(nH0(s)). It is followed by three variants that use similar space:
WTRG (which has an additional O(n)-bit overhead), AP (whose o(nH0(s)) space term
is higher than that of wavelet trees), and WTNPRRR (whose sublinear space term is
of the form o(n lgÏƒ), that is, uncompressed). The remaining structures, WTNPRG and
GMR, are not compressed and use much more space.
In terms of time, structure AP is faster than all the others except GMR (which
in exchange uses much more space). The exception is on access queries, where as
explained Huffman-shaped wavelet trees, WTRG and WTRRR, are favored and reach
the same performance of AP. In general, the rule is that variants using plain bitmaps
are faster than those using FID compression, and that variants using pointers and
Huffman shape are faster than those without pointers (as the latter need additional
operations to navigate the tree). These differences are smaller on select queries, where
the binary searches dominate most of the time spent.
The Spanish collection has a much larger alphabet: Ïƒ is only 100 times smaller
than n. This impacts on the O(Ïƒ lgn) bits used by the pointer-based wavelet trees,
and as a result the space of AP, nH0(s)+o(nH0(s)), is unparalleled. Variants WTRRR
and WTRG use significantly more space and are followed, far away, by WTNPRRR,
which has uncompressed redundancy. The uncompressed variants WTNPRG and RG
use significantly more space. The times are basically as on Simple English.
This second collection illustrates more clearly that, for large alphabets, our struc-
ture AP sharply dominates the whole space/time tradeoff. It is only slightly slower
than GMR in some cases, but in exchange it uses half the space. From the wavelet
trees, the most competitive alternative is WTRG, but it always loses to AP. The sit-
uation is not too different on smaller alphabets (as in Simple English), except that
variant WTRRR uses clearly less space, yet at the expense of doubling the operation
times of AP.
8.4 Intersecting Inverted Lists
An interesting application of rank/select operations on large alphabets was proposed
by Clarke et al. [14], and recently implemented by Arroyuelo et al. [1] using wavelet
trees. The idea is to represent the text collections as a sequence of word tokens (as
done for Simple English and Spanish), use a compressed and rank/select/access-
capable sequence representation for them, and use those operations to emulate an
inverted index on the collection, without spending any extra space on storing explicit
inverted lists.
More precisely, given a collection of d documents T1, T2, . . . , Td , we concatenate
them in C = T1T2 Â· Â· Â·Td , and build an auxiliary bitmap b[1..|C|] where we mark the
beginning of each document with a 1. We can provide access to the text of any docu-
ment in the collection via access operations on sequence C (and select on b). In order
260 Algorithmica (2014) 69:232â€“268
input : C,w,p
output: next document after Tp that contains w
pos â† b.select1(p + 1);
cnt â† C.rankw(pos âˆ’ 1);
return b.rank1(C.selectw(cnt + 1))
Algorithm 1: Function nextDoc(C,w,p), retrieves the next document after p
containing w. The x axis starts at the entropy of the sequence
input : C,W = w1,w2, . . . ,wk
output: documents that contain w1, . . . ,wk
sort W by increasing number of occurrences in the collection;
res â† âˆ…;
p â† nextDoc(C,w1,0);
while p is valid do
if w2, . . . ,wk are contained in p (i.e., p = nextDoc(C,wj ,p âˆ’ 1) for
2 â‰¤ j â‰¤ k) then
Add p to res;
p â† nextDoc(C,w1,p)
end
else
Let wj be the first word not contained in p;
p â† nextDoc(C,w1,nextDoc(C,wj ,p âˆ’ 1))
end
end
return res
Algorithm 2: Retrieving the documents where all w1, . . . ,wk appear
to emulate the inverted list of a given term w, we just need to list all the distinct doc-
uments where w occurs. This is achieved by iterating on procedure nextDoc(C,w,p)
of Algorithm 1 (called initially with p = 0 and then using the last p value returned).
Algorithm 1 also allows one to test whether a given document contains a term
or not (p contains w iff p = nextDoc(C,w,p âˆ’ 1)). Using this primitive we imple-
mented Algorithm 2, which intersects several lists (i.e., returns the documents where
all the given terms appear) based on the algorithm by Demaine et al. [18]. We tested
this algorithm for both Simple English and Spanish collections, searching for phrases
extracted at random from the collection. We considered phrases of lengths 2 to 16.
We averaged the results over 1,000 queries. As all the results were quite similar, we
only show the cases of 2 and 6 words. We tested the same structures as in Sect. 8.3.
Figure 3 shows the results obtained by the different structures. For space, of
course, the results are as before: AP is the best on Spanish and is outperformed by
WTRRR on Simple English. With respect to time, we observe that Huffman-shaped
wavelet trees are favored compared to the random rank and select queries of Sect. 8.3.
The reason is that the queries in this application, at least in the way we have gener-
Algorithmica (2014) 69:232â€“268 261
Fig. 3 Results for intersection queries. The x axis starts at the entropy of the sequence
ated them, do not distribute uniformly at random: the symbols for rank and select are
chosen according to their probability in the text, which favors Huffman-shaped trees.
As a result, structures WTRG perform similarly to AP in time, whereas WTRRR is less
than twice as slow.
8.5 Self-Indexes
A second application of the sequence operations on large alphabets was explored
by FariÃ±a et al. [19]. The idea is to take a self-index [48] designed for text com-
posed of characters, and apply it to a word-tokenized text, in order to carry out word-
level searches on natural language texts. This requires less space and time than the
character-based indexes and competes successfully with word-addressing inverted
indexes. One of the variants they explore is to build an FM-index [21, 22] on words
[15]. The FM-index represents the Burrows-Wheeler transform (BWT) [12] sbwt of s.
Using rank and access operations on sbwt the FM-index can, among other operations,
count the number of occurrences of a pattern p[1..k] (in our case, a phrase of k words)
in s[1..n]. This requires O(k) applications of rank and access on sbwt. A self-index
is also able to retrieve any passage of the original sequence s.
We implemented the word-based FM-index with the same structures measured so
far, plus a new variant called APRRR. This is a version of AP where the bitmaps of the
wavelet tree of t are represented using FIDs [55]. The reason is that it was proved [42]
262 Algorithmica (2014) 69:232â€“268
Fig. 4 Time for counting queries on word-based FM-indexes. The vertical line marks the zero-order
entropy of the sequences; remember that some schemes achieve high-order entropy spaces
that the wavelet tree of sbwt, if the bitmaps are represented using Raman et al.â€™s FID
[55], achieves space nHk(s) + o(n lgÏƒ). Since the wavelet tree t of sub-alphabets of
sbwt is a coarsened version of that of sbwt, we expect it to take advantage of Raman
et al.â€™s representation.
We extracted phrases at random text positions, of lengths 2 to 16, and counted their
number of occurrences using the FM-index. We averaged the results over 100,000
searches. As the results are similar for all lengths, we show the results for lengths 2
and 8. Figure 4 shows the time/space tradeoff obtained.
Confirming the theoretical results [42], the versions using compressed bitmaps
require much less space than the other alternatives. In particular, APRRR uses much
less space than AP, especially on Simple English. In this text the least space is reached
by WTRRR. On Spanish, instead, the O(Ïƒ lgn) bits of Huffman-shaped wavelet trees
become relevant and the least space is achieved by APRRR, closely followed by AP
and WTNPRRR. The space/time tradeoff is dominated by APRRR and AP, the two
variants of our structure.
8.6 Navigating Graphs
Finally, our last application scenario is the compact representation of graphs. Let
G = (V ,E) be a directed graph. If we concatenate the adjacency lists of the nodes,
Algorithmica (2014) 69:232â€“268 263
Table 4 Description of the Web crawls considered
Name Nodes Edges Plain adj. list (bits per edge)
EU (EU-2005) 862,664 19,235,140 20.81
In (Indochina-2002) 7,414,866 194,109,311 23.73
the result is a sequence s[1..|E|] over an alphabet of size |V |. If we add a bitmap
b[1..|E|] that marks with a 1 the beginning of the lists, it is very easy to retrieve the
adjacency list of any node v âˆˆ V , that is, its neighbors, with one select operation on
b followed by one access operation on s per neighbor retrieved.10
It is not hard to reach this space with a classical graph representation. However,
classical representations do not allow one to retrieve efficiently the reverse neighbors
of v, that is, the nodes that point to it. The classical solution is to double the space
to represent the transposed graph. Our sequence representation, however, allows us
to retrieve the reverse neighbors using select operations on s, much as Algorithm 1
retrieves the documents where a term w appears: our â€œdocumentsâ€ are the adjacency
lists of the nodes, and the document identifier is the node v âˆˆ V that points to the
desired node. Similarly, it is possible to determine whether a given node v points to
a given node vâ€², which is not an easy operation with classical adjacency lists. This
idea has not only been used in this simple form [15], but also in more sophisticated
scenarios where it was combined with grammar compression of the adjacency lists, or
with other transformations, to compress Web graphs and social networks [16, 17, 37].
For this experiment we used two crawls obtained from the well-known WebGraph
project.11 The main characteristics of these crawls are shown in Table 4. Note that
the alphabets are comparatively much larger than on documents, just around 22â€“26
times smaller than the sequence length.
Figure 5 shows the results obtained. The nodes are sorted alphabetically by URL.
A well-known property of Web graphs [10] is that nodes tend to point to other nodes
of the same domain. This property turns into substrings of nearby symbols in the
sequence, and this turns into runs of 0 s or 1 s in the bitmaps of the wavelet trees. This
makes variants like WTNPRRR very competitive in space, whereas APRRR does not
benefit so much. The reason is that the partitioning into classes reorders the symbols,
and the property is lost. Note that variant WTRRR does not perform well in space,
since the number of nodes is too large for a pointer-based tree to be advantageous.
For the same reason, even WTRG uses more space than GMR.12 Overall, we note that
our variants largely dominate the space/time tradeoff, except that WTNPRRR uses less
space (but much more time).
10Note that this works well as long as each node points to at least one node. We solve this problem by
keeping an additional bitmap marking the nodes whose list is not empty.
11http://law.dsi.unimi.it.
12Note that WTRRR is almost 50 % larger than WTRG. This is because the former is a more complex
structure and requires a larger (constant) number of pointers to be represented. Multiplying by the Ïƒ nodes
of the Huffman-shaped wavelet tree makes a significant difference when the alphabet is so large.
264 Algorithmica (2014) 69:232â€“268
Fig. 5 Performance on Web graphs, to retrieve direct and reverse neighbors. The vertical line marks the
bits per edge required by a plain adjacency list representation
9 Conclusions and Future Work
We have presented the first zero-order compressed representation of sequences sup-
porting queries access, rank, and select in loglogarithmic time, so that the redun-
dancy of the compressed representation is also compressed. That is, our space for se-
quence s[1..n] over alphabet [1..Ïƒ ] is nH0(s)+ o(n)(H0(s)+ 1) instead of the usual
nH0(s) + o(n lgÏƒ) bits. This is very important in many practical applications where
the data is so highly compressible that a redundancy of o(n lgÏƒ) bits would domi-
nate the overall space. While there exist representations using even nH0(s) + o(n)
bits, ours is the first one supporting the operations in time O(lg lgÏƒ) while break-
ing the o(n lgÏƒ) redundancy barrier. Moreover, our time complexities are adaptive
to the compressibility of the sequence, reaching average times O(lg H0(s)) under
reasonable assumptions. We have given various byproducts of the result, where the
compressed-redundancy property carries over representations of text indexes, permu-
tations, functions, binary relations, and so on. It is likely that still other data structures
can benefit from our compressed-redundancy representation. Finally, we have shown
experimentally that our representation is highly practical, on large alphabets, both in
synthetic and real-life application scenarios.
On the other hand, various interesting challenges on sequence representations re-
main open:
Algorithmica (2014) 69:232â€“268 265
1. Use nHk(s)+o(n)(Hk(s)+1) bits of space, rather than nHk(s)+o(n lgÏƒ) [4, 33]
or our nH0(s) + o(n)(H0(s) + 1) bits, while still supporting the queries access,
rank, and select efficiently.
2. Remove the o(nH0(s)) term from the redundancy while retaining loglogarithmic
query times. Golynski et al. [29] have achieved nH0(s) + o(n) bits of space, but
the time complexities are exponentially higher on large alphabets, O(1 + lgÏƒlg lgn ).
3. Lower the o(n) redundancy term, which may be significant on highly compress-
ible sequences. Our o(n) redundancy is indeed O( nlg lg lgn ). That of Golynski et
al. [29], o(n lgÏƒlgn ), is more attractive, at least for small alphabets. Moreover, for the
binary case, PaË˜trasÂ¸cu [53] obtained O( nlgc n ) for any constant c, and this is likely
to carry over multiary wavelet trees.
After the publication of the conference version of this paper, Belazzougui and
Navarro [8] achieved a different tradeoff for one of our byproducts (Theorem 5).
By spending O(n) further bits, they completely removed the terms dependent on
Ïƒ in all time complexities, achieving O(m), O(lgn) and O(r âˆ’ l + lgn) times for
counting, locating and extracting, respectively. Their technique is based on mono-
tone minimum perfect hash functions (mmphfs), which can also be used to improve
some of our results on permutations, for example obtaining constant time for query
Ï€(i) in Theorem 6 and thus improving all the derived results.13 This is just one
example of how lively current research is on this fundamental problem. Another
example is the large amount of recent work attempting to close the gap between
lower and upper bounds when taking into account compression, time and redun-
dancy [25â€“27, 29, 33, 34, 53, 54]. Very recently, Belazzougui and Navarro [9] proved
a lower bound of Î©(lg lgÏƒlgw ) for operation rank on a RAM machine of word size w,
which holds for any space of the form O(nwO(1)), and achieved this time within
O(n lgÏƒ) bits of space. Then, making use of the results we present in this paper, they
reduced the space to nH0(s) + o(nH0(s)) + o(n) bits. This illustrates how our tech-
nique can be easily used to move from linear-space to compressed-redundancy-space
sequence representations.
To conclude, it is worth mentioning Navarro and Nekrichâ€™s recent result [49] on
optimal representations of dynamic sequences, where in addition to the three opera-
tions we consider in this paper, one can insert and delete symbols at arbitrary posi-
tions. They obtain the optimal time O(logn/ log logn) for all the operations within
essentially nH0(s) + O(n) bits of space. Using the alphabet partitioning idea, com-
bining structures different from those we used here, is the key to remove any depen-
dence on the alphabet size from the query times, to remove o(n lgÏƒ) terms from the
space, and to handle unbounded alphabets. This shows how the alphabet partitioning
concept may have many more applications than those we are able to envision at this
moment.
Acknowledgements We thank Djamal Belazzougui for helpful comments on a draft of this paper, and
Meg Gagie for righting our grammar.
13Djamal Belazzougui, personal communication.
266 Algorithmica (2014) 69:232â€“268
References
1. Arroyuelo, D., GonzÃ¡lez, S., OyarzÃºn, M.: Compressed self-indices supporting conjunctive queries on
document collections. In: Proc. 17th International Symposium on String Processing and Information
Retrieval (SPIRE), pp. 43â€“54 (2010)
2. Barbay, J., Claude, F., Navarro, G.: Compact rich-functional binary relation representations. In: Proc.
9th Latin American Symposium on Theoretical Informatics (LATIN). LNCS, vol. 6034, pp. 170â€“183
(2010)
3. Barbay, J., Golynski, A., Munro, J.I., Rao, S.S.: Adaptive searching in succinctly encoded binary
relations and tree-structured documents. Theor. Comput. Sci. 387(3), 284â€“297 (2007)
4. Barbay, J., He, M., Munro, J.I., Rao, S.S.: Succinct indexes for strings, binary relations and multil-
abeled trees. ACM Trans. Algorithms 7(4), 52 (2011)
5. Barbay, J., LÃ³pez-Ortiz, A., Lu, T., Salinger, A.: An experimental investigation of set intersection
algorithms for text searching. ACM J. Exp. Algorithmics 14(3), 7 (2009)
6. Barbay, J., Navarro, G.: Compressed representations of permutations, and applications. In: Proc. 26th
Symposium on Theoretical Aspects of Computer Science (STACS), pp. 111â€“122 (2009)
7. Barbay, J., Navarro, G.: On compressing permutations and adaptive sorting. CoRR (2011). 1108.
4408v1
8. Belazzougui, D., Navarro, G.: Alphabet-independent compressed text indexing. In: Proc. 19th Annual
European Symposium on Algorithms (ESA). LNCS, vol. 6942, pp. 748â€“759 (2011)
9. Belazzougui, D., Navarro, G.: New lower and upper bounds for representing sequences. In: Proc. 20th
Annual European Symposium on Algorithms (ESA). LNCS, vol. 7501, pp. 181â€“192 (2012)
10. Boldi, P., Vigna, S.: The WebGraph framework I: compression techniques. In: Proc. 13th World Wide
Web Conference (WWW), pp. 595â€“602 (2004)
11. Brisaboa, N., Luaces, M., Navarro, G., Seco, D.: A new point access method based on wavelet trees.
In: Proc. 3rd International Workshop on Semantic and Conceptual Issues in GIS (SeCoGIS). LNCS,
vol. 5833, pp. 297â€“306 (2009)
12. Burrows, M., Wheeler, D.: A block sorting lossless data compression algorithm. Technical Report
124, Digital Equipment Corporation (1994)
13. Clark, D.: Compact Pat Trees. Ph.D. Thesis, University of Waterloo, Canada (1996)
14. Clarke, C., Cormack, G., Tudhope, E.: Relevance ranking for one to three term queries. In: Proc. 5th
International Conference on Computer-Assisted Information Retrieval (RIAO), pp. 388â€“401 (1997)
15. Claude, F., Navarro, G.: Practical rank/select queries over arbitrary sequences. In: Proc. 15th Interna-
tional Symposium on String Processing and Information Retrieval (SPIRE), pp. 176â€“187 (2008)
16. Claude, F., Navarro, G.: Extended compact web graph representations. In: Elomaa, T., Mannila, H.,
Orponen, P. (eds.) Algorithms and Applications (Ukkonen Festschrift). LNCS, vol. 6060, pp. 77â€“91.
Springer, Berlin (2010)
17. Claude, F., Navarro, G.: Fast and compact web graph representations. ACM Trans. Web 4(4), 16
(2010)
18. Demaine, E., LÃ³pez-Ortiz, A., Munro, J.I.: Adaptive set intersections, unions, and differences. In:
Proc. 11th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pp. 743â€“752 (2000)
19. FariÃ±a, A., Brisaboa, N., Navarro, G., Claude, F., Places, A., RodrÃ­guez, E.: Word-based self-indexes
for natural language text. ACM Trans. Inf. Syst. 30(1), 1 (2012)
20. Ferragina, P., Luccio, F., Manzini, G., Muthukrishnan, S.: Compressing and indexing labeled trees,
with applications. J. ACM 57(1), 4 (2009)
21. Ferragina, P., Manzini, G.: Indexing compressed texts. J. ACM 52(4), 552â€“581 (2005)
22. Ferragina, P., Manzini, G., MÃ¤kinen, V., Navarro, G.: Compressed representations of sequences and
full-text indexes. ACM Trans. Algorithms 3(2), 20 (2007)
23. Ferragina, P., Venturini, R.: A simple storage scheme for strings achieving entropy bounds. Theor.
Comput. Sci. 372(1), 115â€“121 (2007)
24. Gagie, T., Nekrich, Y.: Worst-case optimal adaptive prefix coding. In: Proc. 11th International Sym-
posium on Algorithms and Data Structures (WADS). LNCS, vol. 5664, pp. 315â€“326 (2009)
25. Golynski, A.: Optimal lower bounds for rank and select indexes. Theor. Comput. Sci. 387(3), 348â€“359
(2007)
26. Golynski, A.: Cell probe lower bounds for succinct data structures. In: Proc. 20th Annual ACM-SIAM
Symposium on Discrete Algorithms (SODA), pp. 625â€“634 (2009)
27. Golynski, A., Grossi, R., Gupta, A., Raman, R., Srinivasa Rao, S.: On the size of succinct indices.
In: Proc. 15th Annual European Symposium on Algorithms (ESA). LNCS, vol. 4698, pp. 371â€“382
(2007)
Algorithmica (2014) 69:232â€“268 267
28. Golynski, A., Munro, J.I., Rao, S.S.: Rank/select operations on large alphabets: a tool for text index-
ing. In: Proc. 17th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pp. 368â€“373
(2006)
29. Golynski, A., Raman, R., Rao, S.: On the redundancy of succinct data structures. In: Proc. 11th Scan-
dinavian Workshop on Algorithm Theory (SWAT). LNCS, vol. 5124, pp. 148â€“159 (2008)
30. GonzÃ¡lez, R., Grabowski, Sz., MÃ¤kinen, V., Navarro, G.: Practical implementation of rank and select
queries. In: Proc. 4th Workshop on Efficient and Experimental Algorithms (WEA), pp. 27â€“38 (2005).
Posters
31. GonzÃ¡lez, R., Navarro, G.: Statistical encoding of succinct data structures. In: Proc. 17th Annual
Symposium on Combinatorial Pattern Matching (CPM), pp. 294â€“305 (2006)
32. Grossi, R., Gupta, A., Vitter, J.: High-order entropy-compressed text indexes. In: Proc. 14th Annual
ACM-SIAM Symposium on Discrete Algorithms (SODA), pp. 841â€“850 (2003)
33. Grossi, R., Orlandi, A., Raman, R.: Optimal trade-offs for succinct string indexes. In: Proc. 37th
International Colloquim on Automata, Languages and Programming (ICALP), pp. 678â€“689 (2010)
34. Grossi, R., Orlandi, A., Raman, R., Srinivasa Rao, S.: More haste, less waste: lowering the redundancy
in fully indexable dictionaries. In: Proc. 26th Symposium on Theoretical Aspects of Computer Science
(STACS), pp. 517â€“528 (2009)
35. Grossi, R., Vitter, J.: Compressed suffix arrays and suffix trees with applications to text indexing and
string matching. SIAM J. Comput. 35(2), 378â€“407 (2006)
36. Haskel, B., Puri, A., Netravali, A.: Digital Video: an Introduction to MPEG-2. Chapman & Hall,
London (1997)
37. HernÃ¡ndez, C., Navarro, G.: Compression of web and social graphs supporting neighbor and com-
munity queries. In: Proc. 5th ACM Workshop on Social Network Mining and Analysis (SNA-KDD).
ACM, New York (2011)
38. Hreinsson, J.B., KrÃ¸yer, M., Pagh, R.: Storing a compressed function with constant time access. In:
Proc. 17th European Symposium on Algorithms (ESA), pp. 730â€“741 (2009)
39. Huffman, D.: A method for the construction of minimum-redundancy codes. Proc. IRE 40(9), 1090â€“
1101 (1952)
40. Levcopoulos, C., Petersson, O.: Sorting shuffled monotone sequences. Inf. Comput. 112(1), 37â€“50
(1994)
41. MÃ¤kinen, V., Navarro, G.: Rank and select revisited and extended. Theor. Comput. Sci. 387(3), 332â€“
347 (2007)
42. MÃ¤kinen, V., Navarro, G.: Dynamic entropy-compressed sequences and full-text indexes. ACM Trans.
Algorithms 4(3), 32 (2008)
43. Manzini, G.: An analysis of the Burrows-Wheeler transform. J. ACM 48(3), 407â€“430 (2001)
44. Mehlhorn, K.: Sorting presorted files. In: Proc. 4th GI-Conference on Theoretical Computer Science.
LNCS, vol. 67, pp. 199â€“212 (1979)
45. Moffat, A., Turpin, A.: On the implementation of minimum-redundancy prefix codes. IEEE Trans.
Commun. 45(10), 1200â€“1207 (1997)
46. Munro, I.: Tables. In: Proc. 16th Conference on Foundations of Software Technology and Theoretical
Computer Science (FSTTCS). LNCS, vol. 1180, pp. 37â€“42 (1996)
47. Munro, I., Raman, R., Raman, V., Rao, S.S.: Succinct representations of permutations and functions.
Theor. Comput. Sci. 438, 74â€“88 (2012)
48. Navarro, G., MÃ¤kinen, V.: Compressed full-text indexes. ACM Comput. Surv. 39(1), 2 (2007)
49. Navarro, G., Nekrich, Y.: Optimal dynamic sequence representations. In: Proc. 24th Annual ACM-
SIAM Symposium on Discrete Algorithms (SODA) (2013, to appear)
50. Okanohara, D., Sadakane, K.: Practical entropy-compressed rank/select dictionary. In: Proc. 10th
Workshop on Algorithm Engineering and Experiments (ALENEX), pp. 60â€“70 (2007)
51. Pearlman, W., Islam, A., Nagaraj, N., Said, A.: Efficient, low-complexity image coding with a set-
partitioning embedded block coder. IEEE Trans. Circuits Syst. Video Technol. 14(11), 1219â€“1235
(2004)
52. Pennebaker, W., Mitchell, J.: JPEG: Still Image Data Compression Standard. Van Nostrand-Reinhold,
New York (1992)
53. PaË˜trasÂ¸cu, M.: Succincter. In: Proc. 49th Annual IEEE Symposium on Foundations of Computer Sci-
ence (FOCS), pp. 305â€“313 (2008)
54. PaË˜trasÂ¸cu, M.: A lower bound for succinct rank queries. CoRR (2009). arXiv:0907.1103v1 [cs.DS]
55. Raman, R., Raman, V., Rao, S.: Succinct indexable dictionaries with applications to encoding k-ary
trees, prefix sums and multisets. ACM Trans. Algorithms 3(4), 43 (2007)
268 Algorithmica (2014) 69:232â€“268
56. Russo, L., Navarro, G., Oliveira, A., Morales, P.: Approximate string matching with compressed in-
dexes. Algorithms 2(3), 1105â€“1136 (2009)
57. Sadakane, K.: New text indexing functionalities of the compressed suffix arrays. J. Algorithms 48(2),
294â€“313 (2003)
58. Sadakane, K., Grossi, R.: Squeezing succinct data structures into entropy bounds. In: Proc. 17th An-
nual ACM-SIAM Symposium on Discrete Algorithms (SODA), pp. 1230â€“1239 (2006)
59. Said, A.: Efficient alphabet partitioning algorithms for low-complexity entropy coding. In: Proc. 15th
Data Compression Conference (DCC), pp. 193â€“202 (2005)
60. Tarjan, R.E., van Leeuwen, J.: Worst-case analysis of set union algorithms. J. ACM 31(2), 245â€“281
(1984)
61. Witten, I., Moffat, A., Bell, T.: Managing Gigabytes, 2nd edn. Morgan Kaufmann, San Mateo (1999)
