Theoretical Computer Science 75 (1990) 11 I- 138 
North-Holland 
111 
Department of Computer Science, University qf Illinois, Urbana, IL 41801, U.S.A. 
Department OJ’ Computer Science, Concordia University, Montreal, Quebec H3G I M8, Canada 
Abstract. Conditional equations provide a paradigm of computation that combines the clean 
syntax and semantics of LISP-iike functional programming with Prolog-like logic programming 
in a uniform manner. For functional programming, equations are used as rules for left-to-right 
rer.riting; for logic programming, the same rules are used for conditional narrowing. Together, 
rewriting and narrowing provide increased expressive power. We discuss some aspects of the 
theory of conditional rewriting, and the reasons underlying certain choices in designing a language 
based on them. The most imporiant correctness property a conditional rewriting program may 
possess is ground conjhence; this ensures that at most one value can be computed from any given 
(variable-free} input term. We give criteria for confluence. Reasonable conditions for ensuring 
the completeness of narrowing as an operational mechanism for solving goals are provided; these 
results are then extended to handle rewriting with existentially quantified conditions and built-in 
predicates. Some termination issues are also considered, including the case of rewriting with 
higher-order terms. 
In recent years, various suggestions for combining features of functional program- 
ming and logic (relational) programming have een made; see the collection in [7] 
and the survey in [2]. The simplest provide a convenient interface between resolution- 
based goal reduction and rewrite-based term evaluation, by using rewrite rules to 
normalize terms (i.e. rewriting them to terms that cannot be rewritten further) before 
unification is attempted. For example, the append function can be defined as usual: 
append(x, y) =if null(x) then y else cons(car(x), ~ppend(cd~(x)~y)) 
* A previous version of this paper appeared as: Conditional equational programming and the theory 
of conditional term rewriting, in: Proc. Internat. Conj on Fifth Generation Computer SJs&?rns, Tokyo, 
Japan (I%%) 337-346. 
This research was supported in part by the National Science Foundation (United States) under Grant 
DCR 8513417, the Natural Science and Engineering Research Council (Canada) under Grants 
OGP36663, ICR92599, Fonds pour la Formation de Chercheurs et O’Aide a la Recherche (Quebec) under 
Grants EQ41840, NC0025, Social Sciences and 
410-88-884, and the Committee on Aid to Research Activities ( 
en the second author was visi 
ris-Sud, with support fron. 
0304-3975/90/$03.50 @ 1990-Elsevier Science Ptribhshers B.V. (North-Holland) 
i12 N. Dershowitz, M. Qkada 
and Quicksort ca be written with Horn clauses as fdlo*, + 
edx, 4 
sort( nil9 nil) 
A eq(z, append(z,, cons(x, z2))) 2 sort(cons(x, y), z). 
~wi+ a suitable program for partition). Such languages do not use function definitions . 
to instantiate free variables during goal reduction, and, consequently, are incomplete, 
in the sense that a solution to a goal will not necessarily be found whenever one 
provably exists. For example, the above program would find no solutions to the goal 
sort(cons(2, cons( 1, ni!)), append (x, y)). 
An early example of such a language is QLQG 1341. 
An alternative approach is to treat function definitions, like append, as a pair of 
implications 
null(x) 1 append (x, y) = y 
lnuN(x) 3 append(x, y) = cons(car(x), append(cdr(x), y)). 
The necessary properties of car, cdr, and null could also be given as clauses: 
null( nil) 
inull( cons(x, y)) 
car(cons(x, y)) = x 
cdr(cons(x, y)) =y. 
Paramodulation (unifying one side of an equation with a nonvariable subterm of a 
clause and replacing with the other side) would then be used (with resolution) to 
solve goals. Uniform [30] is an early extension of Prolog incorporating such an 
equality rule. Though completeness is achievable in such a manner, the resultant 
language requires non-linear forward reasoning and lacks the sense of direction 
that distinguishes computing from theorem proving. 
Another alternative is to use function definitions as one-way rewriting rules: 
append (x9 Y 1 ---, if null(x) the:1 y else cons(car(x), append(cdr(x), y)). 
Rewrite rules are used to replace equals-by-equals, but only in the left-to-right 
direction. That is, a rule I -+ r may be applied to a term t if a subterm s of t matches 
(by “one-sided” unification) the left-hand side I with some substitution u of terms 
for the variables in 1. The rule is applied by replacing the subterm SC = lo in t with 
the rig ditional rules for simplification are always needed: 
i 
if false t r eke s --+ s. 
Cnmiitional equational programming 113 
In the above example, rules for car , cdr, and null are also needed. Terms are rewritten 
until no rule applies; when (and if) that situation occurs, the resultant irreduc%le 
term, called a normal form, is considered the value of the initial term. 
Often, the two cases defined by a condition can be better expressed as mutually 
exclusive left-hand-side patterns. For example, the following set of rules suffices 
for append : 
append (nil, y) -+ y 
aPPendbnsk Yh3 d -+ cons(x, appevmd (y, z)) 
null(ni1) -+ true 
null(cons(x, y j) ---, false 
car(cons(x, y)) + x 
cdr( cons(x, y)) + y. 
TO use rewrite rules for logic programming, i.e. to find values for variabies that 
satisfy an equational goal like apper;d (x, y) = x, a “linear” restriction of paramodula- 
tion, analogous to the SLD-strategy for Horn-clause logic, can be used. Narrowing 
[52] is like rewriting, except that unification is used in place of pattern matching: 
a rule I+ r may be applied to a term t if a nonvariable subterm s of t unifies with 
the left-hand side I with some substitution of terms for the variables in 1. (Variables 
in I and t are treated as disjoint.) The result is ta with SC replaced by ra, where CT 
is the most general unifier of I and s. A programming language with narrowing-like 
operational semantics was first suggested in [9]. Other languages using narrowing 
or related mechanisms as a way of incorporating functions with goal reduction 
include: SEC [ 181; EQLOG [21]; TABLOG [36]; QUTE [51]; FGL-I- LV [35]; and 
EQL [26]. Like paramodulation, narrowing can be simulated in Prolog by decompos- 
ing terms [S, 551. 
For completeness of narrowing, ground coq?uence of the system of oriented 
equations is required. Ground confluence implies that a variable-free term can have 
at most one normal form. With ground confluence, any irreducible solution to a 
goal can be found by narrowing. Orthogonal (or regular) rewriting systems obey 
the following syntactic conditions: 
(a) no variable appears more than once on any left-hand side, 
(b) only variables that ar>pc;ti; .XI rhe left appear on t 
(c) no Left-hand side is unifiable with a nonvariable (not necess;lrily proper) 
subterm of another left-hand side, and 
(d) no left-hand side uni itself. 
Orthogonal systems are always confluent [40]. 
7 14 IV. Dershowitz, M. Okada 
an irreducible ter For example, with the “if-then-else” definition 
infinite sequence of rewrites is possible: 
append ( nil, nil) ---, if null(ni1) then nil else cons(car(nil), appe (cdr(tlil), nil)) 
--3 if drue then nil else cons(car(nil), append(cdr(nil), nil)) 
* if true then nil else cons(car( nil), if null(cdr( nil)) then rail 
else cons(car(cdr(nil)), append(cdr(cdr(nil)), nil))) 
. . . . 
Thus, to guarantee that normal forms of terms and irreducible solutions to goals 
will be found whenever they exist, requires a lazy, outermost evaluation strategy, 
in which conditions are evaluated first and the “if-then-else” is simplified. See, for 
example, [49]. hus, eager evaluation of arguments (as in LISF, is not permissible. 
Furthermore, rather strict syntactic conditions (i.e. orthogonality) are necessary for 
completeness. 
These considerations suggest he use of conditional rewrite rules as a means of 
expressing function definitions. Each definition 
J(X) = if p[~?] then r[~?] else s[5J 
(square brackets are used to indicate that the variables 3 may appear anywhere in 
the indicated term) translates into two conditional rules: 
p[Z]=true If(Z)-, r[X] 
p[X]= false If(Z)-, ~[a]. 
Using conditional equations allows one to program with rules that can never lead 
to infinite sequences of rewrites. Such systems are called terminating. Proposed 
languages along these lines include RITE [ 14,271, SLOG [ 191, and EQLOG [22]. 
In this paper, we concentrate on narrowing-based programming languages that 
require the programmer to use only terminating rules. Termination does not limit 
expressibility, since any potentially nonterminating function definition (such as the 
definition of an interpreter) can be rephrased to include a bound, as illustrated in 
1141. Instead of a definition 
fix) = t[fi31, 
a definition with one extra argument, 
is used, and instead of computing f(a), the goal f '( 6, n) = z can be solved. 
Section 2 is on corn leteness of conditional rewriting and Section 3 is on decidabil- 
1 forms. Section addresses the completeness of 
variables. Sect 
Conditional equational programming 115 
case in which conditions involve built-in predicates. Then, Section 7 considers 
rewriting with higher-order lambda terms and existential variables. e conclude 
with a brief discussion. 
. itio r~wpi~i~g 
ln functional programming, one is usually interested in finding a “normal form” 
ual” to a given (variable-free) input term s. be a normal form, t 
must satisfy some criterion, usually that no “rule” or “function definition” applies 
to it. Equality of s and t must be provable in some logical system. In this section, 
we explore the adequacy of rewriting as a means of computing normal forms. A 
preliminary version of this section appeared in [43]. 
We use standard notations [23]: s = t stands for the usual sense of equality in 
logical systems; s + t stands for one rewrit:> 5telj in a given rewriting system; + is 
the inverse of the rewrite relation -+; c-) is the symmetric closure of -; ++ is its 
transitive closure; ** is its reflexive-transitive closure; s w* t is its symmetric- 
reflexive-transitive closure; *+ is the reflexive-transitive closure of +-; and :j, r 
means s -+* u *+ t, for some u. A term s is in normal jbr.m if there is no t such 
that s + t; we write s -+! t if s +* t for normal form t. We will assume some 
familiarity with the main notions in rewriting, viz. termination, confluence, and 
critical pair; see [ 241 or [ lo]. 
By a conditional equational system, we mean a set of Horn clauses of the form 
Sl =t,/l l *= /\s,=t, 3 l=r. 
A naturul conditional rewriting system R has rules of the form 
s1 ,*, t, A l ’ l A s, ,*, t* 1 I --, r. 
When such a rule applies, an instance lo of I in a term s is replaced by ra, yielding 
a term t. We write R I- s + t, or just s ---) t. The rule applies, however, only if there 
exists a proof si c)* ti for each tif the instantiated conditions, where these proofs 
may use any number of rewrites in either direction. If n = 0, the rule is unconditional. 
Note that a natural rewriting system is not very diRerent from the clnderlying 
equational system. Every rule (of the above form) corresponds to the conditional 
equation (shown above), obtained by replacing --, wit = , +-+* with = 9 and I with 
1. Let Reqn denote the underlyiplg equational system obtaine 
R”“’ in this way. 
For any natural conditional rewriting system 
tional equational syste eqn 3 
BIti N. Dershowitz, M. flkacia 
rovable in the logical system Reqn, there is 
it) form, i.e. a proof in which each co 
From classical rewriting 
whenever p *- 28 -+* 
(any equational pros 
be assured that any normal form 
d by rewriting? In other words, 
term ?, implies s +* t ? 
problem with natural systems is that the conditions for applying a involve 
ary proofs of equality, so we have gained little from the notion of rewriting. 
To remedy this defect, we consider a more restrictive definition of conditional 
~ew~~t~~g: A soap (join) cond’i~ional rewriting system is a set of rules of the form 
I + r, 
meaning that an instance lg of I rewrites to r~ only if each sig can 3e reduced (by 
ore rewrites) to the same term as the corresponding tp. For example, with 
Conditional equational programming 117 
For a standard system 
Rnaf denote the correql 
eqn denote the underlying eyuational system and 
natural system (replacing each J, with -*). 
inductive argument provides the following. 
For any’conjluent standard conditional rewriting system 
Rstd t- p&q iff 
It is easy to see that if Std is confluent, then so is the natural system nat, but 
the converse does not hold, in general, since the enabling conditions in a natural 
proof need not have proofs that are transformable into downarrow ones. 
A (standard or natural) conditional system is decreasing (cf. [ 13,28,32]) if there 
exists a well-founded extension > of the rewrite relation -+ which satisfies two 
additional properties: 
(a) > contains the proper subterm relation D (i.e. if s is a proper subterm of t 
then t> s) and 
(b) for each rule slit, A l l = A s,J t, 1 i -+ r, b > sj8, t,cr for all substitutions <r and 
indices i (1 s is n). 
We will say that a proof SW* t is j&I/y normal if it is a normai proof s$ t, and 
there are fully normal subproofs of the conditions sia-* tig used in the “surface” 
proof s&t. With these notions, we have the following. 
eorem 2.3. If h vtatural conditional rewriting system Rnat is decreasing and conjluent, 
then 
R”“’ I- piq ifl Rstd I- p.Jq. 
roof. Any proof in the standard system is also a proof in the natural system, so 
one direction is trivial. For the other direction, we show that any proof in the natural 
system can be transformed into a fully normal pro f, which holds in the standard 
system. 
The proof proceeds by replacing each proof level with a rewrite (J,) proof. 
precisely, first we normalize a surface proof s -* t to a normal form s.j, t in the given 
natural system. This is possible by the confluence of the natu 
consider the immediate conditions cl 4 d, , . . _, c, H* d,, use 
and normalize the surface proof of each of these to ciJdi, exactly 
simplification for unconditional systems [11. This normalization proc 
until all proofs and su oofs are rewrite 
To see that the succ 
steps, one can use multiset induction [ 10 
Since the multiset ordering is well-founded, normalization must terminate with a 
fully nomal proof of s = t. q 
One can we3 en the condition of rule applicab3ity even further. A I~O~FYXIZ 
conditional rewrite syste~ol is a rewrite system whose rules have the following form: 
meaning, for each condition, that ti is a normal form derivable from Si. 
The following two theorems show that normal systems are ot too restrictive. The 
first states that any standard system can be simulated by a normal system. For any 
given standard system RSfd, let Rext be the normal system obtained by replacing 
rules of the form 
with rules of the form 
eq(s,, t,) 2 true A * l l A eq(s,, tn) -I true 1 I--_, I 
where eq( l ,*) is a new binary function symbol and true is a neMF constant (0-ary 
function) symbol. Additionally, Rex’ contains the rule 
eq(x, x j - irue. 
We have the following. 
(Simulation). For any standard rewrite system Rstd and terms s, t, 
RStd t- sit implies Rext - s$t. 
The proof of this theorem (and others to follow) is by induction on the “depth” 
of a proof, by which we mean the maximum depth of recursion in the evaluation 
of conditions. More precisely, depth is defined as follows: 
(I) the depth of a proof of s--, t is 0 ifs--, t is the result of an application 
an unconditional rule; 
(2) the depth of a proof of s + t is one more than the maximum depth 
subproofs for conditions U&J,, . . . , u,J v, if s -+ t is the result of an application 
a substitution instance of the form U&J, A l l l A u,~v, 12 --, r of a rule; 
of 
of 
of 
(3) the depth of a proof s --, s1 --) s2-+ l l l ---, crib =+ v - t,* t- tl - t is ihe 
maximum depi of subproofs for s-sl, s,+s2 ,._, s,,,+v, tn+v ,..., 
t,- t2, t--, tp 
Conditional equational programming 119 
Assume, then, that P has depth m + 1 *$’ the induction hypothesis each subproof 
of P whose depth is at mask ku6 s& iles the property of the theorem. Suppose that 
P uses a substitution instance of a rule of the form 
to replace I by r, and that 
are subproofs in RStd for sJt, , . . . , s, J t,, respectively. e induction hypothesis, 
there are proofs 
P’,,...,P:, 
in Rex’ for s,J tl, . . . , s,J. t,a, respectively. Hence, there are proofs 
PY,...; P:: 
in Rex’ for eq(s, , tl) -+! true, . . . , eq(s,, t,) 2 true, respectively. I[t follows that there 
is a substitution instance of the corresponding rule (in Rex’) of the form, 
eq(s,, t,) 2 true A l 0 . A eq(s,, t,) 4 true 1 I ---, r, 
and in ReXt he same rewrite 2 --, r may be used. Hence, there is a proof P’“’ of sit 
in Rex’. 0 
In general, far two deduction systems R, and in languages (i.e. signatures) L1 
and L2, respectively, where L, is a subset of L2, R2 is called a conservative extension 
of RI, if for every formula 4 which is expressed in _hl, 
R2 I-- 4 implies R, I- 4. 
We have the following converse of the previous theorem. 
eorem (Conservation). For any standard rewrite system Rstd and terms s and 
t (having no occurrence of “eq” and of “true”), ifReXt I- s,/, t then Rstd t- s&t, i.e. Rext 
is a conservative xtension of Rstd. 
Together, the two theorems tell us that for all s an t in the language of 
Rex’ I- s&t iff 
Without 10s~ of ge e language of e assu 
or true. If it does, then, one could choose alternative symbo 
The proof is by induction o 
th is 0, then the same 
e is . 
!2@ IV. Dershowitz, M. Okada 
The inductive ste is similar to that in the previous proof, and uses t 
if eq(s, t) -=+! true is provable in Rext with depth I, then SJ t is also provable in R”“’ 
with the same de , t not containing eq or true. It folio 
Pi of P with dep I for a condition eq(s,, ti) +! true, 
for SiJti in exi with the same depth. By the induction hypothesis, we have 
Rstd + si&ti ; ence, the same rewrite step (of P) can be used for R”‘” I-- s&t. El 
These two theorems state that the expressive power of the class of normal 
systems is the same as that of the class of standard conditional systems. 
But, as we will see in the next section, some confluence results for normal systems 
also require left-linearity, i.e. each varia le occurring in a left-hand side 1 occurs 
only once in 1. In eneral, however, one annot re-express a left-linear non-normal 
system as a left-linear normal system, since we need the non-left-linear rule 
eq( x, x) * true. 
For a comparison of different formulations of conditional revriding see [13]. 
3. conditional convergence 
A convergent (conditional or unconditional) rewriting system is one with both 
confluence and termination properties. Convergent systems give unique normal 
forms for any given term. Ground confluence means that s.J+ t for some v whenever 
s *+ u +* t for a variable-free term u. A ground convergent system is one that is 
both terminating and ground confluent. Ground convergent rewriting may be used 
as the evaluation mechanism for first-order functional programs and lends itself 
easily to parallel evalualion skemes. 
For terminating unconditional systems, the Critical Pair Lemma [33] provides an 
effective test for confluence. Also, for such systems (assuming a finite number of 
rules), the joinability (J,) relation is decidable. Thus, validity is decidable for 
convergent unconditional systems. Unfortunately, with conditional systems, we are 
faced with two new phenomena: 
(a) joinability is not necessarily decidable, even for finite terminating conditional 
systems [32]; 
(b) contrary to what had been surmised [32], the critical pair test does not 
guarantee confluence for terminating standard systems [121. 
TO overcome these difficulties, additional constraints on conditional systems are 
required. 
. i;;6br decreasing standard systems, the basic notions are decidable, i.e. the 
rewrite relation (-+), derivability relation ( +*), joinability relation (J.), and normal 
form attribute are all recursive. 
> 
t e, 
Conditional equational programming 121 
we use the decidability of the related conditions of the form U&V, where u, v < s by 
the decreaskrgness constraint. 
One can readily confirm that decreasing systems are strictly more general than 
“simplifying systems” [32] or “red~&e systems” [Zj but enjoy the same nice 
properties (see [ 131). In fact, decreasing systems exactly capture the finiteness of 
recursive evaluation of terms, in the following technical sense. For given conditional 
system R, let - be the relation defined by s - p if there are a rule s,J t, A l . l A 
s,&, ! I --, r in R and substitution o such that kr is a subterm of s and p is one of 
the sia or tier. The relation ---, u - corresponds to one step of computation, and its 
transitive closure ( ---) u -)+ represents an arbitrary computation branch. 
3.2. For any decreasing natural conditional rewriting system R, the relation 
(-=+ u -)+ is well-founded if and only if R is decreasing. 
roof. The &if” direction foliows-directly from the definition of “decrezsing”. For 
the “only if“’ direction, -we can show that if there are no infinite computations (i.e. 
if no Smite sequences of + and - steps are possible), then the ordering (-, u-u 
D )’ satisfies the conditions for “decreasingness”, where D is the subterm order- 
ing. To see that the latter ordering is well-founded, note that were there an infinite 
chain of -), -) and D, then there would also be an infinite chain of just ---) and -, 
since s --, t D v for some t whenever s D u ---) v for some u, and s - v whenever 
s IT u - v for come u. Cl 
It follows from results in the previous section, th t a in order for a standard rewriting 
system to be complete with respect o provability in the underlying equational system 
(or, equivalently, with respect o validity in the sense of first-order logic -with identity), 
we need either to directly establish its confluence, or else to show that the correspond- 
ing natural system is decreasing and confluent. We turn now to consider conditions 
under which a terminating conditional system if confluent whenever its critical pairs 
are joinable. 
If c]Z-, r andp)s ---, t are rules in a conditional system R and I unifies via most 
general unifier p with a nonvariable subterm of s, then the conditional equation 
cp A pp 3 sp[rp] = tp is a critical pair of where sp[ +I is sp with its subterm 
1~ repkced by rc_c. It can be verified that the critical pair test does ho 
natural systems, i.e. if .saJ tcr for every critical pair c A p 3 s = t a 
such that C~CT and ppa hold, then the system is confluent. 
ershowitz an te~rn~~at~~~g nat 
ing system is confluent if every critical pair is joinable. 
t standard systems require a 
er nonvariable su 
122 N. Dershowitz, M. Okada 
heore (Dershowitz et al. [ 121). A terminating overlay standard conditional 
rewriting system is confluent if every critical pair is joinable. 
This theorem is a corollary of the t’ollowing substitution lemma. 
(Substitution Lemma). In any terminating overlay standard conditional 
, for any terms s, t, r (containing any number of occurrences of s) and 
if r[s, s, . . . s] -! N and s A t hold, then r-is, t, . . . t] -+! N also holds. 
To prove the lemma, we define the degree of a term s, deg(s), so that for any 
terms s and t, deg(s) < deg( t) if s is a subterm of t or t + s. The proof depends on 
a triple induction on (a, b, c), where a is deg(s), b is the depth of the given proof 
of r[s, s, s] -! N, and c is deg( r[s, s, . . . s]). See [ 12 j for more details of the proof. 
We should remark that interpreting Worn clauses as conditional rewrite rules 
(with right-hand side true) leads to an overlay system, because predi :ate symbols 
are never nested in the head of a clause. Furthermore, all critical pairs are joinable, 
since i;!l right-hand sides are the same. This theorem also applies to pattern-directed 
functional languages in which defined functions may not be nested on left-hand sides. 
Recall (from Section 2) that when one side of each condition is an irreducibie 
term (like true), the system is said to be normal. Bergstra and Klop [3] extended 
the confluence result for orthogonal unconditional systems [39] to normal condi- 
tional systems. They showed that any left-linear (possibly nonterminating) normal 
system with no critical pairs is confluent. Since our interest here is solely in 
terminating systems, we can relax the “no critical pair” part. A critical pair cp A 
pp 3 s&=p] = tp, obtained from rules c 1 d - r and p 1 s ---, t, is said to be shallow 
joinable if there exist a term v, a derivation tp +* v with depth less than or equal 
to the depth of the rewrite 1~ - rp, and a derivation sp [ up] -* v with depth less 
than or equal to that of sp --j tp. 
(Dershowitz et al. [ 121). A left-linear terminating normal conditional 
rewriting system is confluent, if every critical pair is shallow joinable. 
his theorem is a corollary of the following. 
.‘7 (Diamond Lemma). Let R be a terminating left-linear, conditional rewrite 
normal system all critical pairs of which are shallow-joinable. Then, [f u -* s with 
depth at most m d t with depth at most n there exists a term v such that s -z v 
with depth at most n and t -z v with depth at most m. 
oof is by induction on the pair (m + n, u) wit ect to the (lexico- 
inatio umbers a 
relation - on ter 
Conditional equational programming 123 
For the last result of this section, we have the following theorem (cf. [32]). 
. A decreasing standa 
critical pair is joinable. 
itio~al rewriting system is confluent if every 
The proof uses a substitution lemma similar to Lemma 3.5. This substitution 
lemma for decreasing systems is proved by induction on the un erl yingwe)l-foun&d 
ordering. In this proof, one need only consider normal systems (by 
By virtue of Theorems 2.3 and 3.3, one can also establish confluent 
standard systems Rstd by showing that the corresponding natural 
decreasing and all its critical pairs are joinable. 
The previous two sections concerned the use of conditional rewrite systems to 
reduce terms to their value and to answer universal queries of the form VZ S[ a] = t[a]. 
In this and the following section, we discuss the application of rewtiting techniques 
to solving existential queries of the form 32 s[a] = t[ZJ. This corresponds to the 
logic-programming capability of resolution-based languages like Prolog. 
Narrowing has been proposed as an extension for solving goals in rewriting-based 
languages. Conditional narrowing may be defined as follows. Let s&t be a goal. If 
s and t are unifiable, then the goal is said to “narrow to true” via their most general 
unifier. Alternatively, if there is a conditional rule c i I + r such that 2 unifies with 
a nonvariable subterm of s (or t) via most general unifier p (the variables in the 
rule are renamed so that they are disjoint from those in s), then all the conditions 
in cp are narrowed in tandem until they are solved, say via substitution p. en we 
say that the top-level goal narrows to s~p&t~p via the composed substitution pp. 
Thus, narrowing is a “linear” process: rules are overlapped only on goals, not on 
other rules. 
For example, given the standard conditional system for append in Section 2, the 
goal append (x, y)J.x narrows using the last rule if null(x)4 false narrows to true. 
using (the renamed rule) null(cons(u, v)) --j false, we can solve the conditi 
narrowing the original goal to cons(car(conp(u, v)), append(cdr(c 
y))Jco~~(~a, v) Rewriting is a special case of narrowing; it reduces the 
to cons(u, append (v, y))J cons& v). This, in turn, is narrowable by the first rule for 
append if null( v)$ true 
new goal cons(u, y)Jcons(u, v). Sine 
narrowing has produced the solution x = cons( u, v) = cons( u, nil) am 
s~bstit~tiQ~ 0-su 
125 N. D,*rshowitz, M. Okada 
complete [ 17). For conditional systems the analogous result is that (under the 
same assumptions) any equationally satisfiable goal can be solved 
narrowing. 
conditions). 
ershowitz and Plaisted [ 151). PJarrowing is complete for ground 
rd conditional rewriting systems (with no extra variables in 
The restriction that all variables occurring in conditions also appear on the left 
will be lifted in the next section. 
For ground convergent systems, all goals may be reduced to normal form before 
any narrowing step. Simplification, that is, reduction via terminating rules, is a very 
powerful feature, particularly when defined function symbols are allowed to be 
arbitrarily nested in left-hand sides. Assuming ground confluence and termination, 
any strategy can be used for simplification. Furthermore, negation can be partially 
handled by incorporating negative information in the form of rewrite rules, which 
are then used to simplify subgoals to false. Combined with eager simplification, this 
approach has the advantage of allowing unsatisfiable goals to be pruned, thereby 
avoiding some potentially infinite narrowing paths (see [ 141). Normalizing before 
narrowing is not necessary, however, and other language proposals employ different 
strategies. Some superfluous paths (that cannot lead to solutions) can be avoided 
by making a distinction between constructor symbol5 and defined ones (assuming 
that terms built entirely from constructors are irreducible). Two terms headed by 
different constructors can never be equal; when headed by the same constructor, 
they are equal if and only if their respective arguments are equal. See, for example 
[14,19,31,49]. Other restrictions and variations of narrowing which preserve com- 
pleteness are included in [25,38,16-J. 
Even if a program is ground convergent, alternative narrowing derivations must 
be explored if completeness is to be assured. Thus, narrowing-based languages that 
deterministically choose one possible narrowing over others cannot guarantee that 
solutions will be found. Preprocessing and structure-sharing techniques for rewriting 
and narrowing are explored in [27]. 
Tt aditional rewriting theory (e.g. [ 231) usually has a constraint on occurrences 
of variables, ely that every variable occurring on a right-hand side of a rule 
also occurs on corresponding left-hand side. A natural extension of this constraint 
for conditional rules is that every variable occurring either in a condition or on the 
t-hand side also occurs on the left. ut if conditional rules are to generalize 
ch a constraint is unacce 
relations, such as transitivity, require extra variables in conditions. 
Conditional equational programming 125 
Accordingly, we can redefine rewriting in the extra-variable case as follows: 
tl[ la] -+ u[r~] for a rule c 1 i * r if there er:ists a substitution T for the new variables 
such that ACT holds. As an example, let us re lace the rules for append with 
append (nil, y ) * y 
xJ,cons(u, v) A append(u, y).Jz 1 append@, y)- cons(u, z), 
where u, v, and z are extra variables. The last rule is applicable if there exist 
substitutions for the extra variables that make the conditions hoid. Now we have 
append (cons(a, nil), nil) --, cons(a, nil), since u = a, v = nil, and z = nil is a solution 
to the conditions. Operationally, narrowing may be used to solve conditions with 
extra variables; the definition of narrowing is unchanged. 
Even with extra v ariables, Theorems 3.4 and 3.6 hold as stated. Mowing extra 
variables, however, does introduce a problem: ground confluence no longer guaran- 
tees the completeness of the narriiwing mechanism [3b]. The following theorem 
allows for extra variables, at the expense of a stronger confluence condition, called 
“level-confluence”. A standard system R is (ground) level-confluent if there exists 
a term v such that whenever s *+ u +* t with a maximum depth of n, there is a 
rewrite proof sJt of depth no greater than n. 
Theorem (Bosco et al. [3b]). Narrowing is complete for terminating ground 
level-confluent s andard conditional rewriting systems. 
The proof of t,kis ~~;~i,~e,_-, IX~ (as *ticll ~5 the previous theorem) is based on the 
following. 
Let R be a standard conditional rewrite system (possibly having extra 
variables). If so -+* t, CT is an irreducible substitution, and all the instances of rewrite 
rules use in the proof (not only the surface proof but also subproofs for conditions) 
are irreducible, then there exist a term u and substitutions q and r such that s narrows 
to u via q, UT = t, and TT = o-. 
By “irreducible substitutron”, wt :nean that the substitution maps all variables 
to irreducible terms; by “irreducible instance”, we mean that the rule k applied to 
a subterm having irreducible terms matching left-hand side variables and any extra 
variables appearing in conditions. 
The lemma is proved by double induction on the depth and length of the derivation 
SO ** t. If the de*;%70 .1. ,tion is empty (has zero ste 
obvious. Suppose then that SG is first reduced us 
cr is irreducible, it must be that s has a nonvariable subterm td sue 
instance 10 of 1, i.e. SO-[ u&j = so[lO] -+ so-[r 
ution for variable 
1% N. Lkrshowitz, Ad. Ohda 
since p$ =ppr, by i uction FI_L narrows to true via some F such that T - pq for 
some irreducible 7. the definition of a single narrowing step, s[u] narrows to 
sgp[ r,up] via pp. Since sa[ r = sppv[ rppql +* induction spp[ rpp] narrows 
to u via some 4, T = &+$ a t = u# for some rcI. ence, we have S[ U] ~;arrows to 
u via pp+, o = pp@,b, and t = u#, as desired. 
f critical pairs does not ensure leve!-con 
he following counterexamp 
dS.h(f(xN If(x) + g(x). 
This normal system is terminating and i,-very critical pair is level-joinable, but despite 
the fact thatf(b) f-f(u) * g(a) ---, g(b), narrowing cannot solve the goalf(b)Jg(x). 
However, since shallow-joinable critical pairs are level-joinable, we can apply 
Theorem 3.6, thereby ensuring completeness of narrowing for terminating left-linear 
shallow-joinable normal systems. The following, similar counterexample demon- 
strates the need for left-linearity: 
k(a, 4S.c Ih(f(a)) --j p(a) 
k(a, a).& I a ---) b 
kc% 43.c Ip(x) ---, q(x) 
4(b) -+j(gW 
h(f0)s.c lfW+g(x) 
jk(bN -> c 
k(x, x) - c. 
An alternative d preach to new variables can be based on the notion of decreasing 
systems. There is f course no way one can insist that left-hand sides be greater 
ces of a condition containing a new variable, Instead, we revise our 
g in the extra-variable case, an 
e can say 
Conditional equational programming 127 
a well-founde? :/r bring containing the (new j rewrite relation + and the proper 
subterm relation ‘Y , and for which la is greater than both terms of each condition 
in CUT, for any irreducible substitution T. 
For exn-- Ul.,Ple, the above append system is decreasing in this sense. Note that the 
joinability of the conditions must take the form x +* cons( u, v) A append (v, y) +* z, 
if the new variables are irreducible. 
Employing the above lemma again, the following theorem can be shown. 
CUN? 2. Narrowing is complete for decreasing ground-confluent standard condi- 
tional rewriting systems. 
Related ideas appear in [3a]. 
6. 
to 
A 
unctions 
In this section, we consider programs utilizing built-in predicates and functions 
evaluate the value for values of given terms. We first 
rule may have the form 
P(t[~l, SCW A QWd) 1 l[f] - r[Kl, 
where P and Q are built-in predicates. For example, we 
using built-in null and nonnull predicates: 
null(x) 1 appendk y) - Y 
consider built-in predicates. 
can define append as before, 
nonnull 1 append (x, y) + cons(car(x), append (cdr( x), y)). 
We assume that a built-in predicate evaluates the Boolean value of a term by some 
mechanism that is independent of rewriting (e.g. by hardware, or using a theorem- 
prover). This is like the “hierarchical” conditional case of [%I. We allow the usual 
eqluational conditions, as before, as well as a mixture of built-in predicates and 
equations such as 
P( t[f], ~[a]) ;I Q(u[X]) A v[Z]Jw[X] 1 l[TJ + r[3]. 
Here we assume that buih-in predicates evaluate truth values only for terms in 
normal form. (In practical applications, they may evaluate only for ground raornnaI 
terms.) More precisely, a rewriting system is usually based on a many-sorte 
in which case a built-in predicate evaluates the truth value for the values (normal 
forms) of given types. For example, if a predicate P(x, , . . . , x,,,) has variables of 
,H, then for any val 
A,,AZ,. . . . A,,,, P(n,, . . . , n,,) returns 
implementation, the normal for 
system needs to be interpret 
1% N. Dmhowitz, M. Okada 
say P(Ws(Ob))?, a interprets it as P(3), then the built-in execution evaluates 
P(3). If P(3) evaluates to true, the condition is satisfied. 
In this new setting, the results of earlier sections can be extended. 
of a decreasing system shoul be modified as follows. A system (wi uilt-ins) is 
&Crasing if there xists a well-founded extension > of the rewrite relation + whit 
satisfies 
he proper subterm relation D and 
S&l A * l l As,&t”AP,(u,)h- l nP,(u,)p rv b > Sig, tig, uj@ 
dindicesi(l~i~~)andj(l<j~m). ith this definition, 
s on decreasing systems till hold. 
core . For a 
predicates : 
creasing standard conditional rewriting system With buih-in 
(4 
(W 
( ) C 
the basic notions are decidable, i.e. the rewrite relation (4. derivability relation 
(-+*), joinability relation (1 ), and normal form attribute ale a!1 recursive (cf 
Theorem 3.1); 
the system is confluent if every critical pair is joinable (cf Theorem 3.8); 
when conjluent, it is equivalent to the corresponding natural system (cf. Theorem 
2.3). 
The earlier induction arguments on the underlying well-founded ordering 
hold. We use a substitution lemma similar to Lemma 3.5 for (b). Here, in 
the induction step we need to show, for example, that if P( u[s]) is trw and s *” t 
then P(u[ t]) is also true. This statement can be reduced to the statement hat if 
ubl!Jv iii%d S + * t then u[ t]JN, where N is a normal form of u[s]. Hence, one 
can ignore the occurrence of built-in predicates in the induction argument. For (c) 
we reg a proof of P( u[ t]) as a normal proof if a proof of u[ t] -* N is normal, 
where is a normal term. Cl 
The same reduction argument as in the proof of the substitution lemma for (b) 
above leads to a modified proof of the substitution lemma corresponding to Lemma 
3.5 for an overlay system, which implies the following. 
in predicates is confluent if every critical pair is joinable. 
terminating overlay standard conditional rewriting system with built 
e define the depth of a proof P(u[ t]) to be the depth of the subproof of 
U[ t] -* N, whale 2v is a normal form. In other words, once a term u[t] reaches a 
normal form it+!, we regard t recess of B(N) as a zero-depth proof. 
e can now use th otion of shallow joinability bas 
t,wec 
Conditional equational programming 128 
A left-linear terminating normal conditional rewriting system with built-in 
predicates is confluent if every critical pair is shallow joina!?? 
Note that built-in predicates typically evaluate only ground terms. In such a 
situation, the above convergence criteria are actually criteria for ground convergence 
only. 
Our earlier results on conditional narrowing can be extended to the case in which 
built-in predicates occur, but completeness requires that built-ins a!So solve for 
variables (not normally the case). In particular, ground confluence for standard 
systems ensures completeness of conditional nar k u ---wfng. The argument for complete- 
ness of conditional narrowing with extra variables holds true even with built-in 
predicates and extra variables, but the definition of level confluence must be rnoa,%ed 
to use the above re-definition of proof-depth. The definition of a decreasing system 
with extra-variable conditions (from the previous section) a!so applies to buih-in 
predicates. 
A condition expressed by a built-in predicate, say P( t[x]) can also be expressed 
by using the corresponding built-in function, say G in the form of G( t[x]) = true. 
Here, G is the characteristic function of P such that G(s) = true iff P(s) for any 
normal term (or ground normal term) of the underlying type. This use of a built-in 
function can naturally be extended to a function of any type, i.e. a function, say G 
oftype P,XP,X l a* x P,, 2 Q, instead of type Boolean. Hence we assume that the 
value of G(m,, . . . , m,) for given (ground) normal terms ml, . . . , m,, of sorts 
PI, * l l 9 P, is a (ground, respectively) normal term of type Q. With this extension, 
all the arguments in this section still hold. 
One may, of course, use composition of built-in functions to express conditions. 
For example, one can use an expression F( G( t), H( S, u)), where F( G( * ), W *, * )) 
is a composition of built-k functions and t, s and u are terms of the rewriting 
system. But we do not allow built-in functions as arguments of non-built-ins. 
The expressiveness of functional languages owes much to the ease with which 
higher-order functions can be defined and used. Rewriting systems, on the other 
hand, are better suited to computing with first-order terms. This suggests that GGZ 
might obtain even 
rewriting systems. It is by no means clear, a priori, t 
e the necessary pro 
1.30 A! Dershowitz, M. Okada 
e Church-Rosser property is preserved (cf. also [4]). The preserv 
termination prope was proved in [44,40,4]. ese two preserva 
the preservation o he convergence property. reazu-Tannen an 
polymorphically typed A-calculus for those preservation res 
purpose of thus se tion is to provide a bas’ framework for co 
A-calculus and co itional term rewriting. e first consider a 
system with only unconditional rewriting and 
We show how to reduce the termin 
uli, and for more general rewrite sy 
conditional case, to our simple framework. 
It is easily seen that intro er order terms provides more expressive 
power in rewriting ules. For example, consider the conditional or unconditional 
first-order rules for appel~d given earlier, along with the following algebraic rules: 
~ppeiid( upheld (I, - append (l, append (m, n )), 
and two additional rules w&h higher-order terms: 
mapcan( X, nil) - nil 
mapcun( X, cons@, I)) ---, append(X(x), mapcan(X, I)). 
Here, nil is a constan+. of base type List; l, m and n are variables of base type List; 
append is of type List x List =I List; x !s a variable of base type, say Integer; cons 
is a function of constant type Integer x List 3 List; X is a higher-order variable of 
type Integw 1 List; and ~~IVCCMI is a higher-order constant of type [Integer 2 List] x 
List 3 List. 
lthough the main result of this section holds for many versions of the typed 
A-calculus, we fix our attention on the simply-typed A-calculus, which we combine 
with a many-sorted rewrite theory. Each function symbol of arity n in the signature 
ofthetheoryhasabasetypeP,xP,x=..xP,~Q,whereP,,P,,...,P,,andQ 
are base types. Given a set {P,, P2, . . . , P,) of base types, we define the general 
notion of (higher order) type inductively: 
(1) If P is a base type then P 
(2) If A and B are types then 
,~(A2~(~=~(A,~B)~~~)) in the abbreviated form A, x A2 x 
T:_:ned h-terms are defined as follows. The language has countably many (free 
e. It may also contain constants. 
Axt is a A-ter 
Conditional equational programming 131 
(3) If & is a A-term of type 
A-term of type B. 
and s is a A-term of type ,?. then t(s) is a 
(Juxtaposition is a binary operation.) 
A-calculus is the reduction system consisting of the following rule 
(called p-reduction ): 
(Ax.t[x])(s) -+ t[s]. 
where each occurrence of the bound variable x is replaced by s, a A-term of the 
same type as ;#. 
We consider combined systems, consisting of an arbitrary convergent erm rewrit- 
ing system and the typed A-calculus as defined above. (Note that the append example 
does not fit this paradigm, since the rewrite rules contain higher-order variables, 
not just symbols of base types.) The following theorem is the principal result of 
this section. 
If a term rewriting system R is terminating, then the combined system 
of R and the types A-calculus is also terminating. 
Preservation of convergence follows as a corollary of this and local confiuence 
(Sublemma 7.9); cf. [5]. 
To prove termination, we modify the strong normalization technique of 
[20,37,48,54]. We assume a fixed version of the computability (reducibility) predi- 
cate used in the usual Tait-Girard type of strong normalization proof. For our 
argument o work, we make the following assumption: 
ition 7.2. If t is of a base type P, then RP( t) (meaning “t belongs to the 
reducibility set of type P”) iff t is strongly normalizable (meaning “no infinite 
reduction sequences from t are possible”). 
The usual definitions of computability predicates for the various typed calculi 
satisfy this condition. This point is that under this common condition, one can 
factor out the computability pLVu._ *od%te from the strong-normalizabili~y argument, 
and just establish the Principal Case given below. 
We give one example of a computability predicate (we will use “ 
as a synonym for a rewrite step +R in R). For e 
computability predicate 
(I) When t is of the 
if for all u of type A 
X%2 N. Dmhowitz, M. Okada 
A(:) ihe,i t is strongly normailizuble. 
For any term s of type A, if RA( s) and t reduces to s in one 
uction on the construction oft 
,...,Xt2R?d 
respectively. 
y induction cm t e length of t. Since t e other cases are similar 
to those in 1373, we describe only the case in w ich the outermost operator is 8 
function symbol, say ,fT in the signature of t e r%write system R. 
In this case, t and any reduced form of t have a base type, say R In particular, 
the symbol A will not appear as the outer t symbol after any reductions for I. 
Hence, by definition of R, to show RP( t), it s ces to show the strong normalizability 
of t. To check for strong normaliza ility of the combined system, we need only 
establish the following one case; all other cases are treated exactly in the same way 
as the traditional argument for strong normalizability of the A-calculus, by computa- 
bility predicates. 
Case 7.6. If t = f (s,, . . . , s,)) is of a base type and s,, . . . , s,, are of base 
type, then t is strongly normalizable. 
For any term t, we define the estimated cap (ec) of t. Assume that t is of the form 
s[ur, l l l . u,], where s is th% maximum subterm of .t sush &at s contains the top 
operator (the rootj a? 1 d is a term of the original language of R. Then s is the cup 
of t. if pure A-terms except for variables of the base type are attached to the cap, 
all such A-terms of each base type are regarded as occurrences of the same 
new variable symbol of that base type when the cap is defined. Variables of base 
types attached to the cap remain (cf. [44,40]). 
or example, if s[z(Ayhx.y), x’(Ay.y), w(v), u] where s is in the signature of I?, 
d w have result type C, xp has result type B, and u is of type C’, then the cap 
x, y, x, u], where x and u are variables of type C and y is of type B. 
The estimated cap (ec) s of term t is the cap for the P-normal form of t (written 
pNF( t)), which is t e irreducible form of t with respect o P-reduction; the p-normal 
form is always det mined uniquely. Hence the estimated cap is uniquely defined 
for any term t. 
We prove thk a case by tcansfinite induction on (ec( t), sub(t)), where sub(t) is the 
multiset {sl, . . s , sJ. The .p sub(t)) is ordered 
component in the well-fou in the multiset 
extension of t reduction relation. 
Conditional equational programming 133 
R&I), l - * 3 RA,,(u,) imply &,(sA.. . , R,, (s,, j for suitable base types PI, . . . , P,. 
y Lemma 3.5, sl,. . . , s, are strongly normalizable. ence, sub(t) is well-founded. 
We consider three subcases as follows: 
(1) t^ is obtained from t by one-step P-reduction. Then obviously wb( !j < sub(t) 
and ec( i) = ec( t). 
(2) t^ is obtained from t by one-step R-reduction, and the -reduction applies 
only within ec( t). Then ec( t^) < ec( t). 
(3 j t^ is obtained from t by one-step R-reduction, 
reduce any part of ec( t). Obviously, sub( t^) < sub(t). 
see from Sublemmas 7.8 and 7.9, ec( t) = ec( t ). 
reduction does not 
er hand, as we will 
ublemma 7.7. If h-terms l,. _ a , s, are qfbase types and ifs,, . . . , s, and t[x, . . . , x] 
are /3-normal forms, then t[s,, . . . , s,] is also a p-normal form. 
This is obvious from the definition of p-normal form. 
Sublenrma 7.8. If t a p-normal form, and ifs is obtained from t by an R-reduction 
that does not reduce any part of the cap oft, then ec( t) = et(s). 
Even if some R-term part collapses by the R-reduction, there is no further 
possibility of P-reduction, by Sublemma 7.7 and there is no further possibility of 
collapsing any A-term part. Mence, ec( t) f et(s). 
Sublemma 7.9 ( Breazu-Tannen [S]). If t Y\“R t^, via some rule in R, then the p-normal 
form of t can be R-reduced to the p-normal form of t” by (possibly repeated use of) 
the same R-rule. 
In particuiar, if the reduction t -)R t^ is in case (3) above, Qkn p N P !) --$ /3 NF( t ) 
is obtained by the reductions only from the part which does not reduce the cap. 
That is, the diagram in Fig. 1 commutes. 0 
R 
P* I I P* 
PNF(t)L 
R 
pw( t) 
Fig. 1. 
The proof of strong normalization ca 
the 
sin 
p_).d N. Dershowitz, M. Ukada 
at and our result is in the last of 
rewriting rules. At the sa 
P which the condition parts ?ge satisfied. 
as the conditiona! one. 
convergence follows fro the fact that the confluence property is preserved 
if a conditional rewriting system R is terminating, then the co~5insd 
and the typed A-calculus is also terminating. 
Now we consider the inclusion of the following rule (called T-reduction): 
Ax.( t(x)) + t, 
where x does not appear in t as a free variable. The analogue of Theorem 7.1 for 
termination (strong normalization) continues to hold and the proof is essentially 
the same as before. Especially, all the lemmas and sublemmas above hold, with 
&normal form re @aced by &T-normal form in the suble _ - s. The only hitch is 
that Sublemma 7.7 does not hold as is for p-q-normal form, but one parallel 
urns the terms to normal form. With this modification, the rest of 
e carried through (cf. [4]). 
e above termination and convergence results also hold for higher order rewrite 
systems, if the rewrite rules are restricted to the form of higher-order primitive 
recursive definition based on given constructor terms [44,29]. Here, the primitive 
recursion takes the following fxm: Let F be a new higher-order constant. For each 
constructor symbo J of the same base type, these is a rule 
F(&! 9 l .Yn!,9 + s[~(Y*,~),...,F(y,,~),Y,,...,y,,fl, 
and for each co stant ck of that type, there is a rule 
F(ck, 2) + t[ji], 
Conditional equational programming 135 
definitions of the form: 
F(Z) -3 ?[a], 
where t is as above (in particular, F does not appear in i). This is a natural extension 
of 66deI’s System T to arbitrary inductive data structures. The rules for mapcan at 
the beginning of this section are a simple example. 
If ajirst-order conditional rewrite system is terminating, then the system 
extended by higher-order constructor-based primitive recursive rules and the typed 
A-calculus is also terminating. 
The usual proof (by computability predicates) for termination of System T (based 
on the typed A-calculus) can be extended to include these primitive-recursive 
higher-order functionals. Then, the combination of this system with a terminatin 
set of first-order rules is terminating, as before. 
In the above, if we relax the constraint on the form of higher-order rewriting, 
then this theorem no longer holds, i.e., there is a terminatiug higher-order rewrite 
system which, when combined with P-reduction, is nonterminating: Consider the 
higher-order rule: F(X(x), x) + F(X(x), X(x)), where F is a higher-order func- 
tional constant and X is a functional variable. If one substitutes Ax.x for X, one 
gets an infinite reduction sequence with this rule and p-reduction: 
F((Ax.x)(x), x)-, F((Ax.x)(x), (hx.x)(x))+ F((Ax.x)(x), x)+ l . l . 
In the previous two sections, we considered extensions of expressive power in 
conditions, allowing existential quantifiers and built-in predicates and functions. 
As the last topic of this section, we consider another extension to expressivity by 
allowing mixed terms with A-expressions in conditions (not in the rule). We consider 
a combined system consisting of a set of such rewrite rules with p-reduction. If one 
can transform the set of conditional rewrite rules to an equivalent terminating set 
of (maybe infinitely many) first-order rewrite rules (not containing A-expressions), 
then one can apply Theorem 7.1 for strong normalization of the combined system. 
In particular, if the free variables are all of base types, one can substitute all normal 
forms of base types (which do not contain A-expressions) for them. 
There is much to be gained from a theory that suppo 
paradigms of program 
make conditional term rewriting an obvious candidate for such a 
help demonstrate that, although the 
more subtle than that of unto 
136 N. Dershowitz, M. Okada 
of comMed highe -order systems, we demonstrate that term rewriting can be 
inczgurated within existing functions1 frameworks without the loss of important 
correctness prope 
fences 
IN 
PI 
r31 
[3al 
13bl 
[41 
PI 
[61 
PI 
WI 
PI 
Cl31 
1141 
WI 
WI 
WI 
L. Bachmair, N. Dershowitz and J. Hsiang, Orderings for equational proofs, in: Proc. IFEE Symp. 
on Logic in Computer Science, Cambridge, MA (1986) 346-357. 
M. BeIIia snd G. Levi, The relation between logic and functional languages: a survey, ./. Lo& 
Prsgramming 3( 3) ( 1986) 2 17-236. 
J.A. Bergstra and J.W. Klop, Conditional rewrite rules: confluency and termination, .I. Comput. 
System Sci. 32 (1986) 323-362. 
H. Bertling and H. Ganzinger, Completion-time optimization of 1 ewrite-time goal solving, in: fioc. 
3rd Internat. Conf on Rewriting Techniques and Applications, Chapel Hill, NC, Lecture Notes in 
Computer Science 355 (Springer, Berlin, 1983) 4,C -58. 
PG. Bosco, E. Giovannetti and C. Moiso, Refined strategies for semantic unification, in: Proc. 
Internat. Joint Conf =n Theory and Practice of Software Development, Pisa, Italy, Lecture Notes in 
Computer Science 250 (Springer, Berlin, 1987) 276-290. 
V. Breazu-Tannen and J. Gallier, Polymorphic rewriting conserves algebraic strong normalization 
and confluence, in: Z+oc. SCALP, 2989, Lecture Notes in Computer Science 372 (Springer, Berlin, 
1989). 
V. Breazu-Tannen, Combining algebra and higher-order types, in: pot. 3rd IEEE Symp. on Logic 
in Computer Science, Edinburgh (1988) 82-90. 
J. Darlington, A.J. Field and H. Pull, The unification of functional and logic languages, in: D. 
DeGroot and G. Lindstrom, ed., Logic Programming (1986) 37-70. 
D. DeGroot and G. Lindstrom, eds., Logic Programming: Functions, Relations, and Equations 
(Prentice Hall, Englewood Cliffs, NJ, 1986). 
P. Deransart, An operational algebraic semantics of PROLOG programs, Internal report, Institut 
National de Recherche en Informatique et Automatique, Le Chesnay, France, 1983. 
N. Dershowitz, Computing with rewrite systems, Technical Report ATR-83( 8478)-l, Information 
Sciences Research Office, The Aerospace Corp., El Segundo, CA, January 1983; revised version 
appeared in Inform. and Control 64 (1985) 122-157. 
N. Dershowitz and J.-P. Jouannaud, Rewrite systems, in: J. van Leeuwen, ed., Handbook of 
Theoretical Computer Science, Vol. B (North-Hoiland, Amsterdam, 1990) 243-320. 
N. Dershowitz and Z. Manna, Proving termination with multiset orderings, Comm. ACM 22(8) 
( 1979) 465-476. 
N. Dershowitz and M. Okada, Proof-theoretic techniques and the theory of rewriting, in: Proc. 
3rd IEEE Symp. on Logic in Computer Science, Edinburgh, Scotland (1988) 104-l 11. 
N. Dershowitz, M. Okada and G. Sivakumar, Confluence of conditional rewrite systems, in: Proc. 
1st Internat. Workshop on Conditional Rewriting, Orsay, France, Lecture Notes in Computer Science 
308 (Springer, Berlin, 1988) 31-44. 
N. Dershowitz, M. Okada asid G. Sivakumar, Canonical conditional rewrite systems, in: Proc. 9th 
Conf on Automated DT&iion, Argonne, IL, Lecture Notes in Computer Science 310 (Springer, 
Berlin, 1988) 538-549. 
N. Dershowitz and D.A. Plaisted, Logic programming cuni applicative programming, in: Proc. 
IEEE Symp. 0~ Logic Programming, Boston, MA (1985) 54&6. 
N. DershG&z and D.A. Plaisted, Equational program;&g, in: J.E. Hayes, D. Michie and 
J. Richards, eds., Machine Intelligetxe Ei; The Lo& and Acquisition of Knowledge (Oxford Press, 
Oxford, 1988) 2 l-56. 
N. Dershowitz and G. Sivakumar, Goal-directed equation solving, in: Proc. 7th National Conf on 
Artijcial Intelligence, St. Paul, MN (1988) 166-170. 
M. Fay, First-order unification in an equational theory, in: Proc. 4th Workshop on Automated 
Deduction, Austin, TX (1979) 161-167. 
Conditional equational programming 137 
[18] L. Fribourg, Oriented equational clauses as a programming language, J. Logic Programming 1 
(1984) 179-210. 
[ 191 L. Fribourg, SLOG: a logic programming language interpreter based on clausal superposition and 
rewriting, in: hoc. IEEE $WZp. on Logic Programming, $oston, MA (1985) 172-184. 
[20] J.Y. Girard, Une extension de l’interpretation de Giidel a l’analyse, et son application h l’&imination 
de coupures dans l’analyse et la theorie des types, in: Boc. 2nd Scandinavian Logic symp. ( 1971) 
63-92. 
[21] J.A. Goguen and J. Meseguer, Equality, types, modules and (why not?) generics for logic program- 
ming, Logic Programming I(2) (1984) 179-210. 
[22] J.A. Goguen and J. Meseguer, EQLOG: Equality, types, and generic modules for logic program- 
ming, in: D. DeGroot and 6. Lindstrom, eds., Logic Programming (1986) 295-363. 
[23] G. Huet, Confluent reductions: abstract properties and applications to term rewriting systems, J. 
Assoc. Computing Mach. 27(4) (1980) 797-821. 
[24] G. Huet and D.C. Oppen, Equations and rewrite rules: a survey, in: R. Book, ed., Formal Language 
Theory: Perspectives and Open Problems (Academic Press, New York, 1980) 349-405. 
[25] J.-M. Hullot, Canonical forms and unification, in: Proc. 5th Conf on Automated Deduction, Les 
Arcs, France, Lecture Notes in Computer Science $7 (Springer, Berlin, 1980) 318-334. 
[26] 18. Jayaraman and F.S.K. Silbermann, Equations, sets, and reduction semantics for functional and 
logic programming, in: Proc. ACM Conf: on LISP and Functional Programming, Cambridge, MA 
( 1986) 320-33 1. 
[ 271 N.A. Josephson and N. Dershowitz, An implementation of narrowing, J. Logic Programming 6( 1,2) 
(1989) 57-77. 
[28] J.-P. Jouannaud and B. Waldmann, Reductive conditional term rewriting systems, in: fioc. 3rd 
lFiP Working Conf: on Formal Description of Programming Concepts, Ebberup, Denmark (1986). 
[29] J.-P. Jouannaud and M. Okada, Rewriting with higher order terms, in preparation. 
1301 KM. Kahn, Uniform-A language based upon unification which unifies much of Lisp, Prolog 
and Act 1, in: Proc. 7th Internat. Joint Conf on Artificial IntelhgPn~e, Vancouver, B.C. ( 1981) 933-939. 
[31] T. Kacamori, Computation by meta-unification with constructars, Report TR-152, institute for 
New Generation Computer Technology, Tokyo, Japan, 1985. 
[32] S. Kaplan, Simplifying conditional term rewriting systems: unification, termination and confluence, 
J. Symbolic Comput. 4(3) (1987) 295-334. 
[32a] J.W. Klop, Combinatory Reduction Systems, Mathematical Centre Tracts 127 (Centre for Mathe- 
matics and Computer Science, Amsterdam, 1980). 
[33] D.E. Knuth and P.B. Bendix, Simple word problems in universal algebras, in: J. Leech, ed., 
Computational Problems in Abstract Algebra (Pergamon Press, Oxford, 1970) 263-297. 
[34] H.J. Komorowski, QLOG-The programming environment for PROLOG in LISP, in: K.L. Clarke 
and S.-A. Tarnlund, eds., Logic Programming (Academic Press, New York, 1983) 315-322. 
[35] G. Lindstrom, Functional programming and the logic variable, in: Proc. 12th ACM Symp. on 
Principles of Programming Languages, New Orleans, LA (1985) 266-280. 
1361 Y. Malachi, Z. Manna and R.J. Waldinger, TABLOG: the deductive tableau programming language, 
in: Proc. ACM Symp. on LlSP and Functional Programming, Austin, TX (1984) 323-330. 
[37] P. Martin-Lof, Haupsatz for the theory of species, in: Proc. 2nd Scandinavian Logic Symp. (1971) 
217-233. 
[38] A. Martelli, C. Moiso and G.F. Rossi, An algorithm for unification in equational theories, in: 
Proc. IEEE Symp. on Logic Programming, Salt Lake City, UT (1986) 180- 186. 
[39] M.J. Q’Dotineil, Computing in Systems Described by Equations, Lecture Notes in Computer Science 
58 (Springer, Berlin, 1977). 
[40] M. Okada, Strong normalizability for the combined system of the pure typed A-calculus and an 
arbitrary convergent term rewrite system, in: hoc. Internat. Symp. on Symbohc and Algebraic 
Computation (1989). 
[41] M. Okada and P, Grr?gnr?o, Practical application of conditional term rewriting systems, in: &cc. 
IX Conf of the Chilean Computer Science Society/XV Latin American Conf on hh-matics (1989). 
[42] M. Okada and k. Grogono, New results in term rewriting theory, in: hoc. OJ the hewat. co@ 
on Symbolic and Logic Computation (1989). 
WI Okada, Note on a proof of the extended nite trees, 
W SXada, Int to proof theory for computer science, Unpublished 
toratoire de Infmnatique, Universite de Paris&d, Orsay, Fra 
. Okada, Proof-theoretic ordiraals and ordering structures in ter 
19841 157- 165. 
ii&m, c~~~~tativ~ty. and associativ- 
ity, J. Assoc. Compuc Mtxh. 21(4$ ~~9~4~ 622-642. 
6. Smolka, FRES cation and ~~~ti~~e r sult 5, in: D. DeGroot 
and G. Llndstrom, eds., Lcq$c 524. 
W.W. Tail, Intensional intern on of functionals finite type, J. Synddic Logic 32 (1967) 
198-212. 
H. Tamaki, Semantics of a logic programming language with a reducibility predicate, in: Proc. 
Programming, Atlantic City, NJ ( 1984) 259-264. 
y, Contextual rewriting, in: Proc. 1st Intern. Conf: on Rewriting Techiqws 
ad Appkakm, Dijon, France, Lecture Notes in Computer Science 202 (Springer, Berlin2 1985) 
46-62. 
