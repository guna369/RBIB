Conﬂuence of Orthogonal Nominal Rewriting Systems Revisited
Takaki Suzuki, Kentaro Kikuchi, Takahito Aoto, and Yoshihito Toyama
RIEC, Tohoku University, 2-1-1 Katahira, Aoba-ku, Sendai, Miyagi, 980-8577, Japan {takaki, kentaro, aoto, toyama}@nue.riec.tohoku.ac.jp
Abstract Nominal rewriting systems (Fernández, Gabbay & Mackie, 2004; Fernández & Gabbay, 2007) have been introduced as a new framework of higher-order rewriting systems based on the nominal approach (Gabbay & Pitts, 2002; Pitts, 2003), which deals with variable binding via permutations and freshness conditions on atoms. Conﬂuence of orthogonal nominal rewriting systems has been shown in (Fernández & Gabbay, 2007). However, their deﬁnition of (non-trivial) critical pairs has a serious weakness so that the orthogonality does not actually hold for most of standard nominal rewriting systems in the presence of binders. To overcome this weakness, we divide the notion of overlaps into the self-rooted and proper ones, and introduce a notion of –-stability which guarantees –-equivalence of peaks from the self-rooted overlaps. Moreover, we give a su cient criterion for uniformity and –-stability. The new deﬁnition of orthogonality and the criterion o er a novel conﬂuence condition e ectively applicable to many standard nominal rewriting systems. We also report on an implementation of a conﬂuence prover for orthogonal nominal rewriting systems based on our framework.
1998 ACM Subject Classiﬁcation F.4.1 Mathematical Logic
Keywords and phrases Nominal rewriting, Conﬂuence, Orthogonality, Higher-order rewriting, –-equivalence
Digital Object Identiﬁer 10.4230/LIPIcs.RTA.2015.301
1 Introduction
Expressive formal systems such as systems of predicate logics, ⁄-calculi, process calculi, etc. need variable binding. Nominal rewriting [5][3] is a framework that extends ﬁrst-order term rewriting by a binding mechanism. Studies of nominal rewriting are preceded by extensive studies of a nominal approach to terms and uniﬁcations [6][13][17]. A distinctive feature of the nominal approach is that –-conversion and capture-avoiding substitution are not relegated to meta-level—they are explicitly dealt with at object-level. This makes nominal rewriting signiﬁcantly di erent from classical frameworks of higher-order rewriting systems such as Combinatory Reduction Systems [8] and Higher-Order Rewriting Systems [9] based on ‘higher-order syntax’.
Conﬂuence is a fundamental property of rewriting systems. As expected, the ﬁrst results on conﬂuence of nominal rewriting systems (NRSs for short) are generalisations of two classical results on conﬂuence, namely Rosen’s criterion (orthogonal systems are conﬂuent) and Knuth-Bendix’s criterion (terminating and locally conﬂuent systems are conﬂuent) [3]. We notice, however, that the conﬂuence criterion in [3] for orthogonal NRSs is not applicable to standard NRSs—as the orthogonality in [3] contains the emptiness of the root overlaps of equivariant rules obtained from the same rule (self-rooted overlaps), which does not hold if
© Takaki Suzuki, Kentaro Kikuchi, Takahito Aoto, and Yoshihito Toyama; licensed under Creative Commons License CC-BY 26th International Conference on Rewriting Techniques and Applications (RTA’15). Editor: Maribel Fernández; pp. 301–317
Leibniz International Proceedings in Informatics Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

302 Conﬂuence of Orthogonal Nominal Rewriting Systems Revisited
the system contains a rewrite rule with binders (cf. Remark at the end of Subsection 3.2). Moreover, in contrast to the ﬁrst-order case, one cannot skip the joinability check of selfrooted overlaps (cf. Example 19)—thus, if one relaxes the deﬁnition of orthogonality to omit such overlaps, then conﬂuence is not guaranteed.
The contributions of this paper are summarised as follows:
Our rewrite relation does not allow –-equivalent terms on the result of rewriting. Accordingly, we come to study conﬂuence properties of rewriting modulo –-equivalence, which enables us to perform ﬁne-grained analysis where conﬂuence modulo and Church-Rosser modulo are di erent properties. Such an approach was suggested in [19, page 220].
We overcome the above-mentioned defect of the orthogonality in [3] by introducing a notion of –-stability, which guarantees –-equivalence of peaks from the self-rooted overlaps. We prove Church-Rosser modulo –-equivalence for the class of orthogonal nominal rewriting systems that are uniform and –-stable.
We introduce a notion of abstract skeleton preserving (ASP) as a su cient criterion for uniformity and –-stability. To show the –-stability of ASP rewrite rules, we prove some lemmas on the system of –-equivalence in the nominal setting, which seem to be new.
We report on an implementation of a conﬂuence prover for nominal rewriting systems based on our criterion, that is, orthogonality and ASP. To check the emptiness of the proper overlaps, we use equivariant uniﬁcation [2] with one permutation variable.
While a rewrite system in [5][3] is deﬁned as an inﬁnite set of rewrite rules that is closed under equivariance, we deﬁne a rewriting system as a ﬁnite set of rewrite rules. Instead of appealing to the property of equivariance, we specify a permutation as a parameter in each rewrite relation. (The idea of specifying a permutation as a parameter is found also in [4].) This allows us to make a discussion on avoiding capture of a free atom (cf. the latter part of Example 10) without referring to the property of equivariance.
As regards related work, Vestergaard and Brotherston [18][19] study a conﬂuence proof of ⁄-calculus with variable names, not in the nominal setting, where –-conversion is seriously taken into account. Their deﬁnition of conﬂuence is that of the reﬂexive transitive closure of æ– ﬁ æ—. Formalisation of a conﬂuence proof of ﬁrst-order orthogonal term rewriting systems has been studied, e.g. in [11]. Our proof of Church-Rosser modulo –-equivalence can be seen as an extension of an inductive conﬂuence proof of ﬁrst-order orthogonal term rewriting systems (e.g. [16, Section 4.7] and [7]).
The organisation of the paper is as follows. In Section 2, we explain basic notions and notations of nominal rewriting. In Section 3, we discuss problems on conﬂuence in nominal rewriting, and prove conﬂuence of a class of nominal rewriting systems. In Section 4, we give a su cient criterion for the class, and conclude in Section 6.
2 Nominal rewriting
Nominal rewriting [5][3] is a framework that extends ﬁrst-order term rewriting by a binding mechanism. In this section, we redeﬁne nominal rewriting systems as ﬁnite sets of rewrite rules, and introduce a notion of rewrite relation that is related to but di erent from the rewrite relation deﬁned in [5][3]. In the subsequent sections, we will study conﬂuence properties on our notion of rewrite relation.

T. Suzuki, K. Kikuchi, T. Aoto, and Y. Toyama

303

2.1 Nominal terms

First, we introduce notions and notations concerning nominal terms. A nominal signature is a set of ﬁxed arity function symbols ranged over by f, g, . . . .
We ﬁx a countably inﬁnite set X of variables ranged over by X, Y, Z, . . . , and a countably inﬁnite set A of atoms ranged over by a, b, c, . . . , and assume that , X , and A are pairwise disjoint. Unless otherwise stated, di erent meta-variables for objects in , X , or A denote di erent objects. A swapping is a pair of atoms, written (a b). Permutations ﬁ are bijections on A such that the set of atoms for which a ”= ﬁ(a) is ﬁnite. Permutations are represented by lists of swappings applied in the right-to-left order. For example, ((b c)(a b))(a) = c, ((b c)(a b))(b) = a, ((b c)(a b))(c) = b. We write Id for the identity permutation, ﬁ≠1 for the inverse of ﬁ, and ﬁ ¶ ﬁÕ for the composition of ﬁÕ and ﬁ.
Nominal terms, or simply terms, are generated by the grammar

t, s ::= a | ﬁ·X | [a]t | f t | (t1, . . . , tn)

and called, respectively, atoms, moderated variables, abstractions, function applications (which must respect the arity of the function symbol) and tuples. We abbreviate Id·X as
X if there is no ambiguity. We write f () as simply f . An abstraction [a]t is intended
to represent t with a bound. The set of free atoms occurring in t, denoted by FA(t), is deﬁned as follows:tFA(a) = {a}; FA(ﬁ·X) = ÿ; FA([a]t) = FA(t) \ {a}; FA(f t) = FA(t); FA((t1, . . . , tn)) = i FA(ti). We write V (t)(™ X ) for the set of variables occurring in t. A linear term is a term in which any variable occurs at most once.

I Example 1. A nominal signature for the ⁄-calculus has two function symbols lam and

app with arity 1 and 2, respectively. The nominal term app(lam([a]lam([b]app(a, X))), a)

represents the ⁄-term (⁄a.⁄b.aX)a in the usual notation. Here X is a (meta-level) variable

which can be instantiated by another term possibly with free atoms a and b. For this term t,

we have FA(t) = {a} and V (t) = {X}.

J

Positions are ﬁnite sequences of positive integers. The empty sequence is denoted by Á. The
set of positions in a term t, denoted by Pos(t), is deﬁned as follows: Ptos(a) = Pos(ﬁ·X) = {Á}; Pos([a]t) = Pos(f t) = {1p | p œ Pos(t)} ﬁ {Á}; Pos((t1, . . . , tn)) = i{ip | p œ Pos(ti)} ﬁ {Á}. The subterm of t at a position p œ Pos(t) is written as t|p. For each X œ V (t), we deﬁne
PosX (t) = {tp œ Pos(t) | ÷ﬁ. t|p = ﬁ·X}, and the set of variable positions in t is deﬁned by PosX (t) = XœV (t) PosX (t). The set of atom positions in t is deﬁned by PosA(t) = {p œ Pos(t) | ÷a œ A. t|p = a}, and we deﬁne PosX A(t) = PosX (t) ﬁ PosA(t).
A context is a term in which a distinguished function symbol ⇤ with arity 0 occurs. The term obtained from a context C[ ] by replacing each ⇤ at positions pi by terms ti is written as C[t1, . . . , tn]p1,...,pn or simply C[t1, . . . , tn].
Next, we deﬁne two kinds of permutation actions, which operate on terms extending a
permutation on atoms. These actions are used to deﬁne substitution, –-equivalence and
rewrite relation for nominal rewriting systems. The ﬁrst permutation action, written ﬁ·t, is deﬁned inductively by: ﬁ·a = ﬁ(a); ﬁ·(ﬁÕ·X) = (ﬁ ¶ ﬁÕ)·X; ﬁ·(t1, . . . , tn) = (ﬁ·t1, . . . , ﬁ·tn); ﬁ·([a]t) = [ﬁ·a](ﬁ·t); ﬁ·(f t) = f ﬁ·t. The second permutation action, written tﬁ, is deﬁned by: aﬁ = ﬁ(a); (ﬁÕ·X)ﬁ = (ﬁ ¶ ﬁÕ ¶ ﬁ≠1)·X; (t1, . . . , tn)ﬁ = (tﬁ1 , . . . , tﬁn); ([a]t)ﬁ = [aﬁ](tﬁ); (f t)ﬁ = f tﬁ. The di erence consists in the clause for moderated variables. In particular, when ﬁÕ = Id, ﬁ is suspended before X in the ﬁrst action as ﬁ·(Id·X) = (ﬁ ¶ Id)·X = ﬁ·X, while in the second action ﬁ has no e ect as (Id·X)ﬁ = (ﬁ ¶ Id ¶ ﬁ≠1)·X = Id·X.
A substitution is a map ‡ from variables to terms such that the set {X œ X | ‡(X) ”= X}
is ﬁnite. Substitutions act on variables, without avoiding capture of atoms. We write t‡ for

RTA 2015

304 Conﬂuence of Orthogonal Nominal Rewriting Systems Revisited

Ò „ a#b Ò „ a#[a]t

Ò „ a#t Ò „ a#f t
Ò „ a#t Ò „ a#[b]t

Figure 1 Rules for freshness constraints.

Ò „ a#t1 · · · Ò „ a#tn Ò „ a#(t1, . . . , tn)
ﬁ≠1·a#X œ Ò Ò „ a#ﬁ·X

Ò „ a ¥– a
Ò „ t ¥– s Ò „ [a]t ¥– [a]s

Ò „ t ¥– s Ò „ f t ¥– f s

Ò „ t1 ¥– s1 · · · Ò „ tn ¥– sn Ò „ (t1, . . . , tn) ¥– (s1, . . . , sn)

Ò „ (a b)·t ¥– s Ò „ b#t Ò „ [a]t ¥– [b]s

’a œ ds(ﬁ, ﬁÕ). a#X œ Ò Ò „ ﬁ·X ¥– ﬁÕ·X

Figure 2 Rules for –-equivalence.

the application of ‡ on t. Note here that by replacing X of a moderated variable ﬁ·X in t by ‡(X), a permutation action ﬁ·(‡(X)) occurs. For a permutation ﬁ and a substitution ‡, we deﬁne the substitution ﬁ·‡ by (ﬁ·‡)(X) = ﬁ·(‡(X)).

2.2 –-equivalence and nominal rewriting systems

The distinctive feature of nominal rewriting is that it is equipped with a mechanism to avoid accidental capture of free atoms on the way of rewriting. This is partly achieved by –-conversion built in the matching process of the LHS of a rule and a redex involving also permutations (cf. Example 10).
In this subsection, we ﬁrst recall the notion of –-equivalence in the nominal setting. This is di erent from –-equivalence in the traditional sense in that equivalence between terms is discussed under assumptions on the freshness of atoms in variables.
A pair a#t of an atom a and a term t is called a freshness constraint. Intuitively, this means that a does not occur as a free atom in t, including the cases where the variables in t are instantiated by other terms. A ﬁnite set Ò ™ {a#X | a œ A, X œ X } is called a freshness context. For a freshness context Ò, we deﬁne V (Ò) = {X œ X | ÷a. a#X œ Ò}, Òﬁ = {aﬁ#X | a#X œ Ò}, and Ò‡ = {a#‡(X) | a#X œ Ò}.
The rules in Figure 1 deﬁnes the relation Ò „ a#t, which means that a#t is satisﬁed under the freshness context Ò. It can be seen that a œ/ FA(t) whenever Ò „ a#t. An example using the last rule is {c#X} „ a#((a b)(b c))·X, since ((a b)(b c))≠1·a = ((b c)(a b))(a) = c.
The rules in Figure 2 deﬁnes the relation Ò „ t ¥– s, which means that t is –-equivalent to s under the freshness context Ò. ds(ﬁ, ﬁÕ) in the last rule denotes the set {a œ A | ﬁ·a ”= ﬁÕ·a}. For example, ds((a b), Id) = {a, b}.

I Example 2. Consider the nominal signature for the ⁄-calculus in Example 1, and suppose Ò = {a#X, b#X}. Then we have the following derivation:

a#X œ Ò b#X œ Ò

Ò „ a#X Ò „ b#X b#X œ Ò

Ò „ (a b)·X ¥– X

Ò „ b#X

Ò „ [a]X ¥– [b]X

Ò „ lam([a]X) ¥– lam([b]X)

J

T. Suzuki, K. Kikuchi, T. Aoto, and Y. Toyama

305

The following properties are shown in [3].

I Proposition 3 ([3]). 1. Ò „ a#t if and only if Ò „ ﬁ·a#ﬁ·t. 2. Ò „ t ¥– s if and only if Ò „ ﬁ·t ¥– ﬁ·s. 3. If Ò „ a#t and Ò „ t ¥– s then Ò „ a#s. 4. ’a œ ds(ﬁ, ﬁÕ). Ò „ a#t if and only if Ò „ ﬁ·t ¥– ﬁÕ·t.
I Proposition 4 ([3]). For any freshness context Ò, the binary relation Ò „ ≠ ¥– ≠ is a congruence (i.e. an equivalence relation that is closed under any context C[ ]).

For terms with no variables, this relation coincides with usual –-equivalence (i.e. the relation reached by renamings of bound atoms) [6].
Now we deﬁne nominal rewrite rules and nominal rewriting systems.

I Deﬁnition 5 (Nominal rewrite rule). A nominal rewrite rule, or simply rewrite rule, is a triple of a freshness context Ò and terms l and r such that V (Ò) ﬁ V (r) ™ V (l). We write
Ò „ l æ r for a rewrite rule. A rewrite rule Ò „ l æ r is left-linear if l is linear. We deﬁne V (Ò „ l æ r) = V (Ò) ﬁ V (l) ﬁ V (r) and (Ò „ l æ r)ﬁ = Òﬁ „ lﬁ æ rﬁ.

I Example 6. Using the nominal signature for the ⁄-calculus in Example 1, the ÷-rule can be represented by the following rewrite rule (we omit the braces on the LHS of „):

a#X „ lam([a]app(X, a)) æ X (Eta)

This rule is left-linear.

J

I Deﬁnition 7 (Nominal rewriting system). A nominal rewriting system, or simply rewriting system, is a ﬁnite set of rewrite rules. A rewriting system is left-linear if so are all its rewrite
rules.

I Example 8. We extend the signature in Example 1 by a function symbol sub with arity 2. By sub([a]t, s), we represent an explicit substitution tÈa := sÍ. Then, a nominal rewriting
system to perform —-reduction is deﬁned by the rule (Beta):

„ app(lam([a]X), Y ) æ sub([a]X, Y ) (Beta)

together with a rewriting system R‡ to execute substitution:

Y __] R‡ = __[
b#Y

„ sub([a]app(X, Y ), Z) æ app(sub([a]X, Z), sub([a]Y, Z)) „ sub([a]a, X) æ X „ sub([a]b, X) æ b „ sub([a]lam([b]X), Y ) æ lam([b]sub([a]X, Y ))

(‡app) (‡var) (‡var‘) (‡lam)

In a standard notation, the system R‡ is represented as follows:

Y __] R‡ = __[
b#Y

„ (XY )Èa := ZÍ æ (XÈa := ZÍ)(Y Èa := ZÍ) „ aÈa := XÍ æ X „ bÈa := XÍ æ b „ (⁄b.X)Èa := Y Í æ ⁄b.(XÈa := Y Í)

(‡app) (‡var) (‡var‘) (‡lam)

J

RTA 2015

306 Conﬂuence of Orthogonal Nominal Rewriting Systems Revisited

In [5][3], nominal rewrite systems are deﬁned as inﬁnite sets of rewrite rules that are closed under equivariance, i.e., if R is a rule of a rewrite system R then so is Rﬁ for any permutation ﬁ. In the present paper, we deﬁne rewriting systems as ﬁnite sets of rewrite rules that may not be closed under equivariance. Accordingly, our rewrite relation is deﬁned with a permutation as a parameter unlike in the deﬁnition of rewrite relation in [5][3]. In the following, „ is extended to mean to hold for every member of a set or a sequence on the RHS.

I Deﬁnition 9 (Rewrite relation). Let R = Ò „ l æ r be a rewrite rule. For a freshness context and terms s and t, the rewrite relation is deﬁned by

„ s æÈR,ﬁ,p,‡Í t ≈de∆f

„ Òﬁ‡, s = C[sÕ]p, „ sÕ ¥– lﬁ‡, t = C[rﬁ‡]p

where V (l) ﬂ (V ( ) ﬁ V (s)) = ÿ. We write „ s æÈR,ﬁÍ t if there exist p and ‡ such that „ s æÈR,ﬁ,p,‡Í t. We write „ s æR t if there exists ﬁ such that „ s æÈR,ﬁÍ t. For a
rewriting system R, we write „ s æR t if there exists R œ R such that „ s æR t.

I Example 10. Using the rule (Beta) in Example 8, we see that the term representing (⁄a.⁄b.ba)b rewrites to (⁄b.ba)Èa := bÍ, that is, we have

„ app(lam([a]lam([b]app(b, a))), b) æÈBeta,Id,Á,‡Í sub([a]lam([b]app(b, a)), b)

where ‡ is the substitution [X := lam([b]app(b, a)), Y := b]. The resulting term rewrites further to a normal form lam([c]app(c, b)) in four steps with rules of the system R‡. Here we give a detail of the ﬁrst step with rule (‡lam) to see how capture of a free atom is avoided.
Let s = sub([a]lam([b]app(b, a)), b). Since the rule has a freshness context Ò = {b#Y }, to apply (‡lam) to s at the position p = Á, it is necessary to ﬁnd a permutation ﬁ and a substitution ‡ that satisfy „ Òﬁ‡ and „ s ¥– (sub([a]lam([b]X), Y ))ﬁ‡. Here one cannot simply take ﬁ = Id, because then ‡(Y ) = b from the condition for ¥–, which contradicts „ Òﬁ‡. So we take, e.g. ﬁ = (b c) and ‡ = [X := app(c, a), Y := b] to satisfy the conditions, and get (lam([b]sub([a]X, Y )))ﬁ‡ = lam([c]sub([a]app(c, a), b)) as the result of rewriting. J
In the following, a binary relation „ ≠ ÛÙ ≠ (ÛÙ is æR, ¥–, etc.) with a ﬁxed freshness context is called the relation ÛÙ under , or simply the relation ÛÙ if there is no ambiguity. If a relation ÛÙ is written using æ then the inverse is written using Ω. Also, we write ÛÙ= for the reﬂexive closure, and ÛÙú for the reﬂexive transitive closure. We use ¶ for the composition
of relations.
I Remark. In [5, page 113][3, page 946], the rewrite relation, which we denote by „ s ≠F≠G≠MæR t, is deﬁned in the following way. For a given rewrite rule R = Ò „ l æ r,
„ s ≠F≠G≠MæR t holds if 1. V (R) ﬂ (V ( ) ﬁ V (s)) = ÿ. 2. s = C[sÕ] for some context C[ ] and term sÕ, such that „ Ò‡, „ sÕ ¥– l‡ for some ‡. 3. „ t ¥– C[r‡]. Hence, ≠F≠G≠MæR di ers from our æR in the following two points. First, the rules of a rewrite system in [5][3] are closed under equivariance, so that the rewrite relation is deﬁned without
a permutation as a parameter. Secondly, –-equivalent terms are allowed on the result of rewriting. Consequently, under the same freshness context, we have ≠F≠G≠MæR = æÈR,IdÍ ¶ ¥–.

3 Conﬂuence of nominal rewriting systems
Having deﬁned basic notions on nominal terms and nominal rewriting systems, we now set out to investigate conﬂuence properties on the rewrite relations of nominal rewriting systems.

T. Suzuki, K. Kikuchi, T. Aoto, and Y. Toyama

307

To be exact, we study conﬂuence properties modulo the equivalence relation ¥– in terms of abstract reduction systems [10].
I Deﬁnition 11. Let R be a nominal rewriting system. 1. æR is conﬂuent modulo ¥– if „ s (ΩúR ¶ æúR) t implies „ s (æúR ¶ ¥– ¶ ΩúR) t. 2. æR is Church-Rosser modulo ¥– if
„ s (ΩR ﬁ æR ﬁ ¥–)ú t implies „ s (æúR ¶ ¥– ¶ ΩúR) t. 3. æR is strongly compatible with ¥– if „ s (¥– ¶ æR) t implies „ s (æ=R ¶ ¥–) t.
It is known that Church-Rosser modulo an equivalence relation ≥ is a stronger property than conﬂuence modulo ≥ [10]. So we aim to prove Church-Rosser modulo ¥– for some class of nominal rewriting systems. The strong compatibility with ¥– also plays an important role in proving Church-Rosser modulo ¥– through results in [10].

3.1 Self-rooted and proper overlaps
In the study of conﬂuence, the notion of overlaps is important because they are useful for analysing how peaks „ s æR t and „ s æR tÕ occur. In this subsection, we introduce two kinds of overlaps and give some examples.
First, we deﬁne uniﬁcation for nominal terms. Let P be a set of equations and freshness constraints {s1 ¥ t1, . . . , sm ¥ tm, a1#u1, . . . , an#un} (where ai and aj may denote the same atom). Then, P is uniﬁable if there exist a freshness context and a substitution ◊ such that „ s1◊ ¥– t1◊, . . . , sm◊ ¥– tm◊, a1#u1◊, . . . , an#un◊; the pair È , ◊Í is called a uniﬁer of P . It is known that the uniﬁcation problem for nominal terms is decidable [17].

I Example 12. Consider the nominal signature for the ⁄-calculus in Example 1, and let

P = {lam([a]app(X, a)) ¥ lam([a]Y ), a#X}. Then, È{a#X}, [Y := app(X, a)]Í is a uniﬁer

of P .

J

I Deﬁnition 13 (Overlap). Let Ri = Òi „ li æ ri (i = 1, 2) be rewrite rules. We assume without loss of generality that V (R1) ﬂ V (R2) = ÿ. If Ò1 ﬁ Òﬁ22 ﬁ {l1 ¥ l2ﬁ2 |p} is uniﬁable for some permutation ﬁ2 and a non-variable position p, then we say that R1 overlaps on R2, and the situation is called an overlap of R1 on R2. If R1 and R2 are identical modulo renaming of variables and p = Á, then the overlap is said to be self-rooted. An overlap that is
not self-rooted is said to be proper.

I Example 14. Let R1 and R2 be the rules (Eta) a#X „ lam([a]app(X, a)) æ X and

(Beta) „ app(lam([a]Y ), Z) æ sub([a]Y, Z) from Examples 6 and 8, respectively. Then, R1

overlaps on R2, since {a#X} ﬁ {lam([a]app(X, a)) ¥ (app(lam([a]Y ), Z))Id|11(= lam([a]Y ))}

is uniﬁable as seen in Example 12. This overlap is proper.

J

I Example 15. There exist self-rooted overlaps of the rule (Beta) on its renamed variant, since {app(lam([a]Y ), Z) ¥ (app(lam([a]X), W ))ﬁ} is uniﬁable for any permutation ﬁ. In the case of ﬁ(a) = b, we take È{a#X, b#X}, [Y := X, Z := W ]Í as a uniﬁer (cf. Example 2). J

In ﬁrst-order term rewriting, self-rooted overlaps do not matter, and only proper overlaps need to be analysed. However, in the case of nominal rewriting, that is not enough as seen in the next subsection.

RTA 2015

308 Conﬂuence of Orthogonal Nominal Rewriting Systems Revisited

3.2 Problems on conﬂuence of nominal rewriting systems
In this subsection, we discuss problems on conﬂuence in nominal rewriting that are not present in ﬁrst-order term rewriting.
A standard conﬂuence criterion in rewriting theory is the one by orthogonality.

I Deﬁnition 16 (Orthogonality). A nominal rewriting system R is orthogonal if it is left-linear and for any rules R1, R2 œ R, there exists no proper overlap of R1 on R2.
This deﬁnition of orthogonality is di erent from the one in [3] (cf. Remark at the end of this subsection).
Unlike in ﬁrst-order term rewriting, orthogonality is not enough to guarantee conﬂuence of a nominal rewriting system.
I Example 17. Consider the nominal rewriting system Ruc-÷ with the only rewrite rule:

„ lam([a]app(X, a)) æ X (Uncond-eta)

The system Ruc-÷ is orthogonal, but is not Church-Rosser (even conﬂuent) modulo ¥–, since

„ lam([a]app(a, a)) æÈUncond-eta,IdÍ a and „ lam([a]app(a, a)) æÈUncond-eta,(a b)Í b. The latter

follows from „ lam([a]app(a, a)) ¥– lam([b]app(b, b)) = (lam([a]app(X, a)))(a b)[X := b] (the

third condition of rewrite relation in Deﬁnition 9).

J

The above kind of rules can be excluded by the uniformity condition introduced in [3]. Intuitively, uniformity means that if an atom a is not free in s and s rewrites to t then a is not free in t. Here we employ the following deﬁnition of uniformity which is equivalent to the one in [3].

I Deﬁnition 18 (Uniformity). A rewrite rule Ò „ l æ r is uniform if for any atom a and any freshness context , „ Ò and „ a#l imply „ a#r. A rewriting system is uniform if
so are all its rewrite rules.

The rule (Uncond-eta) in Example 17 is not uniform, since „ a#lam([a]app(X, a)) but not „ a#X. Uniform rewriting systems have many good properties, which we use in the proof of conﬂuence in the next section.
Our deﬁnition of orthogonality together with uniformity does not guarantee conﬂuence of a nominal rewriting system, as seen in the next example.

I Example 19. We extend the signature in Example 1 by a function symbol uc-eta-exp with arity 1. Consider the nominal rewriting system Ruc-÷-exp with the only rewrite rule:

„ uc-eta-exp(X) æ lam([a]app(X, a)) (Uncond-eta-exp)

The system Ruc-÷-exp is orthogonal and uniform. Uniformity follows from the observation

that for any atom aÕ and any freshness context , if „ aÕ#uc-eta-exp(X), which is

equivalent to „ aÕ#X, then „ aÕ#lam([a]app(X, a)). We see, however, that Ruc-÷-exp is

not Church-Rosser (even conﬂuent) modulo ¥–, since „ uc-eta-exp(a) æÈUncond-eta-exp,IdÍ

lam([a]app(a, a)) and „ uc-eta-exp(a) æÈUncond-eta-exp,(a b)Í lam([b]app(a, b)), where the res-

ulting two terms are normal forms in Ruc-÷-exp and not –-equivalent.

J

So orthogonality together with uniformity is still not enough to guarantee conﬂuence of a nominal rewriting system. In the next section, we consider another condition that excludes rewrite rules like the rule (Uncond-eta-exp) in Example 19.

T. Suzuki, K. Kikuchi, T. Aoto, and Y. Toyama

309

I Remark. It is claimed in [3] that terminating uniform nominal rewrite systems are conﬂuent if all non-trivial1 critical pairs are joinable, and that orthogonal uniform nominal rewrite
systems are conﬂuent. However, the latter criterion is not applicable to standard nominal
rewrite systems: In [3], a critical pair is said to be trivial if it is obtained from the root overlap of the same (renamed) rewrite rule or obtained from a variable overlap2, where
overlaps are considered without permutations unlike in our Deﬁnition 13, and a nominal
rewrite system is said to be orthogonal if it is left-linear and has no non-trivial critical pair.
Then, for example, a critical pair obtained from the root overlap of the two rules (Beta) and (Beta)ﬁ (cf. Example 15) is non-trivial, and so any rewrite system with the rule (Beta), which also has (Beta)ﬁ by equivariance, is not orthogonal in the sense of [3]. The same can be said of many other rewrite rules and systems.

3.3 Conﬂuence proof of orthogonal nominal rewriting systems
In the previous subsection, we discussed problems on conﬂuence that are peculiar to nominal rewriting. In this subsection, we prove conﬂuence (Church-Rosser modulo ¥–) for a class of nominal rewriting systems with one more condition besides uniformity and orthogonality. The proof can be considered as an adaptation of inductive conﬂuence proofs of ﬁrst-order orthogonal term rewriting systems found, e.g. in [16, Section 4.7] and [7]. We omit some of (the details of) the proofs, which are available at [15].
First, we deﬁne a notion of parallel reduction using a particular kind of contexts.

I Deﬁnition 20. The grammatical contexts, ranged over by G[ ], are the contexts deﬁned by

G[ ] ::= a | ﬁ·X | [a]⇤ | f ⇤ | (⇤1, . . . , ⇤n)

Let R be a nominal rewriting system. For a given freshness context , we deﬁne the relation „ ≠ ≠qæR ≠ inductively by the following rules:

„ s1 ≠æq R t1 · · ·

„ sn ≠æq R tn

„ G[s1, . . . , sn] ≠æq R G[t1, . . . , tn]

(context)

„ s æÈR,ﬁ,Á,‡Í t R œ R „ s ≠æq R t

(head)

where n (Ø 0) depends on the form of G[ ]. We deﬁne „ ‡ ≠æq R ” by ’X. „ X‡ ≠æq R X”.

I Lemma 21. 1. „ s ≠æq R s. 2. If „ s ≠æq R t then „ C[s] ≠æq R C[t]. 3. If „ s æÈR,ﬁ,p,‡Í t then „ s ≠æq R t. 4. If „ s ≠æq R t then „ s æúR t.
Instead of showing the diamond property of ≠æq R as in usual conﬂuence proofs, we prove strong local conﬂuence modulo ¥– (Lemma 27), which together with strong compatibility with ¥– (Lemma 22) yields Church-Rosser modulo ¥– of ≠æq R (and hence of æR).

I Lemma 22 (Strong compatibility with ¥–). Let R be a uniform nominal rewriting system. If „ sÕ ¥– s ≠æq R t then there exists tÕ such that „ sÕ ≠æq R tÕ ¥– t.

Proof. By induction on the derivation of „ s ≠æq R t. For the details, see [15].

J

1 As mentioned soon, the deﬁnition of non-trivial here is di erent from the standard one. 2 This deﬁnition is not very standard, but it is not the point here.

RTA 2015

310 Conﬂuence of Orthogonal Nominal Rewriting Systems Revisited

The key lemma to strong local conﬂuence modulo ¥– is Lemma 25, which corresponds to Lemma 4.7.7 of [16, page 122] in the ﬁrst-order case. To show it, we ﬁrst prove the following two technical lemmas.

I Lemma 23. Let R be a nominal rewriting system, and let R = Ò „ l æ r œ R and Rˆ = Òˆ „ ˆl æ rˆ œ R (we assume V (R) ﬂ V (Rˆ) = ÿ). Suppose that lÕ is a proper subterm of lﬁ for some ﬁ where lÕ is not a moderated variable, and that there exist ‡, ﬁˆ, ‡ˆ, , s that satisfy „ Òﬁ‡, „ s ¥– lÕ‡, „ Òˆ ﬁˆ ‡ˆ and „ s ¥– ˆlﬁˆ ‡ˆ. Then R is not orthogonal.

Proof. Let p be the position of the subterm lÕ of lﬁ, i.e., lﬁ|p = lÕ. Since Òˆ ﬁ Òﬁˆ≠1¶ﬁ ﬁ {ˆl ¥

lﬁˆ≠1¶ﬁ|p(= lÕﬁˆ≠1 )} is uniﬁable with a uniﬁer È , ﬁˆ≠1·(‡ˆ ﬁ ‡)Í, R is not orthogonal.

J

I Lemma 24. Let R be a uniform rewriting system. Then, if „ Ò‡, „ s ¥– ﬁ·X‡ and „ s ≠æq R t then there exists ” such that „ Ò”, „ t ¥– ﬁ·X”, „ ‡ ≠æq R ” and for
any Y ”= X, Y ‡ = Y ”.

Now we prove the announced lemma.

I Lemma 25. Let R be an orthogonal uniform rewriting system, and let Ò „ l æ r œ R. Suppose that lÕ is a proper subterm of lﬁ for some ﬁ. Then, if „ Òﬁ‡, „ s ¥– lÕ‡ and
„ s ≠æq R t then there exists ” such that „ Òﬁ”, „ t ¥– lÕ”, „ ‡ ≠æq R ” and for any X œ/ V (lÕ), X‡ = X”.

Proof. By induction on lÕ. The case where lÕ is a moderated variable ﬁÕ·X follows from

Lemma 24. For the other cases, we ﬁrst show that the last rule used in the derivation of

„ s ≠æq R t can not be (head). Suppose otherwise. Then by the deﬁnition of rewrite

relation, we have „ Òˆ ﬁˆ‡ˆ and „ s ¥– ˆlﬁˆ‡ˆ for some ﬁˆ, ‡ˆ and Òˆ „ ˆl æ rˆ œ R. However,

by Lemma 23, this contradicts the orthogonality of R. Hence, the last rule used in the

derivation of „ s ≠æq R t is (context). The rest of the proof is by case analysis according to

the form of lÕ. For the details, see [15].

J

Now we introduce a notion of –-stability for proving Lemma 27. This notion as well as uniformity may be introduced independently from the study of conﬂuence as a notion that yields well-behaved rewriting. Here we consider a version in which the redex position is Á.

I Deﬁnition 26 (–-stability). A rewrite rule R = Ò „ l æ r is –-stable if „ s ¥– sÕ, „ s æÈR,ﬁ,Á,‡Í t and „ sÕ æÈR,ﬁÕ,Á,‡ÕÍ tÕ imply „ t ¥– tÕ. A rewriting system R is
–-stable if so is every rewrite rule R œ R.

The rule (Uncond-eta-exp) in Example 19 is not –-stable, since, as we saw,
„ uc-eta-exp(a) æÈUncond-eta-exp,Id,Á,[]Í lam([a]app(a, a)) and „ uc-eta-exp(a) æÈUncond-eta-exp,(a b),Á,[]Í lam([b]app(a, b)), but not „ lam([a]app(a, a)) ¥– lam([b]app(a, b)). In the next section, we give a su cient criterion for –-stability.
Now we show that ≠æq R is strongly locally conﬂuent modulo ¥– for a class of orthogonal nominal rewriting systems.

I Lemma 27 (Strong local conﬂuence modulo ¥–). Let R be an orthogonal rewriting system that is uniform and –-stable. If „ s ≠æq R t and „ s ≠æq R tÕ then there exist u and uÕ such that „ t ≠æq R u, „ tÕ ≠æq R uÕ and „ u ¥– uÕ.

Proof. By induction on s. We distinguish cases according to the last rules used in the derivations of „ s ≠æq R t and „ s ≠æq R tÕ. 1. Both rules are (head). If they are by the same rewrite rule R œ R, then we use the
–-stability of R. Otherwise, this case contradicts the orthogonality of R.

T. Suzuki, K. Kikuchi, T. Aoto, and Y. Toyama

311

2. Both rules are (context). The claim follows from the induction hypothesis. 3. One is (context) and the other is (head). It can be shown that the claim holds by using
Lemma 24 or Lemma 25. For the details, see [15]. J
We are now ready to show that æR is Church-Rosser modulo ¥–.
I Theorem 28 (Church-Rosser modulo ¥–). Let R be an orthogonal nominal rewriting system that is uniform and –-stable. Then, æR is Church-Rosser modulo ¥–.
Proof. By Lemma 22, ≠æq R is strongly compatible with ¥–, and by Lemma 27, ≠æq R is strongly locally conﬂuent modulo ¥–. Hence by the results in [10], ≠æq R is Church-Rosser modulo ¥–. Since æR ™ ≠qæR ™ æúR by Lemma 21, æR is Church-Rosser modulo ¥–. J

4 Criterion for uniformity and –-stability
In this section, we consider a su cient criterion for uniform and –-stable nominal rewriting systems. The main reason why a rewrite rule R does not keep –-stability is that some free atom occurring in a term is bounded through a rewrite step by R. However, such irrelevant rewrite steps can be avoided by adding an appropriate constraint to the freshness context of R. We introduce the notion of abstract skeleton preserving for characterising this constraint and show it gives a su cient criterion for uniformity and –-stability.
Throughout this section, di erent meta-variables for atoms may denote the same atom.

4.1 Abstract skeleton
The abstract skeleton of a nominal term is deﬁned as a subterm abstracted with the binders occurring on the path from the root position Á to the position of the subterm.

I Deﬁnition 29 (Abstract skeleton). For a nominal term t and a position p œ Pos(t), skel(p, t) is deﬁned as follows:
skel(Á, s) = s skel(1q, [a]s) = [a]skel(q, s) skel(1q, f s) = skel(q, s) skel(iq, (s1, . . . , sn)) = skel(q, si)
skel(p, t) is called an abstract skeleton at p of t. skel(p, t) = [a1] . . . [an]s is non-duplicating if i ”= j implies ai ”= aj. We deﬁne Skel(t) = {skel(p, t) | p œ Pos(t)}.

I Example 30. Figure 3 shows the abstract skeletons at the leaf positions of the left and

the right hand sides of the rule (‡lam) in Example 8.

J

For each X œ V (t), we deﬁne SkelX (t) = {skel(p, t) | p œ PosX (t)}. We also deﬁne SkelX (t) = {skel(p, t) | p œ PosX (t)}, SkelA(t) = {skel(p, t) | p œ PosA(t)}, and SkelX A(t) = SkelX (t) ﬁ SkelA(t).
The following lemmas are useful for discussing the freshness context and the –-equivalency of the term through the decomposed parts. (For the proofs, see [15].)

I Lemma 31. I Lemma 32.

„ a#t‡ ≈∆ ’u œ SkelX A(t). „ a#u‡ „ t‡ ¥– tﬁﬂ ≈∆ ’u œ SkelX A(t). „ u‡ ¥– uﬁﬂ

RTA 2015

312 Conﬂuence of Orthogonal Nominal Rewriting Systems Revisited

sub([a]lam([b]X), Y )
sub

lam([b]sub([a]X, Y ))
lam

(, ) [b]

[a] Y

sub

lam (, )

[b] [a] Y

XX [a] [b]

[b] [a] [b]

X
[a][b]X

Y
Y

X
[b][a]X

Y
[b]Y

Figure 3 Abstract skeletons of sub([a]lam([b]X), Y ) and lam([b]sub([a]X, Y )).

4.2 Abstract skeleton preserving rewrite rules
In this subsection, we introduce the notions of abstract skeleton preserving rules and systems. First, we restrict rewrite rules to the following ones.
I Deﬁnition 33 (Standard). A nominal rewrite rule Ò „ l æ r is standard when: (S1) For every moderated variable ﬁ·X appearing in l or r, ﬁ = Id, (S2) FA(r) ™ FA(l), (S3) Every abstract skeleton [a1] . . . [an]t œ Skel(l) ﬁ Skel(r) is non-duplicating. A nominal rewriting system R is standard if so is every rewrite rule R œ R.
All examples of rewrite rules we treated so far are standard. We now deﬁne the abstract skeleton preserving nominal rewriting systems.
I Deﬁnition 34 (Abstract skeleton preseving). A nominal rewrite rule Ò „ l æ r is abstract skeleton preserving (ASP for short) if it is standard and
’[a1] . . . [am]X œ SkelX (r).÷[b1] . . . [bn]X œ SkelX (l).’a œ ds({ai}i, {bj}j). a#X œ Ò
where ds({ai}i, {bj}j) is the set of atoms such that a œ {a1, . . . , am} and a œ/ {b1, . . . , bn}, or a œ/ {a1, . . . , am} and a œ {b1, . . . , bn}. A nominal rewriting system R is abstract skeleton preserving (ASP for short) if so is every rewrite rule R œ R.
It is easy to judge whether a standard rewrite rule is ASP or not. The rule (Uncond-eta) in Example 17 and the rule (Uncond-eta-exp) in Example 19 are not ASP. All the other rewrite rules we treated so far are ASP.
In the rest of this section, we show that the ASP property gives a su cient criterion for the uniformity and the –-stability of nominal rewriting systems. First we prove the uniformity of ASP rewrite rules.
I Lemma 35. An ASP rewrite rule is uniform.

T. Suzuki, K. Kikuchi, T. Aoto, and Y. Toyama

313

Proof. We show that for any ASP rewrite rule R = Ò „ l æ r, if „ Ò and „ a#l then

„ a#r. Suppose „ Ò and „ a#l. From the latter, we have ’u œ SkelX A(l). by Lemma 31. Similarly, the conclusion „ a#r is equivalent to ’u œ SkelX A(r). We show „ a#u for u œ SkelA(r) and for u œ SkelX (r), respectively.

„ a#u „ a#u.

1. u œ SkelA(r). Then u has the form [a1] . . . [am]b. If a œ {a1, . . . , am} or b ”= a, then „ a#[a1] . . . [am]b holds. Otherwise, we have a = b œ FA(r). Since R is standard,
a œ FA(l); contradicting „ a#l.

2. u œ SkelX (r). Then u has the form [a1] . . . [am]X. If a œ {a1, . . . , am} then „ a#[a1] . . . [am]X holds. Otherwise, it is enough to show „ a#X. Since R is ASP, there exists [b1] . . . [bn]X œ SkelX (l) such that ’a œ ds({ai}i, {bj}j). a#X œ Ò. Since we have ’u œ SkelX A(l). „ a#u, it holds that „ a#[b1] . . . [bn]X. Thus, if a œ/ {b1, . . . , bn} then „ a#X. If a œ {b1, . . . , bn}, then we have a œ ds({ai}i, {bj}j) because now we discuss the case of a ”œ {a1, . . . , am}. Hence, a#X œ Ò holds. Since we suppose „ Ò, „ a#X is obtained.

J

4.3 –-stability of abstract skeleton preserving rewrite rules

Next, we prove the –-stability of ASP rewrite rules. For this, we need to derive –-equivalence of respective reducts sÕ and tÕ of terms s, t, from –-equivalence of s and t. The idea is to use
Lemma 32 and infer –-equivalence via abstract skeletons. Recall abstract skeletons of the rule
(‡lam) in Example 30. Here, an abstract skeleton [a][b]X in LHS changes to [b][a]X in RHS. Thus, [a][b]X ¥– [c][d]XÕ should imply [b][a]X ¥– [d][c]XÕ. But generally, this is not true;
for example, we have „ [a][a]a ¥– [a][b]b but ”„ [a][a]a ¥– [b][a]b. This can be guaranteed,
however, for non-duplicating skeletons (cf. Lemma 36). Another abstract skeleton Y in LHS changes to [b]Y in RHS in Example 30. Again, „ Y ¥– Y Õ does not imply „ [b]Y ¥– [b]Y Õ
in general. Fortunately, the freshness constraint of the rule (‡lam) contains b#Y . Thus, it su ces to guarantee b#Y, b#Y Õ „ Y ¥– Y Õ implies b#Y, b#Y Õ „ [b]Y ¥– [b]Y Õ, which is
indeed the case (cf. Lemma 37). The proofs of the following lemmas are found in [15].

I Lemma 36. Let two terms [a1] . . . [an]s and [b1] . . . [bn]t be both non-duplicating. Then,
„ [a1] . . . [ai] . . . [aj] . . . [an]s ¥– [b1] . . . [bi] . . . [bj] . . . [bn]t =∆ „ [a1] . . . [aj] . . . [ai] . . . [an]s ¥– [b1] . . . [bj] . . . [bi] . . . [bn]t

I Lemma 37. Let two terms [a1] . . . [an]s and [b1] . . . [bn]t be both non-duplicating, and let „ ai#s, bi#t. Then,

≈∆

„ [a1] . . . [ai≠1][ai][ai+1] . . . [an]s ¥– [b1] . . . [bi≠1][bi][bi+1] . . . [bn]t „ [a1] . . . [ai≠1][ai+1] . . . [an]s ¥– [b1] . . . [bi≠1][bi+1] . . . [bn]t

I Lemma 38. If „ t‡ ¥– tﬁﬂ then ’a œ FA(t). a = ﬁ·a.

I Theorem 39. ASP nominal rewriting systems are uniform and –-stable.

Proof. We show that if R is ASP then every R = Ò „ l æ r œ R is –-stable, that is,
„ s ¥– sˆ · „ s æÈR,ﬁ,Á,‡Í t · „ sˆ æÈR,ﬁˆ,Á,‡ˆÍ tˆ =∆ „ t ¥– tˆ.
Considering Rﬁ as R and ﬁˆ ¶ ﬁ≠1 as ﬁˆ, we can take ﬁ = Id without loss of generality. (Note that if R is ASP then so is Rﬁ. ) Thus from here on we take Id as ﬁˆ. From the deﬁnition of

RTA 2015

314 Conﬂuence of Orthogonal Nominal Rewriting Systems Revisited

the rewrite relation,

„ s æÈR,ﬁ,‘,‡Í t ≈∆ „ sˆ æÈR,Id,‘,‡ˆÍ tˆ ≈∆

„ Òﬁ‡, „ s ¥– lﬁ‡, t = rﬁ‡ „ Ò‡ˆ, „ sˆ ¥– l‡ˆ, tˆ = r‡ˆ

From the assumption and the transitivity, we have „ Òﬁ‡, „ Ò‡ˆ and „ l‡ˆ ¥– lﬁ‡. Now our aim is to show „ r‡ˆ ¥– rﬁ‡. Here, we have

„ l‡ˆ ¥– lﬁ‡ ≈∆ ’u œ SkelX A(l). „ u‡ˆ ¥– uﬁ‡ (from Lemma 32) „ r‡ˆ ¥– rﬁ‡ ≈∆ ’v œ SkelX A(r). „ v‡ˆ ¥– vﬁ‡ (from Lemma 32)

(1)

We show „ v‡ˆ ¥– vﬁ‡ for v œ SkelA(r) and for v œ SkelX (r), respectively.
1. v œ SkelA(r). Then v has the form [a1] . . . [am]b.
a. b œ {a1, . . . , am}. First we show „ [ai]ai ¥– [ﬁ·ai]ﬁ·ai. It is clear when ai = ﬁ·ai. When ai ”= ﬁ·ai, from „ ﬁ·ai#ai and „ (ai ﬁ·ai)·ai ¥– ﬁ·ai it follows. Moreover, for aj(”= ai), „ aj#ai and „ ﬁ·aj#ﬁ·ai hold. Since v and ﬁ·v are non-duplicating, applying Lemma 37 to „ [ai]ai ¥– [ﬁ·ai]ﬁ·ai repeatedly, we obtain „ [a1] . . . [ai≠1][ai][ai+1] . . . [am]ai ¥– [ﬁ·a1] . . . [ﬁ·ai≠1][ﬁ·ai][ﬁ·ai+1] . . . [ﬁ·am]ﬁ·ai Thus „ v‡ˆ ¥– vﬁ‡ follows.
b. b œ/ {a1, . . . , am}. It is clear that b œ FA(r). Since R is standard, b œ FA(l). From „ l‡ˆ ¥– lﬁ‡ and Lemma 38 it holds that b = ﬁ·b. Thus, „ b ¥– ﬁ·b. Moreover, „ aj#b and „ ﬁ·aj#ﬁ·b for every aj. Since v and ﬁ·v are non-duplicating,
applying Lemma 37 to „ b ¥– ﬁ·b repeatedly, we obtain „ v‡ˆ ¥– vﬁ‡.
2. v œ SkelX (r). Then v has the form [a1] . . . [am]X. Since R is ASP, there exists [b1] . . . [bn]X œ SkelX (l) such that ’a œ ds({ai}i, {bj}j). a#X œ Ò. By (1), we have „ ([b1] . . . [bn]X)‡ˆ ¥– ([b1] . . . [bn]X)ﬁ‡, that is, „ [b1] . . . [bn]X‡ˆ ¥– [ﬁ·b1] . . . [ﬁ·bn]X‡. Now, let {c1, . . . , ck} = {a1, . . . , am}ﬂ{b1, . . . , bn}. Then ’a œ ds({bj}j, {ch}h).a#X œ Ò and ’a œ ds({ﬁ·bj}j, {ﬁ·ch}h). a#X œ Òﬁ. From „ Ò‡ˆ and „ Òﬁ‡, we obtain ’a œ ds({bj}j, {ch}h). „ a#X‡ˆ and ’a œ ds({ﬁ·bj}j, {ﬁ·ch}h). „ a#X‡. Similarly, ’a œ ds({ai}i, {ch}h). „ a#X‡ˆ and ’a œ ds({ﬁ·ai}i, {ﬁ·ch}h). „ a#X‡. Therefore,
„ [b1] . . . [bn]X‡ˆ ¥– [ﬁ·b1] . . . [ﬁ·bn]X‡

≈∆ „ [c1] . . . [ck]X‡ˆ ¥– [ﬁ·c1] . . . [ﬁ·ck]X‡ (from Lemmas 36 and 37)

≈∆ „ [a1] . . . [am]X‡ˆ ¥– [ﬁ·a1] . . . [ﬁ·am]X‡ (from Lemmas 36 and 37)

≈∆ „ v‡ˆ ¥– vﬁ‡

J

By Theorems 28 and 39, we have the following corollary.

I Corollary 40. Let R be an orthogonal nominal rewriting system that is ASP. Then, æR is Church-Rosser modulo ¥–.

I Example 41. The rewriting system R‡ in Example 8 is left-linear and has no proper

overlaps, and hence orthogonal. Moreover, all its rewrite rules are ASP. Hence, æR‡ is

Church-Rosser modulo ¥– by Corollary 40.

J

5 Implementation and Experiments
We have implemented a conﬂuence prover for NRSs proving that input NRSs are CR modulo ¥–, based on Corollary 40. We note that recently some conﬂuence provers for TRSs and CTRSs are emerged (e.g. [1, 20, 14]) and the competition of conﬂuence provers have been

T. Suzuki, K. Kikuchi, T. Aoto, and Y. Toyama

315

Table 1 Summary of experiments.

NRS

LL non-PO ASP result time (ms)

1

R‡

XX

X CR

3

2

NNF of f.o.-formulas without DNE

XX

X CR

<1

3

Ruc-÷-exp

XX

◊ Failure

<1

4 PNF of f.o.-formulas (Example 44 [3]) X

◊

X Failure

20

5

NNF of f.o.-formulas

X◊

X Failure

<1

6

{Beta} ﬁ R‡

X◊

X Failure

8

7

{Beta} ﬁ {Eta} ﬁ R‡

X◊

X Failure

3

8

—-reduction (Example 43 [3])

X◊

X Failure

29

9

÷-expansion (Introduction [3])

XX

X CR

<1

10 structural substitution for ⁄µ-term ([12]) X

X

X CR

17

11 fragment of ML ([3])

X◊

X Failure

152

12 {a#X „ f (X) æ [a]X}

XX

X CR

<1

13 {„ f (X) æ [a]X}

XX

◊ Failure

<1

14 {a#X „ X æ [a]X} (Proof of Lemma 56 [3])

XX

X CR

<1

15

Non-joinable trivial critical pair (Proof of Lemma 56 [3])

X

X

◊ Failure

<1

16 PNF of f.o.-formulas with additional rules (Example 44 [3])

X

◊

X Failure

33

17

Substitution for ⁄-term (Example 43 [3])

X

◊

X Failure

27

18 {Eta}

XX

X CR

<1

19 Ruc-÷

XX

◊ Failure

<1

held annually3. In contrast, no conﬂuence provers for NRSs has been known previously, up to our knowledge.
In order to prove conﬂuence of an NRS R based on Corollary 40, we have to show that (1) R is orthogonal and (2) R is abstract skeleton preserving (ASP). It is straightforward to check (2), as the standardness is just a syntactical restriction and Ò „ a#X is easily checked for any freshness constraint Ò, a œ A and X œ X . For (1), one has to check (1-a) left-linearity and that (1-b) there’s no proper overlaps. The checking of (1-a) is easy. For (1-b), we have to check whether Ò1 ﬁ Òﬁ22 ﬁ {l1 ¥ l2ﬁ2 |p} is uniﬁable for some permutation ﬁ2, for given Ò1, Ò2, l1, l2|p—this problem is di erent from nominal uniﬁcation problems as ﬁ2 is not ﬁxed. Fortunately, the problem can be directly reduced to a problem of equivariant uniﬁcation [2], which has been known to be decidable. From the equivariant uniﬁcation algorithm in [2], we obtain a constraint of ﬁ2 for uniﬁability, if the problem is equivariantly uniﬁable. Our system reports concrete critical pairs generated from this constraint, if there is a proper overlap.
We have tested our conﬂuence prover with 19 NRSs, collected from the literature, and constructed during our study. The summary of our experiments is shown in Table 1. The columns below ‘NRS’, ‘LL’, ‘non-PO’, ‘ASP’ , ‘result’ ‘time (ms)’ show the input NRS, left-linearity, non-existence of proper overlaps, ASP, the result of the conﬂuence prover and

3 Conﬂuence Competition (CoCo) http://coco.nue.riec.tohoku.ac.jp/

RTA 2015

316 Conﬂuence of Orthogonal Nominal Rewriting Systems Revisited
execution time in millisecond, respectively. Here, PNF (NNF) denotes rules for computing prenex normal forms (resp. negation normal forms), and DNE denotes double negation elimination (not (not X) æ X). The symbol ‘X’ denotes that the property holds, and the symbol ‘◊’ denotes that the property does not hold, which have been checked by the prover. Among 19 examples, our prover succeeded in proving conﬂuence of 7 examples. All tests have been performed in a PC equipped with Intel Core i7-4600U processors of 2.1GHz and a memory of 8GB.
All details of the experiments are available on the webpage http://www.nue.riec. tohoku.ac.jp/tools/experiments/rta15nrs/.
6 Conclusion
Using our notion of rewrite relation with a permutation as a parameter, we have presented a proof of Church-Rosser modulo ¥– for the class of orthogonal nominal rewriting systems that are uniform and –-stable. Moreover, we have introduced a notion of abstract skeleton preserving as a su cient criterion for uniformity and –-stability. We have also implemented a conﬂuence prover based on our result on Church-Rosser modulo ¥– for abstract skeleton preserving rewriting systems.
As continuations of this work, we are going to study conﬂuence of nominal rewriting systems with proper overlaps in both terminating and non-terminating cases. In such studies, it will be necessary to investigate joinability check of critical pairs with permutation variables. This is left as future work.
Acknowledgements. We would like to thank the anonymous referees for useful comments. This research was supported by JSPS KAKENHI Grant Numbers 25330004, 25280025 and 15K00003.
References
1 T. Aoto, Y. Yoshida, and Y. Toyama. Proving conﬂuence of term rewriting systems automatically. In Proceedings of RTA’09, LNCS 5595, pages 93–102. Springer-Verlag, 2009.
2 J. Cheney. Equivariant uniﬁcation. Journal of Automated Reasoning, 45:267–300, 2010. 3 M. Fernández and M. J. Gabbay. Nominal rewriting. Information and Computation,
205:917–965, 2007. 4 M. Fernández and M. J. Gabbay. Closed nominal rewriting and e ciently computable
nominal algebra equality. In Proceedings of LFMTP’10, EPTCS 34, pages 37–51, 2010. 5 M. Fernández, M. J. Gabbay, and I. Mackie. Nominal rewriting systems. In Proceedings of
PPDP’04, pages 108–119. ACM Press, 2004. 6 M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax with variable binding.
Formal Aspects of Computing, 13:341–363, 2002. 7 D. Kesner. Conﬂuence. Course material, http://www.pps.univ-paris-diderot.fr/
~kesner/enseignement/master1/semantique/ConfluenceSP-4.pdf. 8 J. W. Klop, V. van Oostrom, and F. van Raamsdonk. Combinatory reduction systems:
introduction and survey. Theoretical Computer Science, 121:279–308, 1993. 9 R. Mayr and T. Nipkow. Higher-order rewrite systems and their conﬂuence. Theoretical
Computer Science, 192:3–29, 1998. 10 E. Ohlebusch. Church-Rosser theorems for abstract reduction modulo an equivalence rela-
tion. In Proceedings of RTA’98, LNCS 1379, pages 17–31. Springer-Verlag, 1998. 11 A. C. R. Oliveira and M. Ayala-Rincón. Formalizing the conﬂuence of orthogonal rewriting
systems. In Proceedings of LSFA’12, EPTCS 113, pages 145–152, 2012.

T. Suzuki, K. Kikuchi, T. Aoto, and Y. Toyama

317

12 M. Parigot. ⁄µ-calculus: an algorithmic interpretation of classical natural deduction. In Proceedings of LPAR’92, LNAI 624, pages 190–201. Springer-Verlag, 1992.
13 A. M. Pitts. Nominal logic, a ﬁrst order theory of names and binding. Information and Computation, 186:165–193, 2003.
14 T. Sternagel and A. Middeldorp. Conditional conﬂuence (system description). In Proceedings of Joint RTA and TLCA’14, LNCS 8560, pages 456–465. Springer-Verlag, 2014.
15 T. Suzuki, K. Kikuchi, T. Aoto, and Y. Toyama. Conﬂuence of orthogonal nominal rewriting systems revisited. http://www.nue.riec.tohoku.ac.jp/user/kentaro/cr-nominal/.
16 Terese. Term Rewriting Systems. Cambridge University Press, 2003. 17 C. Urban, A. M. Pitts, and M. J. Gabbay. Nominal uniﬁcation. Theoretical Computer
Science, 323:473–497, 2004. 18 R. Vestergaard and J. Brotherston. A formalised ﬁrst-order conﬂuence proof for the ⁄-
calculus using one-sorted variable names. In Proceedings of RTA’01, LNCS 2051, pages 306–321. Springer-Verlag, 2001. 19 R. Vestergaard and J. Brotherston. A formalised ﬁrst-order conﬂuence proof for the ⁄calculus using one-sorted variable names. Information and Computation, 183:212–244, 2003. 20 H. Zankl, B. Felgenhauer, and A. Middeldorp. CSI – A conﬂuence tool. In Proceedings of CADE’11, LNAI 6803, pages 499–505. Springer-Verlag, 2011.

RTA 2015

