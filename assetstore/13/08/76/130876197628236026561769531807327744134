  
 
Universidade de Bras√≠lia 
Instituto de Ci√™ncias Exatas 
Departamento de Ci√™ncia da Computa√ß√£o 
 
 
 
 
 
Verifica√ß√£o Formal de Protocolos Criptogr√°ficos ‚Äì 
O Caso dos Protocolos em Cascata 
 
 
 
Rodrigo Borges Nogueira 
 
 
 
Disserta√ß√£o aprovada como requisito parcial para obten√ß√£o do 
grau de Mestre no Curso de P√≥s-gradua√ß√£o em Inform√°tica 
 
 
 
Orientador 
Maur√≠cio Ayala Rinc√≥n 
 
 
 
Bras√≠lia 
2008  
ii 
 
Universidade de Bras√≠lia ‚Äì UnB 
Instituto de Ci√™ncias Exatas 
Departamento de Ci√™ncia da Computa√ß√£o 
Mestrado em Inform√°tica 
Coordenador: Prof. Dr. Li Weigang 
Banca examinadora composta por: 
Prof. Dr. Maur√≠cio Ayala Rinc√≥n (Orientador) ‚Äì MAT/UnB 
Prof. Dr. Anderson Clayton Alves Nascimento ‚Äì ENE/UnB 
Prof. Dr. Fl√°vio Leonardo Cavalcanti de Moura ‚Äì CIC/UnB 
CIP ‚Äî Cataloga√ß√£o Internacional na Publica√ß√£o 
 
 
 
Endere√ßo: Universidade de Bras√≠lia 
Campus Universit√°rio Darcy Ribeiro ‚Äì Asa Norte 
CEP 70910-900 
Bras√≠lia‚ÄìDF ‚Äì Brasil 
Nogueira, Rodrigo Borges. 
Verifica√ß√£o Formal de Protocolos Criptogr√°ficos ‚Äì O Caso dos Protocolos em 
Cascata / Rodrigo Borges Nogueira. Bras√≠lia: UnB, 2008. 90 p. : il. ; 29,5 cm. 
Disserta√ß√£o de Mestrado ‚Äì Universidade de Bras√≠lia, Bras√≠lia, 2008. 
1. Verifica√ß√£o Formal, 2. Protocolos Criptogr√°ficos, 
3. Sistemas de provas autom√°ticas, 4. PVS 
CDU 004.4 
iii 
 
  
 
  
iv 
  
Resumo 
Garantir a seguran√ßa de protocolos criptogr√°ficos n√£o √© uma tarefa 
simples. O modelo Dolev-Yao, proposto no in√≠cio da d√©cada de 80, 
constitui uma importante metodologia matem√°tica de modelagem de 
protocolos criptogr√°ficos, possibilitando a an√°lise e verifica√ß√£o da 
seguran√ßa destes protocolos. Por√©m, a verifica√ß√£o anal√≠tica n√£o 
garante isen√ß√£o de erros nas implementa√ß√µes. Com efeito, existem 
v√°rios exemplos de protocolos que foram considerados 
matematicamente seguros, mas com falhas descobertas at√© mesmo 
ap√≥s mais de uma d√©cada de quando propostos. Dessa forma, as 
abordagens baseadas em m√©todos formais s√£o de grande utilidade 
para garantir, efetivamente, a seguran√ßa de implementa√ß√µes destes 
protocolos. Neste trabalho, utilizamos um sistema de especifica√ß√£o 
e prova, o PVS (Prototype Verification System), para especificar e 
verificar mecanicamente a seguran√ßa de uma classe de protocolos 
no modelo Dolev-Yao: os Protocolos em Cascata para dois 
usu√°rios. Fazendo isto, detectaram-se falhas definicionais na 
especifica√ß√£o matem√°tica desta classe de protocolos e formularam-
se no√ß√µes e lemas mais gerais que os inicialmente propostos. 
 
Palavras-chave: Verifica√ß√£o formal, protocolos criptogr√°ficos, PVS 
v 
 
  
Abstract 
Ensuring the security of cryptographic protocols is not a simple 
task. The Dolev-Yao model, proposed in the early 80s, is an 
important mathematical modeling method of cryptographic 
protocols, enabling the analysis and verification of the safety of 
these protocols. But the analytical verification does not 
guarantee that implementations are not error-prone. Indeed, 
we have, in the history of protocols, a lot of examples with 
flaws detected even after a decade of its introduction. Thus, 
formal method approaches are very useful to ensure the 
security of protocol implementations. In this work, we use the 
PVS (Prototype Verification System) to specify and 
mechanically verify the safety of a protocol class in the Dolev-
Yao model: the two-party cascade protocols. By verifying our 
specification, we have detected a few flaws in the original 
definitions and we have proposed more general concepts and 
lemmas. 
 
Keywords: Formal verification, cryptographic protocols, PVS 
vi 
SUM√ÅRIO 
Cap√≠tulo 1. Introdu√ß√£o ......................................................................................................... 1 
Cap√≠tulo 2. M√©todos Formais e Criptografia ....................................................................... 5 
2.1 Verifica√ß√£o por ferramentas de prop√≥sito geral ....................................................... 5 
2.1.1 Verifica√ß√£o de protocolos por m√°quinas de estados finitos ............................. 6 
2.1.2 Protocolos criptogr√°ficos e complexidade computacional ............................... 7 
2.2 Verifica√ß√£o por sistemas especialistas ..................................................................... 8 
2.2.1 Interrogator [20] ............................................................................................... 8 
2.2.2 CryptoVerif ....................................................................................................... 9 
2.3 Verifica√ß√£o por l√≥gicas de an√°lise de conhecimento e confian√ßa .......................... 10 
2.3.1 L√≥gica BAN .................................................................................................... 10 
2.4 Verifica√ß√£o pela √°lgebra de termos ........................................................................ 12 
2.5 Verifica√ß√£o por outros paradigmas ........................................................................ 12 
2.5.1 Ferramenta H√≠brida na verifica√ß√£o de ataques multi-protocolos .................... 13 
2.5.2 Seguran√ßa baseada em simula√ß√£o ................................................................... 14 
2.5.2.1 Universal Composability ......................................................................... 14 
2.5.2.2 Simulabilidade Caixa-Preta ..................................................................... 15 
Cap√≠tulo 3. Fundamentos do PVS ..................................................................................... 16 
3.1 A l√≥gica implementada no PVS [8] [62] [63] ........................................................ 16 
3.2 O assistente de provas PVS ................................................................................... 18 
3.2.1 Exemplo de especifica√ß√£o em PVS: Soma de PA. ......................................... 19 
3.2.2 Outros detalhes de especifica√ß√£o e verifica√ß√£o em PVS. ............................... 23 
Cap√≠tulo 4. O Modelo Dolev-Yao para Protocolos em Cascata ........................................ 27 
4.1 Conceitos e defini√ß√µes b√°sicos............................................................................... 27 
4.2 Formaliza√ß√£o anal√≠tica do modelo ......................................................................... 29 
4.2.1 Protocolo em cascata e linguagem do advers√°rio ........................................... 29 
4.2.2 Definindo a seguran√ßa de protocolos em cascata ........................................... 32 
4.2.3 Balanceamento da linguagem admiss√≠vel do advers√°rio ................................ 33 
4.2.4 Provando a seguran√ßa de protocolos em cascata ............................................ 37 
vii 
Cap√≠tulo 5. Formaliza√ß√£o do Modelo Dolev-Yao em PVS ................................................ 41 
5.1 Teoria MonoidCryptOps: mon√≥ides em  ‚àó ........................................................ 42 
5.1.1 Lema geral de normaliza√ß√£o ........................................................................... 44 
5.1.2 Verifica√ß√£o do Lema 1 ................................................................................... 48 
5.2 Teoria CascadeProtocols: protocolo em cascata ................................................. 51 
5.2.1 Passo de protocolo .......................................................................................... 51 
5.2.2 Protocolo em cascata ...................................................................................... 51 
5.3 Teoria SecurityDefinitions: Linguagem do Advers√°rio e Defini√ß√µes de Seguran√ßa
 52 
5.3.1 Especifica√ß√£o da Defini√ß√£o 3: Linguagem admiss√≠vel do advers√°rio ............ 52 
5.3.2 Especifica√ß√£o da Defini√ß√£o 4: PB .................................................................. 53 
5.3.3 Especifica√ß√£o da Defini√ß√£o 5: Protocolo balanceado ..................................... 53 
5.3.4 Especifica√ß√£o da Defini√ß√£o 6: Condi√ß√£o inicial de seguran√ßa ....................... 54 
5.3.5 Especifica√ß√£o da Defini√ß√£o 7: Protocolo seguro ............................................ 54 
5.4 Teoria SecurityNecessity: Prova da necessidade do Teorema 1 .......................... 55 
5.4.1 Verifica√ß√£o: Protocolo em cascata   seguro ‚Üí  Condi√ß√£o inicial de 
seguran√ßa. ..................................................................................................................... 55 
5.4.2 Verifica√ß√£o: Protocolo em cascata  seguro ‚Üí  balanceado. ................. 57 
5.5 Teoria SecuritySufficiency: Prova da Sufici√™ncia do Teorema 1 ........................ 65 
5.6 Teoria CascadeProtocolsSecurity: Prova final do Teorema 1 ............................ 68 
Cap√≠tulo 6. Conclus√µes ...................................................................................................... 69 
6.1 Trabalhos Futuros .................................................................................................. 71 
Refer√™ncias ........................................................................................................................... 73 
  
viii 
 
Lista de Figuras 
Figura 1: M√°quina de estados finitos n√£o-determin√≠stica modelando dois participantes A e B 
durante a execu√ß√£o de um protocolo. ..................................................................................... 6 
Figura 2: √Årvore de prova para a soma da PA. .................................................................... 23 
Figura 3: Teorias que comp√µem a formaliza√ß√£o do modelo Dolev-Yao. ............................. 41 
Figura 4: √Årvore de prova do lema normalize_general. ............................................ 48 
Figura 5: Funcionamento do protocolo de Needham-Schroeder. ......................................... 81 
Figura 6: Quebrando o protocolo de Needham-Schroeder. .................................................. 82 
Lista de Anexos 
Anexo 1 ‚Äì Estat√≠sticas da Implementa√ß√£o em PVS .............................................................. 76 
Anexo 2 ‚Äì Quebra do Protocolo de Needham-Schroeder..................................................... 81 
 
 
 1 
Cap√≠tulo 1.  
Introdu√ß√£o 
Protocolos criptogr√°ficos ou protocolos de seguran√ßa s√£o pequenas aplica√ß√µes 
distribu√≠das que garantem propriedades de seguran√ßa em um ambiente hostil [61]. 
Autenticidade e confidencialidade das mensagens trocadas entre os participantes de um 
protocolo s√£o exemplos de requisitos esperados em uma comunica√ß√£o. V√°rios servi√ßos e 
tecnologias s√£o viabilizados pela utiliza√ß√£o de protocolos criptogr√°ficos como, por 
exemplo, transa√ß√µes banc√°rias on-line, com√©rcio eletr√¥nico, sistemas eleitorais eletr√¥nicos e 
comunica√ß√µes militares. 
O principal problema do projeto de um protocolo criptogr√°fico est√° na forma como 
o conceito de seguran√ßa √© definido e atribu√≠do a este protocolo, principalmente porque um 
protocolo criptogr√°fico, geralmente, agrega diversas outras ferramentas da criptografia, 
como as fun√ß√µes de hash, algoritmos de encripta√ß√£o, etc, e cada uma dessas ferramentas 
pode definir a seguran√ßa de um modo espec√≠fico. Formalmente, a seguran√ßa de protocolos 
criptogr√°ficos possui diferentes n√≠veis de defini√ß√µes, que variam de acordo com o grau de 
abstra√ß√£o de determinadas diretivas de seguran√ßa. Assim, para se dizer que um protocolo 
criptogr√°fico √© seguro, √© necess√°rio dizer tamb√©m sob que hip√≥teses a seguran√ßa √© definida. 
Em protocolos criptogr√°ficos, a seguran√ßa, basicamente, diz respeito ao provimento de 
garantias [9], como: 
 Autentica√ß√£o: garante que um participante   esteja se comunicando com , 
quando  acredita estar se comunicando com . 
 Sigilo: garante que mensagens enviadas sejam intelig√≠veis somente aos receptores 
para quem as mensagens s√£o destinadas. 
 N√£o-rep√∫dio: Nenhum dos participantes de um protocolo pode negar a participa√ß√£o 
no protocolo ap√≥s o fim da sess√£o. 
 2 
 N√£o-interfer√™ncia: informa√ß√µes secretas n√£o devem vazar para intrusos durante a 
transmiss√£o. Para prover isso, o sistema deve considerar todo n√≠vel de intera√ß√£o com 
agentes quaisquer. 
 Atomicidade: todos os passos de uma transa√ß√£o devem ser conclu√≠dos 
completamente, ou nenhum passo √© conclu√≠do. 
 Imparcialidade/Justi√ßa (Fairness): n√£o √© admitido a um participante obter qualquer 
tipo de vantagem sobre outro(s) participante(s) durante a execu√ß√£o do protocolo. 
O desenvolvimento de protocolos criptogr√°ficos, no in√≠cio das pesquisas em 
seguran√ßa de dados, realizou-se de modo simples, iterativamente: proposta do protocolo, 
descoberta de algum tipo de ataque, reestrutura√ß√£o do protocolo at√© que nenhum outro 
ataque conhecido fosse descoberto [1]. Seguindo essa metodologia, o projeto de um 
protocolo criptogr√°fico fica suscet√≠vel a graves erros. Um exemplo cl√°ssico disso √© o 
protocolo de chaves p√∫blicas de Needham-Schroeder [4], proposto em 1978. Durante 
dezessete anos considerou-se este protocolo seguro, at√© que Gavin Lowe descobriu uma 
falha e apresentou uma vers√£o corrigida do protocolo, al√©m de provar que o novo protocolo 
√© correto [5]. Outro exemplo √© a descoberta de falhas em um protocolo do projeto do 
padr√£o CCITT X.509 [13]. E ainda, recentemente, descobriu-se uma falha no SET (Secure 
Electronic Transaction) [19], que √© uma su√≠te de protocolos proposta por um cons√≥rcio de 
companhias de cart√µes de cr√©dito e corpora√ß√µes de software para com√©rcio eletr√¥nico. 
Descobriu-se ser imposs√≠vel provar que o SET satisfaz a seguinte garantia esperada: o 
propriet√°rio de um cart√£o de cr√©dito envia os detalhes do seu cart√£o somente ao gateway 
de pagamento, mantendo esses detalhes desconhecidos ao vendedor. 
Durante aproximadamente 20 anos, as comunidades de m√©todos formais e 
criptografia trabalharam em sentidos opostos [7]. A primeira tinha como principal objetivo 
expressar a seguran√ßa focando em metodologias de provas autom√°ticas eficientes para 
expressar objetivos de seguran√ßa. Na segunda comunidade, a maior parte dos trabalhos se 
concentrou em definir a seguran√ßa de algoritmos e protocolos criptogr√°ficos contra os mais 
expressivos tipos de ataques, restritos a condi√ß√µes de tempo polinomial, provando que a 
seguran√ßa se obtinha baseada, tipicamente, em hip√≥teses da teoria dos n√∫meros. 
 3 
Com o desenvolvimento das t√©cnicas autom√°ticas de verifica√ß√£o formal e a 
demanda cada vez maior por protocolos criptogr√°ficos confi√°veis, a conex√£o entre m√©todos 
formais e criptografia tem recebido grande interesse atualmente, a fim de se modelar 
matematicamente requisitos de seguran√ßa de protocolos criptogr√°ficos e provar que estes 
requisitos s√£o atendidos nos modelos. Mais que isso, especificar protocolos criptogr√°ficos 
baseados em opera√ß√µes abstratas, de modo que se possam provar propriedades de seguran√ßa 
que sejam v√°lidas para implementa√ß√µes reais. 
O uso de m√©todos formais na verifica√ß√£o de protocolos criptogr√°ficos teve in√≠cio, 
principalmente, com o trabalho de Dolev e Yao em [6], que propuseram, basicamente, um 
modelo que consiste na defini√ß√£o de um advers√°rio com total controle sobre a rede. Este 
controle √© inferido da modelagem, em √°lgebra abstrata, das regras de um protocolo e 
intera√ß√£o deste com o advers√°rio. √â utilizada a criptografia perfeita, ou seja, √© imposs√≠vel 
desfazer, sem a chave privada, uma encripta√ß√£o ou aprender qualquer informa√ß√£o relativa 
√†s mensagens dos usu√°rios honestos do protocolo. 
Neste trabalho, mostramos como t√©cnicas de provas dispon√≠veis no assistente de 
provas PVS (Prototype Verification System) [8] [63] podem ser aplicadas na an√°lise de 
seguran√ßa de protocolos criptogr√°ficos. Utilizando a linguagem e a l√≥gica do PVS, 
provamos a seguran√ßa do modelo Dolev-Yao para protocolos em cascata [6]. Para a prova 
deste modelo, especificamos algumas teorias gerais sobre propriedades b√°sicas de 
protocolos criptogr√°ficos e, a partir destas teorias, desenvolvemos nossa modelagem, 
mostrando, assim, como se podem construir modelos de protocolos criptogr√°ficos 
utilizando sistemas como o PVS. Al√©m disso, identificamos falhas e omiss√µes no 
formalismo do modelo original proposto por Dolev e Yao e pudemos expressar de modo 
mais gen√©rico alguns lemas e defini√ß√µes. 
Dentre as motiva√ß√µes para uso do PVS em nossa modelagem, est√£o a robustez do 
sistema e sua utiliza√ß√£o em resultados importantes da literatura e aplica√ß√µes industriais. 
Al√©m disso, o PVS possui um sistema de tipos adequado √† modelagem de protocolos 
criptogr√°ficos, especialmente por permitir a defini√ß√£o de tipos n√£o interpretados e 
tipos/subtipos predicados, amplamente utilizados em nossas especifica√ß√µes. Isso possibilita 
especificar elementos da criptografia de forma flex√≠vel e reutiliz√°vel. O PVS utiliza o 
c√°lculo de seq√ºentes como l√≥gica de demonstra√ß√£o de teoremas e implementa um conjunto 
 4 
bastante diversificado de estrat√©gias de provas, o que permite o desenvolvimento de provas 
com n√≠veis de abstra√ß√£o adequados. A seguir, algumas aplica√ß√µes importantes da utiliza√ß√£o 
do PVS. 
‚Ä¢ Provas relacionadas a algoritmos de diagn√≥stico para arquiteturas de toler√¢ncia a 
falhas bizantinas [3]. 
‚Ä¢ Verifica√ß√£o de micro-c√≥digo para um conjunto de instru√ß√µes do microprocessador 
pipelined Collins AAMP5 avionics, que cont√©m 500.000 transistores. Especificaram-se 
formalmente, em PVS, a micro arquitetura do microprocessador e 108 das 209 
instru√ß√µes, sendo que 11 instru√ß√µes importantes foram formalmente verificadas com a 
descoberta de erros [3]. 
‚Ä¢ Verifica√ß√£o formal de protocolos criptogr√°ficos, onde podemos citar, por exemplo, 
os trabalhos em [54] e [55], em que se verificam protocolos de autentica√ß√£o recursiva; e 
os trabalhos de Backes em [1], [65] e [66], onde uma biblioteca criptogr√°fica foi criada 
para utiliza√ß√£o em provas autom√°ticas; ou ainda [56], onde se realizou a verifica√ß√£o do 
protocolo Enclaves. 
A fim de ilustrar a import√¢ncia do estudo e verifica√ß√£o formal da seguran√ßa de 
protocolos criptogr√°ficos, apresentamos no Anexo 2 o protocolo Needham-Schroeder de 
autentica√ß√£o [4], e como este protocolo pode ser subvertido. 
Este documento est√° organizado da seguinte forma: No cap√≠tulo Cap√≠tulo 2, 
apresentamos um survey mostrando diferentes metodologias aplicadas √† an√°lise de 
protocolos criptogr√°ficos. O cap√≠tulo Cap√≠tulo 3 mostra os fundamentos do assistente de 
provas PVS e a l√≥gica implementada por este sistema. O cap√≠tulo Cap√≠tulo 4 descreve, em 
detalhes, nossa modelagem anal√≠tica para o modelo Dolev-Yao de protocolos em cascata. 
No cap√≠tulo Cap√≠tulo 5, mostraremos defini√ß√µes e provas realizadas em PVS, 
correspondentes √† modelagem anal√≠tica do cap√≠tulo Cap√≠tulo 4. E, no cap√≠tulo Cap√≠tulo 6, 
conclu√≠mos e apresentamos alguns trabalhos futuros. 
  
 5 
Cap√≠tulo 2.  
M√©todos Formais e Criptografia 
Em [9], [13] e [21] encontramos quatro abordagens para an√°lise formal de 
protocolos criptogr√°ficos. 
1. Modelagem e verifica√ß√£o de protocolos criptogr√°ficos utilizando m√©todos e 
ferramentas n√£o especificamente desenvolvidos para seguran√ßa. 
2. Desenvolvimento de sistemas especialistas para avalia√ß√£o de possibilidades em 
diferentes cen√°rios. 
3. Modelagem e verifica√ß√£o de protocolos criptogr√°ficos utilizando l√≥gicas 
baseadas em conhecimento e confian√ßa. 
4. Desenvolvimento de modelos formais como propriedades da √°lgebra de termos. 
A seguir, apresentamos a id√©ia geral de cada um dos paradigmas acima, mostrando 
casos em que s√£o aplicados. 
2.1 Verifica√ß√£o por ferramentas de prop√≥sito geral 
Diferentes ferramentas j√° se utilizaram para verifica√ß√£o formal de protocolos 
criptogr√°ficos como, por exemplo: Redes de Petri [24], CSP (Communicating Sequential 
Processes) [22] [23], FDR (Failures-Divergence Refinement) [5], m√°quinas de estados 
finitos [25] [26] e an√°lise via complexidade computacional [29]. 
Em [22], utilizou-se CSP para analisar o protocolo de Woo-Lam, proposto em 1992 
[27]. CSP √© uma linguagem em que um sistema √© modelado em termos de processos e 
eventos, onde os processos podem mudar de estado na ocorr√™ncia de eventos, que s√£o 
at√¥micos.  
Usando FDR em [5], Lowe, ap√≥s a descoberta do ataque man-in-the-middle ao 
protocolo de autentica√ß√£o Needham-Schroeder, prop√¥s uma corre√ß√£o e provou a seguran√ßa 
deste protocolo modificado (com nome Needham-Schroeder-Lowe) no modelo Dolev-Yao. 
 6 
O FDR √© uma ferramenta de verifica√ß√£o de modelos para m√°quinas de estados, com 
fundamentos na teoria da concorr√™ncia baseada em CSP. 
Nas duas se√ß√µes a seguir, apresentamos exemplos mais detalhados de utiliza√ß√£o de 
ferramentas de prop√≥sito geral na verifica√ß√£o de protocolos criptogr√°ficos. 
2.1.1 Verifica√ß√£o de protocolos por m√°quinas de estados finitos 
A Figura 1 a seguir, extra√≠da de [9], modela dois participantes A e B durante a 
execu√ß√£o de um protocolo. Os arcos U-n e U+n, respectivamente, significam que um 
participante U envia e recebe uma mensagem n e, para cada mensagem enviada ou 
recebida, h√° uma mudan√ßa de estado. A m√°quina de estados finitos M, na Figura 1, √© 
constru√≠da pelo produto cartesiano das m√°quinas individuais MA e MB de dois participantes 
A e B, respectivamente. Durante a execu√ß√£o do protocolo, um estado Sij de M indica que A 
est√° em um estado Si de MA e B em um estado Sj de MB. Se o n√∫mero de estados em MA e 
MB √© m, ent√£o o produto cartesiano destas duas m√°quinas resulta na m√°quina M com m2+1 
estados, incluindo o estado final. 
 
Figura 1: M√°quina de estados finitos n√£o-determin√≠stica modelando dois participantes A e B durante a 
execu√ß√£o de um protocolo. 
 7 
Para estudo do protocolo modelado por M, utiliza-se a t√©cnica da an√°lise de 
alcan√ßabilidade [28], onde, para cada transi√ß√£o, o estado global do sistema em M √© 
analisado considerando-se os participantes do protocolo e os canais de comunica√ß√£o. Por 
exemplo, se, em um estado global de M, um participante U n√£o pode receber uma 
mensagem que era esperada, ent√£o h√° um problema no protocolo. 
Com esta t√©cnica podem-se identificar problemas relativos √† corre√ß√£o do protocolo 
quanto a sua especifica√ß√£o, mas n√£o se garante a seguran√ßa contra um advers√°rio ativo. 
2.1.2 Protocolos criptogr√°ficos e complexidade computacional 
A teoria da NP-completude √© parte de uma teoria abrangente chamada complexidade 
computacional [31]. A id√©ia b√°sica dessa teoria √© caracterizar uma classe de problemas para 
os quais existe um algoritmo n√£o-determin√≠stico. Em um problema n√£o-determin√≠stico as 
solu√ß√µes poss√≠veis est√£o localizadas em um espa√ßo de busca exponencial, mas podem ser 
verificadas em tempo polinomial. Todo problema NP-completo pode ser reduzido, 
polinomialmente, a outro problema NP-completo. Esta √© a base das provas de NP-
completude, ou seja, encontrar um problema NP-completo ou NP-dif√≠cil conhecido que 
pode ser reduzido ao problema avaliado, al√©m de se provar que este problema pertence √† 
classe de problemas NP. 
Em [29], mostra-se que a complexidade do problema da inseguran√ßa de um 
protocolo para um n√∫mero finito de sess√µes √© NP-completo, considerando-se o modelo 
Dolev-Yao de advers√°rios. Na prova, o problema 3-SAT foi reduzido ao problema em 
quest√£o, e a id√©ia da redu√ß√£o √© deixar o advers√°rio gerar a primeira mensagem do protocolo 
o que √© representado por uma solu√ß√£o para o problema 3-SAT. O teorema principal 
provado em [29] diz que ‚ÄúDescobrir um ataque a um protocolo com um n√∫mero fixo de 
sess√µes √© um problema NP-completo‚Äù. O problema da inseguran√ßa de um protocolo 
consiste em determinar se existe um cen√°rio de processos em execu√ß√£o, no qual h√° um 
advers√°rio tentando definir um ataque potencial. 
Trabalhos recentes e importantes de verifica√ß√£o de propriedades de protocolos 
criptogr√°ficos, via complexidade computacional, s√£o [32], [33] e [34]. 
 8 
2.2 Verifica√ß√£o por sistemas especialistas 
Com sistemas especialistas, a verifica√ß√£o de protocolos criptogr√°ficos se beneficia 
da gera√ß√£o arbitr√°ria de v√°rias a√ß√µes poss√≠veis e condu√ß√£o de ataques, e o sistema verifica a 
integridade operacional do protocolo para todo estado de ataque. Diferentemente das 
m√°quinas de estados finitos mostradas na se√ß√£o 2.1.1, os sistemas especialistas iniciam em 
um estado indesej√°vel e tentam descobrir se este estado √© alcan√ß√°vel a partir do estado 
inicial ou vice-versa. 
Este tipo de sistema √© desenvolvido especificamente para a an√°lise de protocolos 
criptogr√°ficos e alguns apresentam a limita√ß√£o de que a constru√ß√£o de um ataque vincula-se 
√† limita√ß√£o humana de conhecimento dos ataques. Geralmente, existe um mecanismo de 
busca exaustiva com necessidade de interfer√™ncia do usu√°rio, a fim de se enriquecer a 
quantidade de estados inseguros e caminhos que levam a uma falha. 
2.2.1 Interrogator [20] 
Sistema especialista baseado em m√°quinas de estados finitos, √∫til para an√°lise de 
protocolos sob ataques conhecidos, em que um advers√°rio pode destruir, interceptar e 
modificar todas as mensagens. O protocolo √© visto como uma cole√ß√£o de processos que se 
comunicam, sendo um processo para cada participante. Um processo possui um conjunto de 
estados e a transmiss√£o de uma mensagem pode provocar uma transi√ß√£o de um estado a 
outro. 
A entrada para o sistema √© uma especifica√ß√£o de protocolo e um dado alvo que pode 
ser uma mensagem, por exemplo. A sa√≠da √© um hist√≥rico de mensagens mostrando como o 
advers√°rio p√¥de interagir com o dado alvo. 
No Interrogator, um grande n√∫mero de caminhos poss√≠veis para execu√ß√£o dos 
processos √© gerado. Se um caminho, a partir de um estado inicial, termina em um estado 
inseguro, ent√£o se pode dizer que h√° uma falha no protocolo.  
 9 
2.2.2 CryptoVerif 
Blanchet, em [12], afirma que existem dois principais frameworks para o estudo de 
protocolos criptogr√°ficos: O modelo computacional, onde mensagens s√£o bitstrings e o 
advers√°rio √© uma m√°quina de Turing probabil√≠stica de tempo polinomial. Neste modelo, 
que mais se aproxima do modelo real de execu√ß√£o dos protocolos, as provas s√£o geralmente 
realizadas de forma manual e informal. O modelo Dolev-Yao, onde as primitivas 
criptogr√°ficas s√£o definidas como caixas pretas perfeitas atrav√©s de abstra√ß√µes da √°lgebra de 
termos. Neste modelo, pode-se mais facilmente construir provas autom√°ticas, mas as provas 
de seguran√ßa geralmente n√£o s√£o robustas como no modelo computacional.  
Blanchet desenvolveu um process calculus inspirado, principalmente, pelo pi-
calculus, e sobre este fundamento construiu um provador autom√°tico de protocolos no 
modelo computacional. As provas seguem uma metodologia iterativa de games [35], onde o 
game inicial representa o protocolo a ser provado. O objetivo √© mostrar que a probabilidade 
de se quebrar um requisito de seguran√ßa √© insignificante em um game. A partir de um 
game, outro subseq√ºente √© obtido atrav√©s de transforma√ß√µes tais que a diferen√ßa de 
probabilidade entre games consecutivos √© desprez√≠vel. No game final a probabilidade de se 
quebrar o requisito de seguran√ßa √©, pela forma do game, claramente desprez√≠vel. 
O process calculus criado possui uma sem√¢ntica probabil√≠stica e todos os processos 
rodam em tempo polinomial. A principal ferramenta para especificar propriedades de 
seguran√ßa √© a equival√™ncia observacional: um processo Q √© observacionalmente equivalente 
a Q‚Äô, Q ‚âà Q‚Äô, quando um advers√°rio tem probabilidade desprez√≠vel de distinguir Q de Q‚Äô. 
Para se conseguir transformar o protocolo inicial em um game cuja propriedade de 
seguran√ßa desejada √© √≥bvia, o mais importante tipo de transforma√ß√£o vem da defini√ß√£o de 
seguran√ßa das primitivas criptogr√°ficas. Esta transforma√ß√£o pode ser especificada de um 
modo gen√©rico: a defini√ß√£o de seguran√ßa de uma primitiva criptogr√°fica √© realizada pela 
equival√™ncia observacional L ‚âà R, onde L e R s√£o processos que codificam fun√ß√µes, ou seja, 
s√£o processos que recebem argumentos de fun√ß√µes e devolvem seu resultado. Ent√£o, o 
provador pode, automaticamente, transformar um processo Q, que chama as fun√ß√µes de L, 
em um processo Q‚Äô, que chama as fun√ß√µes de R. Esta t√©cnica tem sido usada para 
especificar encripta√ß√µes de chaves p√∫blicas e/ou compartilhadas, assinaturas, MAC‚Äôs 
(Message Authentication Codes) e fun√ß√µes de hash, passando para o provador as 
 10 
equival√™ncias L ‚âà R apropriadas. Outras transforma√ß√µes de games s√£o sint√°ticas, utilizadas 
para permitir a aplica√ß√£o de defini√ß√µes das primitivas criptogr√°ficas, ou para simplificar o 
game obtido ap√≥s se aplicar estas defini√ß√µes. 
Al√©m dos dois sistemas especialistas citados, outros foram propostos, como o NRL 
Protocol Analyzer por Meadows [36] e o Longley and Rigby [37]. 
2.3 Verifica√ß√£o por l√≥gicas de an√°lise de conhecimento e 
confian√ßa 
Nesta abordagem da verifica√ß√£o formal de protocolos criptogr√°ficos est√£o as l√≥gicas 
modais, que consistem de uma linguagem que descreve v√°rias declara√ß√µes sobre confian√ßa, 
conhecimento de mensagens em um sistema distribu√≠do e algumas regras de infer√™ncia 
usadas para deriva√ß√£o de declara√ß√µes a partir de outras declara√ß√µes. O objetivo √© derivar 
declara√ß√µes que representem condi√ß√µes corretas de um protocolo. 
2.3.1 L√≥gica BAN 
A l√≥gica BAN √© a l√≥gica mais amplamente utilizada na an√°lise de protocolos de 
autentica√ß√£o. Foram publicados diversos artigos mostrando a utiliza√ß√£o da l√≥gica BAN para 
provas de seguran√ßa de protocolos. Exemplos importantes s√£o [39] e [40]. 
Alguns termos b√°sicos da l√≥gica BAN: 
‚Ä¢ KXP }{< : Conhecendo-se a chave K , indica que "P reconhece X", ou seja, P 
recebe uma mensagem X da qual P consegue obter significado. 
‚Ä¢ 
1‚àí‚àã KP : Indica possess√£o de uma chave privada 1‚àíK  por P. 
‚Ä¢ ),,(sec QPXret : Significa que existe um segredo X (chave ou nonce) 
compartilhado entre os participantes P e Q. 
‚Ä¢ $|‚â°P : Indica que P √© levado a acreditar que $ √© v√°lido. 
‚Ä¢ $|~P : Descreve que P, alguma vez, declarou $, ou agora ou no passado. 
‚Ä¢ )(Xfresh : √â um predicado que afirma ser X gerado no presente. 
‚Ä¢ $| ‚àíP : Significa que P proferiu $ no passo corrente do protocolo. 
 11 
Exemplos de regras de infer√™ncia BAN [11]: 
XQP
XfreshPXQPSay
YXQP
QPXretPYXPSS
XP
KPXPDec K
‚àí‚â°
‚â°‚â°
‚â°
‚â°‚àã ‚àí
||
)(|,|~|)(
,|~|
),,(sec|,,)(,}{)(
1
<
<
<
 
‚Ä¢ Regra de decripta√ß√£o (Dec): Se P possui a chave 1‚àíK  e recebeu uma 
mensagem X encriptada por uma chave K, ent√£o P recebeu X. 
‚Ä¢ Regra de segredo compartilhado (SS): Se P reconhece a mensagem composta 
por X e Y, e P acredita que X √© um segredo compartilhado entre P e Q, ent√£o P 
acredita que Q enviou, ou agora ou no passado, a mensagem X,Y. 
‚Ä¢ Regra de proclama√ß√£o (Say) Se P acredita que Q, alguma vez, declarou X e P 
acredita que X √© uma mensagem gerada no presente, ent√£o P acredita que Q 
proferiu X no passo corrente do protocolo. 
Como se pode perceber, com a l√≥gica BAN √© poss√≠vel lidar com protocolos somente 
em um n√≠vel abstrato. 
Segundo os criadores da l√≥gica BAN [38], para an√°lise de protocolos devem-se 
seguir os seguintes passos: 1) O protocolo idealizado √© derivado do protocolo original; 2) 
Especificam-se as suposi√ß√µes sobre o estado inicial; 3) √Äs declara√ß√µes do protocolo, 
anexam-se f√≥rmulas l√≥gicas como assertivas sobre o estado do sistema ap√≥s cada 
declara√ß√£o; 4) Aplicam-se postulados l√≥gicos √†s suposi√ß√µes e assertivas para verificar se os 
crit√©rios de confian√ßa pelos participantes do protocolo s√£o v√°lidos. 
A l√≥gica BAN foi projetada de modo a permitir que fosse estendida, ou seja, novas 
constru√ß√µes e postulados podem ser adicionados, adequando-se a uma aplica√ß√£o particular. 
Algumas extens√µes foram criadas, como por exemplo, a l√≥gica GNY em [41]. 
Diversas outras l√≥gicas foram criadas para expressar propriedades de protocolos 
criptogr√°ficos. Sucintamente, apresentaremos dois exemplos: 
‚Ä¢ Moser, em [42], prop√¥s uma l√≥gica n√£o-monot√¥nica da confian√ßa, onde ele 
afirma que, no mundo real, a confian√ßa no sigilo de uma chave de sess√£o pode 
mudar caso esta chave seja comprometida, por exemplo. Nesta l√≥gica, 
conhecimento e confian√ßa podem ser n√£o-monot√¥nicas. 
 12 
‚Ä¢ Mais recentemente, em [43], Vigano e equipe desenvolveram uma l√≥gica para 
formaliza√ß√£o de ataques, com o desenvolvimento de novas sem√¢nticas que 
combinam caracter√≠sticas de l√≥gicas j√° existentes e m√©todos indutivos. O m√©todo 
contempla o problema da modelagem de protocolos com execu√ß√µes em intervalos 
disjuntos, o que n√£o era realizado anteriormente pelas l√≥gicas de seguran√ßa 
baseadas em l√≥gica modal. Vigano mostrou com esta l√≥gica o ataque man-in-the-
middle ao protocolo Needham-Schroeder. 
2.4 Verifica√ß√£o pela √°lgebra de termos 
Parte dos trabalhos atuais de verifica√ß√£o formal de protocolos criptogr√°ficos est√° 
baseada na utiliza√ß√£o de sistemas alg√©bricos. Nesta abordagem, as primitivas criptogr√°ficas 
s√£o geralmente idealizadas como tipos com certas propriedades e o protocolo √© considerado 
como um sistema que utiliza as propriedades destes tipos para prover as garantias 
requeridas. Muitas provas de seguran√ßa s√£o, portanto, realizadas provando-se 
matematicamente que √© imposs√≠vel que um advers√°rio subverta os objetivos do protocolo.  
Paulson, em [45], utilizou o sistema de provas Isabelle para construir provas 
indutivas de corretude de protocolos criptogr√°ficos. E Millen, em [46], utilizou o sistema 
PVS para obter provas baseadas nas id√©ias de Paulson. Thayer e equipe, em [47], criaram 
um modelo te√≥rico de causalidade em um protocolo, chamado strand spaces. E, Dolev e 
Yao, em [6], propuseram um modelo alg√©brico de seguran√ßa de protocolos criptogr√°ficos. 
Em particular, introduziram uma classe de protocolos em cascata, de chaves p√∫blicas, nos 
quais um participante pode aplicar opera√ß√µes de encripta√ß√£o ou decripta√ß√£o em v√°rias 
camadas para formar mensagens. Abordaremos o modelo Dolev-Yao em detalhes nos 
cap√≠tulos Cap√≠tulo 4 e Cap√≠tulo 5. 
2.5 Verifica√ß√£o por outros paradigmas 
Al√©m dos quatro paradigmas cl√°ssicos apresentados anteriormente, existem outras 
metodologias mais recentes de verifica√ß√£o de protocolos criptogr√°ficos, descritas a seguir. 
 13 
2.5.1 Ferramenta H√≠brida na verifica√ß√£o de ataques multi-protocolos 
Protocolos criptogr√°ficos, em sua maioria, s√£o projetados para uma troca segura de 
chaves de sess√£o ap√≥s um processo de autentica√ß√£o [14]. Um dos problemas mais comuns 
em seguran√ßa, entretanto, √© que as vulnerabilidades aparecem na fronteira entre duas 
tecnologias de prote√ß√£o [16]. Neste sentido, a verifica√ß√£o formal de ataques multi-
protocolos √© importante, pois, tipicamente, a modelagem formal e verifica√ß√£o de seguran√ßa 
s√£o realizadas considerando-se que um protocolo √© executado isoladamente, sem 
compartilhamento da rede com outros protocolos [17]. 
De fato, considerar que apenas um protocolo executa em uma rede n√£o-confi√°vel 
n√£o √© real√≠stico. E, dois protocolos isolados considerados corretos, podem apresentar falhas 
quando utilizados sob a mesma rede. O principal resultado sobre este tipo de ataque aparece 
em [18]. Em [17], descobriu-se que, de 30 protocolos da literatura, 23 s√£o vulner√°veis a 
ataques multi-protocolos. O total de ataques descobertos foi 163. Os testes foram realizados 
considerando protocolos criptogr√°ficos executando, em paralelo, dois a dois e tr√™s a tr√™s, 
utilizando a ferramenta Scyther [44], que, dada uma descri√ß√£o de um conjunto de 
protocolos, tenta construir um contra-exemplo (ataque). Esta ferramenta utiliza um 
algoritmo h√≠brido de provas de teoremas e verifica√ß√£o de modelos. 
Com o Scyther, 17 ataques dois a dois foram observados modelando-se os 
protocolos de modo que os participantes podem, de alguma forma, verificar os tipos dos 
dados que recebem e, ent√£o, aceitar somente termos de tipos corretos. Este √© o modelo mais 
restritivo dos tr√™s modelos avaliados em [17]. A verifica√ß√£o de tipos √© poss√≠vel at√© mesmo 
para um conjunto Nonce de todos os valores rand√¥micos. Os ataques descobertos s√£o de 
viola√ß√£o da autentica√ß√£o entre participantes e falhas em requisitos de sigilo. A principal 
causa dos ataques √© a forma como os mecanismos de desafios para autentica√ß√£o s√£o 
constru√≠dos. Um participante X prova sua identidade a outro participante pela aplica√ß√£o de 
uma chave que somente X conhece. Este procedimento de se aplicar uma chave pode ser 
para encripta√ß√£o ou decripta√ß√£o, e estes dois m√©todos, por serem complementares, tornam 
poss√≠vel que a encripta√ß√£o em um protocolo seja seguida por uma decripta√ß√£o no outro 
protocolo em paralelo. Isso gera a quebra do segredo de valores rand√¥micos e, 
conseq√ºentemente, a quebra do processo de autentica√ß√£o. 
 14 
2.5.2 Seguran√ßa baseada em simula√ß√£o 
Atualmente, v√°rios trabalhos t√™m utilizado id√©ias como a indistinguibilidade e a 
funcionalidade ideal para provar propriedades de seguran√ßa de protocolos criptogr√°ficos. 
Os principais projetos s√£o de Canetti com sua abordagem da Universal Composability [48] 
[49] e de Backes, Pfitzmann, e Waidner, que produziram trabalhos relacionados com o de 
Canetti, mas usando tamb√©m a Simulabilidade Caixa-Preta [1] [7] [50]. 
2.5.2.1 Universal Composability 
Uma das principais raz√µes para a exist√™ncia de falhas em protocolos criptogr√°ficos √© 
a ocorr√™ncia de intera√ß√µes inexperadas entre inst√¢ncias de diferentes protocolos que 
executam paralelamente em sistemas compostos [52]. A composi√ß√£o visa garantir a 
obten√ß√£o de um protocolo seguro pela composi√ß√£o de protocolos seguros. 
Em [48], Canetti introduz a Universal Composability (UC), onde o modelo de 
execu√ß√£o de um protocolo consiste de um conjunto de m√°quinas de Turing Interativas 
(ITMs - Interactive Turing Machines), representando os participantes do protocolo e mais 
uma ITM para representar o advers√°rio. A UC envolve a compara√ß√£o entre um protocolo 
real e uma funcionalidade ideal, a compara√ß√£o entre um advers√°rio real e um ideal e um 
ambiente. O protocolo real realiza a funcionalidade ideal se, para todo ataque de um 
advers√°rio real ao protocolo real, existe um ataque de um advers√°rio ideal √† funcionalidade 
ideal, tal que o comportamento observ√°vel do protocolo real sob ataque √© o mesmo 
comportamento da funcionalidade ideal sob ataque. Cada conjunto de observa√ß√µes do 
sistema √© obtido sobre mesmo ambiente. Em outras palavras, o sistema consistindo do 
ambiente, o advers√°rio real e o protocolo real devem ser indistingu√≠veis do sistema 
consistindo do ambiente, o advers√°rio ideal, e a funcionalidade ideal. 
Em [52], Canetti descreve o UC security framework como uma estrutura para 
representa√ß√£o e an√°lise de protocolos criptogr√°ficos. Neste paradigma, formulou-se uma 
metodologia geral e uniforme para expressar requisitos de seguran√ßa de praticamente 
qualquer ferramenta criptogr√°fica. Al√©m disso, define-se um m√©todo geral para composi√ß√£o 
de protocolos, mostrando que as defini√ß√µes de seguran√ßa geradas neste framework 
preservam a seguran√ßa sob as opera√ß√µes de composi√ß√£o. 
 15 
2.5.2.2 Simulabilidade Caixa-Preta 
O objetivo principal desta abordagem, segundo Pfitzmann e Waidner em [51], √© 
ligar dois diferentes paradigmas de verifica√ß√£o de protocolos criptogr√°ficos: o de provas 
matematicamente rigorosas e o de provas mecanizadas por algum sistema de provas 
formais, de modo que se possam obter provas que permitam abstra√ß√µes e a utiliza√ß√£o de 
m√©todos formais, mantendo as sem√¢nticas criptogr√°ficas robustas. 
Em [51], Pfitzmann e Waidner utilizam uma variante da UC e a no√ß√£o de 
Simulabilidade Caixa-Preta baseada em PIOA (Probabilistic Polynomial-Time IO 
Automata). O modelo segue a id√©ia da Simulabilidade, onde a seguran√ßa de um sistema √© 
definida relativamente a outro sistema. Com base na Simulabilidade e outras defini√ß√µes 
auxiliares, chega-se √† defini√ß√£o de Simulabilidade Caixa-Preta e Simulabilidade Universal, 
que s√£o a base do modelo de seguran√ßa proposto em [51] para sistemas de seguran√ßa 
reativos em redes ass√≠ncronas. 
A Simulabilidade (com omiss√£o de detalhes) √© definida para dois sistemas Sis1 e Sis2 
quando: 
2
,
sec1 SisSis
perff‚â•
 
Isso significa que Sis1 √© perfeitamente pelo menos t√£o seguro quanto Sis2 se existe um 
mapeamento f v√°lido de Sis1 para Sis2 e, para toda configura√ß√£o de Sis1, existe uma 
configura√ß√£o de Sis2 tal que um usu√°rio H tenha uma vis√£o indistingu√≠vel do sistema ao 
interagir com a configura√ß√£o de Sis1 ou de Sis2. 
O sistema Sis1 √© freq√ºentemente um sistema real que utiliza primitivas 
criptogr√°ficas concretas, enquanto Sis2 √© o sistema ideal, isto √©, uma especifica√ß√£o que n√£o 
depende de qualquer detalhe de implementa√ß√£o criptogr√°fica espec√≠fica e √© n√£o real√≠stica. 
  
 16 
Cap√≠tulo 3.  
Fundamentos do PVS 
O PVS [3] √© um sistema que permite a especifica√ß√£o e verifica√ß√£o formal de 
modelos, baseada em um sistema de tipos robusto com uma l√≥gica de ordem superior [2]. 
Basicamente, pode ser visto como composto de tr√™s partes: uma linguagem de 
especifica√ß√£o, um provador de teoremas interativo e uma livraria de teorias j√° provadas, o 
prelude, contendo v√°rias defini√ß√µes e lemas utilit√°rios. 
3.1 A l√≥gica implementada no PVS [8] [62] [63] 
O PVS utiliza o c√°lculo de seq√ºentes na manipula√ß√£o e prova de lemas e teoremas. 
Um seq√ºente √© uma express√£o da forma Œì ‚ä¢ Œî, onde Œì e Œî s√£o seq√º√™ncias de f√≥rmulas, 
chamadas de antecedente e conseq√ºente, respectivamente. O s√≠mbolo ‚ä¢  denota que, 
assumindo Œì, Œî √© dedut√≠vel ou prov√°vel. 
De modo usual, utilizam-se as letras gregas Œì e Œî para representar seq√º√™ncias de 
f√≥rmulas e letras latinas ,  e  para representar f√≥rmulas individuais. Em um seq√ºente Œì ‚ä¢ Œî , as f√≥rmulas   de Œì  e as f√≥rmulas   de Œî  s√£o representadas como , , ‚Ä¶ ,  ‚ä¢ , , ‚Ä¶ ,  , para algum   e  , com 0 <  ‚â§   e 0 <  ‚â§  . 
Entretanto, em cada lado de ‚ä¢, as f√≥rmulas s√£o interpretadas de modo diferente, isto √©, Œì 
√© uma conjun√ß√£o de f√≥rmulas   e Œî  √© uma disjun√ß√£o de f√≥rmulas  . Assim, , , ‚Ä¶ ,  ‚ä¢ , , ‚Ä¶ ,  √© interpretado como  ‚àß  ‚àß ‚Ä¶ ‚àß  ‚ä¢  ‚à®  ‚à® ‚Ä¶ ‚à® . 
No c√°lculo de seq√ºentes, premissas e conclus√µes s√£o constru√≠das simultaneamente 
atrav√©s de um conjunto de regras de infer√™ncia (possuem a forma 
 !"!#$√£"  '()* +, -*.-,) b√°sicas, utilizado para derivar ou deduzir seq√ºentes a partir de 
outros seq√ºentes. Intuitivamente, uma regra de infer√™ncia da forma /‚ä¢0/1‚ä¢01 significa: Se a 
premissa Œì ‚ä¢ Œî √© verdadeira, ent√£o a conclus√£o Œì ‚ä¢ Œî √© verdadeira. 
 17 
No provador interativo do PVS, comandos de prova correspondem √† aplica√ß√£o de 
regras de infer√™ncia do c√°lculo de seq√ºentes. Ao iniciar uma prova, temos o objetivo a ser 
provado, representado como ‚ä¢ Œî. Assim, uma prova √© iniciada aplicando-se a Œî uma 
regra de infer√™ncia de baixo para cima. Em qualquer parte de uma prova, a aplica√ß√£o de 
uma regra de infer√™ncia (comando de prova do PVS) √© representada genericamente por 
/1‚ä¢01‚Ä¶/2‚ä¢02/‚ä¢0 R, ou seja, a aplica√ß√£o da regra R a uma folha da √°rvore de prova da forma Œì ‚ä¢ Œî, pode produzir uma √°rvore com  novas folhas. Ou, se uma folha corresponde a um 
axioma, o ramo √© considerado provado. 
As regras de infer√™ncia podem ser organizadas em grupos, conforme a seguir. 
Mostraremos apenas alguns grupos e regras. 
‚Ä¢ Regras estruturais: Um seq√ºente tem sua estrutura rearranjada ou enfraquecida 
(weakened) pela adi√ß√£o de novas f√≥rmulas antecedentes ou consequentes, o que √© 
expresso pela regra W, abaixo. 
/1‚ä¢01/5‚ä¢05 W, se Œì ‚äÜ Œì e Œî ‚äÜ Œî. 
Podemos ver que as regras de contra√ß√£o 7,7,/‚ä¢07,/‚ä¢0 C ‚ä¢ e /‚ä¢0,7,7/‚ä¢0,7 ‚ä¢ C s√£o absorvidas 
pela regra W. 
‚Ä¢ Regra do corte: Amplamente utilizada em nossas provas, como ser√° mostrado no 
cap√≠tulo Cap√≠tulo 5, esta regra corresponde √† introdu√ß√£o de uma f√≥rmula no seq√ºente 
atrav√©s de comandos do tipo case do PVS. Assim, a regra do corte, a partir de um 
seq√ºente Œì ‚ä¢ Œî, produz dois ramos na √°rvore de prova ao introduzir uma f√≥rmula . 
Em um ramo assume-se  e no outro ramo a nega√ß√£o de . Œì,  ‚ä¢ Œî       Œì ‚ä¢ , ŒîŒì ‚ä¢ Œî Corte 
‚Ä¢ Axiomas proposicionais: Quando um axioma proposicional pode ser aplicado a um 
seq√ºente-folha da √°rvore de prova, ent√£o o ramo correspondente √© considerado 
provado. A aplica√ß√£o de regras deste tipo, no PVS, √© feita automaticamente pelo 
sistema em casos triviais ou atrav√©s do comando assert. A regra Ax garante que, 
dada a f√≥rmula ,  √© verdadeira. E as regras FALSE ‚ä¢ e ‚ä¢ TRUE mostram que 
um seq√ºente com uma f√≥rmula falsa no antecedente ou uma f√≥rmula verdadeira no 
conseq√ºente √© um axioma. 
 18 
[-1] A1 
      
‚ãÆ
 
[-n] An |---------- 
[1] B1 
      
‚ãÆ
 
[m] Bm 
 Œì,  ‚ä¢ , Œî  Ax           Œì, FGHI ‚ä¢ Œî  FALSE ‚ä¢            Œì ‚ä¢ JKLI, Œî  ‚ä¢TRUE  
‚Ä¢ Regras condicionais: Utilizadas para eliminar, em uma prova, a estrutura IF-THEN-ELSE. Representa-se como IF(, , ) a declara√ß√£o IF  THEN  ELSE . 
Esta regra gera dois novos ramos na √°rvore de prova e √© aplicada com o comando 
prop do PVS. Œì, ,  ‚ä¢ Œî     Œì,  ‚ä¢ , ŒîŒì,IF(, , ) ‚ä¢ Œî  IF ‚ä¢            Œì,  ‚ä¢ , Œî     Œì ‚ä¢ , , ŒîŒì ‚ä¢ IF(, , ), Œî  ‚ä¢ IF 
3.2 O assistente de provas PVS 
Em PVS, um seq√ºente  Œì ‚ä¢ Œî, com Ai ‚àà Œì e Bk ‚àà Œî (0 < i ‚â§ n e 0 < k ‚â§ m), √© 
mostrado na forma: 
 
    
 
Na √°rvore de prova mantida pelo provador do PVS, cada n√≥ filho √© um seq√ºente 
gerado a partir da aplica√ß√£o de algum comando PVS. Apenas um seq√ºente-folha √© ativado 
por vez, ou seja, a aplica√ß√£o de um comando do provador √© realizada a somente um sub-
objetivo. O t√©rmino da prova de um seq√ºente passa o controle para a pr√≥xima folha n√£o 
provada da √°rvore. A prova termina quando todos os seq√ºentes da √°rvore s√£o provados. 
A linguagem do PVS cont√©m tipos primitivos, como inteiros e booleanos, bem 
como tuplas, registros e construtores para fun√ß√µes. Por exemplo, [bool, int -> nat] 
define um tipo de fun√ß√£o que recebe como argumentos um par booleano/inteiro e retorna 
um natural. Al√©m disso, tipos n√£o interpretados tamb√©m podem ser definidos. Por exemplo, 
para representar um usu√°rio de um protocolo criptogr√°fico, podemos definir um tipo n√£o-
vazio U, da seguinte forma: U : TYPE+. Portanto, dois usu√°rios x e y podem ser declarados 
como x, y : U. Outra possibilidade importante √© a defini√ß√£o de tipos enumerados em PVS, 
exemplificada pela defini√ß√£o dos tipos de operadores criptogr√°ficos (encripta√ß√£o e 
decripta√ß√£o), como a seguir: 
cryptType : TYPE = {decrypt, encrypt} 
 19 
Em PVS, uma especifica√ß√£o consiste de uma cole√ß√£o de teorias que podem ser 
adequadamente utilizadas para modulariza√ß√£o de especifica√ß√µes, onde teorias complexas 
podem ser provadas a partir de teorias mais simples. Cada teoria pode ser parametrizada e √© 
composta essencialmente de um conjunto de declara√ß√µes, que podem ser a introdu√ß√£o de 
nomes de tipos, constantes, vari√°veis, axiomas, f√≥rmulas e IMPORTINGs, que permitem 
importar outras teorias. 
A parametriza√ß√£o de teorias permite constru√ß√µes gen√©ricas, como mostrado no 
c√≥digo abaixo. A teoria finite_sequences_extras importa a teoria finite_sequences para 
manipula√ß√£o de seq√º√™ncias finitas. 
 
T √© tratado como um tipo n√£o interpretado. Conseq√ºentemente, quando a teoria 
finite_sequences_extras √© invocada por outra teoria, T precisa ser especificado. Por 
exemplo, finite_sequences_extras[int] mostra a utiliza√ß√£o da teoria 
finite_sequences_extras para o tipo int. 
Toda especifica√ß√£o em PVS deve passar por um passo de checagem de tipos, que 
resolve refer√™ncias e procura por erros sem√¢nticos, como nomes n√£o declarados e tipos 
amb√≠guos, garantindo a consist√™ncia de tipos da especifica√ß√£o. A checagem de tipos √© um 
procedimento indecid√≠vel, j√° que o usu√°rio pode definir express√µes booleanas arbitr√°rias em 
uma especifica√ß√£o. Assim, a checagem de tipos pode produzir TCCs (Type Correctness 
Conditions), que s√£o declara√ß√µes que devem ser validadas para que uma teoria seja 
considerada completa. Atrav√©s de estrat√©gias pr√©-definidas, o PVS pode provar 
automaticamente diversos tipos de TCCs, mas em alguns casos, geralmente em defini√ß√µes 
recursivas ou subtipos, √© necess√°rio que o usu√°rio dirija a prova no PVS. 
3.2.1 Exemplo de especifica√ß√£o em PVS: Soma de PA. 
Para ilustrar a linguagem e os procedimentos de especifica√ß√£o e verifica√ß√£o formal 
no PVS, utilizaremos uma prova indutiva para a soma de termos de uma Progress√£o 
Aritm√©tica (PA). 
finite_sequences_extras[T: TYPE] : THEORY 
BEGIN 
  IMPORTING finite_sequences[T] 
 20 
Defina-se uma PA, tal que os n√∫meros naturais 0,0,01 >‚â•‚â• nra  representem, 
respectivamente, o primeiro termo, a raz√£o e o n√∫mero de termos desta PA. A soma dos n  
termos da PA √© dada por: 
2
)))1(((
2
)(
...
111
21
‚àí++
=
+
=+++=
nraanaan
aaaS nnn , tal que 
)1(
2
11
123
12
‚àí+=+=
+=+=
+=
‚àí
nraraa
raraa
raa
nn
M
 
Equa√ß√£o 1: A soma dos n  termos de uma PA. 
A express√£o anterior pode ser especificada como uma teoria em PVS, conforme abaixo. 
 
A teoria progressaoaritmetica define a soma de termos da PA 
nn aaaS +++= ...21  na forma da fun√ß√£o recursiva somaPA, que retorna um n√∫mero natural. 
Isto √© definido na fun√ß√£o por RECURSIVE nat. Os par√¢metros de somaPA s√£o os n√∫meros 
naturais 0,0,01 >‚â•‚â• nra  da Equa√ß√£o 1, conforme assinatura da fun√ß√£o dada por  
somaPA(a1 : nat, r : nat, n : posnat). O PVS verifica automaticamente que somaPA √© 
terminante, pois a medida da recursividade (MEASURE n) √© estritamente decrescente para 
cada chamada recursiva. 
Provaremos a Equa√ß√£o 1 com o lema exprSomaPA, nas linhas 11 e 12 do c√≥digo da 
teoria progressaoaritmetica. A palavra-chave LEMMA define o lema a ser provado e FORALL √© 
o quantificador universal. O lema expressa a seguinte propriedade: 
2
)))1((())1((...)(:)|,|,|( 11111*11 ‚àí++=‚àí+++++‚àà‚àà‚àà‚àÄ nraannraraaNnnNrrNaa  
1. progressaoaritmetica : THEORY 
2. 
3. BEGIN 
4.  
5.   somaPA(a1 : nat, r : nat, n : posnat) : RECURSIVE nat = 
6.     IF(n = 1) THEN a1 
7.     ELSE a1 + somaPA(a1+r,r,n-1) 
8.     ENDIF 
9.   MEASURE n 
10.   
11.  exprSomaPA : LEMMA FORALL(a1 : nat, r : nat, n : posnat) : 
12.    somaPA(a1,r,n) = n*(a1 + (a1 + r*(n-1))) / 2 
13. 
14.END progressaoaritmetica 
 21 
Mostraremos os passos principais da prova em PVS, indicando o comando utilizado com 
descri√ß√£o de seu efeito. A prova se inicia atrav√©s do comando prove. O objetivo inicial √© 
mostrado a seguir. Os seq√ºentes ser√£o rotulados como (S1), (S2), ..., para posterior 
identifica√ß√£o dos seq√ºentes na √°rvore de prova. 
  |------- 
{1}   FORALL (a1: nat, r: nat, n: posnat): 
        somaPA(a1, r, n) = n * (a1 + (a1 + r * (n - 1))) / 2 
‚Ä¢ (induct n): Define a indu√ß√£o em n, produzindo dois ramos principais na prova: o 
ramo para a base de indu√ß√£o e o ramo para o passo de indu√ß√£o. Na base, temos: 
{-1}  n = 0 
  |------- 
[1]   n > 0 
[2]   FORALL (a1: nat, r: nat): 
        somaPA(a1, r, 1 + n) = 
         (2 * a1 + r * n + (2 * (a1 * n) + r * n * n)) / 2 
‚Ä¢ (grind): O objetivo √© provar que, para 0=n , ou vale 0>n  (claramente, este 
termo √© falso), ou vale o termo identificado por [2]. O comando (grind) √© uma 
estrat√©gia que tenta, repetidamente, aplicar skolemiza√ß√£o, expans√£o de termos, 
instancia√ß√£o, e outros. Com o valor de 0=n , a expans√£o e valida√ß√£o pelo PVS do 
termo somaPA em [2], retornar√° a1, que √© igual ao lado direito da express√£o. Assim, 
completa-se a base da indu√ß√£o, e o passo de indu√ß√£o √© apresentado: 
  |------- 
{1}   FORALL n: 
        (n > 0 => 
          (FORALL (a1: nat, r: nat): 
             somaPA(a1, r, n) = n * (a1 + (a1 + r * (n - 1))) / 2)) 
         => 
         n + 1 > 0 => 
          (FORALL (a1: nat, r: nat): 
             somaPA(a1, r, n + 1) = 
              (n + 1) * (a1 + (a1 + r * (n + 1 - 1))) / 2) 
‚Ä¢ (skolem 1 n): Introduz a constante Skolem n. 
  |------- 
{1}   (n > 0 => 
        (FORALL (a1: nat, r: nat): 
           somaPA(a1, r, n) = n * (a1 + (a1 + r * (n - 1))) / 2)) 
       => 
       n + 1 > 0 => 
        (FORALL (a1: nat, r: nat): 
           somaPA(a1, r, n + 1) = 
            (n + 1) * (a1 + (a1 + r * (n + 1 - 1))) / 2) 
‚Ä¢ (assert): Procedimento de decis√£o que, neste caso, validou a inequa√ß√£o n + 1 > 0 
e expandiu as equa√ß√µes da f√≥rmula {1}. 
(S1) 
(S2) 
(S3) 
(S4) 
 22 
  |------- 
{1}   (n > 0 => 
        (FORALL (a1: nat, r: nat): 
           somaPA(a1, r, n) = (2 * (a1 * n) - r * n + r * n * n) / 2)) 
       => 
       (FORALL (a1: nat, r: nat): 
          somaPA(a1, r, 1 + n) = 
           (2 * a1 + r * n + (2 * (a1 * n) + r * n * n)) / 2) 
‚Ä¢ (prop): Realiza a simplifica√ß√£o proposicional, principalmente pela constru√ß√£o de 
sub-objetivos que n√£o possuem elementos conectivos proposicionais. Neste caso, 
prop divide em dois sub-objetivos o termo {1}. O primeiro √© trivial e contempla um 
caso onde 0=n . O segundo sub-objetivo √© mostrado a seguir. No termo {2} 
abaixo, utilizamos o comando (expand somaPA) para expandir a fun√ß√£o somaPA em 
um passo da recursividade, o que equivale dizer que 
))]1()(()[()()( 111111 ‚àí++++++=+++++ nrraraarnaraa LL
.
 
[-1]  FORALL (a1: nat, r: nat): 
        somaPA(a1, r, n) = (2 * (a1 * n) - r * n + r * n * n) / 2 
  |------- 
{1}   n = 0 
{2}   FORALL (a1: nat, r: nat): 
        a1 + somaPA(a1 + r, r, n) = 
         (2 * a1 + r * n + (2 * (a1 * n) + r * n * n)) / 2 
‚Ä¢ Skolemizamos o termo {2} para elimina√ß√£o do quantificador universal atrav√©s do 
comando (skolem 2 ("a1" "r")). Em seguida, o termo [-1] √© instanciado (inst -1 
"a1 + r" "r"), gerando-se a hip√≥tese da indu√ß√£o dada por 
2
))()(()()2()( 11111
rnaran
rnarara
+++
=++++++ L . 
{-1} somaPA(a1 + r, r, n) = (2 * ((a1 + r) * n) - r * n + r * n * n)/2 
  |------- 
[1]   n = 0 
[2]   a1 + somaPA(a1 + r, r, n) = 
       (2 * a1 + r * n + (2 * (a1 * n) + r * n * n)) / 2 
‚Ä¢ Assim, queremos demonstrar que [2] vale; utilizando a hip√≥tese em {-1}. Com o 
comando (replace -1 2) realizamos a aplica√ß√£o da hip√≥tese de indu√ß√£o, 
substituindo o termo somaPA(a1 + r, r, n), em [2], pelo lado direito deste termo 
em {-1}. Finalmente, com um comando (assert), o PVS conclui a prova 
verificando a igualdade do termo produzido ap√≥s a substitui√ß√£o em [2]. 
A Figura 2, a seguir, mostra a √°rvore de prova para a soma da PA. Os seq√ºentes 
analisados acima est√£o mostrados em n√≥s correspondentes da √°rvore. 
(S5) 
(S6) 
(S7) 
 23 
 
Figura 2: √Årvore de prova para a soma da PA. 
3.2.2 Outros detalhes de especifica√ß√£o e verifica√ß√£o em PVS. 
Apresentamos acima alguns comandos importantes do provador do PVS, e aspectos 
da linguagem de especifica√ß√£o. Em nossa formaliza√ß√£o do modelo Dolev-Yao para 
protocolos em cascata, utilizamos v√°rios outros elementos, dos quais destacamos os 
 24 
mostrados a seguir. N√£o ser√£o considerados detalhes definicionais dos fragmentos de 
provas apresentados. 
Algumas defini√ß√µes de tipos 
Registros: t√™m a forma [# a1:t1, ..., an:tn #], onde ai √© um campo do registro e ti √© o 
tipo de ai. 
Conjuntos: s√£o definidos no prelude do PVS como setof[T], onde T √© o tipo dos 
elementos do conjunto. Uma utiliza√ß√£o comum √© em fun√ß√µes que retornam um conjunto a 
partir de um argumento. Por exemplo, podemos especificar uma fun√ß√£o 
conjuntomenorque(n : nat), que retorna o conjunto de n√∫meros naturais menores que n, 
conforme a seguir. 
conjuntomenorque(n : nat) : setof[nat] = {num : nat | num < n} 
Atrav√©s a fun√ß√£o member pode-se verificar se um elemento pertence a um conjunto. member 
recebe um atributo T, de tipo T, e um conjunto , de tipo setof[T], retornando verdadeiro 
caso T ‚àà  , e falso caso contr√°rio. Por exemplo, √© verdadeira a express√£o 
member(10,conjuntomenorque(100)). 
Alguns comandos do provador 
‚Ä¢ measure-induct+: Em nosso contexto, este comando foi principalmente utilizado em 
provas por indu√ß√£o sobre o comprimento de seq√º√™ncias, que s√£o compostas por dois 
componentes: length e seq. Por exemplo, para provar que 
|------- 
FORALL(seq: reduzibleseq): first_cancelable(seq) < seq`length ‚Äì 1, 
utilizamos (measure-induct+ "seq`length" "seq"). Obtemos, ent√£o, a seguinte 
estrutura indutiva: 
{-1}  FORALL (y: reduzibleseq): 
           y`length < seq `length => first_cancelable(y) < y`length - 1 
|------- 
{1}   first_cancelable(seq) < seq `length - 1 
Isto √©, se para toda seq√º√™ncia y do tipo reduzibleseq, com comprimento menor que 
outra sequencia seq do mesmo tipo, vale a propriedade first_cancelable(y) < 
y`length - 1, ent√£o vale a propriedade da f√≥rmula {1}. 
‚Ä¢ typepred: Explicita um predicado que define o tipo de um elemento. Geralmente, 
este elemento √© uma vari√°vel skolemizada. Se aplicado ao exemplo apresentado para 
 25 
o comando anterior, (typepred seq) acrescentaria uma f√≥rmula 
reduzibleseq?(seq) como premissa. Este predicado √© precisamente o que define o 
tipo de seq. 
‚Ä¢ decompose-equality: Decomp√µe uma igualdade de elementos como os registros, 
gerando novas igualdades (f√≥rmulas) para cada um dos campos do registro. Por 
exemplo, um registro de tipo op (operador criptogr√°fico) √© definido, em PVS, como 
uma composi√ß√£o de um tipo de opera√ß√£o crTyp (encripta√ß√£o ou decripta√ß√£o) e um 
usu√°rio user, como a seguir: 
op : TYPE = [# crTyp : cryptType, user : U #]. 
Sendo op1 e op2 duas vari√°veis do tipo op, a igualdade op1 = op2 pode ser 
decomposta pelo comando decompose-equality, resultando nas duas igualdades 
abaixo: 
op1`crTyp = op2`crTyp, e 
op1`user = op2`user 
‚Ä¢ case: Na utiliza√ß√£o mais usual deste comando, criam-se dois sub-objetivos a partir 
do ponto onde √© executado. No primeiro, a f√≥rmula especificada no case aparece no 
antecedente, no segundo, aparece no conseq√ºente. Em uma prova por contradi√ß√£o, 
podemos utilizar o comando case da seguinte forma: 
{-1}  alpha0ContainsE?(prot, x, y) 
{-2}  balanced_cascade_protocol?(prot) 
|------- 
{1}   secure_protocol?(prot, x, y, z) 
A f√≥rmula em {1} √© um predicado que avalia se o protocolo criptogr√°fico prot √© 
seguro. Utilizando o comando (case "insecure_protocol?(prot,x,y,z)") forma-se a 
estrutura para uma prova por contradi√ß√£o, pois adiciona-se esta f√≥rmula ao antecedente da 
prova. insecure_protocol? representa, logicamente, o inverso da defini√ß√£o expressa por 
secure_protocol?. 
O case aplica-se tamb√©m em situa√ß√µes onde √© necess√°rio tratar casos espec√≠ficos 
durante uma prova. Por exemplo, considere-se o seguinte estado de uma prova: 
{-1}  normalizeseq(seq1 o seq2) = empty_seq 
|------- 
{1}   areseqcomplements?(seq1, seq2) 
Na situa√ß√£o acima, seq1 e seq2 s√£o seq√º√™ncias finitas. Cada seq√º√™ncia possui um atributo 
que representa seu comprimento (length). empty_seq denota a seq√º√™ncia vazia. Caso seja 
 26 
necess√°rio considerar um caso em que o comprimento de seq1 √© zero, pode-se utilizar o 
comando case: (case "seq1`length = 0"), que criar√° dois sub-objetivos: o primeiro, onde 
a f√≥rmula seq1`length = 0 aparece no antecedente, e o segundo, onde esta mesma f√≥rmula 
aparece no conseq√ºente. Assim, o primeiro sub-objetivo forma o caso em que se deseja um 
tratamento especifico para seq1`length = 0. O segundo sub-objetivo forma o caso geral, 
onde seq1`length = 0 √© falso, ou seja, seq1`length > 0. 
  
 27 
Cap√≠tulo 4.  
O Modelo Dolev-Yao para 
Protocolos em Cascata 
A seguir, apresentamos a formaliza√ß√£o anal√≠tica para a seguran√ßa de protocolos 
cascata, mostrando tamb√©m as condi√ß√µes sob as quais se define essa seguran√ßa. Em alguns 
aspectos, nossa modelagem difere daquela originalmente proposta por Dolev e Yao em [6], 
principalmente porque a formaliza√ß√£o do modelo original apresenta imprecis√µes, o que foi 
verificado atrav√©s da mecaniza√ß√£o do modelo em PVS. As defini√ß√µes, lemas e provas, 
analiticamente apresentados a seguir, foram baseados na especifica√ß√£o e verifica√ß√£o 
realizadas em PVS. 
4.1 Conceitos e defini√ß√µes b√°sicos 
Em um sistema de chaves p√∫blicas, seja L um conjunto enumer√°vel de usu√°rios. 
Um participante U‚ààL  tem um par de operadores IV  e WV  que denotam, 
respectivamente, a fun√ß√£o de x para encripta√ß√£o e a fun√ß√£o de x para decripta√ß√£o de 
mensagens. O conjunto de operadores I = YIV|U‚ààL[ √© dito p√∫blico, ou seja, √© conhecido 
por todos os usu√°rios. Por outro lado, operadores W = YWV|U‚ààL[ s√£o privados, de modo 
que WV √© conhecido somente pelo usu√°rio x. Restri√ß√µes deste tipo, assumidas sempre como 
v√°lidas, s√£o chamadas de primitivas criptogr√°ficas. 
A aplica√ß√£o de operadores de I e de W, a uma mensagem \, √© representada por IV(\)  e WV(\) , para todo usu√°rio U ‚àà L . Para melhor legibilidade, escrevemos ] ^]_]`(. . . ](\). . . )bc como ]]]`. . . ]\, onde ]  ( = 1. . ) √© um operador. As 
fun√ß√µes de encripta√ß√£o e decripta√ß√£o s√£o inversas para todos os usu√°rios, ou seja, para 
qualquer mensagem \ e qualquer U ‚àà L, vale 
 28 
IV_WV(\)b = WV_IV(\)b = \ 
Seja Œ£ = I ‚à™ W, e Œ£* o conjunto de palavras finitas sobre  Œ£, com h denotando a 
palavra vazia. Utilizaremos o mon√≥ide gerado pelos s√≠mbolos de Œ£, considerando-se o 
seguinte conjunto de congru√™ncias: IVWV = WVIV = h, ‚àÄU ‚àà L 
Neste mon√≥ide m√≥dulo as congru√™ncias acima, para toda palavra j ‚àà Œ£‚àó, existe 
uma √∫nica forma can√¥nica jk, onde n√£o existe nenhuma subpalavra da forma IVWV ou WVIV, para qualquer U‚ààL. Desta forma, definimos a normaliza√ß√£o e, sempre que j = jk, j est√° na forma normal ou reduzida; caso contr√°rio, j √© chamado de normaliz√°vel ou 
redut√≠vel. Considerando um usu√°rio T ‚àà L, dizemos que jl|  √© normal com respeito a T, 
quando n√£o existe nenhuma subpalavra I W  ou W I  em j. 
Alguns lemas simples, como a propriedade a seguir, s√£o provados na formaliza√ß√£o 
em PVS, e suas provas, ainda que rotineiras, s√£o tecnicamente elaboradas. 
Lema 1 [Uma propriedade de normaliza√ß√£o] Para todo Œ¥, Œ¥, Œ¥` ‚àà Œ£‚àó, vale Œ¥Œ¥Œ¥`nnnnnnnnn =Œ¥Œ¥nnnŒ¥`nnnnnnnnn. 
Prova. Por indu√ß√£o no comprimento de j. 
BI. Caso j = h, hk = h, e jhj`nnnnnnnn = jj`nnnnnn. 
PI. Vamos assumir que, para j = oo (o, o ‚àà Œ£‚àó), vale jjj`nnnnnnnnn = jjnnnj`nnnnnnnnn. Seja jp  da 
forma oIVWVo ou oWVIVo. Pela defini√ß√£o de normaliza√ß√£o, jpnnn = oonnnnnn, ent√£o temos 
que jjp j`nnnnnnnnn = jooj`nnnnnnnnnnnn. Assim, por HI, jjp j`nnnnnnnnn = jjpnnnj`nnnnnnnnn. 
Para todo j ‚àà Œ£‚àó, |j| denota o comprimento da seq√º√™ncia j, ou seja, a quantidade 
de operadores em j. E, para todo 0 ‚â§ q < , onde |j| =  ‚àà ‚Ñï, js  √© o (q + 1)-√©simo 
s√≠mbolo em j . Para 0 ‚â§ q ‚â§  < , jus,v  denota a subpalavra de j  composta pelos 
s√≠mbolos (q + 1)-√©simo a ( + 1)-√©simo. 
O complemento de um operador √© definido, para todo U ‚àà L, como IV! = WV e WV! = IV. Para todo j ‚àà Œ£‚àó, j! denota o complemento de j, definido como: h! = h ‚àÄ0 ‚â§  < |j|: (j!) = _j|x|yyb! 
 29 
Por exemplo, (IVIVWV)! = IVWVWV. 
Por premissas estabelecidas anteriormente para um sistema de chaves p√∫blicas no 
modelo Dolev-Yao, um usu√°rio U ‚àà L n√£o possui informa√ß√µes sobre operadores privados 
de um usu√°rio z ‚àà L | z ‚â† U. Assim, definimos ‚àÄU, z ‚àà L a fun√ß√£o Œ¶(U, z)  que, para 
cada par de usu√°rios, retorna o conjunto de operadores que podem ser aplicados por U a 
uma mensagem \ enviada a z. Assim, Œ¶(U, z) = }WV, I~ , IV. 
Com esses elementos, podemos apresentar a no√ß√£o de protocolos em cascata entre 
dois usu√°rios. Protocolos desta classe consistem de uma seq√º√™ncia de passos de 
comunica√ß√£o de ida e volta, alternadamente, entre dois usu√°rios, utilizando os operadores 
de Œ¶ em cada passo. 
4.2 Formaliza√ß√£o anal√≠tica do modelo 
4.2.1 Protocolo em cascata e linguagem do advers√°rio 
Nesta se√ß√£o, apresentamos as defini√ß√µes formais que descrevem um protocolo em 
cascata e, com base nestas defini√ß√µes, a linguagem utilizada pelo advers√°rio na intera√ß√£o 
com esse protocolo. 
Defini√ß√£o 1 [Passo de protocolo] Para a comunica√ß√£o entre dois usu√°rios quaisquer, 
definimos a fun√ß√£o ¬Ä¬Å: L √ó L ‚Üí Œ£‚àó, de modo que, ‚àÄU, z ‚àà L | U ‚â† z, temos: 
¬É¬Ñ
¬Ñ¬Ñ¬Ñ
¬Ö
¬Ñ¬Ñ¬Ñ
¬Ñ¬Ü1. ¬Ä¬Å(U, z) ‚â† h                                                               2. ¬Ä¬Å(U, z) = ¬Ä¬Å(U, z)nnnnnnnnnnn                                                 3. ¬Ä¬Å(U, z) ‚àà Œ¶(U, z)‚àó                                                  4. ‚àÄ¬ä, ¬ã ‚àà L:                                                                    4.1. |¬Ä¬Å(U, z)| = |¬Ä¬Å(¬ä, ¬ã)|                                 4.2. ‚àÄ0 ‚â§ q < |¬Ä¬Å(U, z)|:                                      4.2.1. ¬Ä¬Å(U, z)s = IV ¬å¬å¬ç ¬Ä¬Å(¬ä, ¬ã)s = I$4.2.2. ¬Ä¬Å(U, z)s = I~ ¬å¬å¬ç ¬Ä¬Å(¬ä, ¬ã)s = I¬é4.2.3. ¬Ä¬Å(U, z)s = WV ¬å¬å¬ç ¬Ä¬Å(¬ä, ¬ã)s = W$4.2.4. ¬Ä¬Å(U, z)s = W~ ¬å¬å¬ç ¬Ä¬Å(¬ä, ¬ã)s = W¬é
l
 
 30 
Isto √©, um ¬Ä¬Å(U, z) √© uma seq√º√™ncia n√£o vazia (condi√ß√£o 1) e normal (condi√ß√£o 2) de 
operadores utilizados por U ao enviar uma mensagem qualquer a z (condi√ß√£o 3). Al√©m 
disso, todos os pares de usu√°rios, distintos entre si, trocam mensagens segundo as mesmas 
regras (condi√ß√£o 4), ou seja, ‚àÄ¬ä, ¬ã ‚àà L , temos que um ¬Ä¬Å(¬ä, ¬ã)  possui a mesma 
seq√º√™ncia de operadores de ¬Ä¬Å(U, z), exceto pelo renomeamento dos usu√°rios. 
Defini√ß√£o 2 [Protocolo em cascata] Um protocolo em cascata ¬è √© uma seq√º√™ncia n√£o 
vazia de passos de protocolo. Para a comunica√ß√£o entre dois usu√°rios U, z ‚àà L quaisquer, ¬è aplica os passos de protocolo de forma que a comunica√ß√£o alterna-se entre os usu√°rios U 
e z; isto √©, ‚àÄ0 ‚â§  < |¬è|, o passo ¬è aplica-se segundo os seguintes casos: 
1.  ¬è(U, z),  para  par (U envia mensagem para z) 2.  ¬è(z, U),  para  √≠mpar  (z envia mensagem para U) 
Por abuso de nota√ß√£o, representaremos um  ¬è(U, z) ou  ¬è(z, U) por ¬è, conforme seja 
conveniente. Uma subseq√º√™ncia ¬è ‚Ä¶ ¬ès  (0 ‚â§  ‚â§ q < |¬è|) de ¬è ser√° representada por ¬èu,sv. 
Na defini√ß√£o acima, a comunica√ß√£o entre um par de usu√°rios U e z alterna em cada 
passo de comunica√ß√£o a sua dire√ß√£o; nas posi√ß√µes pares U envia mensagens para z e, nas 
posi√ß√µes √≠mpares, z envia mensagens para U. Isso √© formalizado ao se intercambiar os 
argumentos U e  z dos passos de protocolo. Na comunica√ß√£o entre estes dois usu√°rios, 
cada passo de protocolo ¬è √© aplicado seq√ºencialmente a uma mensagem \, a partir de ¬è¬ê. Ou seja, considerando que U ‚Üí z represente o envio de uma mensagem \ de U para z, temos: U ‚Üí z: ¬è¬ê\ = ¬Ä¬Å¬ê(U, z)\ z ‚Üí U: ¬è¬è¬ê\ = ¬Ä¬Å(z, U)¬Ä¬Å¬ê(U, z)\ ‚ãÆ U ‚Üí z: ¬è|¬ë|y ‚Ä¶ ¬è¬ê\ = ¬Ä¬Å|¬ë|y(U, z) ‚Ä¶ ¬Ä¬Å¬ê(U, z)\, se |¬è| > 2 √≠¬ïT¬ñ;  ¬ò¬ô z ‚Üí U: ¬è|¬ë|y ‚Ä¶ ¬è¬ê\ = ¬Ä¬Å|¬ë|y(z, U) ‚Ä¶ ¬Ä¬Å¬ê(U, z)\, se |¬è| > 2 ¬ïT¬ñ.  
Defini√ß√£o 3 [Linguagem admiss√≠vel do advers√°rio] Um advers√°rio ¬ö, que tenta subverter 
um protocolo em cascata ¬è, disp√µe de uma linguagem admiss√≠vel (Œ£(¬ö)‚àó ‚à™ Œ£)‚àó, onde 
Œ£(¬ö) = I ‚à™ YW¬õ[, e Œ£ = Y¬è(U, z) | 1 ‚â§  < |¬è| e U, z ‚àà L, U ‚â† z[. 
 31 
A defini√ß√£o acima descreve as possibilidades de intera√ß√£o de um advers√°rio ¬ö, no modelo 
Dolev-Yao, com o protocolo ¬è. Assume-se que ¬ö seja capaz de observar todo o tr√°fego da 
rede e que seja limitado pelas primitivas criptogr√°ficas, ou seja, ¬ö n√£o possui nenhum 
conhecimento sobre o conjunto W\YW¬õ[. Desta forma, para se obter um o dentro da 
linguagem admiss√≠vel, ¬ö pode: 
 Utilizar a linguagem _Œ£(¬ö)b‚àó: ¬ö faz qualquer coisa que um usu√°rio honesto √© 
capaz de fazer e, assim, possui um operador privado e tem conhecimento de todo 
operador p√∫blico. 
 Utilizar passos de protocolo Y¬è(U, z) |  par e 1 <  < |¬è| e U, z ‚àà L[: ¬ö √© capaz 
de criar, interceptar e alterar mensagens. Assim, para obter ¬è(U, z) aplicado a 
uma mensagem, ¬ö intercepta a ( ‚àí 1)-√©sima mensagem \ de z para U. Ent√£o, ¬ö se passa por z, o que denotamos por ¬ö(z), e atua ativamente na comunica√ß√£o 
com U, enviando uma mensagem \p arbitrariamente escolhida, ou seja, ¬ö(z) ‚Üí U: \p (passo ¬èy √© executado por ¬ö como se fosse z) U ‚Üí ¬ö(z): ¬è(U, z)\p (passo  de ¬è), 
A restri√ß√£o de que ¬ö n√£o disp√µe de ¬è¬ê deixa claro que a comunica√ß√£o ocorre por 
iniciativa do usu√°rio U, que envia ¬è¬ê(U, z)\ a z, ou seja, ¬ö deve esperar que U 
inicie uma conversa com z . Apesar da possibilidade de isto n√£o acontecer, 
consideramos o pior caso para fins de defini√ß√£o de seguran√ßa. 
 Utilizar passos de protocolo Y¬è(z, U) |  √≠mpar e 1 ‚â§  < |¬è| e U, z ‚àà L[ : Neste 
caso, ¬ö inicia uma conversa com z, passando-se por U. Para que ¬ö obtenha um ¬è(z, U) aplicado a uma mensagem \p escolhida, as seguintes opera√ß√µes sobre \p 
s√£o executadas a partir do passo  ‚àí 1 de ¬è: ¬ö(U) ‚Üí z: \p    (passo  ‚àí 1 de ¬è) z ‚Üí ¬ö(U): ¬è(z, U)\p (passo  de ¬è) 
 
 
 32 
4.2.2 Definindo a seguran√ßa de protocolos em cascata 
Mostraremos, a seguir, as propriedades e condi√ß√µes que possibilitam a defini√ß√£o da 
seguran√ßa para protocolos em cascata. 
Defini√ß√£o 4 [Propriedade de balanceamento (PB)] Seja ¬† ‚àà Y¬°, ¬¢[‚àó. ¬† possui a PB 
com respeito a ¬£ ‚àà ¬§, quando a exist√™ncia de um operador privado de ¬£ em ¬† implica na 
exist√™ncia de um operador p√∫blico de ¬£ em ¬†, ou seja, 
‚àÉ0 ‚â§  < |¬¶|: ¬¶ = W¬õ ‚áí ‚àÉ0 ‚â§ q < |¬¶|: ¬¶s = I¬õ 
Defini√ß√£o 5 [Protocolo balanceado] Um protocolo em cascata ¬è √© balanceado se 
¬®‚àÄU, z ‚àà L e ‚àÄ0 <  < |¬è|:                                               ¬è(U, z) tem a PB com respeito a U, se  √© par.    ¬è(z, U) tem a PB com respeito a z, se  √© √≠mpar. l 
Por exemplo, supondo que ¬è(U, z) = I~WVI~, ent√£o o protocolo ¬è n√£o √© balanceado, 
uma vez que ¬è(U, z) n√£o tem a PB com respeito a U. 
Defini√ß√£o 6 [Condi√ß√£o inicial de seguran√ßa] Dizemos que um protocolo em cascata ¬è 
satisfaz a condi√ß√£o inicial de seguran√ßa quando, ‚àÄU, z ‚àà L, temos: ¬è¬ê(U, z) ‚à© }IV, I~ ‚â† ¬™ 
Sem esta condi√ß√£o, um advers√°rio ¬ö ‚àà L pode trivialmente obter uma mensagem \ 
transmitida entre os usu√°rios U e z, j√° que U disp√µe somente do operador WV. 
Defini√ß√£o 7 [Protocolo seguro] Um protocolo em cascata ¬è √© seguro quando, para 
quaisquer tr√™s usu√°rios distintos entre si U, z, ¬ö ‚àà L, ‚àÄo ‚àà (Œ£‚àó(¬ö) ‚à™ Œ£)‚àó e 0 ‚â§  < |¬è|, 
vale o¬è¬´ ‚Ä¶ ¬è¬ênnnnnnnnnn ‚â† h 
Caso contr√°rio, o protocolo √© inseguro. 
Por esta defini√ß√£o, nenhum advers√°rio ¬ö  pode inverter uma seq√º√™ncia de passos de 
protocolo, a fim de obter uma mensagem \ a ser transmitida em sigilo entre os usu√°rios U e z. 
 33 
4.2.3 Balanceamento da linguagem admiss√≠vel do advers√°rio 
Nesta se√ß√£o, provamos algumas propriedades importantes relativas √† linguagem 
admiss√≠vel do advers√°rio. Para isso, inicialmente, definimos o T -balanceamento e a 
propriedade de enlace, descritos a seguir. 
Defini√ß√£o 8 [T-balanceamento] Seja uma seq√º√™ncia de operadores ¬¶ e um usu√°rio T ‚ààL. Dizemos que ¬¶ √© T-balanceada quando o seguinte √© satisfeito: Se ‚àÉU, z ‚àà L | U, z ‚â† T 
com ¬¶¬ê = WV e ¬¶|¬¨|y = W~ e ¬¶u,|¬¨|yv l|  cont√©m W , ent√£o ¬¶u,|¬¨|yv l|  tem a PB com 
respeito a T. 
Defini√ß√£o 9 [Propriedade de enlace ‚Äì PE] Seja um usu√°rio ¬ö ‚àà L. Uma seq√º√™ncia de 
operadores ] tem a PE com respeito a ¬ö quando toda substring de W¬õ]W¬õ √©, para todo 
usu√°rio T ‚àà L | T ‚â† ¬ö, T-balanceada. 
Lema 2 [¬≠‚àó(¬£) e ¬Æ satisfazem PE]: Seja ¬è um protocolo em cascata balanceado, ¬ö 
um usu√°rio e j uma seq√º√™ncia de operadores. Se j ‚àà Œ£‚àó(¬ö) ou j ‚àà Œ£, ent√£o j tem a 
PE com respeito a ¬ö. 
Prova. Precisamos demonstrar que, para todo natural , q |  < q < |j| + 2 e todo usu√°rio T ‚àà L | T ‚â† ¬ö , (W¬õjW¬õ)u,sv  (substrings de W¬õjW¬õ ) √© T -balanceada, ou seja, que o 
seq√ºente a seguir √© verdadeiro: 
 
Consideremos, separadamente, os casos j ‚àà Œ£‚àó(¬ö) e j ‚àà Œ£. 
‚Ä¢ j ‚àà Œ£‚àó(¬ö): Como W¬õ ‚àà Œ£(¬ö), vale W¬õjW¬õ ‚àà Œ£‚àó(¬ö). Assim, temos que (W¬õjW¬õ)u,sv ‚ààŒ£‚àó(¬ö) implica W ‚àâ _(W¬õjW¬õ)u,svb¬∞,¬±(¬≤¬≥x¬≤¬≥)u¬¥,¬µv¬±y¬∂ l| , pois W ‚àâ Œ£‚àó(¬ö). 
j ‚àà Œ£‚àó(¬ö) ou j ‚àà Œ£, ‚àÉU, z ‚àà L | U, z ‚â† T, tais que _(W¬õjW¬õ)u,svb¬ê = WV e  _(W¬õjW¬õ)u,svb¬±(¬≤¬≥x¬≤¬≥)u¬¥,¬µv¬±y = W~, W ‚àà _(W¬õjW¬õ)u,svb¬∞,¬±(¬≤¬≥x¬≤¬≥)u¬¥,¬µv¬±y¬∂ l| , 
implica _(W¬õjW¬õ)u,svb¬∞,¬±(¬≤¬≥x¬≤¬≥)u¬¥,¬µv¬±y¬∂ l|  tem a PB com respeito a T. 
 34 
‚Ä¢ j ‚àà Œ£: Para este caso, consideramos o protocolo ¬è entre dois usu√°rios ¬ä, ¬ã ‚àà L, com j = ¬è(¬ä, ¬ã), onde 0 <  < |¬è|. Assim, diferenciamos dois casos: T = ¬ä e T ‚â† ¬ä. 
Os casos em que T = ¬ã e T ‚â† ¬ã s√£o an√°logos. 
 T = ¬ä : Para o caso em que  = 0  e q = |j| + 1 , _(W¬õjW¬õ)u,svb¬∞,¬±(¬≤¬≥x¬≤¬≥)u¬¥,¬µv¬±y¬∂ l| = j, de modo que U = ¬ö e z = ¬ö, na defini√ß√£o 
de T-balanceamento. Com W ‚àà j, temos a PB para j, pois ¬è √© balanceado. 
Para  > 0 (e, analogamente, para q < |j| + 1), n√£o existe um usu√°rio U ‚â† T tal 
que _(W¬õjW¬õ)u,svb¬ê = WV, j√° que _(W¬õjW¬õ)u,svb¬ê = jy e jy ‚àà YI$, I¬é, W$[. 
 T ‚â† ¬ä: Neste caso, W ‚àâ _(W¬õjW¬õ)u,svb¬∞,¬±(¬≤¬≥x¬≤¬≥)u¬¥,¬µv¬±y¬∂ l| , uma vez que qualquer 
operador de _(W¬õjW¬õ)u,svb¬∞,¬±(¬≤¬≥x¬≤¬≥)u¬¥,¬µv¬±y¬∂ l|  corresponde a um operador de j ‚àà YI$, I¬é, W$[‚àó. 
Lema 3 [Preserva√ß√£o da PE na composi√ß√£o de duas seq√º√™ncias] Seja um protocolo em 
cascata balanceado ¬è, um usu√°rio ¬ö ‚àà L e as seq√º√™ncias de operadores ¬∑ e ]. Se ¬∑ e ] 
t√™m a PE com respeito a ¬ö, ent√£o a seq√º√™ncia ¬∑] tem a PE com respeito a ¬ö. 
Prova. Devemos mostrar que, para todo usu√°rio T ‚â† ¬ö, toda substring de W¬õ¬∑]W¬õ √© T-
balanceada. Sabemos que toda substring de W¬õ¬∑W¬õ  ou W¬õ]W¬õ  √© T-balanceada. Ent√£o, 
precisamos mostrar somente que s√£o T-balanceadas as substrings j  de W¬õ¬∑]W¬õ , que 
iniciem em alguma posi√ß√£o de W¬õ¬∑ e terminem em alguma posi√ß√£o de ]W¬õ. Conforme a 
defini√ß√£o de T-balanceamento: Se ‚àÉU, z ‚àà L | U, z ‚â† T com j¬ê = WV  e j|x|y = W~ , e ju,|x|yv l|  cont√©m W , ent√£o ju,|x|yv l|  tem a PB com respeito a T . Assim, j =WV¬∑u,|¬∏|yv]u¬ê,svW~ (, q ‚àà ‚Ñï |  < |¬∑| e q < |]|). Vamos supor que ju,|x|yv l|  n√£o tem a 
PB com respeito a T. Deste modo, W ‚àà ju,|x|yv l| , mas I ‚àâ ju,|x|yv l| . Isto leva a uma 
contradi√ß√£o, pois resulta na ocorr√™ncia de pelo menos um dos dois casos a seguir. 
1. W ‚àà ¬∑u,|¬∏|yv l| : Como I ‚àâ ju,|x|yv l| , temos que I ‚àâ ¬∑u,|¬∏|yv l|  e, assim, a 
substring WV¬∑u,|¬∏|yvW¬õ de W¬õ¬∑W¬õ n√£o √© T-balanceada. 
2. W ‚àà ]u¬ê,sv l| : Como I ‚àâ ju,|x|yv l| , temos que I ‚àâ ]u¬ê,sv l|  e, assim, a substring W¬õ]u¬ê,svW~ de W¬õ]W¬õ n√£o √© T-balanceada. 
 35 
Note que os dois casos acima s√£o simultaneamente verdadeiros, caso n√£o surjam pares 
normaliz√°veis I W  ou W I , ao se compor a seq√º√™ncia ¬∑], a partir de ¬∑ e ]. Se um 
par normaliz√°vel √© criado na fronteira entre ¬∑ e ], ent√£o existe um operador I  em ¬∑u,|¬∏|yv l|  ou ]u¬ê,sv l| . Se I ‚àà ¬∑u,|¬∏|yv l| , ent√£o somente o caso 2, acima, √© verdadeiro. O 
caso 1 √© verdadeiro quando I ‚àà ]u¬ê,sv l| . 
Lema 4 [PE para linguagem admiss√≠vel do advers√°rio] Seja ¬è um protocolo em cascata 
balanceado, ¬ö um usu√°rio e ‚àÄo ‚àà (Œ£‚àó(¬ö) ‚à™ Œ£)‚àó. Ent√£o, o tem a PE com respeito a ¬ö. 
Prova. Podemos escrever o = j¬êj ‚Ä¶ j , onde 0 ‚â§   e j ‚àà Œ£‚àó(¬ö)  ou j ‚àà Œ£ . Por 
indu√ß√£o no n√∫mero de termos j de o, temos: 
BI. o = h tem a PE com respeito a ¬ö, pois n√£o existem usu√°rios U, z ‚àà L , conforme a 
Defini√ß√£o 8. 
PI. Vamos supor que o = j¬êj ‚Ä¶ j tenha a PE com respeito a ¬ö. Seja j¬π ‚àà Œ£‚àó(¬ö) ou j¬π ‚àà Œ£ , tal que op = oj¬π . Pelo Lema 2, j¬π  tem a PE com respeito a ¬ö . 
Considerando-se a hip√≥tese de indu√ß√£o e o Lema 3, com ¬∑ = o e ] = j¬π, temos que op 
tem a PE com respeito a ¬ö. 
Lema 5 [PE de uma seq√º√™ncia implica PE da normaliza√ß√£o desta seq√º√™ncia] Seja ] ‚àà Œ£‚àó e ¬ö ‚àà L. Se ] tem a PE com respeito a ¬ö, ent√£o ]k tem a PE com respeito a ¬ö. 
Prova. Para a constru√ß√£o de ]k, podemos supor a exist√™ncia de um m√©todo iterativo que 
elimine, em cada passo de normaliza√ß√£o, um par ¬∫$¬∫$!  de ], para todo ¬ä ‚àà L, e onde ¬∫$ = W$ ou ¬∫$ = I$. Assim, podemos provar este lema por indu√ß√£o no n√∫mero de passos 
para a constru√ß√£o de ]k. Representaremos por ] a aplica√ß√£o de  passos de normaliza√ß√£o 
a uma seq√º√™ncia ]. 
BI. Se ]k √© constru√≠do em zero passos, ent√£o ] = ]k. Assim, ]k tem a PE com respeito a ¬ö. 
PI. Suponhamos que, para ] ( > 0), seja verdade que, se ]  tem a PE com respeito a ¬ö, 
ent√£o ]¬´¬ª  tem a PE com respeito a ¬ö. No passo  + 1 vale que ]¬´¬ª = ]¬´¬πnnnnnn, ent√£o ]¬´¬πnnnnnn tem 
a PE com respeito a ¬ö. Assim, basta mostrar que, se ]¬π = ]p]pp tem a PE com respeito a ¬ö, ent√£o ] = ]p¬∫$¬∫$!]pp tem a PE com respeito a ¬ö, ou seja, toda substring de W¬õ]W¬õ √© T-balanceada para todo usu√°rio T ‚àà L | T ‚â† ¬ö. Verificaremos, ent√£o, se as substrings de 
 36 
] , que n√£o existem em ]¬π , s√£o T -balanceadas. Nessas substrings encontramos 
operadores ¬∫$ e/ou ¬∫$! . Quando ¬ä = T, o T-balanceamento √© v√°lido para ], uma vez 
que ] l| = ]¬π l| . Para ¬ä ‚â† T , e sabendo que toda substring de W¬õ]¬πW¬õ  √© T -
balanceada, temos como substrings de ], que n√£o existem em ]¬π (consideremos que , q ‚àà ‚Ñï |  < |]p| e q < |]pp|): 
‚Ä¢ ]¬∞,¬±¬º¬Ω¬±y¬∂p ¬æI$  e I$¬æ]u¬ê,svpp  (com ¬æ = h  ou ¬æ = W$ ): s√£o T -balanceadas, pela 
defini√ß√£o de T-balanceamento. 
‚Ä¢ ]¬∞,¬±¬º¬Ω¬±y¬∂p ¬æW$ e W$¬æ]u¬ê,svpp : (com ¬æ = h ou ¬æ = I$):  T-balanceamento v√°lido, pois, 
como ]¬∞,¬±¬º¬Ω¬±y¬∂p  e ]u¬ê,svpp  s√£o T -balanceadas, se W ‚àà ]¬∞,¬±¬º¬Ω¬±y¬∂p ¬æW$ l|  ou W ‚ààW$¬æ]u¬ê,svpp l| , ent√£o estas duas seq√º√™ncias t√™m a PB com respeito a T 
‚Ä¢ ]¬∞,¬±¬º¬Ω¬±y¬∂p ¬∫$¬∫$!]u¬ê,svpp : o T-balanceamento tamb√©m √© v√°lido para esta subseq√º√™ncia, 
pois ]¬∞,¬±¬º¬Ω¬±y¬∂p ]u¬ê,svpp  √© T-balanceada e W ‚àâ ¬∫$¬∫$! . 
Lema 6 [Balanceamento da linguagem admiss√≠vel] Seja ¬è um protocolo em cascata 
balanceado. Temos que, para um usu√°rio ¬ö ‚àà U, ‚àÄo ‚àà (Œ£‚àó(¬ö) ‚à™ Œ£)‚àó e ‚àÄT ‚àà L| T ‚â† ¬ö, 
vale que ok tem a PB com respeito a T. 
Prova. Pelo Lema 4, o tem a PE. Al√©m disso, pelo Lema 5, temos a PE para ok. Deste 
modo, pela defini√ß√£o de PE, W¬õokW¬õ  √© -balanceada para todo T ‚àà L | T ‚â† ¬ö, porque ‚àÉU, z ‚àà L | U, z = ¬ö , com W¬õokW¬õ¬ê = WV  e W¬õokW¬õ|¬≤¬≥¬ø¬ª¬≤¬≥|y = W~ . Al√©m disso, ok =W¬õokW¬õu,|¬≤¬≥¬ø¬ª¬≤¬≥|yv l|  cont√©m W , ent√£o ok tem a PB com respeito a T. Assim, conclu√≠mos 
a prova. 
 
 
 
 
 37 
4.2.4 Provando a seguran√ßa de protocolos em cascata 
A seguir, provamos o teorema que estabelece as condi√ß√µes de seguran√ßa para um 
protocolo em cascata. 
Teorema 1 [Seguran√ßa de Protocolos em Cascata] Um protocolo em cascata √Ä √© seguro 
se, e somente se, 
(i) satisfaz a condi√ß√£o inicial de seguran√ßa, e 
(ii) √© balanceado. 
A prova do Teorema 1 divide-se em A. Necessidade e B. Sufici√™ncia e, antes ou durante 
o desenvolvimento de cada uma destas provas, enunciaremos lemas e defini√ß√µes 
necess√°rios, sempre considerando, onde aplic√°vel, quaisquer tr√™s usu√°rios U, z, ¬ö ‚àà L , 
distintos entre si. 
A. Necessidade Se ¬è √© seguro, ent√£o (i) e (ii) s√£o v√°lidos. Provaremos a contra-
rec√≠proca desta implica√ß√£o, ou seja, assumindo que (i) ou (ii) n√£o valem, ent√£o ¬è √© 
inseguro. 
I. (i) n√£o vale, ent√£o ¬è √© inseguro. 
Prova. Como (i) n√£o vale, ¬è¬ê ‚àà YWV[‚àó . Assim, ¬è  √© inseguro, uma vez que 
podemos fazer o = ¬è¬ê! ‚àà YIV[‚àó ‚àà Œ£‚àó(¬ö), a fim de se obter o¬è¬ênnnnn = h. 
II. (ii) n√£o vale, ent√£o ¬è √© inseguro.  
Prova. Neste caso, a inseguran√ßa de ¬è ser√° mostrada por indu√ß√£o no comprimento 
de ¬è¬ê , tomando-se como hip√≥tese que ‚àÉo ‚àà (Œ£‚àó(¬ö) ‚à™ Œ£)‚àó , tal que o¬è¬ênnnnn = h . 
Consideremos, portanto, o Lema 7 a seguir. 
Lema 7 [Extra√ß√£o de operador privado] Sejam dois usu√°rios quaisquer ¬ä, ¬ã ‚àà L | ¬ä ‚â† ¬ã . Se um passo de protocolo ¬Ä¬Å(¬ä, ¬ã)  √© desbalanceado com 
respeito a ¬ä, ent√£o existem duas seq√º√™ncias de operadores √Å, √Å ‚àà Œ£‚àó(¬ã), tais que 
√Å¬Ä¬Å(¬ä, ¬ã)√Ånnnnnnnnnnnnnnnn = W$. 
Prova. Pelo desbalanceamento, sabemos que ¬Ä¬Å ‚àà YW$, I¬é[‚àó . Ent√£o, ¬Ä¬Å! ‚àà
YI$, W¬é[‚àó ‚àà Œ£
‚àó(¬ã) = YI$, I¬é, W¬é[‚àó  e, assim, para todo 0 ‚â§  ‚â§ q < |¬Ä¬Å|, temos 
¬Ä¬Åu,sv
! ‚àà Œ£‚àó(¬ã) . Como, pelo desbalanceamento, ‚àÉ0 ‚â§  < |¬Ä¬Å| tal que ¬Ä¬Å =
 38 
W$ , podemos fazer √Å = ¬Ä¬Åu¬ê,yv!  e √Å = ¬Ä¬Åu¬π,|√Ç√É√Ñ|yv
!
 e, deste modo, 
√Å¬Ä¬Å(¬ä, ¬ã)√Ånnnnnnnnnnnnnnnn = W$.  
Continua√ß√£o da prova indutiva de A. Necessidade - II: 
BI Se |¬è¬ê(U, z)| = 1, ent√£o temos tr√™s possibilidades para a forma√ß√£o de ¬è¬ê(U, z). Ou 
¬è¬ê(U, z) = IV ou ¬è¬ê(U, z) = I~ ou ¬è¬ê(U, z) = WV. Para o primeiro caso, considerando-
se o Lema 7, pode-se obter o = WV. O segundo caso √© an√°logo ao primeiro e no terceiro 
caso basta escolher o = IV. 
PI Assume-se como verdadeiro que ‚àÉo ‚àà (Œ£‚àó(¬ö) ‚à™ Œ£)‚àó , tal que o(¬è¬ê)u,|¬ë√Ö|yvnnnnnnnnnnnnnnnnn = h . 
Ent√£o, deve ser mostrado que ‚àÉop ‚àà (Œ£‚àó(¬ö) ‚à™ Œ£)‚àó, tal que op¬∫(¬è¬ê)u,|¬ë√Ö|yvnnnnnnnnnnnnnnnnnnnn = h, sendo 
¬è¬ê = ¬∫(¬è¬ê)u,|¬ë√Ö|yv e ¬∫ ‚àà }IV , I~, WV. Assim, podem-se distinguir tr√™s casos: 
a) ¬è¬ê = IV(¬è¬ê)u,|¬ë√Ö|yv: O desbalanceamento de ¬è ocorre em algum ¬è  (0 <  <
|¬è|). Vamos assumir que  seja par, ou seja, o desbalanceamento de ¬è(U, z) √© 
com respeito a U . Pelo Lema 7, ‚àÉ √Å, √Å ‚àà Œ£(¬ö)  tais que √Å¬è¬´(U, ¬ö)√Ånnnnnnnnnnnnnnn = WV . 
Assim, por hip√≥tese de indu√ß√£o, o protocolo √© inseguro, pois 
op = o√Å¬è¬´(U, ¬ö)√ÅnnnnnnnnnnnnnnnIV(¬è¬ê)u,|¬ë√Ö|yv
nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn = o(¬è¬ê)u,|¬ë√Ö|yv
nnnnnnnnnnnnnnnnn = h. Para um valor √≠mpar de , 
temos um desbalanceamento de ¬è(z, U) com respeito a z e a prova √© an√°loga. 
b) ¬è¬ê = WV(¬è¬ê)u,|¬ë√Ö|yv: Neste caso, podemos fazer op = oIV e, deste modo, concluir 
que o protocolo √© inseguro por hip√≥tese de indu√ß√£o, op¬è¬ênnnnnn = oIVWV(¬è¬ê)u,|¬ë√Ö|yvnnnnnnnnnnnnnnnnnnnnnnn =
o(¬è¬ê)u,|¬ë√Ö|yv
nnnnnnnnnnnnnnnnn = h. 
c) ¬è¬ê = I~(¬è¬ê)u,|¬ë√Ö|yv: Este passo da prova √© an√°logo ao do item a), acima. 
B. Sufici√™ncia Sendo verdade (i) e (ii), temos que demonstrar que ¬è √© seguro. 
Suponhamos, por contradi√ß√£o, que (i) e (ii) valem, mas que ¬è √© inseguro, ou seja, 
‚àÉo ‚àà (Œ£
‚àó(¬ö) ‚à™ Œ£)‚àó tal que o¬è¬´ ‚Ä¶ ¬è¬ênnnnnnnnnn = h (0 ‚â§  < |¬è|). 
Lema 8 [ inseguro implica existe √Ü complemento de √á] Se ¬è √© inseguro, 
ent√£o ‚àÉo ‚àà (Œ£‚àó(¬ö) ‚à™ Œ£)‚àó tal que ok! = ¬è¬ê(U, z). 
Sub-Lema 8.1 [Inversos normais s√£o complementos] Para qualquer par de 
seq√º√™ncias de operadores normais j  e j‚Ä≤ , vale que jj‚Ä≤nnnn = h  implica 
j! = jp. 
 39 
Prova. A prova √© por indu√ß√£o no comprimento de j. 
BI Se j = h, i.e., |j| = 0, ent√£o, por defini√ß√£o, j! = h. Como jp√© normal, 
hjpnnnn = jp =  h.  
PI Para j ‚â† h, suponhamos que seja verdadeiro para a subseq√º√™ncia normal 
ju¬ê,|x|yv; i.e., ju¬ê,|x|yv j‚Ä≤u,|x¬Ω|yv nnnnnnnnnnnnnnnnnnnnnnn = h implica ju¬ê,|x|yv
! = j‚Ä≤¬∞,¬±x¬Ω¬±y¬∂. Como 
jjpnnnnn = h  e j  e jp  s√£o normais, ent√£o j|x|y! = j¬êp . Logo, jjpnnnnn =
ju¬ê,|x|yvj|x|yj¬ê
p ju,|x¬Ω|yv
pnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn = ju¬ê,|x|yv jpu,|x¬Ω|yv nnnnnnnnnnnnnnnnnnnnnnnn = h  e, por hip√≥tese de 
indu√ß√£o, j! = jp. 
Prova do Lema 8: Sendo ¬è  inseguro, temos um op ‚àà (Œ£‚àó(¬ö) ‚à™ Œ£)‚àó  tal que 
op¬è¬´ ‚Ä¶ ¬è¬ênnnnnnnnnnn = h , para algum 0 ‚â§  < |¬è| . Como ¬è ‚Ä¶ ¬è ‚àà Œ£‚àó , podemos ter um 
o ‚àà (Œ£
‚àó(¬ö) ‚à™ Œ£)‚àó tal que o = op¬è ‚Ä¶ ¬è. Assim, considerando o Lema 1 com 
j = h, j = o e j` = ¬è¬ê, podemos escrever op¬è¬´ ‚Ä¶ ¬è¬ênnnnnnnnnnn = op¬è¬´ ‚Ä¶ ¬è¬è¬ênnnnnnnnnnnnnn = ok¬è¬ênnnnn = h. 
Pelo Sub-Lema 8.1, e sabendo que ¬è¬ê √© normal, temos que ok! = ¬è¬ê. 
Prova de B. Sufici√™ncia: Como o protocolo ¬è  √© inseguro, ent√£o, pelo Lema 8, 
‚àÉo ‚àà (Œ£
‚àó(¬ö) ‚à™ Œ£)‚àó tal que ok! = ¬è¬ê. Al√©m disso, como ¬è √© balanceado, ent√£o, pelo 
Lema 6, ok tem a PB com respeito a U e z. A contradi√ß√£o entre esta √∫ltima afirmativa e 
o fato de que ok! = ¬è¬ê, pode ser mostrada considerando-se as duas situa√ß√µes seguintes: 
a. (¬è¬ê) = I~, para algum 0 ‚â§  < |¬è¬ê|: Como ¬è¬ê √© normal e ok! = ¬è¬ê, ok|¬ø¬ª|yy =
W~. E, como ok tem a PB com respeito a z, existe um q (0 ‚â§ q ‚â†  < |ok|), tal que 
oks = I~. Isto implica em (¬è¬ê)|¬ë√Ö|yys = W~. Mas, pela condi√ß√£o 3 da Defini√ß√£o 1, 
W~ ‚àâ ¬è¬ê, o que leva a uma contradi√ß√£o de que ¬è √© um protocolo em cascata, 
conforme a Defini√ß√£o 2. 
b. (¬è¬ê) ‚â† I~, para algum 0 ‚â§  < |¬è¬ê|: Como ¬è¬ê √© normal e n√£o cont√©m um W~, 
ent√£o, todo (¬è¬ê) = IV. Logo, ok|¬ø¬ª|yy = WV, o que contradiz o fato de que ok tem 
a PB com respeito a U. 
Com base nas provas realizadas sobre as tr√™s diferentes formas de ¬è¬ê, em A. 
Necessidade, podemos ilustrar como um advers√°rio ¬ö ‚àà L  √© capaz de obter uma 
mensagem \  da comunica√ß√£o entre os usu√°rios U  e z , utilizando-se do 
 40 
desbalanceamento do protocolo ¬è. Como ¬ö √© capaz de escutar o canal de comunica√ß√£o, ¬ö 
intercepta ¬è¬ê(U, z)\ , objetivando extrair \ . Seja ¬è  ( 0 <  < |¬è| ) um passo de 
protocolo desbalanceado de ¬è. Temos que ¬è(U, ¬ö) (em uma comunica√ß√£o entre U e ¬ö) 
pode ser escrito na forma jpWVjpp, onde jp ‚àà YI¬õ, WV[‚àó e jpp ‚àà YI¬õ[‚àó. Observe que n√£o 
importa se  √© par ou √≠mpar, j√° que o termo ¬è(U, ¬ö) existe em ambos os casos, mudando 
apenas o usu√°rio que inicia a comunica√ß√£o usando ¬è. ¬ö obt√©m \ executando os tr√™s 
tipos de procedimentos a seguir, conforme o operador mais √† esquerda de uma substring de 
¬è¬ê(U, z) seja IV, WV ou I~. Assim, um a um, os operadores de ¬è¬ê(U, z) s√£o invertidos 
at√© que \ esteja dispon√≠vel. Sejam q e  naturais tais que 0 < q ‚â§  < |¬è¬ê|. 
‚Ä¢ ¬è¬êus,v = IV¬è¬êus¬π,v : ¬ö  mant√©m uma comunica√ß√£o com U , enviando mensagens 
quaisquer at√© chegar ao passo  ‚àí 1  do protocolo. Neste passo, ¬ö  envia a U 
√Å¬è¬êus,v\, onde √Å = j
pp!
. No passo , a resposta de U √© ¬è√Å¬è¬êus,v\. Assim, ¬ö 
aplica a este termo √Å = jp
!
, obtendo √Å¬è¬´√Å¬è¬êu√â,vnnnnnnnnnnnnnnn\ = ¬è¬êus¬π,v\, eliminando, ent√£o, 
o operador IV. 
‚Ä¢ ¬è¬êus,v = WV¬è¬êus¬π,v: Neste caso, ¬ö simplesmente aplica o operador IV para obter 
IV¬è¬êu√â,vnnnnnnnnnnn\ = ¬è¬êus¬π,v\. 
‚Ä¢ ¬è¬êus,v = I~¬è¬êus¬π,v: An√°logo ao caso em que ¬è¬êus,v = IV¬è¬êus¬π,v, exceto que a 
comunica√ß√£o acontece entre z e ¬ö. 
Assim, completamos a formaliza√ß√£o anal√≠tica do modelo de seguran√ßa Dolev-Yao 
para protocolos em cascata. 
  
 41 
Cap√≠tulo 5.  
Formaliza√ß√£o do Modelo Dolev-
Yao em PVS 
A formaliza√ß√£o da seguran√ßa do modelo Dolev-Yao, em PVS, est√° dividida em uma 
estrutura hier√°rquica de 9 teorias, conforme a Figura 3. Esta divis√£o simplifica a vis√£o das 
provas e especifica√ß√µes. 
 
Figura 3: Teorias que comp√µem a formaliza√ß√£o do modelo Dolev-Yao. 
Descrevemos, a seguir, as teorias mais importantes da formaliza√ß√£o do modelo 
Dolev-Yao. Alguns lemas utilizados durante as provas ser√£o apenas citados, assim como 
 42 
algumas f√≥rmulas podem ser omitidas dos seq√ºentes para facilitar a compreens√£o. 
Consideraremos apenas os casos principais de uma prova, omitindo, quando conveniente, 
provas de TCCs gerados. Lemas e defini√ß√µes apresentados ser√£o relacionados aos 
mostrados no cap√≠tulo anterior. Nos fragmentos de c√≥digo a seguir, o s√≠mbolo % significa 
um coment√°rio de linha, em PVS. 
5.1 Teoria MonoidCryptOps: mon√≥ides em ‚àó 
Para definir um operador IV  ou WV  ( ‚àÄU ‚àà L ), utilizamos as seguintes 
especifica√ß√µes: 
U : TYPE+ % Non-empty type modeling a user. 
cryptType : TYPE = {decrypt, encrypt} % The type of a crypt operation. 
op : TYPE = [# crTyp : cryptType, user : U #] % Definition of an operator 
                                                            with a crypt type and an user. 
seqOps : TYPE = finite_sequence[op] % A sequence of operators. 
seqOps define um tipo de dados, que √© uma seq√º√™ncia finita contendo elementos do 
tipo op. Este √© um tipo de registro contendo dois elementos: um tipo de operador cryptType 
e um usu√°rio U. Em uma seq√º√™ncia seq, do tipo seqOps, podemos acessar o elemento de 
uma posi√ß√£o 0 ‚â§ i < seq`length, escrevendo seq1(i), e obter uma subseq√º√™ncia com as 
posi√ß√µes de i a j (0 ‚â§ i ‚â§ j < seq`length), atrav√©s de seq^(i,j). 
N√£o √© necess√°rio formalizar a aplica√ß√£o de uma seq√º√™ncia de operadores a uma 
mensagem, j√° que a modelagem n√£o considera os algoritmos criptogr√°ficos utilizados na 
transforma√ß√£o (encripta√ß√£o ou decripta√ß√£o) de uma mensagem, mas somente o protocolo. 
Dados dois operadores op1 e op2, do tipo op, define-se o predicado 
areopcomplements?, que retorna um valor booleano verdadeiro, caso os dois operadores 
sejam complementares. Os predicados sameUsOp? e oppOp? retornam valores verdadeiros 
caso, respectivamente, os usu√°rios de op1 e op2 s√£o iguais e os operadores de op1 e op2 s√£o 
complementares. A partir destas especifica√ß√µes, podemos definir o predicado 
areseqcomplements?, que verifica se duas seq√º√™ncias seq1 e seq2 s√£o complementares. 
oppOp?(op1, op2 : op) : bool = crTyp(op1)/=crTyp(op2) 
 
sameUsOp?(op1, op2 : op) : bool = user(op1)=user(op2) 
 
areopcomplements?(op1: op, op2: op) : bool =  
                    sameUsOp?(op1, op2) AND oppOp?(op1, op2) 
 
 
 43 
% Checks if two sequences are complements, considering they're symmetric,  
% that is, an op1 in seq1(i) has a complement op2 in seq2(seq2`length - 1 - i),  
% where seq1 and seq2 have the same length. For example, the sequences  
% Ey,Dy,Ex and Dx,Dx,Ex are complements when normalized but they are not  
% symmetric. 
areseqcomplements?(seq1 : seqOps, seq2 : seqOps) : bool = 
  IF seq1`length /= seq2`length THEN FALSE 
  ELSE LET lth = seq1`length - 1 IN 
    FORALL(i : nat | i < seq1`length) : 
      areopcomplements?(seq1(i),seq2(lth - i)) 
  ENDIF 
A verifica√ß√£o de que uma seq√º√™ncia seq √© normal, √© feita pelo predicado 
normalseq?, que avalia se cada par de elementos de seq n√£o √© complementar, retornando 
verdadeiro neste caso. 
% Checks if a sequence is normal, that is, its size is less than 2 or  
% there is no two complementary operators in the sequence. 
normalseq?(seq : seqOps) : bool =  
  IF seq`length < 2 THEN TRUE 
  ELSE FORALL (i : posnat | i < seq`length) : 
    NOT ( areopcomplements?(seq(i-1),seq(i)) ) 
ENDIF 
A partir da defini√ß√£o acima, podemos definir tipos de dados que representem 
seq√º√™ncias normais (normalseq) ou redut√≠veis (reduzibleseq), como a seguir. Os tipos s√£o 
definidos a partir dos predicados que modelam a propriedade correspondente. 
normalseq: TYPE = (normalseq?) % A type describing a normal sequence. 
 
% A sequence is reduzible when it is not normal. 
reduzibleseq?(seq : seqOps): bool = NOT normalseq?(seq) 
 
reduzibleseq: TYPE = (reduzibleseq?) % A reduzible sequence. 
Para normalizar uma seq√º√™ncia redut√≠vel seq, primeiramente definimos uma fun√ß√£o 
recursiva first_cancelable, que retorna a posi√ß√£o do primeiro par normaliz√°vel de seq. O 
argumento desta fun√ß√£o √© uma seq√º√™ncia de tipo reduzibleseq, definida acima. A 
utiliza√ß√£o deste tipo de dados, definido a partir de um predicado, mostra que 
first_cancelable √© definida para seq√º√™ncias seqOps que satisfazem o predicado 
reduzibleseq?. 
% A recursive function that finds the first cancelable position 
% of a pair of complementary operators. 
first_cancelable(seq : reduzibleseq) : RECURSIVE nat =  
  IF areopcomplements?(seq(0),seq(1)) THEN 0 
    ELSE 1 + first_cancelable(^(seq,(1,seq`length-1))) 
  ENDIF 
MEASURE seq`length-1 
Com esta defini√ß√£o, podemos especificar a fun√ß√£o de normaliza√ß√£o normalizeseq de uma 
seq√º√™ncia seq. Esta fun√ß√£o, na primeira cl√°usula IF, verifica se a seq√º√™ncia √© normal; neste 
 44 
caso, a normaliza√ß√£o de seq √© a pr√≥pria seq√º√™ncia seq. Sen√£o, um par de operadores 
complementares √© eliminado de seq, na posi√ß√£o determinada pela aplica√ß√£o de 
first_cancelable. 
% Definition of a recursive function that normalizes a sequence. 
normalizeseq(seq : seqOps) : RECURSIVE seqOps =  
IF normalseq?(seq) THEN seq 
ELSE LET (firstCancPos : nat) = first_cancelable(seq) IN 
  IF firstCancPos=0 THEN normalizeseq(seq^(2,seq`length-1)) ELSE 
    normalizeseq(seq^(0,firstCancPos-1) o seq^(firstCancPos+2,seq`length-1)) 
  ENDIF 
ENDIF 
MEASURE seq`length 
5.1.1 Lema geral de normaliza√ß√£o 
Com o lema normalize_general, a seguir, foi poss√≠vel validar as estruturas de dados 
e fun√ß√µes utilizadas para representar os mon√≥ides em Œ£‚àó. Este lema √© a base para a prova 
do Lema 1 em PVS, e mostra uma propriedade b√°sica, mas n√£o trivial, dos mon√≥ides em Œ£‚àó. 
normalize_general : LEMMA FORALL(seq : seqOps, i : nat | i < seq`length - 1) : 
    areopcomplements?(seq(i),seq(i+1)) => 
    normalizeseq(seq) = normalizeseq(IF i = 0 THEN empty_seq  
                                  ELSE seq^(0,i-1) ENDIF o seq^(i+2,seq`length-1)) 
Este lema pode ser analiticamente escrito como j¬´j¬´¬πnnnnnnnn ‚áí jk = ju¬ê,¬´yvju¬´¬π,|x|yvnnnnnnnnnnnnnnnnnnnnn, ‚àÄj ‚àà Œ£‚àó 
e 0 ‚â§  < |j| ‚àí 1. A prova de normalize_general √© por indu√ß√£o no comprimento de seq. O 
objetivo inicial √© o seguinte: 
  |------- 
{1}   FORALL (seq: seqOps, i: nat | i < seq`length - 1): 
        areopcomplements?(seq`seq(i), seq`seq(i + 1)) 
         => 
         normalizeseq(seq) = 
          normalizeseq(IF i = 0 THEN empty_seq ELSE seq ^ (0, i - 1) ENDIF 
                        o seq ^ (i + 2, seq`length - 1)) 
‚Ä¢ (measure-induct+ "seq`length" "seq"): Indu√ß√£o no comprimento de seq, gerando um 
seq√ºente cuja premissa {-1} representar√°, ap√≥s devida instancia√ß√£o, a hip√≥tese de 
indu√ß√£o. Mostraremos, no passo de indu√ß√£o, que o conseq√ºente {1} √© verdadeiro. 
 
 
 
 
 
 
 
 
 45 
{-1} FORALL (y: seqOps): 
       FORALL (i: nat | i < y`length - 1): 
        y`length < seq`length => areopcomplements?(y`seq(i), y`seq(i + 1)) 
            => 
          normalizeseq(y) = 
            normalizeseq(IF i = 0 THEN empty_seq ELSE y ^ (0, i - 1) ENDIF 
                           o y ^ (i + 2, y`length - 1)) 
  |------- 
{1}   FORALL (i: nat | i < seq`length - 1): 
        areopcomplements?(seq`seq(i), seq`seq(i + 1)) 
         => 
         normalizeseq(seq) = 
          normalizeseq(IF i = 0 THEN empty_seq ELSE seq ^ (0, i - 1) ENDIF 
                         o seq ^ (i + 2, seq`length - 1)) 
‚Ä¢ (skeep): Skolemiza√ß√£o de i no sequente {1}. Abaixo, a hip√≥tese de indu√ß√£o em {-1}, 
do seq√ºente anterior, foi omitida. 
{-2}  areopcomplements?(seq`seq(i), 
                        seq`seq(i + 1)) 
  |------- 
{1}   normalizeseq(seq) = 
       normalizeseq(IF i = 0 THEN empty_seq ELSE seq ^ (0, i - 1) ENDIF o 
                     seq ^ (i + 2, seq`length - 1)) 
Considerando a primeira posi√ß√£o normaliz√°vel de seq, e as posi√ß√µes i e i + 1 de 
seq, onde existem operadores complementares, dividimos a prova em tr√™s casos, 
apresentados a seguir. Referenciaremos o termo first_cancelable(seq), a primeira posi√ß√£o 
normaliz√°vel, como fc. 
1 fc = i. A prova para este caso √© direta, bastando aplicar o lema first_normalize, 
onde provamos que fc = i ‚Üí j¬ª = j¬∞0,i‚àí1¬∂j¬∞i+2,¬±j¬±‚àí1¬∂nnnnnnnnnnnnnnnnnnnnnnnnnnn , ‚àÄj ‚àà Œ£‚àó . A prova para 
first_normalize segue, facilmente, das defini√ß√µes de first_normalize e 
normalizeseq. 
2 fc > i. Por contradi√ß√£o, pode-se verificar que n√£o √© poss√≠vel existir uma posi√ß√£o i 
anterior a uma posi√ß√£o fc.  
3 fc < i. Parte principal da prova, onde verificaremos que ju¬ê,fcyvjufc¬π,|x|yvnnnnnnnnnnnnnnnnnnnnnnnnn =ju¬ê,iyvjui¬π,|x|yvnnnnnnnnnnnnnnnnnnnnnn, ‚àÄj ‚àà Œ£‚àó. Dividiremos esta prova em dois subcasos, fc < i - 1 e 
fc = i - 1. 
As tr√™s situa√ß√µes acima foram provadas, em PVS, conforme mostrado nos casos abaixo. 
Caso 1: 
‚Ä¢ (case "fc = i") 
[-1]  fc = i 
  |------- 
[1]   normalizeseq(seq) = 
       normalizeseq(IF i = 0 THEN empty_seq ELSE seq ^ (0, i - 1) ENDIF o 
                     seq ^ (i + 2, seq`length - 1)) 
‚Ä¢ (lemma first_normalize ("seq" "seq" "i" "i")): Com este comando, invocamos e 
instanciamos o lema first_normalize, obtendo o antecedente {-1}, abaixo. 
 46 
{-1}  fc = i => 
       normalizeseq(seq) = 
        normalizeseq(IF i = 0 THEN empty_seq ELSE seq ^ (0, i - 1) ENDIF o 
                      seq ^ (i + 2, seq`length - 1)) 
Com um comando (assert) conclu√≠mos este caso da prova. 
Fim do caso 1. 
Caso 2: 
‚Ä¢ (case "fc > i") 
[-1]  fc > i 
[-2]  areopcomplements?(seq`seq(i), seq`seq(i + 1)) 
  |------- 
‚Ä¢ (lemma characterization_f_canc): Invocando este lema e instanciando-o 
adequadamente, temos que ju¬ê,ivnnnnnn ‚àß _ji = ji¬πnnnnnnb ‚Üí fc = i, o que √© mostrado em {-1}, a 
seguir. 
{-1}  normalseq?(seq ^ (0, i)) AND 
       areopcomplements?(seq`seq(i), seq`seq(i + 1)) 
       => fc = i 
[-2]  fc > i 
[-3]  areopcomplements?(seq`seq(i), seq`seq(i + 1)) 
  |------- 
‚Ä¢ (assert): Simplificando o seq√ºente anterior, temos: 
[-1]  fc > i 
[-2]  areopcomplements?(seq`seq(i), seq`seq(1 + i)) 
  |------- 
[1]   normalseq?(seq ^ (0, i)) 
A express√£o em [1] √© verdadeira, considerando-se [-1]. Conclui-se, ent√£o, este caso 
utilizando o lema first_canc_greater_imp_normal que prova o seguinte: 
fc ‚â• i ‚Üí j¬∞0,i¬∂ √© normal. 
Fim do caso 2. 
Caso 3: 
Caso 3.1: fc < i - 1 
Neste caso, obtemos um passo da prova onde os termos mais importantes s√£o os 
abaixo apresentados. [2] √© o termo que provaremos ser verdadeiro; em [-4] temos a 
hip√≥tese de indu√ß√£o n√£o instanciada. 
 
 
 
 
 47 
{-1}  fc < i - 1 
[-4]  FORALL (y: seqOps): 
        FORALL (i: nat | i < y`length - 1): 
          y`length < seq`length => areopcomplements?(y`seq(i), y`seq(1 + i)) 
           => 
            normalizeseq(y) = 
             normalizeseq(IF i = 0 THEN empty_seq ELSE y ^ (0, i - 1) ENDIF 
                            o y ^ (2 + i, y`length - 1)) 
[-5]  areopcomplements?(seq`seq(i), seq`seq(1 + i)) 
  |------- 
[1]   seq`length <= 2 
[2]   normalizeseq(IF fc = 0 THEN empty_seq ELSE seq ^ (0, fc - 1) ENDIF o 
                      seq ^ (2 + fc, seq`length - 1)) 
       = normalizeseq(seq ^ (0, i - 1) o seq ^ (2 + i, seq`length - 1)) 
Em [2] √© necess√°rio considerar os casos onde fc = 0 e fc > 0. Mostraremos apenas 
o segundo caso, cuja f√≥rmula em [2]: 
[2]   normalizeseq(seq ^ (0, fc - 1) o seq ^ (2 + fc, seq`length - 1)) 
       = normalizeseq(seq ^ (0, i - 1) o seq ^ (2 + i, seq`length - 1)) 
‚Ä¢ (inst -4 "seq ^ (0, fc - 1) o seq ^ (2 + fc, seq`length - 1)" "i - 2"): 
Instanciando a hip√≥tese de indu√ß√£o e realizando opera√ß√µes de reescrita adequadas, 
obtemos [2] na seguinte forma: 
[2]   normalizeseq(seq1 ^ (0, i - 3) o seq1 ^ (i, seq1`length - 1)) 
     = normalizeseq(seq2 ^ (0, fc - 1) o seq2 ^ (2 + fc, seq2`length - 1)), onde 
seq1 = (seq ^ (0, fc - 1) o seq ^ (2 + fc, seq`length - 1)), e 
seq2 = (seq ^ (0, i - 1) o seq ^ (2 + i, seq`length - 1)). 
Provando-se que os argumentos das fun√ß√µes normalizeseq acima s√£o iguais, temos 
que [2] √© verdadeiro. 
Fim do caso 3.1. 
Caso 3.2: fc = i - 1 
De modo semelhante ao do caso anterior, utiliza-se a hip√≥tese de indu√ß√£o, obtendo 
[-1]  fc = i - 1 
[-3]  areopcomplements?(seq`seq(i), seq`seq(1 + i)) 
  |------- 
[1]   seq`length <= 2 
[2]   normalizeseq(IF fc = 0 THEN empty_seq ELSE seq ^ (0, fc - 1) ENDIF o 
                    seq ^ (2 + fc, seq`length - 1)) 
         = normalizeseq(seq ^ (0, i - 1) o seq ^ (2 + i, seq`length - 1)) 
Para fc = 0, a prova √© facilmente finalizada. Considerando somente o caso em que fc 
> 0, temos, em [2], 
normalizeseq(seq ^ (0, i - 2) o seq ^ (1 + i, seq`length - 1)) = 
    normalizeseq(seq ^ (0, i - 1) o seq ^ (2 + i, seq`length - 1)), 
o que √© verdadeiro, dados [-1] e [-3]. 
 48 
Fim do caso 3.2. 
Fim do caso 3. 
Q.E.D. 
A Figura 4, a seguir, mostra a √°rvore de prova do lema normalize_general. Os n√≥s-
pai de cada caso descrito na prova acima est√£o indicados na figura. A prova conta com 193 
comandos. 
 
Figura 4: √Årvore de prova do lema normalize_general. 
5.1.2 Verifica√ß√£o do Lema 1 
O Lema 1, apresentado no cap√≠tulo Cap√≠tulo 4, foi especificado como um corol√°rio 
do lema normalize_general, conforme mostrado abaixo. 
normalize_general_seq : COROLLARY FORALL (seq1, seq2, seq3 : seqOps) : 
      normalizeseq(seq1 o seq2 o seq3) =  
        normalizeseq(seq1 o normalizeseq(seq2) o seq3) 
A prova √© por indu√ß√£o no comprimento de seq2, com o seguinte objetivo: 
 
 
 
 
 49 
  |------- 
[1]   FORALL (seq1, seq2, seq3: seqOps): 
        normalizeseq(seq1 o seq2 o seq3) = 
         normalizeseq(seq1 o normalizeseq(seq2) o seq3) 
‚Ä¢ (measure-induct+ "seq2`length" "seq2"): A indu√ß√£o sobre seq2`length resulta no 
seq√ºente a seguir. 
{-1}  FORALL (y: seqOps): 
        FORALL (seq1, seq3: seqOps): 
          y`length < seq2`length => 
           normalizeseq(seq1 o y o seq3) = 
            normalizeseq(seq1 o normalizeseq(y) o seq3) 
  |------- 
{1}   FORALL (seq1, seq3: seqOps): 
        normalizeseq(seq1 o seq2 o seq3) = 
         normalizeseq(seq1 o normalizeseq(seq2) o seq3) 
‚Ä¢ (skeep): Ao skolemizar {1}, obtemos no conseq√ºente: 
{1}   normalizeseq(seq1 o seq2 o seq3) = 
       normalizeseq(seq1 o normalizeseq(seq2) o seq3) 
Para o caso onde seq2 √© normal, temos que normalizeseq(seq2) = seq2, e a f√≥rmula 
{1} √© trivialmente verdadeira. Caso contr√°rio, considerando a defini√ß√£o de normalseq? e 
com 0 < i < seq2`length podemos obter a f√≥rmula abaixo como um antecedente. 
{-1}  (areopcomplements?(seq2`seq(i - 1), seq2`seq(i))) 
‚Ä¢  (lemma normalize_general ("seq" "seq1 o seq2 o seq3" "i" "i-1+seq1`length")): 
Utilizando o lema normalize_general, obtemos em {-1}: 
{-1}  areopcomplements?((seq1 o seq2 o seq3)`seq(seq1`length - 1 + i), 
                        (seq1 o seq2 o seq3)`seq(seq1`length + i)) 
       => 
       normalizeseq(seq1 o seq2 o seq3) = 
        normalizeseq((seq1 o seq2 o seq3) ^ (0, seq1`length-2+i) o 
          (seq1 o seq2 o seq3)^(1+seq1`length+i, (seq1 o seq2 o seq3)`length-1)) 
[-2]  (areopcomplements?(seq2`seq(i - 1), seq2`seq(i))) 
  |------- 
[3]   normalizeseq(seq1 o seq2 o seq3) = 
       normalizeseq(seq1 o normalizeseq(seq2) o seq3) 
Temos que (seq1 o seq2 o seq3)`seq(seq1`length - 1 + i) = seq2`seq(i - 1) e 
(seq1 o seq2 o seq3)`seq(seq1`length + i) = seq2`seq(i). Assim, considerando [-2] 
obt√©m-se {-1} na seguinte forma: 
{-1}  normalizeseq(seq1 o seq2 o seq3) = 
         normalizeseq((seq1 o seq2 o seq3) ^ (0, seq1`length-2+i) o 
           (seq1 o seq2 o seq3)^(1+seq1`length+i, (seq1 o seq2 o seq3)`length-1)) 
 50 
Substitui-se, ent√£o, esta √∫ltima f√≥rmula em [3] do seq√ºente anterior e, ap√≥s 
considerar um ramo particular para o caso i <= 1, teremos o caso principal com i > 1. 
Assim, vale 
(seq1 o seq2 o seq3) ^ (0, seq1`length - 2 + i) = seq1 o seq2 ^ (0, i - 2), e 
(seq1 o seq2 o seq3) ^ (1 + seq1`length + i, (seq1 o seq2 o seq3)`length - 1) =  
        seq2^(i+1,seq2`length-1) o seq3 
E obtemos: 
[-3]  (areopcomplements?(seq2`seq(i - 1), seq2`seq(i))) 
  |------- 
{5}  normalizeseq(seq1 o seq2^(0, i-2) o (seq2^(i+1, seq2`length-1) o seq3)) 
       = normalizeseq(seq1 o normalizeseq(seq2) o seq3) 
Temos omitido, at√© este ponto da prova, a hip√≥tese de indu√ß√£o, ainda n√£o 
instanciada. 
‚Ä¢ (inst -4 "seq2 ^ (0, i - 2) o seq2 ^ (i + 1, seq2`length - 1)" "seq1" "seq3"): 
Instancia-se a hip√≥tese de indu√ß√£o com a seq√º√™ncia seq2, sem os operadores 
complementares das posi√ß√µes i e i + 1, obtendo 
[-3]  (areopcomplements?(seq2`seq(i - 1), seq2`seq(i))) 
[-4]  normalizeseq(seq1 o seq2^(0, i-2) o seq2^(1+i, seq2`length-1) o seq3) = 
       normalizeseq(seq1 o normalizeseq(seq2 ^ (0, i - 2) o 
                                      seq2 ^ (i + 1, seq2`length - 1)) o seq3) 
  |------- 
{5}   normalizeseq(seq1 o seq2^(0, i-2) o seq2^(1+i, seq2`length-1) o seq3) 
       = normalizeseq(seq1 o normalizeseq(seq2) o seq3) 
Reescrevendo {5} com [-4], obt√©m-se a f√≥rmula 
{5}  normalizeseq(seq1 o normalizeseq(seq2 ^ (0, i - 2) o 
                              seq2 ^ (i + 1, seq2`length - 1)) o seq3) = 
        normalizeseq(seq1 o normalizeseq(seq2) o seq3) 
Considerando o antecedente [-3] do seq√ºente anterior, e pelo lema 
normalize_general, sabemos que  
normalizeseq(seq2) = normalizeseq(seq2^(0, i-2) o seq2^(i+1, seq2`length-1)) 
Deste modo, [5] √© verdadeiro e a prova est√° completa. 
 
 
 
 
 
 51 
5.2 Teoria CascadeProtocols: protocolo em cascata 
5.2.1 Passo de protocolo 
Na Defini√ß√£o 1, mostramos a fun√ß√£o que representa um passo de protocolo: ¬Ä¬Å: L √ó L ‚Üí Œ£‚àó. Em PVS, esta fun√ß√£o √© especificada como alphabeta : TYPE = [[U, U] -
> seqOps]. Para representar um passo de protocolo, primeiramente, define-se o predicado 
abUsers?, que modela a condi√ß√£o 4 da Defini√ß√£o 1. 
abUsers?(ab : alphabeta, x, y : U) : bool = % condi√ß√£o 4 da defini√ß√£o 1 
  FORALL(u, v : U) :  
  ab(x,y)`length = ab(u,v)`length AND        % condi√ß√£o 4.1 
    FORALL(i : nat | i < ab(x,y)`length) :  % condi√ß√£o 4.2 
      (user(ab(x,y)(i)) = x OR user(ab(x,y)(i)) = y) AND 
      (crTyp(ab(x,y)(i)) = crTyp(ab(u,v)(i))) AND 
      (user(ab(x,y)(i)) = x IFF user(ab(u,v)(i)) = u) AND 
      (user(ab(x,y)(i)) = y IFF user(ab(u,v)(i)) = v) 
Uma vez definido abUsers?, temos o predicado alphabeta_welldef?, que retorna verdadeiro 
caso um alphabeta esteja bem definido para dois usu√°rios quaisquer, segundo condi√ß√µes da 
Defini√ß√£o 1. 
alphabeta_welldef?(ab : alphabeta, x, y : U) : bool =  
  ab(x,y)`length > 0 AND                          % condi√ß√£o 1 
  normalseq?(ab(x,y)) AND                         % condi√ß√£o 2 
  ( FORALL(j : nat | j < ab(x,y)`length) :     % condi√ß√£o 3 
       member(ab(x,y)(j),validSetxy(x,y)) ) AND 
  abUsers?(ab, x, y)                               %condi√ß√£o 4 
5.2.2 Protocolo em cascata 
Um protocolo em cascata √© definido como uma seq√º√™ncia finita de elementos 
alphabeta, isto √©, protocol : TYPE = finite_sequence[alphabeta]. Definimos, ent√£o, o 
predicado protocol_welldef? que, dado um protocolo em cascata do tipo protocol, retorna 
verdadeiro caso este protocolo seja bem-definido, ou seja, √© tal como mostrado pela 
Defini√ß√£o 2. Al√©m disso, definimos tamb√©m um tipo de dados welldefined_protocol, 
baseado no predicado protocol_welldef?. 
protocol_welldef?(prot : protocol) : bool =  
  prot`length > 0 AND 
  FORALL(x : U, y : U | x /= y) : FORALL(i : nat | i < prot`length) :  
    IF even?(i) THEN alphabeta_welldef?(prot(i),x,y)  
    ELSE alphabeta_welldef?(prot(i),y,x) % odd?(i) 
    ENDIF 
 
 52 
welldefined_protocol: TYPE = (protocol_welldef?) 
Em algumas defini√ß√µes ou lemas, um protocolo em cascata deve ser tratado como 
uma seq√º√™ncia de operadores criptogr√°ficos, para que seja poss√≠vel aplicar as 
especifica√ß√µes mostradas na se√ß√£o 5.1. Assim, definimos a fun√ß√£o recursiva extract_eN, 
que lineariza os passos de um protocolo em cascata prot, de modo que se forme uma √∫nica 
seq√º√™ncia de operadores criptogr√°ficos. 
extract_eN(prot : protocol, i : below[prot`length], x, y : U) :  
  RECURSIVE seqOps = 
    IF i = 0 THEN prot(0)(x,y) 
      ELSE (prot(i)(x,y) o extract_eN(prot, i-1, x, y)) 
    ENDIF 
  MEASURE i 
5.3 Teoria SecurityDefinitions: Linguagem do Advers√°rio 
e Defini√ß√µes de Seguran√ßa 
Nesta se√ß√£o, especificamos as estruturas e fun√ß√µes que definem a linguagem 
admiss√≠vel do advers√°rio (Defini√ß√£o 3), propriedade de balanceamento (Defini√ß√£o 4), 
protocolo balanceado (Defini√ß√£o 5), condi√ß√£o inicial de seguran√ßa (Defini√ß√£o 6) e a no√ß√£o 
de protocolo seguro (Defini√ß√£o 7). 
5.3.1 Especifica√ß√£o da Defini√ß√£o 3: Linguagem admiss√≠vel do 
advers√°rio 
O tipo de dados utilizado para representar os termos constru√≠dos por um advers√°rio 
√© gammaT : TYPE = finite_sequence[seqOps]. A linguagem admiss√≠vel do advers√°rio √© 
definida no predicado gamma_welldef?, que retorna verdadeiro caso um termo do tipo 
gammaT, constru√≠do pelo advers√°rio z, esteja em (Œ£(¬ö)‚àó ‚à™ Œ£)‚àó. A defini√ß√£o da linguagem Œ£(¬ö)‚àó √© dada pela fun√ß√£o sigma1, que retorna o conjunto de operadores dispon√≠veis ao 
usu√°rio z. Em wellDefInSigma1, temos uma fun√ß√£o que retorna se uma seq√º√™ncia de 
operadores seq est√° na linguagem Œ£(¬ö)‚àó. A linguagem Œ£ √© especificada por sigma2_3, 
que retorna, a partir de um protocolo em cascata bem definido prot, um conjunto com 
termos de prot acess√≠veis a z. 
sigma1(z : U) : setof[op] = {op1 : op | crTyp(op1) = encrypt OR user(op1) = z} 
 53 
 
sigma2_3(prot : protocol) : setof[seqOps] =  
  {ab : seqOps | EXISTS(i : posnat | i < prot`length) :  
                    EXISTS(a : U, b : U | a /= b) : ab = prot(i)(a,b) } 
 
wellDefInSigma1(seq : seqOps, z : U) : bool = FORALL(i : nat | i < seq`length) : 
                                                       member(seq(i), sigma1(z)) 
 
gamma_welldef?(prot : welldefined_protocol, gamma : gammaT, z : U) :  
  bool = FORALL(i : nat | i < gamma`length) : 
    ( member(gamma(i),sigma2_3(prot)) OR 
      wellDefInSigma1(gamma(i),z) ) 
Dada uma estrutura gammaT, a fun√ß√£o extract_gamma, a seguir, lineariza essa 
estrutura, retornando uma seq√º√™ncia de operadores. 
extract_gamma(gamma : gammaT) :  
   RECURSIVE seqOps = 
     IF gamma`length = 0 THEN empty_seq  
     ELSE (gamma(0) o extract_gamma(gamma^(1,gamma`length-1))) 
     ENDIF 
   MEASURE gamma`length 
5.3.2 Especifica√ß√£o da Defini√ß√£o 4: PB 
Sejam dois usu√°rios distintos x e y trocando uma estrutura alpbet, do tipo 
alphabeta. A PB para alpbet foi especificada na forma do predicado balanced_wrt?, que 
retorna verdadeiro quando alpbet tem a PB com respeito a x ou y. Para se afirmar que um 
operador de alpbet √©, por exemplo, um W¬õ, utiliza-se a express√£o (crTyp(alpbet(x,y)(i)) 
= decrypt AND user(alpbet(x,y)(i)) = z), ou seja, verifica-se se o tipo de operador de 
alpbet(x,y)(i) √© decrypt e o usu√°rio √© z. Apesar de a Defini√ß√£o 4 mostrar uma defini√ß√£o 
gen√©rica para a PB, √© suficiente defini-la em termos de estruturas alphabeta, j√° que 
estaremos tratando sempre de protocolos em cascata em nossa especifica√ß√£o. 
balanced_wrt?(alpbet : alphabeta, x : U, y : U | x/=y,  z : U | z=x OR z=y) : 
  boolean =  
    ( EXISTS (i : nat | i < alpbet(x,y)`length) :  
      ( crTyp(alpbet(x,y)(i)) = decrypt AND user(alpbet(x,y)(i)) = z)) 
        =>  
    ( EXISTS (j : nat | j < alpbet(x,y)`length) :  
      ( crTyp(alpbet(x,y)(j)) = encrypt AND user(alpbet(x,y)(j)) = z)) 
5.3.3 Especifica√ß√£o da Defini√ß√£o 5: Protocolo balanceado 
Um protocolo bem definido √© balanceado sempre que cada termo alphabeta do 
protocolo possuir a PB com respeito ao usu√°rio que construiu esse termo. Se um alphabeta 
est√° em uma posi√ß√£o i par (even?(i)) da seq√º√™ncia do protocolo, ent√£o o balanceamento 
 54 
deve acontecer com respeito a x, ou seja, balanced_wrt?(prot(i),x,y,x). Analogamente, 
para o caso em que i √© √≠mpar. 
balanced_cascade_protocol?(prot : welldefined_protocol) : boolean = 
  FORALL(x : U ,y : U | x /= y, i : posnat | i < prot`length) :  
    IF even?(i) THEN balanced_wrt?(prot(i),x,y,x) 
    ELSE balanced_wrt?(prot(i),y,x,y) 
    ENDIF 
5.3.4 Especifica√ß√£o da Defini√ß√£o 6: Condi√ß√£o inicial de seguran√ßa 
Dados um protocolo em cascata em definido prot e dois usu√°rios x e y, definimos a 
condi√ß√£o inicial de seguran√ßa como o predicado alpha0ContainsE?, que retorna verdadeiro 
caso exista um operador com tipo encrypt em prot(0). 
alpha0ContainsE?(prot : welldefined_protocol, x : U, y : U) : bool =  
  EXISTS(i : nat | i < prot(0)(x,y)`length) : member(prot(0)(x,y)(i), 
                         defineopset(encrypt, {us : U | us=x OR us=y})) 
Assim, a condi√ß√£o inicial de seguran√ßa √© satisfeita quando existir um i menor que o 
comprimento de prot(0), tal que o operador em prot(0)(x,y)(i) perten√ßa ao conjunto 
definido por defineopset. Esta fun√ß√£o retorna um conjunto de operadores de um tipo 
espec√≠fico para cada usu√°rio de um conjunto de usu√°rios. Neste caso, defineopset retorna o 
conjunto }IV , I~. 
5.3.5 Especifica√ß√£o da Defini√ß√£o 7: Protocolo seguro 
Definimos os conceitos de protocolo seguro e inseguro, conforme abaixo. As 
fun√ß√µes extract_gamma e extract_eN foram devidamente utilizadas para gerarem 
seq√º√™ncias de operadores que, ap√≥s concatenadas, s√£o normalizadas e comparadas com a 
seq√º√™ncia vazia empty_seq, para determinar se o protocolo em cascata bem definido prot √© 
ou n√£o seguro. 
secure_protocol?(prot : welldefined_protocol, x : U, y : U | x /= y, z : U) :  
  bool =  
    FORALL (gamma : gammaT | gamma_welldef?(prot, gamma, z),  
              i : nat | i < prot`length) : 
    (normalizeseq(extract_gamma(gamma) o extract_eN(prot, i, x, y)) 
        /= empty_seq) 
insecure_protocol?(prot : welldefined_protocol, x : U, y : U | x /= y, z : U) : 
  bool = 
    EXISTS (gamma : gammaT | gamma_welldef?(prot,gamma,z), 
             i : nat | i < prot`length) : 
      normalizeseq(extract_gamma(gamma) o extract_eN(prot,i,x,y)) = empty_seq   
 55 
O lema a seguir estabelece que efetivamente a nega√ß√£o do predicado 
secure_protocol? √© o predicado insecure_protocol?, mas n√£o mostraremos aqui a prova. 
secure_eq_not_insecure_prot : LEMMA 
  FORALL(prot : welldefined_protocol, x : U, y : U | x /= y, z : U) : 
    secure_protocol?(prot,x,y,z) IFF NOT insecure_protocol?(prot,x,y,z) 
Para a seguran√ßa de protocolos, mostramos a especifica√ß√£o de dois predicados que 
definem os conceitos logicamente opostos de seguran√ßa e inseguran√ßa. Al√©m disso, 
provamos um lema que estabelece a rela√ß√£o entre estes predicados. A mesma id√©ia foi 
aplicada √†s defini√ß√µes da PB e de protocolo balanceado, por√©m, omitimos aqui os lemas de 
relacionamento entre os pares correspondentes destas defini√ß√µes. 
5.4 Teoria SecurityNecessity: Prova da necessidade do 
Teorema 1 
Conforme descrito no cap√≠tulo Cap√≠tulo 4, se√ß√£o A. Necessidade, a prova da 
necessidade para o Teorema 1 consiste em demonstrar a contra-rec√≠proca de: se um 
protocolo bem definido √© seguro, ent√£o valem as propriedades (i) e (ii). Para esta prova, 
expressaremos primeiramente os lemas fundamentais mais importantes utilizados na prova 
final da necessidade. Em alguns casos, lemas ser√£o descritos apenas com rela√ß√£o a suas 
funcionalidades em uma parte de qualquer prova. 
Na se√ß√£o 5.4.1, a seguir, provaremos o lema secProt_imp_alpha0ContainsE, que 
corresponde √† prova mostrada em A. Necessidade-I. E, na se√ß√£o 5.4.2, provaremos o lema 
secure_impl_balanced, correspondente √† prova A. Necessidade-II. 
5.4.1 Verifica√ß√£o: Protocolo em cascata  seguro ‚Üí Condi√ß√£o inicial 
de seguran√ßa. 
O lema secProt_imp_alpha0ContainsE √© enunciado abaixo. 
secProt_imp_alpha0ContainsE : LEMMA FORALL (prot : welldefined_protocol, 
                                               x : U, y : U | x /= y, z : U) : 
  secure_protocol?(prot, x, y, z) => alpha0ContainsE?(prot, x, y) 
 56 
A seguir, temos o objetivo a ser provado por contra-rec√≠proca. 
  |------- 
[1]   FORALL (prot: welldefined_protocol, x: U, y: U | x /= y, z: U): 
        secure_protocol?(prot, x, y, z) => alpha0ContainsE?(prot, x, y)  
‚Ä¢ (skeep): Skolemizando [1] e expandindo a defini√ß√£o de secure_protocol?:  
{-1}  FORALL (gamma: gammaT | gamma_welldef?(prot, gamma, z), 
              i: nat | i < prot`length): 
        (normalizeseq(extract_gamma(gamma) o extract_eN(prot, i, x, y)) /= 
          empty_seq) 
  |------- 
[1]   alpha0ContainsE?(prot, x, y)  
‚Ä¢ (inst -1 "defgammawithcomplementseq(prot`seq(0)(x, y))" "0"): Neste comando, a 
fun√ß√£o defgammawithcomplementseq contr√≥i um gammaT com uma √∫nica seq√º√™ncia de 
operadores, que √© o complemento do primeiro passo de protocolo de prot. Esta 
instancia√ß√£o gera dois ramos principais, I e II, a seguir. Chamaremos de gamComp, o 
termo defgammawithcomplementseq(prot`seq(0)(x, y)). 
I. {-2}  normalizeseq(extract_gamma(gamComp) o prot`seq(0)(x, y)) 
        /= empty_seq 
  |------- 
II. |------- 
{1}   gamma_welldef?(prot, gamComp, z) 
[2]   alpha0ContainsE?(prot, x, y) 
‚Ä¢ Em I, temos que a f√≥rmula {-2} √© falsa, pois a normaliza√ß√£o mostrada resulta na 
seq√º√™ncia vazia, pois extract_gamma(gamComp) = prot`seq(0)(x, y)nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn. 
Resta provar o seq√ºente em II, cuja prova √© dada a seguir. 
‚Ä¢ Em II, a nega√ß√£o l√≥gica de alpha0ContainsE?, que aparece na f√≥rmula [2], √© o 
predicado Nalpha0ContainsE?. O lema alpha0FunctionsEq prova a equival√™ncia 
Nalpha0ContainsE?‚ÜîNOT alpha0ContainsE?. Ent√£o, considerando este lema temos: 
[-1]  Nalpha0ContainsE?(prot, x, y) 
  |------- 
{1}   gamma_welldef?(prot, gamComp, z) 
Conforme podemos ver no seq√ºente acima, devemos demonstrar que gamComp √© bem 
definido, dada a n√£o exist√™ncia de operadores do tipo encrypt em prot`seq(0)(x, y). 
Demonstrar que a f√≥rmula {1} √© verdadeira equivale a demonstrar que prot √© inseguro, o 
que fizemos em I. Assim, o seq√ºente acima pode ser visto como a contra-rec√≠proca do 
objetivo inicial da prova deste lema, ou seja, 
Nalpha0ContainsE?(prot, x, y) ‚Üí insecure_protocol?(prot, x, y, z). 
 57 
‚Ä¢ No seq√ºente anterior, em {1}, vamos provar que gamComp ‚àà Œ£1‚àó(z), isto √©, 
[-1]  Nalpha0ContainsE?(prot, x, y) 
  |------- 
{1}   crTyp(gamComp`seq(i)`seq(j)) = encrypt 
{2}   user(gamComp`seq(i)`seq(j)) = z 
‚Ä¢ A f√≥rmula [-1] implica na exist√™ncia somente de operadores Wx em prot`seq(0)(x, 
y). Expandindo Nalpha0ContainsE?, obtemos: 
[-2]  FORALL (k: nat | k < prot`seq(0)(x, y)`length): 
        prot`seq(0)(x, y)`seq(k)`crTyp = decrypt AND 
         prot`seq(0)(x, y)`seq(k)`user = x 
  |------- 
[1]   crTyp(gamComp`seq(i)`seq(j)) = encrypt 
[2]   user(gamComp`seq(i)`seq(j)) = z 
Como gamComp √© o complemento de prot`seq(0)(x, y), e prot`seq(0)(x, y) possui 
somente operadores Wx , ent√£o k, em [-2], deve ser instanciado com o valor 
prot`seq(0)(x, y)`length ‚àí 1 ‚àí j. Assim, conclu√≠mos a prova desta se√ß√£o. 
5.4.2 Verifica√ß√£o: Protocolo em cascata  seguro ‚Üí  balanceado. 
Nesta se√ß√£o, mostraremos inicialmente tr√™s lemas fundamentais, dos quais depende 
o lema principal, secure_impl_balanced. Em ordem de depend√™ncia, os lemas a serem 
apresentados s√£o: 
unbalanced_implies_complement_in_sigma1, 
extractable_decUser, 
unbalanced_impl_insecure_At_0 e 
secure_impl_balanced. 
Lema unbalanced_implies_complement_in_sigma1: Em parte da prova do Lema 7, no 
cap√≠tulo Cap√≠tulo 4, assumimos que, sendo um passo de protocolo ab(x,y) desbalanceado 
com respeito a y, ent√£o o complemento de toda sub-palavra de ab(x,y) est√° em Œ£‚àó(y). Com 
o lema unbalanced_implies_complement_in_sigma1 provamos a validade desta afirma√ß√£o, 
mas n√£o apresentaremos a prova aqui. 
unbalanced_implies_complement_in_sigma1 : LEMMA FORALL(x : U, y : U | x /= y, 
         ab : alphabeta | alphabeta_welldef?(ab, x, y), 
         i : nat, j : below[ab(x,y)`length] | i <= j) : 
  unbalanced_wrt?(ab, x, y, x) => 
  wellDefInSigma1?(complementseq(ab(x, y)^(i, j)), y) 
No enunciado do lema acima, identificamos o seguinte: 
‚Ä¢ unbalanced_wrt?: predicado logicamente oposto a balanced_wrt?. 
 58 
‚Ä¢ wellDefInSigma1?(tau : seqOps, u : U): predicado que retorna verdadeiro caso 
tau ‚àà Œ£1‚àó(u).  
‚Ä¢ complementseq(seq : seqOps): fun√ß√£o que retorna o complemento de uma 
seq√º√™ncia seq. 
Este lema √© necess√°rio para a prova do lema extractable_decUser, a seguir. 
________________________________________________________________ 
Lema extractable_decUser: Corresponde ao Lema 7 do cap√≠tulo Cap√≠tulo 4. Abaixo, 
apresentamos o enunciado do lema, seguido pelo objetivo que ser√° demonstrado. 
extractable_decUser : LEMMA FORALL(x : U, y : U | x /= y, 
                      ab : alphabeta | alphabeta_welldef?(ab, x, y)) : 
 unbalanced_wrt?(ab, x, y, x) => 
 EXISTS (tau1, tau2 : seqOps) : 
   wellDefInSigma1?(tau1, y) AND wellDefInSigma1?(tau2, y) AND 
   normalizeseq(tau1 o ab(x,y) o tau2) = defalphbetawithop(opDef(decrypt,x), 1) 
  |------- 
{1}   FORALL (x: U, y: U | x /= y, 
              ab: alphabeta | alphabeta_welldef?(ab, x, y)): 
        unbalanced_wrt?(ab, x, y, x) => 
         (EXISTS (tau1, tau2: seqOps): 
            wellDefInSigma1?(tau1, y) AND wellDefInSigma1?(tau2, y) AND 
              normalizeseq(tau1 o ab(x, y) o tau2) = 
               defalphbetawithop(opDef(decrypt, x), 1)) 
Onde, defalphbetawithop(oper : op, n : nat) √© uma fun√ß√£o que cria um passo de 
protocolo (de tipo alphabeta) com n operadores op. 
‚Ä¢ (skeep): Ap√≥s a skolemiza√ß√£o de x, y e ab no objetivo mostrado acima, obtemos o 
seq√ºente: 
{-1}  unbalanced_wrt?(ab, x, y, x) 
{-2}  ab(x, y)`seq(i)`crTyp = decrypt 
{-3}  ab(x, y)`seq(i)`user = x 
  |------- 
{1}   EXISTS (tau1, tau2: seqOps): 
        wellDefInSigma1?(tau1, y) AND wellDefInSigma1?(tau2, y) AND 
          normalizeseq(tau1 o ab(x, y) o tau2) = 
           defalphbetawithop(opDef(decrypt, x), 1) 
{-2} e {-3} s√£o inferidas a partir do desbalanceamento em {-1}, ou seja, existe uma 
posi√ß√£o 0 ‚â§  < ab(x, y)`length, em ab(x, y), onde existe um operador Wx. 
‚Ä¢ (lemma unbalanced_implies_complement_in_sigma1): Considerando {-1} acima, 
utilizamos por duas vezes o lema unbalanced_implies_complement_in_sigma1, para 
gerar as f√≥rmulas {-1} e {-2} a seguir. 
{-1}  wellDefInSigma1?(complementseq(ab(x, y)^(0, i - 1)), y) 
{-2}  wellDefInSigma1?(complementseq(ab(x, y)^(1 + i, ab(x, y)`length - 1)), y) 
 59 
{-3}  ab(x, y)`seq(i)`crTyp = decrypt 
{-4}  ab(x, y)`seq(i)`user = x 
  |------- 
{1}   EXISTS (tau1, tau2: seqOps): 
        wellDefInSigma1?(tau1, y) AND wellDefInSigma1?(tau2, y) AND 
          normalizeseq(tau1 o ab(x, y) o tau2) = 
           defalphbetawithop(opDef(decrypt, x), 1) 
Representados nas f√≥rmulas {-1} e {-2} acima, temos √Å ‚àà Œ£‚àó(y) e √Å ‚àà Œ£‚àó(y) , 
respectivamente, conforme defini√ß√£o de √Å e √Å na prova anal√≠tica do Lema 7. 
‚Ä¢ No seq√ºente anterior, considerando {-1} e {-2} e instanciando [1] com √Å e √Å 
descritos acima, obtemos 
{-1}  ab(x, y)`seq(i)`crTyp = decrypt 
{-2}  ab(x, y)`seq(i)`user = x 
  |------- 
{1}  normalizeseq(complementseq(ab(x, y)^(0, i - 1)) o ab(x, y) o  
                 complementseq(ab(x, y)^(1 + i, ab(x, y)`length - 1))) =  
                    defalphbetawithop(opDef(decrypt, x), 1)  
A fun√ß√£o de normaliza√ß√£o em {1}, claramente, resulta em uma seq√º√™ncia com apenas 
um termo, ab(x, y)`seq(i), que √© igual a um operador Wx, conforme as premissas em 
{-1} e {-2}. Ent√£o, conclu√≠mos a prova do lema extractable_decUser. 
________________________________________________________________ 
Lema unbalanced_impl_insecure_At_0: Neste lema, mostramos a contra-rec√≠proca da 
prova principal desta se√ß√£o: Se um protocolo bem definido prot √© desbalanceado, ent√£o 
existe um o  bem definido, tal que o prot(0)(x,y)nnnnnnnnnnnnnnnnnnn = h . A prova √© por indu√ß√£o no 
comprimento de prot(0). 
unbalanced_impl_insecure_At_0 : LEMMA FORALL (prot : welldefined_protocol,  
                      x : U, y : U | x /= y, z : U | z /= x AND z /= y) : 
  unbalanced_cascade_protocol?(prot) =>  
    EXISTS (gamma : gammaT | gamma_welldef?(prot,gamma,z)) :  
      normalizeseq(extract_gamma(gamma) o prot(0)(x,y)) = empty_seq 
O objetivo a ser provado √© o seguinte: 
  |------- 
[1]   FORALL (prot: welldefined_protocol, x: U, y: U | x /= y, 
              z: U | z /= x AND z /= y): 
        unbalanced_cascade_protocol?(prot) => 
         (EXISTS (gamma: gammaT | gamma_welldef?(prot, gamma, z)): 
            normalizeseq(extract_gamma(gamma) o prot(0)(x,y)) 
             = empty_seq) 
‚Ä¢ (measure-induct+ "length(x, y, prot(0))" ("prot" "x" "y")): Com este comando 
iniciamos a prova por indu√ß√£o no comprimento de prot(0). 
 60 
{-1}  FORALL (hProt: welldefined_protocol, u: U, v: {y: U | u /= y}): 
        FORALL (z: U | z /= u AND z /= v): 
          length(u, v, hProt(0)) < length(x, y, prot(0))  
           IMPLIES 
           unbalanced_cascade_protocol?(hProt) => 
            (EXISTS (gamma: gammaT | gamma_welldef?(hProt, gamma, z)): 
               normalizeseq(extract_gamma(gamma) o hProt(0)(u, v)) = empty_seq) 
  |------- 
{1}   FORALL (z: U | z /= x AND z /= y): 
        unbalanced_cascade_protocol?(prot) => 
         (EXISTS (gamma: gammaT | gamma_welldef?(prot, gamma, z)): 
            normalizeseq(extract_gamma(gamma) o prot(0)(x,y)) 
             = empty_seq) 
Omitiremos a hip√≥tese de indu√ß√£o, em {-1}, de alguns seq√ºentes a seguir, para melhor 
visualiza√ß√£o. 
‚Ä¢ (lemma first_crypt_elem): Com este lema devidamente instanciado, temos que o 
primeiro operador de prot(0)(x,y) pertence ao conjunto }Wx, Iy, Ix . Assim, 
consideraremos um caso para cada um destes tr√™s poss√≠veis valores. 
I. prot(0)(x,y)(0) = Ex: Representaremos esta igualdade como isEx. 
‚Ä¢ Sendo prot desbalanceado, temos uma posi√ß√£o 0 < i < prot`length de prot, onde 
ocorre o desbalanceamento. Podemos supor, usando o comando case, que o 
desbalanceamento seja para um usu√°rio x do protocolo, ou seja, 
unbalanced_wrt?(prot`seq(i), x, z, x). 
‚Ä¢ (lemma extractable_decUser): Com este lema, em {-1} a seguir, e considerando a 
descri√ß√£o acima temos: 
{-1}  FORALL (x: U, y: U | x/=y, ab: alphabeta | alphabeta_welldef?(ab, x, y)): 
        unbalanced_wrt?(ab, x, y, x) => 
         (EXISTS (tau1, tau2: seqOps): 
            wellDefInSigma1?(tau1, y) AND wellDefInSigma1?(tau2, y) AND 
              normalizeseq(tau1 o ab(x, y) o tau2) = 
               defalphbetawithop(opDef(decrypt, x), 1)) 
[-2]  unbalanced_wrt?(prot`seq(i), x, z, x) 
[-3]  isEx 
  |------- 
[4]   EXISTS (gamma: gammaT | gamma_welldef?(x!1, gamma, z)): 
        normalizeseq(extract_gamma(gamma) o prot`seq(0)(x, y)) = empty_seq 
A f√≥rmula {-3} representa o caso a ser tratado neste ramo da prova do lema 
unbalanced_impl_insecure_At_0. Em [4] est√° expressa a exist√™ncia de um gammaT que 
normaliza o primeiro passo de protocolo de prot √† seq√º√™ncia vazia. 
‚Ä¢ (inst -1 "x" "z" "prot`seq(i)"): Instanciamos {-1} do seq√ºente anterior com os 
usu√°rios x e z e um passo de protocolo na posi√ß√£o i de prot. Assim, considerando   
{-2}, teremos em {-1}: 
 61 
{-1}  EXISTS (tau1, tau2: seqOps): 
        wellDefInSigma1?(tau1, z) AND wellDefInSigma1?(tau2, z) AND 
          normalizeseq(tau1 o prot`seq(i)(x, z) o tau2) = 
           defalphbetawithop(opDef(decrypt, x), 1) 
Skolemizando a f√≥rmula acima, e aplicando uma simplifica√ß√£o disjuntiva com o 
comando flatten, teremos tr√™s novas f√≥rmulas no seq√ºente, {-1}, {-2} e {-3}, como 
mostradas a seguir: 
{-1}  wellDefInSigma1?(tau1, z) 
{-2}  wellDefInSigma1?(tau2, z) 
{-3}  normalizeseq(tau1 o prot`seq(i)(x, z) o tau2) = 
       defalphbetawithop(opDef(decrypt, x), 1) 
[-4]  isEx 
  |------- 
[4]   EXISTS (gamma: gammaT | gamma_welldef?(x!1, gamma, z)): 
        normalizeseq(extract_gamma(gamma) o prot`seq(0)(x, y)) = empty_seq 
‚Ä¢ (lemma triplet_welldef): Este lema, que n√£o provaremos aqui, √© enunciado como 
mostrado abaixo. 
triplet_welldef : LEMMA FORALL (prot : welldefined_protocol,  
                                tau1, tau2 : seqOps, a : U, b : U | a /= b, z : U,  
                                i:posnat | i < prot`length) :  
  wellDefInSigma1?(tau1, z) AND wellDefInSigma1?(tau2, z) =>  
  gamma_welldef?(prot, defgammawithtriplet(tau1, prot(i)(a, b), tau2), z)) 
A fun√ß√£o defgammawithtriplet realiza a concatena√ß√£o das tr√™s seq√º√™ncias para 
constituir um gammaT. Com o lema triplet_welldef, provamos o seguinte: Para todo √Å, √Å ‚àà Œ£‚àó(z) (wellDefInSigma1?(tau1, z) AND wellDefInSigma1?(tau2, z)), temos 
que √Å¬èi(a,b)√Å  (defgammawithtriplet(tau1, prot(i)(a, b), tau2)) √© um gammaT 
bem definido. ¬è = prot, i, a, b e z s√£o conforme mostrados no enunciado do lema. 
Ap√≥s a correta instancia√ß√£o de triplet_welldef teremos, considerando {-1} e {-2} do 
seq√ºente anterior: 
gamma_welldef?(prot, defgammawithtriplet(tau1, prot`seq(i)(x, z), tau2), z) 
‚Ä¢ (expand isEx): A expans√£o de isEx produz ¬è¬ê(x,y) = Ix¬è¬ê(x,y)u,|¬ë√Ö(x,y)|yv. 
prot`seq(0)(x, y) = defalphbetawithop(opDef(encrypt, x), 1) o 
    prot`seq(0)(x, y)^(1, prot`seq(0)(x, y)`length - 1) 
Assim, reescrevemos prot`seq(0)(x, y) na f√≥rmula [4] do seq√ºente anterior: 
[4] EXISTS (gamma: gammaT | gamma_welldef?(x!1, gamma, z)): 
   normalizeseq(extract_gamma(gamma) o (defalphbetawithop(opDef(encrypt,x),1) o 
        prot`seq(0)(x, y)^(1, prot`seq(0)(x, y)`length - 1))) = empty_seq 
 62 
‚Ä¢ (inst -1 "suff_ab_prot(prot,1)" "x" "y" "z"): Recuperando-se a hip√≥tese de 
indu√ß√£o, esta instancia√ß√£o deve ser realizada, de modo que obtenhamos o seq√ºente a 
seguir. 
{-1}  EXISTS (gamma: gammaT | gamma_welldef?(suff_ab_prot(prot, 1), gamma, z)): 
        normalizeseq(extract_gamma(gamma) o suff_ab_prot(prot, 1)`seq(0)(x, y)) 
          = empty_seq 
[-2]  gamma_welldef?(prot,defgammawithtriplet(tau1,prot`seq(i)(x,z),tau2),z) 
[-5]  normalizeseq(tau1 o prot`seq(i)(x, z) o tau2) = 
                defalphbetawithop(opDef(decrypt, x), 1) 
  |------- 
[5]   EXISTS (gamma: gammaT | gamma_welldef?(x!1, gamma, z)): 
        normalizeseq(extract_gamma(gamma) o 
          (defalphbetawithop(opDef(encrypt, x), 1) o 
           prot`seq(0)(x, y) ^ (1, prot`seq(0)(x, y)`length - 1))) = empty_seq 
O termo suff_ab_prot(prot, 1), utilizado na instancia√ß√£o, representa o protocolo prot 
com o primeiro passo de protocolo sem operador da posi√ß√£o 0, ou seja, ¬è¬ê(x,y)u,|¬ë√Ö(x,y)|yv. Em nossa especifica√ß√£o, isto √© 
suff_ab_prot(prot, 1)`seq(0)(x, y) =  
      prot`seq(0)(x, y)^(1, prot`seq(0)(x, y)`length - 1) 
‚Ä¢ (skolem -1 "gammap"): Skolemizamos {-1}, acima, com um gammaT que chamaremos 
de gammap, assumido como bem definido. 
‚Ä¢ (inst 5 "gammap o defgammawithtriplet(tau1, prot`seq(i)(x, z), tau2)"): 
Instanciamos o gammaT, em [5], do seq√ºente anterior. Este gammaT √© bem definido, pois 
gammap e defgammawithtriplet(tau1, prot`seq(i)(x, z), tau2) s√£o bem definidos e, 
de acordo com o lema gammas_welldefs_imp_o_is_welldef, que n√£o descreveremos em 
detalhes, a composi√ß√£o de dois objetos gammaT bem definidos resulta em um objeto 
gammaT bem definido. Assim, o seq√ºente anterior se torna o seguinte: 
[-1]  normalizeseq(extract_gamma(gammap) o suff_ab_prot(prot, 1)`seq(0)(x, y))  
           = empty_seq 
[-2]  normalizeseq(tau1 o prot`seq(i)(x, z) o tau2) = 
       defalphbetawithop(opDef(decrypt, x), 1) 
  |------- 
{3}   normalizeseq(extract_gamma(gammap) o 
         extract_gamma(defgammawithtriplet(tau1, prot`seq(i)(x, z), tau2)) o 
         defalphbetawithop(opDef(encrypt, x), 1) o 
         prot`seq(0)(x, y) ^ (1, prot`seq(0)(x, y)`length - 1)) = empty_seq 
Em {3}, temos o seguinte: gammap √Å¬è¬´(x,z)√Å Ix ¬è¬ê(x,y)u,|¬ë√Ö(x,y)|yvnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn = Œª . Como √Å¬è¬´(x,z)√Ånnnnnnnnnnnnnn = Wx, pela f√≥rmula [-2], obtemos em {3}: gammap ¬è¬ê(x,y)u,|¬ë√Ö(x,y)|yvnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn = Œª. 
Pela hip√≥tese de indu√ß√£o em [-1], vemos que {3} √© verdadeiro e conclu√≠mos este ramo 
da prova. 
 63 
II. prot(0)(x,y)(0) = Dx: Neste caso, temos o seguinte seq√ºente: 
{-1}  prot`seq(0)(x, y) = defalphbetawithop(opDef(decrypt, x), 1) o 
        prot`seq(0)(x, y)^(1, prot`seq(0)(x, y)`length - 1) 
  |------- 
[5]   EXISTS (gamma: gammaT | gamma_welldef?(x!1, gamma, z)): 
        normalizeseq(extract_gamma(gamma) o prot`seq(0)(x, y)) = empty_seq 
Em {-1}, temos que ¬è¬ê(x,y) = Wx¬è¬ê(x,y)u,|¬ë√Ö(x,y)|yv  e, em [5], existe o  bem-
definido, tal que o¬è¬ê(x,y)nnnnnnnnnn = h. 
‚Ä¢ (replace -1 5): Substituindo {-1} em [5], obtemos o seq√ºente: 
  |------- 
{5} EXISTS (gamma: gammaT | gamma_welldef?(x!1, gamma, z)): 
     normalizeseq(extract_gamma(gamma) o defalphbetawithop(opDef(decrypt,x),1) o 
         prot`seq(0)(x, y)^(1, prot`seq(0)(x, y)`length - 1))) = empty_seq 
‚Ä¢ Considerando-se a hip√≥tese de indu√ß√£o, instanciada com suff_ab_prot(prot,1), temos 
em {-1}: 
{-1}  EXISTS (gamma: gammaT | gamma_welldef?(suff_ab_prot(prot, 1), gamma, z)): 
        normalizeseq(extract_gamma(gamma) o suff_ab_prot(prot, 1)`seq(0)(x, y)) 
         = empty_seq 
  |------- 
[6]   EXISTS (gamma: gammaT | gamma_welldef?(x!1, gamma, z)): 
        normalizeseq(extract_gamma(gamma) o 
          (defalphbetawithop(opDef(decrypt, x), 1) o 
           prot`seq(0)(x, y)^(1, prot`seq(0)(x, y)`length - 1))) = empty_seq 
‚Ä¢ (skolem -1 "gammap"): Com a skolemiza√ß√£o de {-1}, esta f√≥rmula se torna: 
{-1} normalizeseq(extract_gamma(gammap) o suff_ab_prot(prot, 1)`seq(0)(x, y)) 
         = empty_seq 
‚Ä¢ (inst 6 "gammap o defGammaWithOp(opDef(encrypt, x), 1)"): A instancia√ß√£o de [6] 
com gammap concatenado a uma seq√º√™ncia com um √∫nico operador Ix, produz o 
seq√ºente: 
[-1]  normalizeseq(extract_gamma(gammap) o suff_ab_prot(prot, 1)`seq(0)(x, y)) 
          = empty_seq 
  |------- 
{6} normalizeseq(extract_gamma(gammap) o  
      extract_gamma(defGammaWithOp(opDef(encrypt, x), 1)) o 
      (defalphbetawithop(opDef(decrypt, x), 1) o 
       prot`seq(0)(x, y)^(1, prot`seq(0)(x, y)`length - 1))) = empty_seq 
Em {6}, temos o seguinte: gammap IxWx ¬è¬ê(x,y)u,|¬ë√Ö(x,y)|yvnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn = Œª. Claramente, {6} √© 
verdadeiro, considerando-se a hip√≥tese de indu√ß√£o. 
III. prot(0)(x,y)(0) = Ey: Este caso √© an√°logo ao caso I e n√£o ser√° mostrado. 
________________________________________________________________ 
 64 
Lema secure_impl_balanced: Com este lema concluiremos esta se√ß√£o, provando que um 
protocolo em cascata seguro implica no balanceamento deste protocolo. O lema 
secure_impl_balanced √© enunciado abaixo. 
secure_impl_balanced : LEMMA FORALL (prot : welldefined_protocol,  
                             x : U, y : U | x /= y, z : U | z /= x AND z /= y) : 
  secure_protocol?(prot, x, y, z) => balanced_cascade_protocol?(prot) 
Queremos provar o seguinte objetivo: 
  |------- 
{1}  FORALL (prot: welldefined_protocol, x: U, y: U | x /= y, 
                                                 z: U | z /= x AND z /= y): 
        secure_protocol?(prot, x, y, z) => balanced_cascade_protocol?(prot) 
‚Ä¢ (skeep): A skolemiza√ß√£o do objetivo acima produz o seq√ºente: 
[-2]  secure_protocol?(prot, x, y, z) 
  |------- 
[1]   balanced_cascade_protocol?(prot) 
‚Ä¢ (lemma unbalanced_impl_insecure_At_0): Invocando este lema e fazendo a 
instancia√ß√£o com as vari√°veis de skolem geradas pelo comando anterior, obtemos o 
seq√ºente mostrado a seguir. 
{-1}  EXISTS (gamma: gammaT | gamma_welldef?(prot, gamma, z)): 
        normalizeseq(extract_gamma(gamma) o prot`seq(0)(x, y)) 
          = empty_seq 
[-3]  secure_protocol?(prot, x, y, z) 
  |------- 
‚Ä¢ (lemma secure_eq_not_insecure_prot): Ap√≥s a instancia√ß√£o adequada deste lema, 
temos, no conseq√ºente, uma f√≥rmula com o predicado insecure_protocol?(prot, x, 
y, z). Expandindo a defini√ß√£o de insecure_protocol?, obtemos em {1}: 
[-1]  EXISTS (gamma: gammaT | gamma_welldef?(prot, gamma, z)): 
        normalizeseq(extract_gamma(gamma) o prot`seq(0)(x, y)) 
         = empty_seq 
  |------- 
{1}   EXISTS (gamma: gammaT | gamma_welldef?(prot, gamma, z), 
              i: nat | i < prot`length): 
        normalizeseq(extract_gamma(gamma) o extract_eN(prot, i, x, y)) 
            = empty_seq 
Claramente, o seq√ºente acima pode ser provado com a skolemiza√ß√£o de [-1], e 
instancia√ß√£o de {1} com o gammaT skolemizado em [-1] e i = 0. Deste modo, 
completamos a prova do lema secure_impl_balanced. 
 65 
5.5 Teoria SecuritySufficiency: Prova da Sufici√™ncia do 
Teorema 1 
A seguir, apresentamos a prova de sufici√™ncia do Teorema 1. Mostraremos somente a 
prova para o lema principal alpha0_and_bal_secure, e apresentaremos os enunciados de 
lemas importantes para esta prova. 
Lema gammaAlpha0Complements: Neste lema, provamos o Lema 8 mostrado na prova de 
sufici√™ncia do Teorema 1. 
gammaAlpha0Complements : LEMMA FORALL(prot : welldefined_protocol, x : U, 
                                             y : U | x /= y, z : U) : 
  insecure_protocol?(prot,x,y,z) => 
    EXISTS(gamma : gammaT | gamma_welldef?(prot,gamma,z)) : 
      areseqcomplements?(normalizeseq(extract_gamma(gamma)),prot`seq(0)(x, y)) 
________________________________________________________________ 
Lema userBalancing: Correspondente ao Lema 6 do cap√≠tulo Cap√≠tulo 4, userBalancing √© 
formalizado conforme abaixo. Este lema representa uma importante parte da prova de 
alpha0_and_bal_secure e depende dos lemas Lema 2, Lema 3, Lema 4 e Lema 5, como 
mostrado na se√ß√£o 4.2.3. A teoria UserBalancingProperty apresenta as especifica√ß√µes de 
defini√ß√µes e lemas que permitem a prova de userBalancing. 
userBalancing : LEMMA FORALL (prot : welldefined_protocol, z : U, 
              gamma : gammaT | gamma_welldef?(prot,gamma, z), w : U | w /= z) : 
  balanced_cascade_protocol?(prot) => 
    balancedseq_wrt?(normalizeseq(extract_gamma(gamma)), w) 
________________________________________________________________ 
Lema alpha0WithoutEyContainsOnlyEx: Se n√£o existe um Iy em prot`seq(0)(x,y), ent√£o 
todos os operadores desta seq√º√™ncia s√£o Ix. Esta situa√ß√£o √© descrita na prova anal√≠tica da 
sufici√™ncia, onde analisamos o caso (¬è¬ê) ‚â† Iy. 
alpha0WithoutEyContainsOnlyEx : LEMMA FORALL(prot : welldefined_protocol, 
                                                      x : U, y : U | x /= y) : 
  (NOT memberAlphaBeta(opDef(encrypt,y),x,y,prot(0))  
        AND alpha0ContainsE?(prot, x, y)) => 
  FORALL(i : below[prot(0)(x,y)`length]) : prot(0)(x,y)(i) = opDef(encrypt,x) 
________________________________________________________________ 
O lema principal da prova de sufici√™ncia do Teorema 1 √© mostrado a seguir. 
 
 66 
alpha0_and_bal_secure : LEMMA FORALL (prot : welldefined_protocol,  
                        x : U, y : U | x /= y, z : U | z /= x AND z /= y) :  
  ( alpha0ContainsE?(prot, x, y) AND  
    balanced_cascade_protocol?(prot) ) => secure_protocol?(prot, x, y, z)  
E o objetivo a ser provado √© o seguinte: 
  |------- 
[1]   FORALL (prot: welldefined_protocol, x: U, y: U | x /= y, 
              z: U | z /= x AND z /= y): 
        (alpha0ContainsE?(prot, x, y) AND balanced_cascade_protocol?(prot)) 
         => secure_protocol?(prot, x, y, z)  
‚Ä¢ (skeep): Skolemizando o objetivo acima, temos: 
{-1}  alpha0ContainsE?(prot, x, y) 
{-2}  balanced_cascade_protocol?(prot) 
  |------- 
{1}   secure_protocol?(prot, x, y, z) 
‚Ä¢ (case "insecure_protocol?(prot,x,y,z)"): Conforme mostrado no cap√≠tulo Cap√≠tulo 
4, B. Sufici√™ncia, geraremos uma prova por contradi√ß√£o, supondo que o protocolo em 
cascata prot √© inseguro. 
{-1}  insecure_protocol?(prot, x, y, z) 
[-2]  alpha0ContainsE?(prot, x, y) 
[-3]  balanced_cascade_protocol?(prot) 
  |------- 
‚Ä¢ (lemma gammaAlpha0Complements): Com este lema, e considerando {-1} anterior, 
obtemos uma f√≥rmula onde afirma-se que existe um gammaT que √© o complemento de 
prot`seq(0)(x, y). 
{-1}  EXISTS (gamma: gammaT | gamma_welldef?(prot, gamma, z)): 
        areseqcomplements?(normalizeseq(extract_gamma(gamma)), 
             prot`seq(0)(x, y))  
‚Ä¢ (skeep -1): Ap√≥s a skolemiza√ß√£o da f√≥rmula acima, obtemos o seq√ºente:  
{-1}  areseqcomplements?(normalizeseq(extract_gamma(gamma)),prot`seq(0)(x, y)) 
[-2]  insecure_protocol?(prot, x, y, z) 
[-3]  alpha0ContainsE?(prot, x, y) 
[-4]  balanced_cascade_protocol?(prot) 
  |------- 
‚Ä¢  (lemma userBalancing): Com este lema adequadamente instanciado, e nomeando 
normalizeseq(extract_gamma(gamma)) como normGamma, temos uma nova f√≥rmula em 
{-1}. 
{-1}  FORALL (w: U | w /= z): balancedseq_wrt?(normGamma, w) 
{-2}  areseqcomplements?(normGamma, prot`seq(0)(x, y)) 
[-3]  alpha0ContainsE?(prot, x, y) 
  |------- 
 67 
Assim como na prova anal√≠tica da sufici√™ncia, geramos uma contradi√ß√£o entre {-1} e 
{-2}, considerando dois casos relativos aos operadores contidos em prot(0)(x,y). 
I. (case "memberAlphaBeta(opDef(encrypt,y),x,y,prot(0))"): Neste caso, 
prot(0)(x,y) possui um operador Iz, conforme em {-1}, no seq√ºente a seguir. A 
f√≥rmula em [-2], abaixo, √© a f√≥rmula {-1} do seq√ºente anterior, instanciada com y: 
{-1}  memberAlphaBeta(opDef(encrypt, y), x, y, prot`seq(0)) 
[-2]  balancedseq_wrt?(normGamma, y) 
[-3]  areseqcomplements?(normGamma, prot`seq(0)(x, y)) 
  |------- 
‚Ä¢ Expandindo as defini√ß√µes de balancedseq_wrt? e areseqcomplements?, podemos 
skolemizar e instanciar novas f√≥rmulas, gerando: 
[-1]  normGamma`length = prot`seq(0)(x, y)`length 
{-2}  areopcomplements?(normGamma`seq(i), 
                        prot`seq(0)(x, y)`seq(normGamma`length - 1 - i)) 
[-3]  normGamma`seq(i)`crTyp = encrypt AND normGamma`seq(i)`user = y 
  |------- 
[-1] e {-2} v√™m da defini√ß√£o de areseqcomplements?, e [-3] resulta de 
balancedseq_wrt?. Considerando-se {-2} e [-3], podemos dizer que prot`seq(0)(x, 
y)`seq(normGamma`length - 1 - i) = Wy . Mas prot`seq(0)(x,y) n√£o cont√©m, por 
defini√ß√£o, o operador privado de y. Logo, chegamos a uma contradi√ß√£o para este caso. 
II. Este ramo da prova √© conforme a seguir. Em {1}, temos a situa√ß√£o de que um 
operador Iy n√£o existe em prot`seq(0)(x, y). 
[-1]  FORALL (w: U | w /= z): balancedseq_wrt?(normGamma, w) 
[-2]  areseqcomplements?(normGamma, prot`seq(0)(x, y)) 
[-3]  alpha0ContainsE?(prot, x, y) 
  |------- 
{1}   memberAlphaBeta(opDef(encrypt, y), x, y, (prot)`seq(0)) 
‚Ä¢ (inst -1 x): Instanciando [-1], acima, teremos que: 
[-1]  balancedseq_wrt?(normGamma, x) 
‚Ä¢ (lemma alpha0WithoutEyContainsOnlyEx): Em {-1}, a seguir, utilizamos o lema 
alpha0WithoutEyContainsOnlyEx para afirmar que todos os operadores de 
prot`seq(0)(x, y) s√£o Ix . Isso quer dizer que, considerando [-3], todos os 
operadores de normGamma s√£o Wx, contradizendo [-2], onde diz-se que normGamma tem a 
PB com respeito a x. 
 
 
 
 68 
[-1]  FORALL (i: below[finseq_appl[alphabeta](prot)(0)(x, y)`length]): 
        prot`seq(0)(x, y)`seq(i) = opDef(encrypt, x) 
[-2]  balancedseq_wrt?(normGamma, x) 
[-3]  areseqcomplements?(normGamma, prot`seq(0)(x, y)) 
  |------- 
Deste modo, conclu√≠mos a prova da sufici√™ncia para o Teorema 1. 
5.6 Teoria CascadeProtocolsSecurity: Prova final do 
Teorema 1 
A especifica√ß√£o em PVS do Teorema 1 √© dada a seguir, e √© v√°lida para todo protocolo em 
cascata bem-definido e para todo U, z, ¬ö ‚àà L | U ‚â† z  e ¬ö ‚â† U, z. 
theorem1 : THEOREM FORALL (prot : welldefined_protocol,  
    x : U, y : U | x /= y, z : U | z /= x AND z /= y) :  
 secure_protocol?(prot, x, y, z) IFF  
 ( alpha0ContainsE?(prot, x, y) AND balanced_cascade_protocol?(prot) ) 
O theorem1 pode ser trivialmente provado, considerando-se os lemas anteriores: 
secProt_imp_alpha0ContainsE, secure_impl_balanced e alpha0_and_bal_secure. E, assim, 
temos a prova final para o teorema da seguran√ßa de protocolos em cascata no modelo 
Dolev-Yao. 
Uma aplica√ß√£o imediata do Teorema 1 pode ser feita pela defini√ß√£o de um protocolo em 
cascata simples, conforme mostrado abaixo: 
Para dois participantes quaisquer U, z ‚àà L | U ‚â† z, seja o protocolo ¬è a seguir: 
¬è¬ê(U, z) = IV 
¬è(z, U) = W~IV 
¬è(U, z) = I~ 
Em ¬è, a condi√ß√£o inicial de seguran√ßa (Defini√ß√£o 6) √© satisfeita, mas ¬è n√£o 
possui a PB com respeito a z. Assim, utilizando theorem1, podemos provar que ¬è √© 
inseguro.  
 69 
Cap√≠tulo 6.  
Conclus√µes 
Formalizamos, em PVS, a prova de seguran√ßa para protocolos em cascata no 
modelo Dolev-Yao, seguindo uma metodologia alg√©brica, onde os passos de protocolo s√£o 
especificados como fun√ß√µes de pares de usu√°rios em seq√º√™ncias de operadores. Os 
resultados estat√≠sticos com a quantidade de lemas e TCCs provados, em cada teoria 
especificada, est√£o no Anexo 1. 
Apesar da prova de seguran√ßa, caracterizada pelo Teorema 1, ser de ordem 
superior, a maior parte de nossos esfor√ßos foram no sentido de verificar propriedades sobre 
seq√º√™ncias finitas de operadores; em especial, validar as estruturas de dados e fun√ß√µes 
necess√°rias ao processo de normaliza√ß√£o. O lema normalize_general, descrito no cap√≠tulo 
Cap√≠tulo 5 e correspondente ao Lema 1 da prova anal√≠tica do cap√≠tulo Cap√≠tulo 4, destaca-
se como o principal lema deste processo de valida√ß√£o. 
Utilizamos, em nossas provas, diferentes t√©cnicas dispon√≠veis no PVS, como 
t√©cnicas proposicionais (contradi√ß√£o, contraposi√ß√£o, etc), t√©cnicas l√≥gicas (skolemiza√ß√£o, 
instancia√ß√£o, etc) e indu√ß√£o sobre estruturas envolvidas na especifica√ß√£o, principalmente o 
comprimento de seq√º√™ncias. 
A metodologia aplicada na verifica√ß√£o dos protocolos em cascata no modelo Dolev-
Yao √© adequada para o tratamento formal da seguran√ßa, em geral. Pela utiliza√ß√£o de um 
sistema para automatiza√ß√£o de provas, todas as omiss√µes e pequenas falhas de 
especifica√ß√£o s√£o detectadas e necessitam ser provadas ou enunciadas. Neste trabalho, a 
verifica√ß√£o formal exibiu erros definicionais e omiss√µes presentes na formaliza√ß√£o anal√≠tica 
dos protocolos em [6]. Adicionalmente, o processo de formaliza√ß√£o permitiu atingir 
estruturas de dados precisas e adequadas para implementa√ß√£o do modelo. Modifica√ß√µes 
simples das imprecis√µes mencionadas permitiram formalizar provas para os resultados 
apresentados em [6]. Os problemas mais relevantes, encontrados na formaliza√ß√£o anal√≠tica 
realizada por Dolev e Yao em [6], s√£o os seguintes: 
 70 
‚Ä¢ Passos de protocolo devem ser normalizados: Em [6], um passo de protocolo √© 
considerado, por conveni√™ncia, normalizado. Ao formalizar o modelo em PVS, 
verificamos ser necess√°rio que, por defini√ß√£o, um passo de protocolo seja normal, e 
definimos esta propriedade na condi√ß√£o 2 da Defini√ß√£o 1. Trata-se apenas de um 
rigor matem√°tico necess√°rio para a validade da prova do Lema 7, por exemplo; em 
outros lemas tamb√©m se verifica o problema. A condi√ß√£o de que um passo de 
protocolo deve ser normalizado ocorre devido √† defini√ß√£o da PB. Consideremos um 
passo de protocolo ¬Ä¬Å(¬ä, ¬ã) (¬ä, ¬ã ‚àà L | ¬ä ‚â† ¬ã), que n√£o tem a PB com respeito a ¬ä. 
O passo de protocolo ¬Ä¬Å(¬ä, ¬ã)u¬ê,vI$W$¬Ä¬Å(¬ä, ¬ã)u¬π,|√Ç√É($,¬é)|yv ( < |¬Ä¬Å(¬ä, ¬ã)|) n√£o 
√© normal e tem a PB com respeito a ¬ä, mas ainda assim √© poss√≠vel violar o protocolo 
encontrando os mesmos √Å e √Å relativos a ¬Ä¬Å(¬ä, ¬ã), conforme o Lema 7, tais que 
√Å¬Ä¬Å(¬ä, ¬ã)u¬ê,¬´vI$W$¬Ä¬Å(¬ä, ¬ã)u¬´¬π,|√Ç√É($,¬é)|yv√Ånnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn = W$. Assim, verificamos, durante a 
especifica√ß√£o em PVS, a necessidade de que um passo de protocolo seja normal. Para 
fins de formaliza√ß√£o alg√©brica, esta propriedade precisa ser expl√≠cita, mas, na pr√°tica, 
a normaliza√ß√£o ocorre de modo natural, j√° que cada opera√ß√£o de 
encripta√ß√£o/decripta√ß√£o ocorre sequencialmente, e um operador n√£o √© aplicado √† 
transforma√ß√£o de uma mensagem sem que antes um operador, imediatamente anterior 
na seq√º√™ncia de operadores, seja aplicado. Desta forma, um operador ¬∫$!  (¬ä ‚àà L) 
desfaz a transforma√ß√£o da mensagem resultante da aplica√ß√£o de um operador ¬∫$ 
anterior na seq√º√™ncia. 
‚Ä¢ Generaliza√ß√£o de lemas: Nossa formaliza√ß√£o permitiu especificar algumas defini√ß√µes 
e lemas de modo mais geral que o proposto por Dolev e Yao. Por exemplo, em [6], 
s√£o apresentados os dois lemas a seguir 
(1) ‚ÄúSeja ¬è um protocolo em cascata balanceado. E seja ¬∑  qualquer 
seq√º√™ncia de operadores tendo a PE com respeito a ¬ö ‚àà L. Para toda 
seq√º√™ncia de operadores ] ‚àà (Œ£‚àó(¬ö) ‚à™ Œ£)‚àó , ¬∑]  e ]¬∑  t√™m a PE com 
respeito a ¬ö.‚Äù; e 
(2) ‚ÄúSeja ¬è um protocolo em cascata balanceado. Ent√£o toda seq√º√™ncia 
de operadores ] ‚àà (Œ£‚àó(¬ö) ‚à™ Œ£)‚àó, tem a PE com respeito a ¬ö ‚àà L.‚Äù 
(2), acima, √© provado a partir de (1). H√° uma not√°vel discrep√¢ncia entre o 
maior esfor√ßo para se provar (1), em rela√ß√£o ao esfor√ßo para provar (2). Al√©m disso, 
 71 
existe certa redund√¢ncia na considera√ß√£o de seq√º√™ncias ] ‚àà (Œ£‚àó(¬ö) ‚à™ Œ£)‚àó , por 
ambos os lemas, que poderia ser evitada. A partir dessa an√°lise, formalizamos estes 
dois lemas de uma forma mais geral, conforme pode ser visto no Lema 3 e no Lema 
4 (reescritos abaixo), e de modo independente, ou seja, para provar qualquer um 
destes lemas, n√£o √© necess√°rio utilizar o outro. Assim, tornamos mais gerais duas 
propriedades fundamentais presentes na prova original em [6].  
‚ÄúLema 3 Seja um protocolo em cascata balanceado ¬è, um usu√°rio ¬ö ‚àà L e 
as seq√º√™ncias de operadores ¬∑ e ]. Se ¬∑ e ] t√™m a PE com respeito a ¬ö, 
ent√£o a seq√º√™ncia ¬∑] tem a PE com respeito a ¬ö.‚Äù 
‚ÄúLema 4 Seja ¬è um protocolo em cascata balanceado, ¬ö um usu√°rio e 
‚àÄo ‚àà (Œ£
‚àó(¬ö) ‚à™ Œ£)‚àó. Ent√£o, o tem a PE com respeito a ¬ö.‚Äù 
Afirmar que um protocolo executa suas atribui√ß√µes com seguran√ßa, tem sido um 
desafio h√° mais de 25 anos e, ainda hoje, diversos paradigmas v√™m sendo propostos e novas 
falhas de protocolos criptogr√°ficos detectadas. 
Recentemente, trabalhos importantes como alguns descritos na se√ß√£o 2.5 t√™m 
demonstrado a possibilidade de se representar matematicamente algumas caracter√≠sticas de 
implementa√ß√µes reais, de modo que se possam analisar adequadamente aspectos de 
seguran√ßa. 
Enquanto se desenvolvem os m√©todos formais para verifica√ß√£o de protocolos 
criptogr√°ficos, estes tamb√©m s√£o modificados e criados para novas aplica√ß√µes. E isso 
representa mais um desafio para a verifica√ß√£o por m√©todos formais. 
6.1 Trabalhos Futuros 
A utiliza√ß√£o de diversas t√©cnicas de provas em PVS, bem como a constru√ß√£o do 
conjunto de especifica√ß√µes sobre seq√º√™ncias de operadores e propriedades da normaliza√ß√£o, 
podem contribuir para a realiza√ß√£o de trabalhos futuros, no sentido de se verificar a 
corre√ß√£o l√≥gica de classes de protocolos mais gerais, ou mesmo de protocolos espec√≠ficos. 
Atualmente, temos um grande interesse na verifica√ß√£o da seguran√ßa de protocolos 
oblivious transfer, que representa uma importante primitiva de seguran√ßa para dois 
 72 
participantes, e que implica em qualquer outra funcionalidade de seguran√ßa para dois 
participantes, sem a necessidade de primitivas adicionais [58]. 
 73 
Refer√™ncias 
[1] M. Backes. Cryptographically sound analysis of security protocols. Ph.D thesis, Computer Science 
Department, Saarland University, 2002. 
[2] S. Owre, N. Shankar, J. M. Rushby, D. W. J. Stringer-Calvert. PVS Language Reference ‚Äì Version 2.4. 
Nov 2001. 
[3] J. Crow, S. Owre, J. M. Rushby, N. Shankar, M. Srivas. A Tutorial Introduction to PVS. April 1995.  
[4] Roger Needham and Michael Schroeder. Using encryption for authentication in large networks of 
computers. Communications of the ACM, 21(12):993-999, 1978. 
[5] Gavin Lowe. Breaking and Fixing the Needham-Schroeder public-key protocol using FDR. In Margaria 
and Steffen, editors, Tools and Algorithms for the Construction and Analysis of Systems, volume 1055 of Lecture 
Notes in Computer Science, pages 147-166. Springer-Verlag, 1996. 
[6] D. Dolev and A. Yao. On the security of public-key protocols. IEEE Transactions on Information Theory, 
29:198-208, 1983. 
[7] M. Backes, B. Pfitzmann, and M. Waidner. A Universally Composable Cryptographic Library. IACR 
Cryptology ePrint Archive, Report 2003/015, January 2003. 
[8] S. Owre, N. Shankar, J. M. Rushby. PVS Prover Guide ‚Äì Version 2.4. Nov 2001. 
[9] A. Rubin and P. Honeyman. Formal methods for the analysis of authentication protocols. Technical 
Report CITI TR 93-7, October 1993. 
[10] Jonathan Herzog. Computational Soundness for Standard Assumptions of Formal Cryptography. PhD 
thesis, Massachusetts Institute of Technology, May 2004. 
[11] C. J. F. Cremers, S. Mauw & E. P. de Vink, Formal Methods for Security Protocols: Three Examples of 
the Black-Box Approach. 2003. 
[12] B. Blanchet. A computationally sound mechanized prover for security protocols. In Proc. 27th IEEE 
Symposium on Security & Privacy, 2006. 
[13] C. Meadows, Formal Verification of Cryptographic Protocols: A survey, Advances in Cryptology ‚Äì 
ASIACRYPT‚Äô94 135-150. 
[14] Avinanta Tarigan, Survey in Formal Analysis of Security Properties of Cryptographic Protocol. 
Universit√§t Bielefeld, May 2002.  
[15] M. Abadi and P. Rogaway. Reconciling two views of cryptography: The computational soundness of 
formal encryption. In Proc. 1st IFIP International Conference on Theoretical Computer Science, pages 3--22. 
Springer LNCS 1872, 2000. 
[16] Ross J. Anderson, Security Engineering: a guide to building dependable distributed system. John Wiley & 
Sons Inc., 2001. 
[17] C. J. F. Cremers, Verification of Multi-Protocol Attacks. Eindhoven University of Technology, 2004. 
[18] J. Kelsey, B. Schneier, D. Wagner, Protocol interactions and the chosen protocol attack, in: Security 
Protocols Workshop, 1997, pp. 91-104. 
[19] G. Bella, F. Massacci, and L. C. Paulson. Verifying the SET purchase protocols. Technical report, 
Cambridge University Computer Laboratory, 2001. 
[20] Jonathan K. Millen, Sidney C. Clark, and Sheryl B. Freedman. The interrogator: Protocol security 
analysis. IEEE Transactions on Software Engineering, SE-13(2):274-288, Feb 1987. 
 74 
[21] Levente Buttyan, Formal methods in the design of cryptographic protocols. Technical Report 
SSC/1999/038, Swiss Federal Institute of Technology, ICA, November 1999.  
[22] Siraj Shaikh and Vicky Bush, Analysing the Woo-Lam Protocol Using CSP and Rank Functions. 2006. 
[23] S. SCHNEIDER, Verifying authentication protocols in CSP. IEEE Transactions on Software Engineering 
24(9):741‚Äì758. 1998. 
[24] F. Wang, Formal verification of timed systems: A survey and perspective. Proceedings of the IEEE 92(8). 
2004. 
[25] Vijay Varadharajan, Verification of network security protocols. Computers and Security 8(8): 693-708, 
1989. 
[26] Deepinder P. Sidhu, Authentication protocols for computer networks. I Computer Networks and ISDN 
Systems, 11: 297-310. 1986. 
[27] T.Y.C. WOO and S.S. LAM, Authentication for distributed systems. Computer 25(1):39‚Äì52. 1992. 
[28] C. H. West, General technique for communications protocol validation. IBM Journal of Research and 
Development, 22:393-404. 1978. 
[29] M. Rusinowitch and M. Turuani. Protocol Insecurity with Finite Number of Sessions is NP-complete. In 
14th IEEE Computer Security Foundations Workshop (CSFW-14), pages 174- 190, 2001. 
[30] J. Herzog, A computational interpretation of Dolev-Yao adversaries. Theoretical Computer Science, 
vol.340, pp. 57-81, June 2005. 
[31] Udi Manber, Introduction to Algorithms: A Creative Approach, Addison-Wesley Longman Publishing Co., 
Inc., Boston, MA, 1989. 
[32] S. Delaune and F. Jacquemard, Decision Procedures for the Security of Protocols with Probabilistic 
Encryption agains Offline Dictionary Attacks. Journal of Automated Reasoning 36: 85-124. Nov 2006. 
[33] V. Cortier, S. Kremer, R. K√ºsters and B. Warinschi, Computationally Sound Symbolic Secrecy in the 
Presence of Hash Functions. FSTTCS. 2006. 
[34] L. Mazar√©, An NP Decision Procedure for Generic Dolev-Yao Constraints with Atomic Keys. Nov 2004. 
[35] M. Bellare and P. Rogaway, The game-playing technique. Cryptology ePrint Archive, Report 2004/331, 
Dec 2004. 
[36] Catherine Meadows, The NRL protocol analyzer: An overview. Journal of Logic Programming, 
26(2):113-131, 1996. 
[37] S. Rigby D. Longley, An automatic search for security flaws in key management schemes. In Computers 
and Security, volume 11, pages 75-89, 1992.  
[38] M. Burrows, M. Abadi, and R. Needham, A logic of authentication. ACM Transactions on Computer 
Systems, Feb 1990. 
[39] B. C. Neuman and S. G. Stubblebine, A note on the use of timestamps as nonces. Operating System 
Review, 27(2):10-14, Apr 1993. 
[40] A. Aziz and W. Diffie, Privacy and authentication for wireless local area networks. IEEE Personal 
Communications, pages 25-31, 1994. 
[41] Li Gong, Roger Needham and R. Yahalom, Reasoning about belief in cryptographic protocols. 
Proceedings of the 1990 IEEE Computer Society Symposium on Research in Security and Privacy, pages 234-248, 
May 1990. 
[42] L. E. Moser, A logic of knowledge and belief for reasoning about computer security. Proceedings of the 
Computer Security Foundation Workshop II, pages 57-63, 1989. 
[43] D. Accorsi and L. Vigan√≤, Towards an awareness-based semantics for security protocol analysis. 
Electronic Notes in Theoretical Computer Science, volume 55. Elsevier Science Publishers, 2001. 
[44] C. Cremers, Scyther documentation. http://people.inf.ethz.ch/cremersc/scyther/index.html. 
 75 
[45] L. Paulson, The Inductive Approach to Verifying Cryptographic Protocols. Journal of Computer Security, 
6(1)85-128. 1998; 
[46] H. RueŒ≤ and J. Millen, Local Secrecy for State-Based Models. Formal Methods in Computer Security, 
CAV workshop. Jul 2000. 
[47] J. Thayer, J. Herzog, J. Guttman, Strand Spaces: Proving Security Protocols Correct. Journal of Computer 
Security, Volume 7, Issue 2-3:191-230, 1999. 
[48] Ran Canetti, Universally composable security: A new paradigm for cryptographic protocols. In Proc. 42nd 
IEEE Symp. on the Foundations of Computer Science. 2001. 
[49] R. Canetti, Y. Lindell, R. Ostrovsky and A. Sahai, Universally composable twoparty and multi-party 
secure computation. In Proc. ACM Symp. on the Theory of Computing, pages 494-503, 2002.  
[50] M. Backes, B. Pfitzmann and M. Waidner, A General Composition Theorem for Secure Reactive Systems. 
In Proceedings of the 1st Theory of Cryptography Conference (TCC 2004), volume 2951 of Lecture Notes in 
Computer Science, pages 336-354. Springer, 2004. 
[51] B. Pfitzmann and M. Waidner, A Model for Asynchronous Reactive Systems and its Application to Secure 
Message Transmission, In IEEE Symposium on Security and Privacy, pages 184-200. IEEE Computer Society 
Press, 2001. 
[52] Ran Canetti, Security and composition of cryptographic protocols: a tutorial (part I). ACM SIGACT News - 
Volume 37, Sep 2006. 
[53] M. Backes, B. Pfitzmann, and M. Waidner. A composable cryptographic library with nested operations 
(extended abstract). In Proc. CCS'03, pages 220-230, 2003. 
[54] J. Bryans and S. Schneider. CSP, PVS, and a recursive authentication protocol. In Proceedings of the 
DIMACS Workshop on Design and Formal Verification of Security Protocols, September 3-5 1997. Available at 
http://dimacs.rutgers.edu/Workshops/Security/. 
[55] B. Dutertre and S. Schneider. Using a PVS embedding of CSP to verify authentication protocols. In 
TPHOLS‚Äô97, 1997. 
[56] Mohamed Layouni, Jozef Hooman, and Sofi√®ne Tahar. Modeling and Verication of Leaders Agreement in 
the Intrusion-Tolerant Enclaves Using PVS. May 2003. 
[57] I. Cervesato. The Dolev-Yao intruder is the most powerful attacker. In Proceedings of the Sixteenth 
Annual Symposium on Logic in Computer Science, June 2001. 
[58] Joe Kilian. Founding Cryptography on Oblivious Transfer, Proceedings, 20th Annual ACM Symposium on 
the Theory of Computation (STOC), 1988. 
[59] Bruno Blanchet and Avik Chaudhuri. Automated Formal Analysis of a Protocol for Secure File Sharing on 
Untrusted Storage. In IEEE Symposium on Security and Privacy, May 2008. IEEE. 
[60] Bruno Blanchet. Automatic verification of correspondences for security protocols. Report 
arXiv:0802.3444v1, February 2008. Available at http://arxiv.org/abs/0802.3444v1. 
[61] Steve Kremer. Formal Verification of Cryptographic Protocols. Steve Kremer. MOdelling and VErifying 
parallel Processes (MOVEP‚Äô06), June 2006. Available at http://www.lsv.ens-
cachan.fr/Publis/PAPERS/PDF/kremer-movep06.pdf. 
[62] A. S. Troelstra, H. Schwichtenberg, Basic Proof Theory. Cambridge University Press 1996. 
[63] S. Owre and N. Shankar. The formal semantics of PVS. Technical report, SRI-CSL-97-2, Computer 
Science Laboratory, SRI International, Menlo Park, CA, August 1997. Available at http://pvs.csl.sri.com/. 
[64] M. Backes, B. Pfitzmann, and M. Waidner. Limits of the Reactive Simulatability/UC of Dolev-Yao 
Models with Hashes. Cryptology ePrint Archive, Report 2006/014 (http://eprint.iacr.org/2006/068), 2006. 
[65] M. Backes and C. Jacobi. Cryptographically sound and machine-assisted verification of security protocols. 
In Proc. 20th STACS, vol 2607 of Lecture Notes in Computer Science. Springer, 2003. 
[66] M. Backes, C. Jacobi, and B. Pfitzmann. Deriving cryptographically sound implementations using 
composition and formally verified bisimulation. In Proc. 11th FME, 2002.  
 76 
Anexo 1 ‚Äì Estat√≠sticas da 
Implementa√ß√£o em PVS 
A seguir, mostramos o status das teorias provadas. Estas informa√ß√µes s√£o geradas 
pelo PVS atrav√©s do comando prove-importchain, que executa todas as provas previamente 
realizadas em uma teoria, e em teorias importadas, inclusive provas de TCCs. A maioria 
dos TCCs √© provada automaticamente pelo PVS, por meio de estrat√©gias built-in. 
Entretanto, provamos 13 TCCs que n√£o puderam ser provados pelas estrat√©gias pr√©-
definidas do PVS. 
Proof summary for theory SecuritySufficiency 
    prot_to_gamma_wo_alpha0_TCC1..........proved - complete   [shostak](0.04 s) 
    gamma_from_prot_welldef...............proved - complete   [shostak](0.74 s) 
    extractN_protToGamma_property_TCC1....proved - complete   [shostak](0.01 s) 
    extractN_protToGamma_property.........proved - complete   [shostak](1.12 s) 
    rewriteGammaWithProtocolElements......proved - complete   [shostak](0.07 s) 
    gammaAlpha0Complements_TCC1...........proved - complete   [shostak](0.48 s) 
    gammaAlpha0Complements................proved - complete   [shostak](0.22 s) 
    opInSeqImpExistsMinpos................proved - complete   [shostak](0.67 s) 
    alpha0WithoutEyContainsOnlyEx_TCC1....proved - complete   [shostak](0.47 s) 
    alpha0WithoutEyContainsOnlyEx_TCC2....proved - complete   [shostak](0.04 s) 
    alpha0WithoutEyContainsOnlyEx.........proved - complete   [shostak](1.21 s) 
    alpha0_and_bal_secure.................proved - complete   [shostak](0.48 s) 
    Theory totals: 12 formulas, 12 attempted, 12 succeeded (5.55 s) 
 
 Proof summary for theory UserBalancingProperty 
    user_balanced?_TCC1...................proved - complete   [shostak](0.00 s) 
    linkage_property?_TCC1................proved - complete   [shostak](0.30 s) 
    sigma1_sat_link_property..............proved - complete   [shostak](2.76 s) 
    sigma2_3_sat_link_property............proved - complete   [shostak](4.50 s) 
    admissible_language_sat_link_property...proved - complete   [shostak](0.02 s) 
    balanced_prot_imp_linkage_in_sigmas...proved - complete   [shostak](0.90 s) 
    userBalancing.........................proved - complete   [shostak](1.27 s) 
    Theory totals: 7 formulas, 7 attempted, 7 succeeded (9.75 s) 
 
 Proof summary for theory UserMonoidCryptOps 
    seqDefWithOp_TCC1.....................proved - complete   [shostak](0.01 s) 
    normalseqZ?_TCC1......................proved - complete   [shostak](0.01 s) 
    reduzibleZimpliessize.................proved - complete   [shostak](0.02 s) 
    first_cancelableZ_TCC1................proved - complete   [shostak](0.02 s) 
    first_cancelableZ_TCC2................proved - complete   [shostak](0.03 s) 
    first_cancelableZ_TCC3................proved - complete   [shostak](0.04 s) 
    first_cancelableZ_TCC4................proved - complete   [shostak](0.32 s) 
    first_cancelableZ_TCC5................proved - complete   [shostak](0.31 s) 
    fc_boundZ.............................proved - complete   [shostak](0.51 s) 
    normalizeseqZ_TCC1....................proved - complete   [shostak](0.01 s) 
    normalizeseqZ_TCC2....................proved - complete   [shostak](0.04 s) 
    normalizeseqZ_TCC3....................proved - complete   [shostak](0.30 s) 
    normalizeseqZ_TCC4....................proved - complete   [shostak](0.03 s) 
    normalizeseqZ_TCC5....................proved - complete   [shostak](0.03 s) 
    normalizeseqZ_TCC6....................proved - complete   [shostak](0.30 s) 
    normalizeseqZ_is_normalized...........proved - complete   [shostak](0.11 s) 
    user_normalize_property...............proved - complete   [shostak](0.54 s) 
 77 
    crTyp_normalize_property..............proved - complete   [shostak](0.43 s) 
    subwords_preserve_operators...........proved - complete   [shostak](0.21 s) 
    normalization_preserves_operators.....proved - complete   [shostak](2.08 s) 
    fl_ops?_TCC1..........................proved - complete   [shostak](0.01 s) 
    fl_ops?_TCC2..........................proved - complete   [shostak](0.03 s) 
    Theory totals: 22 formulas, 22 attempted, 22 succeeded (5.39 s) 
  
 Proof summary for theory SecurityNecessity 
    suff_ab_TCC1..........................proved - complete   [shostak](0.04 s) 
    sub_alphabeta_ok......................proved - complete   [shostak](2.11 s) 
    suff_ab_prot_TCC1.....................proved - complete   [shostak](0.60 s) 
    suff_ab_prot_TCC2.....................proved - complete   [shostak](0.46 s) 
    suff_ab_prot_TCC3.....................proved - complete   [shostak](2.29 s) 
    alpha0_suff_eq_TCC1...................proved - complete   [shostak](0.37 s) 
    alpha0_suff_eq_TCC2...................proved - complete   [shostak](0.11 s) 
    alpha0_suff_eq........................proved - complete   [shostak](0.31 s) 
    extract_seq_from_triplet_TCC1.........proved - complete   [shostak](0.01 s) 
    extract_seq_from_triplet..............proved - complete   [shostak](0.04 s) 
    extract_triplet_as_composition........proved - complete   [shostak](0.84 s) 
    triplet_welldef.......................proved - complete   [shostak](0.14 s) 
    gamma_in_prot_suff....................proved - complete   [shostak](0.82 s) 
    unbalanced_implies_complement_in_sigma1...proved - complete [shostak](0.51 s) 
    extractable_op_TCC1...................proved - complete   [shostak](0.07 s) 
    extractable_op_TCC2...................proved - complete   [shostak](0.02 s) 
    extractable_op........................proved - complete   [shostak](2.10 s) 
    extractable_decUser...................proved - complete   [shostak](0.95 s) 
    suff_unbal_prot_is_unbal..............proved - complete   [shostak](1.04 s) 
    secProt_imp_alpha0ContainsE...........proved - complete   [shostak](0.28 s) 
    unbalanced_impl_insecure_At_0.........proved - complete   [shostak](4.94 s) 
    secure_impl_balanced..................proved - complete   [shostak](0.05 s) 
    Theory totals: 22 formulas, 22 attempted, 22 succeeded (18.10 s) 
 
 Proof summary for theory SecurityDefinitions 
    wellDefInSigma1_subalphas.............proved - complete   [shostak](0.34 s) 
    extract_gamma_TCC1....................proved - complete   [shostak](0.01 s) 
    extract_gamma_TCC2....................proved - complete   [shostak](0.02 s) 
    extract_gamma_TCC3....................proved - complete   [shostak](0.13 s) 
    correspondence_unbal_bal_alpbet.......proved - complete   [shostak](0.09 s) 
    unbalanced_property...................proved - complete   [shostak](0.20 s) 
    balanced_cascade_protocol?_TCC1.......proved - complete   [shostak](0.01 s) 
    correspondence_unbal_bal_prot.........proved - complete   [shostak](0.15 s) 
    unbalanced_prot_property..............proved - complete   [shostak](0.06 s) 
    alpha0ContainsE?_TCC1.................proved - complete   [shostak](0.76 s) 
    alpha0FunctionsEq.....................proved - complete   [shostak](0.16 s) 
    defGammaWithOp_TCC1...................proved - complete   [shostak](0.04 s) 
    defgammawithseq_TCC1..................proved - complete   [shostak](0.02 s) 
    normalize_extract.....................proved - complete   [shostak](0.26 s) 
    gammas_welldefs_imp_o_is_welldef......proved - complete   [shostak](0.87 s) 
    extractGammaAssoc.....................proved - complete   [shostak](0.75 s) 
    normalizegammacomplementnormal........proved - complete   [shostak](0.30 s) 
    normalseqgamma........................proved - complete   [shostak](0.38 s) 
    secure_eq_not_insecure_prot...........proved - complete   [shostak](0.05 s) 
    Theory totals: 19 formulas, 19 attempted, 19 succeeded (4.60 s) 
 
 Proof summary for theory CascadeProtocols 
    abUsers?_TCC1.........................proved - complete   [shostak](0.05 s) 
    length_TCC1...........................proved - complete   [shostak](0.06 s) 
    extract_eN_TCC1.......................proved - complete   [shostak](0.01 s) 
    extract_eN_TCC2.......................proved - complete   [shostak](0.03 s) 
    extract_eN_TCC3.......................proved - complete   [shostak](0.01 s) 
    ab_ok_imp_notempty....................proved - complete   [shostak](0.06 s) 
    prot_welldef_imp_notempty.............proved - complete   [shostak](0.11 s) 
    prot_has_length_greater_than_0........proved - complete   [shostak](0.13 s) 
 78 
    welldef_prot_all_users................proved - complete   [shostak](0.18 s) 
    welldef_prot_welldef_alpbet...........proved - complete   [shostak](0.03 s) 
    first_crypt_elem_TCC1.................proved - complete   [shostak](0.27 s) 
    first_crypt_elem......................proved - complete   [shostak](1.51 s) 
    Theory totals: 12 formulas, 12 attempted, 12 succeeded (2.45 s) 
 
 Proof summary for theory MonoidCryptOps 
    complementseq_TCC1...................proved - complete   [shostak]( 0.01 s) 
    areseqcomplements?_TCC1..............proved - complete   [shostak]( 0.07 s) 
    normalseq?_TCC1......................proved - complete   [shostak]( 0.01 s) 
    reduzibleimpliessize.................proved - complete   [shostak]( 0.04 s) 
    isreduziblewhenconcatenated..........proved - complete   [shostak]( 0.25 s) 
    opcomplements_eq.....................proved - complete   [shostak]( 0.05 s) 
    arecomplementswhenconcatenated_TCC1...proved - complete   [shostak]( 0.01 s) 
    arecomplementswhenconcatenated_TCC2...proved - complete   [shostak]( 0.13 s) 
    arecomplementswhenconcatenated_TCC3...proved - complete   [shostak]( 0.12 s) 
    arecomplementswhenconcatenated.......proved - complete   [shostak]( 0.11 s) 
    subSeqComplement_TCC1................proved - complete   [shostak]( 0.05 s) 
    subSeqComplement_TCC2................proved - complete   [shostak]( 0.06 s) 
    subSeqComplement.....................proved - complete   [shostak]( 1.02 s) 
    subSeqComplementNormal...............proved - complete   [shostak]( 0.84 s) 
    subSeqNormal.........................proved - complete   [shostak]( 0.31 s) 
    complements_of_uniform_seqs..........proved - complete   [shostak]( 0.25 s) 
    first_cancelable_TCC1................proved - complete   [shostak]( 0.03 s) 
    first_cancelable_TCC2................proved - complete   [shostak]( 0.02 s) 
    first_cancelable_TCC3................proved - complete   [shostak]( 0.02 s) 
    first_cancelable_TCC4................proved - complete   [shostak]( 0.32 s) 
    first_cancelable_TCC5................proved - complete   [shostak]( 0.30 s) 
    fc_bound.............................proved - complete   [shostak]( 0.36 s) 
    normalizeseq_TCC1....................proved - complete   [shostak]( 0.01 s) 
    normalizeseq_TCC2....................proved - complete   [shostak]( 0.02 s) 
    normalizeseq_TCC3....................proved - complete   [shostak]( 0.23 s) 
    normalizeseq_TCC4....................proved - complete   [shostak]( 0.01 s) 
    normalizeseq_TCC5....................proved - complete   [shostak]( 0.02 s) 
    normalizeseq_TCC6....................proved - complete   [shostak]( 0.41 s) 
    normal_normalized....................proved - complete   [shostak]( 0.78 s) 
    first_canc_greater_imp_normal........proved - complete   [shostak]( 0.85 s) 
    firstcancelablearecomplements_TCC1...proved - complete   [shostak]( 0.01 s) 
    firstcancelablearecomplements_TCC2...proved - complete   [shostak]( 0.03 s) 
    firstcancelablearecomplements........proved - complete   [shostak]( 0.91 s) 
    firstcancelableimpliesreduzible......proved - complete   [shostak]( 1.08 s) 
    first_cancelable_preserv2_TCC1.......proved - complete   [shostak]( 0.01 s) 
    first_cancelable_preserv2............proved - complete   [shostak]( 0.83 s) 
    first_cancelable_preserv3_TCC1.......proved - complete   [shostak]( 0.01 s) 
    first_cancelable_preserv3............proved - complete   [shostak]( 0.74 s) 
    characterization_f_canc_TCC1.........proved - complete   [shostak]( 0.10 s) 
    characterization_f_canc_TCC2.........proved - complete   [shostak]( 0.07 s) 
    characterization_f_canc..............proved - complete   [shostak]( 1.30 s) 
    first_normalize_TCC1.................proved - complete   [shostak]( 0.06 s) 
    first_normalize......................proved - complete   [shostak]( 0.09 s) 
    normalize_id.........................proved - complete   [shostak]( 1.05 s) 
    normalizedImpComplements.............proved - complete   [shostak]( 4.48 s) 
    normalize_general_TCC1...............proved - complete   [shostak]( 0.01 s) 
    normalize_general_TCC2...............proved - complete   [shostak]( 0.00 s) 
    normalize_general_TCC3...............proved - complete   [shostak]( 0.09 s) 
    normalize_general_TCC4...............proved - complete   [shostak]( 0.02 s) 
    normalize_general....................proved - complete   [shostak](20.72 s) 
    normalize_general_seq................proved - complete   [shostak]( 2.82 s) 
    normalization_complements............proved - complete   [shostak]( 2.14 s) 
    normalize_left.......................proved - complete   [shostak]( 0.02 s) 
    normalize_right......................proved - complete   [shostak]( 0.02 s) 
    normalizeRightCompl_TCC1.............proved - complete   [shostak]( 0.02 s) 
    normalizeRightCompl_TCC2.............proved - complete   [shostak]( 0.10 s) 
 79 
    normalizeRightCompl..................proved - complete   [shostak]( 0.37 s) 
    Theory totals: 57 formulas, 57 attempted, 57 succeeded (43.81 s) 
 
 Proof summary for theory finite_sequences_extras 
    first_TCC1............................proved - complete   [shostak](0.02 s) 
    rest_TCC1.............................proved - complete   [shostak](0.01 s) 
    insert_TCC1...........................proved - complete   [shostak](0.09 s) 
    insert_TCC2...........................proved - complete   [shostak](0.08 s) 
    identseq..............................proved - complete   [shostak](0.05 s) 
    identseq2_TCC1........................proved - complete   [shostak](0.01 s) 
    identseq2.............................proved - complete   [shostak](0.27 s) 
    eqseq_comm............................proved - complete   [shostak](0.02 s) 
    seqelem_comm..........................proved - complete   [shostak](0.06 s) 
    eqseq_tran............................proved - complete   [shostak](0.01 s) 
    empty_0...............................proved - complete   [shostak](0.09 s) 
    seqcompositionempty1..................proved - complete   [shostak](0.29 s) 
    seqcompositionempty2..................proved - complete   [shostak](0.11 s) 
    zerolengthempty.......................proved - complete   [shostak](0.00 s) 
    seq_first_rest_TCC1...................proved - complete   [shostak](0.01 s) 
    seq_first_rest........................proved - complete   [shostak](1.11 s) 
    inv_first_rest_TCC1...................proved - complete   [shostak](0.08 s) 
    inv_first_rest........................proved - complete   [shostak](0.37 s) 
    first_rest............................proved - complete   [shostak](0.53 s) 
    eqseq_cons_TCC1.......................proved - complete   [shostak](0.03 s) 
    eqseq_cons_TCC2.......................proved - complete   [shostak](0.01 s) 
    eqseq_cons............................proved - complete   [shostak](1.40 s) 
    eqseq_split...........................proved - complete   [shostak](0.58 s) 
    eqseq_reduce..........................proved - complete   [shostak](0.72 s) 
    eqseq_reduce2_TCC1....................proved - complete   [shostak](0.11 s) 
    eqseq_reduce2_TCC2....................proved - complete   [shostak](0.05 s) 
    eqseq_reduce2.........................proved - complete   [shostak](0.59 s) 
    eqseq_reduce3_TCC1....................proved - complete   [shostak](0.16 s) 
    eqseq_reduce3_TCC2....................proved - complete   [shostak](0.01 s) 
    eqseq_reduce3.........................proved - complete   [shostak](0.31 s) 
    eqseq_reduce4_TCC1....................proved - complete   [shostak]( n/a s) 
    eqseq_reduce4_TCC2....................proved - complete   [shostak]( n/a s) 
    eqseq_reduce4.........................proved - complete   [shostak](1.10 s) 
    eqseq_equivalence_TCC1................proved - complete   [shostak](0.15 s) 
    eqseq_equivalence.....................proved - complete   [shostak](0.80 s) 
    eqop_comp_TCC1........................proved - complete   [shostak](0.11 s) 
    eqop_comp.............................proved - complete   [shostak](0.09 s) 
    eqop_comp2............................proved - complete   [shostak](0.00 s) 
    eqop_comp3_TCC1.......................proved - complete   [shostak](0.13 s) 
    eqop_comp3............................proved - complete   [shostak](0.12 s) 
    eqop3_comp_TCC1.......................proved - complete   [shostak](0.12 s) 
    eqop3_comp_TCC2.......................proved - complete   [shostak](0.15 s) 
    eqop3_comp_TCC3.......................proved - complete   [shostak](0.18 s) 
    eqop3_comp............................proved - complete   [shostak](0.46 s) 
    o_assoc2A.............................proved - complete   [shostak](0.02 s) 
    o_assoc2B.............................proved - complete   [shostak](0.00 s) 
    o_assoc3..............................proved - complete   [shostak](0.01 s) 
    seq_elem_preserve_TCC1................proved - complete   [shostak](0.13 s) 
    seq_elem_preserve_TCC2................proved - complete   [shostak](0.01 s) 
    seq_elem_preserve.....................proved - complete   [shostak](0.14 s) 
    seq_preserve_TCC1.....................proved - complete   [shostak](0.12 s) 
    seq_preserve..........................proved - complete   [shostak](0.91 s) 
    seq_preserve2.........................proved - complete   [shostak](0.76 s) 
    seq_preserve3_TCC1....................proved - complete   [shostak]( n/a s) 
    seq_preserve3_TCC2....................proved - complete   [shostak]( n/a s) 
    seq_preserve3.........................proved - complete   [shostak](0.50 s) 
    seq_commute_TCC1......................proved - complete   [shostak](0.02 s) 
    seq_commute...........................proved - complete   [shostak](0.00 s) 
    seq_commute2_TCC1.....................proved - complete   [shostak](0.14 s) 
 80 
    seq_commute2..........................proved - complete   [shostak](1.83 s) 
    pos_in_seq_preserve_TCC1..............proved - complete   [shostak](0.22 s) 
    pos_in_seq_preserve...................proved - complete   [shostak](0.56 s) 
    Theory totals: 62 formulas, 62 attempted, 62 succeeded (15.96 s) 
 
 Proof summary for theory CascadeProtocolsSecurity 
    theorem1..............................proved - complete   [shostak](0.03 s) 
    Theory totals: 1 formulas, 1 attempted, 1 succeeded (0.03 s) 
 
Grand Totals: 214 proofs, 214 attempted, 214 succeeded (105.64 s) 
Das 214 provas verificadas acima, temos 106 TCCs e dois axiomas, em cujas provas 
estamos atualmente trabalhando. Estes axiomas s√£o linkage_property_composition e 
linkage_normalized, e n√£o foram computados pelo PVS na estat√≠stica de provas mostrada. 
O desenvolvimento completo roda em PVS 4.1 e a especifica√ß√£o foi realizada em 1211 
linhas (55 KB) e 22876 linhas (1.4 MB) de provas. 
  
 81 
Anexo 2 ‚Äì Quebra do Protocolo de 
Needham-Schroeder 
Para descrever o processo no qual o protocolo de Needham-Schroeder √© quebrado, 
utilizaremos a seguinte nota√ß√£o: 
‚Ä¢ A, B e Z denotam os participantes de uma rede de comunica√ß√£o, sendo Z o 
advers√°rio, usualmente limitado pelas primitivas criptogr√°ficas. 
‚Ä¢ A  B : Indica que A envia uma mensagem para B. 
‚Ä¢ Z(A): Significa que Z est√° personificando ou ‚Äúse passando por‚Äù um participante A. 
‚Ä¢ nX denota um n√∫mero aleat√≥rio (nonce) criado pelo participante X. 
‚Ä¢ pkX e pkX-1 denotam as chaves de um participante X. pkX √© chamada chave p√∫blica e 
pkX-1 chave privada. 
‚Ä¢ {m1, m2}pkX: Mensagem encriptada com chave pkX, contendo a informa√ß√£o m1 
concatenada √† informa√ß√£o m2. m1 e m2 podem ser um nonce ou a identifica√ß√£o de um 
participante do protocolo. 
 
Figura 5: Funcionamento do protocolo de Needham-Schroeder. 
Admite-se que as chaves privadas sejam conhecidas somente pelos seus 
propriet√°rios, ou seja, somente um participante X conhece a chave privada pkX-1. No passo 
1 do protocolo, o usu√°rio A envia para B uma mensagem com um nonce nA e seu 
identificador. Esta mensagem est√° encriptada com a chave p√∫blica de B. No passo 2, B 
envia para A um nonce nB e tamb√©m nA, provando a A que B aprendeu nA. Neste momento, 
 82 
B prova a A que sua identidade √© a mesma que a esperada por A. No passo 3, A prova a B 
sua identidade, atrav√©s do envio de nB recebido no passo 2.  
O ataque man-in-the-middle ao protocolo de Needham-Schroeder, descoberto por 
Lowe, em [5], √© mostrado abaixo.  
 
Figura 6: Quebrando o protocolo de Needham-Schroeder. 
Z personifica A para se autenticar com B, utilizando informa√ß√µes de sua sess√£o com 
A. No ataque, a mensagem do passo 1 do protocolo √© enviada de A para Z, e Z envia os 
mesmos dados da mensagem recebida para B, como se fosse A. B, ao responder para o 
falso A, espera ter de volta o nB enviado, para comprova√ß√£o de que est√°, efetivamente, se 
comunicando com A. O problema de Z, personificando A, se autenticar com B sem possuir 
pkA-1, est√° em Z responder corretamente ao desafio proposto por B, que consiste em esperar 
que A decripte nB e envie-o de volta a B. E isso pode ser feito, pois Z, durante a 
autentica√ß√£o com A, envia a mensagem que cont√©m o desafio de B. Implicitamente no 
protocolo, o participante A acredita que nB tenha sido gerado por Z e ‚Äúrevela‚Äù a Z este nB no 
passo 5. Assim, Z, que se autenticou com A, pode se autenticar tamb√©m com B. Do ponto 
de vista de B, a seq√º√™ncia de mensagens √© exatamente a esperada de um participante A que 
tenha iniciado o protocolo. 
A falha deste protocolo poderia resultar na seguinte situa√ß√£o: 
Se A √© um indiv√≠duo honesto, Z √© um comerciante on-line embusteiro e B √© o 
banco de A, ent√£o, quando A executar o protocolo para se autenticar com Z para 
iniciar uma compra, Z ter√° se autenticado com B, o banco de A, podendo Z, 
denotado por Z(A), prosseguir com opera√ß√µes banc√°rias, se passando por A. 
