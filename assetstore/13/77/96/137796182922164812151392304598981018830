Deutsches Forschungszentrum für Künstliche Intelligenz GmbH

Research Report
RR-90-02

A Resolution Principle for Clauses with Constraints
Hans-Jürgen Bürckert
March 1990

Deutsches Forschungszentrum für Künstliche Intelligenz GmbH

Postfach 20 80 67608 Kaiserslautern, FRG Tel.: (+49 631) 205-3211/13 Fax: (+49 631) 205-3210

Stuhlsatzenhausweg 3 66123 Saarbrücken, FRG Tel.: (+49 681) 302-5252 Fax: (+49 681) 302-5341

Deutsches Forschungszentrum für
Künstliche Intelligenz
The German Research Center for Artificial Intelligence (Deutsches Forschungszentrum für Künstliche Intelligenz, DFKI) with sites in Kaiserslautern and Saarbrücken is a non-profit organization which was founded in 1988. The shareholder companies are Atlas Elektronik, Daimler-Benz, Fraunhofer Gesellschaft, GMD, IBM, Insiders, Mannesmann-Kienzle, SEMA Group, and Siemens. Research projects conducted at the DFKI are funded by the German Ministry for Research and Technology, by the shareholder companies, or by other industrial contracts.
The DFKI conducts application-oriented basic research in the field of artificial intelligence and other related subfields of computer science. The overall goal is to construct systems with technical knowledge and common sense which - by using AI methods - implement a problem solution for a selected application area. Currently, there are the following research areas at the DFKI:
J Intelligent Engineering Systems J Intelligent User Interfaces J Computer Linguistics J Programming Systems J Deduction and Multiagent Systems J Document Analysis and Office Automation.
The DFKI strives at making its research results available to the scientific community. There exist many contacts to domestic and foreign research institutions, both in academy and industry. The DFKI hosts technology transfer workshops for shareholders and other interested groups in order to inform about the current state of research.
From its beginning, the DFKI has provided an attractive working environment for AI researchers from Germany and from all over the world. The goal is to have a staff of about 100 researchers at the end of the building-up phase.
Friedrich J. Wendl Director

A Resolution Principle for Clauses with Constraints
Hans-Jürgen Bürckert
DFKI-RR-90-02

A short version of this paper has been published in the Proceedings of 10th Conference on Automated Deduction, Springer LNCS, 1990
© Deutsches Forschungszentrum für Künstliche Intelligenz 1993 This work may not be copied or reproduced in whole or in part for any commercial purpose. Permission to copy in whole or in part without payment of fee is granted for nonprofit educational and research purposes provided that all such whole or partial copies include the following: a notice that such copying is by permission of Deutsches Forschungszentrum für Künstliche Intelligenz, Kaiserslautern, Federal Republic of Germany; an acknowledgement of the authors and individual contributors to the work; all applicable portions of this copyright notice. Copying, reproducing, or republishing for any other purpose shall require a licence with payment of fee to Deutsches Forschungszentrum für Künstliche Intelligenz.

A Resolution Principle for Clauses with Constraints
Hans-Jürgen Bürckert
DFKI, Project Group WINO Postfach 2080, D-6750 Kaiserslautern, FR Germany
e-mail: buerkert@informatik.uni-kl.de
Abstract: We introduce a general scheme for handling clauses whose variables are constrained by an underlying constraint theory. In general, constraints can be seen as quantifier restrictions as they filter out the values that can be assigned to the variables of a clause (or an arbitrary formulae with restricted universal or existential quantifier) in any of the models of the constraint theory. We present a resolution principle for clauses with constraints, where unification is replaced by testing constraints for satisfiability over the constraint theory. We show that this constrained resolution is sound and complete in that a set of clauses with constraints is unsatisfiable over the constraint theory iff we can deduce a constrained empty clause for each model of the constraint theory, such that the empty clauses constraint is satisfiable in that model. We show also that we cannot require a better result in general, but we discuss certain tractable cases, where we need at most finitely many such empty clauses or even better only one of them as it is known in classical resolution, sorted resolution or resolution with theory unification.
Key words: Resolution, unification, constraint solving, restricted quantification
Table of Contents
1. Introduction.................................................................................... 2 2. Syntax ............................................................................................6 3. Semantics......................................................................................10 4. Resolution with Restricted Quantifiers ............................................. 12 5. Consequences and Discussion......................................................... 16 6. Related Work ................................................................................20 7. Conclusion....................................................................................22 References ..........................................................................................23

2 Resolution with Restricted Quantifiers
1. Introduction
A general observation of Artificial Intelligence (AI) research – although it often has not really been realized in many AI systems – is the fact that the knowledge of an AI system about some problem solving task could be separated into at least two parts:
® A well acquainted part of the problem description: Here the system has procedures and facts to treat these problem constraints. In this background part reasoning might be done by calculation and simplification of subgoals, by looking up facts and results in its memory, in a database or anywhere else.
® A more inacquainted part of the problem description: Here the system does not dispose of many techniques and facilities of finding a solution. In this foreground part deep reasoning might be necessary, often just by a more or less “blind” search, in order to find solutions to subgoals –ּperhaps only guided by certain general heuristics.
Now, in the field of Automated Deduction many common automated theorem proving systems or logic programming languages do not support or still worse they completely ignore this separation. They apply standard resolution based deduction methods (with frequently very unsatisfying search procedures) to the whole problem: The description given in a first order predicate logic is transformed into clauses. Hence the structure of the given problem specification is completely destroyed also for those parts, where the system could use standard techniques like integer calculation, linear equation solving etc., if it would know them.
First approaches to separating the knowledge this way are extensions of resolution with paramodulation (Wos & Robinson 1970) or other methods of equality handling, with sort unification (Walther 1983, 1987, Frisch 1989, Schmidt-Schauß 1989), with theory unification (Plotkin 1972, Siekmann 1989) and more general with theory resolution (Stickel 1985, Ohlbach 1986). Sort unification is a very simple way of separating by syntactical phrases rather than by problem oriented reasons; similar for theory unification and paramodulation at least in its use today. Theory resolution provides for a problem oriented separation and takes advantage in allowing special procedures to treat the background parts of the problem. However, it still cuts down the background constraints to literals of clauses, and hence has to apply also search techniques to find the constraints that could be treated by the procedures of the background theories.
In the logic programming area such approaches of replacing “blind” search by computation has also been developed or adapted. However, standard techniques such as theory unification (Gallier & Raatz 1986, Jaffar et al. 1986) or sort unification (Goguen & Meseguer 1984, Smolka et al. 1989) are not exploited in most logic programming languages, especially not in commercial ones. Methods similar to Stickel’s theory resolution are proposed

A Resolution Principle for Clauses with Contraints

3

for constraint logic programming languages (Jaffar & Lassez 1986, Dincbas et al. 1988, Höhfeld & Smolka 1988, Smolka 1989). Origins of these ideas can already be found in (Colmerauer 1984). In these approaches, parts of problem descriptions, where very fast solution algorithms are known, are taken as constraints to be solved by such special constraint solving algorithms over distinguished domains – for example, linear equations and inequations over the real numbers.

We argue that this is the right direction for future research: Considering parts of the problem as constraints and restricting their interpretation to a distinguished class of given models. However, the two approaches, theory resolution and constraint logic programming, are not general enough.1

Before we describe how to generalize these approaches let us first recall Robinson's Resolution Principle and then develop that new view of considering the unification part as constraint solving.

The Resolution Principle is based on the following inference rule: From (A ∨ B) and (¬A ∨ C) infer (B ∨ C)

The rule is obviously correct: If (A ∨ B) and (¬A ∨ C) are true, then the resolvent (B ∨ C) is also true. Since either A is false, then B must be true, or A is true, then C must be true, and hence in any case (B ∨ C) must be true.

For predicate logic the two complementary A ’s are atoms starting with the same predicate symbol, but with potentially different argument terms, say si and ti (1 ≤ i ≤ n). Then one has to unify corresponding arguments of the literals A and ¬ A – that is to find substitutions for the variables that make the corresponding argument terms identical – before the conclusion can be drawn, and the resolvent has to be instantiated with the unifying substitution:

ּ ּ P(s1 ,…,sn) ∨ B ¬ּ P(t 1,…,tn) ∨ C ———————ּּ
ּ ּ σ(B ∨ C)

if σsi = σti (1 ≤ i ≤ n)

Robinson showed that this rule (combined with factorization) provides a complete calculus (Robinson 1965). An analysis of the soundness and completeness proof, however, shows that it is not necessary to unify the terms. It would be enough to test whether they are

1 Stickel (1985) and Ohlbach (1986) consider theory resolution for arbitrary clauses, but with the (implicit) requirement that the background theory has a first order axiomatization – otherwise, their completeness proofs based on the Herbrand Theorem would not be correct. Höhfeld & Smolka (1988) on the other hand allow arbitrary classes of models as background theories – and thus generalize the approach of CLP (Jaffar & Lassez 1987) which restricts the constraint theory to be a single model –, but as in CLP they only consider definite clauses over these constraint theories.

4 Resolution with Restricted Quantifiers

unifiable, provided we add a constraint Γ consisting of term equations si = ti (saying “if the terms can be made equal”) to the infered resolvent. Whenever such constrained resolvents are now involved in a further resolution step the new resolvent inherits their constraints together with the new argument term equations. Now, these collected constraints have to be tested for unifiability. Thus a resolution step in this modification takes two clauses with such equational constraints and produces a resolvent with a new unifiable equational constraint consisting of the constraints inherited from its parents together with the argument equations for the involved complementary literals.

ּ P(s1,…,sn) ∨ Bּ||ּΓ ¬ּ P(t 1,…,tn) ∨ Cּ||ּ ∆ ———————————ּif
B ∨ Cּ||ּΓ ∧ ∆ ∧ si = t i

Γ ∧ ∆ ∧ s i =ti is unifiable

A more general view is that every clause might have some arbitrary, not necessarily equational constraint and a resolvent of two clauses gets a new constraint that is unsatisfiable whenever one of the constraints of the parents (or the equational constraint of the arguments of the complementary literals) is unsatisfiable.

ּ P(s1 ,…,sn) ∨ Bּ||ּR ¬ּ P(t 1,…,tn) ∨ Cּ||ּS ———————————ּif
B ∨ Cּ || Rּ ∧ S ∧ si = t i

R ∧ S ∧ s i =ti is satisfiable

It is quite easy to see that this constrained resolution principle is again sound2, but as in the classical case completeness of a constrained resolution calculus is not straight forward.

The logical view of foreground and background problem descriptions hence could be as follows: There is a set of formulae with a query to be answered or a theorem to be proved or the set itself has to be tested for unsatisfiability. Some of these formulae are axioms of a background theory and parts of the other formulae are constraints that must be solved in the background theory. Here many consequences could be given as well-known or “easy” to verify: 3
® There are lemmata and theorems proven in the past.
® There are techniques to simplify complex constraints into constraints that are immediate consequences of known results or facts.

2 The argument is quite the same as for classical resolution, if all constraints are true. In the case that any of the constraints is false, the constraint of the resolvent must be false, and hence the resolvent is trivially true (a constrained formula is interpreted as true, when its constraint is false).
3 Of course this might not always work, as the constraints might state really hard problems of the background theory. However, solving these should no longer be part of the given task, but could open up a new problem perhaps with a new separation into background and foreground knowledge.

A Resolution Principle for Clauses with Contraints

5

® There is a tool of standard proof techniques of the field that can be used to prove constraints, which cannot be reduced.
In order to state a little more precisely what we are going to investigate, let us give a formal description, abstracting from (for a practical realization necessary and very interesting, but for theoretical considerations of a constrained resolution principle more or less irrelevant) part of the above presentation, namely, the satisfiability test for the constraints. Furthermore we are going to be a little more general: the background theory need not be given by axioms but just as any class of models.
Hence, let us assume the problem description to be given by a class of structures over a first order language4 and a set of formulae over a foreground language, such that each of these formulae is constrained by some formulae of the background language. These constraints filter out the values from models of the background theory the variables of the foreground formulae can be assigned to.
Thus, in this view our constraints are restrictions of the quantifiers (Hailperin 1957) – this is one way sorted logic has been viewed (Oberschelp 1962, Walther 1987, Frisch 1989, Schmidt-Schauß 1989). Therefore we could also describe it in the following way: We are given a (foreground) language with the logical connectives and a signature of non-logical symbols, but with restricted quantifiers instead of common quantifiers. Their restrictions are given as certain formulae over a (background) language and these restriction formulae have to be interpreted in the background theory.
Example: The formula ∀x,y:parent(x)ּ ∧ּchild -of(y,x) loves(x,y) might be a formalization of the sentence “All parents love their children”, when we have a suitable background theory containing knowledge about parents and their children. The constraint parent(x) ∧ child-of(y,x) restricts the possible values of the variables x and y to parents and their
children. Ò
We assume that our set of formulae describing the problem is transformed into a set of constrained clauses5 consisting of literals over the foreground language and constraints restricting the variables of the clause by formulae of the constraint language. Applying the constrained resolution rule given above to this set of constrained clauses we want to prove the unsatisfiability of the clause set – i.e., that no model of the constraint theory will satisfy it.
A closer look at this task shows that this cannot be done by deriving an empty clause as in the classical resolution calculus or its generalizations. The reason is that such an empty clause might still have some constraints, which are only satisfied by some of the constraint
4 For instance, this could be the class of all models of some axioms specifying the background theory. 5 This transformation could of course be tedious, and it provides several problems, essentially stemming from the fact that the restriction of a quantifier could describe an empty set of admissible assignments in some constraint models (empty quantification).

6 Resolution with Restricted Quantifiers
models, but not by all of them. In classical resolution the derivation of the empty clause could be seen as a derivation of false from the starting clause set, but here it is just a derivation of false within those models that satisfy the constraints of the empty clause.
But, how could we then get a refutation for an unsatisfiable set of constrained clauses? Let us briefly try to analyse, what the notion of unsatisfiability means here: No model of the constraint theory satisfies the clause set. The argumentation for classical resolution was: Suppose we have a model of the clause set, then it is a model of every resolvent and hence of the empty clause, which is impossible. The analogous argument cannot work in our framework, as the supposed model could be one of those that do not satisfy the constraints of the empty clause. Hence, our solution is to construct for each constraint model a suitable empty clause whose restriction is satisfied by that model: A set of constrained clauses is unsatisfiable iff for each constraint model there is a refutation of an empty clause, whose constraint is satisfied by that constraint model.
This result looks very unsatisfactory, and in fact it is in the general case, but we cannot require a better result in general (see section 5). Fortunately, there are tractable cases (as we already know from the past): for example the constraint theory of classical resolution, which is the set of all structures or equivalently (for clause sets) the set of all Herbrand structures. We will discuss this and some other interesting cases later in more detail. Here in the introduction we will just give the general idea: In case of a constraint theory with first order axiomatization we need at most finitely many empty clauses, such that the disjunction of their restriction is true in all constraint models. This is a consequence of the first order axiomatization and follows essentially from compactness of first order logics. Such a refutation could be obtained by exhaustive search strategies (cf. Kowalski 1979). Still better, if the constraint theory is given by a set of definite clauses and the constraints are conjunctions of atoms only, then the derivation of a single empty clause provides a refutation. This follows from the least Herbrand model property of definite clauses.
The paper is organized as follows. In section 2 we introduce our language consisting of a restricted quantifier or constraint system, a signature with restricted quantifiers and formulae over this signature. In section 3 we give the semantics of formulae with restricted quantifiers. Section 4 contains our main result, soundness and completeness for resolution with constrained clauses, and in section 5 we discuss some special cases and consequences of our result.
2.ּSyntax
Following our separation idea we first introduce the background theory and the restriction formulae as a system for restricted quantification. In logic programming applications this is

A Resolution Principle for Clauses with Contraints

7

known as a constraint system, i.e., a constraint theory together with a set of constraints, the restriction formulae (Höhfeld & Smolka 1988).6
We require the reader to be familiar with the notions and notations of mathematical logics, automated deduction, and logic programming (cf. Shoenfield 1967, Chang & Lee 1973, Loveland 1978, Kowalski 1979, Lloyd 1984, Gallier 1986, Bläsius & Bürckert 1989). For the notations of unification theory that are essentially based on equational logic and universal algebra, we refer the reader to (Kirchner 1989), especially to the survey of Siekmann (1989).
A restricted quantification system (RQS) ℜ consists of
® a signature ∆ with equality
® a theory over ∆, the restriction theory,
® a set of open ∆-formulae, the restriction formulae or restrictions.
The restrictions must at least be closed under conjunction and under instantiation of
variables. The restriction theory can be given as a distinguished class R of ∆-structures. The
theory provides not only the models for the restriction, but also “skeletons” for the models of
the whole problem description. Observe, that we do not require R to be a first order theory, as there might be no first order axiomatization with exactly the ∆-structures of R as its models. However, R could of course be given by some ∆-axioms, which are then called declarations of R. For computational reasons it would be useful to have calculi, preferably
decision procedures, in order to detect
® R-(un)satisfiability of the existential closures of the restriction formulae ® R-validity of sets of existentially closed restriction formulae7 .
This might be done by a “simplification” calculus for R: a distinguished set of simple
restrictions together with a procedure that can transform non-simple restrictions into simple
restrictions for which R-satisfiability or R-validity is known or easy to check.
2.1 Examples: (1) An order-sorted signature is an RQS, when we define R to be the class
of all models of the sort declarations (given as a sort theory, cf. Frisch, 1989) and when the set of restrictions contains besides the well-sorted equations the open formulae S(x) for each sort symbol S, i.e., it consists of conjunctions of equations and sort restrictions S(x) for their
variables. Notice, that the existential closures of sort restrictions S(x) are R-valid, if sorts are
required to be non-empty (i.e., if for each sort symbol S there is a ground term t, such that S(t) is explicitely declared or follows from the sort theory).
Suppose we have the following sort hierarchy given by the declarations in the right box:
6 We frequently will use these notions synonymously for RQS, restriction theory and restrictions.
7 A set F of formulae is valid in a theory R if for each model of R there is a formula in the set F, that is satisfied
by this model. Hence it is the natural generalization of validity of disjunctions of formulae.

8 Resolution with Restricted Quantifiers

person

parent
mary

child
john

∀x parent(x) ⇒ person(x) ∀x child(x) ⇒ person(x)
parent(mary) child(john)

Here the restriction theory R is the class of all models A, where the denotation SA of a given unary predicate – i.e. a sort symbol – is a subset of the carrier of A satisfying the intended
subset and element relations (parentA and child A are subsets of person A; mary A is an element of parentA and john A is an element of childA). Obviously, the existential closures of sort
restrictions are R-valid, as every sort contains a constant.
Sort unification algorithms play the role of simplification calculi, if the equational forms of well-sorted substitutions together with the sort restrictions of their variables are simple
restrictions, whose existential closures are trivially R-valid. Obviously, sort unifiability of restrictions (i.e., sorted unification problems) is equivalent to R-validity of their existential
closures.
(2) An equational theory E can be seen as the restriction theory of an RQS, whose restrictions are conjunctions of equations (i.e. unification problems). Here either R is the class of all models of the theory E or R is just the initial algebra or the free algebra of E. 8 An
E-unification algorithm would be a suitable simplification calculus with substitutions as simple
restrictions. Notice again, that E-unifiability of restrictions is equivalent to R-validity of their existential closures and that idempotent substitutions are always R-valid restrictions.
(3) As a special case, remember the empty equational theory of syntactical equality, for which
the well-known Robinson unification algorithm is a simplification algorithm. In this case, R is
the class of all algebras over the given signature ∆ or the corresponding free or the initial algebra, i.e., the usual term algebra or ground term algebra (i.e. the Herbrand universe).
Notice again Example 3.2(1).Ò
A signature with restricted quantifiers or an R Q-signature Σ consists of an
RQS ℜ, together with an additional set of predicate symbols PΣ and possibly a set of function symbols FΣ both disjoint from the signature ∆.9 If the set F Σ of Σ-function symbols is not
8 These three RQS are in some sense equivalent. However, this is only true for clauses not for arbitrary formulae, cf. Example 3.2(1). 9 In order to simplify our notation we will use the prefix “Σ-” if we denote these symbols or objects –ּterms, atoms, formulae, etc. – that are built up by the additional symbols only.

A Resolution Principle for Clauses with Contraints

9

empty, we have to extend our set of restrictions, such that it contains in addition all equations built up by the new function symbols. Thus we can assume without loss of generality that the new function symbols are already part of the RQS and the RQ-signature contains only new predicate symbols.10
Given such an RQ-signature Σ we want to define formulae with restricted quantifiers over this RQ-signature. Therefore we allow quantifiers to be indexed not only by variables, but by pairs of a variable set and a restriction formula (e.g. ∀X:R and ∃X:R), and we call them restricted quantifiers. Thus we define R Q-formulae over Σ by
(1) all Σ-atoms are RQ-formulae (2) ∀X:R F and ∃X:R F are RQ-formulae, if F is an RQ-formula, R is a restriction, and
X is the sequence or set of variables that are not bound in R, (3) ∀X F, ∃X F, F ∧ G, F ∨ G, F ⇒ G, F ⇔ G are RQ-formulae, if F and G are
RQ-formulae, and X is the sequence or set of variables that are not bound in F.
Notice, that in definition (2) the formula F might contain free variables of X that are now bound by the restricted quantifiers∀X:R or ∃X:R; the formula R is called the restriction for those variables. We often drop the restricted variables and write ∀R F instead of ∀X:R F.
As in the standard case we will deal with clauses, called RQ-clauses or constrained clauses; they consist of any (possible empty) finite set C of Σ-literals, i.e., a common Σclause, and a restricted quantifier ∀X:R of their variables, frequently written C || R instead of ∀R C. We call C the matrix or the kernel of the RQ-clause and R its restriction or
constraint. If C is empty we call it an empty RQ-clause, denoted ∆ || R or ∀R ∆.
2.2 Examples: (1) Taking the sort signature from Example 2.1(1) and the binary predicate symbols loves and child-of, the RQ-formula
∀x:parent(x) ∀y:child(y) child-of(y, x) ⇒ loves(x, y)
is a formalization of the English sentence “All parents love their children.”
(2) In fact the formula intends a little more, namely, that the children are still “young persons” (i.e., have sort child). In order to be closer to the meaning of the sentence, we could replace the sort child in the RQS by the binary predicate symbol child-of now considered as a symbol of the RQS and perhaps have the declaration in the modified RQS
∀x,y child-of(y,x) ⇒ parent(x) ∧ person(y)
such that our RQ-formula looks like ∀x:parent(x) ∀y:child-of(y,x) loves(x, y)
10 Extending the restrictions with the new function symbols requires also an expansion of the restriction theory with these new symbols, as we have to interpret the extended restriction formulae.

10 Resolution with Restricted Quantifiers
which seems to be a more adequate formalization of “All parents love their children.”
(3) If the RQ-signature is given over an RQS defined by an equational theory as in Example 2.1(2), we obtain the RQ-formulae corresponding to the common formulae without restricted quantifiers by unfolding: We replace each term t in an atom by a new variable v and replace the quantifier governing the term by a restricted quantifier with the restriction v = t. For example, given an equational theory of an associative and commutative function symbol f, a free constant a, and a unary free function symbol g, a formula ∀x,y P(g(f(x, y)), f(x, a)) with
a binary predicate P, becomes the RQ-formula ∀x,y,v,w: v=g(f(x, y)) ∧ w =f(x, a) P(v, w).Ò
3.ּSemantics
The interpretation of the RQ-formulae and especially the restricted quantification causes no deep problems. The semantics of restricted quantifiers can be given by the usual relativization, that is, one could transform any RQ-formula into an equivalent formula without restricted quantifiers by
replacing ∀X:R F by ∀X R ⇒ F replacing ∃X:R F by ∃X R ∧ F However, as we already know the ∆-models given in the RQS, we have to say what our Σ-models should look like. We have to interpret additionally the new predicates of the RQ-signature. Recalling the notion of structure expansions (cf. Shoenfield 1967) we interpret RQ-formulae in structures that expand the ∆-structures of the restriction theory to the new symbols of Σ, such that the variables of a restricted quantifier are assigned by elements of these structures that have to satisfy the restriction. Let us define this more precisely.
An RQ-structure over Σ is a structure A such that its reduct A|∆ to ∆ is one of the ∆-models in R.11 As we assumed Σ to introduce only new predicate symbols, but no function
symbols, we obtain the different RQ-structures by expanding every model of the restriction theory with all possible interpretations of these new predicate symbols. If the restriction
theory R is given by a ∆-axiomatization, RQ-structures are exactly those structures that satisfy the axioms of R considered as formulae over the extended signature. Obviously the
class of all RQ-structures is a conservative extension of the restriction theory: A restriction is
R-valid iff it is satisfied by every RQ-structure.
Given an RQ-structure A, an (open) RQ-formula F , and an assignment α: V → A of the set V of free variables of the formula F, we define satisfiability of F in A with α (written (A ,ּα) 7§ F ) as usual for atoms and formulae built up by the common junctors. The only
11 A reduct of a structure to a subsignature is given by forgetting about the denotations of the symbols that are not in the subsignature. Conversely, an expansion of a structure to a supersignature is given by any interpretation of the additional symbols.

A Resolution Principle for Clauses with Contraints

11

cases that are new are formulae with restricted quantifiers and we give their semantics here explicitely:

® (A, α) 7§ ∀X:R F

iff

for every assignment β: X → A with ( A| ∆, α∪β) 7§ R

we have (A, α∪β) 7§ F

® (A, α) 7§ ∃X:R F

iff

there is an assignment β: X → A with (A|∆, α∪β) 7§ R

such that (A, α∪β) 7§ F

A closed RQ-formula F is RQ-satisfiable, iff there is an RQ-structure that satisfies F with the empty assignment; otherwise F is called RQ-unsatisfiable. The formula F is RQ-valid or an RQ-tautology, iff it is satisfied by every RQ-structure. Notice that formulae with
R-unsatisfiable restrictions can be viewed as quantified over the empty set, hence such
formulae are true in every RQ-structure: they are RQ-tautologies.

3.2 Examples: (1) In case of an RQS given by the empty equational theory (Example 2.1(3)), the RQ-structures are the usual structures considered as the expansions of algebras – the models of equational theories – with predicate symbols. We could also take the Herbrand universe as restriction theory; the RQ-structures are then just the Herbrand models. However, this semantics has to be used with caution, as Herbrand models can only play the rôle of semantics, when we only consider formulae that are in clause form. Thus, as long as we allow arbitrary RQ-formulae, the RQS for the empty theory given by all algebras cannot equivalently be replaced by the RQS of the Herbrand universe.

(2) If the RQS is given by an arbitrary equational theory (cf. Example 2.1(2)) and the restriction theory consists of the initial algebra of this theory, the RQ-structures are the Herbrand models factored by the congruence, which is induced by the equational theory.

(3) The models of order-sorted signatures are exactly the RQ-structures over the corresponding RQS. This is an immediate consequence of a relativization theorem in (Schmidt-Schauß 1989).

(4) Take the restriction theory of Example 2.2(2). Then the formula given there has the
following semantics: An RQ-structure A is every structure with a set parentA and a relation
child-ofA satisfying the declarations of the given restriction theory. Such a structure satisfies that formula, if for each pair a, b of an element a of the parentA set and an element b that is in the child-ofA relation to that parent a this pair is also in the relation lovesA. That means each
structure, where “all parents love their children”, is a model of that formula.Ò

One can see immediately that unrestricted quantifiers are special cases of restricted ones and that we can replace every sequence of restricted universal quantifiers (and analogously of restricted existential quantifiers) by a single one:

12 Resolution with Restricted Quantifiers
∀X:R ∀Y:S F is logically equivalent to ∀X∪Y:R∧S F.12 If the restriction is a complex ∆-formula, which contains quantifiers, we can sometimes move these quantifiers out of the restriction and lift it to RQ-formula, for example,
∀X:R(X) ∧ ∃Y S(Y) F is logically equivalent to ∀X,Y:R(X) ∧ S(Y) F . These, and many further logical equivalent transformations of RQ-formulae can easily be verified for instance via a relativization (Bürckert 1990).
4.ּResolution with Restricted Quantifiers
From now on we assume every RQ-formula to be given in RQ-clause form. Of course, it is not trivial to obtain clause form, as the restriction need not be satisfiable in every model of the restriction theory. For example, the restriction theory might have to be expanded with Skolem functions and certain Skolem ∆-formulae; see (Bürckert 1990) for more details on these problems.
Our calculus consists of the following RQ-resolution rule for any pair of RQ-clauses, such that one of them contains at least one positive literal and the other one contains at least one negative literal each with the same predicate symbol:
ּ {ּP(s 11,…,s1n),…, ּP(s k1,…,skn)} ∪ Cּ||ּR {¬P(t11,…,t1n),…,¬P(tm1,…,tmn)} ∪ Dּ||ּS ּ ּ —————————————————————————
ּ ּ C ∪ Dּ||ּR ∧ S ∧ Γ (if R ∧ S ∧ Γ is R-satisfiable)
C and D are the remaining parts of the two clauses and Γ is the conjunction of the (multi)equations s1i = … = ski = t1i = … = tmi (1 ≤ i ≤ n). The derived clause is called an (RQ-)resolvent of the two parent clauses.13
An RQ-resolution step C → C’ transforms an RQ -clause set C into the set C’ by choosing two suitable clauses in C and adding their resolvent to C (after a renaming of all
variables of the resolvent consistent with variables that have not been used so far).14 An
RQ-derivation is a possibly infinite sequence (Cn) n≥0 of RQ-resolution steps Cn → Cn+1 starting with an initial set C0 of RQ-clauses. An RQ-refutation of a set C0 of RQ-clauses is a (possibly infinite) RQ-derivation (Cn) n≥0 starting with that clause set, such that for each model A of the restriction theory there is an RQ-clause set Cn in the derivation with an empty
12 This means that the two formulae have exactly the same RQ-models. 13 Notice, that it is not really necessary to require satisfiability of the constraint of the resolvent. It could be the task of the control strategies to guarantee that not too many tautological resolvents (i.e., resolvents with unsatisfiable restriction) are derived. 14 We assume that the set of clauses the RQ-resolution step is applied to consists of variable disjoint clauses.

A Resolution Principle for Clauses with Contraints

13

RQ-clause ∆ || R, whose restriction is satisfied by this model, i.e., A 7§ ∃ R . Notice, that an
RQ-structure that satisfies the restriction formula of an empty RQ-clause cannot satisfy this empty RQ-clause. Notice further, that an empty RQ-clause with satisfiable, but non-valid restriction formula has RQ-models and hence its derivation cannot terminate a refutation.
RQ-resolution is sound in the sense that every RQ-resolvent is a logical consequence of its RQ-parents:
4.1 Lemma: Let C be a set of RQ-clauses, let C ' be derived from C by an RQ-resolution step and let A be an RQ -structure. Then: A 7§ C implies A 7§ C'.
Proof: We show that an RQ-structure satisfies the resolvent of two clauses, whenever it satisfies the two parent clauses. For ease of notation we prove this only for the case, where two literals are involved in the resolution. The general case is straight forward.
Let A 7§ {P(x 1,…,xn)} ∪ C || R and A 7§ {¬P(y1 ,…,yn)} ∪ D || S. If A does not satisfy the restriction of the resolvent then A is a model of the resolvent. Hence, let (A, α)ּ 7§ R ∧ S ∧ Γ, then (A, α) must satisfy the kernel of the two parent clauses. As (A,α) satisfies Γ, obviously (A,α) can only satisfy either P(x1,…,xn) or ¬P(y1,…,yn), but not both. Hence (A,α) must satisfy either C or D and therefore A is a model of the resolvent. Ò
As our restriction theory is not given by a set of first order axioms we cannot reduce completeness of RQ-resolution to completeness of classical resolution as in the approaches for resolution modulo the equality axioms (Chang & Lee 1973), sort resolution (Walther 1987, Frisch 1989, Schmidt-Schauß 1989) or theory resolution (Stickel 1985, Ohlbach 1986). Instead we use a technique similar to that being used by Jaffar & Lassez (1986) and in a more general framework by Höhfeld & Smolka (1988). The standard proofs for completeness of classical resolution rely on a proof technique that reduces completeness to ground completeness of ground resolution on a set of ground instances of the given clause set. Now, classical resolution could be considered as RQ-resolution with respect to the restriction theory given by the ground term algebra. Hence, if we have an arbitrary RQS, we just have to replace the Herbrand universe by any of the models distinguished by the restriction theory.
4.2 Definition: Let A ∈ R be a model in the restriction theory. (1) Let C be the kernel of an RQ-clause with variables in X, and let α: X → A an assignment. Then we call the triple (A, α, C) an A-clause . (2) We call an A-clause ( A, α, C) an A-instance of an RQ-clause C || R iff (A, α) 7§ R. (3) Let C be a set of RQ-clauses. Then a set {(A, αi, Ci): i ∈ I} of A-instances of RQ -clauses Ci || Ri (i ∈ I) of C is called an A-instantiation of C, iff ( A,αi) 7§ R i for each i ∈ I.15 The set {(A, α, C): C || R in C, (A, α) 7§ R} of all A-instances of all RQ -clauses in C is called the A -base of C.
15 Notice that an A-instantiation might contain more than one A-instance of the same RQ -clause.

14 Resolution with Restricted Quantifiers
(4) A set of A-clauses {(A, αi, Ci): i ∈ I} is satisfied by a Σ-expansion A* of A iff (A*,αi) 7§ Ci for each i ∈ I; it is unsatisfiable, if it is not satisfied by a Σ-expansion of A. Ò
Our definition is the suitable generalization of the classical notion of a ground instance of a clause, which can be seen as a triple consisting of the Herbrand universe, a ground assignment, and the clause to be instantiated. Ohlbach (1986) introduces abstract clauses as a scheme for sets of ground clauses (e.g., classical clauses are schemes for the sets of all their
ground instances). Our RQ-clauses can be seen as schemes for sets of A-clauses.
As in the classical case we get that unsatisfiability of a set of RQ-clauses implies
unsatisfiability of some A-instantiation (for each model A of the restriction theory).
4.3 Theorem: (Herbrand Theorem for RQ-clauses)
A set C of RQ-clauses is RQ-unsatisfiable iff for each model A in the restriction theory R there is a finite A-instantiation of C that is unsatisfiable.
Proof: For the one direction let C be RQ -unsatisfiable. Suppose there is an A ∈ R such that each finite A-instantiation of C is satisfiable. By the Compactness Theorem for First Order Logics we have that the A-base for C is satisfiable.16 Hence there is an expansion A*, such that for each C || R in C and each assignment α with (A, α) 7§ R we have (A*,α) 7§ C ; a contradiction to the RQ-unsatisfiability of C. The other direction is obvious. Ò
In order to prove unsatisfiability of an A-instantiation we introduce the following A -resolution rule for A-clauses.
(A, α, {P(s 11,…,s1n),…, P(sk1,…,skn)} ∪ C) (A, α,{¬P(t 11,…,t1n),…,¬P(tm1,…,tmn)} ∪ D)
———————————————————————
(A, α, C ∪ D) if (A,α) 7§ Γ (Γ as in the RQ-resolution rule) which can be used to deduce the empty A-clause from every unsatisfiable set of A-clauses.
4.4 Proposition: If a finite A-instantiation D of a set of RQ -clauses is unsatisfiable, then there is a finite derivation of an empty A-clause via A-resolution.ּ
Proof: The proof is analogous to the usual case when we have ground instantiations instead
of A-instantiations. The only difference is that instead of syntactical equality of ground
instances we have here semantical equality of arguments under the assignment.
1. If the empty A-clause is already in D, we are finished.
16 The satisfiability of sets of A-clauses is a first order problem, more precisely it is a propositional logic one:
We can consider it as the problem of satisfiability of ground clauses over the Σ-predicate symbols and the
elements of the carrier of A considered as constants. Each A-clause (A, α,C) corresponds then to the ground
clause αC – the assignments are ground substitutions replacing the variables by the constants, i.e., the elements
of the carrier of A.

A Resolution Principle for Clauses with Contraints

15

2. We proceed by induction on the number N of excess literals in D (number of literal occurrences in D minus number of clauses in D). N = 0: (Then no non-unit clause is in D).17 Hence, as D is unsatisfiable, there must be two complementary units (A, α, C), ( A, α, D) in D (i.e., the corresponding arguments of the two A-clauses are assigned to the same elements in A by α). Otherwise let A* be any expansion of A, such that pA* (αx1,…,αxn) is true in A*, whenever the unit ( A, α,{p(x1 ,…,xn)}) is in D, and pA* (αx1,…,αxn) is false in A*, otherwise. Then A* satisfies D by definition. Hence the empty A-clause can be derived. N > 0: Let the lemma be true for all D with fewer than N excess literals. Then there is at least one non-unit clause, say (A, α, C). (There is at least one excess literal, as N > 0). Now, let Dּ:= C \ {L} for some literal L in C . Then the set D' := (D \ {(A , α, C)})∪{(A, α, D)} is also an unsatisfiable set of A-clauses. Hence, as it contains one fewer excess literal, by the induction hypothesis there is a deduction of the empty A-clause for this set. Similarily, the set D" := (D \ {(A, α, C)})∪{(A, α, {L})} is unsatisfiable and there is a deduction of the empty A-clause by induction hypothesis. If L is not used in the deduction for D' , it works also for D. Otherwise we can construct a deduction of the empty A-clause from D as follows. We add L back into D and all its descendants in the deduction for D' in order to get a deduction for D. Now, either this modified deduction contains the empty A-clause or it contains the unit clause (A, α, {L}) resulting from the empty A-clause after adding L to it. In the latter case we get a deduction of the empty A-clause from D by appending the deduction of the empty A-clause from D" onto the end of this modified deduction.Ò
The following Lifting Lemma is a modification of the usual one. It says that an
A-resolvent of A-instances of two RQ-clauses is an A-instance of the RQ-resolvent of the
two RQ-clauses. However, it is more trivial as we do not simplify the restrictions (this is computing the most general unifier of the arguments of the complementary literals in classical resolution), but keep them as constraints that are only tested for satisfiability (i.e., unifiability in the classical case).
4.5 Lifting Lemma: Let C1 || R1 and C2 || R2 be two constrained clauses and let (A, α, C1), (A, α, C2) be A-instances of the two RQ-clauses. Then an A-resolution step on
the two instances can be lifted to an RQ-resolution step on the RQ-clauses, such that
the A-resolvent ( A, α, C) is an A-instance of the RQ-resolvent C || R.
Proof: By the definition of A-instances and A-resolvents ( A, α) 7§ R with R := R1 ∧ R2 ∧ Γ.Ò
Corollary: If a set C of RQ-clauses is RQ-unsatisfiable, then for each A ∈ R there is a finite RQ-derivation of an empty RQ-clause whose restriction is satisfiable by A.
17 A unit clause is a clause with one literal. Here we use this notion analoguously for A-clauses.

16 Resolution with Restricted Quantifiers
Proof: If C is RQ -unsatisfiable, then for each A ∈ R there must be a finite A-instantiation
which is unsatisfiable (Herbrand Theorem). Hence there is a finite derivation of the empty
clause for this set of A-clauses (Prop. 4.4). By the Lifting Lemma it can be lifted to C, such that A satisfies the corresponding restriction of the empty clause.Ò
Now we are ready to formulate and prove correctness and completeness of our constrained resolution calculus. The result is only of relative merit as we did not give a calculus for proving satisfiability of constraints. Still worse, as the constraint theory is given by a class of models, it need not to be a first order theory (that means that there need not exist a first order axiomatization, e.g., it could be the theory of real numbers), and hence we cannot have a complete calculus for constrained clauses in the strong sense in general.18
4.6 Theorem: (Soundness and Completeness of RQ-resolution)
A set C of RQ-clauses is RQ-unsatisfiable iff for each A ∈ R there exists an RQ-derivation from C containing an empty RQ-clause ∆ || R, such that A 7§ ∃ R.
Proof: 1. Soundness (⇐): Assume C were RQ -satisfiable. Then there exists an A ∈R such that A* 7§ C for some expansion of A. By Lemma 4.1 A* 7§ ∀R C for each RQ-clause ∀R C that can be derived by RQ-resolution from C. By the precondition an empty RQ-clause ∀R ∆ with A 7§ ∃ R is derivable from C. Hence there is an assignment α with (A*,α) 7§ ∆. This is a
contradiction.
2. Completeness (⇒): Let A be a model in R. As C is RQ-unsatisfiable, by the Herbrand Theorem 4.3 there is an unsatisfiable A-instantiation of C and we can deduce the empty A-clause by A-resolution collecting the restrictions in RA. By the Lifting Lemma this
refutation can be lifted and hence the collected restriction RA of the empty clause is satisfied
by A. Ò
Remark: It is enough to consider for each A just those clauses of C whose restrictions are satisfiable by this distinguished A; the same holds for the resolvents that are derived.
Corollary: Let C be a set of RQ -clauses. If there is an empty RQ-clause with an R-valid restriction derivable by RQ-resolution, then C is RQ -unsatisfiable.
5. Consequences and Discussion
Obviously the Completeness Theorem is not very satisfactory from the practical point of view, in particular not when we are interested in an actual implementation of a theorem proving
18 Of course for applications the theory has to be first order in the sense that there should be a way – possibly with a different signature as usual – of first order axiomatization, e.g, linear equation solving over the reals could be coded in first order, although the real numbers are not a first order theory.

A Resolution Principle for Clauses with Contraints

17

system for constrained clauses. The question arises if and how we can guarantee that RQ-derivation terminates when only finitely many empty clauses are needed for an RQ-refutation. Remembering that for classic resolution there exist exhaustive refutation strategies, we observe that with such a strategy there is a finite RQ-refutation terminating with an RQ-clause set that contains finitely many empty RQ-clauses such that each restriction model satisfies the restriction of one of these empty clauses, whenever finitely many empty clauses provide an RQ-refutation.
As a first immediate consequence of the Compactness Theorem of First Order Logics
we have that if R is a first order theory (that is, if there exists a first order axiomatization with exactly the models given in R), then for every RQ -unsatisfiable set of RQ-clauses C there are finitely many empty RQ-clauses derivable from C by RQ -resolution such that the disjunction
of their restrictions is a logical consequence of the restriction theory. Hence, in this case exhaustive refutation strategies provide correct and complete RQ-resolution calculi, if we
have a calculus for proving R-validity of disjunctions of restrictions.
5.1 Theorem: Let ℜ be an RQS with a first order restriction theory R. A set C of
RQ-clauses is RQ-unsatisfiable iff there are finitely many empty RQ-clauses with
constraintsּR1 ,…, Rn RQ-derivable from C such that R 7§ ∃ R1 ∨…∨ ∃ Rn.
Proof: Let Th(R) be a first order axiomatization of R. Then the Completeness Theorem implies that RQ-unsatisfiability of C is equivalent to: for each A with A 7§ Th(R) there is some empty RQ-clause ∆ || RA derivable from C, such that A 7§ ∃ RA.
This in turn is equivalent to the unsatisfiability of the possibly infinite set of formulae
Th(R) ∪ {¬∃ RA: A 7§ Th(R)} .
By the Compactness Theorem there is a finite subset that is unsatisfiable, hence there exist
finitely many empty RQ-clauses derivable from C with R ּ 7§ ∃ R1 ∨ … ∨ ∃ Rn.Ò
Corollary: Let ℜ be as in the theorem above. If the set C of RQ-clauses is RQ-unsatisfiable then there are finitely many models A1 ,…, An of the restriction theory and finitely many empty RQ-clauses ∆ || R1,…,∆ || Rn derivable from C via RQ-resolution such that Ai 7§ ∃ Ri (1 ≤ i ≤ n).
The following example shows that we need the derivation of more than one empty RQ-clause in general, even if the initial clause set constains only clauses with valid restrictions.
5.2 Example: Suppose that we have an RQS given with the restriction theory
R :=ּ{Pa, Pb ∨ Pc}
Let us consider the following set of three constrained clauses:

18 Resolution with Restricted Quantifiers

C: (1) Q(x,x) \ Px
(2)¬ Q(b,y) \ Py
ּ (3)¬ Q(c,z) ּ\ Pz
ּ Then we can derive the following two resolvents

from clause (1) and (2) from clause (1) and (3)

∆ \ Pb ∆ \ Pc

Obviously none of the subsets consisting of clauses (1) and (2) or of clauses (1) and (3) is
unsatisfiable with respect to the restriction theory. This is mirrored in the fact that the two
empty RQ-clauses don't have an R-valid restriction.19 But the two empty clauses together provide a refutation of the whole input clause set C, as R 7= Pb ∨ Pc.Ò

A further interesting consequence is obtained for an RQS that has a generic model for
its distinguished restrictions. This means that there is a model G such that each restriction R of the RQS is satisfiable in G iff R is satisfied by every model of the restriction theory. In that case, for every RQ-unsatisfiable set of RQ-clauses C there exists a single empty RQ-clause derivable from C whose restriction is R-valid. Special examples are RQS whose restriction
theory is given by a single model, and RQS, whose restriction theory is a definite clause theory20 and whose restrictions are conjunctions of atoms.

Let ℜ be an RQS with restriction theory R and let G be a ∆-structure. We call G
generic for ℜ if for all restrictions R in ℜ
G 7§ ∃ R iff R 7§ ∃ R.

5.3 Theorem: Let ℜ be an RQS with generic model G, and let C be a set of RQ -clauses. Then: C is RQ-unsatisfiable iff there exists an empty RQ-clause ∆ || R derivable from C via RQ -resolution such that G 7§ ∃ R, and hence R 7§ ∃ R.

Proof: Without loss of generality we can assume that the generic model G is also in R (otherwise by the genericity property the class R' := R ∪ { G} is an equivalent restriction theory for the RQS in the sense that R' 7§ ∃ R iff R 7§ ∃ R for all restrictions R ).
Let C be RQ-unsatisfiable. By the Soundness and Completeness Theorem for each model A in R and hence especially for the generic model G there is an empty RQ-clause with restriction R derivable from C such that the model satisfies ∃ R .

19 Notice, that the restrictions of the input clauses are all R-valid, because of the first axiom of the restriction theory. That is an RQ-resolution rule, where only resolvents with R-valid restrictions are derived, is not
complete. However, see Theorem 4.6.4.
20 A definite clause contains exactly one positive literal and may be some negative literals. Equational theories or logic programs without negations are definite clause theories.

A Resolution Principle for Clauses with Contraints

19

Conversely, if there is an empty RQ-clause derivable from C, such that its restriction R is satisfied by the generic model: G 7§ ∃ R . Then each model of the restriction theory satisfies this restriction, i.e. R 7§ ∃ R . Hence by the Completeness Theorem the RQ-clause set is RQ-unsatisfiable. Ò
Corollary: If the RQS is given by a single model A, then: C is RQ-unsatisfiable iff there exists an empty RQ-clauses ∆ || R derivable from C such that A 7§ ∃ R.
For such an RQS with a generic model, a refutation will be obtained whenever an empty RQ-clause is derived whose restriction is satisfied by the generic model. Hence we can modify our resolution rule such that we only allow resolvents whose restrictions are satisfied in the generic model. By the genericity property this means that we allow only resolvents
whose restrictions are R-valid, i.e., satisfiable in all models of the restriction theory instead of
some model of the restriction theory. This modified resolution calculus is still complete for RQS with generic models. Of course any refutation of an RQ-unsatisfiable clause set needs
only clauses whose restrictions are satisfiable by the generic model and hence R -valid.
Corollary: Let ℜ be an RQS with generic model G and let C be a set of RQ-clauses. Let C' be the subset of C, whose RQ -clauses are R-valid. Then: C is RQ -unsatisfiable iff C' is RQ-unsatisfiable iff there exists an empty RQ -clauses ∆ּ|| R derivable from C' via RQ-resolution steps with R-valid restrictions only, such that R 7§ ∃ R.
It is well-known that definite clause theories have a least Herbrand model, which is a generic model for queries that are conjunctions of atoms (see for example Lloyd 1984, Theorem 6.6). Hence we can apply our result to constraint theories that have a definite clause axiomatization.
5.4 Theorem: If the restriction theory R is given by a definite clause theory and the
distinguished restrictions are conjunctions of atoms only, then:
A set C of RQ-clauses is RQ-unsatisfiable iff there exists an empty RQ-clause derivable from C that has an R-valid restriction.
This last result demonstrates why resolution with sorted clauses (for sort theories with least Herbrand models as e.g. sort hierarchies, Frisch 1989) or with E-unification works analogously to classical resolution: In the first case only initial clauses and resolvents have to be considered whose sort restrictions are non-empty in all models of the sort hierarchy (or equivalently in the generic least Herbrand model of the sort declarations). This is for example guaranteed when the sort hierarchy satisfies the condition that for each sort there has to exist a constant of this sort. In the case of an RQS given by an equational theory, Plotkin (1972) shows that resolution with E-unification is complete, when we have clauses with negativ

20 Resolution with Restricted Quantifiers
equality literals only. This corresponds to positive equational restrictions in the RQS view. Our result demonstrates once more from a somewhat different perspective that it is enough to consider clauses whose negativ equality literals are E-unifiable: Plotkin's E-trivialization rule is resolution of negative equality literals with the reflexitivity clause, or equivalently, E-unification of the corresponding restriction viewed as unification problem.
In fact, our completeness result shows a little more in the two cases above. We do not need a sort unification or an E-unification procedure. It is enough to have procedures that are able to decide unifiability. This is similar to lazy-unification as proposed by Ohlbach (1986) in order to avoid the problem that, with non-finitary unification, a resolution step need not terminate; see also (Bürckert 1986). Lazy-unification for E-unification and sort unification was inspired by constrained resolution as proposed by Huet (1978) in his thesis.2 1 Nevertheless, unification algorithms provide satisfiability test procedures that have several advantages. The main one is their incrementality. For instance testing unifiability of the conjunction of two equational constraints f(x) = f(f(a)) and g(h(x)) = g(h(f(y))) is equivalent to testing unifiability of the conjunction of the equational forms of the two unifiers x = f(a) and x = f(y) of these two problems. The latter one is obviously simpler and faster to check then the original one. Thus unification algorithms provide a satisfiability test that works incrementally by reducing the original problems to often much simpler ones.
6. Related Work
As already mentioned our approach is related to theory resolution of Stickel (1985) and to constraint logic programming approaches (Jaffar & Lassez 1986, Dincbas et al. 1988, Höhfeld & Smolka 1988). It follows a tradition of automated deduction research that is concerned with the question of how can we replace “blind” search with more directed search, or still better, with deterministic computation (sort unification, constraint solving). Or to phrase it differently: how can we integrate semantic information about the problem, in order to prune the search space (paramodulation, E-unification, theory resolution).
In fact, all of these improvements are special forms of constrained resolution. Here we only sketch how the two most general approaches, Stickel’s theory resolution calculus and constraint logic programming of Höhfeld and Smolka fit into our framework. Stickel already demonstrated how other less general approaches are instances of his theory resolution, Höhfeld and Smolka do the same for constraint logic programming approaches.
21 Huet used higher order equational constraints and postponed unification until an empty clause with such constraints is derived, in order to avoid the problem that, because of the undecidability of higher order unification, already single resolution steps need not terminate.

A Resolution Principle for Clauses with Contraints

21

Stickel’s total theory resolution extends resolution by a generalization of the notion of complementary literals. A total theory resolution step takes a couple of clauses, and from each clause a subclause is chosen. If this set of subclauses is complementary in the sense that it is unsatisfiable with respect to the given theory T22, then the remaining parts of the chosen clauses are joined together to form a total theory resolvent:

ּ C1 ∨ D1 C2 ∨ D2

ּ…
Cn ∨ Dn ּ————————ּif
ּ ּ ּ ּ D 1 ∨ … ∨Dn

C1 ∧ …

∧ Cn is T-unsatisfiable

If the literals of these Ci are literals of the background theory, we could see their negation ¬Ci as constraints Ri.23 If we further modify constrained resolution by a second deduction rule,
that takes any couple of constrained clauses and adds as a “theory resolvent” the clause

obtained by the union of the literals of the parents and whose restriction is the union of the

parent’s constraints and is valid with respect to the constraint theory, then this is equivalent to

a total theory resolution step.

ּ D1ּ || ּR1 ּ D2ּ || ּR2

ּ…
Dnּ || ּRn ּ——————— ּ ּ ּ D 1 ∨ … ∨Dn

if ∃ R1 ∨ … ∨ Rn is T-valid 24

However, as our result shows, such theory resolution steps could be delayed until the end,

which means they have only to be applied to constrained empty clauses.

Höhfeld and Smolka investigate constrained (SLD-)resolution for definite clauses with constraints as a goal reduction procedure. As their application in logic programming requires, they are only interested in answers to queries, but not in refutation proofs. In fact, their approach cannot serve as a theorem proving system since they will stop whenever an answer goal – a constrained empty clause – is returned. But in general this does not prove the query to be a theorem of the constrained logic program. This implies only that the query holds just in those models of the constraint theory that satisfy the answer constraints. Our result shows that, if we want to use their approach as a theorem proving procedure, we have to derive

22 A set of clauses is T-unsatisfiable iff it has no T-models.
23 Remember that C ∨ D is equivalent to ¬C ⇒D, which in turn is equivalent to D || ¬C, as constraints can be
seen as preconditions.
24 A formula is T-valid iff it is a logical consequence of T. Hence T-validity of ∃ R1 ∨ … ∨ Rn is equivalent to T-unsatisfiability of C1 ∧ … ∧ C n.

22 Resolution with Restricted Quantifiers
“enough” answers in order to have, for each model of the constraint theory, an answer constraint that is satisfied by this model. If the constraint theory is just one model, as in common constraint logic programming approaches (Jaffar & Lassez 1986, Dincbas et al. 1988), then of course a single answer determines also a proof for the query.
7. Conclusion
We have introduced a general method to handle clauses over constraints, or equivalently, clauses whose variables are bound by restricted quantifiers. Our approach generalizes wellknown methods of restricted quantification like sorted resolution and highlights constraint logic programming languages in the theorem proving context. It provides a new view of E-unification and other more general ways of building in theories, as for example in theory resolution. In fact, it generalizes theory resolution in that it allows the specification of theories not necessarily by a first order axiomatization but by any other form that describes a class of models.
Hence our results can be applied to build in any kind of theory, especially, when we are not interested in general formulae but in a restricted class of formulae that can be seen as constraints or quantifier restrictions, i.e., that is at least closed under conjunction. However, it could also be used as a method to reason about theories on the meta-level of building strong theorem provers, as it might be possible to replace a restricted quantification system – restriction theory and restrictions – by an equivalent one. For example, in (Buntine & Bürckert 1989, Bürckert 1988) we argue that AC-unification is equivalent to AC1disunification.25 This can be justified by considering the following two RQS that are equivalent in the sense that their constraints have the same solutions with respect to their constraint theory: one is the equational theory AC of associative and commutative function symbols (more exactly the corresponding free AC-algebra) together with equational constraints (the AC-unification problems), the other is the theory AC with additional unit 1 (more exactly the free AC1-algebra) together with equations and certain negated equations (AC1-disunification problems) as constraints.
Our approach could also be used to combine knowledge representation languages of the KL-ONE family (Brachman & Schmolze 1985, Nebel 1989) with predicate logic. In (Bürckert 1990) we sketch a logical framework for such a concept logic. Here RQ-resolution, where the satisfiability test for restrictions is just the consistency check for concept descriptions, could be a suitable inference method for such a hybrid knowledge representation system based on concept logic.
25 AC-unification may return millions of most general unifiers, which are represented by a few solutions of a corresponding AC1-disunification problem (Bürckert et al. 1988).

A Resolution Principle for Clauses with Contraints

23

We like to emphasize that our approach is not only useful when algorithms that test satisfiability of the restrictions are available. But the method may also be used if there is some knowledge base for the background theory, that provides a couple of results like theorems etc. for this theory. We could then use RQ-resolution in order to reduce the given problem to restriction formulae – the restrictions of the empty clauses – that could be found in the knowledge base.
Obviously there remain many open problems: How should several constraint theories be combined? Do there exist (incremental) satisfiability tests for their constraints? And of course, a most pressing problem is to gain experience with some actual implementations of constraint theories. In (Bürckert 1990) we investigate some general properties of constraint reduction or simplification systems that can be used as incremental satisfiability test systems.
Acknowledgements. I like to thank Norbert Eisinger, Werner Nutt, Hans Jürgen Ohlbach, and Gert Smolka for their support and intensive discussions that helped me to understand what’s going on in constrained resolution. This research was supported by the German Bundesministerium für Forschung und Technologie under grant ITW 8903 0.
References
K.H. Bläsius, H.-J. Bürckert (eds.). Deduction Systems in Artificial Intelligence. Horwood, Chichester, 1989
R.J. Brachman, J.G. Schmolze. An Overview of the KL-ONE Knowledge Representation System. Cognitive Science 9(2), 171-216, 1985.
W. Buntine, H.-J. Bürckert. On Solving Equations and Disequations. SEKI-Report SR-89-03, Universität Kaiserslautern, 1989
H.-J. Bürckert. Lazy Theory Unification in Prolog: An Extension of the Warren Abstract Machine. Proc. of German Workshop on Artificial Intelligence, Springer InformatikFachberichte 124, 277-288, 1986
H.-J. Bürckert. Lazy E-Unification – A Method to Delay Alternative Solutions, SEKIReport SR-87-07, Universität Kaiserslautern, 1987
H.-J. Bürckert. Solving Disequations in Equational Theories. Proc. of Conf. on Automated Deduction, Springer LNCS 310, 517-526, 1988
H.-J. Bürckert. A Resolution Principle for a Logic with Restricted Quantifiers. Dissertation, in preparation, 1990
H.-J. Bürckert, A. Herold, D. Kapur, J.H. Siekmann, M.E. Stickel, M. Tepp, H. Zhang. Opening the AC-Unification Race, J. of Automted Reasoning 4, 465-474, 1988
C.-L. Chang, R.C.-T. Lee. Symbolic Logic and Mechanical Theorem Proving. Academic Press, New York – London, 1973

24 Resolution with Restricted Quantifiers
A. Colmerauer. Equations and Inequations on Finite and Infinite Trees. Proc. of Conf. on Fifth Generation Computer Systems, 85-99, 1984
M. Dincbas, P. van Hentenryck, H. Simonis, A. Aggoun, T. Graf, F. Berthin. The Constraint Logic Programming Language CHIP. Proc. of Conf. on Fifth Generation Computer Systems, 1988
A. Frisch. A General Framework for Sorted Deduction: Fundamenrtal Results on Hybrid Reasoning. Conf. on Principles of Knowledge Representation and Reasoning, 126-136, 1989
J. Gallier, S. Raatz. SLD-Resolution Methods for Horn Clauses with Equality Based on E-Unification. Proc. of Symp. on Logic Programming, 1986
J. Gallier. Logic for Computer Science: Foundations of Automatic Theorem Proving. Harper and Row, 1986
M.R. Genesereth, N.J. Nilsson. Logical Foundations of Artificial Intelligence. Morgan Kaufmann Publishers, 1987
J.A. Goguen, J. Meseguer. Equalities, Types, Modules, and Generics for Logic Programming. J. of Logic Programming 1, 179-210, 1984
M. Höhfeld, G. Smolka. Definite Relations over Constraint Languages. LILOG-Report 53, IBM Deutschland, 1988
G. Huet. Constrained Resolution – A Complete Method for Higher Order Logic. Ph.D. Thesis, Case Western University, 1972
J. Jaffar, J.-L. Lassez. Constrained Logic Programming. Proc. of ACM Symp. on Principles of Programming Languages, 111-119, 1987
J. Jaffar, J.-L. Lassez, M. Maher. Logic Programming Scheme. In: Logic Programming: Functions, Relations, Equations (eds. D. De Groot, G. Lindstrom), Prentice Hall, 1986
C. Kirchner (ed.). Special Issue on Unification. J. of Symbolic Computation, 1989 R. Kowalski. Logic for Problem Solving. North-Holland, 1979 J.W. Lloyd. Foundations of Logic Programming. Springer, 1984 D.W. Loveland. Automated Theorem Proving: A Logical Basis. North-Holland, 1978 B. Nebel. Reasoning and Revision in Hybrid Representation Systems. Dissertation,
Universität Saarbrücken, 1989 A. Oberschelp. Untersuchungen zur mehrsortigen Quantorenlogik (in German).
Mathematische Annalen 145, 297-333, 1962 H.J. Ohlbach. The Semantic Clause Graph Procedure – A First Overview. Proc. of German
Workshop on Artificial Intelligence, Springer Informatik-Fachberichte 124, 218-229, 1986 G. Plotkin. Building in Equational Theories. Machine Intelligence 7, 1972 J.A. Robinson. A Machine Oriented Logic Based on the Resolution Principle. Journal of the ACM 12(1), 1965 M. Schmidt-Schauß. Computational Aspects of an Order-Sorted Logic with Term Declarations, Springer LNAI 395, 1989

A Resolution Principle for Clauses with Contraints

25

J.R. Shoenfield. Mathematical Logic. Addison Wesley, 1967
J.H. Siekmann. Unification Theory – A Survey. In: Special Issue on Unification (ed. C. Kirchner), J. of Symbolic Computation, 1989
G. Smolka. Logic Programming over Polymorphically Order-Sorted Types. Dissertation, Universität Kaiserslautern, 1989
G. Smolka, W. Nutt, J.A. Goguen, J. Meseguer. Order-Sorted Equational Computation. In: Resolution of Equations in Algebraic Structures (eds. H. Ait-Kaci, M. Nivat). Prentice Hall, 1989
M.E. Stickel. Automated Deduction by Theory Resolution. J. of Automated Reasoning 1(4), 1985
C. Walther. A Many-Sorted Calculus Based on Resolution and Paramodulation. Pitman & Morgan Kaufmann Publishers, Research Notes in Artificial Intelligence, 1987
L. Wos, G.A. Robinson. Paramodulation and the Set of Support. Proc. of Symp. on Automated Demonstration, Springer, 1970

Deutsches Forschungszentrum für Künstliche Intelligenz GmbH

DFKI -BibliothekPF 2080 67608 Kaiserslautern FRG

DFKI Publikationen
Die folgenden DFKI Veröffentlichungen sowie die aktuelle Liste von allen bisher erschienenen Publikationen können von der oben angegebenen Adresse oder per anonymem ftp von ftp.dfki.unikl.de (131.246.241.100) unter pub/Publications bezogen werden. Die Berichte werden, wenn nicht anders gekennzeichnet, kostenlos abgegeben.
DFKI Research Reports
RR-92-46 Elisabeth André, Wolfgang Finkler, Winfried Graf, Thomas Rist, Anne Schauder, Wolfgang Wahlster: WIP: The Automatic Synthesis of Multimodal Presentations 19 pages
RR-92-47 Frank Bomarius: A Multi-Agent Approach towards Modeling Urban Traffic Scenarios 24 pages
RR-92-48 Bernhard Nebel, Jana Koehler: Plan Modifications versus Plan Generation: A Complexity-Theoretic Perspective 15 pages
RR-92-49 Christoph Klauck, Ralf Legleitner, Ansgar Bernardi: Heuristic Classification for Automated CAPP 15 pages
RR-92-50 Stephan Busemann: Generierung natürlicher Sprache 61 Seiten
RR-92-51 Hans-Jürgen Bürckert, Werner Nutt: On Abduction and Answer Generation through Constrained Resolution 20 pages
RR-92-52 Mathias Bauer, Susanne Biundo, Dietmar Dengler, Jana Koehler, Gabriele Paul: PHI - A Logic-Based Tool for Intelligent Help Systems 14 pages

DFKI Publications
The following DFKI publications or the list of all published papers so far are obtainable from the above address or per anonymous ftp from ftp.dfki.uni-kl.de (131.246.241.100) under pub/Publications. The reports are distributed free of charge except if otherwise indicated.
RR-92-53 Werner Stephan, Susanne Biundo: A New Logical Framework for Deductive Planning 15 pages
RR-92-54 Harold Boley: A Direkt Semantic Characterization of RELFUN 30 pages
RR-92-55 John Nerbonne, Joachim Laubsch, Abdel Kader Diagne, Stephan Oepen: Natural Language Semantics and Compiler Technology 17 pages
RR-92-56 Armin Laux: Integrating a Modal Logic of Knowledge into Terminological Logics 34 pages
RR-92-58 Franz Baader, Bernhard Hollunder: How to Prefer More Specific Defaults in Terminological Default Logic 31 pages
RR-92-59 Karl Schlechta and David Makinson: On Principles and Problems of Defeasible Inheritance 13 pages
RR-92-60 Karl Schlechta: Defaults, Preorder Semantics and Circumscription 19 pages
RR-93-02 Wolfgang Wahlster, Elisabeth André, Wolfgang Finkler, Hans-Jürgen Profitlich, Thomas Rist: Plan-based Integration of Natural Language and Graphics Generation 50 pages

RR-93-03 Franz Baader, Berhard Hollunder, Bernhard Nebel, Hans-Jürgen Profitlich, Enrico Franconi: An Empirical Analysis of Optimization Techniques for Terminological Representation Systems 28 pages
RR-93-04 Christoph Klauck, Johannes Schwagereit: GGD: Graph Grammar Developer for features in CAD/CAM 13 pages
RR-93-05 Franz Baader, Klaus Schulz: Combination Techniques and Decision Problems for Disunification 29 pages
RR-93-06 Hans-Jürgen Bürckert, Bernhard Hollunder, Armin Laux: On Skolemization in Constrained Logics 40 pages
RR-93-07 Hans-Jürgen Bürckert, Bernhard Hollunder, Armin Laux: Concept Logics with Function Symbols 36 pages
RR-93-08 Harold Boley, Philipp Hanschke, Knut Hinkelmann, Manfred Meyer: C OLAB : A Hybrid Knowledge Representation and Compilation Laboratory 64 pages
RR-93-09 Philipp Hanschke, Jörg Würtz: Satisfiability of the Smallest Binary Program 8 Seiten
RR-93-10 Martin Buchheit, Francesco M. Donini, Andrea Schaerf: Decidable Reasoning in Terminological Knowledge Representation Systems 35 pages
RR-93-11 Bernhard Nebel, Hans-Juergen Buerckert: Reasoning about Temporal Relations: A Maximal Tractable Subclass of Allen's Interval Algebra 28 pages
RR-93-12 Pierre Sablayrolles: A Two-Level Semantics for French Expressions of Motion 51 pages
RR-93-13 Franz Baader, Karl Schlechta: A Semantics for Open Normal Defaults via a Modified Preferential Approach 25 pages

RR-93-14 Joachim Niehren, Andreas Podelski,Ralf Treinen: Equational and Membership Constraints for Infinite Trees 33 pages
RR-93-15 Frank Berger, Thomas Fehrle, Kristof Klöckner, Volker Schölles, Markus A. Thies, Wolfgang Wahlster: PLUS - Plan-based User Support Final Project Report 33 pages
RR-93-16 Gert Smolka, Martin Henz, Jörg Würtz: ObjectOriented Concurrent Constraint Programming in Oz 17 pages
RR-93-17 Rolf Backofen: Regular Path Expressions in Feature Logic 37 pages
RR-93-18 Klaus Schild: Terminological Cycles and the
Propositional m-Calculus
32 pages
RR-93-20 Franz Baader, Bernhard Hollunder: Embedding Defaults into Terminological Knowledge Representation Formalisms 34 pages
RR-93-22 Manfred Meyer, Jörg Müller: Weak Looking-Ahead and its Application in Computer-Aided Process Planning 17 pages
RR-93-23 Andreas Dengel, Ottmar Lutzy: Comparative Study of Connectionist Simulators 20 pages
RR-93-24 Rainer Hoch, Andreas Dengel: Document Highlighting — Message Classification in Printed Business Letters 17 pages
RR-93-25 Klaus Fischer, Norbert Kuhn: A DAI Approach to Modeling the Transportation Domain 93 pages
RR-93-26 Jörg P. Müller, Markus Pischel: The Agent Architecture InteRRaP: Concept and Application 99 pages

RR-93-27 Hans-Ulrich Krieger: Derivation Without Lexical Rules 33 pages
RR-93-28 Hans-Ulrich Krieger, John Nerbonne, Hannes Pirker: Feature-Based Allomorphy 8 pages
RR-93-33 Bernhard Nebel, Jana Koehler: Plan Reuse versus Plan Generation: A Theoretical and Empirical Analysis 33 pages
RR-93-34 Wolfgang Wahlster: Verbmobil Translation of Face-To-Face Dialogs 10 pages
RR-93-35 Harold Boley, François Bry, Ulrich Geske (Eds.): Neuere Entwicklungen der deklarativen KIProgrammierung — Proceedings 150 Seiten Note: This document is available only for a nominal charge of 25 DM (or 15 US-$).
RR-93-36 Michael M. Richter, Bernd Bachmann, Ansgar Bernardi, Christoph Klauck, Ralf Legleitner, Gabriele Schmidt: Von IDA bis IMCOD: Expertensysteme im CIM-Umfeld 13 Seiten
RR-93-38 Stephan Baumann: Document Recognition of Printed Scores and Transformation into MIDI 24 pages
RR-93-40 Francesco M. Donini, Maurizio Lenzerini, Daniele Nardi, Werner Nutt, Andrea Schaerf: Queries, Rules and Definitions as Epistemic Statements in Concept Languages 23 pages
RR-93-41 Winfried H. Graf: LAYLAB: A Constraint-Based Layout Manager for Multimedia Presentations 9 pages
RR-93-42 Hubert Comon, Ralf Treinen: The First-Order Theory of Lexicographic Path Orderings is Undecidable 9 pages

DFKI Technical Memos
TM-91-14 Rainer Bleisinger, Rainer Hoch, Andreas Dengel: ODA-based modeling for document analysis 14 pages
TM-91-15 Stefan Busemann: Prototypical Concept Formation An Alternative Approach to Knowledge Representation 28 pages
TM-92-01 Lijuan Zhang: Entwurf und Implementierung eines Compilers zur Transformation von Werkstückrepräsentationen 34 Seiten
TM-92-02 Achim Schupeta: Organizing Communication and Introspection in a Multi-Agent Blocksworld 32 pages
TM-92-03 Mona Singh: A Cognitiv Analysis of Event Structure 21 pages
TM-92-04 Jürgen Müller, Jörg Müller, Markus Pischel, Ralf Scheidhauer: On the Representation of Temporal Knowledge 61 pages
TM-92-05 Franz Schmalhofer, Christoph Globig, Jörg Thoben: The refitting of plans by a human expert 10 pages
TM-92-06 Otto Kühn, Franz Schmalhofer: Hierarchical skeletal plan refinement: Task- and inference structures 14 pages
TM-92-08 Anne Kilger: Realization of Tree Adjoining Grammars with Unification 27 pages
TM-93-01 Otto Kühn, Andreas Birk: Reconstructive Integrated Explanation of Lathe Production Plans 20 pages
TM-93-02 Pierre Sablayrolles, Achim Schupeta: Conlfict Resolving Negotiation for COoperative Schedule Management 21 pages
TM-93-03 Harold Boley, Ulrich Buhrmann, Christof Kremer: Konzeption einer deklarativen Wissensbasis über recyclingrelevante Materialien 11 pages

DFKI Documents
D-92-21 Anne Schauder: Incremental Syntactic Generation of Natural Language with Tree Adjoining Grammars 57 pages
D-92-22 Werner Stein: Indexing Principles for Relational Languages Applied to PROLOG Code Generation 80 pages
D-92-23 Michael Herfert: Parsen und Generieren der Prolog-artigen Syntax von RELFUN 51 Seiten
D-92-24 Jürgen Müller, Donald Steiner (Hrsg.): Kooperierende Agenten 78 Seiten
D-92-25 Martin Buchheit: Klassische Kommunikations- und Koordinationsmodelle 31 Seiten
D-92-26 Enno Tolzmann: Realisierung eines Werkzeugauswahlmoduls mit Hilfe des Constraint-Systems CONTAX 28 Seiten
D-92-27 Martin Harm, Knut Hinkelmann, Thomas Labisch: Integrating Top-down and Bottom-up Reasoning in COLAB 40 pages
D-92-28 Klaus-Peter Gores, Rainer Bleisinger: Ein Modell zur Repräsentation von Nachrichtentypen 56 Seiten
D-93-01 Philipp Hanschke, Thom Frühwirth: Terminological Reasoning with Constraint Handling Rules 12 pages
D-93-02 Gabriele Schmidt, Frank Peters, Gernod Laufkötter: User Manual of COKAM+ 23 pages
D-93-03 Stephan Busemann, Karin Harbusch(Eds.): DFKI Workshop on Natural Language Systems: Reusability and Modularity - Proceedings 74 pages
D-93-04 DFKI Wissenschaftlich-Technischer Jahresbericht 1992 194 Seiten

D-93-05 Elisabeth André, Winfried Graf, Jochen Heinsohn, Bernhard Nebel, Hans-Jürgen Profitlich, Thomas Rist, Wolfgang Wahlster: PPP: Personalized Plan-Based Presenter 70 pages
D-93-06 Jürgen Müller (Hrsg.): Beiträge zum Gründungsworkshop der Fachgruppe Verteilte Künstliche Intelligenz Saarbrücken 29.30. April 1993 235 Seiten Note: This document is available only for a nominal charge of 25 DM (or 15 US-$).
D-93-07 Klaus-Peter Gores, Rainer Bleisinger: Ein erwartungsgesteuerter Koordinator zur partiellen Textanalyse 53 Seiten
D-93-08 Thomas Kieninger, Rainer Hoch: Ein Generator mit Anfragesystem für strukturierte Wörterbücher zur Unterstützung von Texterkennung und Textanalyse 125 Seiten
D-93-09 Hans-Ulrich Krieger, Ulrich Schäfer: TDL ExtraLight User's Guide 35 pages
D-93-10 Elizabeth Hinkelman, Markus Vonerden,Christoph Jung: Natural Language Software Registry (Second Edition) 174 pages
D-93-11 Knut Hinkelmann, Armin Laux (Eds.): DFKI Workshop on Knowledge Representation Techniques — Proceedings 88 pages
D-93-12 Harold Boley, Klaus Elsbernd, Michael Herfert, Michael Sintek, Werner Stein: RELFUN Guide: Programming with Relations and Functions Made Easy 86 pages
D-93-14 Manfred Meyer (Ed.): Constraint Processing – Proceedings of the International Workshop at CSAM'93, July 20-21, 1993 264 pages Note: This document is available only for a nominal charge of 25 DM (or 15 US-$).

