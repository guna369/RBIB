See	discussions,	stats,	and	author	profiles	for	this	publication	at:	http://www.researchgate.net/publication/229026712
Principality	and	Decidable	Type	Inference	for
Finite-Rank	Intersection	Types
ARTICLE	Â·	JANUARY	1999
DOI:	10.1145/292540.292556
CITATIONS
70
2	AUTHORS,	INCLUDING:
A.	J.	Kfoury
Boston	University
291	PUBLICATIONS			3,914	CITATIONS			
SEE	PROFILE
Available	from:	A.	J.	Kfoury
Retrieved	on:	26	August	2015
Principality and Decidable Type Inference
for Finite-Rank Intersection Types
A. J. Kfoury
y
Boston University
Boston, MA 02215, U.S.A.
kfoury@cs.bu.edu
http://www.cs.bu.edu/~kfoury
J. B. Wells
yz
Heriot-Watt University
Edinburgh, EH14 4AS, Scotland
jbw@cee.hw.ac.uk
http://www.cee.hw.ac.uk/~jbw
Abstract
Principality of typings is the property that for each ty-
pable term, there is a typing from which all other typ-
ings are obtained via some set of operations. Type infer-
ence is the problem of nding a typing for a given term,
if possible. We dene an intersection type system which
has principal typings and types exactly the strongly nor-
malizable -terms. More interestingly, every nite-rank
restriction of this system (using Leivant's rst notion of
rank) has principal typings and also has decidable type
inference. This is in contrast to System F where the -
nite rank restriction for every nite rank at 3 and above
has neither principal typings nor decidable type infer-
ence. This is also in contrast to earlier presentations of
intersection types where the status (decidable or unde-
cidable) of these properties is unknown for the nite-
rank restrictions at 3 and above. Furthermore, the no-
tion of principal typings for our system involves only one
operation, substitution, rather than several operations
(not all substitution-based) as in earlier presentations
of principality for intersection types (without rank re-
strictions). In our system the earlier notion of expansion
is integrated in the form of expansion variables, which
are subject to substitution as are ordinary variables. A
unication-based type inference algorithm is presented
using a new form of unication, -unication.
1 Introduction
1.1 Background and Motivation
The Desire for Polymorphic Type Inference Program-
ming language designers now generally recognize the
benets (as well as the costs!) of strong static typing.
Languages such as Haskell [PJHH
+
93], Java [GJS96],
and ML [MTHM90] were all designed with strong typ-
ing in mind. To avoid imposing an undue burden on

Partly supported by NATO grant CRG 971607.
y
Partly supported by NSF grant CCR{9417382.
z
Partly supported by EPSRC grant GR/L 36963.
the programmer, the compiler is expected to infer as
much type information as possible. To avoid rejecting
perfectly safe programs, the type inference algorithm
should support as much type polymorphism as possi-
ble. The main options for polymorphism are univer-
sal types, written 8: , and intersection types, written
 ^  . (Their duals are the existential types, written
9: , and union types, written  _  .)
The most popular type inference algorithm is algo-
rithmW by Damas and Milner [DM82] for the type sys-
tem commonly called Hindley/Milner which supports
polymorphism with a restricted form of universal types.
In practice this type system is somewhat inexible,
sometimes forcing the programmer into contortions to
convince the compiler that their code is well typed. This
has motivated a long search for more expressive type
systems with decidable typability. In this search, there
have been a great number of negative results, e.g., unde-
cidability of System F [Wel94], nite rank restrictions of
F above 3 [KW94], F

[Pie94], F
!
[Urz97], F+ [Wel96],
and unrestricted intersection types [Pot80]. Along the
way, there have been a few positive results, some ex-
tensions of the Damas/Milner approach, but, perhaps
more interestingly, some with intersection types.
What are Principal Typings? The various systems of
intersection types have generally had a principal typ-
ings property, which diers from the principal types
property of the Hindley/Milner system, as described by
Jim [Jim96]:
Principal Types
Given: a term M typable in type environ-
ment A.
There exists: a type  representing all possible
types for M in A.
Principal Typings
Given: a typable term M .
There exists: a judgement A ` M :  represent-
ing all possible typings for M .
A typing for a program is principal if all other typings
for the same program can be derived from it by some
set of operations. As explained by Jim, this kind of
approach supports the possibility of true separate com-
pilation as well as other benets.
Principal Typings with Intersection Types The rst
system of intersection types for which principal typings
was proved (as far as we are aware) was presented by
Coppo, Dezani, and Venneri [CDCV80] (a later version
is [CDCV81]). Like many systems of intersection types,
it is similar to ours in that \^" can not appear to the
right of \!" and ^-elimination can only occur at -
term variables. Like our system, this system is restricted
so that the binding type of the bound variable of an
abstraction must be an intersection of exactly the set of
types at which it is used. However, this system diers
from ours by allowing dierent occurrences of the bound
variable to use the same member of an intersection. It
also has a rule to assign the special type ! (representing
the intersection of 0 types) to any term.
There is a general approach for an algorithm for
nding principal typings that was followed by Coppo,
Dezani, and Venneri for their type system as well as
by Ronchi della Rocca and Venneri [RDRV84] and van
Bakel [vB93] for other systems of intersection types. In
this approach, the principal typing algorithm rst nds
a normal form (or approximate normal form) and then
creates a typing for the normal form. A separate proof
shows that any typing for the normal form is also a
typing for the original term. The algorithms of this
approach are intrinsically impractical, not only due to
the expense of normalization but, more importantly, be-
cause there is no possibility of a short cut to normaliza-
tion. The principality of the principal typing is shown
using a technique of several dierent kinds of opera-
tions: expansion (sometimes called duplication), lifting
(sometimes called rise), and substitution. The biggest
dierence with the approach we present in this paper is
that we use expansion variables to formalize expansion
in a much simpler way as part of substitution. This
allows our approach to be based on both substitution
and unication. This opens the possibility of more ef-
cient algorithms by adding additional (unnecessary)
constraints to the unication problem to shortcut the
solution, an adaptation we leave to future work.
Sayag and Mauny [SM97, SM96] continue the ear-
lier work cited above, and succeed in dening a simpler
notion of principal typings for a system of intersection
types. An important dierence with our analysis is the
continued use of an expansion operation, although con-
siderably simplied from earlier formulations, in part
because they restrict attention to -terms in normal
form. Moreover, their approach is not substitution-
based and it is not immediately clear how to extend
it to arbitrary -terms not in normal form.
The rst unication-based approach to principal
typing with intersection types is by Ronchi della
Rocca [RDR88]. Of course, the general method here
will diverge for some terms in the full type system, but
a decidable restriction is presented which bounds the
height of types. Unfortunately, this approach uses the
old, complicated approach to expansion and is very dif-
cult to understand. It also has trouble with commuta-
tivity and associativity of \^".
Subsequent unication-based approaches to princi-
pal typing with intersection types have focused on the
rank-2 restriction of intersection types, using Leivant's
notion of rank [Lei83]. Van Bakel presents a unica-
tion algorithm for principal typing for a rank-2 sys-
tem [vB93]. Later independent work by Jim also at-
tacks the same problem, but with more emphasis on
handling practical programming language issues such
as recursive denitions, separate compilation, and accu-
rate error messages [Jim96]. Successors to Jim's method
include Banerjee's [Ban97], which integrates ow anal-
ysis, and Jensen's [Jen98], which integrates strictness
analysis. Other approaches to principal typings and
type inference with intersection types include [CG92]
and [JMZ92].
1.2 Contributions of This Paper
The main contributions of this paper are the following:
 A fully substitution-based notion of principality
for a system of intersection types (with or with-
out a rank restriction on types). Expansion vari-
ables abstractly represent the possibility of multi-
ple subderivations for the same term, supporting
a substitution-based approach in place of the old
notion of expansion.
This contribution makes the technology of inter-
section types signicantly more accessible to non-
theorists. The notions of expansion in earlier liter-
ature are so complicated that few but the authors
could understand them.
 A unication-based type inference algorithm for in-
tersection types using a novel form of unication,
-unication. The algorithm always returns prin-
cipal typings when it halts. The algorithm is ter-
minating when restricted to nite-rank types.
This algorithm is the rst understandable type
inference algorithm for intersection types beyond
the rank-2 restriction which does not require that
terms rst be -reduced to normal form. Although
it may seem that there is quite a bit of material
in this report, the vast majority of it exists only
to prove properties of the algorithm. The actual
algorithm is largely contained in denitions 2.11,
2.12, 2.13, 2.15, 3.1, 4.1, 4.2, 4.4, and 5.1, together
with theorem 5.6.
 Decidability of type inference and principal typings
for the restrictions to every nite rank.
Ours is the rst system of intersection types
for which this has been shown. At rank 3,
our system already types terms not typable in
the very powerful system F
!
, e.g., the term
(x:z(x(fu:fu))(x(vg:gv)))(y:yyy), which was
shown untypable in F
!
by Urzyczyn [Urz97].
1.3 Future Work
Using Intersection Types in Practice This work is car-
ried out in the context of the Church Project,
1
a fo-
cused eort to explore the implications of intersection
types for programming language design and implemen-
tation. The Church Project is actively implementing
and evaluating intersection-type-based technology in an
ML compiler. A number of practical concerns need to
be addressed to nish the task of making the technol-
ogy presented in this report usable in the overall project
eort. In particular, the following tasks are important:
1
hURL:http://www.cs.bu.edu/groups/church/i.
1. Adapt the technology to type systems in which \^"
is associative, commutative, and idempotent. This
will be vital for reducing the space and time com-
plexity of our algorithm, because it will enable the
expression of the rank restrictions without requir-
ing an essentially linear ow analysis.
2. Add support for sum types, e.g., booleans and con-
ditionals. This is highly likely to require the addi-
tion of union types.
3. Add support for recursive denitions, e.g., a x-
point operator or letrec bindings. This will sig-
nicantly complicate the analysis, because it will
interfere with the invariant that -compatible con-
straint sets (denition 3.7) have constraints neatly
divided into positive and negative types (deni-
tion 3.3). Also, polymorphic/polyvariant analysis
of recursion is notoriously dicult.
4. Take advantage of the new notion of substitution
developed in this report to devise ecient repre-
sentations of polyvariant program analyses. This
is particularly promising.
Theoretical Concerns The work presented here in-
spires the following possible tasks:
 Investigate the relationship between -unication
and other forms of unication { decidable and
undecidable. In particular, investigate the rela-
tionship with second-order unication and semi-
unication.
 Further develop the meta-theory of -unication.
In particular, investigate conditions under which -
unication (1) satises a principality property and
(2) is decidable. Use this to develop more sophis-
ticated type inference algorithms.
 Investigate the complexity of the decidable nite-
rank restriction of -unication introduced in sec-
tion 6. Separately, investigate the complexity of
the set of programs typable in the various nite-
rank restrictions.
2 Intersection Types with Expansion Variables
This section denes a system of intersection types for
the -calculus with the additional feature of expansion
variables. The expansion variables do not aect what is
typable; instead they support reasoning about principal
typings via a notion of substitution.
Throughout the paper, the notation
~
X
n
is meta-
notation standing for the notation X
1
; : : : ; X
n
. The
notation
~
X stands for
~
X
n
for some n  0 which either
does not matter or is clear from the context. A warning:
Some authors use the notation

X for similar purposes,
but in this paper the bar mark on a symbol is not used
to stand for a sequence.
2.1 The Type System
Denition 2.1 (-Terms). Let x and y range over
-Var, the set of -term variables. We use the usual set
of -terms
M;N 2  ::= x j x:M jMN ;
quotiented by -conversion as usual, and the usual no-
tion of reduction
(x:M)N !

M [x := N ] :
As usual, FV(M) denotes the set of free variables of
M .
The following denition gives a structure to type
variable names that will be helpful later when we need
to rename them distinctly.
Denition 2.2 (Type Variables). The set of ba-
sic type variables or basic T-variables is TVar
b
=
f a
i
j i 2 N g. The set of basic expansion variables or
basic E-variables is EVar
b
= fF
i
j i 2 N g. We assume
TVar
b
and EVar
b
are disjoint sets, and use Var
b
to denote
the union EVar
b
[ TVar
b
.
We use binary strings in f0; 1g

, called oset labels,
to name (and later to rename) variables. If s; t 2 f0; 1g

,
we write s  t for their concatenation. The statement
s  t holds i t = s  s
0
for some s
0
2 f0; 1g

. The
set of type variables or T-variables and and the set of
expansion variables or E-variables are:
TVar = f a
s
i
j i 2 N ; s 2 f0; 1g

g
EVar = fF
s
i
j i 2 N ; s 2 f0; 1g

g
Let TVar and EVar properly extend TVar
b
and EVar
b
by
taking a
i
to be a
"
i
and F
i
to be F
"
i
, where " denotes the
empty string. Let (a
s
i
)
t
denote a
st
i
and let (F
s
i
)
t
denote
F
st
i
. Let  and  be metavariables ranging over TVar
and let F (in italics) be a metavariable ranging over
EVar. For example, if  denotes a
s
i
, then 
t
denotes a
st
i
.
We use v (appropriately decorated) as a metavariable
ranging over the disjoint union Var = EVar [ TVar.
Denition 2.3 (Types). Let \!" and \^" be binary
type constructors. The set T of types and its subset
T
!
as well as metavariables over these sets are given as
follows:
 2 T
!
::=  j ( ! )
 2 T ::=  j ( ^ 
0
) j (F )
Note that  is only a metavariable over T
!
. The letters
 and  will be used later to range over certain other
subsets of T. Observe in the tree representation of any
 2 T that no \^" and no E-variable can occur as the
right child of \!". We sometimes omit parentheses
according to the rule that \!" and \^" associate to
the right and the application of an expansion variable
(e.g., F ) has higher precedence than \^" which has
higher precedence than \!". For example, F 
1
^ 
2
!

3
= ((F 
1
) ^ 
2
)! 
3
.
Denition 2.4 (Type Environments). A type en-
vironment is a function A from -Var to T with nite
domain of denition. A type environment may be writ-
ten as a nite list of pairs, as in
x
1
: 
1
; : : : ; x
k
: 
k
for some distinct x
1
; : : : ; x
k
2 -Var, some 
1
; : : : ; 
k
2
T and some k  0. If A is a type environment,
then A[x 7!  ] is the type environment such that
(A[x 7!  ])(x) =  and (A[x 7!  ])(y) = A(y) if y 6= x
and Anx = A? fx 7! A(x)g. If A and B are type envi-
ronments, then A ^ B is a new type environment given
by:
(A ^B)(x) =
8
>
>
>
<
>
>
>
:
A(x) ^B(x) if both A(x) and B(x)
dened,
A(x) if only A(x) dened,
B(x) if only B(x) dened,
undened if both A(x) and B(x)
undened.
If F 2 EVar is an E-variable and A is a type envi-
ronment, then F A is the type environment such that
(F A)(x) = F (A(x)).
Denition 2.5 (Skeletons and Derivations). The
sets of judgements, rule names, and pre-skeletons are
determined by the following grammar:
J 2 Judg ::= A ` M :  j A `
e
M : 
R 2 Rule ::= VAR j ABS-K j ABS-I j APP j
^ j F
Q 2 PSkel ::= hR; J;
~
Qi
Judgements formed with the `
e
symbol will be used to
restrict the ^ and F rules so these rules are used only
for subterms which are the arguments of an application.
Observe that a pre-skeleton S is a rule name, a nal
judgement, and zero or more subskeletons. The order
of the subskeletons is signicant. Note that F is a rule
name for every F 2 EVar.
A skeleton S of System I is a pre-skeleton Q such
that, for every sub-pre-skeletonQ
0
= hR; J;
~
Qi occurring
in Q, it holds that the judgement J is obtained from the
end judgements of the pre-skeletons
~
Q (whose order is
signicant) by rule R and rule R is one of the rules for
skeletons of System I in gure 1. The rule named \(S)
APP" is used in skeletons for the case of APP. The
order of the pre-skeletons
~
Q determines the order in
which their end judgements must match the premises of
the rule R. A skeleton hR; J;Q
1
: : : Q
n
i may be written
instead as:
Q
1
: : : Q
n
R
J
A derivation D of System I is a skeleton S such that
every use of the rule named \(S) APP" also qualies
as a use of the more restrictive rule named \(D) APP"
in gure 1. The \(D) APP" rule diers from the \(S)
APP" rule in requiring the type of the term in function
position to be a function type, requiring the domain
portion of the function type to match the type of the
term in argument position, and requiring the codomain
portion of the function type to match the result type. In
interpreting the rules in gure 1, the pattern A `
?
M : 
can refer to either A ` M :  or A `
e
M :  . Henceforth,
all skeletons and derivations belong to System I.
Observe that the set Deriv of derivations is a proper
subset of the set Skel of skeletons. Henceforth, we do
not consider pre-skeletons that are not also skeletons.
Let the statement A `
I
M :  hold i there exists
a derivation D of System I whose nal judgement is
A ` M :  . When this holds, we say that D is a typing
for M . A term M is typable in System I i A `
I
M : 
holds for some A and  .
Observe that the rule ABS-K is not a special case
of the rule ABS-I. This is because there is no rule or
other provision for \weakening" (adding redundant type
assumptions to a type environment) in our system and
therefore, if there is a proof for the judgementA `M : 
where x 62 FV(M), then A(x) is not dened.
The following result is merely what anyone would
expect from a system of intersection types formulated
without a rule for !.
Theorem 2.6 (Strong Normalization). A -term
M is strongly normalizable (i.e., there is no innite -
reduction sequence starting from M) if and only if M is
typable in System I.
Corollary 2.7 (Undecidability of Typability). It
is undecidable whether an arbitrarily chosen -term M
is typable in System I.
Later in the paper, we will show certain restrictions
of System I to have decidable typability.
Remark 2.8. System I does not have the subject re-
duction property. For example,
z : 
2
! 
1
! 
3
; w : 
1
^ 
2
`
I
(x:(y:zyx)x)w : 
3
;
but
z : 
2
! 
1
! 
3
; w : 
1
^ 
2
0
I
(x:zxx)w : 
3
:
By theorem 2.6, typability is preserved, so for example:
z : 
2
! 
1
! 
3
; w : 
2
^ 
1
`
I
(x:zxx)w : 
3
:
The reason for the lack of subject reduction is that
(1) \^" is neither associative, commutative, nor idem-
potent, (2) the implicit ^-elimination done by the VAR
rule and the way type environments are built together
x the component of an intersection type associated
with a particular variable, and (3) there is no provi-
sion for weakening (i.e., introducing unneeded type as-
sumptions). If subject reduction is viewed as a means
to achieve other goals rather than as a goal by itself,
then the lack of subject reduction is not a problem, be-
cause derivations of System I can be easily translated
into derivations of more permissive systems of intersec-
tion types (see [vB93] for a survey) for which numerous
desirable properties have already been veried. The fea-
tures of System Iwhich prevent subject reduction make
the later analysis of principal typings and type inference
much easier.
2.2 Substitution
The notion of substitution dened here will be used later
in unication for type inference and in establishing a
principal typing property for System I.
Denition 2.9 (Type Contexts). The symbol  de-
notes a \hole". The set T
2
of type contexts and its sub-
set T
!
2
as well as metavariables over these sets are given
as follows:
' 2 T
!
2
::=  j  j ('! ')
' 2 T
2
::= ' j (' ^ '
0
) j (F ')
Inference Rules for both Skeletons and Derivations
VAR x :  ` x :  ^
A
1
`
?
M : 
1
; A
2
`
?
M : 
2
A
1
^ A
2
`
e
M : 
1
^ 
2
ABS-I
A[x 7!  ] ` M : 
A ` (x:M) : ( ! )
F
A `
?
M : 
F A `
e
M : F 
ABS-K
A ` M : 
A ` (x:M) : (
0
! )
if x 62 FV(M) Remember that  ; 
0
2 T
!
and F 2 EVar.
Inference Rule for Skeletons Only
(S) APP
A
1
` M :  ; A
2
`
?
N : 
A
1
^ A
2
` MN : 
0
Inference Rule for Derivations Only
(D) APP
A
1
` M :  !  ; A
2
`
?
N : 
A
1
^ A
2
` M N : 
Figure 1: Inference Rules of System I.
Note that ' is only a metavariable over T
!
2
. If ' has
n holes, we write #
2
(') = n and use 
(1)
, : : : , 
(n)
to
denote these n holes in their order of occurrence in '
from left to right. Care must be applied when insert-
ing 
1
; : : : ; 
n
2 T in the holes of ' in order to obtain
a type  = '[
1
; : : : ; 
n
] which is valid according to
Denition 2.3. Specically, if hole 
(i)
in ' is to the
immediate right of \!", then 
i
must be restricted to
the subset T
!
.
Denition 2.10 (Expansions). The set E of expan-
sions is a proper subset of T
2
, dened by the following
grammar:
e 2 E ::=  j (e ^ e
0
) j (Fe)
In words, an expansion is a type context which mentions
no T-variable and no \!".
Denition 2.11 (Paths in Type Contexts). We
dene path as a partial function which determines the
position of 
(i)
in ' as a string in f L; R; 0; 1g

. The def-
inition goes as follows, using a \value" of ? to indicate
that the function is undened on that input:
path(
(i)
;) =
(
" if i = 1;
? otherwise.
path(
(i)
; ) = ?
path(
(i)
; '! ') =
8
>
>
<
>
>
:
L  p if p = path(
(i)
; ') 6=?;
R  q if q = path(
(i #
2
('))
; ')
and q 6=?;
? otherwise.
path(
(i)
; ' ^ '
0
) =
8
>
>
<
>
>
:
0  p if p = path(
(i)
; ') 6=?;
1  q if q = path(
(i #
2
('))
; '
0
)
and q 6=?;
? otherwise.
path(
(i)
; F') = path(
(i)
; ')
Let paths(') = f path(
(i)
; ') j 1  i  #
2
(') g. Be-
cause an expansion e 2 E is a type context that does
not mention \!", a path in e is a string in f0; 1g

rather
than in f L; R; 0; 1g

. We thus use binary strings in
f0; 1g

for a dual purpose: as paths in expansions and
as oset labels to rename variables (see denition 2.2).
The coincidence between the two is by design.
Denition 2.12 (Variable Renaming). For every
t 2 f0; 1g

(we do not need to consider the larger set
f L; R; 0; 1g), we dene a variable renaming h i
t
from T
to T, by induction:
1. h
s
i
i
t
= 
st
i
for every 
s
i
2 TVar.
2. h ! i
t
= hi
t
! hi
t
.
3. h
1
^ 
2
i
t
= h
1
i
t
^ h
2
i
t
.
4. hF
s
i
i
t
= F
st
i
hi
t
for every F
s
i
2 EVar.
In words, hi
t
is obtained from  by appending t to
every oset that is part of a variable name in  .
Denition 2.13 (Substitution on Types). A sub-
stitution is a total function S : Var ! (E [ T
!
) which
respects \sorts", i.e., SF 2 E for every F 2 EVar and
S 2 T
!
for every  2 TVar. Note that S() can not
have an E-variable or \^" in outermost position. We
write SF instead of S(F ) and S instead of S(), as
long as no ambiguity is introduced. We lift a substi-
tution S to a function S from T to T by induction on
T:
1. S = S.
2. S( ! ) = (S)! (S).
3. S(
1
^ 
2
) = (S
1
) ^ (S
2
).
4. S(F) = e[S(hi
s
1
); : : : ;S(hi
s
n
)],
where SF = e and s
i
= path(
(i)
; e) for 1  i 
#
2
(e) = n.
When no ambiguity is possible, we write S for S and
S  for S().
Denition 2.14 (Support of Substitutions). Let
S : Var ! (E [ T
!
) be a substitution. The non-
trivial E-domain and non-trivial T-domain of S are
EDom(S) = fF 2 EVar j SF 6= F g and TDom(S) =
f 2 TVar j S 6=  g; respectively. The non-trivial do-
main of S (or the support of S) is Dom(S) = EDom(S)[
TDom(S): The notation
f[F
1
:= e
1
; : : : ; F
m
:= e
m
; 
1
:= 
1
; : : : ; 
n
:= 
n
]g
denotes a substitution S with the indicated mappings
where EDom(S) = fF
1
; : : : ; F
m
g and TDom(S) =
f
1
; : : : ; 
n
g.
Denition 2.15 (Operations on Judgements and
Skeletons). The notion of renaming from deni-
tion 2.12 is lifted to type environments, judgements, rule
names, and skeletons in the obvious way.
The ^ operator and the operation of applying an
E-variable are lifted to skeletons as follows:
1. S ^ S
0
= h^; A
1
^A
2
`
e
M : 
1
^ 
2
;S;S
0
i if
S = hR
1
; A
1
`
?
M : 
1
;
~
Si and
S
0
= hR
2
; A
2
`
?
M : 
2
;
~
S
0
i.
2. F S = hF; F A `
e
M : F ;Si if
S = hR;A `
?
M : ;
~
Si.
Using the preceding, the notation for \expansion lling"
is lifted to skeletons as follows:
1. (e ^ e
0
)[S
1
; : : : ;S
n
] = S ^ S
0
if #
2
(e) = j,
e[S
1
; : : : ;S
j
] = S, and e
0
[S
j+1
; : : : ;S
n
] = S
0
.
2. (F e)[S
1
; : : : ;S
n
] = F (e[S
1
; : : : ;S
n
]).
3. [S] = S.
The notion of substitution is lifted to type environ-
ments so that SA is the function such that (SA)(x) =
S(A(x)). Substitution is lifted to judgements so that
S(A `
?
M : ) = S(A) `
?
M : S(). Substitution is
lifted to skeletons as follows:
1. ShR; J;S
1
: : :S
n
i = hR;S J; (SS
1
) : : : (SS
n
)i if
R =2 EVar.
2. ShF; J;Si = e[S(hSi
s
1
); : : : ;S(hSi
s
n
)], where
SF = e and s
i
= path(
(i)
; e) for
1  i  #
2
(e) = n.
Lemma 2.16 (Substitution Preserves Skeletons
and Derivations). Let S be any substitution.
1. If S is a skeleton, then S(S) is a skeleton.
2. If D is a derivation, then SD is a derivation.
Denition 2.17 (Principal Typings). A derivation
D is a principal typing for -term M i D is a typing
for M and for every other typing D
0
for M , there is a
substitution S such that D
0
= S(D). The principality
property for typings is the existence of a principal typing
for every typable -term.
Subsequent sections will establish that System Ihas
the principality property. We next give two simple
examples to illustrate how notions introduced so far
are used, in particular, the key concepts of \skeleton",
\derivation" and \substitution" in the presence of ex-
pansion variables.
Example 2.18 (Principal Typing for
(x:x)(y:yy)). Let M
1
denote the -term
(x:x)(y:yy). Depicted in gure 2 is a skeleton
S
1
for M
1
. The skeleton S
1
is a particular one,
produced from M
1
by the Skel algorithm of section 5.
It is just a decorated version of the parse tree of M
1
and its size is therefore \small", i.e., proportional to
the size of M
1
:
(x:x)(y:yy)
x:x
x
y:yy
yy
y y
Applying an arbitrary substitution to S
1
, we can ob-
tain another skeleton for M
1
. Thus, S
1
is a scheme for
innitely many skeletons for M
1
.
Associated with S
1
is a constraint set

1
= f 
1
! 
1
:
= G(
2
^ F
3
! 
1
)! 
2
;
G
2
:
= G(F
3
! 
1
) g
produced from M
1
by the   algorithm of section 5.
(\Constraint sets" and restrictions on them are dened
precisely in section 3.) Note that there is one constraint
in 
1
for each use of the APP rule in S
1
. A particu-
lar substitution S
1
, obtained from 
1
using the Unify
algorithm of section 4, is given by:
S
1
F = F, S
1
G = ,
S
1

1
= S
1

2
= ((F! ) ^ F)! ,
S
1

2
= F! , S
1

3
= , S
1

1
= .
Applying substitution S
1
to skeleton S
1
, we obtain an-
other skeleton which is now a derivation D
1
= S
1
(S
1
),
depicted in gure 2.
A consequence of the analysis in sections 4 and 5 is
thatD
1
is a principal typing forM
1
, i.e., every typingD
0
for M
1
is of the form D
0
= S
0
(D
1
) for some substitution
S
0
.
Example 2.19 (A Principal Typing for
(x:y:xy)(z:zz)). Let M
2
denote the -term
(x:y:xy)(z:zz). Depicted in gure 3 is a skeleton S
2
for M
2
.
As in example 2.18, the skeleton S
2
is a particular
one, produced from N
2
by the Skel algorithm. Associ-
ated with S
2
is the following constraint set, produced
from M
2
by the   algorithm of section 5:

2
= f 
1
:
= F
2
! 
1
,

1
! F
2
! 
1
:
= H(
3
^G
4
! 
2
)! 
3
,
H
3
:
= H(G
4
! 
2
) g.
A particular substitution S
2
, obtained from 
2
using
the Unify algorithm of section 4, is given by:
S
2
F =  ^G, S
2
G = G, S
2
H = ,
S
2

1
= S
2

3
= ((G! ) ^G)! ,
S
2

0
2
= S
2

3
= G! , S
2

1
2
= S
2

4
= ,
S
2

1
= S
2

2
= .
Observe that, in this example, S
2
assigns values to the
osprings 
0
2
and 
1
2
of 
2
, but does not need to assign
any particular value to 
2
itself. This follows from the
way substitutions are applied \outside-in", and becomes
clear when we consider the action of S
2
on F
2
:
S
2
(F
2
) = ( ^G)[Sh
2
i
0
; Sh
2
i
1
] =
( ^G)[S
0
2
; S
1
2
] = S
0
2
^G(S
1
2
) =
(G! ) ^G :
Applying substitution S
2
to skeleton S
2
, we obtain a
new skeleton which is also a derivation D
2
= S
2
(S
2
), as
depicted in gure 3.
A consequence of the analysis in sections 4 and 5 is
thatD
2
is a principal typing forM
2
, i.e., every typingD
0
for M
2
is of the form D
0
= S
0
(D
2
) for some substitution
S
0
.
The skeleton S
1
= Skel(M
1
) is:
VAR
x : 
1
` x : 
1
ABS-I
` x:x : 
1
! 
1
VAR
y : 
2
` y : 
2
VAR
y : 
3
` y : 
3
F
y : F
3
`
e
y : F
3
APP
y : 
2
^ F
3
` yy : 
1
ABS-I
` y:yy : 
2
^ F
3
! 
1
G
`
e
y:yy : G(
2
^ F
3
! 
1
)
APP
` (x:x)(y:yy) : 
2
Letting 
1
= ?(M
1
) and S
1
= Unify(
1
), the derivation D
1
= S
1
(S
1
) is:
VAR
x :  ` x : 
ABS-I
` x:x :  ! 
VAR
y : F!  ` y : F! 
VAR
y :  ` y : 
F
y : F `
e
y : F
APP
y : (F! ) ^ F ` yy : 
ABS-I
` y:yy : 
APP
` (x:x)(y:yy) : 
where  = ((F! ) ^ F)! .
Figure 2: Skeleton S
1
and derivation D
1
for M
1
= (x:x)(y:yy).
The skeleton S
2
= Skel(M
2
) is:
VAR
x : 
1
` x : 
1
VAR
y : 
2
` y : 
2
F
y : F
2
`
e
y : F
2
APP
x : 
1
; y : F
2
` xy : 
1
ABS-I
x : 
1
` y:xy : F
2
! 
1
ABS-I
` x:y:xy : 
1
! F
2
! 
1
VAR
z : 
3
` z : 
3
VAR
z : 
4
` z : 
4
G
z : G
4
`
e
z : G
4
APP
z : 
3
^G
4
` zz : 
2
ABS-I
` z:zz : 
3
^G
4
! 
2
H
`
e
z:zz : H(
3
^G
4
! 
2
)
APP
` (x:y:xy)(z:zz) : 
3
Letting 
2
= ?(M
2
) and S
2
= Unify(
2
), the derivation D
2
= S
2
(S
2
) is:
VAR
x : 
3
` x : 
3
VAR
y : 
1
` y : 
1
VAR
y :  ` y : 
G
y : G `
e
y : G
^
y : 
2
`
e
y : 
2
APP
x : 
3
; y : 
2
` xy : 
ABS-I
x : 
3
` y:xy : 
3
ABS-I
` x:y:xy : 
3
! 
3
VAR
z : 
1
` z : 
1
VAR
z :  ` z : 
G
z : G `
e
z : G
APP
z : 
2
` zz : 
ABS-I
` z:zz : 
3
APP
` (x:y:xy)(z:zz) : 
3
where 
1
, 
2
and 
3
abbreviate the following types:

1
= G! ; 
2
= 
1
^G = (G! ) ^G; 
3
= 
2
!  = (G! ) ^G! :
Figure 3: Skeleton S
2
and derivation D
2
for M
2
= (x:y:xy)(z:zz).
3 Lambda-Compatible Beta-Unication
The problem of -unication was introduced and shown
undecidable by Kfoury in [Kfo9X]. This section in-
troduces -compatible -unication, a restriction of -
unication, in order to develop a principality property
and in preparation for a unication algorithm presented
later.
Denition 3.1 (E-paths). The set EVar

of all nite
sequences of E-variables is also called the set of E-paths.
We dene a function E-path from VarT to nite sub-
sets of EVar

. By induction:
1. E-path(v; ) =
(
f"g if v = ;
? if v 6= :
2. E-path(v;  ! 
0
) = E-path(v; ) [ E-path(v; 
0
).
3. E-path(v;  ^ 
0
) = E-path(v; ) [ E-path(v; 
0
).
4. E-path(v; F ) =
(
fF
~
G j
~
G 2 E-path(v; )g if v 6= F ;
f"g [ fF
~
G j
~
G 2 E-path(v; )g if v = F :
Denition 3.2 (Well Named Types). If  2 T, we
write EVar() for the set of E-variables occurring in  ,
TVar() for the set of T-variables occurring in  , and
Var() for the disjoint union EVar()[TVar(). We say
that a type  2 T is well named i both of the following
statements hold:
1. For every v 2 Var(), it holds that E-path(v; ) =
f
~
Gg (a singleton set) where v does not occur in
~
G.
2. For all v
s
; v
t
2 Var() with v basic and s; t 2
f0; 1g

, if s  t then s = t.
Informally, the rst condition says that, for ev-
ery (type or expansion) variable v, the sequence of
E-variables encountered as we go from the root of 
(viewed as a tree) to any occurrence of v is always the
same. Furthermore, E-variables do not nest themselves.
If E-path(v; ) is the singleton set f
~
Fg, we can write
E-path(v; ) =
~
F without ambiguity.
The second condition says that if a variable v occurs
in  , then no proper ospring of v occurs in  , where a
variable v
st
is called an ospring of v
s
. Note that types
that mention only basic variables automatically satisfy
the second condition.
Denition 3.3 (Positive and Negative Types).
We identify two proper subsets R and S of T, which
we call the \positive types" and the \negative types",
respectively. We rst dene R and S with polarities
inserted, as R and S, dened simultaneously with
R
!
and S
!
, together with metavariables over these
sets, as follows:
 2 R
!
::= + j (! )
 2 R ::=  j (+F )
 2 S
!
::= ? j (+F ! )
 2 S ::=  j ( ^ 
0
) j (?F )
We obtain R
!
and R from R
!
and R, respectively,
by omitting all polarities. Similarly we obtain S
!
and
S from S
!
and S.
Note that there is a restriction that exactly one E-
variable occurs in each positive position to the left of
\!", and \^" occurs only in negative positions. Note
also that the metavariables  and  are restricted to the
subsets R
!
and S
!
, respectively.
If  2 R (resp.  2 S), there is exactly one way of
inserting polarities in  (resp. ) so that the resulting
type 
0
(resp. 
0
) with polarities is in R (resp. S).
Let ()
+
2 R (resp. ()
 
2 S) be the uniquely de-
ned expression obtained by inserting polarities in  2 R
(resp.  2 S). We thus have two well-dened functions:
( )
+
from R to R and ( )
 
from S to S.
Denition 3.4 (Constraint Sets). A constraint is
an equation of the form 
:
= 
0
where ; 
0
2 T. An
instance  of -unication is a nite set of constraints,
i.e.,
 = f
1
:
= 
0
1
; 
2
:
= 
0
2
; : : : ; 
n
:
= 
0
n
g
Given  of the above form, we write EVar() for the set
EVar(
1
^  ^
0
n
), TVar() for the set TVar(
1
^  ^
0
n
)
and Var() for their disjoint union EVar()[TVar().
If  is a set of constraints and F 2 EVar, we write F
to denote the set of constraints:
F =

F
:
= F
0
j 
:
= 
0
is a constraint in 
	
Denition 3.5 (Outer and Inner E-Variable Oc-
currences). Let
~
F 2 EVar

,  2 R and  2 S, with
Var() \ Var() = ?: (All constraints generated will
be of this form.) We say the expansion variable G
has an outer (resp. inner) occurrence in the constraint
~
F
:
=
~
F i G 2
~
F (resp. i G 2 EVar(^)). In words,
an \outer" occurrence appears on both sides of the con-
straint and at the top level. Occurrences of T-variables
are always inner; only occurrences of E-variables are
dierentiated between outer and inner.
Let  be a nite set of constraints, each of the form
specied in the two preceding paragraphs. We say G 2
EVar has an outer (resp. inner) occurrence in  if G
has an outer (resp. inner) occurrence in a constraint in
.
The denition of \outer" and \inner" occurrences of
E-variables carries over, in the obvious way, to the equa-
tion
~
F ()
+
:
=
~
F ()
 
after polarities are inserted. Only
inner occurrences are said to be positive or negative.
Denition 3.6 (Connected Constraint Sets). We
say that a constraint set  is connected i for all con-
straints 
:
= 
0
and ~
:
= ~
0
in , there are constraints
f
1
:
= 
0
1
; : : : ; 
n
:
= 
0
n
g   such that
Var(
i
:
= 
0
i
) \ Var(
i+1
:
= 
0
i+1
) 6= ?
for 1  i  n ? 1 where \
:
= 
0
" is \
1
:
= 
0
1
" and
\~
:
= ~
0
" is \
n
:
= 
0
n
".
Denition 3.7 (-Compatibility). A constraint set
 is -compatible i  is of the form:
 = f
~
F
1

1
:
=
~
F
1

1
; : : : ;
~
F
n

n
:
=
~
F
n

n
g
where
~
F
i
2 EVar

, and 
i
2 R and 
i
2 S such that
if 
i
2 R
!
then 
i
2 S
!
for every 1  i  n, and
moreover  satises all of the following conditions:
(A)  is well named, which we dene to hold i the
type
~
F
1

1
^
~
F
1

1
^  ^
~
F
n

n
^
~
F
n

n
is well named.
(B) Every expansion variable F 2 EVar has at most
one inner positive occurrence in , i.e., +F oc-
curs at most once in , where  is obtained by
inserting polarities in :
 = f
~
F
1
(
1
)
+
:
=
~
F
1
(
1
)
 
; : : : ;
~
F
n
(
n
)
+
:
=
~
F
n
(
n
)
 
g
(C) Every type variable  2 TVar occurs at most twice
in . And if it occurs twice, it occurs once pos-
itively as + and once negatively as ? in the
constraint set .
(D) For every constraint
~
F
:
=
~
F in , we have
Var() \ Var() = ?.
(E) For every connected 
0
  and constraint
~
F
:
=
~
F in  ? 
0
, either Var(
0
) \ Var() = ? or
Var(
0
) \ Var() = ?.
In words, the variables of a connected 
0
  can
overlap with the inner variables of at most one side
of a constraint
~
F
:
=
~
F in ?
0
.
We use the name \-compatible" because, as shown in
lemma 5.2, every constraint set induced by a -term
satises the conditions above.
Denition 3.8 (Solutions). Let S : Var ! (E [ T
!
)
be a substitution and let  = f
1
:
= 
0
1
; : : : ; 
n
:
= 
0
n
g be
a -compatible constraint set. We say S is a solution
for  i two conditions hold:
1. Dom(S) \ Var(Sv) = ? for every v 2 Var.
2. S
i
= S
0
i
for every i 2 f1; : : : ; ng.
The rst condition is a mild restriction. It can probably
be eliminated, at the price of making these propositions
and their proofs more complicated.
Denition 3.9 (Principal Solutions). Let S :
Var ! (E [ T
!
) be a substitution and let  be a -
compatible constraint set. The substitution S is a prin-
cipal solution for  i S is a solution for  and for
every solution S
0
for , there is a substitution S
00
such
that S
0
 = S
00
(S).
2
The principality property is the
existence of a principal solution for every constraint set
that has a solution.
Example 3.10 (Uniqueness of Principal Solu-
tions in a Weaker Sense). A peculiarity resulting
from the presence of expansion variables is illustrated
by a simple example. Let  be the constraint set:
 = fFG
:
= (
1
^ 
2
) ^ (
3
^ 
4
)g
where 
1
; 
2
; 
3
; 
4
2 S
!
are arbitrary. Assume that
 is -compatible. By inspection, it is not dicult to
see that  has three distinct principal solutions, ignor-
ing any principal solution obtained from one of these
three by renaming variables in its range or by adding
2
We purposely write S
0
 = S
00
(S) instead of S
0
= S
00

S in order to avoid pitfalls associated with the composition of
substitutions in -unication.
redundant mappings. The three principal solutions in
question are:
S
1
= f[ F := ; G := ( ^) ^ ( ^)]g [ S
0
S
2
= f[ F :=  ^; G
0
:=  ^; G
1
:=  ^]g [ S
0
S
3
= f[ F := ( ^) ^ ( ^);
G
00
:= ; G
01
:= ; G
10
:= ; G
11
:= ]g [ S
0
where S
0
= f[
00
:= 
1
; 
01
:= 
2
; 
10
:= 
3
; 
11
:=

4
]g. None of the three substitutions can be obtained
from the other two by variable renaming, in contrast
to principal solutions in rst-order unication, semi-
unication, and other forms of unication. If S
1
,
S
2
, and S
3
are principal as claimed, then we must
have S
i
 = S(S
j
) for some substitution S, where
i; j 2 f1; 2; 3g. This is indeed the case, by taking
S = f[ ]g, the identity substitution. Hence, after all,
S
1
 = S
2
 = S
3
 ; and the uniqueness of princi-
pal solutions is recovered in a weaker sense. However,
there is no substitution S such that S
i
= S  S
j
, where
i; j 2 f1; 2; 3g and i 6= j. It is worth noting that algo-
rithm Unify in section 4 on input  returns S
3
, because
Unify works in \top-down" fashion, i.e., it expands F
before G.
4 Algorithm for Lambda-Compatible Beta-
Unication
We design a non-deterministic algorithm Unify which
takes a -compatible constraint set  as input, such
that if  has a solution then every evaluation of
Unify() terminates returning a principal solution for
, and if  has no solution then every evaluation of
Unify() diverges.
The presentation of algorithm Unify in gure 4 is
largely self-contained | except for two parts in the
\mode of operation", namely, the denition of E-env()
and the evaluation of S
1
= S

E
S
0
, which we now ex-
plain. In general, the standard composition of two sub-
stitutions using \" does not produce a substitution,
i.e., for substitutions S
1
and S
2
, there does not neces-
sarily exist a substitution S
3
such that S
3
= (S
2
 S
1
).
To work around this diculty, we use \

E
" to denote
a new binary operation on substitutions, which we will
call \safe composition relative to E", where E is an en-
vironment expressing certain naming constraints.
Denition 4.1 (E-Path Environment). Given a
well-named type context ', we form its E-path envi-
ronment as follows:
(E-env('))(v) =
(
~
F if E-path(v; ') = f
~
F g;
undened if E-path(v; ') = ?:
An E-path environment is a partial function E : Var !
EVar

that is the result of applying the E-env function to
a well-named type context. Let E be a metavariable over
E-path environments. If  = f
1
:
= 
0
1
; : : : ; 
n
:
= 
0
n
g
is a well-named constraint set, then E-env() =
E-env(
1
^ 
0
1
^    ^ 
n
^ 
0
n
).
Denition 4.2 (Safe Composition). We rst dene
a function  which, given a pair (e;S) consisting of an
expansion e and a substitution S, returns a nite set
Metavariable conventions:
  2 R
!
,  2 R,  2 S
!
, ; 
0
2 S, ; 
0
; 
i
; 
0
i
2 T,  2 TVar.
 F;G 2 EVar and H 2 EVar
b
, with F and G distinct and H fresh in rule 4.
Mode of operation:
 Initial call: Unify()) Unify(simplify(); f[ ]g;E-env()).
 Unify(?;S;E)) S.
 Unify(
0
;S
0
; E)) Unify(
1
;S
1
;E), where 
0
=  [
~
Ff
:
= g, 
1
= S
0
and S
1
= S

E
S
0
, provided 
:
=  ) S is
an instance of one of the rewrite rules.
Rewrite rules:

:
=  ) f[ := ]g (rule 1) F 
:
=  ) f[F := ]g (rule 3)

:
=  ) f[ := ]g (rule 2) F 
:
= G ) f[F := GH]g (rule 4)
F 
:
=  ^ 
0
)

F := F
0
 ^ F
1

	
(rule 5)
Applying substitutions to constraint sets:
 S(f
:
= 
0
g [) = simplify((S)
:
= (S
0
)) [ S.
 simplify(f
:
= 
0
g [) = simplify(
:
= 
0
) [ simplify().
 simplify(
:
= 
0
) =
8
>
>
>
<
>
>
>
:
F simplify(
1
:
= 
0
1
) if  = F
1
and 
0
= F
0
1
,
simplify(
0
1
:
= 
1
) [ simplify(
2
:
= 
0
2
) if  = 
1
! 
2
and 
0
= 
0
1
! 
0
2
,
simplify(
1
:
= 
0
1
) [ simplify(
2
:
= 
0
2
) if  = 
1
^ 
2
and 
0
= 
0
1
^ 
0
2
,
? if  = 
0
,
f
:
= 
0
g otherwise.
Figure 4: Algorithm Unify.
(e;S) of triples in f0; 1g

f0; 1g

f0; 1g

. The de-
nition of  is by induction on e, for a xed S throughout:
(;S)
= f("; "; ")g
(e
0
^ e
1
;S)
= f (i  p; i  q; r) j (p; q; r) 2 (e
i
;S); i 2 f0; 1g g
(Fe;S)
= f (s
i
 p; q; s
i
 r) j (p; q; r) 2 (hei
s
i
;S); 1  i  n g
where SF = e
0
; #
2
(e
0
) = n; and
s
i
= path(
(i)
; e
0
) for 1  i  n
The intention of  is that if (p; q; r) 2 (e;S), then
the path p identies hole 
(i)
in S e, the path q iden-
ties hole 
(j)
in e of which 
(i)
in S e is a copy, and
r is the subsequence of the path p contributed by the
substitution S.
Given substitutions S
1
and S
2
, together with an E-
path environment E , the safe composition of S
1
and S
2
relative to E is a new substitution dened by:
(S
2


E
S
1
)(v) =
8
>
<
>
>
:
S
2
hS
1
(v
q
0
)i
r
if v = v
p
0
, E(v
0
) =
~
F ,
S
1
(
~
F) = e, and
(p; q; r) 2 (e;S
2
),
f[ ]g (v) otherwise.
In lemma 4.3, we state a condition and prove that it
is sucient to guarantee that the action of the substi-
tution S
2


E
S
1
on a type  is equal to the action of the
composition S
2
 S
1
on  .
Lemma 4.3 (Sucient Condition for Safe Com-
position). Let S
1
and S
2
be substitutions, let  be a
type, and let S
0
= S
2


E
S
1
for some E-path environment
E. If  and S
1
 are well-named types and E  E-env(),
then S
0
() = S
2
(S
1
()).
Denition 4.4 (Unication Algorithm). The op-
eration of Unify is based on the rewrite rules shown
in gure 4. Because Unify is non-deterministic, there
are in general many evaluations of Unify for the
same input . We exhibit the consecutive rewrite
steps of a particular evaluation of Unify() by writ-
ing: Unify(
0
; f[ ]g; E) ) Unify(
1
;S
1
; E) )    )
Unify(
i
;S
i
; E) )    where 
0
= simplify() and
E = E-env(). To indicate that the evaluation of
Unify() makes i  1 calls to Unify (beyond the ini-
tial call), and that the arguments of the ith call are the
constraint set 
i
, the substitution S
i
, and the E-path
environment E , we write:
Unify(
0
; f[ ]g; E)
i
=) Unify(
i
;S
i
; E) :
We write Unify(
0
; f[ ]g; E)

=) Unify(;S; E) to mean
that either (
0
; f[ ]g; E) = (;S; E) or there is an
evaluation of Unify() such that Unify(
0
; f[ ]g; E)
i
=)
Unify(;S; E) for some i  1.
Whenever we say  and 
0
are -compatible con-
straint sets such that Unify(;S; E)) Unify(
0
;S
0
; E)
for some substitutions S and S
0
and some E-path en-
vironment E , we assume that simplify() = . The
way Unify is dened guarantees that simplify(
0
) = 
0
again.
Lemma 4.5 (-Compatibility Is Invariant). Let

0
and 
1
be constraint sets such that
Unify(
0
;S
0
; E) =) Unify(
1
;S
1
; E)
for some substitutions S
0
and S
1
and some E-path en-
vironment E (which do not matter here). If 
0
is -
compatible, then so is 
1
. In words, the properties listed
in denition 3.7 are invariant relative to the rewrite
rules of Unify.
Lemma 4.6 (Progress). If 
0
is a non-empty -
compatible constraint set such that simplify(
0
) = 
0
,
together with a substitution S
0
and an E-path environ-
ment E, then there is a constraint set 
1
such that
Unify(
0
;S
0
; E)) Unify(
1
;S
1
; E)
for some substitution S
1
(which does not matter here).
In words, 
0
always contains a constraint that can be
processed by one of the rewrite rules of Unify.
Lemma 4.7 (Solutions with Finite Support Suf-
ce). Let  be a -compatible constraint set and let
S : Var ! (E [ T
!
) be a substitution. If S is a solution
for , then we can construct a substitution S
0
from S
such that:
1. Dom(S
0
) is nite.
2. S
0
is a solution for .
Denition 4.8 (Size). Given a type  2 T, the func-
tion size( ) applied to  returns an integer size()  1
which is the number of symbols in  excluding all oc-
currences of E-variables and all parentheses. We extend
size( ) to expansions e 2 E in the obvious way. Formal
denitions, by induction on  and e respectively, are
omitted.
Denition 4.9 (Degree). Let  be a -compatible
constraint set, with EVar() = fF
1
; : : : ; F
k
g: Let S be
a solution for  with nite Dom(S), say:
S = f[G
1
:= e
1
; : : : ; G
m
:= e
m
; 
1
:= 
1
; : : : ; 
n
:= 
n
]g :
If
~
F 2 EVar

, let j
~
F j denote its length, i.e., the num-
ber of variables in the sequence. We dene a mea-
sure degree(S;) = (p; q; r) on the pair (S;), where
p; q; r 2 N , as follows:
 p =
P
1im
(size(e
i
)? 1)
 q = size()
 r =
P
1ik
(k ? jE-path(F
i
;)j)
Given two triples (p; q; r) and (p
0
; q
0
; r
0
) of natural num-
bers, we write (p; q; r) < (p
0
; q
0
; r
0
) i either p < p
0
,
or p = p
0
and q < q
0
, or p = p
0
, q = q
0
and r < r
0
.
This is the so-called \lexicographic ordering" on triples
of natural numbers, and it is easy to see that it is well-
founded.
Lemma 4.10 (Decreasing Degree when Solv-
able). Let 
0
be a -compatible constraint set, let 
1
be a constraint set, and let
Unify(
0
;S
0
; E)) Unify(
1
;S
1
; E)
for some substitutions S
0
and S
1
and some E-path en-
vironment E (which do not matter here). If there is
a solution S
0
0
for 
0
with Dom(S
0
0
) nite, then there
is a solution S
0
1
for 
1
with Dom(S
0
1
) nite such that
degree(S
0
1
;
1
) < degree(S
0
0
;
0
).
Lemma 4.11 (Principal Solution Constructed).
Let 
0
be a -compatible constraint set with E =
E-env(
0
), let 
1
be a constraint set, and let
Unify(
0
;S; E)

=) Unify(
1
;
~
S

E
S; E)
for some substitutions S and
~
S. If S
1
is a principal
solution for 
1
, then S
1


E
~
S is a principal solution for

0
.
The following theorem shows that the algorithm is
sound (i.e., the substitutions Unify produces when it
terminates are in fact solutions) and complete (i.e.,
Unify produces a solution if there is one), as well as
showing it produces principal solutions.
Theorem 4.12 (Soundness, Completeness, &
Principality). Let  be a -compatible constraint set
with E = E-env().
1.  has a solution if and only if
Unify(simplify(); f[ ]g; E)

=) Unify(?;S; E) for
some substitution S.
2. If Unify(simplify(); f[ ]g; E)

=) Unify(?;S; E) for
some S, then S is a principal solution for .
Note that Unify diverges exactly when there is no
solution. The evaluation strategy does not matter, be-
cause lemma 4.10 implies termination when there is a
solution and lemma 4.11 implies divergence when no
solution exists.
5 Type Inference Algorithm
This section denes a procedure which, given a -term
M , generates a nite set  (M) of constraints, the solv-
ability of which is equivalent to the typability of the
term M . We use this to prove the principality property
for System I and to dene a complete type inference
algorithm.
Denition 5.1 (Algorithm Generating Con-
straints and Skeleton). For every -term M ,
gure 5 gives an inductive denition of a set of
constraints  (M) and a derivation skeleton Skel(M),
dened simultaneously with a type Typ(M) and a
type environment Env(M). In this denition, for a
given subterm occurrence N , when a fresh variable
is chosen, the same fresh variable must be used in
Env(N), Typ(N),  (N), and Skel(N). The process
of going from M to  (M) and Skel(M) is uniquely
determined up to the choice of expansion variables and
type variables.
Lemma 5.2 (Constraint Set is -Compatible).
Let M be an arbitrary -term. The constraint set  (M)
induced by M is -compatible.
Lemma 5.3 (All Derivations Instances of
Skel(M)). If D is a derivation of System I with
nal judgement A ` M :  , then there exists some
substitution S such that D = S(Skel(M)).
Theorem 5.4 (Constraint Set and Skeleton
Equivalent). Given -term M , a substitution S is
a solution for  (M) if and only if S(Skel(M)) is a
derivation of System I. Thus,  (M) is solvable if and
only if M is typable in System I.
Corollary 5.5. It is undecidable whether an arbitrarily
chosen -compatible constraint set  has a solution.
From the principality property for -compatible -
unication, we can derive the following.
If M = x, for fresh  2 TVar
b
: Typ(M) = ;
Env(M) = fx 7! g;
?(M) = ?;
Skel(M) = hVAR;Env(M) ` M : i:
If M = (N
1
N
2
), for fresh F 2 EVar
b
,  2 TVar
b
: Typ(M) = ;
Env(M) = Env(N
1
) ^ F Env(N
2
);
?(M) = ?(N
1
) [ F ?(N
2
) [ fTyp(N
1
)
:
= F Typ(N
2
)! g;
Skel(M) = hAPP;Env(M) ` M : ; Skel(N
1
) (F Skel(N
2
))i:
If M = (x:N), for fresh  2 TVar
b
: Typ(M) =
(
Env(N)(x)! Typ(N) if Env(N)(x) dened,
! Typ(N) otherwise,
Env(M) = Env(N)nx;
?(M) = ?(N);
Skel(M) = hR;Env(M) ` M : Typ(M); Skel(N)i
where if x 2 FV(N), then R = ABS-I, else R = ABS-K.
Figure 5: Denition of  (M), Skel(M), Typ(M), and Env(M).
Theorem 5.6 (Principal Typings and Complete-
ness of Type Inference). Let PT be the algorithm
such that
PT(M) = (Unify( (M)))(Skel(M))
If M is typable in System I, then PT(M) returns a prin-
cipal typing for M , else PT(M) diverges. Thus, Sys-
tem Ihas the principality property and PT is a complete
type inference algorithm for System I.
6 Termination and Decidability at Finite Ranks
This section denes UnifyFR, an adaptation of algo-
rithm Unify which produces a solution S with bounded
rank k for a -compatible constraint set . The de-
nition of UnifyFR diers from Unify only in the \mode
of operation" as presented in gure 6. The invocation
of UnifyFR on  at rank k produces a solution S if
Unify() produces S and the rank of S is bounded by
k. Otherwise UnifyFR halts indicating failure, unlike
Unify which diverges if it can not nd a solution.
Note that the principality of solutions produced by
UnifyFR follows from the principality of solutions pro-
duced by Unify.
Denition 6.1 (Rank of Types). For every s 2
f L; R; 0; 1g

, let #
L
(s) denote the number of occur-
rences of L in s. Let  2 T. There is a smallest (and,
therefore, unique) ' 2 T
2
with n  1 holes such that
1.  = '[
1
; : : : ; 
n
] for some 
1
; : : : ; 
n
2 T.
2. None of the types in f
1
; : : : ; 
n
g contains an oc-
currence of \^".
The rank of hole 
(i)
in ' is given by
hole-rank(
(i)
; ') = #
L
(path(
(i)
; ')). If ' = , i.e.,
 does not mention any \^", we dene rank() = 0. If
' 6= , we dene rank() by:
rank() = 1 +maxfhole-rank(
(i)
; ') j 1  i  #
2
(')g :
This denition of rank() is equivalent to others found
in the literature.
If  = f
1
:
= 
0
1
; : : : ; 
n
:
= 
0
n
g is a -compatible
constraint set, we dene rank() by:
rank() =
maxfrank(
1
); rank(
0
1
); : : : ; rank(
n
); rank(
0
n
)g
Denition 6.2 (Rank-k System of Intersection
Types). Let k  1. If S is a skeleton of System I
where every environment type has rank  k ? 1 and
every derived type has rank  k, we write rank(S)  k
and say that S is a rank-k skeleton.
We dene the restriction I
k
of System I as follows.
A skeleton S of I is a skeleton of I
k
i rank(S)  k. A
particular susbet of the rank-k skeletons are the rank-k
derivations.
Denition 6.3 (Rank-k Solution). Let  be a -
compatible constraint set, A  TVar, and k  1. We
say that a substitution S : Var ! (E [ T
!
) is a rank-k
solution for  relative to A provided:
1. S is a solution for .
2. rank(S)  k ? 1, for every  2 A.
3. rank(S)  k, for every  62 A.
The set A discriminates between T-variables corre-
sponding to environment types and T-variables corre-
sponding to derived types in a typing; for a rank-k typ-
ing, the rst must have rank  k ? 1, and the second
must have rank  k.
Lemma 6.4. Let M be a -term and  =  (M). If S
is a rank-k solution of , then there is a derivation of
M is System I
k+2
.
To show that for a xed A  TVar and xed k  1,
an evaluation of UnifyFR(; A; k) always terminates,
we need to reason about the rank of a constraint in a
constraint set. The following denitions support this.
Denition 6.5 (-Compatible Pairs). Let (; 
0
) be
a pair of types. We dene its constraint decomposition
sequence d(; 
0
) = ('; ^
1
; : : : ; ^
n
; ^
0
1
; : : : ; ^
0
n
) with 1+2n
entries, where ' 2 T
2
with n  0 holes is the largest
(and therefore unique) type context such that
 = '[
1
; : : : ; 
n
];

0
= '[
0
1
; : : : ; 
0
n
];
f
i
; 
0
i
g = f^
i
; ^
0
i
g for 1  i  n;
(
i
; 
0
i
) = (^
i
; ^
0
i
) if hole-rank(
(i)
; ') is even,
(
i
; 
0
i
) = (^
0
i
; ^
i
) if hole-rank(
(i)
; ') is odd.
Mode of operation:
 Initial call: UnifyFR(; A; k)) UnifyFR(simplify(); f[ ]g ;E-env(); A; k) for A  TVar and k  1.
 UnifyFR(?;S;E; A; k)) S.
 UnifyFR(
0
;S
0
; E; A; k)) UnifyFR(
1
;S
1
; E; A; k) if Unify(
0
;S
0
;E)) Unify(
1
;S
1
;E) and also:
{ rank(S
1
)  k   1 for every  2 A.
{ rank(S
1
)  k for every  62 A.
Figure 6: Algorithm UnifyFR (refer to gure 4 for missing parts).
If
~
G
i
= E-path(
(i)
; ') for 1  i  n, then its constraint
set decomposition is:
(; 
0
) = f
~
G
1
^
1
:
=
~
G
1
^
0
1
; : : : ;
~
G
n
^
n
:
=
~
G
n
^
0
n
g:
If (; 
0
) is a -compatible constraint set, then (; 
0
)
is a -compatible pair. In this case, ^
i
2 R and ^
0
i
2 S
for 1  i  n, so we can let ^
i
= 
i
and ^
0
i
= 
i
for
1  i  n and write (; 
0
) in the form:
(; 
0
) = f
~
G
1

1
:
=
~
G
1

1
; : : : ;
~
G
n

n
:
=
~
G
n

n
g:
Note that simplify((; 
0
)) = (; 
0
), because d(; 
0
)
chooses the largest ' with the stated property. We de-
ne the rank of constraint
~
G
i

i
:
=
~
G
i

i
in (; 
0
):
rank(
~
G
i

i
:
=
~
G
i

i
; (; 
0
)) = hole-rank(
(i)
; '):
We also dene h(; 
0
):
h(; 
0
) = minf hole-rank(
(i)
; ') j 1  i  n g;
i.e., h(; 
0
) is a lower bound on the L-distance of all
the holes in ' from its root (viewed as a binary tree).
If  = 
0
= ', i.e., ' has 0 holes, we leave h(; 
0
)
undened.
Denition 6.6 (Evaluating -Compatible Pairs).
Let (
0
; 
0
0
) and (
1
; 
0
1
) be -compatible pairs. Let rule
a be one of the 5 rules listed in gure 4. We write
(
0
; 
0
0
) =)
a
(
1
; 
0
1
)
i d(
0
; 
0
0
) = ('; 
1
; : : : ; 
n
; 
1
; : : : ; 
n
) and there is i 2
f1; : : : ; ng such that:
1. 
i
:
= 
i
) S is an instance of rule a.
2. (
1
; 
0
1
) = (S
0
;S
0
0
).
In such a case, we say that (
0
; 
0
0
) is evaluated to (
1
; 
0
1
)
by rule a. Moreover, if hole-rank(
(i)
; ') = k, we say
that the constraint 
i
:
= 
i
is at rank k and that the
evaluation from (
0
; 
0
0
) to (
1
; 
0
1
) is also at rank k, in-
dicated by writing
(
0
; 
0
0
) ===)
(a;k)
(
1
; 
0
1
):
We write (
0
; 
0
0
)) (
1
; 
0
1
) in case (
0
; 
0
0
) =)
a
(
1
; 
0
1
) for
some rule a, and

=) for the reexive transitive closure
of ).
Let R  f1; : : : ;5g. Let (
0
; 
0
0
) )    ) (
n
; 
0
n
)
be an evaluation sequence with n  1 steps. We write
(
0
; 
0
0
)
n
=)
R
(
n
; 
0
n
) to indicate that the evaluation has
n steps, and that each step is carried out using rule a
for some a 2 R.
Finally, if there is no pair (
1
; 
0
1
) such that
(
0
; 
0
0
) =)
R
(
1
; 
0
1
), then we say that the pair (
0
; 
0
0
)
is in R-normal form.
Lemma 6.7 (Evaluating without Rule 5). Let
R = f1; : : : ;4g, i.e., R is the set of all rewrite rules
without rule 5. If (
0
; 
0
0
) is a -compatible pair, there
is a bound M(
0
; 
0
0
) solely depending on (
0
; 
0
0
) such
that for every evaluation with R: (
0
; 
0
0
)
n
=)
R
(
1
; 
0
1
), we
have n  M(
0
; 
0
0
). In words, a non-terminating eval-
uation of (
0
; 
0
0
) must use innitely many times rule
5.
Lemma 6.8 (Evaluating with Rule 5 at a Fixed
Rank). Let R be the set of all rewrite rules without
rule 5, as in lemma 6.7.
Hypothesis: Let (
0
; 
0
0
) be a -compatible pair in
R-normal form, with k = h(
0
; 
0
0
), and consider an
arbitrary evaluation with the rules in R (with no rank
restriction) and rule 5 restricted to rank k:
(
0
; 
0
0
) =)
a
1
(
1
; 
0
1
) =)
a
2
(
2
; 
0
2
) =)
a
3
   =)
a
n
(
n
; 
0
n
)
where for every 1  i  n, either a
i
2 R or a
i
= 5 and
the step (
i 1
; 
0
i 1
) =)
5
(
i
; 
0
i
) is at rank k.
Conclusion: There is a uniform bound N(
0
; 
0
0
)
solely depending on (
0
; 
0
0
) such that n  N(
0
; 
0
0
).
Moreover, if (
n
; 
0
n
) cannot be evaluated further, i.e., if
(
n
; 
0
n
) is in R-normal form and in (5; k)-normal form
(see denition 6.6), then either 
n
= 
0
n
or h(
n
; 
0
n
) >
k.
Denition 6.9 (Increasing-Rank Evaluations).
Let R be the set of all rewrite rules without rule 5, as
in lemma 6.8. Let (
0
; 
0
0
) be a -compatible pair. An
increasing-rank evaluation of (
0
; 
0
0
) is of the form:
(
0
; 
0
0
)

=)
R
(
1
; 
0
1
)

==)
R
1
(
2
; 
0
2
)

==)
R
2
  
where (
1
; 
0
1
) is in R-normal form and, for every i  1,
if 
i
6= 
0
i
then R
i
= R [ f(5; k
i
)g where k
i
= h(
i
; 
0
i
)
and (
i+1
; 
0
i+1
) is in R
i
-normal form.
Denition 6.10 (Coding -Compatible Con-
straint Sets as -Compatible Pairs). The
coding pq of a -compatible constraint set
 = f
1
:
= 
0
1
; : : : ; 
n
:
= 
0
n
g is the pair (; 
0
)
given by:
 = (
1
^    ^ (
n 1
^ 
n
))

0
= (
0
1
^    ^ (
0
n 1
^ 
0
n
))
It is clear that pq is a -compatible pair (deni-
tion 6.5).
Lemma 6.11 (Increasing-Rank Evaluations
Complete). Let  be a -compatible constraint
set, and let (; 
0
) = pq. If an increasing-rank
evaluation of (; 
0
) does not terminate, then  has no
solution.
Theorem 6.12 (Decidability of Finite-Rank -
Unication). Let  be a -compatible constraint set,
A a set of T-variables, and k  1.
1.  has a rank-k solution relative to A i there is a
successful evaluation UnifyFR(; A; k)

=) S.
2. There are no innite (diverging) evaluations start-
ing from UnifyFR(; A; k).
3. It is decidable whether  has a rank-k solution rel-
ative to A.
References
[vB93] S. van Bakel. Intersection Type Disciplines in
Lambda Calculus and Applicative Term Rewriting
Systems. PhD thesis, Catholic University of Ni-
jmegen, 1993.
[Ban97] A. Banerjee. A modular, polyvariant, and type-
based closure analysis. In Proc. 1997 Int'l Conf.
Functional Programming, 1997.
[CDCV80] M. Coppo, M. Dezani-Ciancaglini, and B. Ven-
neri. Principal type schemes and -calculus seman-
tics. In Seldin and Hindley [SH80], pp. 535{560.
[CDCV81] M. Coppo, M. Dezani-Ciancaglini, and B. Ven-
neri. Functional characters of solvable terms.
Z. Math. Log. Grund. Math., 27:45{58, 1981.
[CG92] M. Coppo and P. Giannini. A complete type infer-
ence algorithm for simple intersection types. In 17th
Colloq. Trees in Algebra and Programming, vol. 581
of LNCS, pp. 102{123. Springer-Verlag, 1992.
[DM82] L. Damas and R. Milner. Principal type schemes for
functional programs. In Conf. Rec. 9th Ann. ACM
Symp. Principles of Programming Languages, pp.
207{212, 1982.
[GJS96] J. Gosling, B. Joy, and G. Steele. The Java Lan-
guage Specication. Addison Wesley, 1996.
[Jen98] T. Jensen. Inference of polymorphic and conditional
strictness properties. In Conf. Rec. POPL '98: 25th
ACM Symp. Principles of Prog. Languages, 1998.
[Jim96] T. Jim. What are principal typings and what are
they good for? In Conf. Rec. POPL '96: 23rd ACM
Symp. Principles of Prog. Languages, 1996.
[JMZ92] B. Jacobs, I. Margaria, and M. Zacchi. Filter
models with polymorphic types. Theor. Comp. Sc.,
95:143{158, 1992.
[Kfo9X] A. J. Kfoury. Beta-reduction as unication. In
D. Niwinski, ed., Logic, Algebra, and Computer Sci-
ence (H. Rasiowa Memorial Conference, December
1996). Springer-Verlag, 199X.
[KW94] A. J. Kfoury and J. B. Wells. A direct algorithm for
type inference in the rank-2 fragment of the second-
order -calculus. In Proc. 1994 ACM Conf. LISP
Funct. Program., 1994.
[Lei83] D. Leivant. Polymorphic type inference. In Conf.
Rec. 10th Ann. ACM Symp. Principles of Program-
ming Languages, pp. 88{98, 1983.
[MTHM90] R. Milner, M. Tofte, R. Harper, and D. B. Mac-
Queen. The Denition of Standard ML (Revised).
MIT Press, 1990.
[Pie94] B. Pierce. Bounded quantication is undecidable.
Inf. & Comput., 112:131{165, 1994.
[PJHH
+
93] S. L. Peyton Jones, C. Hall, K. Hammond,
W. Partain, and P. Wadler. The Glasgow Haskell
compiler: A technical overview. In Proc. UK Joint
Framework for Information Technology (JFIT)
Technical Conf., 1993.
[Pot80] G. Pottinger. A type assignment for the strongly
normalizable -terms. In Seldin and Hindley [SH80],
pp. 561{577.
[RDR88] S. Ronchi Della Rocca. Principal type schemes and
unication for intersection type discipline. Theor.
Comp. Sc., 59:181{209, 1988.
[RDRV84] S. Ronchi Della Rocca and B. Venneri. Principal
type schemes for an extended type theory. Theor.
Comp. Sc., 28:151{169, 1984.
[SH80] J. P. Seldin and J. R. Hindley, eds. To H. B. Curry:
Essays on Combinatory Logic, Lambda Calculus,
and Formalism. Academic Press, 1980.
[SM96]

E. Sayag and M. Mauny. A new presentation of the
intersection type discipline through principal typings
of normal forms. Technical Report RR-2998, INRIA,
Oct. 16, 1996.
[SM97]

E. Sayag and M. Mauny. Structural properties of in-
tersection types. In Proceedings of the 8th Interna-
tional Conference on Logic and Computer Science {
Theoretical Foundations of Computing (LIRA), pp.
167{175, Novi Sad, Yugoslavia, Sept. 1997.
[Urz97] P. Urzyczyn. Type reconstruction in F
!
. Math.
Struc. in Comp. Sc., 7(4):329{358, 1997.
[Wel94] J. B. Wells. Typability and type checking in the
second-order -calculus are equivalent and undecid-
able. In Proc. 9th Ann. IEEE Symp. Logic in Com-
puter Sci., 1994. Superseded by [Wel9X].
[Wel96] J. B. Wells. Typability is undecidable for F+eta.
Tech. Rep. 96-022, Comp. Sci. Dept., Boston Univ.,
Mar. 1996.
[Wel9X] J. B. Wells. Typability and type checking in Sys-
tem F are equivalent and undecidable. Ann. Pure &
Appl. Logic, 199X. To appear. Supersedes [Wel94].
