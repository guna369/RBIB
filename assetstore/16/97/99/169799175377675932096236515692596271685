Vademecum of Divergent Term Rewriting Systems

Miki HERMANN
Centre de Recherche en Informatique de Nancy
CNRS and INRIA-Lorraine
Campus Scientique, BP 239,
54506 Vand√∑uvre-l√®s-Nancy, France
e-mail: hermann@loria.crin.fr
Abstract
This paper presents two structural patterns to detect
divergence of the completion procedure, followed by
a detailed overview of dierent examples of diver-
gent rewrite systems. Further it introduces ve dif-
ferent empirical methods to avoid divergence, appli-
cable during a session with a rewrite rule laboratory.
1 Introduction
Applying the KnuthBendix procedure [36] to com-
plete a given term rewriting system may result in
producing the canonical term rewriting system or
failure, if it halts, or in a diverging process trying to
generate an innite set of rewrite rules. The rst re-
sult concerning structural properties of an innite set
of rules generated by the KnuthBendix completion
procedure is due to Huet [26]. Further attempts to
study the reasons of KnuthBendix procedure diver-
gence through investigation of the structural prop-
erties of the generated rules were initiated in [22],
and more developed in [20]. The notion of crossed
term rewriting systems as a sucient criterion for
proving divergence of the KnuthBendix procedure
emerged from these investigations. Recently, a com-
plementary research focused on the nite descrip-

Research report CRIN 88-R-022. Appeared in Avanc√©es
en Programation  Journ√©es AFCET-GROPLAN , Nice
(France), BIGRE, volume 70, January 1990.
tion of innite sets of rules generated by diverging
KnuthBendix procedure, developing the notion of
metarules, is due to Kirchner [35].
This paper has a twofold purpose. First, it serves
as a comprehensive collection of examples for diver-
gent rewrite systems. Second, it presents a possible
instruction kit for dealing with divergent rewrite sys-
tems. The proposed remedies are strictly empirical
and can be divided mainly into ve categories:
1. changes within an ordering class to obtain a new
particular ordering of the same type (e.g. in the
class of recursive path orderings change the op-
erator precedence), to order an equation in the
opposite direction,
2. choosing another ordering class (e.g. instead of
recursive path ordering choose recursive decom-
position ordering, polynomial ordering or trans-
formation ordering) in order to get the right di-
rection of rewrite rules,
3. separating the rule that causes divergence into
a sequence of less complex equations, if the con-
structor(s) in the equational theory are pro-
vided,
4. dividing the rule that causes divergence into two
rules,
5. enriching the system by new rewrite rules to
avoid divergence originated from underspeci-
cation.
These actions are to be taken into account dur-
ing sessions with a rewrite rule laboratory such as
REVE [39], when a decision must be met quickly in
order to obtain a canonical (i.e. conuent, terminat-
ing, and interreduced) rewrite system. Of course,
these suggestions need not to produce the desired ef-
fect, mostly for the reason that the changed rewrite
system does not correspond with the user's ideas. In
this case the user is proposed to upgrade to formal
methods developed by Kirchner [35].
2 Completion of term rewriting
systems
For completeness, the notation used in the term
rewriting system theory is introduced in the rst part
of this section. The second part contains the basic
denitions concerning term rewriting systems in gen-
eral with references to related work, and introduces a
review of notions from background papers which are
frequently referred to in this paper. The last part
contains a denition of a completion procedure in a
general framework.
2.1 Basic notation and denitions
We adopt the notation of [12].
Let F be a nite or enumerable set of function
symbols graded by arity (signature). F
0
denotes the
constants. Let X be an enumerable set of variables
such that F \ X = ;. Denote by T (F ;X ) the set of
all terms (free algebra) over variables X and symbols
F . Var(t) denotes the set of all variables in the term
t. Denote by G(F) the set of all ground terms with
function symbols F .
Let N

be the set of strings of natural numbers
with a special symbol  2 N

for the empty string
and a concatenation operation on N

. Using the
elements of N

as labels, the terms can be viewed
as labeled trees. A term t is a partial function
N

! F [ X such that its domain Pos(t) satises
the following properties:
1. if t 2 F
0
[ X then Pos(t) = fg,
2. if t = f(t
1
; : : : ; t
n
) then Pos(t) = fg [ fi:a j
i = 1; : : : ; n and a 2 Pos(t
i
)g
Pos(t) is the set of positions of the term t. The
subset of non-variable positions of t is denoted by
FPos(t).
A subterm of t at a position a 2 Pos(t) is denoted
by tj
a
. If t = f(t
1
; : : : ; t
n
) then tj

= t and tj
ia
= t
i
j
a
for all i = 1; : : : ; n. Denote by s[t]
a
a new term ob-
tained from the term s after replacing its subterm
sj
a
by t. For properties of replacement see the arti-
cle [47].
A substitution is a function : X ! T (F ;X ) such
that x = x holds for all but a nite number of vari-
ables. Denote a substitution  by [x
1
7! t
1
; : : : ; x
n
7!
t
n
]when the terms t
i
are substituted for the variables
x
i
and x
i
6= t
i
, for i = 1; : : : ; n. An empty substi-
tution is denoted by [ ]. Substitutions have a homo-
morphic extension on the terms. Denote by Dom(),
Ran(), and Var() the domain, range, and all vari-
ables of a substitution , respectively. A substitution
, such that x 2 X and x = y implies x = y for
all x; y 2 Dom(), is a variable renaming . Substitu-
tions need not be idempotent in our approach.
Two terms s and t are uniable if, and only if, there
is an idempotent substitution  such that s = t.
The substitution  is called a unier . The substitu-
tion  is called the most general unier (up to vari-
able renaming) for s and t if for all uniers ' of s
and t there exists a substitution  , such that ' =  .
The substitution  on term t is a substitution in own
variables of t if it does not introduce new variables,
i.e. Var(t)  Var(t), and does not contain a vari-
able renaming. This notion can be enlarged to a set
of substitutions.
An equation is a pair of terms e = (s; t). For con-
venience, the equations are written as s ' t with
undistinguished left and right hand side. A rewrite
rule is an ordered pair of terms r = (s; t) such that
Var(t)  Var(s). The rules are written s ! t. A
term rewriting system (or rewrite system for short)
is a nite set of rules R = fs! t j s; t 2 T (F ;X )g.
A rewriting relation ?!
R
(or ?! when R is ob-
vious) is the smallest relation containing R, closed
under substitution and replacement. The relation

?! denotes the reexive and transitive closure of
?!, the relation ? denotes the relation symmetric
to ?!, the equivalence relation

 ! denotes the re-
exive, symmetric, and transitive closure of ?!. An
ordering  is compatible with R if

?!
R
 .
A term t is reducible by the rule l ! r if there
exists an position a 2 Pos(t) and a substitution 
such that tj
a
= l. A term is R-reducible if it is
reducible by some rule from R. On the contrary, a
term is R-irreducible if it is not reducible by any rule
from R. A term t is a R-normal form of a term s if
s

?! t and t is R-irreducible. A rewrite system R is
interreduced if for all rules l ! r 2 R the left-hand
side l is R ? fl ! rg-irreducible and the right-hand
side r is R-irreducible.
149
2.2 Term rewriting systems
The following denitions review basic notions from
term rewriting systems theory used in this paper.
For details and related theorems see the references.
Denition 2.1 A term rewriting system R (and
also the rewriting relation

?!
R
) is
 terminating if there is no innite rewrite se-
quence t
1
?! t
2
?! : : :,
 conuent if

 ?
R
:

?!
R


?!
R
:

 ?
R
,
 convergent if it is conuent and terminating,
 canonical if it is convergent and interreduced.
Both basic properties, conuence and termination
of a rewrite system, are undecidable in general. For
issues on termination and reduction orderings
(well-founded orderings on terms closed under term
replacement and substitution) see the review by Der-
showitz [10]. For issues concerning conuence see the
article by Huet [25].
The following notion of critical pairs as overlap in-
stances of rewrite rules was introduced by Knuth and
Bendix [36]. Their production and orientation into
new rewrite rules is the backbone of their completion
procedure.
Denition 2.2 Let s
1
! t
1
and s
2
! t
2
be two
rewrite rules such that s
1
j
a
 = s
2
 holds for a
most general unier , and nonvariable position a 2
FPos(s
1
). Then hs
1
[t
2
]
a
; t
1
i is called a critical
pair of terms. Denote the set of all critical pairs
generated from a rewrite system R by cp(R). A crit-
ical pair ht; ti, for some term t, is called trivial.
The following construction was originated by
Lankford and Musser [38] and comes from Guttag,
Kapur and Musser [18]. They are mentioned also by
Dershowitz [10].
Denition 2.3 Let R be an arbitrary set of rules.
The set of overlap closures OC(R) of R is induc-
tively dened as follows:
1. Every rule s ! t from R is an overlap closure
s t.
2. Let s
1
 t
1
, s
2
 t
2
be two overlap clo-
sures. If t
1
j
a
 = s
2
 holds for a most gen-
eral unier  and position a 2 FPos(t
1
), then
s
1
 t
1
[t
2
]
a
is an overlap closure.
3. Let s
1
 t
1
, s
2
 t
2
be two overlap clo-
sures. If t
1
 = s
2
j
a
 holds for a most gen-
eral unier  and position a 2 FPos(s
2
), then
s
2
[s
1
]
a
 t
2
 is an overlap closure.
An overlap closure s s with the same terms on
both sides is called reexive.
This notion is related to the narrowing process, as
dened by Fay [15], Hullot [29], Lankford [37] and
Slagle [50], and to the superposition process dened
in [18]. The overlap closure provides the essence of
a specic method for proving termination of term
rewriting systems. A survey of related results can be
found in [10].
To dene better the divergence patterns let us in-
troduce the following relation between substitutions.
It was actually dened in [19].
Denition 2.4 The substitutions ' and  are co-
herent (denote it by ' ?  ) if Dom(')\Var( ) = ;
or Var(') \Dom( ) = ;.
2.3 Completion procedure
Given a nite set E of equations presenting a the-
ory and a program for (possibly incremental) com-
puting a reduction ordering  , a completion pro-
cedure deduces consequences of E in its attempt to
nd a convergent (conuent and terminating) rewrite
system R
1
for E. The central idea of comple-
tion is to limit attention to the critical pair deduc-
tions obtained from overlappings of left-hand sides
of rules. These critical pair overlappings are used
to generate new rules. The rst completion proce-
dure was proposed by Knuth and Bendix [36], and
completely proved correct by Huet [26]. Bachmair,
Dershowitz and Hsiang [5] have put completion in
a more abstract framework, based on the notion of
inference rules (see also [4] and [11]). An inference
rule (for this purpose) is a binary relation between
pairs (E;R), where E is a set of equations and R is a
set of rewrite rules. The generalized KnuthBendix
completion procedure is based on the set KB of six
inference rules, presented in Figure 1.
A completion procedure is a control strategy
for applying inference rules of KB to given input
equations and rewrite rules, using a reduction or-
dering compatible with these rewrite rules. The
result of a (possibly innite) completion sequence
(E
0
;R
0
) `
KB
(E
1
;R
1
) `
KB
   are the set E
1
=
lim
n!1
E
n
of persisting equations and the set R
1
=
lim
n!1
R
n
of persisting rules.
This inference rule based completion procedure
must be fair (processing of each critical pair cannot
be postponed innitely many times), correct (when-
ever the procedure nishes successfully, it produces a
convergent rewrite system), and sound (the smallest
equivalence relation generated by E [R remains the
150
Delete: (E [ fs ' sg;R) ` (E;R)
Compose: (E;R [ fs! tg) ` (E;R [ fs! ug) if t ?!
R
u
Simplify: (E [ fs ' tg;R) ` (E [ fu ' tg;R) if s ?!
R
u
Orient: (E [ fs ' tg;R) ` (E;R [ fs! tg) if s  t
Collapse: (E;R [ fs! tg) ` (E [ fu ' tg;R) if s ?!
R
u by l! r 2 R with s

 l
Deduce: (E;R) ` (E [ fs ' tg;R) if s ' t 2 cp(R) ?E
where

 denotes a proper encompassment ordering.
Figure 1: Inference rules of the completion procedure
same through the completion process). Formal de-
nitions of these three concepts can be found in [11].
The inference rules KB can be applied in many dif-
ferent ways, but all of them fair, correct, and sound.
We choose two of them. The rst is a general com-
pletion procedure complete as it was presented e.g.
by Huet [26] or in a more sophisticated way by Les-
canne [41], the second is a nonreducing completion
process nr-complete, generating all critical pair con-
sequences without interreduction. For corresponding
control strategies see [20].
Summarizing the possible performances, the com-
pletion procedure can succeed in generating a nite
convergent/canonical rewrite system R
1
, fail due to
an equation unorientable in a reduction ordering ,
or diverge trying to produce an innite rewrite sys-
tem R
1
.
3 Divergent term rewriting sys-
tems
This section recalls the theoretical notions and re-
sults from the paper [20], with a collection of exam-
ples presenting the divergence patterns.
For given rewrite rules R (or equations E), the
completion procedure performance depends on the
applied control expression and the input ordering .
Therefore, more hierarchically ordered types of di-
vergence can be observed.
Denition 3.1 Let R be a term rewriting system.
R is divergent in the ordering  if complete(R)
is innite. R is weakly divergent in the order-
ing  if nr-complete(R) is innite. R is inherently
(weakly) divergent if R is (weakly) divergent for
all orderings including

?!
R
.
Whether a rewrite system is inherently divergent it
depends on the structure of its rules. Each divergent
rewrite system is also weakly divergent. A connec-
tion between divergent and weakly divergent rewrite
systems is established by the following proposition.
Fact 3.2 Let R be a weakly divergent rewrite system
and let R
0
 R be a subsystem which is also weakly
divergent. If nr-complete(R
0
)  complete(R), then
R is divergent.
In establishing conditions for detection of diver-
gence there arises a question how large is the actual
class of divergent systems described by them, and/or
if it covers all possible divergent systems. Unfortu-
nately, the divergence problem is undecidable in gen-
eral even if it contains only monadic function sym-
bols and constants, as it was proved in [20] by a mod-
ication of the proof method used by Narendran and
Stillman [45].
From the undecidability of divergence follows that
it is reasonable to search only for sucient condi-
tions to detect divergent rewrite systems. The rest
of this section introduces as suciently general con-
ditions of this kind as possible to be able to describe
the largest class of divergent systems. The atten-
tion is oriented on examples actually presenting the
divergence patterns.
3.1 Forward crossed systems
The following denition describes a divergence pat-
tern for the class of rewrite systems with forward
oriented critical pairs. This pattern represents a fur-
ther generalization of the crossed rules notion dened
in [21, 22]. It also comprises the divergence types
(; ) (actually crossed rules) and (;=) (self-
crossed rule) described by Mong and Purdom [44].
For the technical description we refer to [20]. The
presentation here is focused more on the examples.
Denition 3.3 The rewrite rule s
1
! t
1
and the
nonreexive overlap closure s
2
 t
2
(with supposed
disjoint variables) form a forward crossed rewrite
151
system if there are substitutions 
2
, '
1
, '
2
in own
variables of s
2
, an idempotent substitution 
1
, and
positions a 2 FPos(s
1
), b 2 FPos(t
2
) such that
1. s
1
j
a

1
= s
2

2
2. t
2
j
b
'
1
= s
2
'
2
3. '
1
? ('
2
[ 
2
)
The second condition plus the coherence relation
'
1
? '
2
dene s
2
 t
2
to be a forward chain [19].
The previous denition supplies the static part of
conditions to detect forward divergent systems. The
dynamic part of conditions, introduced in the follow-
ing denition, puts requirements on the ordering of
generated critical pairs.
Denition 3.4 The rewrite system R is LR-
persistent in the ordering  if for each nontrivial
critical pair of terms hs
1
[t
2
]
a
; t
1
i 2 cp(R
1
) fol-
lows s
1
[t
2
]
a
 t
1
.
The prex LR- indicates that the produced critical
pairs are oriented in the straight direction, from left
to right .
From these two notions the following proposition
was proved in [20], which guarantees that the pre-
vious conditions are sucient for weak divergence.
Of course, interreduction is not admitted, but for
many examples the Fact 3.2 can be applied, so that
divergence of these systems is implied as well. For
conditions on interreduction in divergence see [20].
Theorem 3.5 If R contains a LR-persistent for-
ward crossed rewrite system then R is weakly diver-
gent.
Let us consider now the examples that belong to
the forward crossed divergence pattern. It is a collec-
tion of divergent systems observed during real speci-
cations as well as articial cases constructed in the
eort to nd more and more complex conditions that
would cover even a greater class of divergent systems.
Example 3.6 It has been almost a common folklore
(this example was mentioned among others by Fri-
bourg [16] and by G√∂bel [17]) that if you extract the
rules
(x
0
+ y
0
) + z ! x
0
+ (y
0
+ z) (1)
x+ s(y) ! s(x + y) (2)
from a rewrite system specifying natural numbers
with addition and you try to complete them, using
recursive path ordering RPO with the precedence
+ > s and a left-to-right status of +, the result
will be a divergent process. The rule (2) forms the
forward chain, the positions are a = 1 and b = 1,
and the substitutions are 
1
= [x
0
7! x; y
0
7! s(y)],

2
= [ ], '
1
= [y 7! s(y)], '
2
= [ ]. The completion
procedure generates the innite family of rules
s
n
(x+ y) + z ! x+ (s
n
(y) + z)
from them. This is also the reason why the proof
by consistency [32] of the associativity in the rewrite
system
x+ 0 ! x
x+ s(y) ! s(x + y)
using an unappropriate reduction ordering (RPO
with the precedence + > s in this case) results in
an innite loop, as described by Dershowitz [11] and
Fribourg [16].
In [21] the rewrite system
x+ 0 ! x (3)
x+ s(y) ! s(x + y) (4)
gcd(x; 0) ! x
gcd(0; x) ! x
gcd(x
0
+ y
0
; y
0
) ! gcd(x
0
; y
0
) (5)
specifying the greatest common divisor of two nat-
ural numbers was proved as divergent. It contains
a forward crossed system consisting of the rules (4)
and (5). The rule (4) forms the forward chain, the
positions are a = 1 and b = 1, and the substi-
tutions are 
1
= [x
0
7! x; y
0
7! s(y)], 
2
= [ ],
'
1
= [y 7! s(y)], '
2
= [ ], as in the previous
case. The completion procedure, using RPO with
the precedence + > s, generates the innite family
of rules
gcd(s
n
(x+ y); s
n
(y)) ! gcd(x; s
n
(y))
from rules (4) and (5), plus another innite family
gcd(s
n
(x); s
n
(0)) ! gcd(x; s
n
(0))
derived from the rst one by the rule (3). The
second innite family cannot be produced inde-
pendently because the underlying overlap closure
x+s(0) s(x), constructed consecutively from the
rules (4) and (3), does not form a forward chain.
To show that divergence problems are not caused
only by natural number specications, let us consider
also other algebraic structures.
Example 3.7 A very simple and elegant example
of a forward crossed system is Associativity & En-
domorphism. It was considered by Bellegarde [7],
152
BenCherifa with Lescanne [9], and Martin [43]. The
rewrite system
(x
0
+ y
0
) + z ! x
0
+ (y
0
+ z)
f(x) + f(y) ! f(x + y)
under completion, using RPO with the precedence
+ > f and the left-to-right status of +, produces
a forward crossed divergent system. The Endomor-
phism rule forms the forward chain, the positions
are a = 1 and b = 1, and the substitutions are

1
= [x
0
7! f(x); y
0
7! f(y)], 
2
= [ ], '
1
= [x 7!
f(x); y 7! f(y)], '
2
= [ ]. The completion procedure
generates the innite family of rules
f
n
(x+ y) + z ! f
n
(x) + (f
n
(y) + z)
from it.
Similar to the previous system is Associativity &
Distributivity studied by Lescanne [40], and men-
tioned also by Martin [43] and Mong together with
Purdom [44]. The rewrite system
(x
0
+ y
0
) + z
0
! x
0
+ (y
0
+ z
0
)
(x  y) + (x  z) ! x  (y + z)
under completion, using RPO with the precedence
+ >  and a left-to-right status of +, produces a di-
vergent system. It is actually a forward crossed sys-
tem with the Distributivity rule forming the forward
chain, and the substitutions 
1
= [x
0
7! x  y; y
0
7!
xz], 
2
= [ ], '
1
= [y 7! xy; z 7! xz], '
2
= [ ]. As
a matter of fact, it is a variation of the previous di-
vergent system, where the operation f is interpreted
as a curried multiplication.
A divergent system need not consist of only two
rules, as the previous examples were. The cardinal-
ity of divergent systems is not even bound. On the
other hand, one rule can be sucient to produce a
divergent system.
Example 3.8 There exists a one-rule forward
crossed system
f(g(f(x))) ! g(f(x))
introduced by Ardis [1], and observed among oth-
ers by Dershowitz with Marcus [13, 14] and Kirch-
ner [35]. This only rule stands for both objects
required by the Denition 3.3. The positions are
a = 1:1 and b = 1, the substitutions are 
1
= [x 7!
g(f(x))]
1
, 
2
= [ ], '
1
= [x 7! g(f(x))], '
2
= [ ]. The
1
The ambiguity in variables can be resolved by doubling
the rewrite rule and splitting the variables.
completion procedure generates the innite family of
rules
f(g
n
(f(x))) ! g
n
(f(x))
from it.
This one-rule divergent system bears another phe-
nomenon. If we want to assure termination of rewrit-
ing by the generated system, its rules cannot be or-
dered in the opposite direction. Therefore the diver-
gence of this system is inherent .
There exists also a forward crossed rewrite system
consisting of a given number of rules, where the pres-
ence of all rules is necessary to maintain the diver-
gence. As it was proved in [21], the rewrite system
f
n+1
(f
n 1
(x
0
)) ! x
0
f
i
(f
n
(x)) ! f
i 1
(x) for i = 2; : : : ; n? 1
f
1
(f
n
(x)) ! f
0
(f
n 1
(x))
ordered by RPO based on the precedence f
i
> f
j
for i > j, is divergent for all n, but each proper
subset of it can be completed to a nite canon-
ical system. The rst rule presents the basis of
divergence and the rest forms the forward chain
f
n 1
(f
n 1
n
(x)) f
0
(f
n 1
(x)). The substitutions
are 
1
= [x
0
7! f
n 1
n
(x)], 
2
= [ ], '
1
= [x 7!
f
n 1
n
(x)], '
2
= [ ]. The completion procedure gener-
ates the innite family of rules
f
n+1
(f
k
0
(f
n 1
(x))) ! f
k(n 1)
n
(x)
from it, plus all the intermediate innite families ac-
cording to the rules that participate in forming the
forward chain.
When someone looks properly on the previously
presented examples, he or she may ask why the Def-
inition 3.3 is so complicated. Not the denition is
too complicated, but the examples were too easy.
They all satisfy the simpler conditions from [22].
Let us analyze more sophisticated systems where all
the conditions of Denition 3.3 must be applied and
where the conditions from [22] appear not to be su-
cient enough. The only drawback of these examples
is that they are articially constructed and do not
reect any reasonable algebraic structure. Neverthe-
less, when they are divergent, they should be covered
by the denition, as it is also true in our case.
Example 3.9 A more general forward crossed
rewrite system is
2
d(x
0
 h(y
0
)) ! y
0
(x
 y)  y ! k(x k(y))
2
The circled operators are to be considered only as syntac-
tic objects, and not as real operators.
153
If we try to complete this system, using RPO based
on the operator precedence 
 >  and 
 > k, we
get a divergent process. The second rule forms the
forward chain. The substitutions are 
1
= [x
0
7!
x 
 h(y); y
0
7! y], 
2
= [y 7! h(y)], '
1
= [x 7! x 

k(y)], '
2
= [y 7! k(y)]. The completion procedure
generates the innite family of rules
d(k
n
(x k
n
(h(y)))) ! y
from it.
A similar case presents the forward crossed rewrite
system
d(x
0
 (x
0

 y
0
)) ! y
0
g(x)  y ! g(x (x y))
only that it is of the second type. If we try to com-
plete it, using RPO based on the operator precedence
 > ,  > g and a left-to-right status of , we
get a divergent process. The second rule forms the
forward chain. The substitutions are 
1
= [x
0
7!
g(x); y
0
7! y], 
2
= [y 7! g(x) 
 y], '
1
= [x 7! g(x)],
'
2
= [y 7! g(x)  y]. The completion procedure
generates the innite family of rules
d(g
n
(x (x (g(x) : : : (g
n
(x)
 y))))) ! y
from it.
Of course, not all systems are so clear to analyze.
There can be systems with more than one forward
chain or systems with multiple overlap positions. Let
us look at such system which has been encountered
as a practical case.
Example 3.10 The following rewrite system spec-
ies the signed binary trees theory [34]. It is pre-
sented here as an extract from a (canonical) rewrite
system specifying groups. It is the system
i(i(x)) ! x
i(x  y) ! i(y)  i(x)
(y  x)  i(x) ! y
i(x)  (x  y) ! y
If we try to complete this system, using RPO based
on the operator precedence i > , we get a divergent
process. First, the rules
(y  i(x))  x ! y
x  (i(x)  y) ! y
are produced, then the innite iterative process be-
gins. The clue here is that the underlying rewrite
system
i(i(x)) ! x
i(x  y) ! i(y)  i(x)
generates an innite set of independent forward
chains. Therefore an innite set of innite families
of rules is produced. Although it is a little bit sur-
prising, it is coherent with the theories in [20] and
in [35]. The forward chain producing rewrite system
is canonical, thus decidable, so that every computa-
tion modulo whichever forward chain is also decid-
able.
3.2 Backward crossed systems
The following denitions describe another divergence
pattern for the class of rewrite systems with back-
ward oriented critical pairs. This pattern was in-
troduced in [22] only by an example, and was not
treated formally. Its denition covers the divergence
types (;) (reverse crossed rules) and (=;) (re-
verse self-crossed rule) described by Mong and Pur-
dom [44], but it is more compact. For its technical
description we refer once more to [20]. Here we focus
our attention more on the examples actually present-
ing the divergence pattern.
Denition 3.11 The overlap closure s
1
 t
1
and
the nonreexive rewrite rule s
2
! t
2
(with sup-
posed disjoint variables) form a backward crossed
rewrite system if t
1
is not a variable, there are sub-
stitutions 
1
, '
1
, '
2
in own variables of s
1
, an idem-
potent substitution 
2
, and position b 2 FPos(s
1
)
such that
1. s
1
j
b

1
= s
2

2
2. t
1
'
1
= s
1
j
b
'
2
3. '
1
? ('
2
[ 
1
)
The second condition plus the coherence relation
'
1
? '
2
dene s
1
 t
1
to be a backward chain [19].
The previous denition supplies the static part of
conditions to detect backward divergent systems. If
it was only for the static parts, a duality principle
could be established between forward and backward
crossed rewrite systems, originating from a similar
one between forward and backward chains [19]. The
dynamic part of conditions, introduced in the follow-
ing denition, which puts requirements on the order-
ing of generated critical pairs, is the main dierence
between the notions dened in 3.3 and 3.11, making
them to two completely dierent divergence patterns.
Denition 3.12 The rewrite system R is RL-
persistent in the ordering  if for each nontrivial
critical pair of terms hs
1
[t
2
]
a
; t
1
i 2 cp(R
1
) fol-
lows t
1
  s
1
[t
2
]
a
.
154
The prex RL- indicates that the produced criti-
cal pairs are oriented in the opposite direction, from
right to left .
From the previously dened notions the following
proposition was proved in [20], which guarantees that
the previous conditions are sucient for weak diver-
gence. The same discussion concerning interreduc-
tion as in the case of forward crossed systems applies
in this case, too.
Theorem 3.13 If R contains a RL-persistent back-
ward crossed rewrite system then R is weakly diver-
gent.
Let us consider the examples that belong to the
backward crossed divergence pattern. This diver-
gence type is not so common as the previous one,
at least not so many real cases of it are known yet.
Example 3.14 An elegant example of a backward
crossed system is the (decidable) theory of bands
(idempotent semigroups)
(x  y)  z ! x  (y  z)
x
0
 x
0
! x
0
studied by Siekmann with Szab√≥ [49], and in connec-
tion with divergence by Dershowitz [11] and Kirch-
ner [35]. The Associativity rule produces an innite
number of independent backward chains, depending
on the multiple choice of overlap positions.
As a marginal remark, it should be mentioned also
that there exists no canonical unconditional rewrite
system for idempotent semigroups [49].
Also in this type there exist multiple rule divergent
systems as well as a one-rule divergent system. The
one-rule system is an extract from a real example in
this case.
Example 3.15 Extracting the rule
(xny)nz ! yn(i(x)nz)
from a rewrite system for deciding groups with left
division, studied by Lescanne in [42], and ordering
it by RPO based on the precedence n > i and the
left-to-right status of n, presents a backward crossed
system. Once more, an innite number of indepen-
dent backward chains is produced from the starting
rule.
There exists also a backward crossed rewrite sys-
tem consisting of a given number of rules, where the
presence of all of them is necessary to maintain the
divergence. It is the rewrite system
f
1
(f
0
(x
0
)) ! x
0
f
n
(f
i 1
(x)) ! f
i
(f
n
(x)) for i = 2; : : : ; n? 1
f
n
(f
n 1
(x)) ! f
1
(f
n
(x))
oriented by RPO based on the precedence f
i
> f
j
for i > j. It is divergent for all n, but each proper
subset of it can be completed to a nite canon-
ical system. The rst rule presents the basis of
divergence and the rest forms the backward chain
f
n 1
n
(f
1
(x)) f
1
(f
n 1
n
(x)). The substitutions are

1
= [x 7! f
0
(x)], 
2
= [x
0
7! x], '
1
= [ ],
'
2
= [x 7! f
n 1
n
(x)]. The completion procedure
generates the innite family of rules
f
1
(f
k(n 1)
n
(f
0
(x))) ! f
k(n 1)
n
(x)
from it, plus all the intermediate innite families ac-
cording to the rules that participate in forming the
backward chain.
Also in this divergence type articially constructed
systems can be presented that reect very well the
conditions required by the Denition 3.11.
Example 3.16 Consider the rewrite system
f(x _ g(y)) ! f(x) _ y
(x
0
^ y
0
) _ y
0
! y
0
If we try to complete this system, using RPO based
on the operator precedence f > _, we get a divergent
process. The rst rule forms the backward chain.
The substitutions are 
1
= [x 7! x ^ g(y)], 
2
=
[y
0
7! g(y)], '
1
= [y 7! g(y)], '
2
= [x 7! f(x)]. The
completion procedure generates the innite family of
rules
f
n
(x ^ g
n
(y)) _ y ! f
n
(g
n
(y))
from it.
A similar case presents the backward crossed
rewrite system
(x
 f(y))  y ! (x y) 
 y
(x
0
 y
0
)
 y
0
! x
0
If we try to complete this system, using RPO based
on the operator precedence  > 
, we get a di-
vergent process. The rst rule forms the backward
chain. The substitutions are 
1
= [x 7! x  f(y)],

2
= [x
0
7! x; y
0
7! f(y)], '
1
= [y 7! f(y)],
'
2
= [x 7! x  f(y)]. The completion procedure
generates the innite family of rules
((((x  f
n+1
(y))  f
n
(y))  : : : f(y))  y) 
 y !
((x  f
n
(y)))  : : : f(y)  y
from it.
155
3.3 Undecidability of crossed systems
In many rewrite systems the existence of a crossed
subsystem can be shown immediately. Of course, we
may ask if it is decidable that complete(R) contains
a crossed system. Unfortunately, it is not.
Theorem 3.17 It is undecidable in general whether
the completion procedure generates a crossed system.
Proof: The result was proved by Narendran and
Stillman [45] for crossed pairs, so that it can be im-
mediately applied to forward crossed systems. A mi-
nor modication extends it also to backward crossed
ones. 2
The result of Narendran and Stillman [45] has
an immediate implication that all divergence con-
ditions, which cover the case of the one-rule system
f(g(f(x))) ! g(f(x)), are undecidable.
4 Avoiding divergence of com-
pletion
A divergent term rewriting system is an unpleasant
fact one has to deal with. The intention is directed
towards the goal to obtain a nite canonical rewrite
system. Therefore something must be done with
the original system to avoid its divergence but to
maintain its semantics. Basically, there exist two
approaches: a theoretical one and an empirical one.
The theoretical approach was formally dened and
exploited by Kirchner [35]. It is an universal one
that allows describing divergent systems by meta-
rules. It is the only complete method that allows
to cope directly with inherently divergent systems.
On the other hand, it is not necessary to use the
heavy artillery immediately when a divergent sys-
tem is encountered, because the divergence of most
rewrite systems is a result of specication errors.
Also the meta-rule approach is not, to our knowl-
edge, yet implemented in existing rewrite rule labo-
ratories. Therefore it can be more convenient to use
empirical methods which are, of course, not as so-
phisticated as the theoretical approach, but can be
applied in the existing rewrite rule laboratories.
The following parts describe ve empirical meth-
ods for avoiding divergence of rewrite systems,
graded by the complexity of actions provided by the
user. As a matter of fact, there exists one more
method to avoid divergence, namely upgrading to
equational rewriting and thus to equational com-
pletion [4, 30]. Although equational term rewriting
provides a powerful generalization which eliminates
many abnormal failure and divergent cases, its func-
tionality is based on the premise of existence of a
complete and nite equational unication algorithm,
which rarely exists for an arbitrary set of equations
E. Moreover, the equational term rewriting method
bears another problem, namely the innite complete
set of uniers, which presents another type of diver-
gence [35]. Therefore it needs a broader space of
investigation. For these reasons it is not analyzed
here. On the other hand, the unfailing completion
procedure, as it was presented in [6, 24], does not
avoid the divergence problem. One can prove very
easily that if the completion procedure with the con-
trol complete diverges then the unfailing completion
procedure diverges as well.
4.1 Changes within ordering class
The rst empirical method to attack divergence con-
sists of changes within an ordering class to obtain
a new concrete ordering. It can be a change of the
underlying operator precedence and/or status in a
recursive path ordering [10], in a recursive decompo-
sition ordering (with status) [42], or in another re-
lated incremental ordering. It can also be a change
of the underlying symbol precedence and/or weight
in a KnuthBendix ordering [36, 43], or a change of
the polynomial interpretation in a polynomial order-
ing [9].
Basically, it is always a (relatively minor) change
to an underlying structure of the used ordering class.
Within the incremental orderings it can be per-
formed by backtracking. The aim of these changes
is to order one or more equations in the opposite
direction, so that the critical overlaps, which were
the starting points of divergence, disappear. This
method replaces objects satisfying either the Deni-
tion 3.3 or the Denition 3.11. The equivalence rela-
tion

 !, generated by the rewrite system, remains
the same, but the normal forms obtained by the re-
arranged system (under the assumption that it can
be completed to a nite canonical system) may not
correspond with the initial intentions. This method
has also its limits because there need not be enough
possibilities to choose from during the completion
process.
Example 4.1 One of the possibilities to resolve the
divergence of the natural number rewrite system is
to change the precedence to s > + in RPO and thus
obtain the canonical system
(x+ y) + z ! x+ (y + z)
s(x + y) ! x+ s(y)
156
where the second rule was ordered in the opposite
direction. Although it is a possible solution, it does
not satisfy the requirement that the successor oper-
ator s should be a constructor, if the rule x+ 0! x
would be added.
Another and a better possibility consists of chang-
ing only the status of + to right-to-left. In this case
we obtain the canonical system
x+ (y + z) ! (x+ y) + z
x+ s(y) ! s(x + y)
where now the rst rule was ordered in the oppo-
site direction. The successor operator s can be then
declared a constructor in the enlarged system.
The divergent system presented by Associativity
& Endomorphism can be resolved by changing the
precedence to f > + and thus producing the canon-
ical system
(x+ y) + z ! x+ (y + z)
f(x + y) ! f(x) + f(y)
where it is also the second rule that has been ordered
in the opposite direction. So far it seems to be an
acceptable solution, unless you want to reduce the
number of f operators in terms by the completed
rewrite system.
In articially constructed divergent systems the
orientation of rules does not play a signicant role,
therefore this method can be fully applied in Exam-
ples 3.9 and 3.16. We get consecutively the canonical
systems
d(x h(y)) ! y
k(x k(y)) ! (x
 y)  y
by changing the precedence to k > 
 and k > ,
d(x (x
 y)) ! y
g(x  (x y)) ! g(x) y
by changing the precedence to g > ,
f(x) _ y ! f(x _ g(y))
(x ^ y) _ y ! y
by changing the precedence to _ > f , _ > g, and a
left-to-right status of _, and last but not least
(x y) 
 y ! (x 
 f(y))  y
(x y) 
 y ! x
by changing the precedence to
3

 > , 
 > f , and
a left-to-right status of .
3
There are also other possible changes of precedence.
Let us consider also rewrite systems ordered by
other ordering classes, in particular the Knuth
Bendix ordering and the polynomial ordering.
Example 4.2 As it was pointed out in [36], the clas-
sical presentation of group theory by the rewrite sys-
tem
e  x ! x
i(x)  x ! e
(x  y)  z ! x  (y  z)
ordered by the KnuthBendix ordering with the
precedence i >  > e, the weight w() = 0, and
the weight of the inverse operator being w(i) > 0,
causes divergence under completion. As analyzed by
Mong and Purdom [44], the completion procedure
produces two crossed subsystems. It is the forward
crossed system
x  i(y  x) ! i(y) (6)
(x  y)  z ! x  (y  z)
and the backward crossed system
i(x)  i(y) ! i(y  x) (7)
i(x  i(y)) ! y  i(x)
The rule (7) in the second system is the real culprit
as indicated in [36], therefore it has to be reoriented.
As a consequence, the rule (6) is not generated any
more. The reorientation can be achieved by changing
the weight of the operator i to w(i) = 0. After that
the standard ten-rule canonical rewrite system for
groups is generated under completion [43].
Example 4.3 The Associativity & Endomorphism
rewrite system in Example 3.7 can be ordered in
the same sense by the polynomial interpretation
[f ](X) = 2X and [+](X;Y ) = X
2
+ Y . It still re-
mains divergent, producing the same innite family
of rules [9]. Fortunately, this system can be proved
to be terminating also using the polynomial interpre-
tation [f ](X) = 2X and [+](X;Y ) = XY +X. The
nice property of this interpretation is that it makes
possible to complete the rules to the canonical sys-
tem
(x+ y) + z ! x+ (y + z)
f(x) + f(y) ! f(x + y)
f(x) + (f(y) + z) ! f(x + y) + z
where the number of f operators in terms can be
reduced by the completed system.
157
The presented method to avoid divergence has its
limits. Changing the precedence to  > i in the
Example 3.10 does not bring anything, and in both
one-rule systems there exists only one choice of prece-
dence in the recursive path ordering. Moreover, the
recursive path ordering remains always too uniformly
persistent, thus it orders critical pairs notoriously in
the same direction. Therefore a change of its under-
lying precedence must make the closure chain non-
operational.
4.2 Changing the ordering class
The second empirical method consist of changing
completely the ordering class. It has to be applied
when the previous one does not resolve the problem
of divergence (ordering class is somehow monotone)
or the completed canonical system does not corre-
spond with the user's intentions. Although there
exist some ordering hierarchies [48], no one order-
ing class is necessarily `better' then another, because
the termination of rewrite systems is undecidable in
general [10, 28]. The aim of this method is to break
a persistence inherent in certain orderings.
The proposed method attacks the conditions of the
Denition 3.4 or of the Denition 3.12. The equiv-
alence relation

 ! remains again the same. The
user's contribution to this method is essential, even
if the proposed ordering is implemented in the used
rewrite rule laboratory, hence it is automatized. On
the other hand, one can use also the method of Pur-
dom [46], based on no ordering class, but on checking
the set of rules for looping .
Example 4.4 Let us consider once more the Asso-
ciativity & Endomorphism rewrite system. Suppose
that f is a costly operator, and this rewrite system is
proposed to optimize the term expressions with re-
spect to f , so that the user can decrease the number
of its uses to minimum. Therefore ordering the rule
f(x) + f(y) ! f(x+ y)
forces to use the precedence + > f in RPO.
This causes divergence of completion, as already de-
scribed. Just as we look at the rst generated rule
f(x+ y) + z ! f(x) + (f(y) + z)
we can see that it does not t our intentions with
decreasing the number of f operators.
The recursive path ordering and also the recursive
decomposition ordering are not suitable for ordering
this rewrite system according to our conditions. As it
was shown already in the Example 4.3, there exists a
polynomial interpretation which allows to produce a
nite canonical rewrite system by the polynomial or-
dering. The same nite canonical system can be ob-
tained if using the KnuthBendix ordering in which
we set w(f) > 0 [43]. There is also a possibility to
use a transformation ordering [3, 8].
4.3 Separating closure chains
This method is applicable within the enlarged com-
pletion procedure in the sense of Huet and Hul-
lot [27], which takes advantage from an explicit dec-
laration of constructors. The method proposes the
separation of a closure chain into a sequence of less
complex equations. It can be described formally by
the inference rule Separate (see Figure 2). As it can
be seen from the inference rule Separate, the trans-
formation is applicable only to closure chains which
have a common root symbol in the term on both
sides. The chaining process is supposed to disappear
after this transformation. The equivalence relation

 !, generated by the original system, remains the
same.
Example 4.5 Consider the one-rule backward
crossed rewrite system
f(g(f(x))) ! f(h(x)) (8)
ordered by RPO based on the precedence f > h (or
g > h). Trying to complete the system results in
generation of the innite family of rules
f(h
n
(g(f(x)))) ! f(h
n+1
(x))
Now, if we declare f to be a constructor, the
rule (8) (considered as equation) is separated into
a new equation, which can be ordered to the rule
g(f(x)) ! h(x)
choosing the precedence g > h. This new rule
presents already a canonical system.
4.4 Dividing closure chains
The fourth empirical method is rooted in a process
proposed as early as in the pioneering article [36],
but cannot be considered as completely valid in com-
parison with standard completion, because the term
algebra is changed (the signature is extended dur-
ing the completion by a new function symbol). This
method consists of dividing the underlying closure
chain into two dierent parts, introducing a new op-
eration symbol, and breaking this way the chaining
process. It can be formally expressed by the inference
rule Divide (see Figure 2). The method is especially
devoted to inherently divergent and one-rule crossed
systems.
158
Separate: (E [ ff(s
1
; : : : ; s
n
) ' f(t
1
; : : : ; t
n
)g;R) ` (E [ fs
i
' t
i
j i = 1; : : : ; ng;R)
if f is a constructor
Divide: (E [ fs ' tg;R) ` (E [ fs ' f(x
1
; : : : ; x
n
); t ' f(x
1
; : : : ; x
n
)g;R)
where f is a new symbol, and Var(s) \ Var(t) = fx
1
; : : : ; x
n
g
Figure 2: Additional inference rules
Example 4.6 Consider once more the one-rule for-
ward crossed system
f(g(f(x))) ! g(f(x)) (9)
observed in Example 3.8 as inherently divergent. Let
us divide the rule (9) into the (not yet reduced)
rewrite system
f(g(f(x))) ! h(x)
g(f(x)) ! h(x)
and enrich the precedence with g > h. If we complete
the previous system, we get the canonical system
f(h(x)) ! h(x)
g(f(x)) ! h(x)
g(h(x)) ! h(h(x))
Although it has some successful applications, this
method is fragile. Applying it to the example of the
idempotent semigroup or the one-rule system
(xny)nz ! yn(i(x)nz)
does not bring the desired eect.
4.5 Enriching underspecied systems
The last proposed and probably the most power-
ful empirical method to avoid divergence consists
of enriching given systems by new rewrite rules. It
must be applied very carefully, otherwise the original
rewrite system can be compromised and another -
nite canonical rewrite system is obtained, which does
not correspond with the original rules. It can be ac-
cepted only as a practical method, because the un-
derlying equational theory is changed by the added
rule. This method attacks the conditions of the
Fact 3.2, where the enriched system remains weakly
divergent but not generally divergent any more. The
new rule is added to interfere with interreduction,
that causes a divergence object to disappear in some
completion step.
The probably best way to proceed in this method
is described in following steps:
1. remove the divergence basis rule(s) from the sys-
tem R, producing R
0
,
2. complete the residual set of rules R
0
to a -
nite canonical rewrite system R
2
(Recently,
there was a method for proving inductive the-
orems proposed in [23], which does not re-
quire the underlying system to be conuent,
not even on ground terms. Therefore this step
may be skipped when using the just mentioned
method.),
3. prove in R
2
by consistency [27, 32], or by in-
ductive reducibility [31, 33], with a possible in-
volvement of Fribourg's method [16] or even the
more general Bachmair's one [2], an inductive
theorem, derived from the structure of the gen-
erated innite family of rules, and add it as a
rule to the existing system R
2
, producing R
0
2
,
4. add the rules removed in step 1 to R
0
2
, forming
an enriched system R
e
, and try to complete it.
Sometimes even a more-cycle iteration of the previ-
ous steps may lead to a desired solution with a nite
canonical system.
The theoretical justication to extend the original
rewrite system by inductive theorems presents the
fact that the extended system R
e
is ground consistent
with the original system R [32].
Proposition 4.7 [32] For all ground terms s; t 2
G(F) the equivalence s

 !
R
e
t holds if, and only if,
s

 !
R
t.
It means that rewriting ground terms with both the
basic and the extended systems yields the same re-
sult. An open question remains the fact how to infer
the new rule, to be proved as an inductive theorem
of the original system, with which the extension is to
be done.
When we add inductive theorems to the original
system, we are interested in its initial model. If
we want to prove an inductive theorem in an initial
model, this model must be nonempty. This requires
the existence of at least one constant. If there is none
so we just introduce a dummy one.
159
? @ x ! x
x @ ? ! x
(x @ y) @ z ! x @ (y @ z)
flatten(?) ! ?
flatten([x]) ! flatten(x)
flatten([x] @ y) ! flatten(x) @ flatten(y) (10)
flatten(flatten(x)) ! flatten(x) (11)
ordered by RPO based on the precedence flatten > @ and a left-to-right status of @.
Figure 3: Rewrite system with the operation atten
Example 4.8
4
Let us consider a rewrite system
specifying lists, with the operators ? for an empty
list, [_] for an one-element list, and the append oper-
ator @. Let us dene a flatten operator that trans-
forms structured lists to lists consisting of only sim-
ple elements. The rewrite system is presented in Fig-
ure 3. If we try to complete this system, we get
a divergent process. The rules (10) and (11) form
a forward crossed rewrite system with the forward
chain (10).
We remove the involution (11) and the residual
system is already canonical. We are able now to
prove the endomorphism rule
flatten(x @ y) ! flatten(x) @ flatten(y)
as its inductive theorem. We add it to the system
and take back also the involution rule (11), forming
the extended system. This extended system is com-
pletable to the nite canonical system
? @ x ! x
x @ ? ! x
(x @ y) @ z ! x @ (y @ z)
flatten(?) ! ?
flatten([x]) ! flatten(x)
flatten(x @ y) ! flatten(x) @ flatten(y)
flatten(flatten(x)) ! flatten(x)
The rule to be removed must be considered care-
fully. If we remove the wrong one, it can be even
generated during completion of the residual system
(dragon's head).
Example 4.9 Let us consider once more the rewrite
system in Example 3.10 that could not be resolved
4
This example is constructed from a divergent inductive
theorem proof.
by the previous empirical methods. If we remove the
antimorphism rule
i(x  y) ! i(y)  i(x)
and try to complete the residual system, then the
just removed rule will be generated from the other
rules again.
The right way consists of removing the rules
(y  x)  i(x) ! y
i(x)  (x  y) ! y
and the residual system
i(i(x)) ! x
i(x  y) ! i(y)  i(x)
is already canonical. There is no constant in the
system so we introduce a dummy one denoted by e.
We are able now to prove the associativity rule
(x  y)  z ! x  (y  z)
as its inductive theorem. We add it to the system
and take back also the removed rules, forming the
extended system. If we try to complete it, the critical
pair
x  i(x) = i(y)  y
is produced, which cannot be ordered because of the
disjoint variables on the left- and right-hand side of
the equation. It can be regarded as a request for a
new operator. Therefore we divide the critical pair
to the rules
x  i(x) ! e
i(y)  y ! e
using the already introduced symbol e as the neu-
tral element and extending the precedence with  >
160
e. After this action the rules are completable to
the standard ten-rule canonical rewrite system for
groups.
It must be admitted that this method has its lim-
its, too, especially in the case of one-rule divergent
systems. There is nothing to be removed; if the
only rule is removed then virtually nothing can be
proved as an inductive theorem in an empty system.
Therefore one has to proceed in another way. One of
the operators has to be decided as a non-constructor
and then the rules to dene it completely have to be
added.
Example 4.10 Consider once more the extracted
rule
(xny)nz ! yn(i(x)nz)
from the group specication with left division. Let us
decide the inverse operator i to be a non-constructor
and therefore to add the rules
5
i(xny) ! ynx
i(i(x)) ! x
i(e) ! e
to dene it completely. To make possible the order-
ing of the new rules in the proposed direction, the
underlying precedence must be changed to i  n.
The enriched system is already canonical. If we add
also the rule
xne ! i(x)
we get the nite canonical system
(xny)nz ! yn(i(x)nz)
i(xny) ! ynx
i(i(x)) ! x
i(e) ! e
xne ! i(x)
enx ! x
5 Conclusion
We described two basic divergence patterns, the for-
ward and backward crossed rewrite systems with LR-
or RL-persistence respectively, by their denition
from [20]. Further we presented in detail a num-
ber of examples to make the denitions more under-
standable and to support them as well. Although the
5
It is necessary to introduce the neutral element e as a
constant.
divergence property is undecidable in general, the
described divergence patterns seem to be sucient
enough to cover a large class of divergent systems,
if not all of them. In the last section we introduced
ve empirical methods to avoid divergence of com-
pletion, which can be applied by an user during a
session with a rewrite rule laboratory.
Acknowledgements
I would like to express my warmest thanks to H√©l√®ne
Kirchner, Leo Bachmair, Jieh Hsiang, and Pierre
Lescanne for comments and suggestions which helped
to ameliorate the early versions of this paper.
References
[1] M.A. Ardis. Data abstraction transformations.
Technical report TR-925, University of Mary-
land, Maryland (USA), 1980.
[2] L. Bachmair. Proof by consistency in equational
theories. In Proceedings 3rd IEEE Symposium
on Logic in Computer Science (LICS'88), Ed-
inburgh (Scotland), pages 228233, July 1988.
[3] L. Bachmair and N. Dershowitz. Commu-
tation, transformation and termination. In
J.H. Siekmann, editor, Proceedings 8th Inter-
national Conference on Automated Deduction
(CADE'86), Oxford (England), volume 230 of
Lecture Notes in Computer Science, pages 520.
Springer-Verlag, July 1986.
[4] L. Bachmair and N. Dershowitz. Completion
for rewriting modulo a congruence. Theoreti-
cal Computer Science, 67(2-3):173202,October
1989.
[5] L. Bachmair, N. Dershowitz, and J. Hsiang. Or-
derings for equational proofs. In Proceedings 1st
IEEE Symposium on Logic in Computer Science
(LICS'86), Cambridge, (Massachusetts, USA),
pages 346357, June 1986.
[6] L. Bachmair, N. Dershowitz, and D.A. Plaisted.
Completion without failure. In H. A√Øt-Kaci
and M. Nivat, editors, Proceedings of Resolution
of Equations in Algebraic Structures, Lakeway,
(Texas, USA); Volume 2: Rewrite Techniques,
pages 130. MCC Corporation & INRIA, Aca-
demic Press, 1989.
[7] F. Bellegarde. Rewriting systems on FP expres-
sions to reduce the number of sequences yielded.
161
Science of Computer Programming, 6(1):1134,
January 1986.
[8] F. Bellegarde and P. Lescanne. Transforma-
tion ordering. In H. Ehrig, R. Kowalski,
G. Levi, and U. Montanari, editors, Proceed-
ings of CAAP '87, Pisa (Italy), volume 249 of
Lecture Notes in Computer Science, pages 69
80. TAPSOFT '87, volume 1, Springer-Verlag,
March 1987.
[9] A. BenCherifa and P. Lescanne. Termination of
rewriting systems by polynomial interpretations
and its implementation. Science of Computer
Programming, 9(2):137159, October 1987.
[10] N. Dershowitz. Termination of rewriting. Jour-
nal of Symbolic Computation, 3(1 & 2):69116,
1987. Special issue on Rewriting Techniques and
Applications.
[11] N. Dershowitz. Completion and its applica-
tions. In H. A√Øt-Kaci and M. Nivat, editors, Pro-
ceedings of Resolution of Equations in Algebraic
Structures, Lakeway, (Texas, USA); Volume 2:
Rewriting Techniques, pages 3186. MCC Cor-
poration & INRIA, Academic Press, 1989.
[12] N. Dershowitz and J.-P. Jouannaud. Notations
for rewriting. Bulletin of the European Associa-
tion for Theoretical Computer Science, 43:162
172, February 1991.
[13] N. Dershowitz and L. Marcus. Existence and
construction of rewrite systems. Technical Re-
port ATR-82(8478)-3, Aerospace Corporation,
El Segundo, California, 1982.
[14] N. Dershowitz, L. Marcus, and A. Tarlecki.
Existence, uniqueness, and construction of
rewrite systems. SIAM Journal on Computing,
17(4):629639, August 1988.
[15] M. Fay. First-order unication in an equational
theory. In S. Sickel, editor, Proceedings of the
4th Workshop on Automated Deduction, Austin
(Texas, USA), pages 161167, February 1979.
[16] L. Fribourg. A strong restriction of the induc-
tive completion procedure. Journal of Symbolic
Computation, 8(3):253276, September 1989.
[17] R. G√∂bel. Ground conuence. In P. Lescanne,
editor, Proceedings 2nd Conference on Rewrit-
ing Techniques and Applications (RTA'87),
Bordeaux (France), volume 256 of Lecture Notes
in Computer Science, pages 156167. Springer-
Verlag, May 1987.
[18] J.V. Guttag, D. Kapur, and D.R. Musser. On
proving uniform termination and restricted ter-
mination of rewrite systems. SIAM Journal on
Computing, 12(1):189214, February 1983.
[19] M. Hermann. Chain properties of rule clo-
sures. In B. Monien and R. Cori, editors,
Proceedings 6th Symposium on Theoretical As-
pects of Computer Science (STACS'89), Pader-
born (Germany), volume 349 of Lecture Notes
in Computer Science, pages 339347. Springer-
Verlag, February 1989.
[20] M. Hermann. Crossed term rewriting systems.
Research report 89-R-003, Centre de Recherche
en Informatique de Nancy, 1989. Included in [?].
[21] M. Hermann and I. Pr√≠vara. On nontermina-
tion of Knuth-Bendix algorithm. Research re-
port VUSEI-AR-OPS-3/85, Institute of Socio-
Economic Information and Automation in Man-
agement, Bratislava, Czechoslovakia, November
1985.
[22] M. Hermann and I. Pr√≠vara. On nontermination
of Knuth-Bendix algorithm. In L. Kott, editor,
Proceedings 13th ICALP Conference, Rennes
(France), volume 226 of Lecture Notes in Com-
puter Science, pages 146156. Springer-Verlag,
July 1986.
[23] D. Hofbauer and R.-D. Kutsche. Proving in-
ductive theorems based on term rewriting sys-
tems. In J. Grabowski, P. Lescanne, and
W. Wechler, editors, Proceedings of the Inter-
national Workshop on Algebraic and Logic Pro-
gramming, Gaussig (Germany), volume 343 of
Lecture Notes in Computer Science, pages 180
190. Springer-Verlag, November 1988.
[24] J. Hsiang and M. Rusinowitch. On word prob-
lems in equational theories. In T. Ottmann,
editor, Proceedings of the 14th ICALP, Karl-
sruhe (Germany), volume 267 of Lecture Notes
in Computer Science, pages 5471. Springer-
Verlag, July 1987.
[25] G. Huet. Conuent reductions: Abstract prop-
erties and applications to term rewriting sys-
tems. Journal of the Association for Computing
Machinery, 27(4):797821, 1980.
[26] G. Huet. A complete proof of correctness of the
Knuth-Bendix completion algorithm. Journal of
Computer and System Science, 23(1):1121, Au-
gust 1981. Also as: Rapport 25, INRIA, 1980.
162
[27] G. Huet and J.-M. Hullot. Proofs by induction
in equational theories with constructors. Jour-
nal of Computer and System Science, 25(2):239
266, October 1982.
[28] G. Huet and D.S. Lankford. On the uniform
halting problem for term rewriting systems.
Rapport de recherche 283, Institut de Recherche
en Informatique et en Automatique, Le Ches-
nay, France, 1978.
[29] J.-M. Hullot. Canonical forms and unication.
In W. Bibel and R. Kowalski, editors, Proceed-
ings 5th International Conference on Automated
Deduction (CADE'80), Les Arcs (France), vol-
ume 87 of Lecture Notes in Computer Science,
pages 318334. Springer-Verlag, July 1980.
[30] J.-P. Jouannaud and H. Kirchner. Completion
of a set of rules modulo a set of equations.
SIAM Journal on Computing, 15(4):11551194,
November 1986.
[31] J.-P. Jouannaud and E. Kounalis. Automatic
proofs by induction in theories without con-
structors. Information and Computation, 82:1
33, 1989.
[32] D. Kapur and D.R. Musser. Proof by con-
sistency. Articial Intelligence, 31(2):125157,
February 1987.
[33] D. Kapur, P. Narendran, and H. Zhang. On
sucient completeness and related properties
of term rewriting systems. Acta Informatica,
24(4):395415, August 1987.
[34] C. Kirchner and H. Kirchner. R√©solution
d'√©quations dans les alg√®bres libres et les var-
i√©t√©s √©quationelles d'alg√®bres. Master's thesis,
Universit√© de Nancy I, 1982.
[35] H. Kirchner. Schematization of innite sets of
rewrite rules generated by divergent completion
process. Theoretical Computer Science, 67(2-
3):303332, 1989.
[36] D.E. Knuth and P.B. Bendix. Simple word prob-
lems in universal algebras. In J. Leech, edi-
tor, Computational Problems in Abstract Alge-
bra, pages 263297. Pergamon Press, Oxford,
1970.
[37] D.S. Lankford. Canonical inference. Research
report ATP-32, Department of Mathematics
and Computer Science, University of Texas,
Austin, Texas (USA), December 1975.
[38] D.S. Lankford and D.R. Musser. A nite termi-
nation criterion. Unpublished draft, Informa-
tion Sciences Institute, University of Southern
California, Marina-del-Rey, CA, 1978.
[39] P. Lescanne. Computer experiments with the
Reve term rewriting system generator. In Pro-
ceedings of the 10th ACM POPL Symposium,
Austin, (Texas, USA), pages 99108, January
1983.
[40] P. Lescanne. Divergence of the Knuth-Bendix
completion procedure and termination order-
ings. Bulletin of the European Association for
Theoretical Computer Science, 30:8083, Octo-
ber 1986.
[41] P. Lescanne. Completion procedures as transi-
tion rules + control. In J. D√≠az and F. Orejas,
editors, Proceedings of TAPSOFT '89, Volume
1: CAAP '89; Barcelona (Spain), volume 351 of
Lecture Notes in Computer Science, pages 28
41. Springer-Verlag, March 1989.
[42] P. Lescanne. On the recursive decomposition
ordering with lexicographical status and other
related orderings. Journal of Automated Rea-
soning, 6:3949, 1990.
[43] U. Martin. How to choose the weights in the
Knuth-Bendix ordering. In P. Lescanne, edi-
tor, Proceedings 2nd Conference on Rewriting
Techniques and Applications (RTA'87), Bor-
deaux (France), volume 256 of Lecture Notes
in Computer Science, pages 4253. Springer-
Verlag, May 1987.
[44] C.-T. Mong and P.W. Purdom. Divergence in
the completion of rewriting systems. Technical
report, Dept. of Comp. Science, Indiana Univer-
sity, 1987.
[45] P. Narendran and J. Stillman. It is undecid-
able whether the Knuth-Bendix completion pro-
cedure generates a crossed pair. In B. Monien
and R. Cori, editors, Proceedings 6th Sympo-
sium on Theoretical Aspects of Computer Sci-
ence (STACS'89), Paderborn (Germany), vol-
ume 349 of Lecture Notes in Computer Science,
pages 348359. Springer-Verlag, February 1989.
[46] P.W. Purdom. Detecting looping simplica-
tions. In P. Lescanne, editor, Proceedings 2nd
Conference on Rewriting Techniques and Appli-
cations (RTA'87), Bordeaux (France), volume
256 of Lecture Notes in Computer Science, pages
5461. Springer-Verlag, May 1987.
163
[47] B. K. Rosen. Tree-manipulating systems and
Church-Rosser theorems. Journal of the Associ-
ation for Computing Machinery, 20(1):160187,
January 1973.
[48] M. Rusinowitch. Path of subterms ordering
and recursive decomposition ordering revisited.
Journal of Symbolic Computation, 3(1 & 2):117
131, 1987.
[49] J. Siekmann and P. Szab√≥. A N√∑therian and
conuent rewrite system for idempotent semi-
groups. Semigroup Forum, 25:83110, 1982.
[50] J.R. Slagle. Automated theorem-proving for
theories with simpliers, commutativity, and as-
sociativity. Journal of the Association for Com-
puting Machinery, 21:622642, 1974.
164
