J. Symbolic Computation (1987) 4, 295-334 
Simpli fying Condit ional Term Rewrit ing Systems : 
Unification, Terminat ion and Confluence 
STEPHANE KAPLAN 
LRI. Bdt. 490 
Universit~ des Sciences 
F-91405 Orsay (France) 
In the field of conditional term rewriting systems, the reduction of a given 
term involves recursive reduction of the premises of the rule currently 
applied, which leads to intractability, In this paper, we introduce simplifying 
systems, that allow to control this recursivity. Our approach enables the 
extension of several results for non-conditional rewriting to the conditional 
framework. In particular, we obtain results about he correctness of evalua- 
tion procedures, unification in conditional theories, termination and 
confluence, together with Knuth-Bendix theorem proving methods. Finally, 
the extension of such results to fully general conditional systems i discussed. 
Introduction 
During the past decade, much attention has been devoted to term rewriting 
systems in several fields of computer science concerned with symbolic mani- 
pulation. Rewriting may be viewed as a way of executing prototypes of enti- 
ties that are modelized via an abstract, algebraic specification. It allows an 
operational simulation of the action of a certain' kind of formulae on an alge- 
bra of abstract terms, each term canonically representing an entity. Very 
often, algebraic specifications naturally arise under the form of conditional 
specifications ; the rewrite rules associated with these specifications are con- 
ditional rules of the form : 
r" ?h~lui = vi ~ ~. -~ p. 
Where as non-conditional term rewriting systems have been thoroughly stu- 
died for several years, investigations in the field of conditional rules are rela- 
tively recent. They have mainly been developed into two directions : 
0747-7171/87/060295+40 $03.00/0 © 1987 Academic Press Limited 
296 S. Kaplan 
• a first attempt was to consider such systems without restrictions on the 
rules, as in Bergstra & K.lop (1982), Kaplan (1984). However, simple 
questions uch as "does a term t rewrite into t' ?" are undecidable. The 
consideration of such systems is therefore mainly of theoretical interest ; 
• severn authors have then imposed strong restrictions on the rules that 
axe admitted, in order to avoid infinite recursive evaluation within the 
~.n_lUi=V i part (called the premise) of the rule. In these approaches, there 
is a hierarchy between the rules, and the premises must be evaluated at a 
lower layer of the hierarchy (cf. e.g. Pletat et al., 1981; Drosten, 1983; 
Rrmy, 1982; R~my & Zhang, 1985). 
In this paper, we introduce a large class of conditional rules for which most 
of the interesting properties are still decidable. These systems are constrained 
to satisfy the property :
for every rule r, % > p and ~ > u i, ~, > v i 
where > is a given simplification ordering. This requirement is at the same 
time simpler than the ones described so far in the literature, and more gen- 
eral, i.e. it is fulfilled by a larger class of rules : in particular, recursion 
between the premises and the conclusion of the rules is authorized. The pro- 
petty intuitively means that the complexity of one computation step, and of 
the tests needed to perform this step, is decreasing. Consequently, all compu- 
tations will terminate. It naturally extends the requirement ")~ > p" generally 
imposed in the non-conditional case. For such "simplifying" systems, we 
show that several important results obtained in the case of classical rewrking 
carry over to our formalism, in a natural and systematical way. These proper- 
ties are richer and apply to a larger class of rules than the ones obtained 
within the second approach, and without the undecidability drawback of the 
ftrst approach. 
This paper is organized as follows. The first section states results about gen- 
eral conditional equations and rewrite roles. Simplifying systems are intro- 
duced, and a rewriting procedure is shown to be totally correct for them. 
Termination issues axe considered. 
In section 2, the notion of narrowing in the framework of simplifying condi- 
tional term rewriting systems is presented. It is then applied to a unification 
algorithm for condkional theories presented by a simplifying systems. 
Section 3 addresses the question of the confluence of such systems; a 
Knuth-Bendix-like completion procedure is presented and discussed. 
In section 4, we consider the applications of our formalism to the proof of 
inductive conditional properties in conditional theories. We describe struc- 
tured theories for which this method applies and give proof examples. 
In section 5, we discuss extensions of our previous results to a larger frame- 
work. In particular, a Knuth-Bendix theorem about the confluence of fully 
Conditional Term Rewriting Systems 297 
general conditional term rewriting systems is given. The proof method of 
section 5 is extended and illustrated by examples. 
Finally, our notion of simplifying conditional term rewriting systems is com- 
pared to other works in section 6. 
Notations : 
We sum up here the notations that are used throughout this paper, along with 
some classical results ; the notations are consistent with standard ones in the 
field of term rewriting systems (cf. e.g. Huet & Oppen, 1980). We present 
our definitions and results in case of the single-sorted operators ; extensions 
to the multi-sorted case (cf. e.g. ADJ, 1978) are straightforward, and will be 
used freely in our examples. 
A signature consists of a finite family E of operator names, with an arity 
function. T~ denotes the set of the terms that are well formed on E. X 
stands for a denumerable s t of variables. Tz(X) is the algebra of the terms 
with variables. For a term t in Tz(X) , Var(t) denotes the variables of X 
appearing in t. A substitution is an application t~ • X ~ Tz(X) that is equal 
to the identity almost everywhere, t~ may be extended in a unique way into 
a morphism g • T::(X) ~ Tr(X). We generally assimilate c and g and write 
t(r instead of or(t). For two substitutions cr and ~', co '  stands for the substi- 
tution such that tt~a'=(tcr)c'. Also, we write ~<~' if there exists a substitu- 
tion Ix such that 6'=crlx. For a substitution or, we respectively define its 
domain and its image by Dom(cr) = {xaX I c~(x)~x} and Im((~) = {or(x), 
x~ Dom(c~) }. Lastly, if Vc_X, ~1 v is the restriction of cr to V. 
A precongruence is a binary predicate on T~: or T~:(X), often denoted by ~,  
that is 'compatible' with the operators of E : if x/i, t i l t ' i ,  then f(tl,...,tn) 
f(t'l,...,t'n). Let ~ be a precongruence. Its reflexive and transitive closure is 
denoted by ---~*. The inverse relation ~-1 of ~ is defined by : t---~-lt ' iff 
t'---~t. We shall often write t,t'---~u instead of t--~u and t'----~u. A term t is a 
normal form (or irreducible) if there exists no t' such that t~t ' .  If t---~*t' and 
t' is a normal form, we say that t' is a normal form of t. The relations $ and 
$ are defined by tSt' iff there exists a u such that t,t --~ u, and t$__t' /ff there 
exists a normal form u such that t,t --~ u. We say that --~ is noetherian (or 
finitely terminating) if there is no infinite sequence of terms (ti)~0 such that 
t I - -~  t 2 --~ . . .  ~ t n - -~  . . .  Lastly, ~ is confluent if for every terms t,t' and t" 
such that t----~*t',t" hen t'$t", and locally confluent if whenever t---~t',t" , then 
t'J,t". When ~ is noethefian, confluence and local confluence are equivalent 
properties. 
A congruence is a precongruence which is also an equivalence r lation. The 
set PCongr z of the precongruences, and the set Congr~ of the congruences on 
T z or T~(X), both ordered by inclusion, are complete lattices. 
298 S, Kaplan 
For a term t and an occurrence co in t, t lo ~ denotes the subterm of t occurring 
at 03. Then t[03<---t'] stands for t where rio ~ is replaced by t'. Lastly, two 
terms t and t' are unifiable if there exists a substitution 't such that t't = t"c.  
In that case, there exists a substitution or, called the most general unifier 
(m.g.u.) of t and t', such that for every unifier c '  of t and t', c<~' .  
I. Evaluation Procedure and Simplifying Systems 
1.1 Basic Results 
In this paragraph, we present general definitions and basic results about con- 
ditional term rewriting systems. 
Definition 1.1 
• A conditional term rewriting system (conditional TRS) is a finite set 
of formulae, called conditional rewrite rules, with the following form : 
r :  /~.n__lUi=V i =:~ ~,---~p. 
• Such a system is said to be steady if it satisfies the condition :
Var(•) ~ Var(p) t.A (k.)in=lVar(ui)k.)Var(vi)). (i). 
Notes : 
- Prem(r)=(/~n_lui=vi) is called the premises of the rule r, and the Lop  part is 
called the conclusion of r. We let Vat(r) = Var(~,) uVar(p) 
u(ui~_-lVar(ui)wVar(v~)). 
- As a general convention in this paper, we shall suppose that name conflicts 
between variables are avoided ; this means for instance that for two distinct 
rules r and r' in R, Var(r)~Var(r')=O. This can always be achieved by suit- 
able variable renaming, which does not modify the interpretation of the rules 
that we define hereafter. 
The purpose of condition (i) is to guarantee that no equation solving is 
needed to apply a role. This would intuitively be the case with a rule such 
as:  
f(x,y,z) = c~ ~ g(x,y) o h(z) 
Reducing a term g(t,t') then requires to search for a z such that f(t,t',z)=a. 
In this paper, we focus mainly on steady conditional systems; however, 
non-steady systems are considered in section 5. 
Definition and lemma 1.2 
Given a conditional TRS R, there exists a smallest precongruence o R 
on T~:(X) satisfying t oR  t' iff there is a rule r : 
Ai'nlui=vi ~ ~,op  in R such that 
- there exists a substitution cr : X o Tr(X) and an occurrence 
co in t such that tlo ~ = ~,c and t' = t[o~--p~] , 
- for any i~ [1..n], ui~ ,1, R vi~, 
with t '~R t' if there exists a u such that t,t ---~R u. 
Conditional Term Rewriting Systems 299 
So, a given rule may be applied to a term if and only if its premises, instan- 
tiated by the matching substitution, are "satisfied"; this is recursively deter- 
mined by rewriting. Note that other interpretations of ~R are possible ; this 
is discussed in particular in Bergstra & Klop (1982), Kaplan (1984). We 
now provide an explicit construction of "-~R, that is used further on. Let 
PCongr z be the lattice of precongruences on Tz(X), ordered by inclusion. 
Consider the functional 3 : PCongr::--~ PCongrz associating to any -"~1 e 
PCongr z the smallest "~2 e PCongr z such that : 
• - - -~1C ----) 2 
• for any r : ~.nlU i = v i =~ L --~ p and any substitution or, 
if, for any ie [1..n], uicr .1,1 vic, then ~.cr ~2 per 
It is shown in Kaplan (1984) that O is continuous, and that its least fixpoint is 
precisely ---~R. As a consequence, --'>R may be constructed iteratively : ~R 
= U~I 3(i)(--,O), where --4 0 is the empty precongmence. 
Theorem 1.3 
(i) When --*R is confluent, then 
-=R = ('--)R W "---~i~1) * = '~R 
(ii) When "->R is confluent and noetherian, then 
-=R = ("~R L)'"~i~1) * -" "~R = ~-R 
Here, by convention, =R is the smallest congruence generated by the roles of 
R, interpreted as axioms. The proofs are by 0-induction and appear in 
Kaplan (1984). When "-->R is confluent and noetherian, each term t has a 
unique normal form, denoted by NFR(t). 
1.2. Recursivity in Steady Conditional TRS 
In this paragraph, we restrict to steady conditional term rewriting systems. In 
order to check whether a rule is applicable to a term, a first step is to search 
for a matching substitution c ; then, in case of success, all the variables of 
the premises are assigned a value via ~. The next step is therefore to check 
the equality of the premises instantiated by ~. However, this involves recur- 
sive evaluation of the premises by rewriting, which may lead to infinite 
loops. Consider for instance the following (one-rule) system :
r 0:  f(f(x))=a ~ f (x )~ a 
Could an evaluator for conditional TRS avoid going into the infinite loop of 
evaluating f(x), f(f(x)), ... even if, in effect, r o never applies ? We actually 
have :  
Theorem 1.4 
There exists a conditional TRS R such that "-->R is confluent and noeth- 
erian, but such that the relation "~R is non decidable and NF R is non 
computable. 
300 S. Kaplan 
Such an example appears in Kaplan (1984). We define now the following 
binary predicate : t--->->Rt' if there exists a rule r: hi.n__lUi = v i =:;, 9~ ---> p in 
R, an occurrence co of t and a substitution cr such that tlco=%a nd t'=uicr or 
t'=vi<~ for some ie [1..n]. Intuitively, this means that evaluating t (while try- 
ing to apply r) may lead to evaluate t'. Now, the crux of the problem is that 
one should guarantee termination of---->RL.)--->->R in order to ensure the termi- 
nation of a natural evaluation procedure. Indeed, consider the following pro- 
cedure NF R that captures the intuition of how to compute normal forms for 
--->R : 
Procedure NFR(t) 
choose a rule r :  h fn lu i=v  i ~ ~' ' -~P of R 
such that t lo ~ = ~.~ and 
for all i, NFR(Ui6) = NFR(Vi~) ) 
then return( NFR(t [ 03 ~ per ] ) 
when-no-other-choice return(t) 
end.procedure 
The previous procedure is non-deterministic, since in general several rule 
may be chosen at a given point to reduce a term. We then have the follow- 
ing correctness results (cf. Kaplan, 1984): for every possible execution of 
the procedure, y is a normal form of t when the procedure stops. 
Moreover, if --->RU--->->R is finitely terminating, 
- any non-deterministic execution of the procedure eventually stops, 
producing a normal form of t ; 
- there are finitely many different executions paths, and all the normal 
forms of t are computed along these paths. 
Now, in order to treat the noetherianity issue, we come to the central idea of 
the paper. We shall ensure that -->Rt.)--~ R is finitely terminating by imposing 
that, for every rule, the right-hand side and the premises are "simpler", in 
some sense, than the left-hand side. We use simplification orderings (cf. 
references hereafter) to this effect. A simplification ordering is a well- 
founded ordering > on T~(X) such that : 
f(...,t,...) > t (subterm property) 
if t > t' then f(...,t,...) > f(...,t',...) (compatibility). 
Def in i t ion  1 .5  
A conditional term rewriting system (not necessarily steady) is said to 
be simplifying if there exists a simplification ordering > such that for 
every rule ro fR  : hi.n=lui=v i =~ ~--->p, for all cr : X- ->T~:(X) ,  
then : 
(j) La > pcs 
(jj) x/i~ [1..n], ~cr > ui(r and )~ > vi~.  
Notes  : 
Conditional Term Rewriting Systems 301 
- The intuitive reasons for condition (j) and (jj) is that they ensure respec- 
tively the noetherianity of ---~gtJ---~ R (cf. theorem 1.6). 
- Condition (j) is generally imposed in the framework of classical term 
rewriting systems when termination is needed. Much attention has been 
devoted to  the conception of tools that generate orderings satisfying (j) (cf. 
e.g. Dershowitz, 1985; Detlefs & Forgaard, 1985 and Rusinowitch, 1985 for 
recent references on the topic). These methods also apply in order to guaran- 
tee condition (j j). 
- For people used to the "Logic Programming" paradigm, these two condi- 
tions may seem drastic. However, it should be remembered that our purpose 
is to deal with rewriting : computing the normal form of a given term must 
be a straightforward process. We intend to prevent here all the branching 
and backtracking that is involved along Logic Programming computations. 
The steadiness condition (i) was imposed for similar reasons. 
- These conditions may be slightly weakened, as remarked in Waldmann 
(1985). We also borrow from this work the denomination 'simplifying', 
which has less confusing connotations than the word 'fair' that we used in 
previous articles. 
- The following theorem states that simplifying conditional TRS fulfill the 
previous requirements. It may be considered as extending Dershowitz' 
Theorem (Dershowitz, 1979) to the conditional fxamework. 
Theorem 1.6 
Given a steady simplifying conditional TRS R, then : 
( i )  ~RU----~R are finitely terminating ; 
( i i )  -'->R is decidable and the procedure NF R computes 
correctly the normal form function associated with ~g.  
Proof : 
(i) If t----)Rt' , then tlco=kfr for a given rule r : ~ in lu i  = v i ~ ~, ----) p , an 
occurrence 03 of t and a substitution G. Then ~,o'>p~ by (j) and t=t[0a<---~,a] > 
t[03e--pcfl=t' by monotonicity. Thus t--->Rt' implies t>t'. Similarly, if t ;'R t', 
then t l~=La and t'=uicr (for instance). Then t>)~cr by the subterm property of 
>, and ~o'>uic by (jj). Thus, t>t'. [] 
(ii) By noetherian induction associated with >, let t be a term such that, for 
every t' with t>t', the normal form procedure applies correctly on t' (i.e. 
stops for every computation. Cf. supra). For any rule r : 
~'nlu i=  v i ~ %--~ p such that tl0~=~,cr, t is greater than any of the 
Ui(~,Vi( I  and by induction hypothesis, the body of the ehoose statement must 
terminate. Now, the first call NFR(t[o_~-pc]) terminates since t > t[03~--p(r]) 
as before, and using the induction hypothesis on t. [] 
The requirements on simplifying systems are sufficient o recover tractability 
for rewriting and normal form computations. We shall see in the following 
that it also allows to deal with several problems arising in the field of term 
302 S. Kaplan 
rewriting systems : unification in theories presented by conditional TRS, 
Knuth-Bendix criterion for confluence, completion procedure, proofs in con- 
ditional theories... These questions have well-known answers in the non- 
conditional case. This paper proposes solutions in the larger framework of 
(simplifying) conditional TRS. Now, steady simplifying systems have a 
natural induction principle, namely induction on >. Most of the proofs of 
this paper are carried out on the basis of this principle. Nevertheless, everal 
results that we present for steady simplifying TRS are also true for more 
general systems (this is examined in section 5) ; they need to be proven by 
0-induction (cf section 1.1), which is more difficult to manipulate than >- 
induction. Moreover, results obtained for non steady or non simplifying TRS 
are mainly of theoretical interest because of intractability. 
Example 1.7 : 
Let £ be the signature : 
0 : ~ integer 
s,p : integer ~ integer 
< : integer x integer ~ integer 
T,F : ~ boolean 
is a multi-sorted signature. 
Let R be the following term rewriting system :
{e l : spx  ~ x 
e2 :psx  ~ x 
e3 :0<0 --~ T 
e4 :0~p0 --~ F 
es :0 '~x=T :=~ 0<sx  ~ T 
e6 :0<x=F =~ 0<px ~ F 
e7 :sx<y ~ x<py 
es :px<y ~ x<sy  } 
R is steady and easily shown to be simplifying. It is shown in Kaplan 
(1984) that R modelizes the integers with the "less or equal" predicate. From 
a methodological point of view, this simplification is simpler and more 
natural than those one could write without conditional rules (though a con- 
venient non-conditional specification for this problem has been communi- 
cated to the author by M. Broy). 
2. Unification in Conditional Theories 
In this section, we suppose that a steady simplifying conditional TRS R is 
given, to which the congruence -- R on Tz(X) is associated. Given two terms 
u,v a Tz(X), we consider the following problem :
find all the substitutions G : X ~ Tz(X) such that uG - R v~. 
Conditional Term Rewrit ing Systems 303 
Such a (r is called a unifier of u and v in the algebraic theory defined by R 
(or a R-unifier). 
For two substitutions c o and cr, we say that ~0-~R(r /f-f there exists a substitu- 
tion p such that (~(x) -R  ((r0p)(x), for any variable x. A complete set of 
R-unifiers for two terms u and v is a set U of R-unifiers for u and v such 
that for any R-unifier c of u and v, there exists (roe U such that (;~Rc;. 
rl _ A clause C is a conjunction of equalities A~__lUi-V i The empty clause is 
denoted by 0 .  By extension, we say that a clause C is R-unifiable iff there 
exists a substitution c such that, for any i~ [1..n], ui~ = R viC;" 
• In the case of non-conditional theories, a satisfying answer to the problem 
of  the R-unification may be found in Fay (1979), HuUot (1980). A semi- 
decision procedure, based on the notion of narrowing, is described, that gives 
a complete (though possibly infinite) set of such unifiers. Let us recall the 
idea behind this method (notations are from Hullot, 1980). Given a role r • ~, 
19, t is narrowable in t' at occurrence co using role r and via a substitution 
(r (which we write : t N--~o~,r,~ r t'), if tic o and )~ are unifiable (with m.g.u.(r) 
and t '=t[o.~p](r.  Now, consider two terms t and t' in T~(X) that are R- 
unifiable. There exists a substitution c such that tcy -  R t'(r. Then : 
• either (r is a unifier of t and t' (in the usual sense) and classical 
algorithms give a most general unifier of t and t', 
• or one of the t(r, t'cr is --~R-reducible : otherwise, one could not 
have t(r _= R t'O. Suppose, for instance, that t(y may be reduced by 
the rule r : )~ --~ p (assuming that Var(t)c'~Var@)=O). For a suitable 
occurrence 03 in k and a substitution (y', then tcrlc o = )~o". Thus t is 
narrowable by r, via o~(r '  at occurrence 03. 
• The purpose of this part is to extend the previous method to the case of 
steady simplifying conditional TRS. As before, suppose that ta is reducible 
rl by a rule r : ~=lUi = v i ~ L --~ p with t(Ylo ~ = )~(r'. The main difference 
with the classical case is that the relation :
~lu i ( r '  - Rvi~' (°) 
must now hold. As previously, t and L are unifiable. Let Ix be their most 
general unifier. There exists p such that g'=l.tp. The relation (o) implies that 
Prem(r)~t is R-unifiable (via p). This leads to the foUowing definition • 
Definition 2.1 
Given two clauses C and C',  the couple (t,C) is narrowable into (t',C'), 
at a non-variable occurrence o3 of t, using role r • 
/kinlU i = V i :=> ~, --~ p ,  via substitution Ix, which we write : 
(t,C) "~"~0~,r,~ (t',C'), 
if : 
tim and L are unifiable (with most general unifier It) 
t' = t[03 e-- p]g 
C' = (C tj Prem(r))Jx 
304 S. Kaplan 
Note that checking whether (M,C) is narrowable into (M',C') is of syntacti- 
cal order, as it is in the non-conditional case. We now have several results 
similar to those of HuUot (1980), though in the larger framework of condi- 
tional term rewriting systems. 
Lemma 2.2 
Let R be a steady, simplifying and confluent conditional TRS. 
(a) With any ,,,,,--)-derivation : 
(1):  [To,Col "v">ro,oo "" '~'-'>r~-,,~,_, [Tn,Cn] 
with CO=~ and Ci+l=[CiuPrem(ri)]cri, 
such that C n has a unifier 0, 
one can associate a -->-derivation : 
(2) : to -->to "'" ">r._, tn 
such that : 
t i = ((yi...•n_10)(Ti) for 0<i.g.n-1 
t n = 0(Tn) .  
(b) With any --->-derivation : 
(2) : to -% ... ~r._l  tn 
and any normalized substitution rl0, 
one can associate a ,.,,->-derivation : 
(1) : [To,C0] " -%,o0  ... "~ro~,,~_, [Tn,C,] 
with C0=~ and Ci+l=[CiuPrem(ri)]ci, 
and normalized substitutions rli for 1<iS.n such that : 
- t i = Tli(Ti) for 0--<-i-~q 
- tin is a R-unifier of C n 
- 1]i = ((yi...~n_lTln)lDom(Th) for 0<i<n-1. 
Lemma 2.2 may be illustrated by the following diagram :
[T0 'C0]  '~¢--)ro,Oo "'" r~")r~-l.on-1 
11o 
to "'~ro "'" "-)r~-i 
[T.,C.] 
t~ 
Proof  of lemma 2.2 
The proof of lemma 2.2 is similar to the proof of Hullot (1980), but taking 
into account he conditions on the clauses C i. It reads as follows. 
(a) Let qi = (Yi '"(Yn-10 for 0<i<n-1 and qn = 0. Let t i = lqi(Ti). By 
hypothesis, we have Ttl co,oi = ~,i(Yi for 0<i~.n-1. Thus, 
" til co~ = r i i (T i  I ¢oi) = lq i+l(T i  I co,(Yi) = Th+l()~i(Yi) = 
Conditional Term Rewriting Systems 305 
But : 
~q~ (1) 
• ti+ 1 = Tli+l(Ti+ 1) = rh+l(Tioi[03i<--Pi~i] ) 
ti[coie--p0qi ] (2) 
Because of properties 
0<i<_<_n- 1. [] 
= rli+l (Ti) [coie--piTli ] 
• r h is a R-unifier of Prem(ri) for 0<i.~.n-1 (3) : 
By decreasing induction on i : the property is true for i=n-1 
because Zln = 0 is a R-unifier of C n = Cn_lCn_ 1 t.) Prem(ri)~i, 
and thus tin_ 1 = cn_l~ n is a R-unifier of  Prem(rn_l). Assuming 
that it holds for i+1, we know that' rli+t is a R-unifier of 
Ci+ 1 = City i u Prem(ri)~ i. So, similarly, rli = giqi+l is a R- 
unifier of  Prem(ri). [] 
(1), (2) and (3), we deduce that t i ---~,,~ ti+ 1 for 
(b) By induction on n. 
• For n = 0, there is nothing to prove. 
• We now suppose that the property is true for n, and consider a --+- 
derivation of length n+ 1 : 
(2) : to -%0 -" -°r,-~ tn "Or. tn+l" 
By induction hypothesis, there exists a ,~,--)-derivation of length n : 
(1) : [To,Co] '~">ro,Oo "'" "~Or,,-,,Oo-, [Tn'Cn] 
with C0=0 and Ci+l=[CitdPrem(ri)]Gi, 
and normalized substitutions Tli such that : 
- t i = Tli(Ti) for 0_<_iS.n 
-Tln is a R-unifier of C n 
- Tli ---- ((~i...(~n_l~n)[Dom(~t) for 0_<'L<-n-1. 
Now, t n = ~ln(Tn) reduces to tn+ 1 via a role r n : Cn ~ ~,n---)pn, and at an 
occurrence co n. con is also a (non-variable) occurrence of Tn:  otherwise, it 
would correspond to the occurrence of a subterm "qn(X) (with an x~ Var(Tn)) 
of T n and "fin would not be normalized. 
Let ~ be the matching substitution from t n tO tn+ 1. We have : Tnl0~ rln = kn~. 
Still supposing that Var(~n) c3 Var(~) = 0 ,  this implies that rlnU ~ is a unifier 
of  Tnl~0" and ~.  Let c~ n stand for their m.g.u. We have : Dom((y n) ~_ 
Dom(~n)UDom(~).  We can suppose without loss of generality that a n 
renames all the variables of  r n and that Im(~a)n(Dom(TIn)UDom(~)) = ~.  
There exists a substitution qn+l such that TIn~=CnTln+l. Again, it is not res- 
trictive to suppose that 
Dom(qn+t) ___ Dom(rln)WIm(an). Now, clearly, rl n = (t3nlqn+l) lDom(~.). Then, 
- let y~Dom('qn+l). We want to show that rln+l(y) is a normal form. There 
are two cases : 
, yalm(Cn).  Then there exists a variable xeDom(gn)  such that 
y~Var(~n(X)). Since rln(x) = qi+l(t~n(X)) is a normal form, so is 
306 S. Kaplan 
~i+l(Y)" 
• y4 Im((rn). Then crn(y) = y, and qn+l(Y) = rln(Y) is normalized. 
This shows that tin+ 1 is normalized. 
- Tn+ 1 = Tn(rn[Con<-"pnCrn]. So qn+l(Tn+l) = Tn~nqn+t[C0n<----Pn~nq.+l] 
tn[(0n<---rn~ ] = t.+ 1. 
- 1"!,1+ t is a R-unifier of Cn+I = CnOn ~ Prem(r,)o,, because : 
We 
(¢~nT~n+l)lDom(rl~), it is also the case that r h = ((Yi...(Yn_l~nTln+l)lDom(rh) 
0<i5.n-1. Indeed, this relation also holds for i=n. 
This terminates the proof of part (b). 
[] lemma 2.2 
Theorem 2.3 
Given a steady, simplifying and confluent TRS R, two terms U o and V o, 
and a new binary symbol @, consider all the ,.~->-derivations : 
%] ,v-->ro.o o ... Cn] 
with Co=O and Ci+l=[Ci~Prem(ri)]g i 
such that : 
• Tin ---- (anl]n+l)lDom(~.) is a R-unifier of C n (by induction hypothesis). 
A fortiori, rln+l is a R-unifier of Cn(~ n ; 
• let xaVar(r). Then x~Dom(~n) and ernrln+l(X) = {(x). So, the fact 
that ~ is a R-unifier of Prem(rn) implies that rln+l is a R-unifier of 
Prem(rn)(Yn. 
know that r l i= ((Yi"'(Yn-lTln)lDom(n.0 for  0<i<n-1. Since Tln = 
for 
- U n and V n are unifiable (of m.g.u Ix) 
- Cn~l .  admits a R-unifier d?. 
Then, the set of all the substitutions % = (O0...Cn_l~tdP)lVar(U0)uVar(V0) 
formed in the previous manner, constitutes a complete set of R-unifiers 
of u0 and Vo. 
Proof of Theorem 2.3 
Theorem 2.3 is the theoretical basis for the R-unification algorithm that we 
present later on. The following example will help illustrate its proof. 
Example 2.4 
Let us consider the system :
ro :X+X=0- -> (X+X)+X --->X 
r 1 : a(0,X) + a(0,X) --~ 0 
where a and + are two binary symbols, 0 is a constant and X is a variable. 
Let y, z, Z, w and w' be new variables and let us consider the following 
drawing, illustrating the search for a R-unifier of the terms y + z and 
a(w,w ' )  : 
Conditional Term Rewriting Systems 307 
[8 (Y+Z,CZ(w,w ' ) ) ,  1} ] "~ro,oo 
e((a(O,O)+(~(O,O))+~(O,O),  c~(O,O)) 
[ 8( z ,  ~(w,w')),  {z + z = O} ] 
-%° ~(~(0 ,0 ) ,  ~(0,0)) 
The R-unifier rio of U 0 and V o is obtained by composition of : 
- the narrowing substitution c~ o
- the m.g.u, g of U 1 and V 1 
- a R-unifier qb of CIIX 
further restricted to the variables {y, z, w, w'} of U 0 and V o which produces 
Z, as described in theorem 2.3. 
Proof of theorem 2.3 is as follows. 
• Let 2=(Oo...o,,_llx~)lv~tJo)~v~(Vo) be as in theorem 2.3. Consider the 
,~,~->-derivation : 
[~ (U0'V0)'C0] "*~">ro,Oo "" ""r-)r._1,cra_, [8 (Un,Vn),Cn] 
with Co=O and Ci+l=[CiwPrem(ri)]cri 
We can apply part (a) of lemma 2.2 with T i = @(Ui,Vi) and 0=}.t~. There 
exists a ---~-derivation : 
(2) : to = e (rlo(Uo),rlo(Vo)) -o  ... ---> t, = 8 (rl~(Un),'qn(Vn)). 
Since rln(Un) = ¢(UnlX) = ~(Vnls ) = Tln(Vn) , then rlo(U o) ,~o(Vo) 
~* Tln(Un)=rln(Vn), and Z : rl01Var(Uo)wVar(Vo) = (O0...Crn-l~)tV~O0uVat(Vo) 
is a R-unifier of Uo and V o. 
• Conversely, let r I be a R-unifier of U o and V o. We can write ~1 = ~P, 
with ~ = T I t Var(Uo)UVar(Vo) and p = r I I Dom(q)-(Var(Uo)uVar(Vo)) " Let us define 
the substitution 11o by rio(X) = ~(x),l,, for any variable x. Let uo---qo(Uo) and 
Vo-.--qo(Vo). We have u o ---- RVo. Let ~ = Uo$ = Vo-l,. There exists a ---~- 
derivation :
(2) : to = 8 (Uo,V O) --) ... ---) t n = ~ (cz,o0. 
110 is normalized. Using part (b) of lemma 2.2, there exists a ,-,,,-~- 
derivation :
(1) : [~(Uo,Vo),Co] "%,~0 '" '~%._,,oo_, [8(U.,v~),Cn] 
with Co=~ and Ci+l=[CiwPrem(ri)]oi, 
such that tin(@ (Un,Vn)) = 8(a ,a ) ,  which implies that tin is a unifier of Un 
and V n. Let g be theix rn.g.u. There exists a ~ such that 11 n = ~t~. By the 
proof of lemma 2.2, we know that tin = be is a R-unifier of C n. It follows 
that d~ is a R-unifier of Cn~t. We have 2 = (O0..AYn_lgt~)tVar(Uo)VVox(Vo) = "q0" 
308 S. Kap lan 
Thus, ~ = 1"10 -<R ~P = q, which shows that the set of the ~'s described in 
theorem 2.3 is a complete set of R-unifiers. [] Th2.3 
Theorem 2.3 makes it possible to give a semi-decision procedure computing 
a complete set of R-unifiers for two given terms. Before doing so, we notice 
that R-unification of two terms involves R-unification of clauses. Let us add 
a new binary 6~ to E (in order to map R-unification of clauses into simple R- 
unification). 
Lemma 2.5 
Let C = ~.nlUi=V i be a clause, and a a substitution. The two following 
properties are equivalent 
- cr is a R-unifier for C [i.e. ~.nlUit~ ----. R Vi(~ ] 
- ~ is a R-unifier of the two terms ult~...t~u n and vtt~...~v n 
We can now define the unification procedure. A clause C = (ul=vlA...AUn=Vn) 
to be unified will be represented by the term T = @( ul~...t~u n , vl~...t~v n ), 
in accordance with lemma 2.5. As a particular case, an equation u=v will be 
represented by the term T = ~(u,v). The call UnifR(~(U,V),0,O,e) will com- 
pute a complete set of R-unifiers for U and V. During the computation, a
recursive call of the procedure of the form UnifR(T,i,C,rc) will implement he 
search of a narrowing of [Ti,Ci] with the notations of lemma 2.2, T i = T and 
C i = C. 'i' is a recursion index and ~ stands for the product Co...ai_ 1. We 
adopt the convention that the procedure returns a particular element 'fai lure' 
when it fails, such that for any substitution or, a.fai lure = failure. The pro- 
cedure is as follows : 
Procedure .U. nifR[T, i ,  C ,  re] 
if I(T) and 2(T) are unifiable, of m.g.u. 
then 
t~ := UnifR[C~, 0 ,  ~ , e] ; 
return(rcgq~) 
else 
rl m choose  r" ~_ lu j  - v. ~ ~, --> p in R 
such that TI~ ..~d ~ are unifi.able, of m.g.u, c and 
(~ :-UnifR[l(T[o.~-p]g),2(T[a~-p]~),i+l,CG~Prem(r)cr,rcg ] ) 
failure 
then retum(~) 
when-no-other-choice return(failure) 
end.procedure 
The functions i and 2 are defined by l'[~(a,b)] = a and 2[@(a,b)] = b. The 
correctness of the procedure is stated by the next result. 
Theorem 2.6 
Conditional Term Rewriting Systems 309 
The 
tion 
previous procedure is a semi-decision procedure for the computa- 
of the R-unifiers of t o and t' o. 
- If t o and t' 0 admit a complete finite set of R-unifiers, the pro- 
cedure provides a complete finite set of unifiers after a finite 
amount of time, but may run forever. 
- If t o and t' o admit no complete finite set of R-unifiers but are R- 
unifiable, then the procedure runs forever and provides an (infinite) 
complete set of R-unifiers. 
- If t o and t' 0 are not R-unifiable, the procedure may run forever. 
Proof : 
The correctness of the procedure stems from the following facts : 
• when the procedure returns a substitution, this substitution is a R-unifier of 
the input (by theorem 2.3.) ; 
• consider a "successful" path described in theorem 2.3 leading to a R- 
unifier. Then an execution of the procedure will eventually follow the path, 
and produce the unifier : 
ad absurdum, suppose that the unifier is not reached. Then, there must 
exist a recursive call to the procedure that does not return. Now, by 
the construction of the path, this recursive call is on a pair of R- 
unifiable terms. Then, the only way this call cannot retum its result 
is to induce in turn another call to the procedure itself, and so forth. 
Thus, there is an infinite sequence of recursive calls to the procedure. 
Assuming now that R is a steady simplifying conditional TRS, with 
order > on the rules, it is easy to show that such a sequence of 
infinite calls would be strictly decreasing for >, which is contradic- 
tory. Let us check it on a typical configuration : 
suppose that during the evaluation of UnifR[T,i,C,n], the pro- 
cedure is recursively called. This means that T I ¢o=Lc. Thus : 
T > ~.(y (subterm property of >). 
Then : %g > uj6,  vj6 ('q j) (R is simplifying). 
Therefore : T > @ ([~juj](~ , [~jvj]~). [] 
Finally, this shows that the procedure will eventually produce very R-unifier 
described in theorem 2.3. 
Examples of unification of terms and clauses are given in the next three sec- 
tions. The previous unification procedure should be optimized in order to be 
suitably implemented. Typical optimizations are the ones used in the classical 
case (cf. Hullot, 1980; R6ty et al., 1985; Dershowitz & Plaisted, 1986). 
Moreover, several additive ones are relevant in our case . In particular, a 
unifier for Ci+l is also a unifier for C i. Thus, a narrowing for C i leading to no 
R-unifier may be discarded when unifying Ci+l. 
The questions addressed in this section have been considered from a close 
310 S. Kaplan 
point of view by Fribourg (84a,b), Paul (1985), Hussmann (1985), Geser & 
Hussmann (1986), Dershowitz & Plaisted (1986), Josephson & Dershowitz 
(1986). The main purpose of these authors is to extend the resolution 
mechanisms underlying logic programming to Horn clauses with equality. 
These methods are somehow more general than ours, since for instance the 
heads of the clauses need not be oriented, and termination is not compulsory. 
However, confluence is generally required, and these approaches do not pro- 
vide means to check for that property. On the other hand, we provide a 
satisfying treatment to this question under our formalism (cf. sections 3 and 
5). Lastly, we (partially) deal with the non-termination issue of the 
unification procedure with simplifying systems, since recursive calls are 
decreasing w.r.t, the associated simplification ordering >. 
The results of this section, in addition to their application to the unification 
problem, are thoroughly used in the next sections. 
3. Confluence for Steady Simplifying Conditional TRS 
3.1. Knuth.Bendix Criteria for the Confluence of Steady Simplifying 
TRS 
In section 1, noetherianity is treated via the use of shnpliflcation orderings. 
It seems natural at this point to consider the question of confluence for 
steady simplifying systems. Firstly, for steady conditional TRS (not neces- 
sarily simplifying) and afortiori for conditional TRS in their full generality, 
confluence is non-decidable (cf. Kaplan, 1984). Note that it is a/ways co- 
semi-decidable : ff "->R is not confluent, one can find an instantiated critical 
pair (cf. hereafter) by enumeration. For steady simplifying systems, we pro- 
vide in this section criteria ~ la Knuth-Bendix to decide confluence. Let us 
consider the following example :
Example 3.1 : 
R = { r 1 : even?(0) ---> T 
r 2 : even?(s(0)) ---> F 
r 3 : even?(s(s(x))) --, even?(x) 
r 4 : even?(x) = T ~ odd?(x) ---> F 
r 5 :even?(x )=F  ~ odd?(x)--->T } 
r 1 through r3 provide a (non-conditional) definition of the even? predicate on 
the integers, r 4 and r 5 form a (conditional) definition of odd? in terms of the 
predicate even?. Without consideration of the premises, a term odd?(x) 
might be rewritten into both of the terms 'T' and 'F'. For classical term 
rewriting systems, the pair <T,F> would be called a critical pair (cf. e.g. 
Knuth & Bendix, 1970; Huet & Hullot, 1980, and hereafter). However, these 
two reductions may take place if and only if the premises even?(x)=T and 
even?(x)=F are satisfied at the same time, which is not possible here. This 
Conditional Term Rewriting Systems 311 
leads to the following definitions :
Definition 3.2 
• Given a steady simplifying system R and two rules in R : 
m 
rl • ~"=1 Ul,i - vl,i =~' ~,l"~Pl and r 2 : ]ki.m~ u2i = v2i ~ ~.2----)p2 
such that ~'ti co and ~ are unifiable, co being a non varlable occurrence 
of L1.1 Let c~ be their most general unifier. The formula : 
((/kim{ Ul,i = Vl'i ) /~ (~.m~ U2,i = V2,i)) G ~ <~l[O)~....p2G],plG> ' 
is called a contextual critical pair [abbreviated CCP] in the critical con- 
text: 
m I Ill 2 
((~":i ul,i = vl,i)/k (~=1 uzi = v2,i))o. 
• A critical context (/k,.m 1 a i = bi) is called feasible iff it is R-unifiable 
(as a clause). 
• A CCP is said to be feasible iff its associated critical context is feasi- 
ble. 
In example 3.1, the only CCP is :  even?(x)=T/keven?(x)=F ~ <T,F>. Its 
critical context is non-feasible. In general, when testing confluence, only 
feasible critical pairs are taken into consideration. We can now formulate 
results stating the connection between criteria on the CCP's, and notions of 
confluence for steady simplifying conditional term rewriting systems. In the 
next theorem, ~R(C) stands for "(C) is R-unifiable" and t$ R is any normal 
form of the term t. 
Theorem 3.3 [Knuth-Bendix theorem for steady simplifying condi- 
tional TRS] 
Given a steady simplifying TRS R, consider the two groups of proper- 
ties : 
(i) --*R is locally confluent, and thus confluent on Tz(X) 
and 
(0) For every feasible CCP (C) =~ <t,t'>, then 
t$ R = t'$ R 
(1) For every feasible CCP (C) =~ <t,t'> , Yo : X ---) Tz(X) with 
~R(C)c,  then 
tO,~ R = t'O$ R 
Then : 
• (0) 
. (1)  
(1), 
(i) 
~4 t,t' ~ Tr(X), t - -R  t' iff t~. R=t' ,~ R
Proof : 
The last equivalence is a straightforward generalization of the classical case ; 
the (0) ~ (1) part is clear after the definition of these criteria, and (i) ~ (1) 
is by definition of the confluence property In the implication (1) ~ (i) lies 
312 S. Kaplan 
the difficult part of the theorem ; it is given in Appendix A. 
Notes : 
* It is not the case that (1) implies (0). The system 
p(x)=~ ~ f(x)-->g(x), 
p(x)=5 ~ f(x)--->h(x), 
p(a)---->5, p(b)--->5, 
g(a)--->a, h(a)--->a, 
g(b)--rl3, h(b)-->13, 
admits as contextual critical pair :  p(x)=8 ==> <g(x),h(x)>, that is feasible. 
However, g(x)$~:h(x)$. Thus (0) does not hold while (1) is clearly satisfied. 
* The equivalence ( i )~  (1) constitutes the extension of Knuth-Bendix 
theorem for classical systems (cf. Knuth & Bendix, 1970; Huet & Oppen, 
1980) to conditional TRS. It is the theoretical point that justifies a possible 
Knuth-Bendix-like completion procedure (that we denote KBCP(1 )) for steady 
simplifying conditional term rewriting systems - yet to be described. In 
KBCP(1 ), we shall use the fact that determining whether a contextual critical 
pair is feasible is exactly the same problem as unifying a clause in - R. This 
is precisely the question addressed in Section 2. 
. Nevertheless, it appears that KBCP(1 ) would make too intensive a use of 
the R-unification procedure ; its use would therefore be unrealistic in many 
practical cases. For this reason, we will focus in the sequel on a completion 
procedure based on criterion (0), that we denote KBCP(o ). KBCP(1 ) is how- 
ever discussed in Appendix B. 
3.2. The Completion Procedure for Steady Simplifying Systems 
As in the classical case, a completion procedure takes as input a system E of 
(conditional) equations, and attempts to produce a conditional term rewriting 
system RR that is noetberian and confluent, and such that = E and -= RR are 
equivalent on T~:(X). Of course, we shall impose incrementally that the sys- 
tems produced during the execution of the completion procedure are steady 
and simplifying. The procedure is then : 
Completion procedure KBCP(0)(E, R ,  i ,  >) 
if E= 
then return(R) -- STOP with success 
else 
choose an equation e : ~n__lui=v i => M=N in E 
such that e may be oriented into r : /~'nlUi-'V i ~ 3. .--> D, 
(3.,p) being one of (M,[.rt,NSg) or (N~R,M.I, It ) and so that 3. > p, 
u i, v i (for l_<i<n). 
AR := {r~R : ]k~nl~i=V i ~ 1 --> r I 1 or r contains an instance 
of 3.} ; 
Rlo c :=R+ {r} -AI~; 
Conditional Term Rewriting Systems 313 
CCP := the set of the contextual critical pairs of Rio ¢ 
CCPoK := O ; 
for [C =~ <t,t'>] e CCP do { 
i f  C is Rio:unifiable 
then CCPoK := CCPoK + [C ~ <t,t'>] } 
return( KBCP(o)( E - {e} + AR + CCPoK, Rio c , i+ l ,  > ) ) 
end-procedure 
Theorem 3.4 
The completion procedure takes a system of conditional equations E as 
input, and produces, whenever it stops, a system RR of conditional 
rewrite rules that is steady, simplifying and confluent, and such that: 
=E = ----RR" 
Proof : 
The correctness of the procedure comes from the following facts (E i and R i 
denoting respectively the value of E and R for the value i of the iteration 
index): 
(i) For every step i, - E = - EiuRi : 
By induction on i. The result is trivial for i = 0. Let us suppose 
that it holds for a given i_>0. With the notations of the procedure, 
we have Ei+l = E i - {e} + AR +CCPoK , and Ri÷ 1 = R i + {r} - 
AR. Since 'r' is simply the equation 'e' after orientation, it is 
dear that -= E~.,U - R~+, --~ -- El U -= P~. The converse is also true, 
since = RaU - e -- - CCPoK" [] 
(ii) R i is a steady simplifying system [because of the orientation step].. 
(iii) At STOP-WITH-SUCCESS,  R i = RR is locally confluent 
[it admits no feasible critical pair any more]. [] 
Notes : 
• This procedure is essentially similar to the one in Huet & Oppen (1980), 
except hat only feasible CCP's are retained. 
• In addition to the traditional failure cases of the K_nuth-Bendix completion 
procedure, additive cases introduced by our method are the following :
- the call to the Riot-unification procedure may lead to an infinite 
loop. This is inherent to the semi-completeness of the unification pro- 
cedure. Waldmarm (1985) suggests to put a bound on the depth of the 
narrowing; this bound is increased during the completeness pro- 
cedure, which ensures the correctness when i=+oo. Cf. also hereafter ; 
- the system may be compelled to orient a "harmless" CCP : (C) 
<M,M'> (with (C) feasible) and fail. This is the case when M,I% 
M',~Ra, though for every (r such that ~R(C)o, (Mcr),~l~ = (M'~)$1L. In 
this case, K_BCP(1) would recognize that (C) =~ <M,M'> needs not 
314 S. Kaplan 
be oriented, while KBCP(0 ) cannot. 
• During the normalization and orientation step, a contextual critical pair 
(C) ~ <M,M'> may be generated, such that neither M,I, > (C),I, nor M',I, > 
(C),[, for any simplification ordering. Thus, as opposed to what happens in 
the classical case, normalization of "the head" of a CCP can be harmful. On 
the contrary, normalizing the premises is never harmful, for if ~, > (C), then 
a fortiori, L > (C),[,. An analogous problem is that there may be variables 
appearing in (C) that do not appear any longer in M or M'. In this case, the 
resulting system is not steady. 
• At each iterationr the set CCP of the contextual critical pairs of R is com- 
puted, as well as the subset CCPoK of the ccp's that are feasible for Rtoc. It 
may happen that, at a certain iteration i, a given ccp is not R1o¢-unifiable, 
resulting in an infinite loop in the Rto¢-unification procedure, while it is RR- 
unifiable. Thus, checking too soon for the unifiability of clauses may be 
harmful. As proposed in Waldmann (1985), a solution to this problem is to 
perform the Rlo¢-unifiability test only up to a certain, always increasing, 
depth of narrowing. This is shown to preserve the completeness of the 
method. 
• To implement he procedure, several optimizations may be applied ; for 
instance, marking the roles would avoid recomputing useless critical pairs 
(cf. e.g. Huet, 1980). Fairness in the choice of the rules should be carefully 
considered too. 
* Another optimization, meaningful in the sole conditional ease, would be to 
use a refined notion of normalization : let (C) ~ <T,T'> be a CCP to "nor- 
malize", and a rule r : P ~ ~,---->p such that T ico=~,t~. If Pc~ is not satisfied 
by rewriting, one cannot a priori reduce T by the rule r. However, if Pa can 
be detected as being a "consequence" of (C), it becomes sound to normalize 
T. This is in general non-decidable; but we could restrict ourselves to 
detections of syntactic order, checking for instance whether Pa is a (possibly 
renamed and reordered) subset of the clauses of (C). This still needs to be 
further investigated ; the work of R6my & Zhang (1985) is probably relevant 
to that respect. 
We now present an example of the application of our completion procedure 
on a larger example (cf. also section 4). 
Example 3,5 : 
In this example, we specify the natural numbers with the usual < predicate 
(rules r<l to r<4), and lists with constructors ~ (the empty list) and [ _ ,  _ ] : 
natxlist-->list. We also define the membership redicate for lists (rules r e 1 to 
re4) and the function ins : natxlist--->list (rules rll to ri3) that inserts an ele- 
ment e in a list 1 before the first element of 1 that is greater than e (and at the 
end of 1 if every element of 1 is greater than e). For instance, 
Conditional Term Rewriting Systems 315 
ins(4, [3,[1,[5,~]]]) = [3,[4,[1,[5,O]]]] and ins(2, [1,[0,O]])= [1,[0,[2,O]]]. 
r<l : 0 < x --> T 
r<2: s x < 0---> F 
r<3 : sx<sy- ->x<y 
r<4 : x < x ---> T 
re l  : x~ O ---) F 
r~ 2 : x ~ [x,s] --~ T 
r~3:x_<y=F =~ x~ [y ,s ]~x~ s 
r~4:y<x=F ~ x~ [y,s]--->x~ s
ril : ins(x,O) ---) [x,~] 
ri2 : x < y = T => ins(x,[y,1]) --> [x,[y,1]] 
ri3 : x < y = F ~ ins(x,[y,1]) ~ [y,ins(x,1)] 
The critical pairs of the system are as follows : 
- between r<l and r<4, there is a critical pair <T,T> that need not be taken 
into account. 
- Between r<3 and r<4, there is a critical pair <x.~x,T> that normalizes into 
<T,T>. 
- There is, between r~ 2 and r e 3, the contextual critical pair <T,x~ s> in the 
critical context (x_~x=F), which rewrites in (T=F). Hence, the corresponding 
critical context is not feasible, and the corresponding critical pair is dis- 
carded. 
- The contextual critical pair between re2 and re4 is discarded the same way. 
- There is a contextual critical pair <[x,[y,1]],[y,ins(x,1)]> in the critical con- 
text (x<y=T)/k(x<y=F) between ri2 and q3, which is discarded. 
Thus, the previous ystem is complete. [] 
Now, suppose that the rule 
r~5:x~ s - -T  ~ x~ [y,s]-->T 
is added to the previous system. The completion procedure applied to the 
new system will run as follows : 
- ra2 and r~5 generate the contextual critical pair: (x~s=T)::~ <T,T>, 
which is discarded. 
- r~ 3 and r e 5 generate the contextual critical pair : (xa s=T)/k (x<y=F) 
<x~s,T>, which normalizes into (x~s=T) /k (x<y=F)~ <T,T> via the 
optimized normalization procedure. 
- Similarly, r~4 and rE5 generate no relevant critical pair. 
Thus, this new system is complete. We shall see, in section 4, that this actu- 
ally proves that rE5, interpreted as an equation, is an inductive theorem of 
the specification under consideration. [] 
The ideas exposed so far in this paper have been partially implemented under 
the REVE system (cf. Waldmann, 1985) and section 6 for a brief analysis of 
this experiment). 
316 S. Kaplan 
4. Proof in Steady Simplifying Conditional Theories 
In this section, we address the question of proving inductive properties in 
theories specified by steady simplifying TRS's. By definition, a conditional 
equality Prem =~ M = M' is an inductive theorem of the current theory if 
and only if : 
x/c : X --~Tz, if ~RPremc~, then Mc -- R M '~.  
Inductive properties are usually proved in two different ways : 
• explicitly using induction techniques, as in Boyer & Moore (1979), 
Bidoit (1981), Bidoit & Choquer (1985) ; 
• via so-called inductionless induction techniques, which involve 
Knuth-Bendix algorithms, in theories that are specified in appropriate 
ways (cf. references hereafter). 
In this section, we rely on the second approach. It has been carefully investi- 
gated in the case of classical rewrite rules (cf. e.g. Goguen, 1980; Musser, 
1980; Huet & HuUot, 1980; Fribourg, 1984), or of rewriting modulo equa- 
tions (cf. Jouannaud & Ki.rchner, 1984). Those investigations led to the 
design of automated systems for theorem proving (cf. Huet & Hullot, 1980; 
Lescanne, 1983). 
However, such methods have been more rarely considered in the conditional 
case (R6my, 1982; R6my & Zhang, 1985). We are going to show that the 
proof techniques of the non-conditional case may be naturaUy extended to 
our framework of steady simplifying systems. From now on, we suppose 
that the current heory is defined by a steady simplifying conditional TRS R 
on the signature ~, such that : 
(i) ~ may be partioned in Const~Der , where operators in Constr 
are called constructors and operators in Der are called derived opera- 
tors. 
(ii) For any t,t' ~ Tconstr , then t -- R t' iff t = t'. 
(iii) For any f~ Der of arity n, for any terms tl,...,t n of TConstr, there 
exists a t'~Tconstr such that : f(t I .... ,tn) --~I~ t' . 
Such specifications are called structured specifications. These conditions are 
commonly assmned in the classical framework. We need to consider how 
they may be realized in the conditional case. 
- Condition (i) is a matter of methodological choice. When writing a 
specification, the user knows what the constructors of its theory are (i.e. 
which operators generate the concrete values on which he intends to work), 
and what the derived operators are (i.e. which operator perform computations 
on the previous concrete values). 
- Condition (ii) is sometimes formulated by saying that R has no equations 
between constructors. It is generally guaranteed by forbidding, in R, rules of 
the form Prem =:3, M --~ M', where symbols occurring at the root of M and 
M' are both in Constr. 
Conditional Term Rewriting Systems 317 
- Condition (iii) is more subtle to obtain. It states that functions correspond- 
ing to the derived operators are well-defined with respect to constructors. 
One also says that their definition is sufficiently complete (w.r.t. Constr). 
This question is mainly of methodological concern. Again, it has been largely 
investigated in the classical framework, but far more rarely in the case of 
conditional definitions. 
In order to ensure condition (iii), we suppose from now on that R = 
ufe DerDeff, where Deff is a system of rules defining the derived operator f of 
the form : 
Deff = { Premi.j ~ f(~i) ~ "~i }ie[1..n],je[1..m] 
and such that : 
(a) R is steady and simplifying ;
(b) Vie [1,.n], 'q(r:X---)T z, there exists a unique j~[1..m] such that 
~RPremi,j(L 
(c) (Oi)i~[1..n] is a Constr-derivation. 
By definition, a Constr-derivation is a finite family (f2 i) of terms of 
Tconstr(X) such that, for any t~Tconstr(X), there exists a unique i and a 
unique substitution c such that t-f~i(Y. 
The previous conditions extend to the conditional case the criteria given in 
particular in Bidoit (1981) for the classical case. This methodology is 
analyzed systematically in another paper Gaudel & Kaplan (1986) ; in partic- 
ular, we develop there sufficient conditions of syntactic order that ensure 
condition (b). The intuitive meaning for conditions (a)(b)(c) is that Deff 
induce a definition of f acting by both syntactic (via the (f~i)i~[x..,1) and 
semantic (via the Prernio,j for every i o) case-analysis on its arguments. So, 
for any vector'~ of ~guments of Tconst r, there is exactly one substitution cr 
and one i o such that ~=f~i0~, because of conditions (i_i) and (c). Then, by (b), 
there is exactly one J0 such that ~RPremi0,Jo. Then f(t-~Xiojo~, and the nor- 
realization may proceed. The two following examples illustrate these 
notions. 
Example 4.1 
318 S. Kaplan 
The following system : 
f(0,0) ----> xl, 1 
g(1)(y) = T => f(0,y) --> "~2,1 
g(1)(y) = F A g(2)(y) = T :=> f(0,y) ---> 272, 
g(1)(y) = F ?x g(2)(y) = F ~ f(0,y) ----> x2,3 
g(3)(x) = F ~ f(s(x),0) --> x3,1 
g(3)(x) = F ~ f(s(x),0) ~ "~3,2 
g(4)(X) = T =~ f(s(x), s(0)) ---> '~,~,1 
g(a)(x) = F '-> f(s(x), s(0)) ~ ~4,2 
g(5)(x,y) = T /~ g(6)(x,y) = T =~. f(s(x),s(s(y))) --~ zs, 1 
g(5)(x,y) T /k  g(6)(x,y) F =:~ f(s(x),s(s(y))) ---> xs, 2 
g(5)(x,y) = F /k  g(6)(x,y) = T =~. f(s(x),s(s(y))) ---> Xs, 3 
g(5)(x,y) F /~ g(6)(x,y) F =~ f(s(x),s(s(y))) "~ "~5,4 
forms a sufficiently complete definition of the operator f, provided the g(i)'s 
have themselves sufficiently complete definitions. The xi j 's are terms of 
Tz(X) satisfy the sirnplifying-ness constraints. The Constr-derivation used  in 
Deff is 
{f21=(0,0), ~2=(0,s(y)) ,  f23=(s(x),0) , ~~4" - - ( s (x ) , s (0 ) )  , f25=(s(x),s(s(y))) }.
We return now to the question of the proofs in theories specified in such  a 
structured way. As in Huet & Hullot (1980), the completion procedure of 
section 3 is modifi.ed into an inductive completion procedure, in the fo l low-  
ing way : the statement 
CCPoK := CCPoK + [C =~, <t,t'>] 
becomes:  
p 
if t = c(t t, • • • ,t n) and t' = c(t' b • ' - ,t n) with ce Constr 
then CCPoK := CCPoK + [C =~ <ti,t'i>]l_g_i~n 
elseif t = C(tl, ",t n) and t' = c ' ( t ' l , ' ' ' , tn '  ) with c ,c 'eConstr  and 
C~C'~ 
then STOP-with-DISPROOF 
elself t = c(tt, ' '  .,t~) with ce Constr and t' is a variable (or symmetr i -  
cally in t and t') 
then STOP-with-DISPROOF 
else CCPoI < := CCPoK + [(C) ~ <t,t'>] 
Conditional Term Rewriting Systems 319 
Theorem 4.2 
Let Prem ~ M = M' be a property to be verified (with for instance 
M > M' for the current simplification ordering >). We suppose that the 
inductive completion procedure is applied to : R u { Prem ~ M --~ 
M' }, and eventually stops. Then, 
if the procedure stops with "STOP-WITH-SUCCESS", then 
Prem =~ M=M' is an inductive theorem of the theory ;
if the procedure stops with "DISPROOF", Prem ~ M=M' is not 
an inductive theorem of the theory. 
Note that when the procedure stops with "STOP-WTFH-FAILURE", not 
much can be said about the veracity of the property to prove; this 
corresponds to a failure of the method itself. 
The proof of theorem 4.2 is similar to the classical case (cf. e.g. Huet & Hul- 
lot, 1980). Actually, it should be emphasized that this principle is rather 
independent of the underlying formalism (classical rewriting, rewriting 
modulo equations, different notions of conditional rewriting), provided it has 
a correct Knuth-Bendix completion procedure. Lastly, if Prem =~ M=M' is 
not an inductive theorem of the theory, the procedure may loop forever (con- 
trary to the classical case, where the corresponding procedure would either 
STOP-WITH-FAILURE or stop with DISPROOF). However, such an infinite 
loop might occur only within a Riot-unification test. 
We are going to show how the whole method applies to examples. 
Example 4.3 (example 3.5 revisited) 
The specification of example 3.5, without r~5, is a structured specification, in 
the sense of this section. Hence, the script of the whole completion pro- 
cedure constitutes a proof that re5 is indeed an inductive theorem of the 
theory. 
Example 4.4 
Consider the following (non-conditional) specification : 
rl : x+0- - *x  
r2 :x+s(y )~s(x+y)  
r3 : even(0) --, T 
r4: even(s(0)) ~ F 
r5 : even(s(s(x)) ~ even(x) 
The Constr-derivation {I21=(x,0),f~2=(x,s(y))} is used to define the derived 
operator '+', while {f~l=0,~z=s(0),f~a=s(s(x))} is used to define the derived 
operator 'even'. We wish to prove the conditional theorem 
even(x)=Tfieven(y)=T ~even(x+y)=T. o this effect, the rule : 
r6 : even(x) = T ~ even(y) = T =~ even(x+y) --~ T 
is added to the system, and the inductive completion procedure is run. 
- rl-r6 generate the CCP : even(x)=T ~ <even(x),T> that need not be 
320 S. Kaplan 
added. 
- r2-r6 generate the CCP : even(x)=T]~even(s(y))=T =~ <even(s(x+y)),T>, the  
context of which is easily found to be satisfiable. The new rule : 
r'6 : even(x) = T ]k even(s(y)) = T ~ even(s(x+y)) ---> T 
is added to the system. 
- r l -r '6 generate the CCP : even(x)=T/kF=T =~ <F,T> that is discarded. 
- r2-r'6 generate the CCP : even(x)=T /k even(s(s(y))=T :=~ 
<even(s(s(x+y))),T>. It is normalized into even(x)=T /~ even(y)=T =:~ 
<even(x+y),T>, which is trivial, because of r6. The inductive completion 
procedure stops without having generated equations between constructors, 
and the theorem is thus proven. [] 
We now define queues, generated by the constructors '~ '  and 'ins', together 
with a predicate 'P' testing whether all the elements of a queue are even, and  
an operator '®' adding two queues elementwise : 
rpl : P(O) ---> T 
rp2 : even(x)=T]kP(q)=T ~ P(ins(x,q)) ---> T 
rp3 : even(x)=T/kP(q)=F ~ P(ins(x,q)) .---> F 
rp4 : even(x)=F/~q~(q)=T ~ P(ins(x,q)) ~ F 
rp5 : even(x)=F]kP(q)=F ~ P(ins(x,q)) ---> F 
r~ l :  O® q--> q 
r~2:  q® O ---~ q 
r~3 : ins(x,q) ® ins(x',q') ---> ins(x+x',q®q') 
Again, the resulting system is steady, simplifying and confluent. An interest- 
ing property to check is : 
R1 : P(ins[s(s(x)),q]) ---> P(ins(x,q). 
rp2-R1 generate the CCP : even(s(s(x))=T/kP(q)=T ~ <P(ins(x,q),T>. It  
normalizes into even(x)=T/'W(q)=T~<P(ins(x,q),T>, which is trivial 
because of rp2. 
- Similarly, the CCP from rp3-R1, rp4-R1 and rp5-R1 are trivial, and R1 is 
proven. [] 
Let us now prove a more difficult property, namely :
R2 : P(q)=T]XP(q')=T =~ P(q®q')---~T. 
The inductive completion procedure works as follows : 
- R2 generates trivial CCP with r® 1 and r~ 2. 
- R2-r@3 generates the rule : 
R3 : P(ins(x,q)) = T/k P(ins(x',q')) = T ~ P(ins(x+x',q®q') ---> T. 
- The following rules are generated ( iscarding non-trivial CCP) : 
R ' I  : P(ins(x,gD))=T/kP(ins(x',q'))=T ~ P(ins(x+x',q')) ~ T (from r~l -R2)  
R'2 : P(ins(x,q))=T/X,P(ins(x',~))=T ~ P(ins(x+x',q)) ---> T (from r®2-R2) 
R'3 : P(ins(x,~))=TAP(ins(s(x'),q'))=T ~ P(ins(s(x+x'),q')) ----> T (from r2- 
R ' I )  
R '4 : P(ins(x,q))=T]kP(ins(s(x'),~))=T ~ P(ins(s(x+x'),q)) ---> T (from r2- 
Conditional Term Rewriting Systems 321 
R'2) 
R'5 : P(ins(x,q))=T/~P(ins(s(x'),q'))-'T ~ P(ins(s(x+x'),q®q')) ~ T (from 
r2-R2) 
Note that R'3, R'4, R'5 create no new rules with r2, using the "lemma" R1. 
Also, the superpositions of R1 with the (R'i)i e [1..5] yield trivial CCP. 
- Now, the CCP between the (rpj)je[z.51 and the (R'i)ia[1..51 have to be exam- 
ined. Actually, only rp3,rp4,rp5 may lead to non-trivial contextual critical 
pairs, that are of the form C ~ <T,F>. This leads to show (by narrowing) 
that the corresponding 15 contexts are non-satisfiable. We illustrate this on a 
typical (actually, the most complicated) configuration, amely rp4-R'5. 
The corresponding CCP is : 
even(s(x+x'))=FAP(q®q')=TAP(ins(x,q))=TAP(ins(s(x'),q))=T =:~ <T,F>. 
Let us consider the possible narrowings of "P(ins(x,q))=T". The only win- 
ning one is by rp2, and the whole context becomes : 
even(s(x+x'))=FAP(q®q')=Theven(x)=TAP(q)=T]kP(ins(s(x'),q'))=T. 
Now, the only winning narrowing of "P(ins(s(x'),q')=T" is by rp2, and the 
new context is : 
even(s(x+x'))=F/keven(x)=TNeven(s(x'))=TAP(q)=TlXP(q')=TN~(q® q')=T. 
By normalization, using r'6 and R2, we obtain :
T=F/Xeven(x)=T/keven(s(x'))=TAP(q)=TAP(q')=% 
which is not satisfiable. 
Then, the system is complete and the property R2 is proven. [] 
5. General Conditional Term Rewriting Systems 
It has been shown in section 1 that when the hypothesis that R is steady and 
simplifying is abandoned, the associated rewriting relation and the normal 
form function are not decidable any longer. The purpose of this section is 
then twofold. We firstly establish that most of the theoretical results of sec- 
tion 2, 3 and 4 may be extended to generalized system ; in particular, we 
give a general Knuth-Bendix theorem for conditional TRS. Then, it is shown 
informally that even though the latter esults give rise to semi-decisions pro- 
cedures, they may still be useful for achieving proofs in general conditional 
theories. 
For general systems, the evaluation of the premises allows to assign values to 
some variables that have not been already "bound" by the matching substitu- 
tion. For instance, with the rule f(x,y,z)=~ g(x,y)---~h(z) of section 1, it is 
necessary to solve the equation f(t,t',z)=~ in order to reduce the term g(t,t'). 
This will bind z to a certain value (several different values may be possible) 
and the evaluation will proceed. Again, this search can be performed by the 
unification procedure described in section 2. The modified evaluation pro- 
cedure then becomes : 
322 S. Kaplan 
Procedure NFR(t) ; 
choose a rule r : ~n_lu i = v i ==~ ~ --'> P of  R 
such that t I co = ~,G and 
( "r := UnifR(ulo~...~unts, VlO~...~VnC0 ) # failure 
then return( NFR(t [ co <-- (c'c)(9) ] ) 
when-no-other-choice return(t) 
end-procedure 
The unification procedure that is used here is the one defined in section 2 ; 
indeed, it need not be modified to cope with general systems. Also, one 
remarks that ax may still leave some variables of P unbound. In this case, a 
ground term may rewrite into a term with variables. 
Lastly, non-noethedan systems will often lead to non-terminating pro- 
cedures; however, the theoretical semi-completeness of our results still 
holds. 
Example 5.1 
Consider the following specification of the predicate '<' ('strictly smaller 
than') on the natural numbers : 
0< s 0 ---> T 
sx<sy- ->x<y 
x<y=T/ky<z=T ~ x<z-- -~T 
The system is neither steady nor simplifying 'due to the third rule. This 
specification is not sufficiently complete, in the sense of  section 4 :  for 
instance, 0<0 is a normal form: Nevertheless, if n and m are two natural 
number such that n<m, then s(n)(0)<s(m)(0)--R T (shown by induction on n 
and m). Now, the evaluation procedure, applied to the term t = 0<s(s(0)), 
runs as follows : 
the only rule that matches t is the third one, with ~={xe--0,z~---s(s(0))}. 
Then, the unification procedure is applied to solve the equation 
0<y=Thy<s(s(0))=T. 
- A possible narrowing of this clause is via the first rule ; its left-hand 
side and 0<y are unifiable with rn.g.u. ~={y~--s(0)}. The clause is 
now 0<s(0)As(0)<s(s(0)), which becomes trivia2 after reduction by the 
second and the first rule. The resolution procedure retums, with x=~. 
- Thus, t rewrites into (c'~)(T)=T, which is a normal form. 
The validity of the two previous procedure is stated in the following result : 
Theorem 5.2 
The normal form procedure and the unification procedure are semi- 
decision procedures. Their different executions compute respectively all 
the normal forms and all the unifiers of their respective arguments ; 
some executions may not terminate. 
The proofs are similar to those of section 1 and 2. In effect, most of the 
Conditional Term Rewriting Systems 323 
time, there exist non-terminating executions, even for the normal form pro- 
cedure (as opposed to the case of steady simplifying systems). In the previ- 
ous example, narrowing the clause by the last rule leads to solve y<s(s(0))=T 
in the conditional context 0<y2=TAy2<y=T. Solving y2<Y=T via the third rule 
clearly leads to infinite loops. 
The results of section 3 about confluence also apply. Consider a rule of the 
form Prem(x,y) ~ f(x)--rh(y). A given term f(t) may be reduced in h(u) and 
h(v), for two terms u and v such that ~RPrem(u),Prem(v). Thus, a rule may 
now generate a critical pair with itself at its root occurrence. In general, let r 
: Prem~,~) ~ ~(-xx~---)pC-~,3?) be a role of R, with ~ standing for the variables 
of ~, and ~ standing for the variables of p and of the premises that do not 
appear in %. Let ~' be a vector of variables of the same length as ~, that do 
not appear in Y or ~. Then Premff,2C)APrem(~,~') =~ <p(-~,-y]),p~,-~)> is a 
contextual critical pair of R. Let the contextual critical pairs of R stand for 
the ones of this kind, and the ones defined in section 3. We then have : 
Theorem 5.3 [Knuth-Bendix theorem for general conditional TRS] 
The conclusions of theorem 3.3 still hold under the extended notion of 
critical pair. In particular, "-)R being noetherian, it is confluent if and 
only if 
for every feasible CCP (C) =~ <t,t'>, 
for any c~:X--)Tz(X ) such that h~(C)cL then 
tSR=t'~ R 
where t,l,R,t',l, R stand for any normal form of t,t' for " - -~R"  
Theorem 5.3 is proven in Appendix A' 
Similarly, the proof method introduced in section 4 may be naturally adapted 
to general systems. We still have to be under the conditions (i),(ii),(iii) of 
section 4 (ensuring that the conditional specification is well-structured). The 
unification procedure should then be optimized in the following fashion (@ 
and 81 being considered as constructors) : 
- trying to unify two terms of the form c(...) and c'(...), where c and 
c' are two distinct constructors, immediately leads to STOP-with- 
failure ; 
- trying to unify two terms c ( t l , . . . , t  n) and c ( t ' l , . . . , t 'n ) ,  where c 
is a constructor different from ~ and ~, is replaced by unifying 
tl~...~t n with t't~...~t' n. 
Then the inductive completion procedure of section 4 works as before, except 
that : 
- a rule of the form : 
c(...) = c'(...)/~ Prem' ~ ~, --) p. 
(c and c' being distinct constructors) Is immediately discarded. 
Indeed, it is discarded by the unification procedure ; 
324 S. Kaplan 
- a rule of the form : 
C(tl,...,tn) = c'(t'x,...,t'n) Ix Prem' ~ ~ -.--> p 
(c being a constructor) is replaced by : 
tl=t'lfi~..fitn---'t'nfi~Prem' "~ L--->p. 
This transformation is then applied again, if possible, on the resulting 
rule, etc ... (cf. next example). 
Example 5.4 
The system of example 5.1 is enriched into : 
r l :  0<s0  ---~T 
r2:  sx<sy  ---> x < y 
r3 :x<y=TAy<z=T =:~ x<z  --->T 
r4:  x<O --->F 
r5:  x+O ----> x 
r6 : x + s(y) --~ s(x + y) 
Here, rl,r2,r3 are as in example 5.1. The rule r4 is added in order to provide 
a sufficiently complete definkion of the '<' predicate, r5,r6 form a 
sufficiently complete definition of the addition. As before, the system rl  to r6 
is complete. We now wish to prove the following theorem : 
y = s(z) + x ~ x<y = T. 
The theorem reads as fol lows: if there exists a strictly positive natural 
number z' (= s(z)) such that y=x+z', then x is strictly smaller than y. Note 
that both the rule r3 of the specification, and the theorem to be proven do not 
satisfy the steadiness hypothesis on the variables. The oriented version of the 
theorem is 
r7 :y=s(z )+x  ~ x<y-oT .  
The inductive completion procedure, applied to the system r l  to r7, runs as 
follows : 
- rl and r7 generate the trivial CCP : 0 = s(s0 + z) ~ <T,T>, that need not 
be added. In any case, the unification procedure would immediately detect 
the context '0 = s(s0 + z)' as non-feasible. 
- r2 and r7 generate the normalized CCP : s(y)=s(s(z) + x )=~ <x<y,T>, 
which is transformed into : y = s(z) + x ~ x<y --4 T. This is exactly r7 ; 
- r3 and r7 generate a trivial CCP ; 
- r$ and r7 generate the CCP : 0=s(z) =~ <T,F>, the context of  which 
'0<s(z)' is immediately recognized as non-feasible. 
The inductive completion procedure stops without having generated 'equa- 
tions between cons~actors', and the theorem is proven. 
This example illustrates the fact that methods of section 4 do apply in order 
to prove non-steady (or non-simplifying) properties in non-steady non- 
simplifying theories. However, such a method should not be considered as 
fully automatizable : human intuition may be often needed in order to avoid 
infinite loops during the proofs (though parallel exploration, combined with 
Conditional Term Rewriting Systems 325 
breadth-first rategy, will often "automatically" lead to correct proof scripts). 
6. Pragmatics of our Approach and 
Comparison with Other Works 
It seems useful to recall here the advantages of conditional rules w.r.t, non- 
conditional ones. From a purely mathematical point of view, they share the 
same expressive power : both kinds of rules specify, and are sufficient o 
specify, semi-decidable algebras (cf. Bergstra et aL, 1981; Bergstra & 
Tucker, 1986). However, it is often more comfortable and natural to use 
conditional rules when complex systems axe to be specified. Such conditional 
specifications allow for systematical development of large specifications (cf. 
Gaudel & Kaplan, 1986). It should be noted, to this respect, that several of 
the examples appearing in this paper have been designed under the CATY 
module of the ASSPEGIQUE environment for the development of algebraic 
specifications (cf. Bidoit & Choppy, 1985). Under CATY, a user may syn- 
thesize in an assisted, semi-automatic way, algebraic specifications and 
implement hem in different ways (conditional term rewriting systems, 
ADA ® programs, etc). Our opinion is that, principally in such a framework 
of algebraic specifications, conditional term rewriting systems how their util- 
ity, and should be studied. 
On other hand, we do not feel that conditional term rewriting systems are 
appropriate tools to investigate structures commonly used in mathematics, as
it is the case for classical systems via the solution of uniform word problems. 
This does not mean that we consider that algebraic specifications are not 
mathematical. Our point is that conditional specifications and TRS are better 
suited to describe queues, buffers, arrays, etc.., that groups, rings, fields, etc... 
Indeed, it does not seem that usual mathematical structures are better 
described by conditional systems than by classical ones (the first theory one 
might think of is elementary field theory, which not positive conditional, and 
thus falls out of the scope of our systems). Again, the privileged omain of 
application of conditional TRS is for us the description of data structures 
dealt with in computer science. 
In order to compare the approach of this article with previous works, we 
roughly have the following taxonomy : 
- as stated in the introduction, a first group of authors Bergstra & Klop 
(1982), Kaplan (1984) has considered general conditional rewrite rules, and 
investigated the undecidability hat it involves. Most of their results, mainly 
dealing with intractability issues, are recalled in section 1. Section 5 of the 
present paper proposes a global way of considering fully general rules, and 
relevant results. 
- A second group has been considering restricted kinds of rules. 
326 S. Kaplan 
• Brandt et al. (1978) and Lankford (1979) performed the first 
researches in the field. They showed in particular that different 
evaluation mechanisms were possible, and considered the concept of 
hierarchical evaluation. 
• Pletat et al. (1981), Bergstra & Klop (1982) and Drosten (1983) 
have investigated rules satisfying syntactical conditions uch as left- 
linearity, non-overlapping-ness, etc. This led to results 'extending 
those of O'Donnel (1977), concerned in particular with the confluence 
property, and the correctness of evaluation strategies. These authors 
often use the concepts of boolean specifications in which the premises 
consist of a single term of boolean type, and of hierarchical 
specification where premises are evaluated in a lower layer of 
specification interpreted by non-conditional rewriting. Pletat (1983) 
considers pecifications with any finite number of layers, the lowest 
one being interpreted by non-conditional rewriting. This may be simu- 
lated in our approach : if SPECi+I is a specification built over SPECi, 
we would use a simplification ordering such that the operators 
declared in SPECi+ 1 are greater than those of SPEC i. Apart from the 
technicality of the conditions on the specifications, the main drawback 
of this approach is its reduced expressiveness. For instance, recursion 
between premises and conclusions of the rules is forbidden, which is 
allowed in our approach. 
• Rrmy (1982), Rrmy & Zhang (1985) in a hierarchical and boolean 
framework, also consider questions related with confluence and 
Knuth-Bendix procedures. Their notion of contextual rewriting and 
normalization seems promising. For instance, the term ins(x,[y,1]) or 
our example 3.5 would have two contextual normal forms : the nor- 
mal form [x,[y,1]] in the context {x<y = T}, and the normal form 
[y,ins(x,1)] in the context {x<y = F}. Relating to the present work, we 
noticed in section 3 that an optimized form of normalization may be 
useful inside the completion procedure ; this question might be con- 
sidered in the perspective of these authors. 
The formalism presented here has the following characteristics : 
- checking if a given conditional TRS is steady and simplifying is of syntac- 
tical order. The conditions to be satisfied o not restrict much the expressive 
power of the theory, as long as one is not interested in resolution-like 
mechanisms as found in logic programming ; 
we obtain powerful results, naturally extending the ones about non- 
conditional rewriting. We treat the question of the evaluation process (which 
most authors do), the question of confluence (considered only in Rrmy 
(1982), Rrmy & Zhang (1985), in a more restricted framework), and the 
problem of unification in conditional theories. 
Conditional Term Rewriting Systems 327 
The results exposed in sections 1 to 3 have been implemented under the 
REVE system (Waldmann, 1985), under the slightly more general form of 
steady 'reducing' systems. First experiments show that the completion pro- 
cedure, when applied to steady simplifying/reducing systems tend to generate 
systems that are no longer steady nor simplifying/reducing. This justifies a 
posteriori our considering eneralized systems (section 5 of this paper). 
7. Conclusion 
Conditional term rewriting systems arise naturally in the development of 
algebraic specifications. In this article, we have shown that steady simplify- 
hag conditional term rewriting systems constitute an interesting subclass of 
general conditional systems, for which we have extended several results of 
the purely classical case. In this approach, the recursivity introduced by the 
evaluation of the premises is not harmful, as it is controlled by the use of 
simplification orderings. The main results that we obtain wkhin this formal- 
ism consist of the total correction of an evaluation procedure for such sys- 
tems, a meta-unification algorithm for conditional theories, criteria for 
confluence leading to a Knuth-Bendix completion procedure, and an induc- 
tive completion procedure for automated theorem proving. Our approach 
appears as more general than the ones described so far in the field (allowing 
for a larger class of roles), and also gives rise to more general results. The 
extensions of our results to a larger framework still allow for theorem prov- 
ing methods. 
Some further esearch is still needed about several optimizations of the pro- 
cedures described in this paper. This is necessary in order to implement, in a 
satisfying way, a specification environment and a proof system that support 
our formalism. Practical experiments in Waldmann (1985) already show that 
the extensions described in section 5 are often useful and should be sup- 
ported by such an environment. 
I thank M.-C. Gaudel, N. Dershowitz, L. Fribourg, J.-L. R~my and J.-P. 
Jouannaud for very fruitful and stimulating discussions. I am also grateful to 
H. Zhang, and M. Choquer for careful comments. 
I thank anonymous and vigilant referees for their attentive readings and con- 
structive suggestions, and Pr. B. Buchberger for his very helpful observa- 
tions. 
This work has been partially supported by the Gr6co de Programmation 
(CN'RS), the INRIA, the AdI contract N°639 and the ESPRIT project 
328 S. Kaplan 
METEOR.  Part of it was done while the author was visiting the Weizmarm 
Institute (Rehovot - ISRAEL).  
References 
AD~ - Goguen,J.A.,Thatcher, LW., Wagner,E.G.(1978). An initial algebra approach to the 
specification, correctness and implementation f abstract data types. Current Trends in 
Programming Methodology, Prentice-Hall N.-J. 
B ergstra, J.,Broy,M.,Wirsing,M.,Tucker,J.V.(1981). On the power of algebraic 
specifications. Proc. of the MFCS Conference, LNCS 118, Berlin. 
Bergstra, L Klop,W.(1982). Conditional rewrite rules : confluence and termination. Report 
IW 198/82, Mathemadsch Centrum, Amsterdam. 
Bergstra,J.,Tucker,J.V.(1986). Algebraic specifications of computable and semi-computable 
data types. Report CS-R8619, CWI, Amsterdam. 
Bidoit,C.,Choppy,C.(1985). Asspegique : an integrated environment for algebraic 
specification. Proc. of the CSE-TAPSOFT'85 Conference, LNCS 186, Berlin, 
Bidoit,M.(1981). Une methode de presentation de types abstraits : applications, Th~se de 
3 eme cycle, Orsay - France. 
Bidoit,M.,Choquer, M.(1985). Preuve par induction dans les theories conditionnelles. Proc. 
of the AFCET Conference on Artificial Intelligence, Grenoble. 
Boyer, R.,Moore,J.S.(1979). A computational logic. Academic Press. 
Brandt,D.,Darfinger,J.A.,loyner,W.H.(1978). Completeness of conditional reductions. 
Report IBM Research Center, Yorktown Heights. 
Dershowitz,N.(1979). Orderings for term rewriting systems. Proc of the 20 th Symposium 
on Foundation of Computer Science, 223-131. 
Dershowitz,N.(1985). Termination. Proc. of the 1 st Conf. on Rewriting Techniques and 
Applications, LNCS 202, Dijon - France. 
Dershowitz,N.,Plaisted,D.A.(1986). Equational Programming. In : Machine Intelligence, 
MichieJ-layes,Richards Eds. 
Detlefs,D.,Forgaard,R.(1985). A procedure for automatically proving the termination of a 
set of rewrite rules. Proc. of the I st Conf. on Rewriting Techniques and Applications, 
LNCS 202, Dijon - France. 
Drosten,K.(1983). Toward executable specifications using conditional axioms. Report 83- 
01, T.U. Braunschweig . W.-Germany. 
Fay,M.(1979). First-order unification in an equational theory. Proc. of the 4 th Workshop on 
Automated Deduction, Austin - Texas. 
Fribourg,L.(1984a). Oriented equational clauses as a programming language. Proc. of the 
11 th ICALP Conference, Antwerpen - The Netherlands. 
Fribourg,L.(1984b). A narrowing procedure for theories with constructors, Proc. of the 7 th 
Computer Automated Deduction, Napa. 
Futatsugi,K.,Goguen,J.,Jouannaud,L-P.,Messeguer,/.(1985). Principles of OBJ2. Proc. of 
the 12 th POPL Conference, New-Orleans. 
Gaudel,M.-C.,Kaplan,S.(1986) How to build meaningfuU algebraic specification. ESPRIT 
Meteor Project Technical report, Orsay - France. 
Conditional Term Rewriting Systems 329 
Geser,A.,Hussmann,H.(1986). Unification in conditional-equational theories. Proc. of the 
ESOP 86 Conference. To appear in LNCS. 
Goguen,L(/980). How to prove algebraic inductive hypotheses without induction, Proc. of 
the 5 th Conference on Automated Deduction, Les Arcs - France. 
Huet,G.(1977). Confluent reductions : abstract properties and applications to term rewriting 
systems, Proc. of the 18 th FOCS Symposium. 
Huet,G.,Hullot,J.-M.(1980). Proofs by induction in equational theories with constructors, 
Proc. of the 21 st FOCS Conference. 
Huet, G.,Oppen,D.C.(l.980). Equations and rewrite rules : a survey, In : Formal languages : 
Perspective and open problems, R. Book Ed., Academic Press. 
HuUot,J.-M.(1980). Canonical forms and unification, Proc. of the 5 th Conference on 
Automated Deduction, LNCS 87, Les Arcs - France. 
Hussmann,H.(1985). Unification in conditional equational theories, Proc. of the EUROCAL 
Conference, LNCS 204, 
Josephson, A.,Dershowitz,N.(1986). Efficient implementations of narrowing : the RITE 
way. Internal Report, University of Illinois. 
Jouannaud,J.-P.,Kirchner,C.(1984). Completion of a set of rules modulo a set of equations, 
Proc. of the 11 th POPL Conference. 
Kaplan,S.(1984a). Conditional rewrite rules, Tt~eoretical Computer Science 33, pp.175-193. 
K_nuth,D.E.,Bendix,P.B.(1970). Simple word problems in universal algebra,Computational 
problems in abstract algebra, J.Leech Ed., Pergammon Press. 
Lankford,D.S.(1979). Some new approaches to the theory and applications of conditional 
rewriting systems. 
Lescanne,P.(1983). Computer experiment with the REVE term rewriting systems generator, 
Proc. of the 10 th POPL Conference. 
Musser,D.L.(1980). On proving inductive properties of Abstract Data Types, Proc. of the 
7 th POPL Conference, Las Vegas. 
O'Donnel,M.J.(1977). Computing in systems described by equations, LNCS 58. 
Paul,E.(1985). On solving the equality problem in theories defined by Horn clauses, Proc. 
of the EUROCAL Conference, LNCS 204. 
Pletat,U.,Engels,G.,Ehrich,H.-D.(1981). Operational semantics of algebraic specifications 
with conditional equations, Proc. of the 7 th CAAP Conference, Lille - France. 
R~my,L-L.(1982). Etudes des syst~mes de r~dcriture conditionnels et applications aux 
types abstralts algdbriques, Thhse d'Etat, CRIN.Nancy - France. 
Rdmy,J.-L.,Zhang,H.(1985). Contextual Rewriting, Proc. of the 1 st Conf. on Rewriting 
Techniques and Applications, LNCS 202, Dijon - France. 
Rdty,P.,Kirchner, C. Kirchner,H.,Lescanne,P.(1985). Narrower, a new algorithm for 
unification and its application to logic programming, Proc. of the 1 st Conf. on Rewrit- 
ing Techniques and Applications, LNCS 202, Dijon - France. 
Rusinowitch,M.(1985). Path of subterm ordering and decomposition rderings revisited, 
Proc. of the i st Conf. on Rewriting Techniques and Applications, LNCS 202, Dijon - 
France. 
Waldmann,B.(1985). Les syst~mes de r~6criture conditionnels r~duisants, Crin Internal 
Report, Nancy - France. 
330 S. Kaplan 
Appendix A 
Proof of the implication (1) =~ (i) [Theorem 3.3] 
Knuth-Bendix theorem for steady simplifying conditional TRS 
The hypothesis is that R is a steady simplifying system such that : 
for every feasible CCP (C) ~ <t,t'>, 
for every o:X----~T~: such ~R(C)cL then tcr~, R = t'o,~ R 
We wish to show that "~R is confluent on Try(X). It is enough to prove 
that --'~R is locally confluent. Ad absurdum, suppose that there exists a 
term t such that : 
• t---~Rt 1 and t----~Rt 2 
* there exists no t' such that tl--->~t' and t2-->~t'. 
Such a term will be called a lethal critical term. By noetherian induction 
on >, there must exist a lethal critical term t such that if t>t', then t' is 
not a lethal critical term. We shall prove that, actually, t cannot be a 
lethal critical term, hence deriving a contradiction. There exist two 
rules: r i : C i ~ Li----)pi (iE {1,2}), such that, for instance tl0 h = ~,i(~1 
and rico2 = Lz(r 2 with ~RCI(Sl/XC2c2. We can suppose that 
Var(rl)c~Var(r2)=O. There are three cases to consider (as in the proof 
of Huet, 1977, for the non-conditional case) : 
1- 031 and 032 are independent 
occurrences of t. 
This means that neither is on the way 
from the root to the other one. It is then 
straightforward that : 
tl -">r2 t['o31~'-'Pl(Y1,oh~'-'P2(~2 ] 
t2 t [O31(--- p 1 (Yl,Oh(-'- p2(~ 2] 
Thus h t2, which contradicts the 
hypothesis. 
From now on, we suppose that, for instance, 031 is in t, between o3 2 and the 
root. 
2- Suppose that o h is the occurrence of a 
node of ~,1 corresponding to a symbol of 
Z. Then, ~'llco and 2. 2 are unifiable by 
Clt-)~ 2 (with 02=03i.03). Let /x be their 
m.g.u. There exists a "r such that 
~iu~2=W~. Then Ci~tACz~t 
<pl~t, ~,1/ . t [~92~]>,  is a contextual 
critical pair. Since ~RCIW~AC2W~, then 
Conditional Term Rewriting Systems 331 
plgx ,l, L1~tz[o3e--p2g'c], and thus t 1 $ t 2. 
ilia, ., 
Proof  that ~R C1°"1 • 
3- Else, co occurs in t at the occurrence 
of a variable x of )h. Then, 
t,m, -')R t21c0, = Xleq[°+-P2O2] -'->R 
%1t~t[x¢--P202] by successive applica- 
tions of r 2. Let 0" 1 = tJltJ{x~pz(r2}. 
The previous relations is reformulated in 
t2lo~, "-~t~ )'10'1 ' We are going to show 
that ~RCI~'I. Then, it will be possible to 
apply r z to %10'1, yielding 
t21o~ ' ~ plo"l = t' . But on the other 
hand, it is clear that tzlco ~ ~R t'. This 
will show that h lo~,,l, t21~, which implies 
that t 1 ,1, t 2 and is contradictory. 
* I f  C I "- O,  then this is obvious. 
* Else, C 1 =/~nlui=v i. We need to show that i, uio" 1 ,1, vio" 1. Suppose that 
this is wrong for a given i o. We have : ~(uioo"t ,1, d vio 1), but: ui0oz ,1, vioa 1. 
Thus, there exist (txi)ie [1..nl and (~i)ie [1..m] such that : 
u~ ~ c~1 ~R ... ~R 
Vio "'~R ~1 -")R "'" --'~R ~m 
Consider now the following diagram (DIAG) : 
Uio o" I 
/ ' . . ,  
LIiOCT I Ul ,,,,_/\ 
a2 \ 
VL ~1 /o..., 
/ 
Ba 
% • 
% • 
-,., . p 
a~ n / 
]5 and ~',,, _,~ 
gn+2=/~n+2 
332 S, Kaplan 
There exists a term Uz 2 such as (DIAG), since otherwise uioc 1 would be a 
lethal critical term smaller for > than t ; 
so, there exists a term ~3 such as (DIAG), since otherwise tx 1 would be a 
lethal critical term smaller for > than t ; 
• • ° 
so, there exists a term ~n+l such as (DIAG), since otherwise txn_ 1 would be a 
lethal critical term smaller for > than t. 
Similarly, there exists a term [3 2 such as (DIAG), since otherwise vioo 1 would 
be a lethal critical term smaller for > than t ; 
so, there exists a term ~3 such as (DIAG), since otherwise [31 would be a 
lethal critical term smaller for > than t ; 
• . , 
so, there exists a term ~m+l such as (DIAG), since otherwise 13m_l would be 
a lethal critical term smaller for > than t. 
So, there exist terms U~,n+2=~m+2 such as (DIAG), since otherwise txa=~m 
would be lethal critical terms smaller for > than t ;  thus, there exist 
~+2=13"m+2 such as (DIAG), which implies that Ui0~'l'~RViot~'l, which contrad- 
icts the previous hypothesis. [] 
Appendix A' 
Proof of the implication (0) ~ (i) [Theorem 5.3] 
The proof is similar to the previous one; however, the >-induction principle 
cannot be used any longer. We need some kind of 0-induction (cf. section 1). 
Let us define Oaux(a,b), for a couple (a,b) such that a-~Rb , as being the 
minimal number of calls to the evaluation procedure, including the recursive 
calls for the premises, along all possible executions reducing a to b. 
The well-definedness of Oaux is guaranteed by the fact that there is at least an 
execution of the non-deterministic evaluation procedure leading from a to b 
(cf. section 1). 
Now, consider the triple (t,tl,t 2) in Appendix A. Let us define : 
~*(t,tl,t2) = Oau~(t,tl) + baux(t,t2) 
We will show, by induction on n = O'(t,tl,t2) (that is called the 3*-index of 
the triple), that for every such triple, then tl,~Rt 2
If n = 0, then tl=t 2 and there is nothing to prove. 
Else, the three cases of Appendix A need to be considered. 
- The two first cases are solved as before• 
- For the third case, as before, the proof consists in proving that 
~RCI~'I. The argument about the diagram (DIAG) becomes :
There exists a ~2 such as (DIAG), since otherwise uio~ 1 would be a lethal 
critical term ; the associated triple (uio~l,uioc'l,Ctl) would have a 3*-index 
Conditional Term Rewriting Systems 333 
strictly smaller than n, which contradicts the induction hypothesis ; 
so, there exists a ~3 such as (DIAG), since otherwise 131 would be a lethal 
critical term ; the associated triple (ct1,13"-2,132) would have a O*-index strictly 
smaller than n, which contradicts the induction hypothesis ; 
, . • 
so, there exists a ~n+l such as (DIAG), since otherwise t~n_ I would be a 
lethal critical term ; the associated triple (I]m-l,~m,gm) would have a O*-index 
strictly smaller than n, which contradicts the induction hypothesis. 
Similarly, there exists a 132 such as (DIAG), since otherwise vioc 1 would be a 
; ' 2*- lethal critical term the associated triple (viocl,~l,viog 1) would have a 
index strictly smaller than n, which contradicts the induction hypothesis ; 
so, there exists a g3 such as (DIAG), since otherwise 131 would be a lethal 
critical term ; the associated triple ([~1,~2,g2) would have a 3*-index strictly 
smaller than n, which contradicts the induction hypothesis, 
• • • 
so, there exists a I]m+l such as (DIAG), since otherwise [3m_ 1 would be a 
lethal critical term ; the associated triple (~m-l,~m,~m) would have a 3*-index 
strictly smaller than n, which contradicts the induction hypothesis. 
So, there exists a gn+2=gm+2 such as (DIAG), since otherwise ~,=13 mwould 
be a lethal critical term ; the associated triple (t~n=13m,~n+ 1, ~m+l) would have 
a ~*-index strictly smaller than n, which contradicts the induction hypothesis. 
This establishes the property for n, and thus achieves the proof• [] 
Appendix B 
Completion procedure KBCPo) 
The procedure KBCPo) is identical to procedure KBCP(o) given in section 3., 
except for the statement : 
fo r [C  ~ <t,t '>]~ CCPdo{ 
if C is Rl°C-unifiable then CCPoK := CCPoK + [C ~ <t,t'> ] } 
that must be substituted by the following : 
for [C =~ <t,t'>] ~ CCP do { 
U = UnifR,~(C ) ; 
if U ~ 0 then 
fo rc r~ U do ,1 
if tg.l.R, ~ ~ t C.[.R... 
then CCPoK := CCP-OK + <t~.l,R,.,, t'g,l,R, > } } 
Thus, only feasible critical pairs instantiated by matching substitutions are 
retained in KBCPo). On the contrary, in KBCP(o), a (non-instantiated) critical 
pair is retained as soon as it is feasible. 
334 S. Kaplan 
Note that, since Coy,I, is satisfied by hypothesis, CCPoK is simply augmented 
of 
"<tCrJ, Rio, , t'CrSR,.> , and not of "[ Cc$ ~ <tCSR,o, , t'(~,~Rto > ]". 
We also remark that in order to use K.BCP(1), the Riot-unification procedure 
must return after a finite amount of time. This implies in particular that the 
set of unifiers is finite (which justifies the innermost "for-loop" hereabove). 
This hypothesis is not very realistic; this is why we focused interest on 
K-BCP(0) in section 3 : in the latter, the existence of only one unifier for C 
was required, in order to add [ C$ ~ <t,  t'> ]. 
Finally, note that informally speaking, whenever the procedure KBCP(1) ter- 
minates, it has the same power, with respect o our framework of steady sim- 
plifying systems, as the usual Knuth-Bendix completion procedure in the 
classical case. 
