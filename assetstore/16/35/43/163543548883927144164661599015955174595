Logical Methods in Computer Science Vol. 5 (3:1) 2009, pp. 1–29 www.lmcs-online.org

Submitted Dec. 8, 2008 Published Jul. 15, 2009

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION
DELIA KESNER
PPS (Universit´e Paris-Diderot and CNRS), France e-mail address: kesner@pps.jussieu.fr
Abstract. Many diﬀerent systems with explicit substitutions have been proposed to implement a large class of higher-order languages. Motivations and challenges that guided the development of such calculi in functional frameworks are surveyed in the ﬁrst part of this paper. Then, very simple technology in named variable-style notation is used to establish a theory of explicit substitutions for the lambda-calculus which enjoys a whole set of useful properties such as full composition, simulation of one-step beta-reduction, preservation of beta-strong normalisation, strong normalisation of typed terms and conﬂuence on metaterms. Normalisation of related calculi is also discussed.

1. Introduction

This paper is about explicit substitutions (ES), a formalism that - by decomposing the

implicit substitution operation into more atomic steps - allows a better understanding of

the execution models of higher-order languages.

Indeed, higher-order substitution is a meta-level operation used in higher-order lan-

guages (such as functional, logic, concurrent and object-oriented programming), while ES

is an object-level notion internalised and handled by symbols and reduction rules belonging

to their own worlds. However, the two formalisms are still very close, this can be eas-

ily seen for example in the case of the λ-calculus whose solely reduction rule is given by

(λx.t) v →β t{x/v}, where the operation t{x/v} denotes the result of substituting all the free occurrences of x in t by v, a notion that can be formally deﬁned modulo α-conversion1

as follows:

x{x/v}

:= v

y{x/v}

:= y

x=y

(u1u2){x/v} := u1{x/v}u2{x/v} (λy.u){x/v} := λy.u{x/v}

The simplest way to specify a λ-calculus with ES is to incorporate substitution operators

into the language, then to transform the equalities of the previous speciﬁcation into a set

1998 ACM Subject Classiﬁcation: F.3.2, D.1.1, F.4.1.

Key words and phrases: operational semantics, functional languages, lambda calculus. 1Deﬁnition of substitution modulo α-conversion avoids to explicitly deal with the variable capture case.

Thus, for example (λx.y){y/x} =α (λz.y){y/x} =def λz.y{y/x} = λz.x.

Ð LOGICAL METHODS IN COMPUTER SCIENCE

DOI:10.2168/LMCS-5 (3:1) 2009

c Delia Kesner CC Creative Commons

2 DELIA KESNER

of reduction rules (so that one still works modulo α-conversion). The following reduction system, known as λx [Lin86, Lin92, Ros92, BR95], is thus obtained.

(λx.t) v → t[x/v]

x[x/v]

→v

y[x/v]

→y

x=y

(u1u2)[x/v] → u1[x/v]u2[x/v]

(λy.u)[x/v] → λy.u[x/v]

The λx-calculus corresponds to the minimal behaviour2 that can be found among the cal-

culi with ES appearing in the literature (equivalent minimal behaviours can be found, for example, in [Cur91, BBLRD96, KR98]). However, when using this simple operational semantics, outermost substitutions must be always delayed until the total execution of all the

innermost substitutions appearing in the same environment. Thus for example, the prop-

agation of the outermost substitution [x/v] in the term (zyx)[y/xx][x/v] must be delayed

until [y/xx] is ﬁrst executed on zyx.

This restriction can be recovered by the use of more sophisticated interactions, known

as composition of substitutions, which allow in particular the propagation of substitu-

tions through other substitutions. Thus for example, (zyx)[y/xx][x/v] can be reduced

to (zyx)[x/v][y/(xx)[x/v]], which can be further reduced to (zyv)[y/vv], a term equal to (zyx)[y/xx]{x/v}, where {x/v} is the meta/implicit substitution that the explicit substi-

tution [x/v] is supposed to implement.

In these twenty last years there has been a growing interest in λ-calculi with ES. They

can be deﬁned either with unary [Ros92, LRD94] or n-ary [ACCL91, HL89] substitutions,

by using de Bruijn notation [dB72, dB78], or levels [LRD95], or nominal logic [GP99], or combinators [GL99], or director strings [SFM03], or ... simply by named variables as in the λx-calculus. Besides diﬀerent notations, a calculus with ES can be also seen as a

term notation for a logical system where the reduction rules behave like cut elimination

transformations [Her94, DU01, KL08].

Composition rules for ES ﬁrst appeared in λσ [ACCL91]. They turn out to be nec-

essary to get conﬂuence on open terms [HL89] in calculi implementing higher-order uniﬁ-

cation [DHK00] or functional abstract machines [LM99, HMP96]. They also guarantee a

simple property, called full composition, that calculi without composition do not enjoy: any term of the form t[x/u] can be reduced to t{x/u}; in other words, explicit substitution imple-

ments the implicit one. Indeed, taking again the previous example, (zyx)[y/xx][x/v] reduces to (zyx)[y/xx]{x/v} = (zyv)[y/vv]. Many calculi such as λσ, λσ⇑ [HL89], λsub [Mil06], λlxr [KL05, KL07] and λes [Kes07] enjoy full composition.
In any case, all these calculi were introduced as a bridge between formal higher-order

calculi and their concrete implementations. However, implementing an atomic substitution operation by several elementary explicit steps comes at a price. Indeed, while λ-calculus is perfectly orthogonal (in particular does not have critical pairs), calculi with ES such as λx

suﬀer at least from the following well-known diverging example:

t[y/v][x/u[y/v]] ∗← ((λx.t) u)[y/v] →∗ t[x/u][y/v]

Diﬀerent solutions were adopted in the literature to close this diagram. If no new rewriting rule is added to those of the minimal λx-calculus, then reduction turns out to be conﬂuent on terms but not on metaterms (terms with metavariables used to represent

2Some presentations replace the rule y[x/u] → y by the more general one t[x/u] → t if x ∈/ fv(t).

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

3

incomplete programs and proofs). If liberal rules for composition are considered, as in λσ, λσ⇑, or λse [KR97], then one recovers conﬂuence on metaterms but loses preservation of β-strong normalisation (PSN) as not all the β-strongly normalising terms remain normalising in the corresponding ES version. This phenomenon, known as Melli`es’ counterexample [Mel95] (see also [BG99] for later counterexamples in named calculi), shows a ﬂaw in the design of ES calculi since they are supposed to implement their underlying calculus (in our case the λ-calculus) without losing its good properties.
There are many ways to avoid Melli`es’ counter-example in order to recover the PSN property. One can forbid the substitution operators to cross λ-abstractions or avoid composition of substitutions. One can also impose a simple strategy on the calculus with ES to mimic exactly the calculus without ES. The ﬁrst solution leads to weak lambda calculi [LM99, For02], not able to express strong beta-equality (used for example in implementations of proof-assistants). The second solution [BBLRD96] is drastic when composition of substitutions is needed for implementations of HO uniﬁcation [DHK00] or functional abstract machines [LM99, HMP96]. The last one does not take advantage of the notion of ES because they can be neither composed nor even delayed.
Fortunately, conﬂuence on metaterms and preservation of β-strong normalisation can live together, this is for example the case of λws [DG99, DG01] and λlxr, which both introduce a controlled notion of composition for substitutions. Syntax of λws is based on terms with explicit weakening constructors. Its operational semantics reveals [DCKP00] a natural understanding of ES in terms of Linear Logic’s proof-nets [Gir87], which are a geometrical representation of linear logic sequent proofs that incorporate a clear mechanism to control weakening and contraction. Weakening, viewed as erasure, and contraction, viewed as duplication, are precisely the starting points of the λlxr-calculus whose syntax is obtained by incorporating these new operators to the λ-terms. The reduction system of λlxr contains 6 equations and 19 rewriting rules, thus requiring a big number of cases when developing some combinatorial reasoning. This is notably discouraging when one needs to check properties by cases on the reduction step; a reason why conﬂuence on metaterms for λlxr is just conjectured but not still proved. Also, whereas λlxr gives the evidence that explicit weakening and contraction are suﬃcient to verify all the properties expected from a calculus with ES, there is no justiﬁed reason to think that they are also necessary.
We choose here to use simple syntax in named variable notation style to deﬁne a formalism with full and safe composition that we call λex-calculus. Thus, we dissociate the operational semantics of the calculus from all the renaming details that are necessary to specify higher-order substitution on terms that are implemented by non-trivial technologies such as de Bruijn indices or nominal notation. Even if our choice implies the use of α-equivalence, we think that this presentation is more appropriate to focus on the fundamental (operational) properties of full and safe composition. It is now perfectly well-understood in the literature how to translate terms with named variables into other notations, so that we expect these translations to be able to preserve all the properties of the λex-calculus.
The λex-calculus is obtained by extending λx with one rewriting rule to specify composition of dependent substitutions and one equation to specify commutation of independent substitutions. This will turn out to be essential to obtain a safe notion of full composition which does not need anymore the complex manipulation of explicit operators for contraction and weakening used in λlxr to guarantee PSN. The substitutions of λex are deﬁned by means of unary constructors but have the same expressive power as n-ary substitutions. Indeed, while simultaneous substitutions are speciﬁed by lists (given by n-ary substitutions)

4 DELIA KESNER
in λσ, they are modelled by sets (given by commutation of independent unary substitutions) in λex.
We thus achieve the deﬁnition of a concise language being easy to understand, and enjoying a useful set of properties: conﬂuence on metaterms (and thus on terms), simulation of one-step β-reduction, full composition, preservation of β-strong normalisation and strong normalisation of typed terms (SN).
Most of the available SN proofs for calculi with composition are not really ﬁrst-hand: either one simulates reduction by means of another well-founded relation, or SN is deduced from a suﬃcient property, as for example PSN. Proofs using the ﬁrst technique are for example those for λws in [DCKP03] and λlxr [KL07], based on the well-foundedness of the reduction relation for multiplicative exponential linear logic (MELL) proof-nets [Gir87]. An example of SN proof using the second technique is that for λes, where PSN is obtained by two consecutive translations, one from λes into a calculus with ES and weakening, the second one from this intermediate calculus into the Church-Klop’s ΛI -calculus [Klo80]. In both cases the resulting proofs are long, particularly because they make use of normalisation properties of other (related) calculi.
It is then desirable to provide more direct arguments to prove normalisation properties of full and safe composition, thus avoiding unnecessary detours through other complex theories. And this becomes even necessary when one realises that normalisation of a calculus which allows duplication of void substitutions, such as λex, cannot be understood in terms of calculi like MELL proof-nets where such behaviour is impossible.
The technical tools used in the paper to show PSN for λex are the following. We ﬁrst deﬁne a perpetual reduction strategy for λex: if t can be reduced to t′ by the strategy, and t′ ∈ SN λex, then t ∈ SN λex. In particular, since the perpetual strategy reduces t[x/u] to t{x/u}, one has to show that normalisation of Implicit substitution implies normalisation of Explicit substitution. More precisely,
(IE) u ∈ SN λex & t{x/u} ∈ SN λex imply t[x/u] ∈ SN λex.
In other words, explicit substitution implements implicit substitution but nothing more than that, otherwise one may get calculi such as λσ where t[x/u] does much more than t{x/u}. A consequence of the IE property is that standard techniques to show SN based on meta-substitution can also be applied to calculi with ES, thus simplifying the reasoning considerably. Indeed, the perpetual strategy is used to give an inductive characterisation of the set SN λex by means of just four inference rules. This inductive characterisation is then used to show that untyped terms preserve β-strong normalisation and that typed terms are in SN λex. At the end of the paper we also show how SN of other calculi with or without full composition can be obtained from SN of λex.
All our proofs are developed using simple logical tools: intuitionistic reasoning, induction, reasoning by cases on decidable predicates. All this gives a constructive (no use of classical logic) ﬂavour to the whole development.
The proof technique used to show the IE property is mostly inspired from the PSN proofs used for the non equational systems λx and λws in [LLD+04] and [ABR00]. Current investigations carried out in [SvO07] show PSN for diﬀerent calculi with (full or not) composition. The approach is based on the analysis of minimal non-terminating reduction sequences. The calculus proposed in [Sak] speciﬁes commutation of independent substitutions by a non-terminating rewriting system (instead of an equation), thus leading to complicated notions and proofs.

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

5

This paper extends some ideas summarised in [Kes07, Kes08], particularly by the use of intersection types to characterise the set SN λex as well as the use of the Z-property of van Oostrom [vO] to show conﬂuence. It is organised as follows. Section 2 introduces syntax and reduction rules for the λex-calculus. The perpetual strategy for λex is introduced in Section 3 together with its corresponding Perpetuality Theorem. This fundamental theorem is proved thanks to a key property whose proof is left to Sections 4 and 5. The equivalence between intersection typed and β-strongly normalising terms is given in Section 6. In Section 7 we explain how to infer SN for other calculi with ES. In Section 8 we prove conﬂuence for metaterms. Finally we conclude and give directions for further work in Section 9.

2. Syntax

The λex-calculus can be viewed as a simple extension of the λx-calculus. The set of terms (meta-variables s, t, u, v) is deﬁned by the following grammar.
T ::= x | T T | λx.T | T [x/T ]

Free and bound variables of t, written respectively fv(t) and bv(t), are deﬁned by

induction as follows:

fv(x)

:= {x}

bv(x)

:= ∅

fv(λx.u) := fv(u) \ {x}

bv(λx.u) := bv(u) ∪ {x}

fv(uv)

:= fv(u) ∪ fv(v)

bv(uv)

:= bv(u) ∪ bv(v)

fv(u[x/v]) := (fv(u) \ {x}) ∪ fv(v)

bv(u[x/v]) := bv(u) ∪ {x} ∪ bv(v)

Thus, λx.t and t[x/u] bind the free occurrences of x in t.
The congruence generated by renaming of bound variables is called α-conversion. Thus for example (λy.x)[x/y] =α (λz.x′)[x′/y]. Given a term of the form t[x/u][y/v], the two outermost substitutions are said to be independent iﬀ y ∈/ fv(u), and dependent iﬀ y ∈ fv(u).
Notice that in both cases we can always assume x ∈/ fv(v) by α-conversion. We use the
notation tn for a list of n (n ≥ 0) terms t1, . . . , tn and utn for ut1 . . . tn, which is in turn an abbreviation of (. . . ((ut1)t2) . . . tn).
Meta-substitution on terms is deﬁned modulo α-conversion in such a way that capture
of variables is avoided. It is given by the following equations.

x{x/v}

:= v

y{x/v}

:= y if y = x

(λy.t){x/v} := λy.t{x/v}

(tu){x/v} := t{x/v}u{x/v}

t[y/u]{x/v} := t{x/v}[y/u{x/v}]

Thus for example (λy.x){x/y} = λz.y. Notice that t{x/u} = t if x ∈/ fv(t).

Besides α-conversion, we consider the equations and rewriting rules in Figure 1. Notice that α-conversion allows to assume that there is no capture of variables in the previous equations and rules. Thus for example we can assume y = x and y ∈/ fv(v) in the rewriting rule Lamb. Same kind of assumptions are done for the rewriting rule Comp and the equation C. The rewriting relation →Bx is generated by all the rewriting rules in Figure 1 and →x is only generated by the ﬁve last ones. The equivalence relation =e is generated by the conversions α and C. The reduction relations →ex and →λex are respectively generated by

6 DELIA KESNER

Equations : t[x/u][y/v] =C

t[y/v][x/u]

if y ∈/ fv(u) & x ∈/ fv(v)

Rules : (λx.t) u x[x/u] t[x/u] (tu)[x/v] (λy.t)[x/v] t[x/u][y/v]

→B →Var →Gc →App →Lamb →Comp

t[x/u] u t t[x/v] u[x/v] λy.t[x/v] t[y/v][x/u[y/v]]

if x ∈/ fv(t) if y ∈ fv(u)

Figure 1: The λex-calculus

the rewriting relations →x and →Bx modulo =e (thus specifying rewriting on e-equivalence classes):
t →ex t′ iﬀ ∃ s, s′ s.t. t =e s →x s′ =e t′ t →λex t′ iﬀ ∃ s, s′ s.t. t =e s →Bx s′ =e t′
Given any reduction relation R, a term t is said to be in R-normal form, written t ∈ N FR, if there is no u such that t →R u. As an example, an inductive deﬁnition of N F λex can be given by: t1, . . . , tn ∈ N F λex imply xt1 . . . tn ∈ N F λex, and t ∈ N F λex implies λx.t ∈ N Fλex.
Again for any reduction relation R, a term t is said to be R-strongly normalising, written t ∈ SN R, if there is no inﬁnite R-reduction sequence starting at t, in which case the notation ηR(t) means the maximal length of a R-reduction sequence starting at t. An inductive deﬁnition of SN R is usually given by:
t ∈ SN R iﬀ ∀s (t →R s implies s ∈ SN R)

The notation →∗R (resp. →+R) closure of →R. Thus in particular,

is if

used for t →∗λex t′

the reﬂexive (resp. reﬂexive and transitive) in 0 reduction steps, then t =e t′.

The following basic properties can be shown by a straightforward induction on the

reduction relation.

Lemma 2.1 (Basic Properties). Let R ∈ {ex, λex} and let t, t′, u be terms. • If t →R t′, then fv(t′) ⊆ fv(t). • If t →R t′, then u{x/t} →∗R u{x/t′} and t{x/u} →R t′{x/u}. Thus in particular
t{x/u} ∈ SN R implies t ∈ SN R.

As explained in Section 1 the composition rule Comp and the equation C guarantee the following property:

Lemma 2.2 (Full Composition for Terms). Let t, u be terms. Then t[x/u] →+ex t{x/u}.

Proof. By induction on t. Consider t = s[y/v]. If x ∈ fv(v), then s[y/v][x/u] →Comp s[x/u][y/v[x/u]] →+ex (i.h.) s{x/u}[y/v{x/u}] = t{x/u}. If x ∈/ fv(v), then s[y/v][x/u] =C s[x/u][y/v] →+ex (i.h.) s{x/u}[y/v] = t{x/u}. All the other cases are straightforward.

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

7

Simulation of one-step β-reduction is then a direct consequence of full composition. Lemma 2.3 (Simulating One-Step β-Reduction). Let t, t′ be λ-terms. If t →β t′, then t →∗λex t′.

3. Perpetuality and Preservation of Normalisation
A perpetual strategy gives an inﬁnite reduction sequence for a term, if one exists, otherwise, it gives a ﬁnite reduction sequence leading to some normal form. Perpetual strategies, introduced in [BBKV76], can be seen as antonyms of normalising strategies, they are particularly used to obtain normalisation results. We refer the reader to [vRSSX99] for more details.
Perpetual strategies can be speciﬁed by one or many steps. In contrast to one-step strategies for ES given for example in [Bon01a], we now deﬁne a many-step strategy giving a reduct for any t ∈/ N Fλex. This is done according to the following cases. If t = xt1 . . . tn, rewrite the left-most ti which is reducible. If t = λx.u, rewrite u. If t = (λx.s)uvn, rewrite the head redex. If t = s[x/u]vn and u ∈/ SN λex, rewrite u. If t = s[x/u]vn and u ∈ SN λex, apply full composition to the head redex s[x/u] by using as many steps as necessary. Formally,
Deﬁnition 3.1 (A Strategy for Terms). The strategy on terms is given by an inductive deﬁnition.

un ∈ N F λex t t′

t

xuntvm xunt′vm (p-var) λx.t

t′ λx.t′ (p-abs) (λx.t)uun

(p-B) t[x/u]un

u ∈ SN λex (p-subs1)
t[x/u]vn t{x/u}vn

u ∈/ SN λex u u′ t[x/u]vn t[x/u′]vn (p-subs2)

The strategy is deterministic so that t u and t v imply u = v. Moreover, the strategy is not necessarily leftmost-outermost or left-to-right because of the (p-subs1) rule: substitution propagation can be performed in any order. Notice that the syntactical details concerning the manipulation of substitutions are completely hidden in the deﬁnition of the strategy which is only based on the full composition property. This makes the results of this section to be abstract and modular. A basic property of the strategy is:

Lemma 3.2. Let t, t′ be terms. If t t′, then t →+λex t′.

Proof. By induction on the deﬁnition of the strategy using Lemma 2.2.

The strategy turns out to be perpetual, that is, terminating terms are stable by antireduction (also called expansion). The proof of this property is presented in a modular way, by leaving all the details concerning the particularities of the substitution calculus to one single statement, called the IE property (Lemma 5.9) and fully developed in the next section.

Theorem 3.3 (Perpetuality Theorem). Let t, t′ be terms. If t t′ and t′ ∈ SN λex, then t ∈ SN λex.

Proof. By induction on the deﬁnition of the strategy .

8 DELIA KESNER

• t = (λx.s)uun s[x/u]un = t′ by (p-B). If s[x/u]un ∈ SN λex, then s, u, un ∈ SN λex. We show (λx.s)uun ∈ SN λex by induction on ηλex(s) + ηλex(u) + Σi∈1...n ηλex(ui). For that, it is suﬃcient to show that every λex-reduct of (λx.s)uun is in SN λex. If the reduction takes place in a subterm of (λx.s)uun, then the property holds by the i.h. Otherwise (λx.s)uun →B s[x/u]un which is in SN λex by hypothesis. We thus conclude (λx.s)uun ∈ SN λex.
• t = s[x/u]vn s[x/u′]vn = t′ by (p-subs2), so that u ∈/ SN λex and u u′. If s[x/u′]vn ∈ SN λex, then in particular u′ ∈ SN λex, thus u ∈ SN λex by the i.h. From u ∈/ SN ex and u ∈ SN λex we can get any proposition, so in particular t ∈ SN λex.
• t = s[x/u]vn s{x/u}vn = t′ by (p-subs1) so that u ∈ SN λex. Then the IE property (Lemma 5.9 in Section 4) allows to conclude.
All the other cases are straightforward.
An inductive syntactic characterisation of the set SN λex can be now given using the perpetual strategy. This kind of characterisation is usually useful when developing SN proofs. An inductive syntactic deﬁnition of SN terms for the λ-calculus is given for example in [vR96]. It was then extended in [LLD+04, Bon01b] for calculi with ES, but using many diﬀerent inference rules to characterise SN terms of the form t[x/u]. We just give here one inference rule for each possible syntactical form.
Deﬁnition 3.4 (Inductive Characterisation of SN λex). The inductive set ISN is deﬁned as follows:

t1, . . . , tn ∈ ISN

n≥0 (var)

xt1 . . . tn ∈ ISN

u{x/v}t1 . . . tn ∈ ISN v ∈ ISN u[x/v]t1 . . . tn ∈ ISN

u[x/v]t1 . . . tn ∈ ISN

n≥0 (app)

(λx.u)vt1 . . . tn ∈ ISN

n≥0 (subs)

u ∈ ISN (abs)
λx.u ∈ ISN

Proposition 3.5. SN λex = ISN .
Proof. If t ∈ SN λex, then t ∈ ISN is proved by induction on the lexicographic pair ηλex(t), t . If t ∈ ISN , then t ∈ SN λex is proved by induction on t ∈ ISN using Theorem 3.3.
The PSN property received a lot of attention in calculi with explicit substitutions, starting from an unexpected result given by Melli`es [Mel95] who has shown that there are βstrongly normalisable λ-terms that are not strongly normalisable in calculi with composition such as λσ [ACCL91]. Since then, many formalisms with and without composition have been shown to enjoy PSN. The proof technique used in this paper to show PSN is based on the Perpetuality Theorem and is mostly inspired from [ABR00, LLD+04, ABR00]. However, the use of two quite abstract concepts, namely, full composition and the IE property, makes our proof much more modular than the existing ones.
Theorem 3.6 (PSN for λ-terms). If t ∈ SN β, then t ∈ SN λex.
Proof. By induction on the deﬁnition of SN β [vR96] using the inductive Deﬁnition 3.4 and Proposition 3.5 (which holds by the Perpetuality Theorem 3.3).
If t = xt1 . . . tn with ti ∈ SN β, then ti ∈ SN λex by the i.h. so that the (var) rule allows to conclude. The case t = λx.u is similar. If t = (λx.u)vt1 . . . tn, with u{x/v}t1 . . . tn ∈ SN β

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

9

and v ∈ SN β, then both terms are in SN λex by the i.h. so that the (subs) rule gives u[x/v]t1 . . . tn ∈ SN λex and the (app) rule gives (λx.u)vt1 . . . tn ∈ SN λex.

Alternative Proof. By induction on the deﬁnition of SN β [vR96] using the IE property (Lemma 5.9 in Section 4).
If t = xt1 . . . tn with ti ∈ SN β, then ti ∈ SN λex by the i.h. so that t ∈ SN λex is straightforward. If t = λx.u with u ∈ SN β, then u ∈ SN λex by the i.h. and thus t ∈ SN λex is also straightforward. If t = (λx.u)vt1 . . . tn, with u{x/v}t1 . . . tn ∈ SN β and v ∈ SN β, then both terms are in SN λex by the i.h. The IE property gives t′ = u[x/v]t1 . . . tn ∈ SN λex so that in particular u, v, t1 . . . , tn ∈ SN λex. We show t = (λx.u)vt1 . . . tn ∈ SN λex by induction on µλex(u) + µλex(v) + Σi µλex(ti). For that, it is suﬃcient to show that every λex-reduct of t is in SN λex. Now, if the λex-reduct of t comes from an internal reduction, then conclude with the i.h. Otherwise, t →λex t′ which is already in SN λex.
4. The Labelling Technique
This section develops the key technical tools used to guarantee that the strategy (Deﬁnition 3.1) is perpetual. More precisely, we want show that normalisation of Implicit substitution implies normalisation of Explicit substitution:
(IE) u ∈ SN λex & t{x/u}vn ∈ SN λex imply t[x/u]vn ∈ SN λex
For that we adapt the labelling technique [DG01, ABR00, Bon01b] to the equational case. The technique can be summarised by the following steps:
(1) Use a labelling to mark some λex-strongly normalising terms used as substitutions. Thus for example t[[x/u]] indicates that u ∈ T & u ∈ SN λex.
(2) Enrich the original λex-reduction system with a relation ex used only to propagate terminating labelled substitutions. Let λex be the enriched calculus.
(3) Show that u ∈ SN λex & t{x/u}vn ∈ SN λex imply t[[x/u]]vn ∈ SN λex. (4) Show that t[[x/u]]vn ∈ SN λex implies t[x/u]vn ∈ SN λex.
We now develop the ﬁrst and second points, leaving the two last ones to Section 5.
Deﬁnition 4.1 (Labelled Terms). Given a ﬁnite set of variables S, the S-labelled terms (or simply labelled terms if S is clear from the context), are deﬁned by the following grammar:
LS ::= x | LSLS | λx.LS | LS[x/LS] | LS[[x/v]] (v ∈ T ∩ SN λex & fv(v) ⊆ S)
Thus, labelled substitutions can only contain terms so in particular they cannot contain other labelled substitutions. Notice that all the terms (as deﬁned in Section 2) are labelled terms, but some terms with arbitrary labels are not. Labelled terms need not be confused with the decent terms of [Blo97] which do not have labels at all and are not stable by reduction.
We can always assume that subterms λx.u, u[x/v] and u[[x/v]] inside t ∈ LS are s.t. x ∈/ S. Indeed, α-conversion allows to choose names outside S for the bound variables of labelled terms. As a consequence, no substitution (labelled or not) can be used to aﬀect the bodies of other labelled substitutions (whose free variables are all in S). That means also that given a term t having a subterm u[[x/v]], no free occurrence of y in v can be bound in the path leading to the root of t. In other words, the bodies of labelled

10 DELIA KESNER

Equations :

t[y/u][[x/v]] t[[y/u]][[x/v]]

=C t[[x/v]][y/u] =C t[[x/v]][[y/u]]

if x ∈/ fv(u) & y ∈/ fv(v) if x ∈/ fv(u) & y ∈/ fv(v)

Rules : x[[x/v]] t[[x/v]] (tu)[[x/v]]
(λy.t)[[x/v]] t[y/u][[x/v]]

→Var →Gc →App
→Lamb →Comp

v t t[[x/v]] u[[x/v]]
λy.t[[x/v]] t[[x/v]][y/u[[x/v]]]

if x ∈/ fv(t) if x ∈ fv(u)

Figure 2: The ex-calculus

substitutions are safe since they are already normalising and cannot loose normalisation after reduction/substitution.
The idea behind the operational semantics of labelled terms, speciﬁed by the equations and reduction rules in Figure 2, is that labelled substitutions may commute/traverse ordinary substitutions but these last ones cannot traverse the labelled ones.
The rewriting relation →x is generated by the rewriting rules in Figure 2 and the equivalence relation =e is generated by the conversions α and C. The reduction relation →ex is generated by the rewriting relation →x modulo =e. In particular, both relations →x and →ex enjoy termination (see Lemma 4.7). An even richer reduction relation λex can be deﬁned on labelled terms by adding to ex the old reduction relation λex but now on labelled terms. That is, →λex is deﬁned as the union of the rewriting relations →Bx and →x on labelled terms modulo α ∪ C ∪ C-equivalence classes:
t →λex t′ iﬀ ∃ s, s′ s.t. t =e∪e s →Bx∪x s′ =e∪e t′
In order to show that u ∈ SN λex & t{x/u}vn ∈ SN λex imply t[[x/u]]vn ∈ SN λex we ﬁrst need to relate the λex-reduction relation to that of the λex-calculus. For that, the reduction relation λex, which is deﬁned on labelled terms, is split in two relations λexi and λexe, on labelled terms as well, which will both be projected into λex-reduction sequences. More precisely, λexi can be weakly projected (eventually empty steps) into λex while λexe can be strongly projected (at least one step) into λexe (details in the forthcoming Lemma 5.2).
Deﬁnition 4.2 (Internal and External Reductions). The internal reduction relation →λexi on labelled terms is given by adding to ex the λex-reduction relation in the bodies of labelled substitutions. Formally, →λexi is taken as the following reduction relation →λxi on α ∪ C ∪ C-equivalence classes:
• If u →Bx u′ and u, u′ are terms, then t[[x/u]] →λxi t[[x/u′]]. • If t →x t′, then t →λxi t′. • If t →λxi t′, then tu →λxi t′u, ut →λxi ut′, λx.t →λxi λx.t′, t[x/u] →λxi t′[x/u],
u[x/t] →λxi u[x/t′], t[[x/u]] →λxi t′[[x/u]].
The external reduction relation →λexe on labelled terms is given by λex-reduction on labelled terms everywhere except inside bodies of labelled substitutions. Formally, →λexe is taken as the following reduction relation →λxe on α ∪ C ∪ C-equivalence classes: • If t →Bx t′ occurs outside a labelled substitution, then t →λxe t′.

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

11

• If t →λxe t′, then tu →λxe t′u, ut →λxe ut′, λx.t →λxe λx.t′, t[x/u] →λxe t′[x/u], u[x/t] →λxe u[x/t′] and t[[x/u]] →λxe t′[[x/u]].

Lemma 4.3. →λex=→λexe ∪ →λexi .
Proof. Since we are working everywhere with α∪C∪C-equivalence classes, then it is suﬃcient to show →Bx∪x=→λxi ∪ →λxe . ⊆: If t →Bx t′ occurs inside a labelled substitution, then t →λxi t′, otherwise t →λxe t′. If
t →x t′, then t →λxi t′. ⊇: By induction on the deﬁnitions of →λxe and →λxi.
Since λexi-reduction will only be weakly projected into λex, we need to guarantee that there are no inﬁnite λexi-reduction sequences starting at labelled term. This is exactly the goal of the ﬁnal part of this section. We will then use this result in Section 5 to relate termination of λex to that of λex (Corollary 5.4).

Deﬁnition 4.4 (A Decreasing Measure for Comp). For every variable x ∈/ S, the function
afx( ) counts the number of bodies of non-labelled substitutions having free occurrences of x. Formally, afx( ) is deﬁned on labelled terms as follows.

afx(z)

:= 0

afx(λy.t) := afx(t)

afx(t[[y/u]]) := afx(t)

afx(tu)

:= afx(t) + afx(u)

afx(t[y/u]) := afx(t)

if x ∈/ fv(u)

afx(t[y/u]) := afx(t) + 1 + afx(u) if x ∈ fv(u)

A second function dep( ) counts the total number of afx( ) in a labelled term t, and this for all variables x which are bound by some labelled substitution of t. Formally, dep( ) is

deﬁned on labelled terms as follows.

dep(x) := 0

dep(tu)

:= dep(t) + dep(u)

dep(λy.t) := dep(t)

dep(t[x/u]) := dep(t) + dep(u)

dep(t[[x/u]]) := dep(t) + afx(t)

For example, given v = w[w/(xx)[y/x]], we have afx(v) = 2 and dep(v[y/v][[x/x1]]) = 5. Notice that afx(t) = 0 if x ∈/ fv(t) and dep(t) = 0 if t does not have labelled substi-
tutions. Notice also that dep(t[[x/u]]) is well-deﬁned in terms of afx since we can always assume x ∈/ S by α-conversion.

Deﬁnition 4.5 (A Decreasing Measure for x \ Comp). We consider the following function K( ) on terms:

K(x) := 1 K(λx.t) := K(t) + 1

K(tu) := K(t) + K(u) + 1 K(t[x/u]) := K(t) · K(u)

In order to extend K( ) on terms to K( ) on labelled terms we deﬁne a special measure for λex-strongly normalising terms. Thus, given u ∈ SN λex, let us consider
φ(t) := 1 + ηλex(t) + maxKλex(t), where maxKλex(t) := max{K(t′) | t →∗λex t′}
Notice that φ is well-deﬁned since λex-strongly normalising terms have only a ﬁnite set of reducts. Notice also that φ(t) ≥ 2 for every term t. Moreover, t →λex t′ implies ηλex(t) > ηλex(t′) and maxKλex(t) ≥ maxKλex(t′) so that φ(t) > φ(t′).
We can now consider the following function K( ) on labelled terms.

K(x) := 1 K(λx.t) := K(t) + 1

K(tu)

:= K(t) + K(u) + 1

K(t[x/u]) := K(t) · K(u)

K(t[[x/u]]) := K(t) · φ(u)

12 DELIA KESNER

Lemma 4.6. Let t, u be S-labelled terms and let z ∈/ S. Then, (1) t =α,C,C u implies afz(t) = afz(u), dep(t) = dep(u) and K(t) = K(u). (2) t →Comp u implies afz(t) = afz(u) and dep(t) > dep(u). (3) t →x\Comp u implies afz(t) ≥ afz(u), dep(t) ≥ dep(u) and K(t) > K(u).
Proof. By induction on reduction. Notice that afz(t) > afz(u) holds for example for t = t1[x/u1] →Gc t1[x/u′1] = u, where u1 →Gc u′1, z ∈ fv(u1) and z ∈/ fv(u′1). Similarly, dep(t) = dep(u) holds for example for t →Var u, and dep(t) > dep(u) holds for example for t = t2[[z/u2]] →Gc t′2[[z/u2]] = u, where t2 →Gc t′2 and afz(t2) > afz(t′2).
Lemma 4.7. The reduction relation ex (and thus also x) is terminating.
Proof. Since t →ex u implies dep(t), K(t) >lex dep(u), K(u) by Lemma 4.6 and >lex is a well-founded relation, then ex terminates.
Lemma 4.8. The reduction relation λexi is terminating.
Proof. Lemma 4.6(1) guarantees that t =e∪e t′ implies dep(t), K(t) = dep(t′), K(t′) . We now show that t →λxi t′ implies afz(t) ≥ afz(t′) for z ∈/ S and dep(t), K(t) >lex dep(t′), K(t′) . We proceed by induction on →λxi. • If t = u[[x/v]] →λxi u[[x/v′]] = t′ comes from v →Bx v′, then afz(t) = afz(u) = afz(t′),
dep(t) = dep(u) + afx(u) = dep(t′) and K(t) = K(u) · φ(v) > K(u) · φ(v′) = K(t′). • If t →λxi t′ comes from t →x t′, then conclude using Lemma 4.6. • If t = u[[x/v]] →λxi u′[[x/v]] = t′ or t = u[x/v] →λxi u′[x/v] = t′ or t = v[x/u] →λxi
v[x/u′] = t′ or t = uv →λxi u′v = t′ or t = vu →λxi vu′ = t′ or t = λx.u →λxi λx.u′ = t′ comes from u →λxi u′, then the property trivially holds by the i.h.

5. The IE Property
This section is devoted to show the IE Property, this is done by using the labelled terms introduced in Section 4 as an intermediate formalism between t{x/u}vn and t[x/u]vn. More precisely, we split the IE Property in two diﬀerent steps:
• Show that u ∈ SN λex & t{x/u}vn ∈ SN λex imply t[[x/u]]vn ∈ SN λex. • Show that t[[x/u]]vn ∈ SN λex implies t[x/u]vn ∈ SN λex.
In order to relate reduction steps in λex to reduction steps in λex we use a function xc from labelled terms to terms which computes all the labelled substitutions as follows:

xc(x)

:= x

xc(tu)

:= xc(t)xc(u)

xc(λy.t) := λy.xc(t)

xc(t[x/u]) := xc(t)[x/xc(u)]

xc(t[[x/v]]) := xc(t){x/v}

Notice that xc(t) = t if t is a term.

Lemma 5.1. Let t, t′ be labelled terms. If t →ex t′, then xc(t) = xc(t′).

Proof. By induction on t →ex t′. The interesting case is t = s[x/u][[y/v]] =C s[[y/v]][x/u] = t′, with y ∈/ fv(u) & x ∈/ fv(v). The term xc(t) is equal to xc(s)[x/xc(u)]{y/v} = xc(s){y/v}[x/xc(u)] = xc(t′).

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

13

Lemma 5.2 (Projecting λex). Let t, t′ be labelled terms. Then, (1) t =α,C,C t′ implies xc(t) = xc(t′). (2) t →λxi t′ implies xc(t) →∗λex xc(t′). (3) t →λxe t′ implies xc(t) →+λex xc(t′).

Proof.

(1) By induction on the conversion relation.

(2) Internal reduction:

• If u[[x/v]] →λxi u[[x/v′]] comes from v →Bx v′, then xc(u[[x/v]]) = xc(u){x/v} →∗λex (L. 2.1) xc(u){x/v′} = xc(u[[x/v′]]).
• If t →λxi t′ comes from t →x t′ (so that also t →ex t′), then Lemma 5.1 gives xc(t) = xc(t′).

• If uv →λxi u′v where u →λxi u′, then xc(uv) = xc(u)xc(v) →∗λex (i.h.) xc(u′)xc(v) = xc(u′v).
• If u[[x/v]] →λxi u′[[x/v]] where u →λxi u′, then xc(u[[x/v]]) = xc(u){x/v} →∗λex (i.h. & L. 2.1) xc(u′){x/v} = xc(u′[[x/v]]).
• The other cases are similar since xc does not alter application, lambda and substitu-

tion.

(3) External reduction:

• If t →λxe t′ comes from a reduction t →Bx t′ which occurs outside a labelled substitu-

•

tion, If tu

then →λxe

xt′cu(,t)ut→→+λeλxxexcu(tt′,′)λcxa.nt

be shown by induction →λxe λx.t′, t[x/u] →λxe

on t →Bx t′ using Lemma 2.1. t′[x/u] or u[x/t] →λxe u[x/t′]

comes from t →λxe t′, then xc(t) →+λex xc(t′) by the i.h. and thus the property

holds by deﬁnition of xc and the fact that xc does not alter application, lambda and

substitution.

• If t[[x/u]] →λxe t′[[x/u]] comes from t →λxe t′, then xc(t[[x/u]]) = xc(t){x/u} →+λex (i.h. & L. 2.1) xc(t′){x/u} = xc(t′[[x/u]]).

Lemma 5.3. Let t be a labelled term. If xc(t) ∈ SN λex, then t ∈ SN λex.

Proof. We apply the Abstract Theorem A.2 in the Appendix A by taking A1 = λexi, A2 = λexe, A = λex and u R U iﬀ xc(u) = U . Lemma 5.2 guarantees properties P1 and P2 and Lemma 4.8 guarantees property P3. We then get that xc(t) ∈ SN λex implies t ∈ SN λexi∪λexe, which is exactly SN λex by Lemma 4.3. We thus conclude.

Corollary 5.4. Let t, u, vn be terms. If u ∈ SN λex & t{x/u}vn ∈ SN λex, then t[[x/u]]vn ∈ SN λex.

Proof. Take S = fv(u). The hypothesis u ∈ SN λex allows us to construct the S-labelled term t[[x/u]]vn. Moreover, xc(t) = t so that xc(t[[x/u]]vn) = t{x/u}vn and we thus conclude
by Lemma 5.3.

Labelled terms can be unlabelled in such a way that λex-reduction on unlabelled labelled terms can be simulated by λex-reduction.

Deﬁnition 5.5 (Unlabelling). Unlabelling of labelled terms is deﬁned by induction.

14 DELIA KESNER

U(x) := x

U(tu)

:= U(t)U(u)

U(λx.t) := λx.U(t)

U(t[x/u]) := U(t)[x/U(u)]

U(t[[x/u]]) := U(t)[x/u]

Notice that fv(t) = fv(U(t)).

Lemma 5.6. Let t ∈ LS s.t. U(t) →λex t′1. Then ∃ t1 ∈ LS s.t. t →λex t1 and U(t1) = t′1.
Proof. By induction on →λex and case analysis. The interesting cases are the following. • t = u[x/v][[y/w]] where y ∈ fv(v), and

U(u[x/v][[y/w]]) = U(u)[x/U(v)][y/w] →Comp U(u)[y/w][x/U(v)[y/w]] = t′1
We then let t1 = u[[y/w]][x/v[[y/w]]] so that U(t1) = t′1 and t →Comp t1. • t = u[x/v][[y/w]] where y ∈/ fv(v), and

U(u[x/v][[y/w]]) =

U(u)[x/U(v)][y/w] =C U(u)[y/w][x/U(v)] = t′1

We then let t1 = u[[y/w]][x/v] so that U(t1) = t′1 and t =C t1. • t = u[[y/w]][x/v]. By α-conversion we can always choose x ∈/ S, which is a ﬁxed set of

variables, so that we necessarily have x ∈/ fv(w) since fv(w) ⊆ S by construction. Now,

consider

U(u[[y/w]][x/v]) =

U(u)[y/w][x/U(v)] =C U(u)[x/U(v)][y/w] = t′1 We then let t1 = u[x/v][[y/w]] so that U(t1) = t′1 and t =C t1. • t = u[[x1/v1]][[x2/v2]]. Again, by α-conversion we can assume xi ∈/ S so that xi ∈/ fv(vj) since fv(vi) ⊆ S by construction. Now, consider

U(u[[x1/v1]][[x2/v2]]) = U(u)[x1/v1][x2/v2] =C U(u)[x2/v2][x1/v1] =
U(u[[x2/v2]][[x1/v1]]) = t′1 We then let t1 = u[[x2/v2]][[x1/v1]] so that U(t1) = t′1 and t =C t1. All the other cases are straightforward.
Lemma 5.7. Let t ∈ LS. If t ∈ SN λex, then U(t) ∈ SN λex.
Proof. We prove U(t) ∈ SN λex by induction on ηλex(t). This is done by considering all the λex-reducts of U(t) and using Lemma 5.6.
Taking S = fv(u) and transforming the term s[x/u]un into the S-labelled term s[[x/u]]un we have the following special case.
Corollary 5.8. If t[[x/u]]vn ∈ SN λex, then t[x/u]vn ∈ SN λex.
We can now conclude with the main property required in the proof of the Perpetuality Theorem:
Lemma 5.9 (IE Property). Let t, u, vn be terms. If u ∈ SN λex & t{x/u}vn ∈ SN λex, then t[x/u]vn ∈ SN λex.
Proof. By Corollaries 5.4 and 5.8.

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

15

6. Intersection Types
The simply typed calculus is a typed lambda calculus whose only type connective is the function type. This makes it canonical, simple, and decidable [Tai67]. The simply typed lambda calculus enjoys the β-strong normalisation property stating that every β-reduction sequence starting with a typed λ-term terminates.
However, some intersection type disciplines [CDC78, CDC80] are more expressive and ﬂexible than simple type systems in the sense that not only are typed λ-terms β-strongly normalising, but the converse also holds, thus giving a characterisation of the set of βstrongly normalising λ-terms.
Intersection types for calculi with explicit substitutions have been studied in [LLD+04, Kik07, KC]. Here, we apply this technique to the λex-calculus, and obtain a characterisation of the set of λex-strongly normalising terms by means of an intersection type system.
Types are built over a countable set of atomic symbols as follows:
A ::= σ (atomic) | A → A | A ∩ A
An environment is a ﬁnite set of pairs of the form x : A. Typing judgements have the form Γ ⊢ t : A where t is a term, A is a type and Γ is an environment. The intersection type system, called System ∩, is deﬁned by means of the set of typing rules in Figure 3.

Γ, x : A ⊢ x : A

Γ⊢t:A→B Γ⊢u:A (ax) Γ ⊢ tu : B (app)

Γ, x : A ⊢ t : B Γ ⊢ λx.t : A → B

(abs) Γ ⊢ u : B Γ, x : B ⊢ t : A (subs) Γ ⊢ t[x/u] : A

Γ ⊢ t : A Γ ⊢ t : B (∩ I) Γ⊢t:A∩B

Γ ⊢ t : A1 ∩ A2 Γ ⊢ t : Ai

(∩ E)

Figure 3: System ∩: an intersection type discipline for terms
A derivation of a typing judgement Γ ⊢ t : A, written Γ ⊢∩ t : A, is a tree obtained by successive applications of the typing rules of the system ∩. A term t is said to be ∩-typable, iﬀ there is an environment Γ and a type A s.t. Γ ⊢∩ t : A. Notice that every λ-term is ∩-typable iﬀ there is an environment Γ and a type A s.t. Γ ⊢∩ t : A holds in the system which only contains the typing rules {ax, abs, app, ∩ I, ∩ E} in Figure 3.
The well-known characterisation of the set of β-strongly normalising λ-terms reads now as follows:
Theorem 6.1 ([Pot80]). Let t be a λ-term. Then t is ∩-typable iﬀ t ∈ SN β.
A subtyping relation on intersection types is now speciﬁed by means of a preorder. This will be used to establish a Generation Lemma transforming any type derivation into a speciﬁc derivation depending only on the form of the term (and not on the type). Thus, the Generation Lemma turns out to be extremely useful to reason by induction on type derivations.

16 DELIA KESNER
Deﬁnition 6.2. The relation ≪ on types is deﬁned by the following axioms and rules (1) A ≪ A (2) A ∩ B ≪ A and A ∩ B ≪ B (3) A ≪ B & B ≪ C implies A ≪ C (4) A ≪ B & A ≪ C implies A ≪ B ∩ C
Lemma 6.3. If Γ ⊢∩ t : B and B ≪ A, then Γ ⊢∩ t : A.
Proof. Let Γ ⊢∩ t : B. We reason by induction on the deﬁnition of B ≪ A. Case B = A ≪ A: Trivial. Case B = A ∩ C ≪ A and B = C ∩ A ≪ A: Use ∩ E. Case B ≪ C, C ≪ A: Use (twice) the i.h. to get successively Γ ⊢∩ t : C and then Γ ⊢∩ t : A. Case B ≪ B1, B ≪ B2, A = B1 ∩ B2: Use (twice) the i.h. to get Γ ⊢∩ t : B1 and Γ ⊢∩ t : B2, then apply ∩ I.
We use the notation n for {1 . . . n} and ∩nAi for A1 ∩ . . . ∩ An.
Lemma 6.4. Let ∩nAi ≪ ∩mBj, where none of the Ai and Bj is an intersection. Then for each Bj there is Ai s.t. Bj = Ai.
Proof. By induction on the deﬁnition of ∩nAi ≪ ∩mBj. Let ∩pCk be some type where none of the Ck is an intersection type.
Case ∩nAi ≪ ∩nAi: Trivial. Case ∩mBj ∩ ∩pCk ≪ ∩mBj and ∩pCk ∩ ∩mBj ≪ ∩mBj: Trivial. Case ∩nAi ≪ ∩pCk, ∩pCk ≪ ∩mBj: Applying the i.h. a ﬁrst time we have for each Bj
a Ck s.t. Bj = Ck. Applying the i.h. again we have for each Ck a Ai s.t. Ck = Ai. Thus we can conclude. Case ∩nAi ≪ B1 ∩ . . . ∩ Bk, ∩nAi ≪ Bk+1 ∩ . . . ∩ Bm: By the i.h. we have for each Bj, 1 ≤ j ≤ k a type Ai s.t. Bj = Ai and for each Bj, k + 1 ≤ j ≤ m a type Ai s.t. Bj = Ai. Thus we can conclude.
Lemma 6.5 (Generation Lemma).
(1) Γ ⊢∩ x : A iﬀ there is x : B ∈ Γ and B ≪ A. (2) Γ ⊢∩ t[x/u] : A iﬀ there exist Ai, Bi (i ∈ n) s.t. ∩nAi ≪ A and ∀i ∈ n, Γ ⊢∩ u : Bi and
Γ, x : Bi ⊢∩ t : Ai. (3) Γ ⊢∩ tu : A iﬀ there exist Ai, Bi (i ∈ n) s.t. ∩nAi ≪ A and ∀i ∈ n, Γ ⊢∩ t : Bi → Ai
and Γ ⊢∩ u : Bi. (4) Γ ⊢∩ λx.t : A iﬀ there exist Ai, Bi (i ∈ n) s.t. ∩n(Ai → Bi) ≪ A and ∀i ∈ n, Γ, x :
Ai ⊢∩ t : Bi. (5) Γ ⊢∩ λx.t : B → C iﬀ Γ, x : B ⊢∩ t : C.
Proof. The right to left implications follow from the typing rules of the intersection type system ∩ and Lemma 6.3.
The left to right implication of the ﬁrst four points are shown by induction on the typing derivation of the left part. We only show the two ﬁrst points as the other ones are similar.
(1) Consider Γ ⊢∩ x : A. • Suppose the derivation is (ax) so that x : A ∈ Γ, then B = A.

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

17

• Suppose A = C1 ∩ C2 and the root of the derivation is

Γ ⊢ x : C1 Γ ⊢ x : C2 (∩ I) Γ ⊢ x : C1 ∩ C2
By the i.h. there is B1 ≪ C1 and B2 ≪ C2 s.t. x : B1, x : B2 ∈ Γ, thus B1 = B2 and
B1 ≪ C1 ∩ C2 concludes the proof of this case.
• Suppose the root of the derivation is

Γ ⊢ x : A ∩ A′ (∩ E)
Γ⊢x:A By the i.h. there is B ≪ A∩A′ s.t. x : B ∈ Γ. By transitivity B ≪ A which concludes the proof of this case. • There is no other possible case. (2) Consider Γ ⊢∩ t[x/u] : A. • Suppose the root of the derivation is
Γ ⊢ u : B Γ, x : B ⊢ t : A (subs)
Γ ⊢ t[x/u] : A
then the property immediately holds by taking n = 1, B1 = B and A1 = A. • Suppose A = C1 ∩ C2 and the root of the derivation is
Γ ⊢ t[x/u] : C1 Γ ⊢ t[x/u] : C2 (∩ I) Γ ⊢ t[x/u] : C1 ∩ C2
By the i.h. there are Ai, Bi (i ∈ n) s.t. ∩nAi ≪ C1 and Γ ⊢∩ u : Bi and Γ, x : Bi ⊢∩ t : Ai for all i ∈ n. Also there are A′i, Bi′ (i ∈ n′) s.t. ∩n′A′i ≪ C2 and Γ ⊢∩ u : Bi′ and Γ, x : Bi′ ⊢∩ t : A′i for all i ∈ n′. Since ∩nAi ∩ ∩n′A′i ≪ C1 ∩ C2, this concludes this case. • Suppose the root of the derivation is
Γ ⊢ t[x/u] : A ∩ B (∩ E)
Γ ⊢ t[x/u] : A
By the i.h. there are Ai, Bi (i ∈ n) s.t. ∩nAi ≪ A ∩ B and Γ ⊢ u : Bi and Γ, x : Bi ⊢ t : Ai for all i ∈ n. Since ∩nAi ≪ A, this concludes this case.
The left to right implication of point 5 follows from point 4 and Lemma 6.4. Indeed, if Γ ⊢∩ λx.t : B → C, then point 4 gives Γ, x : Bi ⊢∩ t : Ci for ∩n(Bi → Ci) ≪ B → C. Lemma 6.4 gives B → C = Bj → Cj for some j ∈ n, thus Γ, x : B ⊢∩ t : C.
The rest of the section is now devoted to establish some connections between typable and strongly normalisable terms in the λex-calculus.

Deﬁnition 6.6. The function V( ) from terms to λ-terms is deﬁned by induction as follows:

V(x) := x V(λx.t) := λx.V(t)

V(tu) := V(t)V(u) V(t[x/u]) := (λx.V(t))V(u)

This function is compositional with respect to substitution:

Lemma 6.7. Let t, u be terms. Then V(t){x/V(u)} = V(t{x/u}).

Proof. By induction on t.

18 DELIA KESNER

The function V( ) does not modify typability.
Lemma 6.8. Let t be a term. Then Γ ⊢∩ V(t) : A iﬀ Γ ⊢∩ t : A. Proof. By induction on t using the Generation Lemma 6.5.
Theorem 6.9 (Typable Terms are SN). If t is ∩-typable, then t ∈ SN λex. Proof. By Lemma 6.8 the λ-term V(t) is also ∩-typable so that the left to right implication of Theorem 6.1 gives V(t) ∈ SN β and then the PSN Property (Theorem 3.6) gives V(t) ∈ SN λex. Since V(t) →+B t (a straightforward induction on t), then t is necessarily in SN λex.

We now complete the picture by showing that the intersection type discipline for terms gives a characterisation of λex-strongly normalising terms.

Lemma 6.10. Let t be a term s.t. V(t) →β t′1. Then, ∃ t1 s.t. t →+λex t1 and t′1 = V(t1).

Proof. By induction on the reduction step V(t) →β t′1.

• If V((λx.u) v) = (λx.V(u))V(v) →β V(u){x/V(v)}, then let t1 = u{x/v}. We have

(λx.u)

v

→B

u[x/v]

→+
λex

(L.

2.2)

u{x/v}

and

we

conclude

by

Lemma

6.7.

• If V(u[x/v]) = (λx.V(u))V(v) →β V(u){x/V(v)}, then again we conclude by letting t1 =

u{x/v}.

• If V(u[x/v]) = (λx.V(u))V(v) →β (λx.u′1)V(v), where V(u) →β u′1 then the i.h. gives u1

s.t. u′1 (λx.u′1)

= V(u1) and u →+λex V(v) = V(u1[x/v]).

u1.

Let t1 = u1[x/v].

We have u[x/v] →+λex u1[x/v] and

• If V(u[x/v]) = (λx.V(u))V(v) →β (λx.V(u))v1′ , where V(v) →β v1′ , then proceed as in the

previous one.

• All the other cases are straightforward.

Theorem 6.11 (SN Terms are Typable). If t ∈ SN λex, then t is ∩-typable.
Proof. Let t ∈ SN λex. One ﬁrst shows that V(t) ∈ SN β by induction on ηλex(t). This is done by considering all the β-reducts of V(t) and using Lemma 6.10.
Now, V(t) ∈ SN β implies that V(t) is ∩-typable by the right to left implication of Theorem 6.1. Finally, Lemma 6.8 allows to conclude that t is ∩-typable.

Corollary 6.12. Let t be a term. Then t is ∩-typable iﬀ t ∈ SN λex.
We conclude this section by focusing on the particular case of the simply typed λexcalculus : types are only built over atomic symbols and functional types so that the type system only contains the typing rules {ax, abs, app, subs} in Figure 3. Since every simply typed λ-term is β-strongly normalising (this is the restriction of the left to right implication of Theorem 6.1 to simple types), then in particular:

Corollary 6.13 (Simply Typed Terms are SN - First Proof). Simply typed λex-calculus is λex-strongly normalising.

This proof depends however on previous results by [Pot80]. Another self-contained argument can be given by means of the arithmetical technique [vD77], and is extremely short.

Lemma 6.14. If tA, uB ∈ SN λex, then t{xB/uB} ∈ SN λex. Proof. By induction on the lexicographic triple B, ηλex(t), t .

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

19

• t = x. Then x{x/u} = u ∈ SN λex by the hypothesis. • t = yvn with x = y and n ≥ 0. The i.h. gives vi{x/u} ∈ SN λex since ηλex(vi) decreases
and vi is strictly smaller than t. Then we conclude by Deﬁnition 3.4 and Proposition 3.5. • t = xvvn. The i.h. gives V = v{x/u} and Vi = vi{x/u} in SN λex. We show t{x/u} =
uV Vn ∈ SN λex by induction on ηλex(u) + ηλex(V ) + Σi∈1...n ηλex(Vi). For that, it is suﬃcient to show that all its reducts are in SN λex. If the reduction takes place in a subterm of u, V, Vn, then we conclude by the i.h. Otherwise, suppose u = λy.U and (λy.U )V Vn → U [y/V ]Vn. Then type(V ) = type(v) < type(u) = type(x) so that U {y/V } ∈ SN λex by the i.h. Let us write U {y/V }Vn = (zVn){z/U {y/V }}. We have type(U {y/V }) = type(U ) < type(u) so that again by the i.h. we get U {y/V }Vn ∈ SN λex. We conclude U [y/V ]Vn ∈ SN λex by Deﬁnition 3.4 and Proposition 3.5. • t = λy.v. Then v{x/u} ∈ SN λex by the i.h. and thus t{x/u} = λx.v{x/u} ∈ SN λex follows from Deﬁnition 3.4 and Proposition 3.5. • t = (λy.s)vvn. The i.h. gives S = s{x/u}, V = v{x/u} and Vi = vi{x/u} in SN λex. To show t{x/u} = (λy.S)V Vn ∈ SN λex we reason by induction on ηλex(S) + ηλex(V ) + Σi∈1...n ηλex(Vi). For that, it is suﬃcient to show that all its reducts are in SN λex. If the reduction takes place in a subterm of (λy.S), V, Vn, we conclude by the i.h. Otherwise suppose (λy.S)V Vn → S[y/V ]Vn. Take T = s[y/v]vn. Since ηλex(T ) < ηλex(t), then the i.h. gives T {x/u} ∈ SN λex. But S[y/V ]Vn = T {x/u} so that S[y/V ]Vn ∈ SN λex. • t = s[y/v]vn. The i.h. gives S = s{x/u} and V = v{x/u} and Vi = vi{x/u} are in SN λex. They are also typed. We claim t{x/u} = S[y/V ]Vn ∈ SN λex. The perpetual strategy gives
t{x/u} = S[y/V ]Vn S{y/V }Vn
This last term can be written as T {x/u} where T = s{y/v} vn. Since ηλex(T ) < ηλex(t), then the i.h. gives T {x/u} ∈ SN λex and thus Theorem 3.3 gives S[y/V ]Vn in SN λex.
Corollary 6.15 (Simply Typed Terms are SN - Second Proof). Simply typed λex-calculus is λex-strongly normalising.
Proof. Let t be a simply typed term. We reason by induction on the structure of t. The cases t = x and t = λx.u are straightforward. If t = uv, then u, v are typed so that u, v ∈ SN λex by the i.h. We write t = (zv){z/u}, where zv is SN λex by Deﬁnition 3.4. The term zv is also appropriately typed. Lemma 6.14 then gives t ∈ SN λex. If t = u[x/v], then u, v are typed and by the i.h. u, v ∈ SN λex so that Lemma 6.14 gives u{x/v} ∈ SN λex. Deﬁnition 3.4 and Proposition 3.5 allow us to conclude u[x/v] ∈ SN λex.
7. Deriving Strong Normalisation for Other Related Calculi
We now informally discuss how strong normalisation of other calculi with ES (having or not safe composition) can be derived from strong normalisation of λex.
• The λx-calculus [Lin86, Lin92, Ros92] is just a sub-calculus of λex, with no equation and no composition rule. Thus, the fact that t →λx t′ implies t →+λex t′ is straightforward. Since simply typed terms in both calculi are the same, we thus deduce that typed terms are λx-strongly normalising.
• The λes-calculus [Kes07] can be seen as a reﬁnement of λex, where propagation of substitution with respect to application and substitution is done in a controlled way. We refer the reader to [Kes07] for details on the rules. The fact that t →λes t′ implies t →+λex t′ is

20 DELIA KESNER

straightforward. Simply typed terms in both calculi are the same, we thus deduce that

typed terms are λes-strongly normalising.

• Milner’s calculus with explicit partial substitution [Mil06], called λsub, is able to encode

λ-calculus in terms of a bigraphical reactive system. The operational semantics of λsub

is given by reduction rules which only propagate a substitution of the form [x/u] on one

occurrence of the variable x at a time (see for example [Mil06] for details). In [KC] it is

shown that there exists a translation T from T(t) →+λes T(t′). Since simply typed terms in

terms to terms both calculi are

such that the same,

t →λsub t′ implies we conclude that

typed terms are λsub-strongly normalising from the previous point.

• A λ-calculus with implicit partial β-reduction, written here λβp, appears in [dB87]. Its

syntax is the one of the pure λ-calculus (so that there is no explicit substitution operator)

and its semantics is similar to that of λsub since arguments are consumed on only one

occurrence at a time. Similarly to [KC] one can deﬁne a translation T from λ-terms to

terms such that one-step reduction in λβp is projected into at least one-step reduction in λsub. Since simply typed λ-terms translate to simply typed terms, then typed λ-terms

are λβp-strongly normalising from the previous point. • David and Guillaume [DG01] deﬁned a calculus with labels, called λws, which allows

controlled composition of ES without losing PSN. The calculus λws has a strong form of

composition which is safe but not full. Its simply typed named notation can be translated

into simply typed terms in such a way that one-step reduction in λws implies at least one-

step reduction in λex. Thus, SN for typed terms in λws is a consequence of SN for typed

λex.

• A calculus with a safe notion of composition in director string notation is deﬁned in [SFM03].

The named version of this calculus can be understood as the λx-calculus together with a

composition rule of the form:

t[x/u][y/v] → t[x/u[y/v]] if y ∈ fv(u) & y ∈/ fv(t)

This composition rule can be easily simulated by the rules Comp and Gc of the λexcalculus so that the whole calculus can be simulated by λex. As a consequence, simply typed terms turn out to be strongly normalising. • The λesw-calculus [Kes07] was used as a technical tool to show that λes enjoys PSN. The syntax extends terms with weakening constructors so that it is straightforward to deﬁne a translation T from λesw-terms to terms which forgets these weakening operators. The reduction relation λesw can be split into an equational system E and two rewriting relations L1 and L2 s.t. (1) If t =E t′ or t →L1 t′ then T(t) =C T(t′) (2) If t →L2 t′ then T(t) →+λex T(t′)
The reduction relation generated by the rules L1 modulo the equations E can be easily shown to be terminating. Also, simply typed λesw-terms trivially translate via T to simply typed terms. Thus, the Abstract Theorem given in the Appendix A allows us to conclude that typed λesw-terms are λesw-strongly normalising.

8. Confluence
In this section we study conﬂuence of the λex-calculus. More precisely, we show conﬂuence of the relation →λex on metaterms, which are terms containing metavariables denoting incomplete programs/proofs in a higher-order framework [Hue76]. Metavariables should

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

21

come with a minimal amount of information to guarantee that some basic operations such as instantiation (replacement of metavariables by metaterms) are sound in a typing context. We thus specify metavariables as follows. We consider a countable set of raw metavariables, denoted X, Y, . . .. To each raw metariable X, we associate a set of variables ∆, thus yielding a decorated metavariable denoted by X∆. Thus for example Xx,y,z and Yx,z are decorated metavariables. This decoration says nothing about the structure of the incomplete proof itself but is suﬃcient to guarantee that diﬀerent occurrences of the same metavariable are never instantiated by diﬀerent metaterms.
The set of metaterms is deﬁned by the following grammar.
M ::= x | X∆ | M M | λx.M | M[x/M]
Notice that terms are in particular metaterms. We extend the notion of free variables to metaterms by fv(X∆) := ∆. Thus, α-
conversion turns out to be perfectly well-deﬁned on metaterms by extending the renaming of bound variables to the decoration sets. Thus for example λx.YxXx,y =α λz.YzXz,y.
Meta-substitution on metaterms extends that on terms by adding two new cases:

X∆{x/v} := X∆

if x ∈/ ∆

X∆{x/v} := X∆[x/v] if x ∈ ∆

Lemma 8.1. Let t, u be metaterms. Then t{x/u} = t if x ∈/ fv(t).

Proof. By induction on t.

The following property holds for metaterms.

Lemma 8.2 (Composition Lemma). Let t, u, v be metaterms and let x, y s.t. x = y and x ∈/ fv(v). Then t{x/u}{y/v} =e t{y/v}{x/u{y/v}}.
Proof. By induction on metaterms using Lemma 8.1. Notice that =e is needed for the case where t is a metavariable.

Reduction on metaterms must be understood in the same way reduction on terms: the λex-relation is generated by the →Bx-reduction relation on e-equivalence classes of metaterms.
Reduction on terms and metaterms enjoys stability by substitution and full composition.

Lemma 8.3 (Stability of Reduction of Metaterms by Substitution). Let t, u be metaterms. For R ∈ {x, ex, λx, λex}, if t →R t′, then u{x/t} →∗R u{x/t′} and t{x/u} →R t′{x/u}. Thus in particular t{x/u} ∈ SN R implies t ∈ SN R.
Proof. By induction on t → t′.

Lemma 8.4 (Full Composition for Metaterms). Let t, u be metaterms. Then t[x/u] →∗ex t{x/u}.

Proof. The proof can be done by induction on t using Lemma 8.1. In contrast to full composition on terms (Lemma 2.2), the property holds with an equality for the base case t = X∆ with x ∈ ∆ since X∆[x/u] = X∆{x/u}.

22 DELIA KESNER

It is well-known that conﬂuence on metaterms fails for calculi without composition for ES as for example the following critical pair in the λx-calculus shows

s = t[x/u][y/v] ∗← ((λx.t) u)[y/v] →∗ t[y/v][x/u[y/v]] = s′

Indeed, while this diagram can be closed in λx for terms without metavariables [BR95],

there is no way to ﬁnd a common reduct between s and s′ whenever t is (or contains)

metavariables: no λx-reduction rule is able to mimic composition on raw/decorated metavari-

ables. Fortunately, this diagram can be closed in the λex-calculus as follows. If y ∈ fv(u),

then

s

→Comp

s′,

otherwise

s′

→∗
ex

(L.

8.4)

t[y/v][x/u{y/v}]

=(L.

8.1)

t[y/v][x/u]

=C

s′.

We now develop a conﬂuence proof for metaterms which is based on the existence of a

mapping allowing to verify the Z-property as stated by van Oostrom [vO].

Deﬁnition 8.5 (Z-Property). A map ◦ from terms to terms satisﬁes the Z-property for a reduction relation →R iﬀ t →R u implies u →∗R t◦ and t◦ →∗R u◦. A reduction relation →R has the Z-property if there is a map which satisﬁes the Z-property for →R.
It turns out [vO] that →R is conﬂuent if it has the Z-property (see Theorem A.1 in the Appendix A), so to show conﬂuence of λex it is then suﬃcient to deﬁne a map on metaterms satisfaying the Z-property. Such a map can be deﬁned in terms of the superdevelopment function for the λ-calculus [Acz78, vR93].

Deﬁnition 8.6 (Superdevelopment Function). The function ◦ on metaterms is deﬁned by

induction as follows:

X◦∆ := X∆ x◦ := x

(tu)◦ (tu)◦

:= t◦u◦

if t◦ is not an abstraction

:= v{x/u◦} if t◦ = λx.v

(λx.t)◦ := λx.t◦

t[x/u]◦ := t◦{x/u◦}

Notice that fv(t◦) ⊆ fv(t).

Lemma 8.7. Let t, u be metaterms. Then t◦u◦ →∗λex (tu)◦.

Proof. If t◦ is not an abstraction, then t◦u◦ = (tu)◦. If t◦ = λy.s, then t◦u◦ = (λy.s)u◦ →B

s[y/u◦]

→∗
ex

(L.

8.4)

s{y/u◦}

=

(tu)◦.

Lemma 8.8. Let t, u be metaterms. Then t◦{x/u◦} →∗λex t{x/u}◦.

Proof. The proof is by induction on t. Suppose t = vw. • If v◦ is not an abstraction, then

(vw)◦{x/u◦} =

v◦{x/u◦}w◦{x/u◦} →∗λex (i.h.) v{x/u}◦w{x/u}◦ →∗λex (L. 8.7) (vw){x/u}◦

•

If v◦ = λz.r, then the i.h. gives v◦{x/u◦} = (λz.r){x/u◦} v{x/u}◦ = λz.s where r{x/u◦} →∗λex s. As a consequence,

→∗λex

v{x/u}◦

so

that

(vw)◦{x/u◦} = r{z/w◦}{x/u◦} =e (L. 8.2) r{x/u◦ }{z /w◦ {x/u◦ }}

→→∗λ∗λeexx (i.h. & L. 8.3)

s{z/w◦{x/u◦}} s{z /w{x/u}◦ }
= (v{x/u}w{x/u})◦ = (vw){x/u}◦

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

23

The case t = v[y/w] also uses the i.h. and Lemma 8.2. All the other cases are straightforward.

Lemma 8.9. Let t be a metaterm. Then t →∗λex t◦.

Proof. By induction on t. The interesting cases are the following ones.

• t = uv: Then uv →∗λex (i.h.) u◦v◦ →∗λex (L. 8.7) (uv)◦ = t◦.

•

t = u[x/v]:

Then

u[x/v] →∗λex

(i.h.)

u◦[x/v◦] →∗
ex

(L. 8.4)

u◦{x/v◦} →∗λex

(L. 8.8)

u{x/v}◦.

All the other cases are straightforward.

Lemma 8.10 t◦ →∗λex u◦.

(Towards the Z-Property).

Let

t, u

be metaterms.

If

t →Bx

u,

then u →∗λex

Proof. By induction on t →Bx u.
• If t = λx.r →Bx λx.s = u, where r →Bx s, then the property holds by the i.h. • If t = r[x/v] →Bx s[x/v] = u, where r →Bx s, then

u = s[x/v]

→∗λex (i.h.)

→∗λex (L. 8.9)

→∗
ex

(L.

8.4)

r◦[x/v] r◦[x/v◦]
r◦{x/v◦} = t◦

→∗λex (i.h. & L 8.3)

s◦{x/v◦} s[x/v]◦

= = u◦

• If t = v[x/r] →Bx v[x/s] = u, where r →Bx s, then proceed as in the previous case. • If t = rv →Bx sv = u, where r →Bx s, then sv →∗λex (i.h.) r◦v →∗λex (L. 8.9) r◦v◦ →∗λex (L. 8.7)
(rv)◦. For the second part of the statement there are two cases:

− If r◦ is not an abstraction, then (rv)◦ = r◦v◦ →∗λex (i.h.) s◦v◦ →∗λex (L. 8.7) (sv)◦.

−

If r◦ = λz.w, with (rv)◦ =

then the w{z /v◦ }

i.h. r◦ →∗λex

→∗λex (L. 8.3)

s◦ implies s◦ = λz.q, q{z/v◦} = (sv)◦.

where

w

→∗λex

q.

We

conclude

• If t = vr →Bx vs = u, where r →Bx s, then vs →∗λex (i.h.) vr◦ →∗λex (L. 8.9) v◦r◦ →∗λex (L. 8.7)

(vr)◦. For the second part of the statement there are two cases:

− If v◦ is not an abstraction, then (vr)◦ = v◦r◦ →∗λex (i.h.) v◦s◦ = (vs)◦. − If v◦ = λy.w, then (vr)◦ = w{y/r◦} →∗λex (i.h. & L. 8.3) w{y/s◦} = (vs)◦. • If t = x[x/v] →Var v = u, then x[x/v]◦ = x{x/v◦} = v◦. We conclude since v →∗λex v◦ holds by Lemma 8.9.

• If t = r[x/v] →Gc r = u, then r[x/v]◦ = r◦{x/v◦} =(L. 8.1) r◦. We conclude since r →∗λex r◦ holds by Lemma 8.9.
• If t = (rs)[x/v] →App r[x/v]s[x/v] = u, then

u →∗λex (L. 8.9) r◦[x/v◦]s◦[x/v◦]

→∗
ex

(L. 8.4)

r◦{x/v◦}s◦{x/v◦} =

(r◦s◦){x/v◦}

→∗λex (L. 8.3 & 8.7) (rs)◦{x/v◦} =

(rs)[x/v]◦ = t◦

For the second part there are two cases. − If r◦ is not an abstraction, then

t◦ = r◦{x/v◦}s◦{x/v◦} = r[x/v]◦s[x/v]◦ →∗λex (L. 8.7) (r[x/v]s[x/v])◦ = u◦

24 DELIA KESNER

− If r◦ = λy.q, then r[x/v]◦ = λy.q{x/v◦}, so that

t◦ = (rs)[x/v]◦

= (rs)◦{x/v◦}

= q{y/s◦}{x/v◦} =e (L. 8.2) q{x/v◦}{y/s◦{x/v◦}} = q{x/v◦}{y/s[x/v]◦} =

(r[x/v]s[x/v])◦

= u◦

• If t = (λy.r)[x/v] →Lamb λy.r[x/v] = u, then (λy.r)[x/v]◦ = λy.r◦{x/v◦}. We have u = λy.r[x/v] →∗λex (L. 8.9) λy.r◦[x/v◦] →∗ex (L. 8.4) λy.r◦{x/v◦} = t◦ = u◦

• If t = r[x/v][y/w] →Comp r[y/w][x/v[y/w]] = u, then

u = r[y/w][x/v[y/w]] r◦[y/w◦][x/v◦[y/w◦]] r◦ {y /w◦ }{x/v◦ {y /w◦ }}

→∗λex (L. 8.9) →∗λex (L. 8.4 & 8.3) =e (L. 8.2) r◦{x/v◦}{y/w◦} = t◦

Since u◦ = r◦{y/w◦}{x/v◦{y/w◦}}, then we have t◦ →∗λex u◦ as well.

Lemma 8.11. Let t, u be metaterms s.t. t =e u. Then, • If r =e s, then t{x/r} =e u{x/s}. • t◦ =e u◦.

Proof. Suppose t =e u holds in n steps. Both properties can be simultaneously proved by induction on the lexicographic pair n, t .

Corollary 8.12 (Z-Property). Let t, u be metaterms. If t →λex u, then u →∗λex t◦ →∗λex u◦.

Proof. Let t t◦ =e r◦ and

=e r →Bx s =e u. By Lemma 8.10 r s◦ =e u◦. We thus conclude t →∗λex u◦

→→∗λ∗λeexx

s◦ t◦.

→∗λex

r◦

and

by

Lemma. 8.11

Corollary 8.13 (Conﬂuence). The reduction relation →λex is conﬂuent on metaterms.

Proof. Corollary 8.12 guarantees the Z-property. We conclude by Theorem A.1 in the Appendix A.

9. Conclusion
We propose simple syntax in named variable notation to model a calculus with explicit substitutions enjoying good properties, specially conﬂuence on metaterms, preservation of β-strong normalisation, strong normalisation of typed terms and implementation of full composition.
A simple perpetual strategy is deﬁned for calculi with ES enjoying full composition in a modular way. This strategy is used to provide an inductive deﬁnition of SN terms which is then used to prove that untyped terms enjoy PSN. The inductive characterisation of SN terms and the PSN theorem are really modular with respect to other proofs in the literature [LLD+04, Bon01b], especially because we make an intensive use of two abstract properties: full composition and the IE property. Last but not least, our development is direct, since it is not based on similar properties for other related calculi, and has a constructive style, since no classical axiom seems to be needed.

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

25

Some remarks about the application of this modular method to other calculi with ES might be interesting. On one hand, the technology presented in this paper has been successfully applied to other calculi with explicit substitutions enjoying full composition [KR09, AG09]. On the other hand, full composition alone is not suﬃcient to achieve the SN proof, otherwise the λσ-calculus [ACCL91], which is known to not being strongly normalising [Mel95], could be treated. Indeed, our strategy is not perpetual for λσ: Melli`es’ counter-example is based on an inﬁnite λσ-reduction sequence starting from a simply typed term which is not reached by our perpetual strategy. In other words, is incomplete for λσ. The deﬁnition of a perpetual strategy for λσ remains open.
We believe that a de Bruijn or nominal version of λex could be useful in real implementations. In the ﬁrst case, this could be achieved by using for example λσ⇑ technology (so that equation C can be eliminated) together with some control of composition needed to guarantee strong normalisation.
Another interesting issue is the extension of Pure Type Systems (PTS) with ES in order to improve the understanding of logical systems used in theorem-provers. Work done in this direction is based on sequent calculi [LDM06] or natural deduction [Mun˜01]. The main contribution of λex with respect to the formalisms previously mentioned would be the safe notion of full composition.

References

[ABR00] Ariel Arbiser, Eduardo Bonelli, and Alejandro R´ıos. Perpetuality in a lambda calculus with

explicit substitutions and composition. Workshop Argentino de Inform´atica Te´orica (WAIT),

JAIIO, 2000.

[ACCL91] Mart´ın Abadi, Luca Cardelli, Pierre Louis Curien, and Jean-Jacques L´evy. Explicit substitu-

tions. Journal of Functional Programming, 4(1):375–416, 1991.

[Acz78] Peter Aczel. A general church-rosser theorem, 1978. Unpublished note, University of Manch-

ester.

[AG09]

Beniamino Accattoli and Stefano Guerrini. Jumping Boxes. Representing lambda-calculus boxes

by jumps. In 18th EACSL Annual Conference on Computer Science Logic (CSL), Lecture Notes

in Computer Science, September 2009.

[BBKV76] Henk Barendregt, Jan Bergstra, Jan-Willem Klop, and Henri Volken. Degress, reductions and

representability in the lambda calculus. Technical Report 22, Utrecht University, 1976.

[BBLRD96] Zine-El-Abidine Benaissa, Daniel Briaud, Pierre Lescanne, and Jocelyne Rouyer-Degli. λυ, a

calculus of explicit substitutions which preserves strong normalisation. Journal of Functional

Programming, 6(5):699–722, 1996.

[BG99]

Roel Bloo and Herman Geuvers. Explicit substitution: on the edge of strong normalization.

Theoretical Computer Science, 211(1-2):375–395, 1999.

[Blo97]

Roel Bloo. Preservation of Termination for Explicit Substitution. PhD thesis, Eindhoven Uni-

versity of Technology, 1997.

[Bon01a] Eduardo Bonelli. Perpetuality in a named lambda calculus with explicit substitutions. Mathe-

matical Structures in Computer Science, 11(1):47–90, 2001.

[Bon01b] Eduardo Bonelli. Substitutions explicites et r´e´ecriture de termes. Th`ese de doctorat, Universit´e

Paris XI, Orsay, November 2001.

[BR95]

Roel Bloo and Kristoﬀer Rose. Preservation of strong normalization in named lambda cal-

culi with explicit substitution and garbage collection. In Computer Science in the Netherlands

(CSN), pages 62–72, 1995.

[CDC78] Mario Coppo and Mariangiola Dezani-Ciancaglini. A new type assignment for lambda-terms.

Archive for Mathematical Logic, 19:139–156, 1978.

[CDC80] Mario Coppo and Mariangiola Dezani-Ciancaglini. An extension of the basic functionality the-

ory for the λ-calculus. Notre Dame Journal of Formal Logic, 4:685–693, 1980.

26 DELIA KESNER

[Cur91] [dB72] [dB78] [dB87] [DCKP00]
[DCKP03] [DG99] [DG01] [DHK00] [DU01]
[For02]
[Gir87] [GL99]
[GP99] [Her94]
[HL89] [HMP96] [Hue76] [KC] [Kes07]

Pierre-Louis Curien. An abstract frame work for environment machines. Theoretical Computer Science, 82(2):389–402, 1991. Nicolaas G. de Bruijn. Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the church-rosser theorem. Indag. Mathematicae, 5(35):381–392, 1972. Nicolaas G. de Bruijn. A namefree lambda calculus with facilities for internal deﬁnition of expressions and segments. Technical Report 78-WSK-03, Eindhoven University of Technology, 1978. Nicolaas G. de Bruijn. Generalizing Automath by Means of a Lambda-Typed Lambda Calculus. In Mathematical Logic and Theoretical Computer Science, number 106 in Lecture Notes in Pure and Applied Mathematics, 1987. Roberto Di Cosmo, Delia Kesner, and Emmanuel Polonovski. Proof nets and explicit substitutions. In Jerzy Tiuryn, editor, Foundations of Software Science and Computation Structures (FOSSACS), volume 1784 of Lecture Notes in Computer Science, pages 63–81. Springer-Verlag, March 2000. Roberto Di Cosmo, Delia Kesner, and Emmanuel Polonovski. Proof nets and explicit substitutions. Mathematical Structures in Computer Science, 13(3):409–450, 2003. Ren´e David and Bruno Guillaume. The λl-calculus. In Delia Kesner, editor, Proceedings of the 2nd Workshop on Explicit Substitutions: Theory and Applications to Programs and Proofs, pages 2–13, July 1999. Ren´e David and Bruno Guillaume. A λ-calculus with explicit weakening and explicit substitution. Mathematical Structures in Computer Science, 11:169–206, 2001. Gilles Dowek, Th´er`ese Hardin, and Claude Kirchner. Higher-order uniﬁcation via explicit substitutions. Information and Computation, 157:183–235, 2000. Roy Dyckhoﬀ and Christian Urban. Strong normalisation of Herbelin’s explicit substitution calculus with substitution propagation. In Pierre Lescanne, editor, Proceedings of the 3rd Workshop on Explicit Substitutions: Theory and Applications to Programs and Proofs, pages 26–45, June 2001. Julien Forest. A weak calculus with explicit operators for pattern matching and substitution. In Sophie Tison, editor, 13th International Conference on Rewriting Techniques and Applications (RTA), volume 2378 of Lecture Notes in Computer Science, pages 174–191. Springer-Verlag, July 2002. Jean-Yves Girard. Linear logic. Theoretical Computer Science, 50(1):1–101, 1987. Jean Goubault-Larrecq. Conjunctive types and SKInT. In Thorsten Altenkirch, Wolfgang Naraschewski, and Bernhard Reus, editors, Proceedings of the International Workshop Types for Proofs and Programs, volume 1657 of Lecture Notes in Computer Science, pages 106–120. Springer-Verlag, March 1999. Murdoch Gabbay and Andrew Pitts. A new approach to abstract syntax involving binders. In Giuseppe Longo, editor, 14th Annual IEEE Symposium on Logic in Computer Science (LICS), pages 214–224. IEEE Computer Society Press, July 1999. Hugo Herbelin. A λ-calculus structure isomorphic to sequent calculus structure. In Leszek Pacholski and Jerzy Tiuryn, editors, Proceedings of the 8th Annual Conference of the European Association for Computer Science Logic (CSL), volume 933 of Lecture Notes in Computer Science. Springer-Verlag, September 1994. Th´er`ese Hardin and Jean-Jacques L´evy. A conﬂuent calculus of substitutions. In France-Japan Artiﬁcial Intelligence and Computer Science Symposium, 1989. Th´er`ese Hardin, Luc Maranget, and Bruno Pagano. Functional back-ends within the lambdasigma calculus. In R. Kent Dybvig, editor, Proceedings of the ACM International Conference on Functional Programming, pages 25–33. ACM Press, May 1996. G´erad Huet. R´esolution d’´equations dans les langages d’ordre 1, 2, . . . , ω. Th`ese de doctorat d’´etat, Universit´e Paris VII, 1976. Delia Kesner and Shane O´ Conchu´ir. Milner’s lambda calculus with partial substitutions. Available on http://www.pps.jussieu.fr/∼kesner/papers/. Delia Kesner. The theory of calculi with explicit substitutions revisited. In Jacques Duparc and Thomas Henzinger, editors, Proceedings of the 16th Annual Conference of the European

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

27

[Kes08]
[Kik07]
[KL05] [KL07] [KL08]
[KR09] [Klo80] [KR97] [KR98] [LDM06]
[Len06] [Lin86] [Lin92] [LLD+04] [LM99]
[LRD94] [LRD95]

Association for Computer Science Logic (CSL), volume 4646 of Lecture Notes in Computer Science, pages 238–252. Springer-Verlag, September 2007. Delia Kesner. Perpetuality for full and safe composition (in a constructive setting). In Luca Aceto, Ivan Damg˚ard, Leslie Ann Goldberg, Magnu´s M. Halld´orsson, Anna Ing´olfsd´ottir, and Igor Walukiewicz, editors, Proceedings of the 35th International Colloquium on Automata, Languages and Programming (ICALP), volume 5126 of Lecture Notes in Computer Science, pages 311–322. Springer-Verlag, July 2008. Kentaro Kikuchi. Simple proofs of characterizing strong normalization for explicit substitution calculi. In Franz Baader, editor, 18th International Conference on Rewriting Techniques and Applications (RTA), volume 4533 of Lecture Notes in Computer Science, pages 257–272. Springer-Verlag, September 2007. Delia Kesner and St´ephane Lengrand. Extending the explicit substitution paradigm. In Ju¨rgen Giesl, editor, 16th International Conference on Rewriting Techniques and Applications (RTA), volume 3467 of Lecture Notes in Computer Science, pages 407–422. Springer-Verlag, April 2005. Delia Kesner and St´ephane Lengrand. Resource operators for lambda-calculus. Information and Computation, 205(4):419–473, 2007. Kentaro Kikuchi and St´ephane Lengrand. Strong normalisation of cut-elimination that simulates β-reduction. In Roberto Amadio, editor, Foundations of Software Science and Computation Structures, volume 4962 of Lecture Notes in Computer Science, pages 380–394. SpringerVerlag, March 2008. Delia Kesner and Fabien Renaud. The prismoid of resources. In 34st International Symposium on Mathematical Foundations of Computer Science (MFCS), Lecture Notes in Computer Science, Springer-Verlag, August 2009. Jan-Willem Klop. Combinatory Reduction Systems. PhD thesis, Mathematical Centre Tracts 127, CWI, Amsterdam, 1980. Fairouz Kamareddine and Alejandro R´ıos. Extending a λ-calculus with explicit substitution which preserves strong normalisation into a conﬂuent calculus on open terms. Journal of Functional Programming, 7(4):395–420, 1997. Fairouz Kamareddine and Alejandro R´ıos. Bridging de Bruijn indices and variable names in explicit substitutions calculi. Logic Journal of the Interest Group of Pure and Applied Logic, 6(6):843–874, 1998. St´ephane Lengrand, Roy Dyckhoﬀ, and James McKinna. A sequent calculus for type theory. In Zoltan Esik, editor, Proceedings of the 15th Annual Conference of the European Association for Computer Science Logic (CSL), volume 4207 of Lecture Notes in Computer Science. SpringerVerlag, September 2006. St´ephane Lengrand. Normalisation and Equivalence in Proof Theory and Type Theory. PhD thesis, University Paris 7 and University of St Andrews, November 2006. Raphael Lins. A new formula for the execution of categorical combinators. In 8th Conference on Automated Deduction (CADE), volume 230 of Lecture Notes in Computer Science, pages 89–98. Springer-Verlag, August 1986. Raphael Lins. Partial categorical multi-combinators and Church Rosser theorems. Technical Report 7/92, Computing Laboratory, University of Kent at Canterbury, May 1992. St´ephane Lengrand, Pierre Lescanne, Dan Dougherty, Mariangiola Dezani-Ciancaglini, and Steﬀen van Bakel. Intersection types for explicit substitutions. Information and Computation, 189(1):17–42, 2004. Jean-Jacques L´evy and Luc Maranget. Explicit substitutions and programming languages. In R. Ramanujam C. Pandu Rangan, Venkatesh Raman, editor, Foundations of Software Technology and Theoretical Computer Science (FSTTCS), volume 1738 of Lecture Notes in Computer Science, pages 181–200. Springer-Verlag, December 1999. Pierre Lescanne and Jocelyne Rouyer-Degli. The calculus of explicit substitutions λυ. Technical report, INRIA, Lorraine, 1994. Pierre Lescanne and Jocelyne Rouyer-Degli. Explicit substitutions with de Bruijn levels. In Jieh Hsiang, editor, 6th International Conference on Rewriting Techniques and Applications (RTA), volume 914 of Lecture Notes in Computer Science, pages 294–308. Springer-Verlag, April 1995.

28 DELIA KESNER

[Mel95]
[Mil06] [Mun˜01] [Pot80] [Ros92]
[Sak] [SFM03]
[SvO07] [Tai67] [vD77] [vO] [vR93] [vR96] [vRSSX99]

Paul-Andr´e Melli`es. Typed λ-calculi with explicit substitutions may not terminate. In Mariangiola Dezani-Ciancaglini and Gordon Plotkin, editors, Proceedings of the 2nd International Conference on Typed Lambda Calculus and Applications (TLCA), volume 902 of Lecture Notes in Computer Science, pages 328–334. Springer-Verlag, April 1995. Robin Milner. Local bigraphs and conﬂuence: two conjectures. In Roberto Amadio and Iain Phillips, editors, Proceedings of the 13th International Workshop on Expressiveness in Concurrency (EXPRESS), volume 175. Electronic Notes in Theoretical Computer Science, 2006. C´esar Mun˜oz. Dependent types and explicit substitutions: a meta-theoretical development. Mathematical Structures in Computer Science, 11(1), 2001. Garrell Pottinger. A type assignment for the strongly normalizable λ-terms. In Roger Hindley and Jonathan P. Seldin, editors, To Haskell Brooks Curry: Essays in Combinatory Logic, Lambda Calculus and formalism, pages 561–577. Academic Press, 1980. Kristoﬀer Rose. Explicit cyclic substitutions. In Micha¨el Rusinowitch and Jean-Luc R´emy, editors, Proceedings of the 3rd International Workshop on Conditional Term Rewriting Systems (CTRS), volume 656 of Lecture Notes in Computer Science, pages 36–50. Springer-Verlag, July 1992. Takafumi Sakurai. Strong normalizability of calculus of explicit substitutions with composition. Available on http://www.math.s.chiba-u.ac.jp/∼sakurai/papers.html. Francois-R´egis Sinot, Maribel Fern´andez, and Ian Mackie. Eﬃcient reductions with director strings. In Robert Nieuwenhuis, editor, 14th International Conference on Rewriting Techniques and Applications (RTA), volume 2706 of Lecture Notes in Computer Science, pages 46–60. Springer-Verlag, June 2003. Fran¸cois-R´egis Sinot and Vincent van Oostrom. Preserving termination of the λ-calculus or not, 2007. Unpublished note. William Tait. Intensional interpretation of functionals of ﬁnite type I. Journal of Symbolic Logic, 32, 1967. Diederik Ton van Daalen. The language theory of automath. PhD thesis, Technische Hogeschool Eindhoven, 1977. Vincent van Oostrom. Z. See http://www.phil.uu.nl/∼oostrom/publication/rewriting.html for slides. Femke van Raamsdonk. Conﬂuence and superdevelopments. In Claude Kirchner, editor, 5th International Conference on Rewriting Techniques and Applications (RTA), volume 690 of Lecture Notes in Computer Science, pages 168–182. Springer-Verlag, June 1993. Femke van Raamsdonk. Conﬂuence and Normalization for Higher-Order Rewriting. PhD thesis, Amsterdam University, Netherlands, 1996. Femke van Raamsdonk, Paula Severi, Morten Heine Sorensen, and Hongwei Xi. Perpetual reductions in λ-calculus. Information and Computation, 149(2), 1999.

A THEORY OF EXPLICIT SUBSTITUTIONS WITH SAFE AND FULL COMPOSITION

29

Appendix A. Abstract Reduction Results

Theorem A.1 (Z implies Conﬂuence). If →R has the Z-property, then →R is conﬂuent.

Proof. We give a proof following the picture appearing in [vO] which proceeds in many steps. Suppose that ◦ is some map satisfying the Z-property for R.

(1) Deﬁne a• := a if a is in R-normal form, a• := a◦ otherwise.

(2) Prove that • also satisﬁes the Z-property for →R.

Proof. If a →R b, then b →∗R a◦ →∗R b◦ by the hypothesis and a• = a◦ by Point (1)

so that b →∗R a•. If b b is not an R-normal

is an R-normal form, then b• = b = a◦ = a• so that form, then b• = b◦ so that also a• = a◦ →∗R b◦ = b•.

a•

→∗R

b•.

If

(3)

Prove that a →∗R a•. Proof. If a is an R-normal

form,

then

a•

= a so

we

are done.

Otherwise,

there is

b

(4)

such that a →R b, so that Point (2) gives Prove that a →∗R b implies a• →∗R b•.

b

→∗R

a•

and

thus

a

→∗R

a•.

Proof. By induction on the number n of steps from a to b. If n = 0, then a = b and

a• = b•. If n > 0, then a →R c →∗R b, where c →∗R b holds in n − 1 steps. Point (2) and the i.h. give a• →∗R c• →∗R b•.

(5) Conclude conﬂuence of →R.

Proof. Let t and t2 →∗R t3.

→∗R t1 and t →∗R t2. We want to show that there is We proceed by induction on the number n of steps

t3 such that from t to t2.

t1 If

→∗R n=

t3 0,

then t = t2 n − 1 steps

and we from u

take t3 = to t2. By

t1 so we are Point (2) u

done. →∗R t•

If n > 0, then and by Point

t →R (4) t•

→u →∗R ∗Rt•1

t2, so

with that

u →∗R t•1. By Point (3) t1 →∗R t•1. Now, u →∗R t•1 and u →∗R t2 holds in n − 1 steps so

we close the diagram by the i.h..

Theorem A.2 (Modular Strong Normalisation). Let A1 and A2 be two reduction relations on s and let A be a reduction relation on S. Let R ⊆ s × S. Suppose
P1: For every u, v, U (u R U & u A1 v imply ∃V s.t. v R V and U A∗ V ). P1: For every u, v, U (u R U & u A2 v imply ∃V s.t. v R V and U A+ V ). P1: The relation A1 is well-founded.
Then, t R T & T ∈ SN A imply t ∈ SN A1∪A2 .

Proof. A constructive proof of this theorem can be found as Corollary 26 of [Len06]. A
proof by contradiction can be easily done as follows. Suppose t ∈/ SN A1∪A2. Then, there is an inﬁnite A1 ∪ A2-reduction sequence starting at t, and since A1 is a well-founded relation by P3, this reduction sequence has necessarily the form

t →∗A1 t1 →+A2 t2 →∗A1 t3 →+A2 . . . ∞ and can be projected by P1 and P2 into an inﬁnite A-reduction sequence as follows:

t →∗A1 t1 →+A2 t2 →∗A1 t3 →+A2 RR R R T →∗A T1 →+A T2 →∗A T3 →+A
We thus get a contradiction with the fact the T ∈ SN A.

...∞ ...∞

This work is licensed under the Creative Commons Attribution-NoDerivs License. To view a copy of this license, visit ØØÔ »»Ö Ø Ú ÓÑÑÓÒ×ºÓÖ »Ð  Ò× ×» Ý¹Ò »¾º¼» or send a letter to Creative Commons, 171 Second St, Suite 300, San Francisco, CA 94105, USA, or
Eisenacher Strasse 2, 10777 Berlin, Germany

