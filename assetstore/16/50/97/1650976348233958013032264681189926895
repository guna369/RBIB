Universidade de Bras´ılia Instituto de Ciˆencias Exatas Departamento de Ciˆencia da Computac¸˜ao
Especiﬁca¸c˜ao do Algoritmo da Transformada R´apida de Fourier Implementada em um Dispositivo Reconﬁgur´avel usando L´ogica Temporal: Estudo de Caso
Guilherme Juscelino de Sousa Morato
Monograﬁa apresentada como requisito parcial para conclus˜ao do Bacharelado em Ciˆencia da Computa¸ca˜o
Orientador Prof. Dra¯. Cla´udia Nalon
Bras´ılia 2011

Universidade de Bras´ılia – UnB Instituto de Ciˆencias Exatas Departamento de Ciˆencia da Computa¸ca˜o Curso de Bacharelado em Ciˆencia da Computa¸ca˜o

Coordenador: Prof. Dr. Marcus Vinicius Lamar

Banca examinadora composta por: Prof. Dra¯. Cl´audia Nalon (Orientador) – CIC/UnB Prof. Dr. Mauricio Ayala-Rinc´on – CIC/UnB Prof. Dr. Ricardo Pezzuol Jacobi – CIC/UnB
CIP – Cataloga¸c˜ao Internacional na Publica¸c˜ao
.
Especiﬁca¸ca˜o do Algoritmo da Transformada R´apida de Fourier Implementada em um Dispositivo Reconﬁgura´vel usando Lo´gica Temporal: Estudo de Caso/ Guilherme Juscelino de Sousa Morato, . Bras´ılia : UnB, 2011. 46 p. : il. ; 29,5 cm.
Monograﬁa (Gradua¸ca˜o) – Universidade de Bras´ılia, Bras´ılia, 2011.
1. L´ogica Computacional; FPGA; Sistemas Reconﬁgura´veis; Transformada Discreta de Fourier; DFT; Transformada Ra´pida de Fourier; FFT; Veriﬁca¸ca˜o de Hardware de Teoremas; L´ogica Proposicional Temporal
CDU 004

Endere¸co:

Universidade de Bras´ılia Campus Universita´rio Darcy Ribeiro – Asa Norte CEP 70910–900 Bras´ılia – DF – Brasil

Universidade de Bras´ılia Instituto de Ciˆencias Exatas Departamento de Ciˆencia da Computac¸˜ao

Especiﬁca¸c˜ao do Algoritmo da Transformada
R´apida de Fourier Implementada em um
Dispositivo Reconﬁgur´avel usando L´ogica
Temporal: Estudo de Caso

Guilherme Juscelino de Sousa Morato
Monograﬁa apresentada como requisito parcial para conclus˜ao do Bacharelado em Ciˆencia da Computa¸ca˜o

Prof. Dra¯. Cla´udia Nalon (Orientador) CIC/UnB

Prof. Dr. Mauricio Ayala-Rinc´on Prof. Dr. Ricardo Pezzuol Jacobi

CIC/UnB

CIC/UnB

Prof. Dr. Marcus Vinicius Lamar Coordenador do Bacharelado em Ciˆencia da Computa¸ca˜o

Bras´ılia, 11 de Julho de 2011

Agradecimentos
Agrade¸co primeiramente a Deus por estar sempre me capacitando a continuar ﬁrme nessa miss˜ao. Apesar de todas as diﬁculdades, todo sofrimento e todas as mudanc¸as de percurso, tenho certeza que Deus esta´ me levando para o caminho correto.
II Cor 4,1-12.16-17
1. Por isso na˜o desanimamos deste minist´erio que nos foi conferido por miserico´rdia. 2. Afastamos de no´s todo procedimento ﬁngido e vergonhoso. Na˜o andamos com astu´cia, nem falsiﬁcamos a palavra de Deus. Pela manifesta¸ca˜o da verdade no´s nos recomendamos `a consciˆencia de todos os homens, diante de Deus. 3. Se o nosso Evangelho ainda estiver encoberto, est´a encoberto para aqueles que se perdem, 4. para os incr´edulos, cujas inteligˆencias o deus deste mundo obcecou a tal ponto que na˜o percebem a luz do Evangelho, onde resplandece a gl´oria de Cristo, que ´e a imagem de Deus. 5. De fato, n˜ao nos pregamos, a no´s mesmos, mas a Jesus Cristo, o Senhor. Quanto a n´os, consideramo-nos servos vossos por amor de Jesus. 6. Porque Deus que disse: Das trevas brilhe a luz, ´e tamb´em aquele que fez brilhar a sua luz em nossos corac¸˜oes, para que irradia´ssemos o conhecimento do esplendor de Deus, que se reﬂete na face de Cristo. 7. Por´em, temos este tesouro em vasos de barro, para que transpare¸ca claramente que este poder extraordin´ario prov´em de Deus e n˜ao de n´os. 8. Em tudo somos oprimidos, mas n˜ao sucumbimos. Vivemos em completa penu´ria, mas n˜ao desesperamos. 9. Somos perseguidos, mas na˜o ﬁcamos desamparados. Somos abatidos, mas na˜o somos destru´ıdos. 10. Trazemos sempre em nosso corpo os trac¸os da morte de Jesus para que tamb´em a vida de Jesus se manifeste em nosso corpo. 11. Estando embora vivos, somos a toda hora entregues a` morte por causa de Jesus, para que tamb´em a vida de Jesus aparec¸a em nossa carne mortal. 12. Assim em no´s opera a morte, e em v´os a vida.
16. E´ por isso que n˜ao desfalecemos. Ainda que exteriormente se desconjunte nosso homem exterior, nosso interior renova-se de dia para dia. 17. A nossa presente tribula¸c˜ao, momentaˆnea e ligeira, nos proporciona um peso eterno de glo´ria incomensura´vel. Porque na˜o miramos as coisas que se veem, mas sim as que na˜o se veem . Pois as coisas que se veem s˜ao temporais e as que na˜o se veem s˜ao eternas.

Agrade¸co a minha ma˜e e ao meu pai por todo amor, apoio e paciˆencia dedicados a mim, durante este per´ıodo. Agrade¸co aos meus irma˜os, avo´s, primos, tios e amigos por estarem sempre ao meu lado me dando for¸ca. Agrade¸co imensamente a professora Cl´audia por todo apoio e direcionamento, desde que entrei meio perdido no Curso de Ciˆencia da Computa¸c˜ao.
5

Resumo
Este trabalho esta´ situado nas a´reas de Lo´gica Computacional e Engenharia Eletroˆnica. O objetivo principal ´e especiﬁcar formalmente um algoritmo da Transformada R´apida de Fourier em linguagem de descri¸ca˜o de hardware e a deﬁni¸c˜ao da Transformada Discreta de Fourier, ambos expressos na linguagem da Lo´gica Proposicional Temporal, para que futuramente possa ser feito a veriﬁca¸ca˜o da implementac¸˜ao atrav´es da compara¸ca˜o das duas especiﬁca¸co˜es.
Palavras-chave: Lo´gica Computacional; FPGA; Sistemas Reconﬁgur´aveis; Transformada Discreta de Fourier; DFT; Transformada Ra´pida de Fourier; FFT; Veriﬁca¸ca˜o de Hardware de Teoremas; Lo´gica Proposicional Temporal

Abstract
This work refers to the areas of Computational Logic and Electronic Engineering. The main goal is to specify an algorithm of Fast Fourier Transform on a reconﬁgurable device and the deﬁnition of the Discrete Fourier Transform, both expressed in the language of Propositional Temporal Logic, to help the veriﬁcation of the implementation by comparing the two speciﬁcations.
Keywords: Computational Logic; FPGA; Reconﬁgurable System; Discrete Fourier Transform; DFT; Fast Fourier Transform; FFT; Hardware Veriﬁcation; Propositional Temporal Logic

Sum´ario

Cap´ıtulo 1 Introdu¸c˜ao 1.1 Justiﬁcativa e Motivac¸˜ao . . . . . . . . . . . . . . . . . . . . . . . 1.2 Trabalhos Correlatos . . . . . . . . . . . . . . . . . . . . . . . . . 1.3 Descri¸ca˜o dos Cap´ıtulos . . . . . . . . . . . . . . . . . . . . . . .

11 11 11 12

Cap´ıtulo 2 Transformada de Fourier 2.1 Tipos de Transformadas . . . . . . . . . . . . . . . . . . . . . . . 2.2 Transformada Discreta de Fourier . . . . . . . . . . . . . . . . . . 2.2.1 C´alculo da Transformada Discreta de Fourier . . . . . . . . 2.3 Transformada R´apida de Fourier . . . . . . . . . . . . . . . . . . . 2.3.1 Algoritmo da DFT pela Transformada R´apida de Fourier .

13 13 14 19 20 21

Cap´ıtulo 3 A FFT em um FPGA 3.1 FPGA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.2 Arquitetura . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.3 Implementa¸c˜ao da FFT em um FPGA . . . . . . . . . . . . . . . 3.3.1 Algoritmo Implementado . . . . . . . . . . . . . . . . . . . 3.3.2 Exemplo . . . . . . . . . . . . . . . . . . . . . . . . . . . .

23 23 23 24 26 28

Cap´ıtulo 4 Lo´gica Temporal Proposicional 4.1 Sintaxe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4.2 Semaˆntica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4.3 Exemplo de Especiﬁcac¸˜ao . . . . . . . . . . . . . . . . . . . . . .

32 32 33 35

Cap´ıtulo 5 Especiﬁca¸c˜ao da DFT e do Algoritmo da FFT em um Dispositivo Reprogram´avel 5.1 Descri¸ca˜o da Deﬁnic¸˜ao da DFT . . . . . . . . . . . . . . . . . . . 5.2 Descri¸ca˜o do Algoritmo da Implementa¸ca˜o da FFT . . . . . . . .

40 41 42

Cap´ıtulo 6 Conclus˜ao

45

Referˆencias

46

8

Lista de Figuras

2.1 Sinais de Entrada - Tipos de sinais e as correspondentes transformadas que se aplicam . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Exemplos de entradas e sa´ıdas de DFT real e complexa . . . . . . 2.3 Fun¸co˜es base de uma DFT de 8 pontos . . . . . . . . . . . . . . .

14 15 18

3.1 Imagem de uma placa com um FPGA Ciclone R II integrado . . . 24 3.2 Arquitetura de um no´ do circuito da FFT em um FPGA . . . . . 25 3.3 Circuito da FFT para N entradas . . . . . . . . . . . . . . . . . . 26

4.1 Uma sequˆencia de estados temporais . . . . . . . . . . . . . . . . 34

Lista de Tabelas
3.1 Paraˆmetros da conﬁgura¸c˜ao inicial dos no´s da FFT para N = 8 . 27 3.2 Paraˆmetros da segunda reconﬁgurac¸˜ao dos No´s da FFT para N = 8 28 3.3 Paraˆmetros da terceira reconﬁgurac¸˜ao dos No´s da FFT para N = 8 28 3.4 Paraˆmetros da quarta reconﬁgurac¸˜ao dos No´s da FFT para N = 8 28 3.5 Sa´ıda da FFT para N = 8 . . . . . . . . . . . . . . . . . . . . . . 28 3.6 Exemplo de um dom´ınio de tempo . . . . . . . . . . . . . . . . . 29 3.7 Exemplo de um dom´ınio de tempo . . . . . . . . . . . . . . . . . 29 3.8 Valores da FFT ap´os a primeira reconﬁgura¸c˜ao . . . . . . . . . . 29 3.9 Valores da FFT ap´os a segunda reconﬁgura¸c˜ao . . . . . . . . . . . 30 3.10 Valores da FFT apo´s a terceira reconﬁgura¸ca˜o . . . . . . . . . . . 30 3.11 Valores da FFT apo´s a quarta reconﬁgura¸ca˜o . . . . . . . . . . . . 31

Lista de Equa¸c˜oes
2.1 Onda cosseno de N pontos e k ciclos . . . . . . . . . . . . . . . . . . . 17 9

2.2 Onda seno de N pontos e k ciclos . . . . . . . . . . . . . . . . . . . . . 2.3 Equa¸c˜ao da s´ıntese da DFT . . . . . . . . . . . . . . . . . . . . . . . . 2.4 Equa¸c˜ao da DFT pelo m´etodo de correla¸ca˜o . . . . . . . . . . . . . . . 3.1 Equa¸c˜ao da DFT sem fator de normaliza¸c˜ao . . . . . . . . . . . . . . .

17 17 19 25

10

Cap´ıtulo 1
Introdu¸c˜ao
Para realizar a veriﬁca¸ca˜o formal de um sistema computacional, em geral precisamos descrevˆe-lo, ou prover sua especiﬁca¸c˜ao, com o aux´ılio de uma linguagem formal; s˜ao caracterizadas, tamb´em com o aux´ılio de uma linguagem formal, as propriedades que tal sistema deve ter para atender seus requisitos. Apo´s a caracteriza¸ca˜o formal do problema e da soluc¸˜ao proposta, ferramentas de veriﬁca¸ca˜o formal podem ser empregadas para fornecer uma prova de que o sistema, de fato, apresenta solu¸ca˜o correta ao problema. O principal objetivo deste trabalho ´e realizar o primeiro passo para a veriﬁca¸ca˜o do circuito proposto em [3], ou seja, a especiﬁca¸ca˜o tanto do problema quanto da solu¸ca˜o implementada. A linguagem de especiﬁca¸c˜ao ´e a da lo´gica proposicional temporal [1, 10], uma linguagem que estende a l´ogica proposicional cla´ssica com operadores que permitem a descric¸˜ao de sequˆencias de eventos.
1.1 Justiﬁcativa e Motiva¸c˜ao
O interesse em se desenvolver este projeto se deve `as seguintes razo˜es:
• Conhecer melhor a a´rea de dispositivos reconﬁgura´veis, que se mostra como uma solu¸ca˜o para uma poss´ıvel soluc¸˜ao para as limita¸c˜oes da arquitetura de von Neumann [2].
• Aprofundar o conhecimento em lo´gica temporal linear proposicional, pois ´e uma linguagem interessante para expressar ac¸˜oes com varia¸co˜es no tempo, e assim, nos auxiliar na representa¸ca˜o e veriﬁca¸ca˜o de uma sequˆencia de eventos.
1.2 Trabalhos Correlatos
O artigo [3] ´e um estudo de caso de uma arquitetura de um dispositivo dinamicamente reconﬁgur´avel para computar a Transformada Ra´pida de Fourier. A computa¸ca˜o reconﬁgur´avel ´e um a´rea da eletrˆonica digital que vem sendo cada vez mais pesquisada, devido aos bons resultados obtidos, relativos `a performance, quando comparados a solu¸co˜es em software. Al´em disso, apresenta ﬂexibilidade
11

para a gera¸ca˜o de arquiteturas dedicadas para resolu¸c˜ao de problemas espec´ıﬁcos, com baixo custo quando comparada a processadores convencionais.
O livro [9] ´e um estudo de circuitos compostos de Flip-ﬂops, apresentando a especiﬁca¸ca˜o e a veriﬁcac¸˜ao do circuito baseado na L´ogica Temporal Proposicional.
1.3 Descri¸c˜ao dos Cap´ıtulos
Para o entendimento do escopo deste trabalho, ´e necess´ario ter conhecimento aprofundado de alguns conceitos situados na a´rea de l´ogica computacional, matema´tica e engenharia eletroˆnica. Esses conceitos sera˜o apresentados nos Cap´ıtulos 2, 3 e 4. Ap´os a introduc¸˜ao dos conceitos subjacentes, sera´ apresentada, no Cap´ıtulo 5 a especiﬁcac¸˜ao da DFT e da implementa¸ca˜o da mesma pela t´ecnica da Transformada R´apida de Fourier. A estrutura deste trabalho ´e detalhada a seguir.
No Cap´ıtulo 2, ´e apresentada a deﬁni¸ca˜o da Transformada de Fourier. Houve uma certa preocupa¸ca˜o em detalhar cada propriedade desse conjunto de t´ecnicas matema´ticas, para facilitar a compreensa˜o do assunto. Sa˜o apresentados tamb´em exemplos de t´ecnicas para a aplica¸ca˜o da Transformada Discreta de Fourier. A Transformada R´apida de Fourier ´e apresentada em mais detalhe, pois ´e o principal alvo de estudo do projeto. O conteu´do deste cap´ıtulo ´e baseado em [11, 3], para a apresenta¸ca˜o da Transformada de Fourier, e em [8], para apresenta¸c˜ao de propriedades dos nu´meros complexos.
O cap´ıtulo seguinte apresenta informa¸co˜es b´asicas sobre o dispositivo utilizado para a aplica¸ca˜o do algoritmo da Transformada R´apida de Fourier. Para este cap´ıtulo, os manuais de instru¸co˜es da Altera [6, 7, 5], empresa que fabrica um tipo de dispositivo reconﬁgur´avel chamado de FPGA, abrevia¸ca˜o para o termo em Field Programmable Gate Arrays, modelo Ciclone R , ajudaram a entender melhor as caracter´ısticas do dispositivo e dos recursos que ele necessita para a implementac¸˜ao de um algor´ıtimo. Tamb´em neste cap´ıtulo, ´e apresentada a implementac¸˜ao do algoritmo de uma Transformada Ra´pida de Fourier em um dispositivo reconﬁgur´avel, estudo de caso desse projeto. Esse algoritmo foi estudado a partir do artigo [3].
A lo´gica temporal ´e apresentada no Cap´ıtulo 4, onde sa˜o apresentadas as suas principais caracter´ısticas, como a sintaxe e a semaˆntica da linguagem. Tamb´em ´e apresentado um estudo de caso para exempliﬁcar o uso da linguagem [1, 10].
No Cap´ıtulo 5, ´e apresentada a especiﬁca¸ca˜o do Algoritmo da Transformada Ra´pida de Fourier implementado no dispositivo reconﬁgur´avel [3], utilizando o conhecimento apresentado nos cap´ıtulos anteriores. A linguagem da Lo´gica Temporal Proposicional ´e utilizada para a escrita do problema e da solu¸ca˜o implementada.
Por ﬁm, no Cap´ıtulo 6, relatamos os resultados obtidos e a an´alise dos mesmos. Tamb´em ´e apresentada uma visa˜o geral sobre os objetivos, o processo de veriﬁcac¸˜ao e os resultados obtidos.
12

Cap´ıtulo 2
Transformada de Fourier
A ana´lise de Fourier ´e a aplica¸ca˜o de um conjunto de t´ecnicas matema´ticas utilizadas para transformar sinais de entrada do dom´ınio de tempo para o dom´ınio de frequˆencias. A decomposi¸c˜ao de sinais tem o propo´sito de transformar sinais primitivos, complexos de se analisar, em va´rias ondas seno e cosseno, que sa˜o mais simples de analisar e manipular. A soma da multiplica¸c˜ao das amplitudes armazenadas, pelas fun¸co˜es sinusoidais sintetizam o sinal original, previamente decomposto. Neste cap´ıtulo, revisaremos os conceitos b´asicos e algoritmos para decomposi¸ca˜o de sinais, em conformidade com o apresentado em [11].
2.1 Tipos de Transformadas
Os sinais primitivos de entrada podem ser classiﬁcados em quatro categorias, cada uma com duas propriedades espec´ıﬁcas, conforme Figura 2.1. As categorias sa˜o:
Aperi´odico e Cont´ınuo - Os sinais de entrada se estendem continuamente para o inﬁnito positivo e negativo, sem um padra˜o de repetic¸˜ao. A transformada para essa categoria ´e chamada de Transformada de Fourier;
Perio´dico e Cont´ınuo - Os sinais de entrada se estendem continuamente para o inﬁnito positivo e negativo, possuindo um padr˜ao regular de repetic¸˜ao. Essa categoria de transformadas ´e chamada de S´erie de Fourier;
Aperi´odico e Discreto - Os sinais de entrada sa˜o pontos discretos entre o inﬁnito positivo e negativo, sem um padra˜o regular de repeti¸ca˜o. Esse tipo de transformada ´e chamada de Transformada de Fourier de Tempo Discreto, ou DTFT, abrevia¸ca˜o para Discrete Time Fourier Transform;
Perio´dico e Discreto - Os sinais de entrada sa˜o pontos discretos entre o inﬁnito positivo e negativo, com um padr˜ao regular de repeti¸c˜ao. Essa categoria de transformadas ´e chamada de Transformada Discreta de Fourier, ou DFT, abrevia¸ca˜o para Discrete Fourier Transform.
Observe que na caracteriza¸c˜ao acima todos os tipos de sinais sa˜o inﬁnitos, uma vez que ondas seno e cosseno sa˜o deﬁnidas sobre o cont´ınuo real. Obviamente, na˜o
13

Transformada de Fourier
Série de Fourier
Transformada de Fourier de Tempo Discreto
Transformada Discreta de Fourier
Figura 2.1: Sinais de Entrada - Tipos de sinais e as correspondentes transformadas que se aplicam
´e poss´ıvel trabalhar algoritmicamente com um nu´mero inﬁnito de amostras de um sinal. Tamb´em n˜ao ´e poss´ıvel ter como entrada um sinal inﬁnito para sintetizar sinal de tamanho ﬁnito. Para resolver esse problema, os dados discretos de um sinal sa˜o tratados de modo a parecerem inﬁnitos. Um dos enfoques consiste em se obter uma amostra e fazer com que seja atribu´ıdo zero a todos os pontos a` esquerda e a` direita da amostra; neste caso, a amostra inﬁnita resultante pode ser caracterizada como um sinal aperi´odico, sendo tratado como na categoria DTFT. Em outro enfoque, considera-se que a amostra se repete inﬁnitamente a` esquerda e a` direita; neste caso, o sinal considerado ´e tratado como peri´odico, na categoria DFT.
Para sintetizar um sinal aperi´odico, ´e necessa´rio um nu´mero inﬁnito de fun¸co˜es sinusoidais que o caracterizem, tornando imposs´ıvel calcular a Transformada de Fourier de Tempo Discreto por um algoritmo computacional. Assim, a u´nica transformada que, de fato, ´e utilizada no processamento digital de sinais ´e a Transformada Discreta de Fourier, que discutiremos em mais detalhe na pro´xima se¸ca˜o.
2.2 Transformada Discreta de Fourier
Todas as categorias apresentadas na Se¸ca˜o 2.1 podem ter como dom´ınio os nu´meros reais ou os complexos.
14

DFT Real

Domínio de Tempo
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
0

Domínio de Frequência
Parte Real
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
0 N/2

aaaPaaaaaaaaaaraaateaaaaaaIaaamaaaaaaaaaagaaaaaainaaaaaaáaaaraaaia 0 N/2

DFT Complexa

Domínio de Tempo
Parte Real
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
0 N-1

Domínio de Frequência
Parte Real
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
0 N/2 N-1

aaaPaaaaaaaaaaraaateaaaaaaIaaamaaaaaaaaaagaaaaaainaaaaaaáaaaraaaiaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 0 N-1

aaaPaaaaaaaaaaraaateaaaaaaIaaamaaaaaaaaaagaaaaaainaaaaaaáaaaraaaiaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 0 N/2 N-1

Figura 2.2: Exemplos de entradas e sa´ıdas de DFT real e complexa

A Transformada Discreta de Fourier processa sinais de entrada, rotulados como dom´ınio de tempo, em sinais de sa´ıda, rotulados como dom´ınio de frequˆencias. Como esquematizado na Figura 2.2, a DFT Real transforma um dom´ınio de tempo de N pontos em dois dom´ınios de N/2 + 1 pontos, sendo um deles a parte real, e o outro, a parte imagina´ria. Esses dois dom´ınios gerados constituem o dom´ınio de frequˆencias e cont´em as amplitudes das ondas seno e ondas cosseno contidas no sinal de entrada.
A DFT complexa transforma dois dom´ınios de tempo de N pontos de entrada em dois dom´ınios de amplitudes, com N pontos cada um, constituindo o dom´ınio de frequˆencias. Para se calcular a DFT real por um m´etodo de DFT complexa, cada amostra a ser analisada deve ser colocada na parte real de cada ponto do dom´ınio de tempo. Os N valores da parte imagin´aria no dom´ınio de tempo de entrada devem ser nulos. Ao aplicar a t´ecnica, s˜ao gerados dois dom´ınios de N pontos, constituindo o dom´ınio de frequˆencia. O intervalo do ponto 0 ao ponto N/2 dos dois vetores do dom´ınio de frequˆencia gerados correspondem ao resultado da an´alise dessa DFT real.
Apresentaremos a transformada levando em considera¸c˜ao sua representa¸c˜ao como nu´meros complexos, pois a implementa¸c˜ao em estudo [3] utiliza este dom´ınio. Assim, levamos em considera¸c˜ao os N pontos gerados nos dois vetores do dom´ınio de frequˆencia.
O dom´ınio de tempo de entrada e o dom´ınio de frequˆencia de sa´ıda possuem as seguintes caracter´ısticas:
Dom´ınio de Tempo - O sinal de entrada ´e caracterizado por uma amostragem de tamanho N sobre um dado intervalo de tempo. Utilizamos letras
15

minu´sculas para representar os vetores de amostras no dom´ınio do tempo. Por exemplo, se x representa um determinado sinal, ent˜ao x[] ´e o vetor de amostras deste sinal. Observa-se que se x[j] ´e o vetor de N amostras, os seus elementos variam de j = 0 at´e j = N − 1. Ao considerarmos representa¸co˜es complexas de um sinal, x ´e caracterizado, na realidade, por dois vetores, Rex[j] e Imx[j], contendo as partes real e imagina´ria de x[j], respectivamente. Para o ca´lculo da DFT, normalmente considera-se o nu´mero de amostras como sendo uma potˆencia de dois, uma vez que o endere¸camento de dados ´e realizado a partir de tamanhos inteiros bin´arios e porque o algoritmo mais eﬁciente para o ca´lculo da DFT, a Transformada R´apida de Fourier, opera com estas potˆencias.
Dom´ınio de Frequˆencia - O sinal de sa´ıda cont´em as amplitudes de ondas seno e cosseno que podem sintetizar o sinal de entrada. S˜ao usadas letras maiu´sculas para representar as informa¸co˜es referentes a este dom´ınio; por exemplo, X[]. Considerando o sinal de entrada no dom´ınio de tempo x[j] com N valores, o sinal de sa´ıda ´e representado por X[k], com k variando de k = 0 at´e k = N − 1. A parte real desse vetor X[k] corresponde a ReX[k] e descreve as amplitudes das ondas cosseno com N pontos. A parte imagin´aria de X[k] ´e denotada por ImX[k] e corresponde aos valores das amplitudes das ondas seno com N pontos. A varia´vel k representa a frequˆencia das ondas seno e cosseno que sera´ multiplicada pela amplitude armazenada no vetor.
O processo de transformar o sinal do dom´ınio de tempo no dom´ınio de frequˆencias ´e chamado de DFT, decomposi¸c˜ao ou an´alise; o processo de transformar o dom´ınio de frequˆencias no dom´ınio de tempo ´e chamado de DFT inversa ou s´ıntese.
Os ´ındices do eixo horizontal do dom´ınio de frequˆencias X podem ser representado de quatro maneiras distintas, detalhadas a seguir:
Taxa de Amostra - Os N ´ındices de X[k] sa˜o representados diretamente pela varia´vel k.
Fra¸c˜ao da Taxa de Amostra - Os N ´ındices de amplitudes, s˜ao representados por f , sendo f a fra¸ca˜o f = k/N . Assim podemos optar por eixo horizontal variando de −1 a 0 para k variando de −(N − 1) a 0; ou variando de −0, 5 a 0, 5 com k variando de −N/2 a N/2; ou enta˜o variando de 0 a 1, com k variando de 0 a N − 1.
Radianos - E´ semelhante a` Frac¸˜ao da Taxa de Amostra, mas os ´ındices ω do eixo horizontal sa˜o multiplicados por 2π, obtendo ω = 2πk/N . Assim os ´ındices das amplitudes sa˜o representados como igualmente espa¸cados no intervalo entre −2π e 0, ou −π e π ou 0 e 2π, dependendo da forma escolhida para representar k.
Hertz - E´ usado para aplica¸c˜oes espec´ıﬁcas. Considerando um sinal de taxa de entrada igual a T Hz, a vari´avel independente est´a no intervalo entre 0 e T .
16

Por exemplo, se temos 5000 amostras por segundos, o eixo horizontal seria representado por T , variando de T = 0 at´e T = 5 kHz.

As ondas seno e cosseno usadas na DFT s˜ao chamadas de fun¸co˜es bases e sa˜o geradas por:

2πkj Ck[j] = cos( N )

(2.1)

2πkj Sk[j] = sin( N )

(2.2)

onde Ck ´e a onda cosseno com N pontos, correspondente a` amplitude armazenada em ReX[k]; e Sk ´e a onda seno com N pontos, correspondente `a amplitude armazenada em ImX[k].
A Figura 2.3 apresenta um exemplo de todas as ondas cosseno e ondas seno que podem estar presentes em uma DFT de 8 pontos. Para N = 8, k varia de 0 a N − 1 gerando oito ondas cosseno e oito ondas seno. A varia´vel j assume valores entre 0 e N − 1, representando os N pontos de amostra em cada onda. Assim, para cada onda seno e onda cosseno, k representa quanto ciclos inteiros a onda seno ou a onda cosseno completa para os N pontos de amostra.
As ondas representadas por S0 e SN/2 sempre apresentam todos os seus pontos de amostra com valor igual a 0 pois sa˜o resultantes de ca´lculos de sin(0) e sin(j ·π) respectivamente, onde j ´e um nu´mero inteiro positivo, resultando em pontos nulos. Como ImX[0] e ImX[N/2] representam as amplitudes de S0 e SN/2, sempre possuem valores nulos e na˜o inﬂuenciam na s´ıntese de x[].
A s´ıntese de um ponto do dom´ınio de tempo x[] pode ser obtida pela soma, em todas as ondas cosseno e ondas seno, do produto do ponto desejado e da amplitude correspondente `aquela frequˆencia. A fo´rmula que caracteriza a s´ıntese ´e dada por:

N −1

2πkj

2πkj

x[j] = X[k] · (cos( ) + i · sin( )

NN

k=0

(2.3)

A partir da equa¸ca˜o 2.3, obtemos:

x[j]

=

N −1
(ReX [k]

·

2πkj cos(

)

−

I mX

·

2πkj sin(

))

NN

k=0

+i

·

(ReX [k]

·

2πkj sin(

)

+

I mX

·

2πkj cos(

))

NN

Neste trabalho iremos focar na decomposi¸ca˜o, portanto a s´ıntese n˜ao sera´

aprofundada neste texto.

17

C0[ ]
1

C [j] = cos(2πkj) k N

0 -1 0 1 2

3456

78

S0[ ]
1

C [j] = sen(2πkj) k N

0 -1 0 1 2

3456

78

C1[ ]
1

0

-1 0 1 2

3456

78

S1[ ]
1

0

-1 0 1 2

3456

78

C2[ ]
1

0

-1 0 1 2

3456

78

S2[ ]
1

0

-1 0 1 2

3456

78

C3[ ]
1

0

-1 0 1 2

3456

78

S3[ ]
1

0

-1 0 1 2

3456

78

C4[ ]
1

0

-1 0 1 2

3456

78

S4[ ]
1

0

-1 0 1 2

3456

78

C5[ ]
1

0

-1 0 1 2

3456

78

S5[ ]
1

0

-1 0 1 2

3456

78

C6[ ]
1

0

-1 0 1 2

3456

78

S6[ ]
1

0

-1 0 1 2

3456

78

C7[ ]
1

0

-1 0 1 2

3456

78

S7[ ]
1

0

-1 0 1 2

3456

78

Figura 2.3: Fun¸co˜es base de uma DFT de 8 pontos. Sa˜o 8 ondas cosseno e 8 seno com N pontos de amostra

18

2.2.1 C´alculo da Transformada Discreta de Fourier
De acordo com [11], a DFT pode ser calculada de trˆes formas diferentes, variando a eﬁciˆencia:
Equa¸c˜oes Simultˆaneas - E´ bastante ineﬁciente na pra´tica, mas nos ajuda a entender a DFT.
Correla¸c˜ao - E´ eﬁciente para DFT com menos de 32 pontos de amostra.
Transformada R´apida de Fourier - E´ extremamente eﬁciente e muito usada no processamento digital de sinais.
Os trˆes m´etodos produzem resultados idˆenticos e sera˜o explicados nas sec¸˜oes seguintes. Ser´a dada ˆenfase `a Transformada R´apida de Fourier pois ´e o algoritmo usado na implementa¸ca˜o baseada em reconﬁgura¸ca˜o dos dispositivos que iremos analisar [3].

2.2.1.1 DFT por Equa¸c˜oes Simultˆaneas
O ca´lculo da DFT por equa¸co˜es simultaˆneas ´e realizado a partir da deﬁni¸ca˜o da Equa¸ca˜o 2.3, que realiza a s´ıntese de um ponto do dom´ınio de tempo. Considerando um valor N de pontos de amostra do dom´ınio de tempo, seria necess´ario obter N equa¸co˜es independentes para obter todas as amplitudes do dom´ınio de frequˆencias, sendo N amplitudes de X[k].
O m´etodo apresentado ´e simples e nos ajuda a entender melhor a DFT, mas na˜o ´e muito utilizado devido ao grande nu´mero de passos necessa´rios para se encontrar o dom´ınio de frequˆencias.

2.2.1.2 DFT por Correla¸c˜ao
Uma forma melhor que o m´etodo de equa¸co˜es simultaˆneas para se calcular a DFT ´e o m´etodo da correla¸ca˜o. O conceito de correla¸ca˜o aﬁrma que para saber se um sinal conhecido, que neste caso sa˜o as ondas seno e cosseno, est´a contido em outro sinal, basta veriﬁcar a soma do produto de cada par de pontos dos dois sinais. O resultado dessa opera¸ca˜o corresponde ao peso em que uma onda cont´em a outra. Assim, este valor resultante corresponde `a amplitude da onda seno ou onda cosseno no dom´ınio das frequˆencias. A equa¸c˜ao correspondente a este procedimento ´e:

X [k]

=

1 N

N −1
· x[j] · ωNjk

para

k

=

0, 1, · · ·

,N

−1

j=0

(2.4)

onde

ωN

=

e−i

2π N

´e a primitiva da N -´esima raiz complexa.

19

Para separar a fo´rmula nas partes real e imagin´aria do dom´ınio de frequˆencias, ´e preciso realizar algumas operac¸˜oes em nu´meros complexos. Substituindo ω em 2.4, obtemos:

X[k] =

1

N −1

·

x[j

]

·

e−i

2πjk N

para k = 0, 1, · · · , N − 1.

N

j=0

(2.5)

De acordo com a rela¸ca˜o de Euler, ei·t = cos(t) + i sin(t). Fazendo a substitui¸ca˜o em 2.5, temos que:

X[k] =

1

·

N −1

x[j]

·

2πjk (cos( )

−

i

2πjk sin( ))

para

k

=

0,

1,

·

·

·

,

N

−

1.

(2.6)

N NN

j=0

Sabendo que a multiplica¸ca˜o de nu´meros complexos, (a + bi) e (c + di), ´e dada por (ac − bd) + (ad + cb)i, a partir de 2.6, temos:

1 N−1

2πkj

2πkj

ReX[k] = · Rex[j] · cos( ) + Imx[j] · sin( )

N NN

j=0

e

1 N−1

2πkj

2πkj

ImX[k] = · Rex[j] · − sin( ) + Imx[j] · cos( ).

N NN

j=0

Correlacionando o sinal de entrada com as fun¸co˜es bases, podemos encontrar os valores de ReX[k] e ImX[k] para k variando de 0 a N − 1. O valor de X[k] = ReX[k] + i · ImX[k]
O c´alculo da DFT utilizando correla¸ca˜o, em dom´ınios de tempo, ´e simples. Mas para dom´ınios de tempo com nu´mero de pontos de amostra maior que 32, ´e mais eﬁciente usar a Transformada R´apida de Fourier, detalhada na Se¸ca˜o 2.3.

2.3 Transformada R´apida de Fourier
Dos muitos m´etodos para se calcular a DFT, a Transformada R´apida de Fourier, ou FFT, abrevia¸ca˜o para Fast Fourier Transform, ´e mais eﬁciente que os outros, podendo reduzir o tempo de c´alculo em centenas de vezes. A FFT n˜ao ´e um tipo diferente de DFT, e sim uma t´ecnica para se calcular a DFT. O algoritmo foi proposto por J. W. Cooley e J. W. Tukey em [4]. A t´ecnica j´a havia sido usada antes por Karl Friedrich Gauss (1777-1855), mas o trabalho foi abandonado por na˜o existir na ´epoca, a ferramenta apropriada para aplicar o algoritmo, o computador. O algoritmo para a computa¸ca˜o da DFT tem complexidade com cota superior de O(n2) e o algoritmo da FFT proposto por Cooley-Tukey tem cota superior de O(n ln n), conforme [11].

20

2.3.1 Algoritmo da DFT pela Transformada R´apida de
Fourier
A FFT ´e um algoritmo um pouco mais complicado que os outros apresentados e utiliza nu´meros complexos como sinais de entrada. Como visto na Se¸c˜ao 2.2, cada ponto de amostra, possui uma parte real e uma parte imagin´aria. Portanto, quando nos referimos a uma amostra X[k] no dom´ınio de frequˆencias, estamos nos referindo a combinac¸˜ao de ReX[k] e a ImX[k].
A FFT funciona decompondo esse dom´ınio de tempo de N pontos complexos em N dom´ınios de tempo de apenas um ponto. Em seguida, ´e calculado o espectro de frequˆencias desses N dom´ınios para enta˜o sintetizar esses N espectros de frequˆencias em apenas um dom´ınio de frequˆencias. Esse dom´ınio de frequˆencias resultante corresponde `a Transformada Discreta de Fourier do sinal de entrada.
A decomposi¸ca˜o do sinal de entrada ´e realizada atrav´es de uma s´erie de passos at´e que sejam obtidos os N dom´ınios de tempo. Para que isso aconte¸ca, em cada um desses passos da decomposi¸ca˜o, os dom´ınios de tempo existentes sa˜o divididos em dois dom´ınios cada um. Esse padra˜o de divisa˜o ´e seguido at´e que cada um dos dom´ınios possua apenas um ponto. Sa˜o necessa´rios log2 N passos nessa decomposi¸c˜ao.
Em cada uma das diviso˜es dos dom´ınios de tempo, os pontos sa˜o separados de acordo com um padr˜ao chamado Decomposi¸c˜ao Entrela¸cada. Esse padra˜o ´e necessa´rio para que ao ﬁnal da decomposi¸ca˜o, os dom´ınios estejam ordenados conforme a t´ecnica de ordena¸ca˜o chamada de Revers˜ao de Bit. A ideia desse padra˜o ´e que no ﬁnal da decomposic¸˜ao, a posi¸ca˜o de cada ponto seja igual ao reverso do nu´mero em bin´ario da posi¸ca˜o que ele se encontrava antes da decomposic¸˜ao. Para exempliﬁcar essa ordena¸c˜ao, vamos analisar o sinal de entrada x[12] para N = 16. O nu´mero 12 em bina´rio, corresponde a (1100). A reversa˜o desse nu´mero corresponde a (0011), ou seja, o nu´mero 3. Assim, x[12] corresponderia ao quarto dom´ınio de tempo ap´os a decomposic¸˜ao.
Apo´s a decomposic¸˜ao, ´e preciso achar o espectro de frequˆencia para cada um dos dom´ınios de um ponto. Claramente, o espectro de frequˆencia de um dom´ınio com apenas um ponto corresponde a ele mesmo. Assim, decompondo o sinal de entrada, ´e encontrado tamb´em o espectro de frequˆencia. Portanto, para encontrar a Transformada Discreta de Fourier, ´e preciso apenas sintetizar os N espectros de frequˆencia em apenas um dom´ınio de frequˆencias.
Para sintetizar esses dom´ınios, ´e preciso combinar pares de espectro para que formem um dom´ınio com o dobro de seu tamanho original. Essas combina¸co˜es sa˜o repetidas, at´e que se forme um u´nico dom´ınio de frequˆencias, correspondendo a` DFT do sinal de entrada.
Antes de combinar dois dom´ınios, como dito, ´e preciso dobra´-los de tamanho. Isso ´e feito intercalando os pontos do espectro de frequˆencias com zeros. Um dos dom´ınios mant´em o primeiro ponto e insere um zero apo´s cada ponto. O outro dom´ınio a ser combinado inicia com zero, deslocando cada ponto para uma posi¸ca˜o apo´s cada zero. Este deslocamento de uma casa por cada ponto feito no segundo espectro corresponde a` multiplicac¸˜ao por uma fun¸ca˜o sinusoidal. A cada combina¸ca˜o, um dos espectros de frequˆencia ´e multiplicado por uma fun¸c˜ao e, enta˜o, combinado com outro dom´ınio, at´e que um so´ dom´ınio de frequˆencias
21

seja gerado, obtendo assim a Transformada Discreta de Fourier, pela t´ecnica da Transformada Ra´pida de Fourier.
22

Cap´ıtulo 3
A FFT em um FPGA
Os dispositivos digitais na˜o reconﬁgura´veis nem sempre sa˜o ideais para as aplica¸co˜es que executam, ja´ que poderia haver uma melhora signiﬁcativa se arquiteturas espec´ıﬁcas fossem desenvolvidas para cada uma dessas aplica¸co˜es. Os dispositivos reconﬁgur´aveis se apresentam como uma alternativa para executar aplica¸co˜es comuns e como uma alternativa para executar solu¸co˜es para aplica¸co˜es espec´ıﬁcas com melhor desempenho, por meio de uma arquitetura dedicada a` execu¸ca˜o desta solu¸c˜ao. O desenvolvimento desses dispositivos, combinados a co´digos de programa¸ca˜o, e o surgimento de FPGAs (do inglˆes Field Programmable Gate Arrays) facilitam, assim, o desenvolvimento de arquiteturas para ﬁnalidades espec´ıﬁcas. Os conceitos introduto´rios, apresentados a seguir, esta˜o baseados em [6, 7, 5].
3.1 FPGA
Os FPGAs s˜ao dispositivos eletroˆnicos constitu´ıdos de blocos l´ogicos reconﬁgura´veis interligados por circuitos de chaveamento. Estes blocos l´ogicos s˜ao programados para realizar fun¸co˜es espec´ıﬁcas, de acordo com as necessidades de cada projeto, como ocorre em qualquer outro tipo de circuito dedicado. FPGAs foram idealmente desenvolvidos visando aplica¸c˜oes de prototipa¸ca˜o. O baixo custo e o resumido tempo de implementa¸ca˜o de soluc¸˜oes para aplica¸co˜es trazem grandes vantagens sobre a t´ecnica tradicional, ja´ que altera¸c˜oes podem ser feitas rapidamente e sem custos adicionais em caso de se encontrar erros ou se houver necessidade de quaisquer outras modiﬁca¸co˜es no projeto.
3.2 Arquitetura
Um FPGA ´e composto basicamente por trˆes tipos de componentes:
Blocos de entrada e sa´ıda (IOB) - Sa˜o circuitos respons´aveis pelo interfaceamento das sa´ıdas provenientes das sa´ıdas das combinac¸˜oes de blocos l´ogicos conﬁgura´veis. Sa˜o basicamente buﬀers, que funcionar˜ao como um pino bidirecional entrada e sa´ıda do FPGA.
23

Figura 3.1: Imagem de uma placa com um FPGA Ciclone R II integrado
Blocos lo´gicos conﬁgur´aveis (CLB) - Sa˜o circuitos idˆenticos, constru´ıdos pela reunia˜o de ﬂip-ﬂops (entre 2 e 4) e a utilizac¸˜ao de lo´gica combinacional. Utilizando os CLBs, um usua´rio pode construir elementos funcionais lo´gicos.
Chaves de interconex˜ao (Switch Matrix) - Sa˜o as trilhas utilizadas para conectar os CLBS e IOBS. Os recursos de interconexo˜es possuem trilhas para conectar as entradas e sa´ıdas dos CLBs e IOBs para as redes apropriadas. Geralmente, a conﬁgurac¸˜ao ´e estabelecida por programa¸ca˜o interna das c´elulas de memo´ria esta´tica, que determinam func¸˜oes lo´gicas e conexo˜es internas implementadas no FPGA entre os CLBs e os IOBs. O processo de escolha das interconex˜oes ´e chamado de roteamento.
Os blocos l´ogicos sa˜o dispostos de forma bidimensional; as chaves de interconexa˜o sa˜o dispostas em formas de trilhas verticais e horizontais entre as linhas e as colunas dos blocos lo´gicos.
3.3 Implementa¸c˜ao da FFT em um FPGA
A FFT ´e uma implementa¸ca˜o da Transformada Discreta de Fourier, a DFT. A transformada de Fourier F [n] × x, de um vetor de N nu´meros complexos x = (x[0], ..., x[N − 1]), corresponde ao vetor de tamanho N dado por X = (X[0], ..., X[N − 1]), como foi explicado no Cap´ıtulo 2, Equa¸c˜ao 2.4.
Segundo [11], no processo de ana´lise e s´ıntese de sinais complexos, para que um sinal seja reconstru´ıdo de forma idˆentica ao sinal original, o fator 1/N tem que ser aplicado em algum momento do processo. Em [11], esse fator ´e aplicado
24

na f´ormula de ana´lise. Em [3], este fator na˜o est´a presente na f´ormula de ana´lise apresentada, para que seja aplicado no processo de s´ıntese. Nos Cap´ıtulos 3 e 5, consideraremos a Equa¸c˜ao 3.1 apresentada em [3].

N −1

X[k] = ·

x[j

]

·

ei

2πjk N

para

k

= 0, 1, · · ·

,N

−1

j=0

(3.1)

Segundo [3], a implementac¸˜ao dessa transformada em um dispositivo reconﬁgura´vel pode ser feita atrav´es da modelagem de uma arquitetura que executa opera¸co˜es de adi¸ca˜o, subtra¸ca˜o e multiplicac¸˜ao, conforme mostrado na Figura 3.2. Essa arquitetura possui va´rios componentes, a saber:

• duas portas de entrada (P 1 e P 2); • dois registradores (Ar1 e Ar2); • uma constante (C1); • dois operadores (Op1 e Op2); • um registrador (R1); e • um registrador (R2).

O nu´mero de circuitos necess´arios depende do tamanho do vetor ao qual ser´a aplicado o c´alculo. Se tivermos um vetor de tamanho N , s˜ao necessa´rios N circuitos.

R2 Op2
R1 Ar1
Op1

C1 Ar2

P1 P2
Figura 3.2: Arquitetura de um n´o do circuito da FFT em um FPGA
O ca´lculo da FFT ´e feito com uma primeira conﬁgura¸c˜ao e mais trˆes reconﬁgura¸co˜es da arquitetura. Essa conﬁgura¸c˜oes s˜ao indicadas pelos registradores
25

Ar1 e Ar2; pelos operadores Op1 e Op2; e pela constante C1. Os registradores Ar1 e Ar2 indicam o que sera´ carregado nas portas de entradas. Caso a op¸c˜ao seja I, sera˜o carregados na porta de entrada os coeﬁcientes de um polinˆomio, ja´ na ordem adequada para a execu¸ca˜o do algoritmo. Caso n˜ao seja I, sera´ carregado na porta, um nu´mero que indicara´ o registrador R2 de algum dos circuitos. Os operadores Op1 e Op2 indicam qual opera¸ca˜o ser´a realizada pelo circuito. A primeira opera¸ca˜o ´e feita entre as duas portas de entrada, P 1 e P 2. A segunda opera¸ca˜o ´e feita entre o resultado da primeira opera¸ca˜o, em R1, e a constante C1. Os dois operadores Op1 e Op2 podem ser reconﬁgurados para quaisquer opera¸co˜es sobre nu´meros complexos. Para a FFT, usamos apenas as operac¸˜oes de adic¸˜ao, subtra¸ca˜o e multiplica¸c˜ao.
3.3.1 Algoritmo Implementado
ab 00
ab 41
ab 22
ab 63
ab 14
ab 55
ab 36
ab 77
Figura 3.3: Circuito da FFT para N entradas
A Figura 3.3 mostra uma esquematiza¸c˜ao sobre a implementa¸ca˜o do circuito que realiza o c´alculo da FFT. Na ﬁgura, cada ponto representa um no´ do circuito. Cada no´, armazena um valor. A passagem de uma coluna para outra representa uma reconﬁgura¸ca˜o. Assim, o valor armazenado no no´, passa a ser a combina¸ca˜o de dois no´s da coluna anterior. As linhas indicam quais n´os sera˜o combinados por operac¸˜oes aritm´eticas, para gerar o resultado armazenado na pro´xima coluna.
26

No circuito, os registradores Ar1 e Ar2 s˜ao designados para fazer as indica¸co˜es representadas pelas linhas.
No primeiro momento, os registradores Ar1 e Ar2 selecionam o que ser´a carregado nas portas P 1 e P 2; no caso desta implementa¸c˜ao, selecionam como entrada os coeﬁcientes de um polinˆomio, ou seja, os valores discretos que esta˜o no dom´ınio de tempo que sera´ decomposto (a0 a a7). Por isso, Ar1 e Ar2 apresentam a opc¸˜ao I. Os valores externos de entrada, ja´ esta˜o na ordem desejada apo´s a decomposi¸ca˜o feita atrav´es da reversa˜o de bit, conforme explicado na Se¸c˜ao 2.3.1. Dessa forma, conforme podemos ver na Figura 3.3, cada no´ recebe na conﬁgura¸ca˜o inicial um valor discreto ja´ permutado e um zero, para que ao ﬁnal da primeira conﬁgura¸ca˜o, os valores externos de entrada estejam armazenados em R2. Assim, cada no´ fara´ a adi¸ca˜o entre um coeﬁciente e um zero, cujo resultado ser´a armazenado em R1. Na segunda operac¸˜ao, ´e feita a multiplicac¸˜ao entre R1 e 1; o resultado ´e armazenado em R2. A Tabela 3.1 apresenta os paraˆmetros da conﬁgura¸ca˜o inicial dos no´s.
0: I, I, +, 1, x 1: I, I, +, 1, x 2: I, I, +, 1, x 3: I, I, +, 1, x 4: I, I, +, 1, x 5: I, I, +, 1, x 6: I, I, +, 1, x 7: I, I, +, 1, x
Tabela 3.1: Paraˆmetros da conﬁgurac¸˜ao inicial dos no´s da FFT para N = 8
Dessa forma, ao ﬁnal dessa etapa, teremos armazenado em cada R2 de cada no´, os seguintes valores de X[k]:
X[0] x[0] X[1] x[4] X[2] x[2] X[3] x[6] X[4] x[1] X[5] x[5] X[6] x[3] X[7] x[7]
Nesse momento, a execu¸ca˜o ´e interrompida para que os parˆametros da segunda reconﬁgura¸ca˜o sejam carregados de acordo com a Tabela 3.2. De acordo com esta tabela, cada n´o receber´a como entrada o valor armazenado no registrador R2 da etapa anterior. Assim, na primeira reconﬁgura¸ca˜o, s˜ao apresentados dados externos para os registradores de entrada P 1 e P 2. Nas reconﬁgura¸co˜es subsequentes, as portas de entrada sa˜o carregadas com os valores armazenados em R2 na reconﬁgura¸ca˜o anterior. No caso espec´ıﬁco sob estudo, as ordens, opera¸co˜es e constantes de cada reconﬁgura¸ca˜o sa˜o apresentadas nas Tabelas 3.1, 3.2, 3.3 e 3.4. As constantes carregadas em C1 s˜ao geradas a partir das ra´ızes complexas.
Tendo como entrada o vetor x[j] com j = 1 . . . N − 1, temos como sa´ıda no dom´ınio de frequˆencias o vetor X[k], com k = 1 . . . N − 1, apresentado na Tabela 3.5.
27

0: 0, 1, +, 1, x 1: 0, 1, -, 1, x 2: 2, 3, +, 1, x 3: 2, 3, -, i, x 4: 4, 5, +, 1, x 5: 4, 5, -, 1, x 6: 6, 7, +, 1, x 7: 6, 7, -, i, x

Tabela 3.2: Paraˆmetros da segunda reconﬁgura¸ca˜o dos No´s da FFT para N = 8

0: 0, 2, +, 1, x 1: 1, 3, +, 1, x 2: 0, 2, -, 1, x 3: 1, 3, -, 1, x 4: 4, 6, +, 1, x 5: 5, 7, +, 1√+i , x 6: 4, 6, -, i, x 7: 5, 7, -, −√1+i , x
22
Tabela 3.3: Paraˆmetros da terceira reconﬁgura¸ca˜o dos No´s da FFT para N = 8

0: 0, 4, +, 1, x 1: 1, 5, +, 1, x 2: 2, 6, +, 1, x 3: 3, 7, +, 1, x 4: 0, 4, -, 1, x 5: 1, 5, -, 1, x 6: 2, 6, -, 1, x 7: 3, 7, -, 1, x

Tabela 3.4: Paraˆmetros da quarta reconﬁgura¸ca˜o dos No´s da FFT para N = 8

X [0]

(x[0] + x[4]) + (x[2] + x[6]) + (x[1] + x[5]) + (x[3] + x[7])

X[1] (x[0] − x[4]) + (x[2] − x[6])i + ((x[1] − x[5]) + (x[3] − x[7])i) 1√+i 2

X [2]

(x[0] + x[4]) − (x[2] + x[6]) + ((x[1] + x[5]) − (x[3] + x[7]))i

X[3] (x[0] − x[4]) − (x[2] − x[6])i + ((x[1] − x[5]) − (x[3] − x[7])i) −√1+i 2

X [4]

(x[0] + x[4]) + (x[2] + x[6]) − (x[1] + x[5]) + (x[3] + x[7])

X[5] (x[0] − x[4]) + (x[2] − x[6])i − ((x[1] − x[5]) + (x[3] − x[7])i) 1√+i 2

X [6]

(x[0] + x[4]) − (x[2] + x[6]) − ((x[1] + x[5]) − (x[3] + x[7]))i

X[7] (x[0] − x[4]) − (x[2] − x[6])i − ((x[1] − x[5]) − (x[3] + x[7])i) −√1+i 2

Tabela 3.5: Sa´ıda da FFT para N = 8

Como estamos tratando nu´meros complexos, a parte real de cada entrada,

corresponde `a parte real do dom´ınio de tempo e a parte real de cada valor de sa´ıda

corresponde `a parte real do dom´ınio de frequˆencias. Da mesma forma, a parte

imagina´ria de cada entrada corresponde `a parte imagina´ria do dom´ınio de tempo e

a parte imagina´ria dos valores de sa´ıda corresponde a` parte imagina´ria do dom´ınio

de frequˆencias. Quando usamos apenas nu´meros reais, a parte imagina´ria do vetor

de entrada ´e nulo. O mesmo n˜ao ocorre com a parte imagina´ria do dom´ınio de

frequˆencias, j´a que este vetor corresponde a`s ondas seno que pertencem ao sinal

de entrada. Nesse caso de nu´mero reais de entrada, levamos em considera¸ca˜o

apenas

os

N 2

+1

valores

do

dom´ınio

de

frequˆencia.

3.3.2 Exemplo
Nesta se¸ca˜o, apresentaremos a aplicac¸˜ao do m´etodo para analisar o dom´ınio de tempo x[] escolhido de forma aleato´ria, contido na Tabela 3.6, ou seja, calcularemos X[] usando as reconﬁgura¸co˜es do FPGA.

No primeiro instante, ´e necess´ario fazer a permutac¸˜ao por revers˜ao de bits para que os registradores Ar1 e Ar2 possam selecionar a entrada externa na ordem correta, ap´os a decomposi¸ca˜o do dom´ınio de tempo x[]. Apresentamos a reversa˜o de bits dos ´ındices das amostras de entrada de 0 a 7, na Tabela 3.7.
28

Dom´ınio de Tempo x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7] Amplitude (3, 0) (7, 0) (9, 0) (10, 0) (8, 0) (4, 0) (2, 0) (1, 0)
Tabela 3.6: Valores do dom´ınio de tempo usado no exemplo de FFT.

´Indice de Entrada x[0] x[1] x[2] x[3] x[4] x[5] x[6] x[7]

Bina´rio 000 001 010 011 100 101 110 111

Reversa˜o 000 100 010 110 001 101 011 111

´Indice de Sa´ıda x[0] x[4] x[2] x[6] x[1] x[5] x[3] x[7]

Tabela 3.7: Reversa˜o dos bits no exemplo da FFT.

Dessa forma, temos a nova sequˆencia das nossas amostras discretas e apo´s a primeira reconﬁgura¸c˜ao, temos armazenado em cada registrador R2 de cada n´o X[j] para j = 0 · · · 7 os valores apresentados na Tabela 3.8.

X[0] = (X[0] + 0) · 1 X[0] = ((3, 0) + (0, 0)) · (1, 0) X[0] = (3, 0)
X[2] = (X[2] + 0) · 1 X[2] = ((9, 0) + (0, 0)) · (1, 0) X[2] = (9, 0)
X[4] = (X[1] + 0) · 1 X[4] = ((7, 0) + (0, 0)) · (1, 0) X[4] = (7, 0)
X[6] = (X[3] + 0) · 1 X[6] = ((10, 0) + (0, 0)) · (1, 0) X[6] = (10, 0)

X[1] = (X[4] + 0) · 1 X[1] = ((8, 0) + (0, 0)) · (1, 0) X[1] = (8, 0)
X[3] = (X[6] + 0) · 1 X[3] = ((2, 0) + (0, 0)) · (1, 0) X[3] = (2, 0)
X[5] = (X[5] + 0) · 1 X[5] = ((4, 0) + (0, 0)) · (1, 0) X[5] = (4, 0)
X[7] = (X[7] + 0) · 1 X[7] = ((1, 0) + (0, 0)) · (1, 0) X[7] = (1, 0)

Tabela 3.8: Valores da FFT ap´os a primeira reconﬁgura¸c˜ao

Como pode ser observado, ´e preciso trabalhar com nu´meros complexos, apesar do exemplo possuir apenas a parte real n˜ao nula. Ap´os a segunda reconﬁgura¸ca˜o, seguindo corretamente os parˆametros, obtemos os valores dados na Tabela 3.9.

29

X[0] = (X[0] + X[1]) · 1 X[0] = ((3, 0) + (8, 0)) · (1, 0) X[0] = (11, 0)
X[2] = (X[2] + X[3]) · 1 X[2] = ((9, 0) + (2, 0)) · (1, 0) X[2] = (11, 0)
X[4] = (X[4] + X[5]) · 1 X[4] = ((7, 0) + (4, 0)) · (1, 0) X[4] = (11, 0)
X[6] = (X[6] + X[7]) · 1 X[6] = ((10, 0) + (1, 0)) · (1, 0) X[6] = (11, 0)

X[1] = (X[0] − X[1]) · 1 X[1] = ((3, 0) − (8, 0)) · (1, 0) X[1] = (−5, 0)
X[3] = (X[2] − X[3]) · i X[3] = ((9, 0) − (2, 0)) · (0, 1) X[3] = (0, 7)
X[5] = (X[4] − X[5]) · 1 X[5] = ((7, 0) − (4, 0)) · (1, 0) X[5] = (3, 0)
X[7] = (X[6] − X[7]) · i X[7] = ((10, 0) − (1, 0)) · (0, 1) X[7] = (0, 9)

Tabela 3.9: Valores da FFT ap´os a segunda reconﬁgura¸c˜ao

X[0] = (X[0] + X[2]) · 1 X[0] = ((11, 0) + (11, 0)) · (1, 0) X[0] = (22, 0) X[2] = (X[0] − X[2]) · 1 X[2] = ((11, 0) − (11, 0)) · (1, 0) X[2] = (0, 0) X[4] = (X[4] + X[6]) · 1 X[4] = ((11, 0) + (11, 0)) · (1, 0)
X[4] = (22, 0) X[6] = (X[4] − X[6]) · i X[6] = ((11, 0) − (11, 0)) · (0, 1)
X[6] = (0, 0)

X[1] = (X[1] + X[3]) · 1

X[1] = ((−5, 0) + (0, 7)) · (1, 0)

X[1] = (−5, 7)

X[3] = (X[1] − X[3]) · 1

X[3] = ((−5, 0) − (0, 7)) · (0, 1) X[3] = (−5, −7)

X[5] = (X[5] + X[7]) · 1√+i

2

X [5]

=

((3,

0)√+

(0,

9√))

·

( √1 , 2

√1 ) 2

X[5] = (−3 · 2, 6 · 2)

X[7] = (X[5] − X[7]) · −√1+i

2

X [7]

=

((3,√0)

−

(0√, 9))

·

( √−1 , 2

√1 ) 2

X[7] = (3 · 2, 6 · 2)

Tabela 3.10: Valores da FFT ap´os a terceira reconﬁgura¸c˜ao

Apo´s a terceira reconﬁgura¸ca˜o, temos os seguintes resultados apresentados na Tabela 3.10.

E ﬁnalmente, apo´s a quarta reconﬁgurac¸˜ao, chegamos ao resultado ﬁnal de nossa Transformada Ra´pida de Fourier, apresentado na Tabela 3.11.
Apo´s as quatro reconﬁgura¸co˜es, obt´em-se o resultado da transformada desejada. Como o algoritmo foi desenvolvido para ser aplicado em um dispositivo reconﬁgura´vel, houve uma certa complexidade nos ca´lculos feitos `a ma˜o. E´ poss´ıvel perceber, por´em, que esse algoritmo, aplicado em um dispositivo reconﬁgur´avel conforme foi desenvolvido, ´e um eﬁciente m´etodo para se calcular a Transformada
30

X[0] = (X[0] + X[4]) · 1 X[0] = ((22, 0) + (22, 0)) · (1, 0) X[0] = (44, 0) X[2] = (X[2] + X[6]) · 1 X[2] = ((0, 0) + (0, 0)) · (1, 0) X[2] = (0, 0) X[4] = (X[0] − X[4]) · 1 X[4] = ((22, 0) − (22, 0)) · (1, 0) X[4] = (0, 0) X[6] = (X[2] − X[6]) · 1 X[6] = ((0, 0) − (0, 0)) · (1, 0) X[6] = (0, 0)

X[1] = (X[1] + X[5]) · 1√ √ X[1] = ((−5, 7) +√(−3 · 2, 6√· 2)) · (1, 0) X[1] = (−5 − 3 · 2, 7 + 6 · 2) X[3] = (X[3] + X[7]) · 1√ √ X[3] = ((−5, −7)√+ (3 · 2, 6 ·√ 2)) · (1, 0) X[3] = (−5 + 3 · 2, −7 + 6 · 2) X[5] = (X[1] − X[5]) · 1√ √ X[5] = ((−5, 7) −√(−3 · 2, 6√· 2)) · (1, 0) X[5] = (−5 + 3 · 2, 7 − 6 · 2) X[7] = (X[3] − X[7]) · 1√ √ X[7] = ((−5, −7)√− (3 · 2, 6 ·√ 2)) · (1, 0) X[7] = (−5 − 3 · 2, −7 − 6 · 2)

Tabela 3.11: Valores da FFT ap´os a quarta reconﬁgurac¸˜ao

de Fourier de um sinal discreto, por usar o m´etodo da Transformada R´apida de Fourier e tamb´em por haver a reutiliza¸ca˜o de vari´aveis armazenadas em registradores.

31

Cap´ıtulo 4
L´ogica Temporal Proposicional
A l´ogica temporal linear proposicional (PTL, do inglˆes Propositional Temporal Logic), que apresentaremos neste cap´ıtulo, tem por ﬁnalidade expressar fatos, levando em considera¸ca˜o o tempo em que estes fatos ocorrem.
4.1 Sintaxe
A sintaxe de uma linguagem formal determina as regras de forma¸ca˜o de senten¸cas de tal linguagem. No caso da linguagem da l´ogica temporal proposicional, al´em dos elementos da linguagem cla´ssica proposicional (s´ımbolos proposicionais, constantes, nega¸ca˜o, conjun¸c˜ao, disjun¸ca˜o, implicac¸˜ao e bi-implicac¸˜ao), temos tamb´em um conjunto de novos operadores para expressar as rela¸co˜es no tempo. Para a apresenta¸ca˜o da linguagem, primeiramente deﬁniremos o conjunto de s´ımbolos que podem ser empregados na constru¸ca˜o de senten¸cas.
Deﬁni¸c˜ao 1 A linguagem da PTL ´e composta por um conjunto enumer´avel de s´ımbolos:
• um conjunto enumer´avel, P = {p, q, . . . , p0, q0, . . . , p1, q1, . . .}, de s´ımbolos proposicionais;
• conectivos: ¬ (nega¸c˜ao), ∧ (conjun¸c˜ao), ∨ (disjun¸c˜ao), → (implica¸c˜ao) e ↔ (bi-implica¸c˜ao);
• conectivos nul´arios (ou constantes): true e false; • operadores modais: (alguma vez no futuro), (sempre no futuro), h
(no pr´oximo momento no futuro), U (at´e que), W (a n˜ao ser que).
Utilizando os s´ımbolos acima deﬁnidos, podemos expressar fatos mais complexos do que aqueles expressos pela Linguagem Proposicional. Por exemplo, se quis´essemos que expressar o fato dado pela orac¸˜ao:
“Joa˜o toca viol˜ao, at´e que arrebente a corda”
32

na logica proposicional, as informac¸˜oes sobre a sequˆencia em que estes fatos ocorrem ﬁcaria impl´ıcita na fo´rmula lo´gica. No entanto, podemos utilizar a linguagem proposicional cl´assica para representar os fatos. Seguindo o exemplo, poder´ıamos representar por p o fato de que Joa˜o toca viola˜o; e por q o fato de arrebentar a corda. Com o aux´ılio dos operadores modais da linguagem temporal, o fato expresso no exemplo acima poderia ser escrito como:
p U q.
A deﬁnic¸˜ao abaixo nos diz exatamente quais sa˜o as sentenc¸as que podemos escrever na linguagem lo´gica temporal:
Deﬁni¸c˜ao 2 Uma f´ormula na PTL e bem-formada (F BFP TL) se as seguintes condi¸c˜oes s˜ao satisfeitas:
• os conectivos nul´arios pertencem a F BFP T L;
• p ∈ P, ent˜ao p ∈ F BFP T L;
• se φ e ψ pertencem a F BFP TL, ent˜ao ¬φ, (φ ∧ ψ), (φ ∨ ψ), (φ → ψ), (φ ↔ ψ), φ, φ, hφ, φ W ψ, φ U ψ pertencem `a F BFP T L.
Observe que na deﬁni¸c˜ao acima, “φ” e “ψ” s˜ao utilizados como s´ımbolos metalingu´ısticos, denotando quaisquer fo´rmulas da linguagem. N´os poder´ıamos restringir o nu´mero de conectivos, usando somente os operadores ¬, ∧, h, U , utilizando as seguintes abreviac¸˜oes: φ = true U ψ, φ = φ U false e φ W ψ = (φ W ψ) ∨ φ.
4.2 Semˆantica
Um modelo de PTL ´e representado por uma sequˆencia de estados que chamamos de mundos:
σ = S1, S2, S3, . . .
Cada estado (ou mundo) ´e caracterizado por um conjunto de literais, correspondendo, portanto, a uma valora¸ca˜o proposicional. Por exemplo, seja σ o modelo apresentado na Figura 4.1. O modelo σ mostra trˆes primeiros mundos, isto ´e, trˆes primeiros instantes distintos que s˜ao representados pela sequˆencia de estados σ = S1, S2, S3, . . . Temos uma fun¸ca˜o que atribui valores booleanos, {V, F }, aos s´ımbolos proposicionais dentro desses mundos; essa func¸˜ao ´e π(mundo), onde mundo deve ser substitu´ıdo pelo ro´tulo do mundo. Caracterizamos, formalmente, os mundos do modelo acima atrav´es de suas valora¸co˜es:
π(S1)(p) = V, π(S1)(q) = V π(S2)(p) = V, π(S2)(q) = F π(S3)(p) = V, π(S3)(q) = F
π(S3)(r) = V
33

'$ '$ '$

pq

- p ¬q

- p ¬q r

-

&% &% &%

...

Figura 4.1: Uma sequˆencia de estados temporais
Segundo a atribui¸ca˜o de valores de verdade dada pela func¸˜ao π em σ temos que p ´e verdadeiro em todos os mundos e q ´e satisfeito apenas em S1. Outra forma de representar a valora¸ca˜o de f´ormulas proposicionais nos mundos ´e atraves da no¸ca˜o de satisfa¸ca˜o, denotada por “|=”. Considerando o exemplo, escrever´ıamos (σ, 2) |= p para dizer que o estado de ´ındice 2 satisfaz p. Observe que a rela¸ca˜o de satisfatibilidade ´e entre um par ordenado, contendo o modelo e o ´ındice do estado sobre o qual estamos falando, e uma fo´rmula. Ao escrevermos σ |= φ, onde φ ∈ F BFP TL, queremos dizer que φ ´e satisfeita pelo estado inicial do modelo σ. A nota¸ca˜o |= φ, onde φ ∈ F BFP TL, diz que φ ´e satisfeita pelo estado inicial de todos os modelos, ou seja, que φ ´e va´lida.
A caracteriza¸ca˜o formal da semˆantica ´e dada a seguir.
Deﬁni¸c˜ao 3 Seja φ e ψ pertencentes `a F BFP TL, σ um modelo, π uma fun¸c˜ao de valorac˜ao e i ∈ N um ´ındice pertencente ao modelo.
• (σ, i) |= true;
• (σ, i) |= false;
• (σ, i) |= p se, e somente se, π(Si)(p) = V, onde p ∈ P;
• (σ, i) |= ¬φ se, e somente se, (σ, i) |= φ;
• (σ, i) |= (φ ∧ ψ) se, e somente se, (σ, i) |= φ e (σ, i) |= ψ;
• (σ, i) |= (φ ∨ ψ) se, e somente se, (σ, i) |= φ ou (σ, i) |= ψ;
• (σ, i) |= (φ → ψ) se, e somente se, (σ, i) |= ¬φ ou (σ, i) |= ψ;
• (σ, i) |= (φ ↔ ψ) se, e somente se, (σ, i) |= (φ → ψ) e (σ, i) |= (ψ → φ); • (σ, i) |= hφ se, e somente se, (σ, i + 1) |= φ;
• (σ, i) |= φ se, e somente se, existe um k, k ∈ N, k ≥ i ent˜ao (σ, k) |= φ;
• (σ, i) |= φ se, e somente se, para todo k, k ∈ N, k ≥ i ent˜ao (σ, k) |= φ;
• (σ, i) |= φ U ψ se, e somente se, existe um k, k ∈ N, k ≥ i ent˜ao (σ, k) |= ψ e para todo j, j ∈ N, se i ≤ j < k, ent˜ao (σ, j) |= φ;
• (σ, i) |= φ W ψ se, e somente se, ou (σ, i) |= φ U ψ ou (σ, i) |= φ;
34

4.3 Exemplo de Especiﬁca¸c˜ao
Como apresentado, a lo´gica temporal linear proposicional pode expressar fatos complexos, levando em considerac¸˜ao situa¸c˜oes que envolvem a varia¸ca˜o de tempo. Um caso ilustrativo do emprego da PTL ´e a especiﬁca¸ca˜o do funcionamento de um elevador, pois seu funcionamento depende dos eventos ao longo do tempo, como por exemplo, as instru¸co˜es que recebe dos usua´rios. Nesta se¸c˜ao, iremos apresentar tal especiﬁca¸ca˜o levando em considera¸c˜ao um elevador em um pr´edio de dois andares. O problema a ser caracterizado com o aux´ılio da linguagem lo´gica ´e dado a seguir:
O pr´edio possui dois andares e um t´erreo. Todos os pavimentos possuem um bota˜o de chamada e uma porta de entrada.
Dentro do elevador existem trˆes boto˜es de chamada de andar, um bot˜ao que serve para abrir a porta e outro para fechar. Existe, na porta do elevador, um sensor que detecta se existe algo obstruindo o fechamento da porta.
O elevador se movimenta para cima e para baixo de acordo com o comando recebido. Se o elevador esta´ subindo, ele atende a todas as chamadas naquela dire¸c˜ao, na ordem em que o elevador alcan¸ca o pavimento. O mesmo acontece quando est´a descendo.
Quando o elevador para em um pavimento, a porta ´e aberta. Caso nada esteja obstruindo a porta do elevador, ela se fechara´ ap´os um determinado tempo, ou se o bot˜ao de fechamento de porta for pressionado. Caso algo esteja obstruindo a porta, ela permanecer´a aberta.
Se um bot˜ao de chamada for pressionado para o mesmo andar que o elevador se encontra, a porta ´e aberta. Se o elevador estiver parado, e na˜o houver nenhuma chamada de andar, ou solicitac¸˜ao de abrir a porta, ele permanecera´ parado com a porta fechada. Em movimento, o elevador n˜ao abrira´ a porta, independente do comando recebido.
Para esquematizar o funcionamento desse elevador, foram utilizadas algumas varia´veis proposicionais, descritas a seguir. Dessas varia´veis, existem cinco representam os boto˜es:
b0 (Bota˜o 0) - Bota˜o existente no t´erreo e dentro do elevador. Ele solicita ao elevador para se movimentar para o t´erreo, caso esteja em algum outro pavimento, ou para que abra a porta, caso esteja parado no t´erreo. E´ acionado pelo usua´rio e ´e desligado ao abrir a porta no andar desejado.
b1 (Bota˜o 1) - Bota˜o existente no primeiro andar e dentro do elevador. Ele solicita ao elevador para se movimentar para o primeiro andar, caso esteja em algum outro pavimento, ou para que abra a porta, caso esteja parado no primeiro andar. E´ acionado pelo usu´ario e ´e desligado ao abrir a porta no andar desejado.
35

b2 (Bota˜o 2) - Bot˜ao existente no segundo andar e dentro do elevador. Ele solicita ao elevador para se movimentar para o segundo andar, caso esteja em algum outro pavimento, ou para que abra a porta, caso esteja parado no segundo andar. E´ acionado pelo usua´rio e ´e desligado ao abrir a porta no andar desejado.
a (Bota˜o abre porta) Bot˜ao existente dentro do elevador. Ele executa a abertura da porta caso o elevador esteja parado com a porta fechada.
f (Bota˜o fecha porta) - Bota˜o existente dentro do elevador. Ele executa o fechamento da porta caso esta esteja aberta e nada a esteja obstruindo.
Cinco varia´veis representam a localiza¸c˜ao do elevador:
pav0 (T´erreo) - Indica que o elevador esta´ no t´erreo.
pav1 (Primeiro andar) - Indica que o elevador esta´ no primeiro andar
pav2 (Segundo andar) - Indica que o elevador esta´ no segundo andar
mov1 (Entre o t´erreo e o primeiro andar) - Indica que o elevador est´a se movimentando entre o t´erreo e o primeiro andar.
mov2 (Entre o primeiro e o segundo andar) - Indica que o elevador esta´ se movimentando entre o primeiro andar e o segundo andar.
Trˆes varia´veis referem-se ao status do elevador:
p (Porta) - p indica que a porta do elevador est´a fechada; portanto, ¬p indica que a porta do elevador est´a aberta o que, conforme a descri¸ca˜o do problema, impede que o elevador entre em movimento.
s (Dire¸ca˜o) - s indica que o elevador esta´ subindo; ¬s indica que o elevador esta´ descendo. E´ uma vari´avel que auxilia o controle do elevador a atender todas as chamadas, de acordo com a direc¸˜ao em que esta´ se movimentando.
m (Movimento) m indica que o elevador entrou em movimento e na˜o abriu a porta desde ent˜ao. A negac¸˜ao, ¬m, indica que o elevador atendeu a algum andar e pode se movimentar de novo quando a porta estiver fechada. Essa varia´vel auxilia na especiﬁca¸ca˜o do controle da abertura da porta do elevador.
Existe ainda uma vari´avel que representa o sinal de um sensor de obstru¸ca˜o:
ob (Obstru¸ca˜o) - ob signiﬁca que algo esta´ obstruindo a porta e que ela n˜ao poder´a ser fechada em hipo´tese alguma. ¬ob indica que a porta pode ser fechada.
Por ﬁm, existe uma varia´vel que armazena o sinal de um temporizador:
36

t (Tempo) - t signiﬁca que o tempo de porta aberta se esgotou e solicita que ela seja fechada. ¬t signiﬁca que a porta deve ﬁcar aberta para que os usu´arios possam entrar e sair do elevador.

A partir da descri¸ca˜o do funcionamento do elevador, em acordo com o signiﬁcado j´a designado para cada varia´vel, podemos apresentar uma especiﬁcac¸˜ao na linguagem da lo´gica temporal proposicional. Para cada estado em que o elevador se encontra, existem comandos que fazem com que o elevador tome a¸co˜es diferentes.
Quando o elevador esta´ parado no t´erreo, com a porta fechada, as a¸co˜es do elevador podem ser expressas pelas senten¸cas abaixo:
• (pav0 ∧ p ∧ (m ∨ a ∨ b0) → h(¬p ∧ ¬b0 ∧ ¬m))
• pav0 ∧ p W b0 ∨ b1 ∨ b2 ∨ m ∨ a
• (pav0 ∧ p ∧ (b1 ∨ b2) → h(mov1 ∧ m)
• (pav0 ∧ p → s)
A senten¸ca (pav0 ∧ p → s), por exemplo, diz que sempre que o elevador esteja no t´erreo e a porta ´e fechada, ele ir´a subir. Ja´ as ac¸˜oes do elevador, quando ele est´a no t´erreo e com a porta aberta sa˜o expressas pelas seguintes senten¸cas:

• pav0 ∧ ¬p W ¬ob ∧ (t ∨ f ) • (pav0 ∧ ¬p ∧ (b0 ∨ ob) → h¬p ∧ ¬b0) • (pav0 ∧ ¬p ∧ ¬ob ∧ (t ∨ f ) → hp)

O estado em que o elevador possui a maior possibilidades de a¸c˜oes ´e quando ele est´a parado no primeiro andar com a porta fechada. Isso acontece devido `a possibilidade do elevador, desse estado, poder se dirigir ao t´erreo, ou ao segundo andar. As a¸c˜oes desse estado podem ser expressas atrav´es das sentenc¸as abaixo:
• (pav1 ∧ p ∧ (m ∨ a ∨ b1) → h(¬p ∧ ¬b1 ∧ ¬m))
• pav1 ∧ p W b0 ∨ b1 ∨ b2 ∨ m ∨ a • (pav1 ∧ p ∧ b0 ∧ ¬b2 ∧ s → h(mov1 ∧ m) ∧ ¬s) • (pav1 ∧ p ∧ b2 ∧ ¬b0 ∧ ¬s → h(mov2 ∧ m) ∧ s) • (pav1 ∧ p ∧ b0 ∧ ¬s → h(mov1 ∧ m)) • (pav1 ∧ p ∧ b2 ∧ s → h(mov2 ∧ m))

Os poss´ıveis movimentos do elevador, parado no primeiro andar, com a porta aberta s˜ao expressos por:

• pav1 ∧ ¬p W ¬ob ∧ (t ∨ f )

37

• (pav1 ∧ ¬p ∧ (b1 ∨ ob) → h¬p ∧ ¬b1) • (pav1 ∧ ¬p ∧ ¬ob ∧ (t ∨ f ) → hp) Ja´ as a¸co˜es do segundo andar s˜ao bem parecidos com o t´erreo e podem ser representadas pelas express˜oes abaixo: • (pav2 ∧ p ∧ (m ∨ a ∨ b2) → h(¬p ∧ ¬b2 ∧ ¬m)) • pav2 ∧ p W b0 ∨ b1 ∨ b2 ∨ m ∨ a • (pav2 ∧ p ∧ (b0 ∨ b1) → h(mov2 ∧ m)) • (pav2 ∧ p → ¬s) • pav2 ∧ ¬p W ¬ob ∧ (t ∨ f ) • (pav2 ∧ ¬p ∧ (b2 ∨ ob) → h¬p ∧ ¬b2) • (pav2 ∧ ¬p ∧ ¬ob ∧ (t ∨ f ) → hp) Finalmente, as express˜oes abaixo representam as a¸co˜es do elevador quando este se encontra entre dois andares:
• (mov1 ∨ mov2 → m) • (mov1 ∧ b0 ∧ ¬s → hpav0 ∧ p ∧ s) • (mov1 ∧ b1 ∧ s → hpav1 ∧ p) • (mov1 ∧ b2 ∧ ¬b1 ∧ s → h(mov2 ∧ m)) • (mov2 ∧ b0 ∧ ¬b1 ∧ ¬s → h(mov1) ∧ m) • (mov2 ∧ b1 ∧ ¬s → hpav1 ∧ p) • (mov2 ∧ b2 ∧ s → hpav2 ∧ p ∧ ¬s) Sempre que o elevador se encontra entre os dois andares, a vari´avel m se tornara´ verdadeira. Quando chega a algum andar, a varia´vel m se tornara´ falsa. As f´ormulas que especiﬁcam a chegada do elevador a algum andar sa˜o: • (pav0 ∧ p ∧ (m ∨ a ∨ b0) → h(¬p ∧ ¬b0 ∧ ¬m)) • (pav1 ∧ p ∧ (m ∨ a ∨ b1) → h(¬p ∧ ¬b1 ∧ ¬m)) • (pav2 ∧ p ∧ (m ∨ a ∨ b2) → h(¬p ∧ ¬b2 ∧ ¬m))
38

Estas f´ormulas tamb´em expressam as a¸co˜es do elevador, caso ele esteja parado no andar e receba alguma instru¸c˜ao.
Apesar da simplicidade do exemplo apresentado, ´e poss´ıvel veriﬁcar a ﬁnalidade da linguagem da l´ogica temporal linear proposicional e sua utilidade na expressa˜o de fatos, levando em considera¸c˜ao o tempo em que eles ocorrem.
O exemplo apresenta um caso espec´ıﬁco de um elevador de apenas dois andares. Para a representac¸˜ao de um caso geral, para um elevador de N andares, seria necessa´rio substituir os ´ındices num´ericos por uma vari´avel que representaria todos os andares poss´ıveis. Tamb´em seria necessa´rio usar o operador modal U para expressar todos os poss´ıveis valores para a vari´avel do ´ındice. O uso desse operador, na representa¸ca˜o de um problema, poder´a ser vista no Cap´ıtulo 5. Nele, iremos empregar a linguagem l´ogica proposicional para descrever o ca´lculo da FFT e da sua implementa¸ca˜o em um FPGA.
39

Cap´ıtulo 5
Especiﬁca¸c˜ao da DFT e do Algoritmo da FFT em um Dispositivo Reprogram´avel
Iremos utilizar a lo´gica proposicional temporal para descrever a deﬁni¸ca˜o da Transformada R´apida de Fourier e o algoritmo implementado na FPGA, conforme Se¸co˜es 2.3.1 e 3.3.1. Para as descric¸˜oes, usaremos as seguintes vari´aveis:
x (Vari´avel do Dom´ınio de Tempo) - Corresponde ao vetor x[], que cont´em os valores do sinal de entrada.
X (Vari´avel do Dom´ınio de Frequˆencias) Corresponde ao vetor X[], que armazena as amplitudes do sinal de sa´ıda.
R (Vari´avel Proviso´ria) Corresponde a um vetor que armazena as amplitudes parciais do sinal de sa´ıda que ser´a armazenado em X[].
m (Momento) - Varia´vel de controle do algoritmo, que indica o que deve ser feito de acordo com cada momento.
k (´Indice relativo ao Dom´ınio de Frequˆencias) - Valor que indica a varia´vel de sa´ıda. No algoritmo, ´e uma das responsa´veis por controlar o loop dos somato´rios.
j (´Indice relativo ao Dom´ınio de Tempo) - Valor que indica a vari´avel de entrada. No algoritmo, ´e uma das respons´aveis por controlar o loop dos somat´orios.
N (Nu´mero de pontos no sinal de entrada) - Vari´avel com o nu´mero de pontos no sinal de entrada.
Primeiro, sera´ feita a especiﬁca¸ca˜o da deﬁni¸ca˜o da DFT conforme deﬁnida pela Equa¸ca˜o 3.1. Depois, ser´a apresentada a especiﬁca¸c˜ao da FFT pela sequˆencia de opera¸co˜es e conﬁgura¸co˜es apresentadas na Sec¸˜ao 3.3.
40

5.1 Descri¸c˜ao da Deﬁni¸c˜ao da DFT

No primeiro momento desse algoritmo, ´e necessa´rio zerar cada valor armazenado no vetor X[]. Esse processo pode ser expresso pelas seguintes proposi¸co˜es:

• m0 → ¬m1 ∧ ¬m2 ∧ (k = 0) ∧ (j = 0)

A f´ormula acima indica que se a vari´avel m0 ´e verdadeira, enta˜o as vari´aveis m1 e m2 sa˜o falsas. Isso porque apenas uma dessas varia´veis pode ser verdadeira em cada instante. Quando m0 for verdadeira, k = 0 e j = 0. Na l´ogica proposicional, utilizamos varia´veis lo´gicas para construir as fo´rmulas. Portanto, express˜oes como k = 0, k + 1 na˜o deveriam existir. Mas nessa especiﬁcac¸˜ao, utilizaremos estes termos, para facilitar a visualiza¸ca˜o e compreensa˜o da especiﬁca¸ca˜o.
Seguindo a especiﬁcac¸˜ao, temos:

• (m0 → h(m1 ∧ ¬m0))

Essa fo´rmula expressa que quando a varia´vel m0 ´e verdadeira, no pro´ximo momento ela sera´ falsa e m1 sera´ verdadeira. Assim ﬁca claro que nesse pr´oximo momento temos k = 0 e j = 0, ja´ que no momento anterior m0 era verdadeira.
• (m1 → ((Xk = 0) ∧ h(k + 1) U k ≥ N ))
• (m1 ∧ (k ≥ N ) → h(m2) ∧ h(¬m1) ∧ h(k = 0))

As duas fo´rmulas acima expressam o loop de um somato´rio. Assim, quando m1 ´e verdadeira, caso k seja menor que N , enta˜o Xk sera´ igual a 0. Caso k seja maior ou igual a N , no pro´ximo momento m1 sera´ falsa e m2 sera´ verdadeira.
Em seguida, atrav´es de dois somato´rios, ´e especiﬁcado o c´alculo do valor da DFT para todo k maior ou igual a 0 e menor que N :

•

(m2 ∧ (k < N ) → ((Xk = Rk) ∧

h(Xk

=

Rk

+

x[j]

·

(cos(

2πjk N

)

+

i

sin(

2πjk N

))

∧

h h(j + 1) U j ≥ N ))

• (m2 ∧ (j ≥ N → ( h(j = 0) ∧ h(k + 1) U k ≥ N ))

Na

fo´rmula

acima,

x[j]

·

(cos(

2πj N

k

)

+

i

sin(

2πj N

k

)

representa

a

fo´rmula

da

DFT

pelo m´etodo de Correla¸ca˜o. Ao indicar os valores armazenados em X[], a seguinte

proposi¸ca˜o encerra a especiﬁca¸ca˜o da deﬁni¸ca˜o da DFT.

• (m2 ∧ (k ≥ N ) → h(¬m2))

Atrav´es das proposi¸co˜es acima, todos os passos da deﬁni¸ca˜o da DFT foram especiﬁcados.

41

5.2 Descri¸c˜ao do Algoritmo da Implementa¸c˜ao da FFT
Antes de iniciar as reconﬁgurac¸˜oes que calculam a DFT pelo m´etodo da FFT, ´e necessa´rio um processo para ordena¸ca˜o dos sinais de entrada, conforme explicado na Subsec¸˜ao 2.3.1. Entretanto, no artigo [3] que estamos estudando, n˜ao existe nenhuma rotina na programa¸ca˜o do FPGA, para executar essa ordenac¸˜ao. Como o FPGA foi programado para executar a DFT para um nu´mero deﬁnido de pontos de entrada, no caso 8, enta˜o os sinais de entrada foram atribu´ıdos aos registradores de entrada, ja´ na ordem correta, sem nenhum processo de ordena¸c˜ao. Na descri¸ca˜o desse algoritmo na L´ogica Proposicional Temporal, tamb´em foi omitida uma rotina de ordena¸c˜ao, atribuindo os sinais de entrada `as vari´aveis, na ordem correta para a aplica¸ca˜o do algoritmo.
Para um algoritmo de ordem N , seria necessa´rio implementar um algoritmo para revers˜ao de bits. Para que a especiﬁcac¸˜ao de um algoritmo de ordem N fosse feita, al´em de especiﬁcar o algoritmo de revers˜ao de bits, seria necessa´rio descobrir um padra˜o para os valores armazenados em C1, u´nica constante para a qual na˜o foi considerada uma caracterizac¸˜ao gen´erica. No artigo [3], os valores da constante C1 sa˜o atribu´ıdos ao registrador sem ca´lculo algum. Como no artigo estudado, apresentaremos a especiﬁca¸ca˜o do algoritmo com 8 pontos no dom´ınio de tempo:
• m0 → ¬m1 ∧ ¬m2 ∧ ¬m3 ∧ ¬m4 ∧ ¬m5 ∧ (k = N ) ∧ (R0 = x0) ∧ (R1 = x4) ∧ (R2 = x2) ∧ (R3 = x6) ∧ (R4 = x1) ∧ (R5 = x5) ∧ (R6 = x3) ∧ (R7 = x7)
• ((k ≥ N ) ∧ ¬m5 → h(k = 0) ∧ m5)
Nessa primeira fo´rmula, ´e expresso que quando a varia´vel m0 ´e verdadeira, todas as outras vari´aveis que representam os passos do algoritmo, sa˜o falsas, com exce¸ca˜o de m5. Como m0 representa o primeiro estado do algoritmo, tamb´em ´e expresso que o vetor R[] tem armazenado os pontos do sinal de entrada.
A f´ormula seguinte especiﬁca o que acontece sempre que m5 ´e verdadeira e k ´e menor que N .
• ((m5 → (Xk = Rk) ∧ h(k + 1)) U (k ≥ N ))
Essa fo´rmula expressa que, para k maior ou igual a 0 e menor que N , os valores de Rk esta˜o armazenado em Xk. Isso acontece no in´ıcio do algoritmo e apo´s os ca´lculos de cada reconﬁgura¸ca˜o, quando a varia´vel m5 ´e verdadeira.
Apo´s caracterizar que os valores de Xk sa˜o iguais aos de Rk, as seguintes fo´rmulas expressam qual sera´ o pro´ximo estado.
• (m0 ∧ m5 ∧ (k ≥ N ) → h(m1) ∧ h(¬m0) ∧ h(¬m5))
• (m1 ∧ m5 ∧ (k ≥ N ) → h(m2) ∧ h(¬m1) ∧ h(¬m5))
• (m2 ∧ m5 ∧ (k ≥ N ) → h(m3) ∧ h(¬m2) ∧ h(¬m5))
• (m3 ∧ m5 ∧ (k ≥ N ) → h(¬m3) ∧ h(¬m5))
42

As trˆes primeiras f´ormulas s˜ao semelhantes. Elas expressam que se m5 ´e verdadeira e mx ´e verdadeira, para x entre 0 e 3, no pro´ximo momento mx sera´ falsa e a vari´avel mx+1 sera´ verdadeira. Isso quer dizer que o algoritmo sair´a de uma conﬁgura¸ca˜o, e entrara´ em outra.
A quarta f´ormula ´e (m3 ∧ m5 ∧ (k ≥ N ) → h(¬m3) ∧ h(¬m5)). Ela expressa que apo´s a quarta reconﬁgurac¸˜ao, nada mais acontece. Assim, quando (m3 ∧ m5 ∧ (k ≥ N ) ´e verdadeira, no pro´ximo momento todas as vari´aveis mx, para x igual a 1, 2, 3 ou 5 sera˜o falsas.
As seguintes f´ormulas mostram o que acontece em cada reconﬁgura¸ca˜o:

•

((m1

∧ ¬m5

∧ ¬(k

mod

4

=

3)

→

(Rk

=

Xk 2

·2

+ (−1)k

·

X(

k 2

·2)+1)

∧

h(k +

1)) U k ≥ N )

•

((m1 ∧ ¬m5 ∧ (k

mod

4

=

3)

→

(Rk

=

X

k 2

·2

+

(−1)k

·

X(

k 2

·2)+1)

·

i)

∧

h(k +

1)) U k ≥ N )

Se m1 ´e verdadeira e m5 ´e falsa, o que signiﬁca que estas f´ormulas expressam a

segunda

reconﬁgura¸ca˜o.

A

expressa˜o

X

k 2

·2

+

(−1)k

·

X(

k 2

·2)+1

mostra

qual

opera¸ca˜o

deve ser feita. Caso k mod 4 = 3 enta˜o o resultado da primeira opera¸ca˜o deve ser

multiplicado por i. Caso contra´rio, a expressa˜o ´e multiplicada por 1, que resulta

na pr´opria expressa˜o.

Apo´s especiﬁcar as opera¸co˜es da segunda reconﬁgura¸ca˜o, as fo´rmulas abaixo

expressam o que acontece na terceira reconﬁgura¸ca˜o.

•

((m2

∧

¬m5

∧

(k

<

5)

→

(Rk

=

(−1)

k 2

·

Xk

+

Xk

k)

(−1) 2 ·((−1) 2 ·k+2)

∧

h(k +

1)) U k ≥ N )

•

((m2

∧

¬m5

∧

(k

=

5)

→

(Rk

=

(−1)

k 2

·

Xk

+

Xk

k)

(−1) 2 ·((−1) 2 ·k+2)

·

1√+i ) 2

∧

h(k + 1)) U k ≥ N )

•

((m2

∧ ¬m5

∧ (k

=

6)

→

(Rk

=

(−1)

k 2

· Xk

+ X k k ) · i) ∧ (−1) 2 ·((−1) 2 ·k+2)

h(k + 1)) U k ≥ N )

•

((m2

∧

¬m5

∧ (k

=

7)

→

(Rk

=

(−1)

k 2

· Xk

+X k

k )·

(−1) 2 ·((−1) 2 ·k+2)

−√1+i ) ∧ 2

h(k + 1)) U k ≥ N )

De forma semelhante `a segunda reconﬁgura¸ca˜o, quando m2 ´e verdadeira e m5 ´e

falsa,

o

resultado

das

opera¸co˜es

para

k

<

5

´e

igual

a

(−1)

k 2

·

Xk

+

X (−1)

k 2

k
·((−1) 2

.
·k+2)

No caso de k = 5, k = 6 ou k = 7, o resultado da expressa˜o anterior deve ser

multiplicada por 1√+i , i e −√1+i , respectivamente. 22 A f´ormula seguinte expressa o comportamento do algoritmo na quarta recon-

ﬁgura¸ca˜o:

•

((m3 ∧¬m5

→

(Rk

=

Xk

mod

4

+

(−1)

k 4

· X(k

mod

4)+4 ) ∧

h(k+1)) U k ≥ N )

Assim, sendo m3 verdadeira e m5 falsa, o resultado da FFT ´e igual a Rk =

Xk mod 4

+

(−1)

k 4

·

X(k

mod 4)+4.

A cada reconﬁgurac¸˜ao, quando m5 ´e falsa e k ´e maior ou igual a N , temos

esta u´ltima fo´rmula:

43

• ((¬m5) ∧ (k ≥ N ) → h(m5) ∧ h(k = 0)) que diz que quando m5 ´e falsa e k ´e maior ou igual a N , no pro´ximo momento, m5 ´e verdadeira.
Atrav´es das proposic¸˜oes acima, todos os passos da implementac¸˜ao da FFT foram descritos.
44

Cap´ıtulo 6
Conclus˜ao
O trabalho teve como objetivo especiﬁcar na linguagem da Lo´gica Temporal Proposicional, a deﬁni¸ca˜o da Transformada Discreta de Fourier e a aplicac¸˜ao da mesma pelo m´etodo da Transformada Ra´pida de Fourier, atrav´es de um algoritmo para um dispositivo reprograma´vel.
Assim foi feita uma revisa˜o teo´rica para que fosse poss´ıvel a compreens˜ao de todos os passos at´e a especiﬁca¸c˜ao da deﬁni¸ca˜o e do algoritmo implementado.
Foi apresentado detalhadamente no Cap´ıtulo 2, o que ´e a Transformada de Fourier, para que serve e quais sa˜o os tipos existentes. Assim justiﬁcamos o porquˆe do uso da Transformada Discreta de Fourier na computa¸ca˜o. Apresentamos alguns exemplos de t´ecnicas de se calcular a DFT.
Tamb´em foi explicado no Cap´ıtulo 3 o que ´e um dispositivo reprograma´vel e como funciona. O assunto na˜o foi t˜ao aprofundado, pois n˜ao era necessa´rio para o desenvolvimento do projeto. Dentro d´a a´rea de dispositivos reprogram´aveis, foi abordado o algoritmo que seria especiﬁcado no trabalho.
No Cap´ıtulo 4, foi apresentada a linguagem da L´ogica Temporal Proposicional, utilizada para a descri¸ca˜o da DFT. Para ser mais bem compreendida, foram apresentados e explicados todos os s´ımbolos da linguagem, e explicado a sintaxe e a semˆantica da linguagem. A partir da apresentac¸˜ao da semaˆntica e sintaxe da linguagem, tornou-se vi´avel a especiﬁca¸c˜ao de um sistema usando a L´ogica Temporal Proposicional.
Finalmente, no Cap´ıtulo 5, foi feita a especiﬁca¸ca˜o da deﬁni¸ca˜o da DFT, apresentada pela F´ormula 3.1 e do algoritmo implementado, apresentado na Subse¸ca˜o 3.3.1, ambas na linguagem da Lo´gica Proposicional Temporal.
Nesse trabalho, foi feita uma boa revisa˜o te´orica, com alguns exemplos nos to´picos estudados, possibilitando a compreensa˜o do assunto abordado. Foi gasto um bom tempo na compreensa˜o da DFT, criando um grande interesse em trabalhos na ´area de processamento de sinais. O conhecimento adquirido na especiﬁca¸ca˜o nos mostrou a importaˆncia da L´ogica Temporal Proposicional na especiﬁca¸ca˜o formal de linguagem de hardware e que a linguagem pode ser usada para testar o algoritmo implementado, estudado em [3]. Assim, num trabalho futuro, a veriﬁca¸ca˜o do algoritmo implementado em [3] podera´ ser feita atrav´es dessa linguagem.
45

Referˆencias
[1] Martin Abadi. Temporal-Logic Theorem Proving. PhD thesis, Stanford, CA, March 1987.
[2] William Aspray. John von Neumann and the Origins of Modern Computing. The MIT Press, December 7, 1990.
[3] Mauricio Ayala-Rinc´on, Rodrigo B. Nogueira, Carlos H. Llanos, Ricardo P. Jacobi, and Reiner W. Hartestein. Modeling a reconﬁgurable system for computing the ﬀt in place via rewriting-logic. In IEEE CS Press Proc. 16th Symposium on Integrated Circuits and System Design - SBCCI 03, pages 205–210, Sep 8-11, 2003.
[4] James W. Cooley and Jonh W. Tukey. An algorithm for machine calculation of complex fourier series,. Mathematics Computation, 19:297–301, 1965.
[5] Altera Corporation. Cyclone II Device Family Data Sheet. Altera Corporation, volume 1 edition, Novembro 2004.
[6] Altera Corporation. Getting Started with Altera’s DE2 Board. Altera Corporation, 2005.
[7] Altera Corporation. DE2 Development and Education Board User Manual. Altera Corporation, version 1.3 edition, 2006.
[8] Carlos A. V. Heredia and Francisco Menegat. Matem´atica - Nu´meros Complexos, Polinˆomios e Equa¸c˜oes Alg´ebricas. Renascen¸ca, 5a Edi¸ca˜o (1999).
[9] Thomas Kropf and Hans joachim Wunderlich. A common approach to test generation and hardware veriﬁcation based on temporal logic. Thomas Kropf, Hans-Joachim Wunderlich, University of Karlsruhe, Institute of Computer Design and Fault Tolerance, P.O. Box 6980, 7500 Karlsruhe, Germany, 1991.
[10] Fred Kro¨ger and Stephan Merz. Temporal Logic and State Systems. SpringerVerlag Berlin and Heidelberg GmbH & Co. K, 2008.
[11] Steven W. Smith. The Scientist & Engineer’s Guide to Digital Signal Processing. California Technical Publishing, San Diego, CA, 1st edition (1997).
46

