Polymorphic Bytecode:
Compositional Compilation for Java-like Languages
Davide Ancona
DISI - Universita` di Genova
davide@disi.unige.it
Ferruccio Damiani
Dip. di Informatica - Universita` di Torino
damiani@di.unito.it
Sophia Drossopoulou
Dep. of Computing - Imperial College
sd@doc.ic.ac.uk
Elena Zucca
DISI - Universita` di Genova
zucca@disi.unige.it
ABSTRACT
We define xompositionvl xompilvtion as the ability to type-
check source code fragments in isolation, generate corre-
sponding binaries, and link together fragments whose mu-
tual assumptions are satisfied, without reinspecting the code.
Even though compositional compilation is a highly desirable
feature, in Java-like languages it can hardly be achieved.
This is due to the fact that the bytecode generated for a
fragment (say, a class) is not uniquely determined by its
source code, but also depends on the compilation context.
We propose a way to obtain compositional compilation for
Java, by introducing a polymorphix form of wytexoye contain-
ing type variables (ranging over class names) and equipped
with a set of constraints involving type variables. Thus,
polymorphic bytecode provides a representation for all the
(standard) bytecode that can be obtained by replacing type
variables with classes satisfying the associated constraints.
We illustrate our proposal by developing a typing and a
linking algorithm. The typing algorithm compiles a class
in isolation generating the corresponding polymorphic byte-
code fragment and constraints on the classes it depends
on. The linking algorithm takes a collection of polymor-
phic bytecode fragments, checks their mutual consistency,
and possibly simplifies and specializes them. In particular,
linking a self-contained collection of fragments either fails, or
produces standard bytecode (the same as what would have
been produced by standard compilation of all fragments).
Cutygoriys unx guvjywt Dyswriptors: D.3.3[Programming
languages]: Language constructs and featuresâ€”xlvsses vny
owjexts; D.3.1[Programming languages]: Formal definitions
and theoryâ€”syntvxA semvntixs; D.3.4[Programming languages]:
Processorsâ€”inxrementvl xompilers
Gynyrul hyrms: languages, theory, design
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee.
POPLâ€™05, January 12â€“14, 2005, Long Beach, California, USA.
Copyright 2005 ACM 1-58113-830-X/05/0001 ...$5.00.
Kyyworxs: type systems, compositional analysis
1. INTRODUCTION
Compilers have two main tasks: To check that the source
code adheres to the language rules (which usually means
that it typechecks), and to produce target code.
Originally, compilers would process the complete source
of an application; thus they would apply glowvl xompilvtion.
In strongly typed languages execution of a globally compiled
application is guaranteed to be type safe.
In the 70s, inspired by Parnasâ€™s ideas about abstract data
types, languages like Mesa, LIS, Modula-2, and Ada intro-
duced sepvrvte xompilvtion, whereby an application would
consist of frvgments (e.g., modules, packages, or classes).1
A fragment would be compiled separately in the context of
other, usey fragments. The produced target code fragment
would reflect these used fragments, that is, it would reflect
the compilation environment in which it was created.
An application would be put together through svfe linkB
ing of target fragments; linking of target fragments was legal
only with target fragments which corresponded to the com-
pilation environment in which the former was created. Thus,
linking preserved a correspondence between the compilation
and the execution environment, and the ensuing application
would correspond to a globally compiled one, and have the
same type safety guarantees.
In recent years, Java and Cr have adopted the separate
compilation approach, however combined with yynvmix linkB
ing, whereby fragments (in this case, classes in binary form)
are loaded lazily at run-time. Thus, dynamic linking does
not attempt to preserve a correspondence between the com-
pilation and the execution environment, nor does the en-
suing application correspond to a globally compiled one;
type safety can only be achieved through runtime verifica-
tion checks.
Thus, we argue that in Java (and Cr too) there is a clash
of philosophy between compilation and execution. Namely,
the adoption of separate compilation means that the target
fragments reflect the compilation environment in which they
1Separate compilation should not be confused with inyepenB
yent xompilvtion, introduced by FORTRAN II, which does
not use type information from the used fragments, and thus
does not guarantee type-safety [15].
were created, while the adoption of dynamic linking means
that there is no correspondence between compilation and
execution environment.
For example, compilation of the source method declara-
tion mds:
E m(B x)f return x.f1.f2; g
in an environment âˆ†1 containing class B with field f1 of type
C, and class C with field f2 of type E, generates bytecode mdb1
with annotations which reflect the classes where fields were
found and their types, that is:
E m(B x)f return x[B:f1 C][C:f2 E]; g
On the other hand, compilation of mds in an environment
âˆ†2 containing a class B with a field f1 of type D, and a
class D with a field f2 of type F, for some F subclass of E,
generates a different bytecode mdb2:
E m(B x)f return x[B:f1 D][D:f2 F] g
More importantly, execution of mdb1 in the environment âˆ†2
will throw a FieldNotFoundException, even though compila-
tion and subsequent execution of mds in the environment âˆ†2
would be successful.2
Thus, given the lazy nature of Java dynamic linking, sepa-
rate compilation is, in some sense, too eager, and too context
dependent.
In this paper, we consider, instead, xompositionvl xompiB
lvtion, whereby target fragments do not reflect the compi-
lation environment in which they were created, while link-
ing produces an application which corresponds to a globally
compiled one, and which, therefore, has all its type safety
guarantees.
We define compositional compilation to be the ability
to typecheck source code fragments in isolation, to gener-
ate corresponding binaries, and to link together fragments
whose mutual assumptions are satisfied, without reinspect-
ing the code.
We illustrate a new approach to compilation and linking
for Java-like languages, which will support compositional
compilation. We propose a polymorphix form of wytexoye
containing type vvrivwles (ranging over class names) and
equipped with a set of constraints involving type variables.
Thus, polymorphic bytecode provides a representation for
all the (standard Java) bytecode that can be obtained by
replacing type variables with class names satisfying the as-
sociated constraints.
In terms of our example, mds can be compiled in isola-
tion; the set of polymorphic constraints associated with mds
is f (B; f1; ); (; f2; );   E g, where ,  are type
variables, and a constraint of the shape (e; f; eâ€²) expresses
that type e is expected to declare or inherit a field f of type
eâ€². Furthermore, the following polymorphic bytecode mdb
would be generated:
E m(B x)f return x[B:f1 ][:f2 ]; g
Our approach also supports linking, which checks whether
the polymorphic bytecode of the various fragments satisfies
2This example shows, in a sense, the most simple case of
dependency of generated bytecode on the context; Java fea-
tures such as method overloading and field hiding complicate
matters even further, but the essence of the problem remains
the same.
each otherâ€™s requirements, without inspecting the code it-
self. The process involves the replacement of some type
variables by concrete class names. In our example, linking
mdb in the environment âˆ†1 leads to md
b
1, linking md
b in the
environment âˆ†2 leads to md
b
2.
The rest of the paper is organized as follows. In Section 2
we define a schema formalizing global and compositional
compilation, introduce the notions of soundness and com-
pleteness of compositional compilation w.r.t. global compi-
lation, and give sufficient conditions for guaranteeing them.
These conditions place requirements on the linking process,
and on the relation between global and compositional com-
pilation of one class. In Sections 3 and 4 we instantiate the
schema to model global compilation and compositional com-
pilation for a small Java-like language [9]. In Section 5 we
give an algorithm for linking which satisfies the properties
required by the theorems in Section 2. Finally, in Section 6
we discuss related work and in the Conclusion applicability
of our approach and further work.
A preliminary version of the material from this paper ap-
peared in [1]. Proofs of the main results can be found in an
extended version of this work [2].
2. FORMALIZING COMPILATION
In this section we define a schema formalizing both global
and compositional compilation.
We start by listing the basic syntactic categories and judg-
ments such a type system should define. We use a Java-
oriented terminology, since a significant class of languages
on which the schema could be instantiated are Java-like (in
particular, in the next sections we present an instance which
defines global and compositional compilation for Feather-
weight Java [9]). However, the schema is much more general,
and is appropriate for any language where, roughly speak-
ing, generated binary code is context-dependent. Hence,
â€œclassâ€ below can be thought of, in general terms, as â€œlan-
guage entityâ€.
 Source and binary class declarations (s and b).
 Source fragments (S), which are sequences of source
class declarations; and binary fragments (B), which
are sequences of binary class declarations.
 Class type environments (âˆ†), which are sequences of
class type assignments (). A class type assignment
can be thought of as the type information which can be
extracted from a class declaration (hence the metavari-
ables âˆ† and ); thus a class type environment corre-
sponds to a sequence of source class declarations de-
prived of bodies.
 Global compilation (of a class), âˆ† { g s :  j b, to
be read: The source class declaration s has type  and
compiles to b in the class type environment âˆ†.
 Type constraint environments (Î“), which are sequences
of type constraints (). A type constraint expresses
expectations from used classes, e.g., that a given class
has a field of a given type.
 Compositional compilation (of a class), {w s :  j Î“ j b,
to be read: The source class declaration s has type 
and compiles to b under the type constraints in Î“.
 Linking, âˆ† { Î“ j B  Î“â€² j Bâ€², to be read: In the
class type environment âˆ† the type constraints Î“ are
simplified into Î“â€², and the binary fragment B becomes
Bâ€².
Empty class type environments and empty type constraint
environments will be denoted by Î›.
The ingredients from above model two different approaches
to compilation.
In the first approach, code fragments are compiled in the
context of full type information on other fragments (formal-
ized by the class type environment âˆ†), as shown by the rules
in Fig.1. The global compilation (of a fragment) judgment
âˆ†â€² {G S : âˆ† j B means that in âˆ†
â€² the fragment S has
type âˆ† and compiles to B. Here âˆ†â€² represents (full) type
information related to classes which are not being compiled,
such as libraries. In particular, Î› {G S : âˆ† j B models the
compilation of a self-contained fragment.
(g-frug1)
âˆ†  {g s :  j b
âˆ† {G s :  j b
(g-frug2)
âˆ† âˆ†1 ::: âˆ†iâˆ’1 âˆ†i+1 ::: âˆ†n {G Si : âˆ†i j Bi 8i 2 1::n
âˆ† {G S1 ::: Sn : âˆ†1 ::: âˆ†n j B1 ::: Bn
n  2
Figury E: Glovul wompilution of u frugmynt
In the second approach, code fragments can be compiled
in isolation producing binary code equipped with type con-
straints (both the binary code and the type constraints might
contain type variables denoting yet unknown classes). Then,
it is possible to link together a successfully compiled collec-
tion of fragments, obtaining, if their mutual requirements
are compatible, a new binary fragment with simplified type
constraints. Notice that this check does not depend on the
source code. This is shown by the rules in Fig.2. The com-
positional compilation (of a fragment) judgment { C S :
âˆ† j Î“ j B means that the source fragment S has type âˆ† and
compiles to B under the type constraints in Î“.
(w-frug1)
{w s :  j Î“
â€² j bâ€²
 { Î“â€² j bâ€²  Î“ j b
{C s :  j Î“ j b
(w-frug2)
{C Si : âˆ†i j Î“
â€²
i j B
â€²
i 8i 2 1::n
âˆ†1 ::: âˆ†n { Î“
â€² j Bâ€²  Î“ j B
{C S1 ::: Sn : âˆ†1 ::: âˆ†n j Î“ j B
n  2
(Î“â€²;Bâ€²)=
iâˆˆ1::n
 (Î“â€²i; B
â€²
i)
Figury F: Compositionul wompilution of u frugmynt
In rule (c-frag2), we assume an operator  which, given a se-
quence of (at least two) pairs consisting of a type constraint
environment and a binary fragment, gives a new pair, intu-
itively obtained by combining them avoiding interferences
(typically, this operator will eliminate clashes in type vari-
ables, through -renaming.)
Iterating this process, we will eventually obtain a fragment
for which no type constraints are left, that is, a judgment
{C S : âˆ† j Î› j B. This means that we have obtained a self-
contained fragment. In this case, we expect to have obtained
the same result as global compilation, that is, compositional
compilation to be souny w.r.t. global compilation, and con-
versely, that is, compositional compilation to be xomplete
w.r.t. global compilation. As a first approximation, sound-
ness and completeness could be expressed as follows:
{C S : âˆ† j Î› j B if and only if Î› {G S : âˆ† j B:
However, since compositional compilation is obviously ex-
pected to be incremental, and since global compilation al-
lows for the import of some library classes, whose binary
may be available, but whose source may not be available, the
claim above should be generalized in order to deal with open
source fragments, that is, fragments where some needed class
is missing.
We say that a class type environment âˆ† is xonsistent
(w.r.t. global compilation) if Î› {G S : âˆ† j B for some S,
B.3
Dynition 1. le svy thvt xompositionvl xompilvtion is
sound fiCrCtC glowvl xompilvtion i for xonsistent âˆ†â€² âˆ†:
{C S : âˆ† j Î“ j BA vny âˆ†
â€² âˆ† { Î“ j B Î› j Bâ€²
imply âˆ†â€² {G S : âˆ† j B
â€²:
We now state sufficient conditions for soundness. These
conditions (and analogously those which guarantee com-
pleteness later on) provide a general schema for proving
that compositional compilation is sound (resp. complete).
Indeed, they allow to split the proof in two parts: First,
checking that compositional compilation of a single class is
sound and complete â€” conditions (1) in Theorems 4 and
6. Second, checking that linking satisfies some requirements
of well-behaviour â€” conditions (2) and (3) in Theorems 4
and 6. In particular, conditions (2) are related to vertical
(sequential) composition and conditions (3) to horizontal
composition of linking steps. Conditions (2) require that,
whenever two linking steps in sequence allow to eliminate
all type constraints, and the latter requires more type in-
formation on classes, then starting with this richer type in-
formation the two steps can be combined in just one step;
conversely, given a linking step which allows to eliminate all
type constraints under some type information on classes, if
we start with only partial type information it is always pos-
sible to perform a partial simplification of type constraints.
Conditions (3) require that, whenever a linking step allows
to eliminate a combination of type constraint environments,
it is always possible to eliminate each component, and con-
versely. Finally, condition (4) in Theorem 4 is just a trivial
requirement needed to express soundness for closed frag-
ments as a particular case of soundness.
Note that, in order to prove soundness and completeness,
it is not necessary that linking is well-behaved for vll type
constraint environments, but only for those which can be
obtained through the compilation and linking process. This
is formalized by the following definition:
Dynition 2. Relevant type xonstrvint environments vre
inyuxtively yeney wy the follofiing xlvusesO
 if { w s :  j Î“ j b holys for some s; ; bA then Î“ is
relevvntP
3This definition assumes the fact that libraries used in global
compilation have been obtained by correctly compiling some
code.
 if Î“ is relevvnt vny âˆ† { Î“ j B Î“â€² j Bâ€² holys for some
âˆ†; B; Bâ€²A then Î“â€² is relevvntP
 if Î“1; :::; Î“n vre relevvnt vny (Î“;B)=
iâˆˆ1::n
 (Î“i; Bi) for
some B; B1; :::; BnA then Î“ is relevvntC
Fuwt 3. If {C S : âˆ† j Î“ j B holys for some S; âˆ†; BA then
Î“ is relevvntC
hhyorym 4 (Smffacaefl cgfdalagfk fgr kgmfdfekk).
Compositionvl xompilvtion is souny fiCrCtC glowvl xompilvtion
if the follofiing xonyitions holyO
FC {w s :  j Î“
â€² j bâ€²A vny âˆ†  { Î“â€² j bâ€²  Î› j bA vny
âˆ†  xonsistent imply âˆ†  {g s :  j bC
2C Î“â€²â€² relevvntA âˆ†2 { Î“
â€²â€² j Bâ€²â€²  Î“â€² j Bâ€²A vny âˆ†1âˆ†2 {
Î“â€² j Bâ€²  Î› j B imply âˆ†1 âˆ†2 { Î“
â€²â€² j Bâ€²â€²  Î› j BC
3C âˆ† { Î“ j B Î› j Bâ€²â€²A vny (Î“;B)=
iâˆˆ1::n
 (Î“i; Bi) for some
B1; :::; Bn vny Î“1; :::; Î“n relevvntA implies âˆ† { Î“i j Bi  
Î› j Bâ€²iA for some B
â€²
iA for vll i21::nA vny B
â€²â€² = Bâ€²1 ::: B
â€²
nC
IC Î› { Î› j B Î› j B for vll BC
Dynition 5. le svy thvt xompositionvl xompilvtion is
complete fiCrCtC glowvl xompilvtion i
âˆ†â€² {G S : âˆ† j B
â€² implies 9 B; Î“ sCtC
{C S : âˆ† j Î“ j B vny âˆ†
â€² âˆ† { Î“ j B Î› j Bâ€²C
hhyorym . (Smffacaefl cgfdalagfk fgr cgepdelefekk).
Compositionvl xompilvtion is xomplete fiCrCtC glowvl xompiB
lvtion if the follofiing xonyitions holyO
FC âˆ†  {g s :  j b implies 9 b
â€²; Î“â€² sCtC
{w s :  j Î“
â€² j bâ€² vny âˆ†  { Î“â€² j bâ€²  Î› j bC
2C Î“â€²â€² relevvnt vny âˆ†1 âˆ†2 { Î“
â€²â€² j Bâ€²â€²  Î› j B imply 9 Î“â€²; Bâ€²
sCtC âˆ†2 { Î“
â€²â€² j Bâ€²â€²  Î“â€² j Bâ€² vny âˆ†1 âˆ†2 { Î“
â€² j Bâ€²  
Î› j BC
3C Î“i relevvnt vny âˆ† { Î“i j Bi  Î› j B
â€²
iA for i21::nA fiith
iâˆˆ1::n
 (Î“i; Bi) = (Î“; B)A imply âˆ† { Î“ j B Î› j B
â€²
1 ::: B
â€²
nC
Note that theorems 4 and 6 imply soundness and com-
pleteness for closed fragments. Namely, if we take âˆ†â€² =
Î› = Î“, applying (4) from theorem 4 we get soundness for
closed fragments:
{C S : âˆ† j Î› j B implies Î› {G S : âˆ† j B:
On the other hand, for âˆ†â€² = Î›, if there exist B; Î“ s.t.
{ C S : âˆ† j Î“ j B and âˆ† { Î“ j B  Î› j B
â€², we get
{C S : âˆ† j Î› j B
â€² by applying rule (c-frag2), and hence we
obtain completeness for closed fragments:
Î› {G S : âˆ† j B implies {C S : âˆ† j Î› j B:
3. FJ GLOBAL COMPILATION
In this section, we formalize global compilation of a small
Java-like language. This models both standard type check-
ing for Java-like languages (see, e.g., [9, 16]), as well as
bytecode generation (as already in, e.g., [4, 8]).
The syntax of the (source) language is defined in Fig.3.
It is basically Featherweight Java [9] (FJ in the sequel) hence
a functional subset of Java with no primitive types, except
S ::= s1 : : : sn
s ::= cladd c eieendd câ€² f fds mdss g (c 6= Objece)
fds ::= c1 f1; ::: cn fn;
mdss ::= mds1 ::: md
s
n
mds ::= mh fceeucn es;g
mh ::= c0 m(c1 x1 ::: cn xn)
es ::= x j es:f j es0:m(e
s
1 ::: e
s
n) j
neh c(es1 ::: e
s
n) j (c)e
s
where field, method and parameter names
in fds, mdss and mh are distinct
Figury G: gourwy lunguugy
for the minor difference that here class constructors are im-
plicitly declared. Every class can contain instance field and
method declarations and has only one constructor whose pa-
rameters correspond to all class fields (both inherited and
declared) in the order of declaration. In class declarations
we assume that the name of the class c cannot be Objece.
Method overloading and field hiding are not supported. Ex-
pressions are variables, field access, method invocation, in-
stance creation and casting; the keyword ehid is considered
a special variable. Finally, in order to simplify the presenta-
tion, we assume field names in fds, method names in mdss,
parameter names in mh to be distinct.
In Fig.4 we give the syntax of bytecode generated by
global compilation â€” that is (an abstraction of) standard
Java bytecode.
B ::= b1 ::: bn
b ::= cladd c eieendd câ€² f fds mdsb g
mdsb ::= mdb1 ::: md
b
n
mdb ::= mh fceeucn eb;g
eb ::= x j eb[c:f câ€²] j eb0[c:m(cÂ¯)c
â€²](eb1 ::: e
b
n)
j neh [c cÂ¯](eb1 ::: e
b
n) j (c)e
b
cÂ¯ ::= c1 ::: cn
where fds and mh are defined in Fig.3 and
method names in mdsb are distinct
Figury 4: (Avstruwt) stunxurx vytywoxy
Our notion of bytecode is abstract, since the only differences
between source code and bytecode of interest here are the
annotations needed by the JVM verifier â€” recall that in
Java bytecode a field access is annotated with the static
type of the receiver and the type of the field, a method
invocation with the static type of the receiver, the type of
the parameters and the return type, and an instance creation
with the type of the parameters.
In Fig.5 we define class type assignments. A class type as-
signment collects the type information needed for compiling
other classes which can be extracted from a class declara-
tion; it is a 4-tuple consisting of the name of the class, the
name of the parent class, the set of field signatures (type
and name of declared fields) and the set of method signa-
tures (return type, name and parameter types of declared
methods).
We assume the existence of a function type extracting type
 ::= (c; câ€²; fss; mss)
fss ::= ffs1; : : : ; fsng
fs ::= c f
mss ::= fms1; : : : ; msng
ms ::= c m(cÂ¯)
Figury I: Cluss typy ussignmynts
information from a source class declaration. So we will write
type(fds) and type(mdss) to denote the set of field signatures
and the set of method signatures extracted from the field
declarations fds and from the method declarations mdss, re-
spectively. The straightforward definition of type has been
omitted.
The typing rules defining global compilation of a class are
given in Fig.6. They are standard rules analogous to those
given in other type systems for Java-like languages [9, 8, 4].
We use the following auxiliary judgments:
 âˆ†; c {g mds
s : mdsb, meaning that method declara-
tion(s) mdss in class type environment âˆ† and current
class c (needed for assigning the right type to ehid)
compile(s) to mdsb.
 âˆ†; Î  { g e
s : c j eb, meaning that expression es in
class type environment âˆ† and local type environment
Î  (which maps ehid and method parameters to class
names) has type c and compiles to eb.
In rule (g-class), for compiling a class c in a class type
environment âˆ† we check that âˆ† is well-formed (judgment
{g âˆ†), and compile each method body in âˆ† and current
class c. A class type environment is well-formed if there are
no multiple type assignments for the same class name, the
inheritance relation is acyclic, each extended class is avail-
able, there is no field hiding, the Java rule on overriding is
respected and there is no overloading (the last two condi-
tions correspond to the requirement that a class may not
declare a method with the same name and different return
or parameter types as an inherited method). Note, how-
ever, that a class which is only used as a type may not have
an assignment in âˆ†. This definition of well-formedness ex-
actly models the checks which Java compilers perform on the
needed compilation context.The formal definition of {g âˆ†
can be found in [2].
It is easy to see that the notion of well-formed class type
environment is the concrete version in the FJ case of the gen-
eral notion of consistent class type environment introduced
in Section 2 (see [2] for the details).
In rules for compiling expressions, we use an auxiliary
judgment of the form âˆ† { , meaning that in the class
type environment âˆ† the type constraint  holds. Type con-
straints are listed in Fig.7. They have the following informal
meaning:
 c  câ€² means â€œc is a subtype of câ€²â€.
 9 c means â€œc is definedâ€.
 (c; f; câ€²) means â€œc provides field f with type câ€²â€.
 ::= c  câ€² j 9 c j (c; f; câ€²) j (c; m; cÂ¯; (câ€²; cÂ¯â€²))
j (c; cÂ¯; cÂ¯â€²)
Figury K: hypy wonstruints
 (c; m; cÂ¯; (câ€²; cÂ¯â€²)) means â€œc provides method m appli-
cable to arguments of type cÂ¯, with return type câ€² and
parameters of type cÂ¯â€².
 (c; cÂ¯; cÂ¯â€²) means â€œc provides constructor applicable to
arguments of type cÂ¯, with parameters of type cÂ¯â€²â€.
Note that both the constraints (c; m; cÂ¯; (câ€²; cÂ¯â€²)) and (c; cÂ¯; cÂ¯â€²)
implicitly include the constraint cÂ¯  cÂ¯â€².
The rules defining the judgment âˆ† {  (in Fig.8) are in-
tuitive and almost self-explanatory. In rule =B2), the side
condition f 62 fss means that f is not declared in fss; analo-
gously, in rule =B2), m 62 mss means that m is not declared
in mss. The type constraints in Fig.7 and the rules in Fig.8
are essentially a subset of those defined in [5] (where type
constraints were called local type assumptions).
The rules for the compilation of a class in Fig.6, together
with the general rules for the global compilation of a frag-
ment, given in Fig.1, provide an instantiation to FJ of the
global compilation schema introduced in Section 2.
4. FJ COMPOSITIONAL COMPILATION
In this section we formalize compositional compilation for
the small Java-like language introduced in Section 3. Classes
are compiled in isolation into polymorphic bytecode. That
is, bytecode where the annotations may contain type vari-
ables denoting names of yet unknown classes. The syntax of
polymorphic bytecode is described by the first four produc-
tions in Fig.4 (defining binary fragments, class declarations,
method sequences, and methods, respectively) and by the
productions in Fig.9 (defining binary expressions).
eb ::= x j eb[e:f eâ€²] j eb0[e:m(eÂ¯)e
â€²](eb1 ::: e
b
n)
j neh [c eÂ¯](eb1 ::: e
b
n) j (c)e
b j c; e eb
e ::= c j 
eÂ¯ ::= e1 ::: en
Figury 9: dolymorphiw vytywoxy (yfipryssions)
Besides the presence of type variables, the only difference be-
tween polymorphic and standard bytecode is the presence of
the â€œpolymorphic castingâ€ annotated expression; if the type
variable  is substituted with câ€², then  c;  eb can be
specialized either into eb, if câ€²  c holds (casting-up), or into
(c)eb, if c  câ€² holds (casting-down), or into  c; câ€² eb if
nothing can be said about câ€²  c and c  câ€². For the
â€œpolymorphic castingâ€ annotation we use a different nota-
tion (double angle brackets rather than parentheses) since
this annotation is only allowed in polymorphic bytecode.
Polymorphic bytecode comes with a sequence of polymorB
phix type xonstrvints, which involve type variables and class
names. These are listed in Fig.10. As for polymorphic byte-
code, the meta-variable e denotes either a type variable or a
class name. Besides the presence of type variables, the only
(g-wluss)
{g âˆ†
âˆ†; c {g mds
s : mdsb
âˆ† {g cladd c eieendd câ€² ffds mdssg : (c; câ€²; fss; mss) j cladd c eieendd câ€² ffds mdsbg
type(mdss) = mss
type(fds) = fss
(g-methods)
âˆ†; c {g md
s
i : md
b
i 8i 2 1::n
âˆ†; c {g md
s
1 ::: md
s
n : md
b
1 ::: md
b
n
n 6= 1
(g-method)
âˆ†; x1:c1 ::: xn:cn; ehid:c {g e
s : câ€² j eb
âˆ†; c {g c0 m(c1 x1 ::: cn xn) fceeucn es;g : c0 m(c1 x1 ::: cn xn) fceeucn eb;g
âˆ†{câ€²  c0
âˆ†{9ci 8i 2 0::n
(g-purumeter)
Î {x :c
âˆ†; Î  {g x : c j x
(g-eld uwwess)
âˆ†; Î  {g e
s : c j eb
âˆ†; Î  {g es:f : câ€² j eb[c:f câ€²]
âˆ†{(c; f; câ€²)
(g-meth wull)
âˆ†; Î  {g e
s
0 : c0 j e
b
0
âˆ†; Î  {g e
s
i : ci j e
b
i 8i 2 1::n
âˆ†; Î  {g es0:m(e
s
1; : : : ; e
s
n) : c j e
b
0[c0:m(cÂ¯)c](e
b
0; : : : ; e
b
n)
âˆ†{(c0; m; (c1; : : : ; cn); (c; cÂ¯))
(g-new)
âˆ†; Î  {g e
s
i : ci j e
b
i 8i 2 1::n
âˆ†; Î  {g neh c(es1 ::: e
s
n) : c j neh [c cÂ¯](e
b
1 ::: e
b
n)
âˆ†{(c; c1 ::: cn; cÂ¯)
(g-downwust)
âˆ†; Î  {g e
s : câ€² j eb
âˆ†; Î  {g (c)es : c j (c)eb
âˆ†{c  câ€² (g-upwust)
âˆ†; Î  {g e
s : câ€² j eb
âˆ†; Î  {g (c)es : c j eb
âˆ†{câ€²  c
Figury 6: Glovul wompilution
 ::= e  eâ€² j 9 c j (e; f; eâ€²) j (e; m; eÂ¯; (eâ€²; eÂ¯â€²))
j (c; eÂ¯; eÂ¯â€²) j c  e
Figury ED: dolymorphiw typy wonstruints
difference between the polymorphic type constraints and the
type constrains listed in Fig.7 is the presence of the last con-
straint in Fig.10, whose informal meaning is the following:
 c  e means â€œc and e are comparableâ€ (this constraint
will be generated when compiling a cast).
Polymorphic type constraints not containing type variables
will be called monomorphix type xonstrvints.
The rules defining the judgement for compositional com-
pilation of classes are given in Fig.11. We use the following
auxiliary judgments:
 c {w mds
s : Î“ j mdsb, meaning that method declara-
tion(s) mdss in current class c (needed for assigning the
right type to ehid) compile to mdsb under the poly-
morphic type constraints in Î“.
 Î  {w e
s : e j Î“ j eb, meaning that expression es in lo-
cal type environment Î  (which maps ehid and method
parameters to class names) has type e and compiles to
eb under the polymorphic type constraints in Î“.
The intuition behind the compositional compilation rules is
that they extract the polymorphic type constraints Î“ nec-
essary to compile a given source fragment into a certain
polymorphic binary fragment.
However, note that the rules do not check whether the
inferred collection of constraints Î“ is actually satisfiable; in-
deed, for any fragment it is possible to derive a judgment,
even for those that are not statically correct. Consistency
checks are performed by the rule for the linking judgment
(see below). This approach has the advantage that the typ-
ing rules for separate compilation are very simple and can
be implemented in a straightforward way.
Note also that in the type system a unique judgment can
be derived for any class declaration (the proof is immedi-
ate); therefore, we can easily define a type inferenxe algo-
rithm, that is, an effective way for deducing just from the
single declaration of a class c the type and the (polymor-
phic) bytecode of c, and the required type constraints. This
is not possible for the systems in [4, 5, 3], where one needs
to know the environment where c is compiled.
We now define the linking judgment âˆ† { Î“ j B Î“â€² j Bâ€².
Linking a fragment of polymorphic bytecode B, equipped
with polymorphic type constraints Î“, in a given class type
environment âˆ†, amounts to finding a suitable substitution
 mapping the type variables into class names. The substi-
tution  instantiates some polymorphic type constraints in
Î“ into monomorphic type constraints that hold in âˆ†, and in-
stantiates variables in B correspondingly; these constraints
can be eliminated, leaving only the constraints in Î“â€². In
particular, when all constraints are eliminated, we obtain
a fragment of standard bytecode (like the one produced by
global compilation).
Instantiation of Î“ w.r.t. substitution  is denoted by (Î“);
we have omitted the trivial inductive definition which coin-
cides with conventional variable substitution. Instantiation
of B w.r.t. âˆ† and  is denoted by I.âˆ†(B); âˆ† is needed for
(Î“)
âˆ† {  8 2 Î“
âˆ† { Î“
(âˆƒ)
âˆ†; (c; câ€²; fss; mss) { 9 c
(âˆƒ-cbj)
âˆ† { 9 Objece
(â‰¤-re)
âˆ† { c  c
(â‰¤-truns)
âˆ†; (c1; c2; fss; mss) { c2  c3
âˆ† { c1  c3
(â‰¤-cbj)
âˆ† { c  Objece
(-1)
âˆ†; (c; câ€²; fss; mss) { (c; f; câ€²â€²)
c
â€²â€²
f 2 fss (-2)
âˆ†; (c; câ€²; fss; mss) { (câ€²; f; câ€²â€²)
âˆ†; (c; câ€²; fss; mss) { (c; f; câ€²â€²)
f 62 fss
(-1)
âˆ†; (c; câ€²; fss; mss) { ci  c
â€²â€²
i 8 i 2 1::n
âˆ†; (c; câ€²; fss; mss) { (c; m; c1 ::: cn; (câ€²â€²; câ€²â€²1 ::: c
â€²â€²
n))
c
â€²â€²
m(câ€²â€²1 ::: c
â€²â€²
n) 2 mss
(-2)
âˆ†; (c; câ€²; fss; mss) { (câ€²; m; cÂ¯; (câ€²â€²; cÂ¯â€²â€²))
âˆ†; (c; câ€²; fss; mss) { (c; m; cÂ¯; (câ€²â€²; cÂ¯â€²â€²))
m 62 mss
(-1)
âˆ† { (Objece; ; )
(-2)
âˆ†; (c; câ€²; fss; mss) { (câ€²; câ€²1 ::: c
â€²
k; c1 ::: ck)
âˆ†; (c; câ€²; fss; mss) { câ€²i  ci 8 i 2 k + 1::n
âˆ†; (c; câ€²; fss; mss) { (c; câ€²1 ::: c
â€²
n; c1 ::: cn)
fss = fck+1 fk+1; : : : ; cn fng
Figury L: Entuilmynt juxgymynt âˆ† {  (rulys for thy typy wonstruints in Fig.K)
(âˆ¼-1)
âˆ† { c  câ€²
âˆ† { c  câ€²
(âˆ¼-2)
âˆ† { c  câ€²
âˆ† { câ€²  c
Figury EF: Entuilmynt juxgymynt âˆ† {  (rulys for
thy typy wonstruint c1  c2)
dealing with the case c; e eb:
I.âˆ†(c; e e
b) =8<
:
I.âˆ†(e
b) if (e) = câ€² and âˆ† { câ€²  c
(c)I.âˆ†(e
b) if (e) = câ€² and âˆ† { c  câ€²
c; (e) I.âˆ†(e
b) otherwise.
In all other cases instantiation of polymorphic bytecode cor-
responds to variable substitution.
Remark. Note that the ability of instantiating polymorphic
bytecode into different kinds of standard bytecode instruc-
tions is a key feature for dealing with important issues, such
as resolution of Java syntax ambiguities (see the Conclusion
for an example of such ambiguities) and, in a wider context,
code optimization.
The fact that the monomorphic type constraint  holds in
the class type environment âˆ† is expressed by the judgement
âˆ†{, which is defined by the rules in Fig.8 and in Fig.12.
(w-linking)
{c âˆ†
âˆ† { Î“ !ls  j Î“
â€²
âˆ† { Î“ j B Î“â€² j I.âˆ†(B)
Figury EG: Linking
The linking judgement is defined by rule (c-linking) in
Fig.13, which is parameterized w.r.t. a linkingBsimplixvtion
relvtion !ls . A linking-simplification relation models a par-
ticular way of finding suitable substitutions for simplifying
type constraints w.r.t. class type environments.
The formal definition of {c âˆ† (well-formed type environ-
ments for compositional compilation) can be found in [2].
The judgment {c âˆ† is more liberal than {g âˆ†, since it
allows extended classes to be undefined in âˆ†. Indeed, the
check {g âˆ† in global compilation (rule (g-class)) models
the behaviour of standard Java compilers. On the other
hand, the premise {c âˆ† in rule (c-linking) corresponds to
an intrinsic notion of consistency, and expresses that some
additional constraints on each compiled class c are satis-
fied in âˆ†, that is, that there is no other declaration for c,
that the parent class does not have conflicting field/method
declarations, and that the parent class is not a subtype of
c. These constraints could be equivalently generated dur-
ing compositional compilation of class c, as done in [4, 5,
3]; here we preferred a more compact and efficient formu-
lation. Note that for FJ the check of 9 c constraints could
also be moved to be part of well-formedness of class type en-
vironment, since used classes are always mentioned in field
or method declarations; but this is not true in general, for
instance if we have local variables.
The rules for the compilation of a class in Fig.11 and the
rule for linking in Fig.13, together with the general rules
for the compositional compilation of a fragment, given in
Fig.2, provide an instantiation to FJ of the compositional
compilation schema introduced in Section 2. In this case
the operator  used in rule (c-frag2) in Fig.2 in Section 2
just corresponds to pairwise concatenation of sequences (of
constraints and binary fragments, respectively) with proper
-renaming in order to avoid conflicts of type variables.
Note that all the type variables occurring in a compo-
sitional compilation judgement are (implicitly) universally
quantified. In fact, in a class compilation judgement {
w s :  j Î“ j b, the triple  j Î“ j b represents all the standard
binary class declarations of the form I.âˆ†0 âˆ†(b), for some class
(w-wluss)
c {w mds
s : Î“ j mdsb
{w cladd c eieendd câ€² ffds mdssg : (c; câ€²; fss; mss) j Î“; 9 câ€² j cladd c eieendd câ€² ffds mdsbg
type(mdss) = mss
type(fds) = fss
(w-methods)
c {w md
s
i : Î“i j md
b
i 8i 2 1::n
c {w md
s
1 ::: md
s
n : Î“1 ::: Î“n j md
b
1 ::: md
b
n
n 6= 1
(w-method)
x1:c1 ::: xn:cn; ehid:c {w e
s : e j Î“ j eb
c {w c0 m(c1 x1 ::: cn xn) fceeucn es;g : Î“; e  c0; 9 ciiâˆˆ0::n j c0 m(c1 x1 ::: cn xn) fceeucn eb;g
(w-purumeter)
Î  { x :c
Î  {w x : c j Î› j x
(w-eld uwwess)
Î  {w e
s : e j Î“ j eb
Î  {w es:f :  j Î“; (e; f; ) j eb[e:f ]
 fresh
(w-meth wull)
Î  {w e
s
0 : e0 j Î“0 j e
b
0
Î  {w e
s
i : ei j Î“i j e
b
i 8i 2 1::n
Î  {w es0:m(e
s
1 ::: e
s
n) :  j Î“0Î“1 : : : Î“n; (e0; m; e1 ::: en; (; Â¯)) j eb0[e0:m(Â¯)](e
b
1; : : : ; e
b
n)
,Â¯ fresh
(w-new)
Î  {w e
s
i : ei j Î“i j e
b
i 8i 2 1::n
Î  {w neh c(es1 ::: e
s
n) : c j Î“1 : : : Î“n; (c; e1 ::: en; Â¯) j neh [c Â¯](e
b
1 ::: e
b
n)
Â¯ fresh
(w-wust)
Î  {w e
s : e j Î“ j eb
Î  {w (c)es : c j Î“; c  e j c; e eb
Figury EE: Compositionul wompilution
type environment âˆ†â€² and substitution  such that {c âˆ†
â€² âˆ†
and âˆ†â€² âˆ† { (Î“).
We prove now that, under suitable hypothesis on the linking-
simplification relation, the compositional compilation which
we defined for FJ can be safely used in place of global com-
pilation, that is, is sound and complete w.r.t. global compi-
lation in the sense of Def.1 and Def.5 in Section 2.
We start by stating some properties of entailment which
will be needed in the proof and hold independently of the
linking-simplification relation we choose. Let  and â€² be
two substitutions, that is, finite mappings from type vari-
ables to class names. Then  â€² denotes the unique substi-
tution s.t. ( â€²)(Î“) = (â€²(Î“)) for all Î“; the empty substi-
tution is denoted by . Finally, Î“ n Î“â€² denotes the sequence
of constraints obtained by removing from Î“ all constraints
in Î“â€², while kvrs(Î“) (resp. kvrs(b)) denotes the set of type
variables appearing in Î“ (resp. in b).
droposition 7. If {g âˆ† A âˆ†  { (Î“)A then for vll s; b :
{w s :  j Î“ j b implies âˆ†  {g s :  j I
.
âˆ† (b):
droposition 8. If âˆ†  { g s :  j bA then there exist
; Î“; bâ€² sCtC dom()  kvrs(Î“)A vny
{w s :  j Î“ j b
â€²
; âˆ†  { (Î“); b = I.âˆ† (b
â€²):
droposition 9 (Weacefafg gf eflaadeefl). âˆ† { Î“
implies âˆ† âˆ†â€² { Î“C
droposition 10. {c âˆ†1âˆ†2 implies {c âˆ†1C
Note that Prop.10 does not hold for the judgment {g âˆ†
defining well-formed type environments for global compila-
tion; indeed, {g âˆ† holds only if the class hierarchy in âˆ† is
(upward) complete.
In order to establish assumptions in Theorem 4 and The-
orem 6, we require the simplification relation to satisfy the
properties listed in Theorem 11 below, which have the fol-
lowing informal meaning.
!ls Asounx guarantees that the simplification step is sound,
in the sense that, after applying the given substitution,
it actually eliminates only type constraints which hold
in the current class type environment.
!ls AwomplytyAE guarantees that, if âˆ† contains enough type
information to satisfy all type constraints in Î“, then
this simplification step must be possible in !ls .
!ls AwomplytyAF handles the case in which there is not
enough type information in a class type environment,
say âˆ†2, to guarantee that all constraints in Î“ hold.
However, if it is possible to eliminate these type con-
straints in a larger class type environment âˆ†1 âˆ†2, then
it must be possible to partially simplify Î“ in âˆ†2, ob-
taining Î“â€².
Note that the last requirement allows many different â€œstrate-
giesâ€ for !ls â€” including the strategy where simplification
just does nothing (Î“â€² = Î“ in the above) until the class
type environment contains sufficient information to simplify
vll type constraints, in which case it applies vll the sub-
stitutions. However, algorithms implementing !ls should
attempt to find as many simplifications as possible at any
step. We will present such an algorithm in the next section.
hhyorym 11. If the linkingBsimplixvtion relvtion ! ls
svtises the follofiing propertiesO
!ls Asounx
Î“ relevvnt vny {c âˆ† vny âˆ† { Î“ !ls  j Î“
â€² imply
dom()kvrs(Î“) vny Î“â€²(Î“) vny âˆ† { (Î“) n Î“â€²C
!ls AwomplytyAE
Î“ relevvnt vny {c âˆ† vny âˆ† { (Î“) vny dom() 
kvrs(Î“) imply âˆ† { Î“ !ls  j Î›C
!ls AwomplytyAF
Î“ relevvnt vny {c âˆ†1 âˆ†2 vny âˆ†1 âˆ†2 { Î“ ! ls  j Î›
imply 9 Î“â€²; â€²; â€²â€² sCtC =F) âˆ†2 { Î“ ! ls 
â€² j Î“â€²A =2)
âˆ†1 âˆ†2 { Î“
â€² !ls 
â€²â€² j Î›A vny =3)  = â€² â€²â€²C
ihenA xompositionvl xompilvtion of FJ is souny vny xomB
plete fiCrCtC glowvl xompilvtionC
5. A LINKING ALGORITHM
In this section we describe a particular linking algorithm,
thus making rule xBlinking effective, and we sketch a proof
that this algorithm is a correct implementation of the !ls
relation. We start with some basic definitions which specify
the problem we are aiming to solve.
5.1 Basic definitions
Unless specified, in this section we will only consider type
environments âˆ† s.t. {c âˆ†, that is, possibly open envi-
ronments with no multiple type assignments for the same
class name, no inheritance cycles, no field hiding and no bad
method overriding. Furthermore, when more convenient, we
will treat âˆ† and Î“ as the sets of their elements (regardless
possible repetitions in Î“), and use the standard set theory
notations.
As a first, rather imprecise attempt, the problem could
be informally stated as follows: given a type environment âˆ†
and a sequence of constraints Î“, find the possibly maximal
Î“â€²  Î“ s.t. âˆ† satisfies Î“â€²; note that, since we are inter-
ested in incremental linking, âˆ† might not satisfy the whole
environment Î“.
A first problem with the above statement is that satis-
faction of type constraints is under-specified; e.g., for âˆ† =
(c; Objece; ;; ;) and Î“ = (c1; f; );   c (with c 6= c1), one
might be tempted to assert that   c is satisfied by âˆ† with
 = c. Nevertheless, even though  = c originally seems like
the only possible solution, it cannot be considered valid be-
cause it is sensitive to extensions to âˆ†. For instance, if we
take âˆ†â€² = âˆ†; (c1; c; fc1 fg; ;) then we discover that  = c is
no longer a valid solution, and that the whole Î“ is satisfied
by âˆ†â€² with  = c1. In terms of the linking process, this
means that we would need to backtrack from  = c when
adding a class c1 as specified by âˆ†
â€².
We now formalize the above reasoning. First, a solution is
a substitution  for type variables s.t. âˆ† satisfies (Î“), that
is, âˆ† { (Î“) is valid. Second, in order to avoid backtracking,
 must be the unique possible choice (up to inclusion of
maps) for all extensions of âˆ†.
Dynition 12. For suwstitutions ; â€²A fie svy   â€² i
yom()  yom(â€²) vny for vll  2 yom()A () = â€²()C
Dynition 13. V sequenxe of xonstrvints Î“ has solution
 fiCrCtC v given âˆ† i
FC âˆ† { (Î“)P
2C 8â€²; âˆ†â€²O if âˆ†  âˆ†â€² vny âˆ†â€² { â€²(Î“)A then   â€²C
Fuwt 14. V Î“ hvs vt most one solution fiCrCtC v given âˆ†C
Now that we have formalized the notion of solution, we
can consider in more detail the situation where Î“ has no
solution w.r.t. a given âˆ†; as already said, this situation oc-
curs quite naturally when considering incremental linking,
because âˆ† is likely to be incomplete, and thus may contain
insufficient information to compute a solution for Î“. Nev-
ertheless, the algorithm should be able to identify a subse-
quence Î“â€²â€²  Î“ s.t. Î“â€²â€² has a solution  w.r.t. âˆ†, and perform
a simplification step: the constraints Î“â€²â€² are removed in order
to avoid unnecessary checks in further linking steps, whereas
 is applied to the remaining constraints Î“nÎ“â€²â€², thus return-
ing a sequence Î“â€². Note that if the algorithm was smart
enough, then Î“â€²â€² would be maximal, that is, there would not
exist a Î“â€²â€²â€² s.t. Î“â€²â€²  Î“â€²â€²â€²  Î“ and Î“â€²â€²â€² has solution w.r.t. âˆ†.
We distinguish two possible situations w.r.t. remaining
constraints Î“â€²: If there exists no extension of âˆ† which gives
a solution for Î“â€², then the algorithm should detect a linking
error. In this case, we say that Î“ is inxonsistent w.r.t. âˆ†.
Otherwise, linking succeeds, but the constraints Î“â€² still
need to be satisfied, therefore the obtained fragment needs
to be linked further before execution. In this case, we say
that Î“â€²â€² is unyeterminey w.r.t. âˆ†.
Dynition 15. V sequenxe of xonstrvints Î“ is inxonsisB
tent fiCrCtC v given âˆ† i for vll âˆ†â€² if âˆ†  âˆ†â€²A there is no 
sCtC âˆ†â€² { (Î“)P it is xonsistent =fiCrCtC âˆ†) otherfiiseC
A sequence of constraints Î“ which is inconsistent w.r.t.
Î› (that is, for all âˆ†) is called inconsistent. Conversely, a
sequence of constraints Î“ which is consistent w.r.t. some âˆ†
(hence, w.r.t. Î› as well) is called consistent.
Dynition 16. V sequenxe of xonstrvints Î“ is determined
fiCrCtC âˆ† i Î“ either hvs v solution or is inxonsistent fiCrCtC
âˆ†P it is undetermined =fiCrCtC âˆ†) otherfiiseC
Dynition 17. V sequenxe of xonstrvints Î“ is determined
i for vll âˆ†A there exists âˆ†â€² sCtC âˆ†  âˆ†â€² vny Î“ is yeterminey
fiCrCtC âˆ†â€²P vny is undetermined otherfiiseC
droposition 18. ihe xonstrvint  is determined i it
mvtxhes one of the follofiing pvtternsO 9 cA c  câ€²A (c; f; t)A
(c; m; cÂ¯; (t; tÂ¯))A (c; cÂ¯; tÂ¯)A c  câ€²C
Finally, in order to prove that our algorithm implements a
!ls relation satisfying properties!ls -sound,!ls -complete-
1, and !ls -complete-2 of Theorem 11 â€” hence, soundness
and completeness of compositional compilation w.r.t. global
compilation is guaranteed â€” we show that each relevant set
of constraints satisfies a quite intuitive syntactic property,
and that for constraint sets which satisfy this syntactic prop-
erty we can define an algorithm which satisfies the conditions
of Theorem 11.
This syntactic property is based on a topological relation
 between constraints, with the following intuitive meaning:
if   â€², then  has to be processed prior to â€². For this we
define the predicates I(; ), expressing that  appears in
an â€œin-positionâ€ in  that is, needs to have been substituted
before  can be processed, and O(; ) expressing that 
appears in an â€œout-positionâ€ in , that is, processing  will
provide a substitution for this variable. I(), I(Î“), O(),
O(Î“) have the obvious meaning, that is, the set of I variables
in , or Î“, and the set of O variables in , or Î“.
InputO
this: a well-formed Î“
argument: a well-formed âˆ†
dutputO
if it fails then Î“ is inconsistent w.r.t. âˆ†
else returns  and transforms Î“ into Î“â€² s.t.
â€“ Î“â€² = (Î“ n Î“â€²â€²)
â€“ Î“â€²â€²  Î“
â€“  is the solution of Î“â€²â€² w.r.t. âˆ†
â€“ for all  2 Î“â€²,  has no solution w.r.t. âˆ†
eseuyoBxoyeO
huws solve(Env âˆ†) throws fvilf
 = 
this.topsort () // Î“ must be topologically sorted
for each  2 this f // according to the order
tryf
:vpply()
â€² = :entvileyWy(âˆ†)
this.remove()
:upyvte(â€²)
g
catch(unyeterminey )fg
g
return 
g
Figury E4: Construint solving ulgorithm solve
Dynition 19. For vny Î“A A vny  fie yeneO
FC I(; ) i  =   tA or  = t  A or  = c  A
or  = (; f; t)A or  = (t; m; tÂ¯; (tâ€²; tÂ¯â€²)) fiith  = t
or  2 tÂ¯A or  = (c; tÂ¯; tÂ¯â€²) fiith  2 tÂ¯C
2C O(; ) i  = (t; f; )A or  = (t; m; tÂ¯; (tâ€²; tÂ¯â€²)) fiith
 2 tÂ¯â€² or  = tâ€²A or  = (c; tÂ¯; tÂ¯â€²) fiith  2 tÂ¯â€²C
3C I() = f j I(; ) gA I(Î“) = [âˆˆÎ“I()A
O() = f j O(; ) gA O(Î“) = [âˆˆÎ“O()C
Dynition 20. ihe follofiing topologixvl relvtion is yeB
ney on type xonstrvintsO   â€² i O() \ I(â€²) 6= ;C
Dynition 21. aet + yenote the trvnsitive xlosure of
C ihen v set of xonstrvints Î“ is fiellBformey i
FC 8 2 Î“ : I(; ) =) 9â€² 2 Î“ : O(; â€²)A
2C 6 9 2 Î“ :  + A
3C 8; â€² 2 Î“ : O(; ) vny O(; â€²) =)  = â€²
5.2 Description of the algorithm
The Java pseudo-code of the main algorithm is defined in
Figure 14. The method solve takes a class type environment
âˆ† and returns a substitution; it is declared in the class im-
plementing sequences of constraints, therefore this denotes
a certain Î“. When invoked, method solve either throws fvil
or returns a substitution  and simplify Î“ into Î“â€².
The invocation :entvileyWy(âˆ†), will throw the exception
fvil if a  2 Î“ is found to be inconsistent w.r.t. âˆ† (and
hence the whole Î“ is inconsistent as well).
The method solve returns a , if it has found a subse-
quence Î“â€²â€²  Î“ which has solution  w.r.t. âˆ†, and has
modified Î“ to Î“â€² by removing Î“â€²â€² and applying . We can
see that Î“â€²â€² is maximal, by proving that for all  2 Î“â€², 
has no solution w.r.t. âˆ†. However, while all possible sim-
plifications are always performed, some inconsistencies may
be discovered later on, when some new fragment is linked,
mainly because each constraint  2 Î“ is checked separately.
For instance, given âˆ† = (c; Objece; ;; ;) and Î“ = c1 
c2; c2  c1 (with all class names distinct), Î“:solve(âˆ†) re-
turns the empty substitution and does not modify Î“, even
though Î“ is clearly inconsistent; however, such inconsistency
can be captured when performing further linking steps. For
instance, if we take âˆ†â€² = âˆ†; (c1; Objece; ;; ;) then Î“:solve(âˆ†
â€²)
throws fvil since c1  c2 is clearly inconsistent w.r.t. âˆ†
â€².
The constraints are processed respecting the topological
order given in Definition 20, so that it is possible to scan
Î“ only once without failing to simplify some constraints.
To see that the topological sorting is needed, consider for
instance Î“ =   c; (c; f; ), which is not topologically
sorted, and âˆ† = (c; Objece; fc fg; ;). The constraint   c
is processed first and kept, since is undetermined w.r.t. âˆ†.
Then the constraint (c; f; ) is removed (since it has solu-
tion  = c); however, the already examined constraint   c
cannot be further instantiated into c  c, and, therefore, is
not removed. Therefore solve fails to perform a simplifi-
cation step. Finally, note that since Î“ is assumed to be
well-formed, it can always be topologically sorted.
Before being processed, each  is instantiated w.r.t. the
current substituion . Then, the method entvileyWy checks
whether  has solution w.r.t. âˆ†; if so, it returns the corre-
sponding substitution â€², otherwise it throws either fvil, if
 is inconsistent w.r.t. âˆ†, or undetermined if  is undeter-
mined w.r.t. âˆ†. As already explained, fvil is propagated by
solve, whereas undetermined is captured; in this way, the
constraint is not removed, the current substitution is not
updated, and solve continues with the next constraint.
Figure 15 contains pseudo-code for entvileyWy in the class
representing constraints of the form e  eâ€² (the other cases
can be found in [2]).
If either the left or right hand side of the constraint is
a variable, then the constraint is undetermined, therefore
the corresponding exception is thrown. Otherwise the con-
straint is ground and we can check whether it is satisfied by
âˆ†. If the trivial cases do not apply (reflection and top type),
then we perform an inheritance graph traversal from c1 up
to Objece which can terminate in three different ways: if c2
is found, then the constraint is satisfied and we return the
empty substitution; if Objece is reached without finding c2
then the constraint is inconsistent and fvil is thrown; other-
wise the traversal stops because method superxlvss throws
unyeterminey since some superclass of c1 (c1 included) could
not be found in âˆ†. In the last case, the exception must
be caught since the constraint still could be inconsistent if
there exists c s.t. c2  c and c  c1. For this reason a new
traversal is started from c2 looking for a superclass of c2 (c2
included) contained in the set S of all superclasses of c1 (c1
included) collected during the first traversal. If such a class
is found, then fvil is thrown, otherwise (if either superxlvss
throws unyeterminey , or Objece is reached) unyeterminey
is thrown.
5.3 Correctness of the algorithm
In the sequel, let !ls denote the relation implemented by
solve, that is, the relation defined as follows:
huws entvileyWy(Env âˆ†) throws unyeterminey ; fvilf
// âˆ† assumed to be well-formed
if this.lhs():vvr () _ this.rhs():vvr () throw unyeterminey
c1 = this.lhs()
c2 = this.rhs()
if c1:equvls(c2) _ c2:equvls(Objece) return 
c = c1
S = fc1g // will contain all c s.t. c1  c
try f
while c 6= Objecef
c = âˆ†:superxlvss (c)
S:vyy(c)
if c:equvls(c2) return 
g
throw fvil // chain complete up to Objece
g
catch(unyeterminey )fg
c = c2 // still could fail
while c 6= Objecef
c = âˆ†:superxlvss(c)
if S:xontvins(c) throw fvil
g
throw undetermined
g
Figury EI: Dynition of entvileyWy for e  eâ€²
âˆ† { Î“ !ls  j Î“
â€² iff Î“:solve(âˆ†) returns  and transforms Î“
into Î“â€².
The following propositions ensure that ! ls leads to a
sound and complete compositional compilation of FJ w.r.t.
global compilation.
droposition 22. Vny relevvnt Î“ is fiellBformeyC
droposition 23. ihe relvtion ! ls svtises properties
!ls BsounyA !ls BxompleteBFA vny !ls BxompleteB2 of iheoB
rem FF for vny fiellBformey Î“C
Finally, note that Prop. 22 ensures also that solve is only
invoked for sequences of constraints which can be sorted
w.r.t. the topological order  defined in Definition 20.
6. RELATED WORK
No formal model for separate compilation and linking had
been developed until Cardelliâ€™s seminal work in 1997 [7],
which can be considered a milestone in the area. It develops
a simple formal framework for separate compilation (which,
for the sake of simplification, is considered to consist only
of typechecking), and linking. This framework can be con-
sidered to embody the notion of compositional compilation
formalized in the present paper. The main differences are
that we are also interested in code generation, and that the
general framework in Section 2 abstracts from a particular
programming language, and is parametric in the definition
of separate compilation and linking judgments. Instead, [7]
illustrates the concepts on a simple lambda-calculus, and
linking just amounts in checking that each used entity has
the required type and replacing its name by its definition.
Moreover, [7] did not consider the issue of which prop-
erties compositional compilation should satisfy in order to
produce the same final result as global compilation. These
properties correspond to some form of soundness and com-
pleteness as described in the present paper. They have
been firstly introduced and formalized in [5], within a gen-
eral framework for separate compilation and linking espe-
cially suited for Java-like languages similar to that intro-
duced here. However, the framework in [5] did not take
into account possible specialization of bytecode during link-
ing, hence linking was reduced to interBxhexking, that is,
checking that mutual assumptions on fragments are satis-
fied. As a consequence, in the instantation of the frame-
work presented in [5] (again on Featherweight Java) the
code generated by separate compilation was standard Java
bytecode, rather than the polymorphic bytecode introduced
here; hence, since generated bytecode is context-dependent,
separate compilation of a class was only possible under some
given type constraints (or, equivalently, for each possible re-
sulting bytecode).
The result in [5] was nevertheless important, since a type
system for a Java-like language was firstly formally proved to
guarantee sound and complete inter-checking (or, from an-
other point of view, to support prinxipvl typings, see below).
On the practical side, type systems as that in [5] (see also
[4, 3]) constitute a good basis for selective recompilation,
as exploited for full Java in [11, 12, 14], since it is possi-
ble to check whether a change in a source fragment affects
other fragments by simply checking that their requirements
still hold, but not for type inference, since type constraints
needed for compiling a class cannot be inferred by just in-
specting its source code.
In other words, compositional compilation as meant in
this paper (compilation of a fragment in isolation) is not
possible; type constraints can only be inferred for a given
resulting bytecode.
The difference between the present paper and [5] becomes
clearer by discussing the relation of our approach with the
notion of prinxipvl typing . According to Wells [17]:
 a typing for a term i is the collection of all the infor-
mation other than i which appears in the final judge-
ment of a proof derivation showing that i is typable,
and
 (roughly speaking) a typing for a term i is prinxipvl
if it somehow represents all the typings for i .
The paper [17] (see also [10]) pointed out that the principal
typing property (that is, every typable term has a principal
typing) plays a key role in compositional type inference.
In this paper, as in [5], we have formalized compilation (in-
cluding code generation) by means of a type system. There-
fore, in our framework, performing compilation amounts to
performing type inference.
In the type system in [5], the principal typing property
holds by taking as terms pairs consisting of a source and a
binary fragment (in other words, bytecode is considered part
of the term). Instead, in the type system for compositional
compilation proposed in this paper, {C , the principal typing
property holds by taking as terms source fragments S: a
typing is a triple âˆ† j B j Î“ (note that bytecode is considered
part of the typing) and the system has the principal typing
property since, for any source fragment S, at most one typing
(modulo renaming of type variables) can be derived.
7. CONCLUSION
In this paper we addressed the problem of supporting
compositional compilation for languages (like Java and Cr)
where the binary code depends on the compilation context.
For this, we defined a schema formalizing global and com-
positional compilation for such languages, and instantiated
it by providing algorithms supporting compositional com-
pilation for Featherweight Java. To the best of our knowl-
edge, this is the first compositional compilation procedure
for a Java-like language.
We believe that the results in this paper can be exploited
at least in two different ways.
Firstly, they can be directly applied to the development
of a new generation of compilers/interpreters/linkers (sup-
porting compositional compilation) for real languages like
Java and Cr. In this approach, polymorphic bytecode would
be instantiated eagerly, in a step corresponding to static-
linking. Such compilers would naturally support selective
recompilation mechanisms, in the same spirit of [11, 12, 14].
In this respect, note that the application of our approach
to, e.g., full Java, does not pose substantially new problems,
though obviously more and more involved forms of type con-
straints, as we briefly discuss below. Type constraints mod-
eling field hiding and method overloading were already pre-
sented (in the non polymorphic approach) in [4, 5, 3], and
are omitted in this paper for simplicity. Roughly speaking,
allowing method overloading simply leads to a different in-
terpretation of the type constraint (c; m; cÂ¯; (câ€²; cÂ¯â€²)), which
becomes: â€œfor a call of method m with receiver of type c
and arguments of type cÂ¯ the most specific method has re-
turn type câ€² and parameters of type cÂ¯â€²â€ (and analogously
for field hiding). Hence, rule (c-meth-call) in Fig.11 is not
affected, whereas rules defining the entailment judgment for
this type constraint, that is, (-1) and (-2) in Fig.8, must
change in order to reflect that the type constraint holds when
câ€² and cÂ¯â€² are the return and parameter types of the most
specific method for the call in the given class type envi-
ronment. The linking simplification algorithm must change
accordingly. Type constraints modeling most other relevant
Java features, such as checked exceptions, accessibility lev-
els, unreachable code, compile-time constants, are presented
in [11, 12, 14]. Finally, in [13] it is shown how to deal with
another Java peculiar feature, that is, the ambiguity in an
expression such as A.B.C.4
Secondly, the results in this paper could lead to the de-
velopment of a more flexible run-time support for Java-like
languages, allowing execution of bytecode containing type
variables. In this approach, polymorphic bytecode would be
instantiated lazily, during dynamic linking and loading â€”
some initial exploration appears in [6].
Further work includes extensions of our polymorphic model
to other Java features, adapting to the polymorphic case
the results mentioned above, and, more interestingly, to F-
founded polymorphic methods and classes as introduced by
GJ and Java 1.5. We also plan to investigate the extension
of the source language so that it may contain type variables
as well.
4For instance, A could be a class, B a static field, C a field,
or A could be a class, B a nested class, C a static fied, or A
could be a package, B a class, and C a field.
Acknowledgements. We are grateful to the anonymous ref-
erees for detailed and insightful comments and suggestions,
and to to Alex Buckley for feedback. This work has been
partially supported by Dynamic Assembly, Reconfiguration
and Type-checking - EC project IST-2001-33477, and by
APPSEM II - Thematic network IST-2001-38957.
8. REFERENCES
oEq DB Unwonu, ZB Dumiuni, gB Drossopoulou, unx EB nuwwuB Evyn
mory prinwipul typings zor JuvuAliky lunguugysB ]n Jth Intl.
korkshop on Formul hychniquys for Juvu drogrums FDD4,
Juny FDDHB
oFq DB Unwonu, ZB Dumiuni, gB Drossopoulou, unx EB nuwwuB
dolymorphiw vytywoxyN Wompositionul wompilution zor
JuvuAliky lunguugysB hywhniwul ryport, Dipurtimynto xi
]nzormutiwu y gwiynâ€“y xyll']nzormuâ€“iony, inivyrsitu xi [ynovu,
bovymvyr FDDHB Efitynxyx vyrson with proozs, uvuiluvly ut
ffb://ffb.diei.gnige.if/bgb/bedean/AncanaD/BBCCJL.bdfB
oGq DB Unwonu unx [B LugorioB gtrongyr hypings zor gmurtyr
fywompilution oz JuvuAliky LunguugysB Journul of cvjyct
hychnology, G(J)NI{FI, Juny FDDHB gpywiul issuyN EWccd FDDG
workshop on Zormul hywhniquys zor JuvuAliky drogrumsB
oHq DB Unwonu, [B Lugorio, unx EB nuwwuB hruy sypuruty
wompilution oz Juvu wlussysB ]n AWa gIGdLAb Wonfyryncy
on drinciplys und dructicy of Dyclurutivy drogrumming
(ddDd'DF), pugys ELM{FDDB UWa dryss, FDDFB
oIq DB Unwonu unx EB nuwwuB drinwipul typings zor JuvuAliky
lunguugysB ]n AWa gymp. on drinciplys of drogrumming
Lunguugys FDD4, pugys GDJ{GE7B UWa dryss, Junuury FDDHB
oJq Ulyfi Vuwklyy unx gophiu DrossopoulouB Zlyfiivly Dynumiw
LinkingB ]n Jth Intl. korkshop on Formul hychniquys for
Juvu drogrums FDD4, Juny FDDHB
o7q LB WurxylliB drogrum zrugmynts, linking, unx moxuluriâ€“utionB
]n AWa gymp. on drinciplys of drogrumming Lunguugys
EMM7, pugys FJJ{F77B UWa dryss, EMM7B
oLq gophiu Drossopoulou unx gusun EisynvuwhB ]s thy Juvu hypy
gystym gounxS ]n EEth Europyun Wonfyryncy on cvjyct
criyntyd drogrumming (EWccd'M7), volumy EFHE oz LbWg,
pugys GLM{HELB gpringyrAVyrlug, Juny EMM7B
oMq UB ]gurushi, VB diyrwy, unx dB kuxlyrB Zyuthyrwyight JuvuN U
minimul wory wulwulus zor Juvu unx [JB ]n AWa gymp. on
cvjyctAcriyntyd drogrummingN gystyms, Lunguugys und
Applicutions EMMM, pugys EGF{EHJ, bovymvyr EMMMB
oEDq hB JimB khut ury prinwipul typings unx whut ury thyy goox
zorS ]n drocyydings of thy FGrd AWa gIGdLAbAgIGAWh
symposium on drinciplys of progrumming lunguugys, pugys
HF{IGB UWa dryss, EMMJB
oEEq [B LugorioB howurxs u smurt wompilution munugyr zor JuvuB ]n
Vlunxo unx Lunyvy, yxitors, Ituliun Wonf. on hhyoryticul
Womputyr gciyncy FDDG, numvyr FLHE in Lywtury botys in
Womputyr gwiynwy, pugys GDF{GEIB gpringyr, cwtovyr FDDGB
oEFq [B LugorioB Unothyr styp towurxs u smurt wompilution
munugyr zor JuvuB ]n Hishum Huxxux, Unxryu cmiwini,
fogyr LB kuinwright, unx Loriy aB Liyvrowk, yxitors, AWa
gymp. on Appliyd Womputing (gAW FDD4), gpyciul hruck on
cvjyctAcriyntyd drogrumming Lunguugys und gystyms, pugys
EF7I{EFLDB UWa dryss, aurwh FDDHB
oEGq [B LugorioB Wupturing ghost xypynxynwiys in Juvu sourwysB
Journul of cvjyct hychnology, FDDHB ho uppyurB
oEHq [B LugorioB hypy systyms for Juvu sypuruty compilution und
sylyctivy rycompilutionB dhD thysis, Dipurtimynto xi
]nzormutiwu y gwiynâ€“y xyll']nzormuâ€“iony, inivyrsitu xi [ynovu,
auy FDDHB
oEIq fovyrt gyvystuB Woncypts of drogrumming LunguugysB
UxxisonAkyslyy, FDDHB gyvynth yxitionB
oEJq DB von chyimv unx hB bipkowB Juvu is hypy guzy A DynitylyB
]n AWa gymp. on drinciplys of drogrumming Lunguugys
EMML, UWa dryss, EMMLB
oE7q JBVB kyllsB hhy yssynwy oz prinwipul typingsB ]n Intyrnutionul
Wolloquium on Automutu, Lunguugys und drogrumming
FDDF, numvyr FGLD in Lywtury botys in Womputyr gwiynwy,
pugys MEG{MFIB gpringyr, FDDFB
