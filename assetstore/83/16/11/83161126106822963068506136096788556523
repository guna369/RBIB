What are principal typings and what are they good for?
Technical Memorandum MIT/LCS/TM{532
Trevor Jim August 1995; revised November 1995
Abstract
We demonstrate the pragmatic value of the principal typing property, a property distinct from ML's principal type property, by studying a type system with principal typings. The type system is based on rank 2 intersection types and is closely related to ML. Its principal typing property provides elegant support for separate compilation, including \smartest recompilation" and incremental type inference, and for accurate type error messages. Moreover, it motivates a new rule for typing recursive de nitions that can type some interesting examples of polymorphic recursion.
Keywords: Polymorphic recursion, separate compilation, incremental
type inference, error messages, intersection types.
1 Introduction
We would like to make a careful distinction between the following two properties of type systems.
Property A
Given: a term M typable in type environment A. There exists: a type representing all possible types for M in A.
Property B
Given: a typable term M. There exists: a typing A ` M : representing all possible typings of M. Property A is the familiar principal type property of ML. By analogy, we will call Property B the principal typing property. The names are close enough to give us pause. In fact, some authors have used \principal typings" in reference
545 Technology Square, Cambridge, MA 02139, trevor@theory.lcs.mit.edu. Supported by NSF grants CCR{9113196 and CCR{9417382, and ONR Contract N00014{92{J{1310.
1

to Property A. But \principal typings" is also the name traditionally applied to Property B, and we will not introduce a new name here.
Why do we care to make such a distinction? Property A|principal types| is certainly useful. But Property B|principal typings|is more useful still. We believe this has been overlooked because ML and its extensions completely dominate current research on type inference; and we know of no sense in which ML has principal typings. This was already noted by Damas in his dissertation 6], but there have been subsequent claims that ML has the principal typing property, indicating that the distinction between principal types and principal typings is not widely appreciated. We examine ML's lack of principal typings more closely in x6.
In this paper, we demonstrate the usefulness of the principal typing property by studying a type system that has it. We emphasize that our results are motivated entirely by the general principal typing property, and not by the technical details of this particular case study. Any system with principal typings can bene t from our observations.
Nevertheless, we take some care in choosing our case study, so that its relevance to current practice will be immediately evident. Therefore, we seek a type system closely related to ML: it should be able to type all ML programs, it should have decidable type inference, and the complexity of type inference should be approximately the same as in ML.
The type system that satis es all of these requirements is the system of rank 2 intersection types. This system is closely related to the more well-known rank 2 of System F|we will show that they type exactly the same terms|but it possesses the additional property of principal typings. We use a variant of
the intersection system, called P2, as our case study.
The distinction between principal types and principal typings is evident in
the type inference algorithm for P2: it takes a single input, a term M, and
produces two outputs, an A and such that A ` M : . The types required of the free variables of M are speci ed by A; but A is a byproduct of type inference, not a necessary input. Contrast this with Milner's algorithm for ML, whose let-polymorphism relies on A being an input.
We illustrate the bene ts of principal typings in three areas: recursive de nitions, separate compilation, and accurate type error messages.
Recursive de nitions. Two rules that have been used to type recursive
de nitions in ML are given below.

(rec-simple)

A fx : g ` M : A ` ( xM) :

(where is a simple type)

(rec-poly)

A fx : g ` M : A ` ( xM) :

(where is an ML type scheme)

The rule (rec-simple) requires the body M of the recursive de nition ( xM) to be typed under the assumption that x has a simple type. This restriction

2

is relaxed in (rec-poly), the rule of polymorphic recursion 26, 16], which

permits M to be typed under the assumption that x has a polymorphic type.

More terms are typable under (rec-poly) than (rec-simple), and practical

examples of programs requiring polymorphic recursion are a recurring topic

on the ML mailing list. But (rec-simple) is used in practice, because type

inference for (rec-poly) is undecidable 17, 9]. To understand why, consider

type inference using Milner's algorithm: in order to infer a type, , for the

de nition M, we need to know the type to use for the free variable x, that is, .

In the case of (rec-poly), this \chicken and egg" problem cannot be solved.

The principal typing property suggests a new rule for typing recursive de -

nitions:

A fx : g ` M : A ` ( xM) :

(where

)

In this rule, the type assumed for the recursive variable x need not be the same as the type derived for its de nition M. The type expresses the requirements on x needed to give M the type ; as long as meets these requirements ( ), it is safe to assume it as the type of the de nition.
Now the strategy for type inference becomes clear: infer the principal typing A ` M : for M, producing both and = A(x). It only remains to ensure
, and this can be accomplished by subtype satisfaction, a procedure similar to uni cation.
When we use this strategy to type recursive de nitions in P2, we obtain an
interesting typing rule, lying between (rec-simple) and (rec-poly): it is able to type some, but not all, examples of polymorphic recursion.

Separate compilation. In separate compilation, a large program is divided
into smaller modules, each of which is type checked and compiled in isolation. The program as a whole is closed, but modules have free variables|a module may refer to other modules. Types play an important role in compilation; for instance, the data representations and calling conventions of a module may depend on its type. Thus the compiled machine code of a module may depend on the types of external variables that it references.
Consequently, most compilers require the user to specify the types of ex-
ternal variables referenced in each module. In P2, our ability to perform type
inference on program fragments with free variables means that the user need not write these speci cations: the compiler can infer them itself. More significantly, principal typings will enable us to achieve smartest recompilation 27], which guarantees that a module need not be recompiled unless its own de nition changes. We also show that principal typings enable an elegant and e cient solution to a related problem, incremental type inference 1].

Error messages. Most compilers for strongly typed languages do not do a
good job of pinpointing the location of type errors in programs; see Wand 30] for a discussion. As a nal example of the utility of principal typings, we show that principal typings help to produce error messages that accurately identify the source of type errors.

3

Organization of the paper. We introduce the type system P2 in x2,

and show its connection with rank 2 of System F. We describe how we type

recursive de nitions in x3, and we show how principal typings support separate

compilation in x4. We describe how principal typings produce more accurate

type error messages in x5. In x6, we address the question of whether principal

typings exist for ML. We we describe an extension

odfePsc2ribweitahltperrinnactipivaelsttyopipnrgins.ciWpael

typings discuss

in x7. In x8, related work

in x9, and we summarize our results in x10. Proofs of all theorems can be found

in a separate paper 11].

2 The type system
We now present our type system, in an expository manner. Uninteresting details have been placed in an appendix. For the most part, the system relies on familiar rules of subtyping and type assignment. However, the system is based on a notion of rank, and there are some complications due to the need to stay within rank. These complications are characteristic of all ranked systems.
Our programs are just the terms of the lambda calculus: M ::= x j (M1M2) j ( xM):
Notice that our programs do not use ML's let-expressions. In our type system,
(let x = M in N) can be considered an abbreviation for ( xN)M.
We will be de ning several classes of types, each of which is a restriction of the types with quanti cation and intersection:
::= t j ( 1 ! 2) j (8t ) j ( 1 ^ 2): For those unfamiliar with intersection types, we present a brief example. A term of type ( ^ ) is thought of as having both the type and the type . For example, the identity function has both type (t ! t) and (s ! s) ! (s ! s), so
( y:y) : (t ! t) ^ ((s ! s) ! (s ! s)): By this intuition, a quanti ed type stands for the in nite intersection of its instances:
( y:y) : (8u:u ! u): The types (t ! t) and (s ! s) ! (s ! s) are instances of (8u:u ! u), so in some sense this typing is \more general" than the rst.
Our ranked system will allow only a limited use of intersections: they may only appear to the left of a single arrow. For example, we will be able to derive the following type in our system:
( x:xx) : 8s; t:(s ^ (s ! t)) ! t:

4

This says that as long as the argument of the function ( x:xx) has both the types s and s ! t, for some s and t, the result will be of type t. Note that this term is not typable in ML. An appropriate argument for this function is the identity function:

( x:xx)( y:y) : (8u:u ! u):

Again, we will be able to derive this type in our system. This example is typable in ML, provided it is translated into a let-expression:

(let x = ( y:y) in xx) : (8u:u ! u):

T2,WanednTow82giovfetythpeesdaetraeidlseofneodurinrdaunckteidveslyysbteymt,hceaelqleudatPio2n. sTbheeloswet.s T0, T1,

T0 = f t j t is a type variable g f( ! ) j ; 2 T0g; T1 = T0 f( ^ ) j ; 2 T1g; T2 = T0 ( )f ! j 2 T1; 2 T2g; T82 = T2 f(8t ) j T :22 8 g

The set T0
intersections

is the set of simple

of simple
types. T2

types, is the

and set

T1 is the set of nite, nonempty
of rank 2 intersection types: these

are types possibly containing intersections, but only to the left of a single arrow.

Note that rank here refers to the depth of intersections below arrows, not the

dquepaJtnhutisotfcaansteiwsoteninhogafvoteyf psaeervrveorawarsli,acbalalnesdssettsohoaTftt2Ty.p0e=s,

T1
we

\ T2. Finally, T82 adds top-level
have several subtyping relations.1

Their de nition is simpli ed by observing the following conventions: we con-

sider types to be syntactically equal modulo renaming of bound type variables,

reordering of adjacent quanti ers, and elimination of unnecessary quanti ers;

and we consider `^' to be an associative, commutative, and idempotent oper-

ator, so that any types, written in

T1
the

type form

(mVaiy2Ibei)c,ownshiedreereedacah

nite, nonempty set of simple
i 2 T0.

De nition 1 For i 2 f1; 2; 82g, we de ne the relation order on Ti closed under the following rules:

i as the least partial

If f j j j 2 Jg f i j i 2 Ig, then (Vi2I i) 1 (Vj2J j).

If 1 1 1 and 2 2 2, then ( 1 ! 2) 2 ( 1 ! 2).

If 2 , then 82 .
If 2 T0, then (8t ) 82 ft := g .
If 82 and t is not free in , then 82 (8t ).
1These could be combined into a single subtyping relation, but it is technically convenient to keep them separate.

5

The rst rule says that 1 expresses the natural ordering on intersection types.

The second rule says that 2 obeys the usual antimonotonic ordering on function

types, restricted to rank 2. The is a subtype of its instances (we

rules for write ft

:=82

express the intuition that g for the substitution of

a

type for t

in ). They are equivalent to the following rule, similar to ML's notion of

generic instance:

If f~s := variables

~t~gare

n2ot

, where ~ free in (8~s

is ),

a vector then 8~s

of8s2im8~tpl.e

types,

and

the

type

Note that we only allow instantiation of simple types. This ensures that instantiation does not take us beyond rank 2. It also has less desirable implications, e.g., (8t:t) is not a least type in the ordering 82: (8t:t) 6 82 (s ^ (s ! u)) ! u.
A fourth subtyping relation will play an important role in the type system.
The relation 82;1 between T82 and T1 is the smallest relation satisfying the
rule: If 82 i for all i 2 I, then 82;1 (Vi2I i).

Tithreelraetleastitoynpes8\2;a1cirsosnsotraankp.a"rtNiaoltoerdthera;tiitnisancootmevpeanrisroenexive. This is because (8t ) 82;1 (^ i);
i2I

the type variable t may be instantiated di erently The typing judgments are of the form A ` M
and all of the types in A are T1 types. The typing

for :

,eawchherei.

is

rules are given

a in

T82 type,
Figure 1.

Example 2 Recall that the typings

( x:xx) : 8s; t:(s ^ (s ! t)) ! t; ( y:y) : (8u:u ! u);

hold in our system. Then by rule (sub),

( x:xx) : ((s ! s) ^ ((s ! s) ! (s ! s))) ! (s ! s):

And (8u:u ! u) 82 (s ! s) and (8u:u ! u) 82 ((s ! s) ! (s ! s)), so by rules (sub) and (app),

( x:xx)( y:y) : (s ! s):

Finally, by rule (gen),

( x:xx)( y:y) : 8s:s ! s:

We now give the de nition of principal typings appropriate to our system.

6

(var) (abs) (app)

fx : (Vi2I i)g ` x : i0 (where i0 2 I)

A fx : g ` M : A ` ( xM) : !

A

`

M

:

(Vi2I

i) ! ; (8i A ` (MN) :

2

I)

A

`

N

:

i

(gen)

A`M : A ` M : (8t )

t 62 FTV(A)

(sub)

A`M : A`M :

82

(add-hyp)

A`M : A fx : g ` M :

Figure 1: types are

Typing
in T82.

rules

of

P2.

Types

in

type

environments

are

in

T1,

and

derived

De nition 3

i) A typing B ` M : is an instance of a typing A ` M : if there

is a substitution S such that S
x 2 dom(A).

82 and B(x) 1 S(A(x)) for all

ii) A principal typing for a term M is a typing A ` M : of which any other typing of M is an instance.

This de nition is standard, cf. 25]. Note in particular that the notion of instance is monotonic in the derived type, but antimonotonic in the type environment. The intuition is, a principal typing expects less of its free variables, and provides more than any other typing judgment.

2.1 Comparison with Rank 2 of System F
The system P2 is closely connected to 2, the restriction of System F to rank 2
types. Our presentation of 2 is based on that of Kfoury and Tiuryn 15]. The types of System F are de ned by the following grammar:
::= t j ( 1 ! 2) j (8t ):
We consider System F types to be syntactically equal modulo renaming of bound type variables, reordering of adjacent quanti ers, and elimination of unnecessary quanti ers.

7

(var) Ax fx : g ` x :

(abs)

Ax fx : g ` M : A ` ( xM) : !

(app)

A`M : ! ; A`N: A ` (MN) :

(inst)

A ` M : 8t A ` M : ft := g

(gen)

A`M : A ` M : 8t

t 62 FTV(A)

Figure 2: Typing rules of
derived types are in R(2).

2. Types in type environments are in R(1), and

The types of System F can be organized into a hierarchy as follows. First,

de set

ne R(0) =
satisfying

T0.

Then

for

n

0, the set R(n + 1) is de ned to be the least

R(n + 1)

=

R(n)

( )f !

j

2 R(n);

2 R(n + 1)g

f(8t ) j 2 R(n + 1)g:

The typing judgments are of the form A ` M : , where is an R(2) type, and all of the types in A are R(1) types. The typing rules are given in Figure 2.

Theorem 4 A term M is typable in P2 i M is typable in 2 i M is typable
in the rank 2 intersection type system.

PTh2uhsatshethPe 2prpirnocgipraaml tsyapriengexparcotplyertthy,e

2 programs. As we will see, however, while no notion of principal typings is

known for 2 19].

Corollary 5 Typability in P2 is DEXPTIME-complete.
The proof of Theorem 4 relies on the principal type property of ML and is given in a separate paper 11]; a similar theorem has been shown independently by Yokouchi 32]. Corollary 5 follows by the results of Kfoury and Tiuryn 15] ( 2 typability is polynomial time equivalent to ML typability), and Kfoury et al. 18] and Mairson 22] (ML typability is DEXPTIME-complete).

8

2.2 Subtype satisfaction

In order to perform type inference, we must solve subtype satisfaction problems,

which generalize uni cation. Solving subtype satisfaction also gives a decision

procedure for subtyping. We will focus on the relation 82;1, as it is the most

important for type inference; all of the other relations can be handled in a

similar manner.

A 82;1-satisfaction problem is a pair 9~s:P , where P is a set whose every

element is either: 1) an equality between simple types; or 2) an inequality

between there is

a a

sTub82sttityupteioanndS0asuTc1h

type. that

for all inequalities ( ) 2 P , and

A substitution S is a solution S(t) = S0(t) for all t 62 ~s, S0 S0 = S0 for all equalities (

to 9~s:P if = 82);12SP0 .

We write MGS( ) for the set of most general solutions to a 82;1-satisfaction

problem (as with uni cation, most general solutions are not unique).

Theorem 6
i) The relation 82;1 is decidable.

ii) If a 82;1-satisfaction problem is solvable, then there is a most general solution for . Moreover, there is an algorithm that decides, for any , whether is solvable, and, if so, returns a most general solution.

Algorithms for deciding 82;1 subtyping and solving 82;1-satisfaction problems are given in Appendix B.

2.3 Type inference
The type inference algorithm is presented in the style favored by the intersection type community: for any M, we de ne a set, PP(M), called the principal pairs of M. Every element of PP(M) is a pair hA; i such that A ` M : is a principal typing of M.

De nition 7 For any term M, the set PP(M) is de ned by the following cases.

If M = x, then xhf : tg; ti 2 PP(x) for any type variable t.

If M = xN, and hA; 8~s i 2 PP(N), where the type variables ~s are distinct from all other type variables, then:

{ If x 62 dom(A), and t is a fresh type variable, then hA; 8t~s(t ! )i 2
PP( xN).
{ If x 2 dom(A), then hAx; Gen(Ax; A(x) ! )i 2 PP( xN).

If M = M1M2, and hA1; 8~s 1i 2 PP(M1), then:

{

If 1 = t (a type variable), t1 and t2 are fresh variables of hA2; 2i 2 PP(M2) are fresh, U

type variables,
2 MGS(f 2

the type t1; t =

t1 ! t2g), and A = U(A1 + A2), then

hA; Gen(A; Ut2)i 2 PP(M):

9

{

IPPfPi2(1MI A=2)i)a,(Vrtehi2efnrIesih),

!
U

2

,M(8Gi S2(fI

)
i

hA; Gen(A; U

the type variables i j i 2 Ig), and
)i 2 PP(M):

of A

=hAUi;(Aii1

2
+

The following technical property is used to show that PP(M) indeed speci es a type inference algorithm: the set PP(M) is an equivalence class of pairs under permutations, i.e., hA1; 1i; hA2; 2i 2 PP(M) i hA1; 1i = ShA2; 2i for some bijection S of type variables. Therefore, in choosing hA; i 2 PP(M) it is always possible to guarantee that the type variables of hA; i are \fresh."
To perform type inference, simply follow the de nition of PP(M), choosing
\fresh" type variables and using the MGS algorithm as necessary.

Example 8 We show how the algorithm nds a principal typing for ( x:xx).
i) PP(x) produces a pair xhf : t1g; t1i. ii) PP(x) (again) produces a pair xhf : t2g; t2i. iii) To calculate PP(xx), we nd a most general solution to

ft2 t3; t1 = t3 ! t4g; such as ft2 := t3; t1 := t3 ! t4g. Then
xhf : t3 ^ (t3 ! t4)g; t4i 2 PP(xx):

iv) Finally, PP( x:xx) produces

;h; 8t3; t4:(t3 ^ (t3 ! t4)) ! t4i:

Theorem 9 (Principal typings) If M is typable in P2, then there is a pair
hA; i 2 PP(M) such that A ` M : is a principal typing for M.

3 Recursive de nitions

We now add recursive de nitions to our language: a term of the form ( xM) represents the program x such that x = M, where M may contain occurrences of x.
As we remarked in the introduction, the principal typing property suggests that we type recursive de nitions by a rule of the following form.

(rec)

A fx : g ` M : A ` ( xM) :

82;1

The rule (rec) can type strictly more terms than the rule (rec-simple) of

ML. For example, the
P2 + (rec-simple):

following

term

is

typable

in

P2

+

(rec),

but

not

in

( x:( yz:z)(xx)) : 8t:t ! t:

10

The self-application xx cannot be typed if x is assigned just a simple type. However, (rec) cannot type as many terms as (rec-poly). For example,
the term ( x:xx) has type (8t:t) in ML+(rec-poly), but it is not typable with our rules.
It is interesting to compare (rec) with a rule, (fix'), that Mycroft 26] suggested in the context of ML:

(fix')

A ` x1

xn:M0 : 1 ! A ` ( xM) :

n! !

Here M is a term with n occurrences of x, M0 is M with each occurrence of x

renamed for all i

to a n.

fresh

variable

xi,

1; : : :; n;

are simple types, and Gen(A;

)

i

The idea behind Mycroft's rule is that each of the nite occurrences of x in M

may have a di erent simple type (so long as M can be shown to satisfy those

types). The same idea explains the typing power of (rec). Note, however, that

this idea was not the motivation for (rec). Instead, (rec) arose as an instance

of a general rule motivated by the principal typing property. Other interesting

typing rules may arise as instances of the general rule, in type systems other

than P2.

Mycroft's rule is actually more powerful than (rec). The side condition,

GiTnheAne(,tAeinr;mcl)u(dinxg:ix,txpy)pereimsvoiatnrseiapbllteaoscbeaepwpgheeeanrreeirnatghliiizsnemdthabekyeasi.nayTdthiyispeeirsevnnacoreti:aabiltlleoiwsnoetydtpabapybpl(eerawericint)hg.

(fix') but not (rec). For a more practical example, consider the following ML

code. It comes from the ML mailing list, and has arisen in practice.

datatype 'a T = EMPTY | NODE of 'a * ('a T) T

fun collect EMPTY = nil | collect (NODE(n,t)) = n :: flatmap collect (collect t)

Here 'a T is a polymorphic tree type, and flatmap is the mapping function of type ('a -> 'b list) -> 'a list -> 'b list. The function ,collect which collects all the labels of an 'a T and returns them in an 'a list, is typable with (rec-poly) and with (fix'), but not with (rec). Of course, we could generalize our rule along the lines of (fix'):

(rec')

A fx : g ` M : A ` ( xM) :

Gen(A; ) 82;1

The system would retain principal typings and decidable type inference, but for simplicity, we stay with (rec).

11

(letrec-simple)

(8j

2

I) A

`

(AAletrffexxciif::xGiie=jni(MA2;iIjgii)`2j MiI2gj

:
Iing

j
`

( M

M) :

j:

2

T0)

(letrec-var)

8j

2

I A

`A(letfrxeic:

xi j
fi

i 2 Ig = Mi

`
ji

M2 jI

:
g

inj

( xi0

)j:

82;1 i0

j)

i0 2 I

(letrec)

8j

2

I A

`AA(l`e^tfrx(eilce:tfrxieijc=if2xMiIi=gj`Mi N2i

: ji Ig

2I in

g
N

in
):

xj

)

:

j

N 62 fxi j i 2 Ig

Figure 3: Rules for typing mutually recursive de nitions. The rule (letrec-
simple) is used by ML, while P2 uses (letrec-var) and (letrec).

3.1 Mutual recursion

In order to support the applications of principal typings in the next section, we add mutually recursive de nitions to the language. Such de nitions are written

(letrec x1 = M1; : : :; xn = Mn in N)

or

(letrec fxi = Mi j i 2 Ig in N);

wheTrehealtlyopfintgheruxliesafroerdliesttrinecct.are given in Figure 3. ML uses the rule (letrec-

simple) to type mutual recursion. In (letrec-simple), the recursive de ni-

tions must be typed under the assumption that the recursive variables have

simple type. In typing the body of the letrec, however, the types of the recur-

sive variables can be generalized, so that they can be used polymorphically.

ti

We cannot ed types to

use (letrec-simple) with P2, because
appear in type environments. And it is

nPo2tdeoaessilynoatdpaeprtmedittqouPan2-.

In ML, the polymorphic type Gen(A; i) of xi is easily obtained from the simple

tPiosyf2pnaeIionsntyssiitometumaesmrdeemd,eidnoitiu(naelretrtesrtyelurpycleitenccislogefnBaotrrh(VePhinojr2w2eNcaJurt)eorjsb)icgv,aaeewsntedhddbeeireroeennceietxttalihpyocerhnferfssoo.sjlmelTdoishweaiiinnntegoqitnueo(rsbiVmvtsaaejsnl2revcJnoeafttojioto)fhf.nGeG:eettnyhn(pe(AAitn;y;gpisi)i).nfogiIntrs

terms (letrec B in x), where x is a variable de ned by B. Formally, for any

B = fx1 = M1; x2 = M2; : : :; xn = Mng and M = (letrec B in N), we de ne

Mhh ii to be the term

Mhh ii = (let x... 1 = (letrec B in x1) in Nxn):= (letrec B in xn)

The following lemma is easily proved.

12

Lemma 10 In ML + (letrec-simple), A ` M : i A M :` hh ii .

This is the intuition behind the rules (letrec-var) and (letrec) of Figure 3. (letrec-var) is a straightforward generalization of the rule (rec) for terms
of the form (letrec B in x), where x is a variable de ned in B. Lemma 10 suggests that we type other letrec expressions by a rule of the form

A ` hhletrec B in Nii : A ` (letrec B in N) :

(N is not de ned by B)

Our rule (letrec) is obtained simply by desugaring the let-expression formed

by hh ii into abstractions and applications, and considering how the resulting

term would be typed by
uPsR2inWfgoerthtwehrenitosetyasttR2ieomnfoAPr 2t`h+^e

(Msaybs:ts(e)Vmain2dI2(i+a) p(tpor)ea.cbW-bsreiemvmpiaaltkeee)(t+8hie(2lreuItl)erAmec`o-rsMeimco:pmliep. )a,ctanbdy (rec) + (letrec-var) + (letrec).

Theorem 11 If M is typable in R2 , then M is typable in PR2 .

tDoePR2nibtiyoand1d2ingTthhee

type inference algorithm following cases.

of

De

nition

7

can

be

extended

If M = ( xN) and hA; i 2 PP(N), then:

{ If x 62 dom(A), and U 2 MGS(f tg) where t is a fresh type
variable, then hUA; Gen(UA; U )i 2 PP(M).
{ If x 2 dom(A) and U 2 MGS(f A(x)g),
then hUAx; Gen(UAx; U )i 2 PP(M).

If M = (letrec fxi = Mi j i 2 Ig in xi0), where i0 2 I,
and hUAAA0002i=;=MPiAiG0i22SIP(fAfPxi(i,iM: tii)Ajfxo00r(ix62ii)2djoIi,m2(IAg0)),; ti freshg,
and A = U A0f0xiji2Ig, then hA; Gen(A; U i0)i 2 PP(M).

If M = (letrec fxi = Mi j i 2 Ig in N), where N 62 fxi j i 2 Ig, and
hA; i 2 PP(hhM ii), then hA; i 2 PP(M).

Theorem 13 (Principal
hA; i 2 PP(M) such that

typings)
A`M :

If is

Ma pirsintycpipaablletyipninPgR2f,otrheMn

there is
in PR2 .

a

pair

13

An important limitation of our rules for mutual recursion is illustrated by the following well-known example of Mycroft 26]:

map =
squarelist = complement =

f: l: if null l then nil else f(hd l) :: map f (tl l)
l: map ( x: x x) l l: map ( x: not x) l

This program is not typable under our rules (or ML's rules) when presented as a

single, mutually recursive de nition. The function map is used polymorphically

by the other functions, and our rules do not allow su cient polymorphism for

the program to type. Note that map does not depend on the other functions; if

map is placed in a separate recursive de nition, the program can be typed by

our rules.

Thus to type an unordered set of de nitions, it is necessary to examine the

call graph of the program to determine an order in which to type This complication must be addressed by the applications of the

tnheextdesecntiitoionn.2s.

4 Separate compilation
Any separate compilation system manages a collection of small program fragments that together make up a single large program. Two questions must be answered by such a system. First, does the program as a whole type check? And second, how do we generate code for each program fragment, and how can we combine these code fragments into an executable program?
We consider each of these questions in turn.
4.1 Incremental type inference
The problem of incremental type inference 1] can be described as follows. A user develops a program in an incremental fashion, by entering a sequence of de nitions to a read-eval-print loop:
x1 = M1; x2 = M2; x3 = M3; : : : After each de nition is entered, the compiler performs type inference to ensure the type-correctness of the partial program. De nitions may be re-de ned as the programmer detects and corrects bugs, and they may be mutually recursive. Most relevant, a \bottom-up" style of program development is made possible by allowing de nitions to refer to other de nitions which have not yet been entered.
Incremental type inference is thus the type checking task of separate compilation on an extremely ne scale: not just every module, but every de nition is typed and compiled separately.
2A generalization of our rules along the lines of Mycroft's (fix') could handle the map example, but not all such examples.

14

Consider initions have

abepeanrtidailscparrodgerda.mTxo1

c=hecMk1t;h:a: t:;

txhne

=proMgnra,mwhiserwe edllu-tpylpiceadt,e

defit is

su cient to perform type inference on the expression

(letrec B1 in (letrec Bm in 0) )

derived from the call graph of the program: each Bi is a strongly connected

component (SCC) of mutually recursive bindings, and the Bi are topologically

sorted.

This can be accomplished by any type inference algorithm that works on

terms with free variables. But this is not enough to solve the incremental

problem e ciently: when the user enters the next de nition, xn+1 = Mn+1,

we must do better than just running the type inference algorithm on the new

expression

(letrec B10 in (letrec Bm0 0 in 0) ):

A close inspection of typings are the key to e

thceiePntR2

type inference algorithm will incremental type inference.

show

that

principal

If P = (letrec B1 in
the variables de ned by equivalent of Lemma 10,

teyapceh(lienBtfierreaecnrecBedmfeonirnoPte0d)is

xeqi);u1;iisv: a:o:lue;nrxtip;tnaoir,ttiytahpleepnirnobfgyerraetmnhce,eaPfnoR2dr

the expression

Phh ii = (let x... 1;1 = (letrec B1 in x1;1) ...x1;n1 = (letrec B1 in x1;n1) ...xm;1 = (letrec B1 in xm;1)
in 0x)m;;nm = (letrec Bm in xm;nm)

where let's are desugared into applications of abstractions.
We now show that type inference for such an expression is equivalent to solving a subtype satisfaction problem constructed from the principal pair of
each (letrec Bi in xi;j).

De nition 14 For any term M, we de ne the set L (M) inductively as follows.

If M = ( xM1)M2,

and hA1; ; i 2 L (M1)

(hAV2i2; I

2i 2 PP(M2)

i) =

t A1(x)

if x 62 dom(A1) and t is fresh,
otherwise.

(8i 2 I then hA1 +

)(PSii2rIenSaimA2e)s;

FTV(A2; ; fSi

2)
2

to fresh type variables i j i 2 Igi 2 L (M ).

15

Otherwise, hA; ; ;i 2 L (M) i hA; i 2 PP(M).

Lemma 15 hA; i 2 PP(M) i for some A0; 0; and U, Ah 0; 0; i 2 L (M), U 2 MGS( ), and hA; i = hUA0; Gen(UA0; U 0)i.

Therefore, we can perform type inference for P by calculating hA; ; i 2

L (hhP ii), and nding a solution to . And L ( P )hh ii is calculated from the

principal pair of each (letrec Bi in xi;j).

Now consider the incremental case. When the user enters the next de nition,

xn+1 = Mn+1, we must perform type inference on a new partial program, P 0.

Just as before, this means requires the principal pair
We now argue that L

(cohahfPlceu0aiilca)htci(nalgnetabreencecwoBni0s0 t0irnfurocxtmie0d;jL0)in.(chhrPem0iie)n.tAalnlyd.

again, this First note

that the new de nition may not change the SCC's of the existing call graph:

the SCCs change only when the new de nition is mutually recursive with a

p(olfree(tvlreioetucrseBdcieBininiixtniio;jxn)i;.;jaS)noidsmtuhonsectnho,afbntyegnet,hd(e.leptrrineccipBai0l0

in xi0;j0) will equal
typing property, the

some previous principal pair

We even bene t if the SCC's change. SCC, we must calculate the principal pair

If of

B(le=trfexcif=xi

Mi j i = Mi

2
ji

Ig is I2 g

a new
in xj)

for all j 2 I. This involves computing PP(Mi) for each Mi; but if i 6= n + 1, then by the principal typing property, PP(Mi) is unchanged.

Thus the principal pair for each de nition need only be computed once, as it

is entered by the user; it does not need to be recomputed at each new de nition

or re-de nition. This is not the case in the system of Aditya and Nikhil, where a

new de nition may cause the entire program to be reprocessed (see 8], p. 104).

We must also calculate a solution to the new satisfaction problem. How-

ever, the new problem may be almost identical to the previous problem. In

particular, if the new de nition does not change the SCCs of the call graph,

the new satisfaction problem will be a superset of the old problem. We may be

able to incorporate large parts of the old solution into the new solution. Our

algorithm for subtype satisfaction, described in Appendix B, solves problems by

transforming them into equivalent, simpler problems until a solution is reached.

Such an algorithm is ideally suited to incorporating parts of the old solution.

The transformations that applied to the old problem will, for the most part, be

identical to the transformations applicable to the new problem.

Finally, we remark that the SCCs and topological sort may be computed

incrementally by o -the-shelf algorithms 10, 23].

4.2 Smartest recompilation
Once we have solved the type checking task of separate compilation, we face the task of code generation. Types determine data representations, calling conventions, and other implementation details. Thus we regard compilers as functions from typing judgments to machine code. For example, the compilation of a

16

module M that imports a module x can be written Compile(fx : g ` M : ) = hmachine code for Mi:
There are two di culties with this strategy. First, the compiler requires as input a typing judgment, or, at least, the types of external variables. The typical solution is to require the user to supply the types. A better solution is
afovraialatbelreminMP2w,iwthhefrreeetvhaericaobmlepxil.er itself can infer a judgment fx : g ` M :
The second di culty arises when we need to link all of the code fragments together into a single program. In particular, consider recompilation, in which a user changes a single module x and the system attempts to recompile as small a portion of the entire program as possible. Certainly the de nition of x must be recompiled. Moreover, an unchanged module M that imports x may have to be recompiled: if the type of x changes, then the typing judgment of M, and thus its compiled output, changes.
This is where principal typings help. Suppose that we have compiled a module M by compiling its principal typing, A ` M : . At link time, we discover that in order to be consistent with the rest of the program, we should instead have compiled M by a di erent typing, B ` M : . The principal typing
property tells us that the second judgment is an instance of the rst: in P2,
it can be obtained by substitution and subsumption from the principal typing. More formally,
hB; i = ChA; i; where C is an operator that applies substitution and subsumption to the pair hA; i.
Stating the problem in this way lets us study the operator C in isolation. The operations of substitution and subsumption speci ed by C can be implemented via coercions. These coercions can be \wrapped" around the code generated for the typing A ` M : at link time, making it behave like code generated for B ` M : . That is,
Compile(B ` M : ) = Link(C; Compile(A ` M : )); where Link produces machine code that implements the coercions speci ed by C.
Using this strategy, a module need not be recompiled unless its de nition changes. This property was dubbed smartest recompilation by Shao and Appel 27]. They achieved smartest recompilation for ML by relating ML to a
restriction of P2 with principal typings.
Shao and Appel identi ed the following problem with smartest recompilation. If a module references many free variables, e.g., functions from the standard library, then the type environment of the principal typing becomes large. This can be alleviated in the following way. Let B be a type environment speci-
fying the T82 types of our library functions. We modify our type system to use
two type environments, so that typings are of the form A; B ` M : :
17

We modify our old rules to ignore this new type environment, and add a rule that allows us to use it:

(var-new) A; B fx : g ` x :

This system does not have principal typings, but it does have a useful \weak" form of principal typing property: given a term M typable in type environment B, there exists a typing A; B ` M : representing all possible typings for M in B. We say that M has a principal typing with respect to the type environment B, and that we have smartest compilation with respect to B. Since B only speci es types for identi ers that are relatively stable, we gain most of the bene ts of full smartest recompilation.
As an aside, we remark that this immediately suggests an extension to the type system: restore let-expressions to the language and add the rule

(let)

A;

B

`M A; B

:
`

; A;
(let x

Bx =M

fx
in

: g` N) :

N

:

We call this a \rank 2.5" system, since it lies between ranks 2 and 3. For instance, it can type a term that is untypable in rank 2:

let g = ( x:xx) in g( y:y) : 8t:t ! t:

We will not pursue this a more general system,

further, because we
called P, that does

already not rely

konnolwet-hpoowlytmooerxptheinsdmP. T2 htoe

description of P will appear in a future paper.

We do not claim that we have solved the smartest recompilation problem

for Standard ML. Standard ML has a rich module system, with type com-

ponents in modules, and generative, user-de nable, recursive datatypes. Our

simple language does not support such features (nor does the work of Shao and

Appel 27]). However, we have identi ed principal typings, or some equivalent,

as the key ingredient of such a system.

5 Error messages

Up until now, we have concentrated on one bene t of principal typings: a term

can be given a type without regard to the de nitions of its free variables.

The ip side of this bene t is that a de nition can be typed independently

of its uses. We now show how this allows us to produce accurate error messages

when our type inference algorithm is faced with a program containing type

errors.

Consider a de nition, ( xM)N, in which some uses of the variable x cause

type errors: they require types that N cannot satisfy. To perform type inference,

we calculate the principal typings of both the operator and the operand, say

A ` ( xM A0 ` N :

) 0:

:

(Vi2I

i) !

;

18

By the principal typing property, we can calculate these principal typings in any order. To complete type inference, we simply check whether we can satisfy

= fSi 0 i j i 2 Ig;

where each Si renames FTV(A0; 0) to fresh type variables. At this point we

will not

discover all of the type errors related to x: be able to satisfy the constraints expressed

for by

some i, i. If we

tthaeketycpaereStio

0 will label

each constraint with the use of x that produced it, we can output the o ending

uses, all in one batch.

Contrast this with the situation in ML. Assuming the de nition is polymor-

phic, we must perform type inference on a let-expression (let x = N in M).

Without principal typings, we are forced to rst calculate the principal type, ,

of N. We then process M, instantiating at each use of x. Errors are reported

as they are encountered, at each use. But note, the errors of one de nition can

be interspersed with errors for other de nitions, or with run-on errors. And the

type may have been specialized for that particular (erroneous) use, leaving

the programmer to understand a type only remotely related to the type of

the de nition.

6 Does ML have principal typings?

We have deliberately that it can be applied

sttoatmedantyhedipreirnecniptatlyptyepsiynsgtepmrosp.3erItny

in a broad particular,

way, so we have

not precisely de ned what it means to represent all possible typings, because

this will vary from one type system to another.

This imprecision makes it impossible for us to prove that a given type system

lacks the principal typing property. Nevertheless, we do not know of a sensible

formulation of principal typings for ML, and in particular, ML does not have

principal typings in the sense of our De nition 3. For example, consider the

following ML typings of the term xx.

fx : 8t:tg ` xx : 8t:t; fx : 8t:t ! tg ` xx : 8t:t ! t:

Our intuition is that a principal typing expects less of its free variables and provides more than any other typing. We certainly cannot hope to derive a more general type for the term xx than (8t:t), so the rst judgment provides more than the second. However, the rst judgment also makes a strong requirement on x: the type environment indicates that it too must have type (8t:t). Thus the second judgment expects less than the rst, and neither typing is more general than the other. Moreover, there is no typing more general than both the typings above. The obvious candidate,

fx : 8t:t ! tg ` xx : 8t:t;

3In fact, we could have stated it more broadly still: we assumed typing judgments were of the form A ` M : , but this is not always the case.

19

is not derivable.

Why doesn't ML's principal type property imply the existence of principal

typings? You might think that the principal typing of a term could be obtained

from the principal type of the -closure of the term. But ML has only a restricted

abstraction rule:

A fx : 1g ` M : 2 A ` ( xM) : 1 ! 2

1; 2 2 T0

In ML, we cannot abstract over variables of polymorphic type; the only way of introducing polymorphic variables is through let-expressions.

7 Living without principal typings

If we want to work in a language lacking the principal typing property, we may

still achieve some of its bene ts by nding a \representation" for all possible

typings. That is, we may relax the principal typing condition that the repre-

sentatives themselves be typings.

Pushed to an extreme, this is nonsense|after all, M itself is a represen-

tation of all typings of M! But there is a middle ground. For example, the

\representation" may be a typing in another type system.

This idea was the basis of the smartest recompilation system of Shao and

Appel 27]. They de ned a type system with the following property: for any ML

typable term M, there is a judgement in the Shao-Appel system that encodes

all of the ML typings for M, in an appropriate sense. They did not prove a

principal typing property for their system, but it is essentially identical to a

system of Damas 6]. Damas proved a principal typing theorem for his system,

and showed that it types exactly the same terms as ML.

Hcsahoouo\wwtnTretnhuveeerete"rhsx,yaaastbmt2sePptmdr2laeoschexPtsaixso2nntoaphtnrraiduhntlacewiv;p2eeatapulhrrsitesieyndapicsiisfnpoengcarosolMtntadynaLpdeicaxnotlagsynomsptrewipanslodeertickxohtfsaeicotfsthonelir,ynssbpteeh2hc.oeeafnUsuoDasnmmeeliekeinnnetioetManirod.mLndW,si3taei.o2shnThahvat2oees.

lacking principal typings, 2 And for a third example,

PlaaclskbseprgrinacnidpaSlctoytpt4esha1v9e].shown

that

the

recursive

type system of Amadio and Cardelli 3] types exactly the same terms as a type

system based on constraints 7]. Palsberg has shown that the Amadio-Cardelli

system does not have principal typings, and Jim has shown that the constraint-

based system does have principal typings.

8 An extension

mThoeresytesrtmems.PT2hies

the rank 2 fragment of a type system, P, that can type many description of P is beyond the scope of this paper. However,

we will present a few examples of its typing power.

4Personal communication, September 1995.

20

If we de ne terms M and N by
M = ( g:g( f:f( x:x))); N = ( w:w( y:yy));
then the following typings hold in P:
M : 8t:((8s:((8u:u ! u) ! s) ! s) ! t) ! t; N : 8u:((8st:(s ^ (s ! t)) ! t) ! u) ! u; MN : 8t:t ! t:
Only M is typable in ML or P2, and only at less informative types. Note that
in the type of M, the inner quanti er, 8u, is under the left of four arrows, well beyond rank 2.
The system P has the principal typing property, decidable type inference,
and a rule in the style of (rec) for typing recursive de nitions. The crucial technical advance is a way of solving subtype satisfaction problems for types with quanti ers and intersections at unlimited depth.

9 Related work

Principal typings are not a new concept. A number of existing type systems

have principal typings, including the simply typed lambda calculus 31], the

system of recursive types 5], the system of simple subtypes 25], and the system

of intersection types 4]. Our contribution is to highlight the practical uses

of the principal typing property, and to distinguish it from the principal type

property. A number of authors have published o hand claims that ML possesses

the principal typing property, despite the early remarks of Damas 6] to the

contrary.

The system of rank 2 intersection types is also not new, but as with the

principal typing property, it has attracted little attention. It was rst suggested

by Leivant in 1983 21], but he did not give a formal de nition of the type

inference algorithm or proof of correctness. In an oft-referenced 1984 paper 24],

McCracken gave a type inference algorithm for rank 2 of System F, inspired by

Leivant's ideas. This algorithm is incorrect. A correct algorithm for rank 2 of

System F was nally given by Kfoury and Wells 19] in 1993. Their algorithm is

completely unrelated to Leivant's algorithm. The earliest formal de nition and

proof of Leivant's algorithm was published in 1993, by van Bakel 29].

Our addition of top-level quanti cation is a useful technical improvement

to the rank 2 intersection system. In particular, the simplicity of our rule for

typing recursive de nitions is due to the power of quanti ers and the subtyping

rdeelantiiotinons82w;1it.hIotuits

possible to formulate an top-level quanti cation,

equivalent rule for typing recursive but the machinery is cumbersome

and simply duplicates the functionality of the quanti ers.

We have shown that rank 2 of System F is closely related to our type sys-

tem. However, rank 2 of System F does not have principal types or principal

21

typings 19]. Launchbury and Peyton Jones 20] describe an interesting constant with a rank 2 System F type. Rank 2 System F types are not part of our type system, and we do not know how to handle their constant without resort to a special typing rule. This is the same solution employed by Launchbury and Peyton Jones.
The system of Aiken and Wimmers 2] uses ML's let-polymorphism, and, therefore, we believe it does not have principal typings. The subsystem without let-polymorphism, though, is still of interest, and may have principal typings (but this is not clear). The constraint-based systems of Jones 12], Kaes 14], and Smith 28] are also based on ML.
Constraint satisfaction, including subtype satisfaction, is an important component of each of these systems. Our method for solving constraints involving qwuitahntiinteerrsse(ct8io2n;1s-,sathtiissfaiscttihone)ciesnatrsaigl nmi eccahnatnaisdmvabnycewohviecrhthleets-eposylysmtemorsp.hAislmonigs
avoided and principal typings are achieved. In our work on the system P, we
will show how to solve some subtype satisfaction problems for types with quanti ers and intersections at unlimited depth, giving type inference for a system with a much richer class of types.

10 Conclusion

We have shown that the principal typing property has practical applications,

including smartest recompilation, incremental type inference, and accurate type

error messages. Inspired by the principal typing property, we proposed a new

rule for typing recursive de nitions. The type inference algorithm of our system

Pth2e

is easily extended to new rule, resulting in

infer principal a type system

typings for recursive de nitions under with decidable type inference that can

type some interesting examples of polymorphic recursion.

A number of languages, including ML, seem to lack the principal typing

property. In such languages, we may achieve some of the bene ts of principal

typings by nding a way to represent all possible typings for a term. In partic-

ular, a term's principal typing in one type system may serve as a representative

of all of its typings in another type system. This technique serves for
typings can be represented by principal typings in P2.

2, whose

Although our primary goal was to draw attention to the principal typing

property, a secondary contribution is to draw attention to the system of rank 2

intersection types, which also seems to have been overlooked. Our particular

version of this system, P2, makes an important technical contribution by show-

ing how to solve subtype satisfaction problems for types containing quanti ers.

Our types only have quanti ers at top level, but the method is easily extended

to types with quanti ers at unlimited depth, as we will show in a forthcoming

paper.

Acknowledgments. This paper has bene ted from the comments of Assaf
Kfoury, Albert Meyer, Jens Palsberg, Mona Singh, Phil Wadler, and the POPL

22

referees. We thank Fritz Henglein for pointing out Mycroft's rule (fix') and the work of Damas.

References

1] Shail Aditya and Rishiyur Nikhil. Incremental polymorphism. In Functional Programming Languages and Computer Architecture, volume 523 of Lecture Notes in Computer Science, pages 379{405. Springer-Verlag, 1991.

2] Alexander Aiken and Edward L. Wimmers. Type inclusion constraints and type inference. In Functional Programming Languages and Computer Architecture, pages 31{41. ACM Press, June 1993.

3] Roberto M. Amadio and Luca Cardelli. Subtyping recursive types. ACM Transactions on Programming Languages and Systems, 15(4):575{631, September 1993.
4] Henk Barendregt, Mario Coppo, and Mariangiola Dezani-Ciancaglini. A lter lambda model and the completeness of type assignment. J. Symbolic Logic, 48(4):931{940, December 1983.
5] Felice Cardone and Mario Coppo. Type inference with recursive types: Syntax and semantics. Information and Computation, 92(1):48{80, May 1991.
6] Luis Manuel Martins Damas. Type Assignment in Programming Languages. PhD thesis, University of Edinburgh, 1984.

7] J. Eifrig, S. Smith, and V. Trifonov. Type inference for recursively constrained types and it application to OOP. In Proc. Mathematical Foundations of Programming Semantics, 1995. To appear.

8] Shail Aditya Gupta. An incremental type inference system for the programming language Id. Master's thesis, Massachusetts Institute of Technology, November 1990. Available as MIT/LCS Technical Report TR{488.

9] Fritz Henglein. Type inference with polymorphic recursion. ACM Transactions on Programming Languages and Systems, 15(2):253{289, April 1993.

10]

Monika Rauch Henzinger and transitive closure. To

aanpdpeVaarleinriePrKoicn.g3.6FthulAlynnduyanlamSyimc bpi.coonnnFeocutinvditay-

tions of Computer Science, 1995.

11] Trevor Jim. Rank 2 type systems and recursive de nitions. Technical Memorandum MIT/LCS/TM{531, M.I.T. Lab. for Computer Science, August 1995.

12] Mark P. Jones. Quali ed Types: Theory and Practice. Cambridge University Press, November 1994.

23

13] Jean-Pierre Jouannaud and Claude Kirchner. Solving equations in abstract algebras: A rule-based survey of uni cation. In Jean-Louis Lassez and Gordon Plotkin, editors, Computational Logic: Essays in Honor of Alan Robinson, chapter 8, pages 257{321. MIT Press, 1991.
14] Stefan Kaes. Typing in the presence of overloading, subtyping, and recursive types. In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, pages 193{204, 1992.
15] A.J. Kfoury and J. Tiuryn. Type reconstruction in nite rank fragments of the second-order -calculus. Information and Computation, 98(2):228{257, June 1992.
16] A.J. Kfoury, J. Tiuryn, and P. Urzyczyn. A proper extension of ML with an e ective type-assignment. In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, pages 58{69, 1988.
17] A.J. Kfoury, J. Tiuryn, and P. Urzyczyn. Type reconstruction in the presence of polymorphic recursion. ACM Transactions on Programming Languages and Systems, 15(2):290{311, April 1993.
18] A.J. Kfoury, J. Tiuryn, and P. Urzyczyn. An analysis of ML typability. Journal of the ACM, 41(2), March 1994.
19] A.J. Kfoury and J.B. Wells. A direct algorithm for type inference in the rank 2 fragment of the second-order lambda-calculus. In Proceedings of the 1994 ACM Conference on Lisp and Functional Programming, pages 196{207, 1994.
20] John Launchbury and Simon L Peyton Jones. Lazy functional state threads. In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, pages 24{35, 1994.
21] Daniel Leivant. Polymorphic type inference. In Conference Record of the Tenth Annual ACM Symposium on Principles of Programming Languages, pages 88{98, 1983.
22] Harry G. Mairson. Deciding ML typability is complete for deterministic exponential time. In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, pages 382{401, 1990.
23] Marchetti-Spaccamela, Nanni, and Rohnert. On-line graph algorithms for incremental compilation. In Graph-Theoretic Concepts in Computer Science, International Workshop WG, 1993.
24] Nancy McCracken. The typechecking of programs with implicit type structure. In G. Kahn, D.B. MacQueen, and G. Plotkin, editors, Semantics of Data Types, volume 173 of Lecture Notes in Computer Science, pages 301{315, June 1984.
24

25] John Mitchell. Type inference with simple subtypes. J. Functional Programming, 1(3):245{285, July 1991.
26] A. Mycroft. Polymorphic type schemes and recursive de nitions. In Proceedings of the International Symposium on Programming, Toulouse, volume 167 of Lecture Notes in Computer Science, pages 217{239. SpringerVerlag, 1984.
27] Zhong Shao and Andrew W. Appel. Smartest recompilation. In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages 439{450, 1993.
28] Geo rey S. Smith. Principal type schemes for functional programs with overloading and subtyping. Science of Computer Programming, 23:197{ 226, 1994.
29] Ste en van Bakel. Intersection Type Disciplines in Lambda Calculus and Applicative Term Rewriting Systems. PhD thesis, Mathematisch Centrum, Amsterdam, February 1993.
30] Mitchell Wand. Finding the source of type errors. In Conference Record of the Thirteenth Annual ACM Symposium on Principles of Programming Languages, pages 38{43, 1986.
31] Mitchell Wand. A simple algorithm and proof for type inference. Fundamenta Infomaticae, 10:115{122, 1987.
32] Hirofumi Yokouchi. Embedding a second-order type system into an intersection type system. Information and Computation, 117(2):206{220, March 1995.

A Technical details of the type system

We use x; y; : : : to range over a countable set of (term) variables, and M; N; : : : to range over terms. The terms of the language are just the terms of the lambda calculus:

M ::= x j (M1M2) j ( xM):

Terms are considered syntactically equal modulo renaming of bound variables,

and we adopt the usual conventions that allow us to omit parentheses: appli-

cation associates to the left, and the scope of an abstraction x extends to the

right as far We use

as possible. s; t; u : : : to

We write range over

x1 xn:M a countable

fsoert,(Txv1,(

of

( xnM) )). type variables,

and

; ; : : : to range over types. We de ne several classes of types, each of which is

a restriction of the types with quanti cation and intersection:

::= t j ( 1 ! 2) j (8t ) j ( 1 ^ 2):

25

The constructor `^' binds more tightly than `!', e.g., ^ ! t means ( ^

)! sible.

t, If

a~tn=d

the scope t1; t2; : : :;

of a quanti tn, n 0,

er `8' and

extends as
2 T2, we

wfarirteto(8t~the)

right as for the

postype

(8t1(8t2(: : : (8tn ) : : :))).

A type environment is a nite set fx1 : 1; : : :; xn : ng of (variable, type)

epnavirisr,onwmheernetst.hWe veawriraibtelesAx(x1); :f:o:r;

xthneatryepdeisptainircetd.

We use A to with x in A,

range over type
dom(A) for the

set fx j 9 :(x : ) 2 Ag, and Ax for the type environment A with any pair for the

variable x removed. We write A1 A2 for the union of two type environments;

by A1

convention we assume that the domains
+ A2 as follows: for each x 2 dom(A1)

of

dAo1ma(nAd2A),2

are

disjoint.

We de

ne

8< A1(x) (A1 + A2)(x) = : AA12((xx)) ^ A2(x)

if if

x x

62 62

ddoomm((AA12));;

otherwise.

We write Gen(A; ) for the 8-closure of variables free in but not A.

B A subtype satisfaction algorithm

A uni cation problem is a satisfaction problem involving only equalities. Uni-

cation algorithms, such as Robinson's algorithm, can determine, for any uni-

cation problem, whether a solution exists, and, if so, produce a most general

solution. Two problems are equivalent if they have the same solutions.

lentWueniwcilaltsihoonwprhoobwletmo.tTrahnesftorramnsaform82a;t1i-osnatiissfdaectinoendpbryobrluelmesionftothaen

equivaform

) 9~s:P:

The rules may need to introduce fresh type variables, that is, type variables that do not appear on the left-hand side. These variables will appear in the variables ~s of the right-hand side (but they are not the only source of variables in ~s).
The rules are used to de ne a rewrite relation on problems:

9~s:P 0 ] f

g

) )

9~t:P 9~s ]

~t:P

0

P

The operator the variables

~t`]m' uisstdbisejofirnetshun(itohnis;

on the right of can always be

the consequent, it means achieved by renaming).

that

The problem

rules for transforming are given in Figure 4.

a To

se8e2;1t-huanti

cation problem into these rules constitute

a uni cation an algorithm

for producing an equivalent uni cation problem, observe that the rules preserve

solutions, that the system is terminating, and that normal forms contain no

inequalities, and thus are uni cation problems.

26

( 1 ! 2) t ) 9iftt11;;tt22:fat1re fres1h; 2 t2; t = t1 ! t2g

( 1 ! 2) ( 1 ! 2) 1) f 1; 2 2g

( 1 ^ 2) ) f 1; 2g

t

t =) f

g

if is a simple type

(8t )

t) 9 f

g

if is not a ^-type, and t is not

free in

Figure 4: Transformational rules for 82;1-satisfaction problems

A uni cation algorithm in a transformational style,5 taken from 13], is given

in Figure 5. The normal forms of the rewrite system are in solved form, a set of

equations that corresponds immediately to a most general substitution. Note

the special problem F, used to denote failure of uni cation.

The combination of these two transformation systems is an algorithm for

nding most general solutions we obtain a decision procedure

to for

su82b;t1y-spaitnigsf:atcotisoene

problems. whether

a member of MGS(f g) and check whether it is the

As a special case,

id8e2n;t1ity,

compute (empty)

substitution.

exp5oTnheinstipaalritnictuhlearsiuzneiofcathtieoninaplugto.riItthims pisosinsieblectieonstp, ebceicfyauesectiheentsiuzneiofcathtieonouatlpgourtitmhamysbine this style, but in order to simplify the presentationwe use this more straightforward algorithm.
27

P = P] f

g)

P =1] f ! 2 1 ! 2g ) P f 1 = 1; 2 = 2g

P ] ft1 = t2g ) ft1 := t2gP ft1 = t2g if t1; t2 2 FTV(P ) and t1 6= t2

P ] ft = g ) F
if t 2 FTV( ) and 62 Tv

P ] ft = g ) ft := gP ft = g
if t 62 FTV( ), 62 Tv,
and t 2 FTV(P )

Figure 5: A set of transformational rules for solving uni cation of simple types.

28

