Deciding knowledge in security protocols
under equational theories
Martı´n Abadi a,b,1 and Ve´ronique Cortier c,2
aComputer Science Department University of California at Santa Cruz, USA
bMicrosoft Research, Silicon Valley, USA
cLoria/CNRS & INRIA Lorraine project Cassis, Nancy, France
Abstract
The analysis of security protocols requires precise formulations of the knowledge of pro-
tocol participants and attackers. In formal approaches, this knowledge is often treated in
terms of message deducibility and indistinguishability relations. In this paper we study the
decidability of these two relations. The messages in question may employ functions (en-
cryption, decryption, etc.) axiomatized in an equational theory. One of our main positive
results says that deducibility and indistinguishability are both decidable in polynomial time
for a large class of equational theories. This class of equational theories is defined syntacti-
cally and includes, for example, theories for encryption, decryption, and digital signatures.
We also establish general decidability theorems for an even larger class of theories. These
theorems require only loose, abstract conditions, and apply to many other useful theo-
ries, for example with blind digital signatures, homomorphic encryption, XOR, and other
associative-commutative functions.
1 Introduction
Understanding security protocols often requires reasoning about the knowledge of
legitimate protocol participants and attackers. As a simple example, let us consider
a protocol in which A sends to B a message that consists of a secret s encrypted un-
der a pre-arranged shared key k. One may argue that, after processing this message,
1 Abadi’s work was partly supported by the National Science Foundation under Grants
CCR-0204162, CCR-0208800, and CCF-0524078.
2 Ve´ronique Cortier’s work was partly supported by the RNTL project PROUVE-
03V360 and the ACI Jeunes Chercheurs JC9005. Corresponding author address: Lo-
ria, Campus Scientifique, BP 239, 54506 Vandoeuvre-les-Nancy cedex, Nancy, France;
Veronique.Cortier@loria.fr.
Preprint submitted to Elsevier Science 9 April 2006
B knows s. More interestingly, one may also argue than an attacker with bounded
computing power that does not know k but eavesdrops on the communications be-
tween A and B and sees the message does not learn s.
Accordingly, formal methods for the analysis of security protocols rely on defini-
tions of the knowledge of protocol participants and attackers. In those methods,
the knowledge of an attacker is used to determine what messages the attacker can
send at each point in time—it can send only messages it knows. Moreover, security
guarantees can be phrased in terms of the knowledge of the attacker. For example,
a guarantee might be that, at the end of a protocol run, the attacker does not know a
particular key, or that the attacker does not know whether a certain ciphertext con-
tains the plaintext “true” or “false”. For such applications, although the attacker is
typically an active entity that can learn by conducting experiments, the definition
of knowledge focuses on a particular point in a protocol execution.
Many formal definitions explain the knowledge of an attacker in terms of message
deduction (e.g., [26,30,34,31]). Usually, a set of messages S indicates what the
attacker has invented or received up to a particular point in a protocol execution;
these messages may be from multiple protocol sessions and even multiple proto-
cols, and may be obtained legitimately or by other means. Then, given such a set
of messages S and another message M , one asks whether M can be computed
from S. The messages are represented by expressions, and correspondingly the
computations allowed are symbolic manipulations of those expressions. Intuitively
these computations can rely on any step that an eavesdropper who has obtained
the messages in S can perform on its own in order to derive M . For example, the
eavesdropper can encrypt and decrypt using known keys, and it can extract parts of
messages.
Despite its usefulness in proofs about protocol behaviors, the concept of message
deduction does not always provide a sufficient account of knowledge, and it is
worthwhile to consider alternatives. For instance, suppose that we are interested in
a protocol that transmits an encrypted boolean value, possibly a different one in
each run. We might like to express that this boolean value remains secret by saying
that no attacker can learn it by eavesdropping on the protocol. On the other hand,
it is unreasonable to say that an attacker cannot deduce the well-known boolean
values “true” and “false”. Instead, we may say that the attacker cannot distin-
guish an instance of the protocol with the value “true” from one with the value
“false”. More generally, we may say that two systems are equivalent when an at-
tacker cannot distinguish them, and we may then express security guarantees as
equivalences. The use of equivalences is common in computational approaches to
cryptography (e.g., [25]), and it also figures prominently in several formal methods
(e.g., [5,29,3]).
Two systems that output messages that an attacker can tell apart are obviously dis-
tinguishable. Conversely, in order to establish equivalences between systems, an
2
important subtask is to establish equivalences between the messages that the sys-
tems generate (for example, between the encrypted boolean values). These equiva-
lences may be called static equivalences, because they consider only the messages,
not the dynamic processes that generate them. Analogously, the deduction rela-
tion should perhaps be called static deduction. Despite the static character of these
relations, they are useful in analyzing the dynamics of protocols and attacks. In par-
ticular, proof methods for properties of protocol behaviors often rely on deduction
(e.g., [31]), and process equivalences can be reduced to static equivalences plus
fairly standard bisimulation conditions [3] (see also [4,14]).
In this paper we study the decidability of deduction and static equivalence. We de-
fine a relation φ  M that means that M can be deduced from φ, and a relation
ϕ ≈s ψ that means that ϕ and ψ are statically equivalent; here φ, ϕ, and ψ are
all essentially lists of messages, each with a name, represented by formal expres-
sions. For generating these messages, we allow the application of a wide array of
functions—pairing, projections, various flavors of encryption and decryption, digi-
tal signatures, one-way hash functions, etc.. Indeed, our results do not make any as-
sumption on any particular cryptographic system beyond fairly general hypotheses
on the equational theory that is used for defining the properties of the cryptographic
operations.
Our results start with basic observations about the decidability of deduction and
static equivalence. Specifically, we demonstrate that, even for decidable equational
theories, φ  M and ϕ ≈s ψ can be undecidable. Moreover, we establish that
deduction can be reduced to static equivalence (not too surprisingly), but that the
converse does not hold. Therefore, we investigate hypotheses that would guarantee
decidability, allowing for the possibility that the decidability of ϕ ≈s ψ requires
more than the decidability of φ  M .
We identify a simple, syntactically defined class of theories for which φ  M and
ϕ ≈s ψ are both decidable in polynomial time. These theories, which we call con-
vergent subterm theories, are given by convergent rewriting systems with a finite
number of rules of the form M → N where N is a proper subterm of M or a
constant symbol. Convergent subterm theories appear frequently in applications;
in particular, standard axiomatizations of encryption, decryption, and digital signa-
tures yield convergent subterm theories.
Going further, we develop decision methods for φ  M and ϕ ≈s ψ under an even
larger class of equational theories. For this purpose, we assume only loose, abstract
conditions, rather than syntactic criteria on the theories. In this respect, we are
inspired by Comon-Lundh’s current investigations [19] (see Section 6). The general
decidability theorems that we obtain subsume the previous ones for convergent
subterm theories (with more difficulties and without the same complexity bounds,
hence the separate treatment of convergent subterm theories). They also apply to
many other useful theories, for example with blind digital signatures, homomorphic
3
encryption, XOR, and other AC (associative-commutative) functions. Several of the
decidability results that we obtain are new.
Checking that a particular theory satisfies our abstract conditions may involve some
work, though often less than direct proofs of decidability. In some cases, it may
also involve some (fairly elementary and pleasant) mathematics, such as facts on
Z-modules. We expect that some of the techniques that we employ in our examples
may be reused in the study of other theories.
The problem of deciding knowledge is particularly important in the context of al-
gorithms and tools for automated protocol analysis. Often, special techniques are
introduced for particular sets of cryptographic operations of interest, on a case-
by-case basis. For example, the classic Dolev-Yao result deals with a fixed, lim-
ited suite of public-key operations [24]; more recent decidability results deal with
XOR and modular exponentiation (e.g., [16,17,20]); many variants and combina-
tions that arise in practice have not yet been explored. On the other hand, other
algorithms and tools (e.g., [10–12]) allow much freedom in the choice of crypto-
graphic operations but their analysis of the knowledge of the attacker is not always
guaranteed to terminate. Decidability results under general equational theories have
been rare. Comon-Lundh and Treinen have studied the decidability of deduction
for a class of equational theories in which, for example, they allow the homomor-
phism property enc(〈u, v〉, k) = 〈enc(u, k), enc(v, k)〉 but not the inverse property
I(I(x)) = x [21]. These examples illustrate that their class is incomparable with
the class of convergent subterm theories; we do not know how their class relates to
our results for other theories. Delaune and Jacquemard have shown that deduction
is decidable for a subclass of convergent subterm theories, also considering active
attacks [22]. Chevalier and Rusinowitch have developed an algorithm for combin-
ing decision procedures for equational theories, considering active attacks and a
bounded number of sessions [18]. These results do not address static equivalence,
nor associativity and commutativity properties. In fact, even results on specific the-
ories with AC functions have been rare. Three important exceptions are decidability
results for deduction with XOR [17,20], in an Abelian group [20], and under certain
“AC-like” theories with homomorphisms [28]. We discuss other recent and ongoing
related work in Section 6.
The next section, Section 2, introduces notations and definitions. Section 3 com-
pares  and ≈s. Section 4 focuses on convergent subterm theories and gives our
main decidability results for these theories. Section 5 considers the larger class of
equational theories. Section 6 concludes. The Appendix contains proofs.
Parts of this paper have been presented, in preliminary form, at ICALP 2004 and
CSFW 2005 [1,2]. This paper represents a synthesis and an extension of the work
presented there. (Basically, Sections 3 and 4 correspond to the ICALP 2004 pa-
per [1] while Section 5 corresponds to the CSFW 2005 paper [2], with improve-
ments in presentation and additional technical material throughout.)
4
2 Basic definitions
Next we review definitions from previous work. We mostly adopt the definitions
of the applied pi calculus [3]. In Section 2.1 we give the syntax of expressions.
In Section 2.2 we explain a representation for the information available to an ob-
server who has seen messages exchanged in the course of a protocol execution. In
Section 2.3 and 2.4 we present the relations  and ≈s, which (as explained in the
introduction) provide two formalizations of the knowledge that the observer has on
the basis of that information.
2.1 Syntax
A signature Σ consists of a finite set of function symbols, such as enc and pair, each
with an arity. We write arity(f) for the arity of a function symbol f , and let ar(Σ)
be the maximal arity of a function symbol in Σ. A function symbol with arity 0 is
a constant symbol.
Given a signature Σ, an infinite set of names N , and an infinite set of variables, the
set of terms is defined by the grammar:
L,M,N, T, U, V ::= terms
k, . . . , n, . . . , s name
x, y, z variable
f(M1, . . . ,Ml) function application
where f ranges over the function symbols of Σ and l matches the arity of f . A
term is closed when it does not have free variables (but it may contain names and
constant symbols). We write fn(M) for the set of names that occur in the term M .
We use meta-variables u, v, w to range over names and variables. The size |T | of a
term T is defined by |u| = 1 and |f(T1, . . . , Tl)| = 1 + ∑li=1 |Ti|. The DAG-size
|T |DAG is the number of distinct subterms of T .
A context C is a term with holes, or (more formally) a term with distinguished
variables that each occur at most once in the context. When C is a context with
n distinguished variables x1, . . . , xn, we may write C[x1, . . . , xn] instead of C in
order to show the variables, and when T1, . . . , Tn are terms we may also write
C[T1, . . . , Tn] for the result of replacing each variable xi with the corresponding
term Ti.
We equip the signature Σ with an equational theory E, that is, an equivalence rela-
tion on terms that is closed under application of contexts and under substitutions of
terms for both names and variables. (While non-standard, the requirement that E
be closed under substitutions of terms for names simplifies some technical details
5
and has been harmless in applications.) We write M =E N when M and N are
closed terms and the equation M = N is in E. We use the symbol == to denote
syntactic equality of closed terms. As in these definitions, we often focus on closed
terms for simplicity.
2.2 Assembling terms into frames
At a particular point in time, while engaging in one or more sessions of one or
more protocols, an attacker may know a sequence of messages M1, . . . , Ml. This
means that it knows each message but it also knows in which order it obtained the
messages. So it is not enough for us to say that the attacker knows the set of terms
{M1, . . . ,Ml}. Furthermore, we should distinguish those names that the attacker
knows from those that were freshly generated by others and which may remain
secret from the attacker; both kinds of names may appear in the terms.
In the applied pi calculus, such a sequence of messages is organized into a frame
νn˜.σ, where n˜ is a finite set of names (intuitively, the fresh names), ν is the restric-
tion operator from the pi calculus, which intuitively introduces fresh names, and σ
is a substitution of the form:
{M1/x1, . . . ,Ml/xl} with dom(σ) def= {x1, . . . , xl}
The variables enable us to refer to each Mi, for example for keeping track of their
order of transmission. We always assume that the terms Mi are closed. The size of
a frame φ = νn˜.{M1/x1 , . . . ,Ml/xl} is |φ| def=
∑l
i=1 |Mi|. The names n˜ are bound in φ
and can be renamed.
2.3 Deduction
Given a frame φ that represents the information available to an attacker, we may
ask whether a given closed term M may be deduced from φ. This relation is written
φ  M (following Schneider [34]). It is axiomatized by the rules:
if ∃x ∈ dom(σ) s.t. xσ = M
νn˜.σ M s ∈ n˜νn˜.σ  s
φ M1 · · · φ  Mk
f ∈ Σ
φ  f(M1, . . . ,Mk)
φ M M =E M ′
φ M ′
Since the deducible messages depend on the underlying equational theory, we write
E when E is not clear from the context. Intuitively, the deducible messages are
the messages of φ and the names that are not protected in φ, closed by equality
6
in E and closed by application of functions. The names that are protected in φ
may however appear in deducible messages, as an example illustrates below. When
νn˜.σ M , any occurrences of names from n˜ in M are bound by νn˜ (so νn˜.σ  M
could perhaps be written νn˜.(σ M)).
We have the following characterization of deduction:
Proposition 1 Let M be a closed term and νn˜.σ be a frame. Then νn˜.σ  M if
and only if there exists a term ζ such that fn(ζ) ∩ n˜ = ∅ and ζσ =E M .
As an example, we consider the equational theory of pairing and symmetric encryp-
tion. The signature is Σenc = {pair, enc, fst, snd, dec}. As usual, we write 〈x, y〉
instead of pair(x, y). The theory Eenc is defined by the axioms:
fst(〈x, y〉) = x snd(〈x, y〉) = y dec(enc(x, y), y) = x
Let φ def= νk, s.{enc(s, k)/x, k/y}. Then φ  k and φ  s. Furthermore, we have
k =Eenc yφ and s =Eenc dec(x, y)φ.
2.4 Static equivalence
Deduction does not always suffice for expressing the knowledge of an attacker, as
discussed in the introduction. For example, consider φ1 def= νk.{enc(0, k)/x, k/y}
and φ2 def= νk.{enc(1, k)/x, k/y}, where 0, 1 ∈ Σ are constant symbols. The at-
tacker can deduce the same set of terms from these two frames since it knows 0 and
1. But it could tell the difference between these two frames by checking whether
the decryption of x with y produces 0 or 1.
We say that two terms M and N are equal in the frame ϕ for the equational the-
ory E, and write (M =E N)ϕ, if and only if ϕ = νn˜.σ, Mσ =E Nσ, and
{n˜} ∩ (fn(M) ∪ fn(N)) = ∅ for some names n˜ and substitution σ. Then we
say that two frames ϕ and ψ are statically equivalent, and write ϕ ≈s ψ, when
dom(ϕ) = dom(ψ) and when, for all terms M and N , we have (M =E N)ϕ if
and only if (M =E N)ψ. We write ≈sE when E is not clear from the context.
In our example, we have (dec(x, y) =Eenc 0)φ1 but not (dec(x, y) =Eenc 0)φ2.
Therefore, φ1 ≈s φ2 although νk.{enc(0, k)/x} ≈s νk.{enc(1, k)/x}.
3 Comparison of deduction and static equivalence
We compare equality, deduction, and static equivalence from the point of view
of decidability. There is little hope that deduction or static equivalence would be
7
decidable when equality itself is not. (We note however that, for some artificial,
especially designed equational theories, deduction may be decidable while equality
is undecidable.) Therefore, we focus on equational theories for which equality is at
least decidable.
3.1  may be undecidable
Unfortunately, the decidability of equality is not sufficient for the decidability of
deduction and static equivalence. As evidence, let us consider the signature Σ =
{f, ·, [ , ] } where f is a unary functional symbol, · is a binary functional symbol,
and [ ] is a ternary functional symbol, and the equational theory Epc defined by:
x · (y · z) = (x · y) · z
[x1, y1]
z · [x2, y2]z = [x1 · x2, y1 · y2]z
f([x, x]y)= y
According to these equations, the symbol · is associative and distributes over the
symbol [ ], and any term of the form f([M,M ]k) can be collapsed to k. Note that
Epc is decidable since orienting the two last equations from left to right leads to
a confluent rewriting system. On the other hand, this equational theory enables us
to encode the Post Correspondence Problem (PCP) into the deduction problem.
The PCP is: given a finite number of pairs of words (ui, vi)1≤i≤n on the alphabet
A ⊂ N , does there exist a sequence s1, . . . , sk ∈ {1..n}∗ such that us1 · · ·usk =
vs1 · · · vsk? We have:
Proposition 2 Given the PCP instance (ui, vi)1≤i≤n on the alphabet A ⊂ N , we
define the substitution σ = {[ui, vi]k/xi}. Then there exists a solution to the PCP
instance if and only if νk.σ Epc k.
It follows:
Proposition 3 The deduction problem for Epc (Epc) is undecidable.
In order to prove Proposition 2, we characterize the terms deducible from νk.σ. Let
Pub be the set of terms built from the names N \ k and the function symbols f , ·,
and [ ] (the public terms). Let L be the set of all terms of the form:
[us1 · · · · · usp, vs1 · · · · · vsp ]k
where s1, . . . , sp ∈ {1..n}. We define the set WF of well-formed terms by the
grammar:
WF := L | Pub | f(WF) | WF ·WF | [WF,WF]WF
Note that if T ∈ WF then T = k (by induction on the construction of WF).
8
Lemma 1 The terms deducible from νk.σ are, modulo Epc, in the set WF of well-
formed terms.
This lemma is proved by induction on the construction of deducible terms.
• For every variable xi, xiσ is well-formed.
• For any name n ∈ N , if n = k, then n is well-formed, since n ∈ Pub.
• If T1, T2, and T3 are well-formed modulo Epc, then f(T1), T1 · T2, and [T1, T2]T3
are also well-formed modulo Epc.
• If T1 is well-formed modulo Epc and T1 =Epc T2, then T2 is also well-formed
modulo Epc.
We also characterize terms equal to k modulo Epc.
Lemma 2 Let T be a term. If k =Epc T and T = k then T is of the form:
f([T1, T
′
1]
Ui · · · [Tm, T ′m]Um)
with Ui =Epc k and T1 · · ·Tm =Epc T ′1 · · ·T ′m.
This lemma is proved by induction on the number of applications of equalities that
establish k =Epc T . The only equation that can yield k is f([x, x]y) = y, which
leads to a term of the specified form in the base case. In the inductive step, if
T =Epc T
′ with T ′ = f([T1, T ′1]Ui · · · [Tm, T ′m]Um), Ui =Epc k, and T1 · · ·Tm =Epc
T ′1 · · ·T ′m, and only one equation has been applied to establish T =Epc T ′, then
• either the equation has been applied inside one of the terms Ti, T ′i or Ui, and in
that case, the property holds immediately;
• or the equation has been applied above the terms Ti, T ′i , and Ui; and then either
T = k or only the two first equations can have been applied, and in either case
the property holds.
Lemma 3 Let T be a term. If T =Epc k then T contains k as a subterm.
This lemma is proved by induction on the size of T . In the base case, T = k, and the
property holds immediately. In the inductive step, T is of the form f([T1, T ′1]Ui · · ·
[Tm, T
′
m]
Um) with Ui =Epc k, by Lemma 2, and by induction hypothesis we obtain
that the terms Ui contain k as a subterm, so T contains k as a subterm. An easy
consequence of this lemma is that if T =Epc k then T /∈ Pub.
Returning to Proposition 2, let us assume that there exists a solution to a given PCP
instance. This assumption means that there exists a sequence s1, . . . , sp ∈ {1..n}∗
such that us1 · · ·usp = vs1 · · · vsp . Then
9
f(xs1 · · ·xsk)σ = f([us1, vs1 ]k · · · [usp, vsp]k)
=Epc f([us1 · · ·usp, vs1 · · · vsp]k)
=Epc k
so k is deducible.
Conversely, assume that k is deducible. By Lemma 1, k must be equal modulo
Epc to some term T ∈ WF. We show by induction on the size of T that there ex-
ists a solution to the PCP instance. By Lemma 2 and since T = k (since T ∈
WF), T must be of the form f([T1, T ′1]Ui · · · [Tm, T ′m]Um) with Ui =Epc k and
T1 · · ·Tm =Epc T ′1 · · ·T ′m. Since T cannot be public, T ∈ WF implies that the term
T ′ def= [T1, T ′1]
Ui · · · [Tm, T ′m]Um must be well-formed. If one of the terms Ui is well-
formed, we conclude by induction hypothesis, since Ui =Epc k. On the other hand,
if none of the terms Ui is well-formed, we proceed as follows. Since Ui =Epc k and
by Lemma 3, all the terms [Ti, T ′i ]Ui contain k as a subterm, so they are not public.
By inspection of the cases in the definition of WF, we deduce that each [Ti, T ′i ]Ui
must be in WF. Since none of the terms Ui is well-formed, we must have that each
[Ti, T
′
i ]
Ui is in L, so T ′ is actually equal (syntactically) to
[us11 · · · · · us1p1 , vs11 · · · · · vs1p1 ]
k · · · [usm1 · · · · · usmpm , vsm1 · · · · · vsmpm ]k
with
us11 · · ·us1p1 · · ·usm1 · · ·usmpm = vs11 · · · vs1p1 · · · vsm1 · · · vsmpm
for some sji ∈ {1..n}. Therefore, there exists a solution to the PCP instance.
3.2  reduces to ≈s
Next we show that deduction may be reduced to static equivalence by adding only
one free unary function symbol (a unary function symbol with no added equations).
Thus, the equational theory is basically unchanged in the reduction—it can be given
by a fixed set of equational axioms. We leave as an open problem whether the
reduction is always possible without even any change to the signature.
Proposition 4 Let E be an equational theory over some signature Σ. We define
Σ′ def= Σ unionmulti {h}, where h is unary, and let E ′ be the least equational theory that
extends E to terms over Σ′. Let φ = νn˜.{M1/x1 , . . . ,Ml/xl} be a frame over Σ, M be
a closed term over Σ, and k be a fresh name. Then φ E M if and only if
νn˜.{M1/x1 , . . . ,Ml/xl,h(M)/xl+1} ≈sE′ ν(n˜. ∪ {k}){M1/x1 , . . . ,Ml/xl,k/xl+1}
We derive that if ≈sE′ is decidable, then E is also decidable (with at most the
same complexity).
10
In order to prove the proposition, we first introduce some notation. We let σ =
{M1/x1, . . . ,Ml/xl}, so φ = νn˜.σ, and let φ1 = νn˜.σ1 with σ1 = {M1/x1, . . . ,Ml/xl ,
h(M)/xl+1} and φ2 = ν(n˜. ∪ {k})σ2 with σ2 = {M1/x1, . . . ,Ml/xl,k/xl+1}.
One direction of Proposition 4 follows easily from Proposition 1. If φ E M then
Proposition 1 implies that there exists a term ζ such that fn(ζ) ∩ n˜ = ∅ and ζσ =E
M ; then φ1 ≈sE′ φ2 because (h(ζ) =E′ xl+1)φ1 while (h(ζ) =E′xl+1)φ2.
For the other direction, we use a weak version of a lemma due to Baudet et al. [8].
Given a term U == h(U1) and given a name a, the cutting function cutU,a is defined
recursively as follows:
cutU,a(u)=u if u is a name or a constant
cutU,a(g(T1, . . . , Tk))=
⎧⎪⎨
⎪⎩
a if g = h, k = 1, and U1 =E′ T1
g(cutU,a(T1), . . . , cutU,a(Tk)) otherwise
Intuitively, cutU,a(T ) is obtained from T by replacing with a the subterms equal to
U modulo E ′ and whose head symbol is h. The following lemma (adapted from [8])
states that, if an equality holds between terms that mention h, then the equality still
holds after cutting subterms whose head symbol is h.
Lemma 4 Let U == h(U1). If M =E′ N then cutU,a(M) =E′ cutU,a(N).
This lemma relies on the following characterization of E ′: it is the least transitive
relation that contains the equations L′ =E′ R′ for which there exists an equation
L =E R, a substitution θ, and a position p such that L′|p == Lθ and R′ ==
L′[Rθ]p. (As usual, a position is formalized as a sequence of integers that indicates
a path in a term; M |p represents the subterm of M at position p, and M [Rθ]p is
obtained by replacing that subterm with Rθ; see Definition 11 in Appendix B.) The
lemma is proved by induction on the number of applications of equalities L =E R
required for obtaining M =E′ N . For the base case, we assume assume that M =E′
N and that there exists an equation L =E R, a substitution θ, and a position p such
that M |p == Lθ and N == M [Rθ]p. We consider two cases, distinguished by
whether the cutting function cutU,a cuts a subterm of M above p or not:
(1) In the first case, there exists a strict prefix p′ of p such that M |p′ == h(T1)
with U1 =E′ T1. We consider the smallest p′ that satisfies this property, and let
p = p′.1.p′′, so N == M [h(T1[Rθ]p′′)]p′ . Since T1[Rθ]p′′ =E′ T1[Lθ]p′′ ==
T1 =E′ U1, both h(T1) and h(T1[Rθ]p′′) are replaced with a by the cutting
function, so cutU,a(M) == cutU,a(N).
(2) In the second case, any p′ such that M |p′ = h(T1) with U1 =E′ T1 is at least
as long as p or incomparable. Therefore, cutU,a(M [x]p) == cutU,a(N [x]p)
and cutU,a(M) == cutU,a(M [x]p)[cutU,a(Lθ)]p, where x is a fresh variable.
Moreover, cutU,a(Lθ) == LcutU,a(θ) and cutU,a(Rθ) == RcutU,a(θ) since h
11
does not occur in L nor R. We deduce
cutU,a(M) == cutU,a(M [x]p)[cutU,a(Lθ)]p
== cutU,a(N [x]p)[LcutU,a(θ)]p
=E′ cutU,a(N [x]p)[RcutU,a(θ)]p
== cutU,a(N)
The inductive step of the proof of Lemma 4 is straightforward.
Lemma 4 yields the following conservativity property, whose converse is evident:
Lemma 5 If φ1 E′ M then φ E M .
By Proposition 1, we establish this conservativity property by assuming that there
exists a term ζ ′ over Σ′ such that fn(ζ ′) ∩ n˜ = ∅ and ζ ′σ1 =E′ M and proving that
there then exists a term ζ over Σ such that fn(ζ)∩n˜ = ∅ and ζσ =E M . The symbol
h does not appear in M since M is over Σ, but it may appear in ζ ′. Intuitively,
we obtain ζ from ζ ′ by cutting subterms where h appears, as follows. Suppose
that h appears in ζ ′σ1, so there exists a subterm U == h(V ) of ζ ′σ1. Let a be a
fresh name. We apply the cutting function cutU,a to the equality ζ ′σ1 =E′ M , and
derive cutU,a(ζ ′σ1) =E′ cutU,a(M) == M by Lemma 4. Moreover, we can write
cutU,a(ζ
′σ1) in the form ζ ′′σ1 where ζ ′′ is a term over Σ′ such that fn(ζ ′′) ∩ n˜ = ∅.
(We construct ζ ′′ from ζ ′ in the following way: for each path p such that ζ ′σ1|p ==
h(M ′) with M ′ =E′ V , p must be a path of ζ ′ since neither M nor the terms
Mi contain h, so we define ζ ′′ by replacing ζ ′|p with a at each such position p.)
Applying this transformation to all occurrences of h, we eventually obtain ζ ′′ over
Σ and also eliminate any occurrences of xl+1. We thus reduce to the case in which
h does not appear in ζ ′σ1. In this case, we obtain ζ ′σ1 == ζ ′σ (because xl+1 cannot
occur in ζ ′ in this case) and ζ ′σ1 =E M (because E′ does not equate any more
terms over Σ than E), so ζ ′σ =E M .
In order to establish Proposition 4, it remains to prove that if φ1 ≈sE′ φ2 then
φ E M . For this purpose, we assume that φ EM and show that φ1 ≈sE′ φ2, using
Lemma 4 as follows. Let V1 and V2 be two terms that do not contain the names
n˜ ∪ {k}.
• Assume that V1σ2 =E′ V2σ2. By substituting k with h(M) in the equality, we get
V1σ1 =E′ V2σ1 since k occurs only in σ2, and any equation that holds for a fresh
name such as k holds for any term.
• Conversely, assume that V1σ1 =E′ V2σ1. Let U == h(M). We apply the cut-
ting function cutU,k to the equality, and derive cutU,k(V1σ1) =E′ cutU,k(V2σ1) by
Lemma 4. Let us show that cutU,k(V1σ1) == V1cutU,k(σ1). We argue by con-
tradiction, and assume that cutU,k(V1σ1) == V1cutU,k(σ1) does not hold. This
assumption means that there exists a subterm V ′1 of V1 such that V ′1 is not a vari-
12
able and V ′1σ1 == h(T ′) with T ′ =E′ M . Since V ′1 is not a variable, V ′1 must
be of the form h(V ′′1 ) with V ′′1 σ1 == T ′ =E′ M . Since V1 does not contain the
names n˜, neither do V ′1 and V ′′1 , so V ′′1 σ1 =E′ M . Therefore, we have φ1E′M
by Proposition 1, and hence φEM by Lemma 5, contradicting our assumption
that φ EM . We obtain cutU,k(V1σ1) == V1cutU,k(σ1), and similarly we obtain
cutU,k(V2σ1) == V2cutU,k(σ1), so V1cutU,k(σ1) =E′ V2cutU,k(σ1). Finally, since
cutU,k(σ1) == σ2, we deduce that V1σ2 =E′ V2σ2.
We conclude that φ1 ≈sE′ φ2.
3.3 ≈s does not reduce to  in general
The converse is not true: may be decidable while≈s is not. Indeed, we can encode
an undecidable problem into the static equivalence problem in such a way that the
deduction problem remains decidable.
Proposition 5 There exists an equational theory such that≈s is undecidable while
 is decidable.
A preliminary presentation of our work [1] includes a first construction of a suitable
equational theory, with only a brief proof sketch. Following our work, Borgstro¨m
has recently provided an alternative construction, based on context-free grammars,
with a complete proof [15]. In what follows we describe our original construction,
as it may remain instructive, but refer the reader to Borgstro¨m’s paper for a rigorous
argument.
We consider the following construction: Given two deterministic Turing machines
M1 = (Q,A, q0, Qf , δ1) and M2 = (Q,A, q0, Qf , δ2) with the same control states,
where δ1, δ2 : Q×A → Q×A×{L,R}, we construct the machineM(M1,M2) =
(Q,A, q0, Qf , δ) where δ : {1, 2}×Q×A→ Q×A×{L,R} such that δ(1, q, a) =
δ1(q, a) and δ(2, q, a) = δ2(q, a). At each step, the machine M(M1,M2) plays
a transition of either M1 or M2. Since the machines M1 and M2 are determinis-
tic, a run of the machine M(M1,M2) on a word w may be described by a word
s of {1, 2}∗, which gives the list of choices made by M(M1,M2) at each step.
M(M1,M2), w s→ denotes the machine (with its current tape) after the sequence
of choices s on the word w. We assume that the local control state is written on the
tape.
Proposition 6 The following problem is undecidable.
Input: Two machines M(M1,M2) and M(M ′1,M ′2) and a word w of A∗.
Output: Does the following property hold for M(M1,M2) and M(M ′1,M ′2): for
any sequences s1, s2 ∈ {1, 2}∗, M(M1,M2), w s1→ and M(M1,M2), w s2→ have
the same tape if and only if M(M ′1,M ′2), w s1→ and M(M ′1,M ′2), w s2→ have the
same tape?
13
We reduce this undecidable problem to the ≈s problem under an equational the-
ory Etm such that  remains decidable. The intuitive idea of our encoding is that
a frame φ represents a machine of the form M(M1,M2), a term M represents
a sequence of choices such that Mφ represents the tape of the machine (and the
number of choices) after this sequence of choices. Then, for two “machines” φ and
φ′, it is undecidable whether there exists two sequences of choices M1,M2 such
that (M1 =Etm M2)φ and (M1 =Etm M2)φ′, that is, whether φ ≈s φ′.
On the other hand, it is possible to decide whether there exists a sequence of choices
M such that Mφ =Etm N , that is, whether φ  N) for a given term N . The term N
contains the number of choices, so it is sufficient to test any sequence of choices of
length equal to this number of choices.
Appendix A contains a proof of Proposition 6, as well as details on how we use the
problem in question.
4 Deciding knowledge under convergent subterm theories
In this section, in order to obtain decidability results for both  and ≈s, we re-
strict attention to subterm theories, defined by a finite set of equations of the form
M = N where N is a proper subterm of M or a constant symbol. In Section 4.1, we
motivate and introduce a convergence condition on subterm theories. Convergent
subterm theories are quite common in applications, as we illustrate with examples
in Section 4.2. We present our main decidability results for these theories in Sec-
tion 4.3.
4.1 Convergence
The definition of subterm theories is almost vacuous on its own. Even equality may
be undecidable for subterm theories. Any equational theory defined by a finite set
of equations M = M ′ with variables can be encoded as a subterm theory, with the
two equations:
Whichever(M,M ′) = M Whichever(M,M ′) = M ′
for each original equation M = M ′. In light of this encoding, we should add the
assumption that, by orienting the equations that define a subterm theory from left
to right, we obtain a convergent rewriting system:
Definition 1 An equational theory E, defined by a finite set of equations ⋃ni=1{Mi
= Ni} where fn(Mi) = fn(Ni) = ∅, is a convergent subterm theory if the set of
rewriting rules R def= ⋃ni=1{Mi → Ni} is convergent and if each Ni is a proper
14
subterm of Mi or a constant. We write U → V if U and V are closed terms and U
may be rewritten to V (in one step) using a rule of R.
As usual, if R is convergent then for all terms U and V we have U =E V if and
only if U↓= V ↓, where U↓ and V ↓ are the normal forms of U and V .
We write→E instead of→when the equational theory is not clear from the context.
4.2 Examples
Important destructor-constructor rules like those for pairing, encryption, and signa-
ture may be expressed in subterm theories (typically convergent ones):
fst(< x, y >) = x dec(enc(x, y), y) = x
snd(< x, y >) = y check(x, sign(x, sk(y)), pk(y)) = ok
Additional examples can be found in previous work (e.g., [3,12]). Convergent sub-
term theories also enable us to capture sophisticated but sensible properties, as in:
Einv : {I(I(x)) = x, I(x)× x = 1, x× I(x) = 1}
Eidem : {h(h(x)) = h(x)}
Esym : {enc(enc(x, y), y) = x}
The theory Einv models an inverse function. The theory Eidem models a hash func-
tion that is idempotent on small inputs (since the hash of a hash gives the same
hash). The theory Esym represents an encryption function that also decrypts: the
encryption of a plaintext, twice with the same key, returns the plaintext.
A rewriting system is convergent if and only if it is terminating and locally conflu-
ent (by Newmann’s Lemma [23]). For theories with the subterm property, termina-
tion holds immediately, so it suffices to examine critical pairs in order to establish
convergence. For example, the theory Eenc has no critical pairs, so it is convergent;
the theory Esym allows rewriting enc(enc(enc(x, y), y), y) in two different ways,
but they both yield enc(x, y), so Esym is convergent as well; on the other hand, the
theory Eenc ∪ Esym is not convergent because of the critical pair that consists of
dec(enc(enc(x, y), y), y)→ enc(x, y) and dec(enc(enc(x, y), y), y)→ dec(x, y).
4.3 Decidability results
For convergent subterm theories, both  and ≈s become decidable.
15
Theorem 1 For any frames φ and φ′, for any closed term M , we can decide φ  M
and φ ≈s φ′ in polynomial time in |φ|, |φ′|, and |M |.
In order to obtain a polynomial bound, we have to consider DAG representations
of terms. We define and study them in the next section.
4.3.1 DAG representation for terms
Let us define what is a DAG representation of a term.
Definition 2 (DAG representation) A DAG representation of a term is a direct
acyclic graph (V, l, E, v0), where V is the set of vertices, l : V → Σ a labeling
function, E ⊆ V × V × {1..ar(Σ)} the set of edges, and v0 ∈ V the root of the
graph. In addition, we assume that for every v ∈ V , for every integer i such that
0 ≤ i ≤ arity(l(v)), there exists a unique v ′ (denoted by E(v, i)) such that (v, v′, i)
is in E and that there is no edge of the form (v, v ′, i) for i > arity(l(v)).
The size of R, written |R|, is the number of vertices of R.
The term t(V, l, E, v0) represented by a DAG (V, l, E, v0) is defined recursively by
t(V, l, E, v0) = l(v0)(t(V, l, E, e(v0, 1)), . . . , t(V, l, E, e(v0, arity(l(v0))))).
A DAG representation (V, l, E, v0) is minimal if there are no distinct vertices v1
and v2 such that t(V, l, E, v1) = t(V, l, E, v2).
Although the memory size needed for representing a DAG R is larger than |R|, it
is polynomial (actually quadratic) in |R|. Thus the measure |R| is sufficient for our
purposes. Furthermore, with each term T , we can associate a unique minimal DAG
representation of T such that its number of vertices is equal to the number |T |DAG
of subterms of T . See figure 1 for examples.
Proposition 7 Given a DAG representation R, we can compute the minimal DAG
representation of t(R) in polynomial time in |R|. Therefore, checking whether
t(R1) == t(R2) where R1 and R2 are two DAG-representations can be done in
polynomial time in |R1| and |R2|.
Given a DAG representation R, we repeatedly check (at most |R| times) whether
there exist two distinct vertices v1 and v2 (at most |R|2 possibilities) such that
l(v1) = l(v2) and for every i such that 0 ≤ i ≤ arity(l(v1)), E(v1, i) = E(v2, i).
When such v1 and v2 exist, we suppress v1 in the set of vertices and replace each
occurrence of v1 in E by v2. We end with the minimal representation of t(R). The
total cost of this procedure is at most O(|R|3).
Proposition 8 Given a convergent subterm equational theory and a minimal DAG
representation R of a term T , we can compute a (minimal) DAG representation of
16
ff
fba
a
T =
f f
a
1
1 1
f
f
a
1
1
2
2
2
2
2
2
11
f
f
a
1
1
2
22
1
R
R1 R2
b
b
b
b
b
b
f f
f f
2
f
The DAG R is the minimal representation of T but R1 and R2 are also DAG
representations of T .
Fig. 1. Examples of DAG representations.
the normal form T ↓ of T in polynomial time in |R|. Therefore, checking whether
t(R1) =E t(R2) where R1 and R2 are two minimal DAG-representations can be
done in polynomial time in |R1| and |R2|.
Let R = (V, l, E, v0) be a minimal DAG representation of a term T . For every
rewriting rule of the form C[x1, . . . , xn] → C ′[x1, . . . , xn] or C[x1, . . . , xn] →
c of the theory, we check (from the root) if the pattern C appears in R (with at
most |C||R| tests). If it is the case, that is, there exists some v ∈ V such that
t(V, l, E, v) == C[x1, . . . , xn]θ for some θ, then we replace the vertex v by one of
the vertices that represents C ′[x1, . . . , xn]θ or we add the a vertex that represents c.
We minimize the resulting DAG, via Proposition 7, in time O(|R|3). At each step
(except for a constant number of cases), one of the vertices is suppressed, so this
procedure stops after at most |R| steps. We end with a DAG-representation of T↓,
in time O(|R|4).
4.3.2 Proof of Theorem 1
The end of this section is devoted to the proof of the theorem.
Let E be a convergent subterm theory given by ⋃ni=1{Mi = Ni}. The size of the
theory is given by cE = max1≤i≤n(|Mi|, ar(Σ) + 1). For example, we have that
cEinv = 4, cEidem = 3, and cEsym = 5. By convention, when n = 0, we set cE =
ar(Σ) + 1.
Step 1 of the proof: saturating a frame φ. We first associate with each frame φ
the set of subterms of messages in φ that may be deduced from φ by applying
17
only small contexts. We prove that this set can be computed in polynomial time.
In addition, we show that each term in this set has a “recipe” whose DAG-size is
polynomial.
Definition 3 Let φ = νn˜.{M1/x1, . . . ,Ml/xl} be a frame. Let st(φ) be the set of
subterms of the terms Mi. The saturation sat(φ) of φ is the minimal set such that:
(1) M1, . . . ,Mk ∈ sat(φ);
(2) if M1, . . . ,Mk ∈ sat(φ) and f(M1, . . . ,Mk) ∈ st(φ), then f(M1, . . . ,Mk) ∈
sat(φ);
(3) if M1, . . . ,Mk ∈ sat(φ) and C[M1, . . . ,Mk] → M , where C is a context,
|C| ≤ cE , fn(C) ∩ n˜ = ∅, and M ∈ st(φ), then M ∈ sat(φ).
Proposition 9 Let φ be a frame, φ = νn˜.σ.
(1) The set sat(φ) can be computed in time O(|φ|cE+2).
(2) For every M ∈ sat(φ), there exists a term ζM such that fn(ζM) ∩ n˜ = ∅,
|ζM |DAG ≤ cE|φ|, and ζMσ =E M . The term ζM is called a recipe of M and
is chosen arbitrarily from among the terms that verify these properties.
The set sat(φ) is obtained by saturating the set {M1, . . . ,Mk} by applying the
rules 2 and 3 of Definition 3. Since sat(φ) ⊆ st(φ), this set is saturated in at most
|φ| steps. At each step, we compute:
• Every closed term of the form C[M1, . . . ,Mk] (up to renamings in C), where
|C| ≤ cE and the terms Mi are already in the set. For each such term, we check
whether it is an instance of some left-hand side of a rule. Thus we need at most
O(|φ|cE+1) computations.
• Every term f(M1, . . . ,Mk) that is also in st(φ), where the terms Mi are already
in the set. In other words, for every term of the form f(M1, . . . ,Mn) in st(φ) (at
most |φ| terms), we check whether each Mi is already in the set. Thus we need
at most O(|φ|2) computations.
Since 1 ≤ cE , each step takes at mostO(|φ|cE+1). Since there are at most |φ| steps,
sat(φ) can be computed in time O(|φ|cE+2). For the second part of Proposition 9,
we know by Proposition 1 that for each term M of sat(φ) there exists ζM such that
fn(ζM) ∩ n˜ = ∅ and ζMσ =E M . By construction of sat(φ), the term ζM may be
chosen so that:
(1) ζM = xi if σ(xi) = M ;
(2) ζM = f(ζM1, . . . , ζMk) with Mi ∈ sat(φ) if M is obtained by the rule 2;
(3) ζM = C[ζM1, . . . , ζMk] with Mi ∈ sat(φ) if M is obtained by the rule 3.
Assume that we build a graph that contains every DAG that corresponds to the
chosen terms ζM for M ∈ sat(φ).
18
(1) For every 1 ≤ i ≤ l, there is a vertex vi, labeled by xi.
(2) If ζM = f(ζM1, . . . , ζMk) with Mi ∈ sat(φ), we add a vertex labeled by f and
connect this vertex to the vertices that correspond to ζM1, . . . , ζMk .
(3) If ζM = C[ζM1 , . . . , ζMk ] with Mi ∈ sat(φ), we add a graph that corresponds
to C[ 1, . . . , k] (at most |C| ≤ cE vertices) connected to the vertices that
correspond to ζM1, . . . , ζMk .
Each step costs one vertex or cE vertices. Since there are at most |sat(φ)| ≤ |φ|
steps (one for each term M), the maximal DAG-size of a term ζM embedded in this
graph is cE|φ|. Therefore, choosing the recipes from among those terms yields the
desired size bound. In what follows, for each φ, we assume fixed the set of recipes
that corresponds to the terms of sat(φ).
Example 1 We consider again the equational theory Eenc defined in Section 2.3.
We have CEenc = 5, Let φ
def
= νk, s.{enc(s, k)/x, k/y}. By application of rule 1 of
Definition 3, we have {M1,M2} ⊆ sat(φ), where M1 = enc(s, k) and M2 = k.
By application of the rule 3 with the context C = dec( , ) (|C| ≤ 5), we have
dec(M1,M2) == dec(enc(s, k), k) → s and s ∈ st(φ). Thus s ∈ sat(φ). Let
M3
def
= s. Since {M1,M2,M3} ⊆ sat(φ) ⊆ st(φ) ⊆ {M1,M2,M3}, we deduce that
sat(φ) = {M1,M2,M3}.
The recipes for each term of sat(φ) may be chosen in the following way: ζM1 = x,
ζM2 = y, and ζM3 = dec(x, y).
Step 2 of the proof: Introducing a finite set of equalities to characterize a
frame. With each frame φ, we associate a set of equalities Eq(φ) (finite mod-
ulo renaming) such that two frames are equivalent if and only if they satisfy the
equalities from each other’s set: φ′ satisfies the equalities Eq(φ) and φ satisfies the
equalities Eq(φ′).
Definition 4 Let φ = νn˜.σ be a frame. The set Eq(φ) is the set of equalities
C1[ζM1, . . . , ζMk ] = C2[ζM ′1, . . . , ζM ′l ]
such that (C1[ζM1, . . . , ζMk] =E C2[ζM ′1 , . . . , ζM ′l ])φ, |C1|, |C2| ≤ cE , and the terms
Mi and M ′i are in sat(φ). If φ′ is a frame such that (M =E N)φ′ for every (M =
N) ∈ Eq(φ), we write φ′ |= Eq(φ).
Example 2 We continue Example 1. Recall that M1 = enc(s, k), M2 = k, and
M3 = s. We are looking for equalities between small contexts over these terms,
modulo the equational theory Eenc. By removing trivial or redundant equalities, we
obtain that Eq(φ) = {enc(ζM3, ζM2) = ζM1}, that is, Eq(φ) = {enc(dec(x, y), y) =
x}. Intuitively, this equality corresponds to the ability of an intruder that can check
whether the first message enc(s, k) is an encrypted message whose encryption key
19
is the second message k, by decrypting and re-encrypting the first message with the
second.
Although Eq(φ) may be infinite since the contexts C1 and C2 may contain arbitrary
names, Eq(φ) is finite modulo some renamings that we explain at the end of the
section.
Two crucial lemmas show that it is sufficient to consider these equalities:
Lemma 6 Let φ = νn˜.σ and φ′ = νn˜′.σ′ be two frames such that φ′ |= Eq(φ).
For all contexts C1 and C2 such that (fn(C1) ∪ fn(C2)) ∩ n˜ = ∅, for all terms Mi,
M ′i ∈ sat(φ), if C1[M1, . . . ,Mk] == C2[M ′1, . . . ,M ′l ], then (C1[ζM1 , . . . , ζMk ] =E
C2[ζM ′1, . . . , ζM ′l ])φ
′
.
Lemma 7 Let φ = νn˜.σ be a frame. For every context C1 such that fn(C1)∩n˜ = ∅,
for every Mi ∈ sat(φ), for every term T such that C1[M1, . . . ,Mk] →∗E T , there
exist a context C2 such that fn(C2) ∩ n˜ = ∅, and terms M ′i ∈ sat(φ), such that
T == C2[M
′
1, . . . ,M
′
l ] and for every frame φ′ |= Eq(φ), (C1[ζM1, . . . , ζMk ] =E
C2[ζM ′1, . . . , ζM ′l ])φ
′
.
These two lemmas are proved in a more general setting in Appendix B. How these
lemmas are used for proving the decidability of deduction and static equivalence is
explained in steps 3 and 4 of the proof, respectively.
Step 3 of the proof: decidability of . Here we show that any message deducible
from a frame φ is actually a context over terms in sat(φ).
Proposition 10 Let φ = νn˜.σ be a frame, M be a closed term and M↓ its normal
form. Then φ  M if and only if there exist C and M1, . . . ,Mk ∈ sat(φ) such that
fn(C) ∩ n˜ = ∅ and M↓== C[M1, . . . ,Mk].
If M ↓== C[M1, . . . ,Mk] with fn(C) ∩ n˜ = ∅, then M =E C[ζM1 , . . . , ζMk ]σ,
by construction of the terms ζMi. Thus, by Proposition 1, φ  M . Conversely, if
φ  M , then by Proposition 1, there exists ζ such that fn(ζ)∩ n˜ = ∅ and M =E ζσ.
Thus M↓== (ζσ)↓. Applying Lemma 7, we obtain that (ζσ)↓== C[M1, . . . ,Mk]
for some M1, . . . ,Mk ∈ sat(φ) and C such that fn(C) ∩ n˜ = ∅.
We derive that φ  M can be decided by checking whether M ↓ is of the form
C[M1, . . . ,Mk] with Mi ∈ sat(φ). Given a term M , M ↓ can be computed in
polynomial time. Once sat(φ) is computed (in polynomial time by Proposition 9),
checking whether there exist C and M1, . . . ,Mk ∈ sat(φ) such that fn(C)∩ n˜ = ∅
and M ↓== C[M1, . . . ,Mk] may be done in time O(|M ||φ|2). The procedure is
basically as follows:
• Sort sat(φ) by the size of the terms (with cost |sat(φ)|2).
20
• For each term T of sat(φ) (from terms of maximal size to terms of minimal size),
check whether T is equal to a subterm of M . When it is the case, delete this
subterm from M . There are |M | subterms in M , the equality test costs |T | ≤ |φ|
computations, so this loop can be done in |M ||φ|2.
• Check whether the remaining part of M still contains private names in n˜. If it
is not the case, we have found a context C and M1, . . . ,Mk ∈ sat(φ) such that
fn(C) ∩ n˜ = ∅ and M↓== C[M1, . . . ,Mk]; otherwise such a context does not
exist.
This procedure is correct because, when cutting subterms of M equal to terms in
sat(φ), we start with terms in sat(φ) of maximal size. We conclude that φ  M is
decidable in polynomial time.
Step 4 of the proof: decidability of ≈s.
Proposition 11 For all frames φ and φ′, we have φ ≈s φ′ if and only if φ |= Eq(φ′)
and φ′ |= Eq(φ).
By definition of static equivalence, if φ ≈s φ′ then φ |= Eq(φ′) and φ′ |= Eq(φ).
Conversely, assume that φ′ |= Eq(φ) and consider M and N such that there exist
n˜ and σ such that φ = νn˜.σ, (fn(M) ∪ fn(N)) ∩ n˜ = ∅, and (M =E N)φ. Then
Mσ =E Nσ, so (Mσ)↓== (Nσ)↓. Let T = (Mσ)↓. Applying Lemma 7, we
obtain that there exist M1, . . . ,Mk ∈ sat(φ) and CM such that fn(CM)∩ n˜ = ∅ and
T == CM [M1, . . . ,Mk] and Mσ′ =E CM [ζM1, . . . , ζMk]σ′
Since T == (Nσ)↓, we obtain similarly that there exist M ′1, . . . ,M ′l ∈ sat(φ) and
CN such that fn(CN) ∩ n˜ = ∅ and
T == CN [M
′
1, . . . ,M
′
l ] and Nσ′ =E CN [ζM ′1, . . . , ζM ′l ]σ
′
Moreover, since CM [M1, . . . ,Mk] == CN [M ′1, . . . ,M ′l ], we derive from Lemma 6
that CM [ζM1, . . . , ζMk]σ′ =E CN [ζM ′1, . . . , ζM ′l ]σ
′
, thus (M =E N)φ′. Conversely,
when (M =E N)φ′ and φ |= Eq(φ′), we also have that (M =E N)φ. We conclude
that φ ≈s φ′.
Therefore, given φ and φ′, in order to decide whether φ ≈s φ′ we construct sat(φ)
and sat(φ′). This construction can be done in polynomial time by Proposition 9.
For each term M of sat(φ) or sat(φ′), the term ζM has a polynomial DAG-size.
As noted previously, Eq(φ′) may be infinite since the equalities may contain arbi-
trary names. However, each equation of Eq(φ) is of the form (C1[ζM1, . . . , ζMk] =E
C2[ζM ′1, . . . , ζM ′l ]) with |C1|, |C2| ≤ cE , so each equality of Eq(φ) contains at most
2cE distinct names besides the names of the recipes. The following lemma, whose
proof is easy, says that those 2cE names can be fixed:
21
Lemma 8 Let K = 2cE and {n1, . . . , nK} be any set of K distinct names, distinct
from the names of the recipes for the terms of sat(φ). Let Eq′(φ) be the set consisting
on the all the equalities
C1[ζM1, . . . , ζMk ] = C2[ζM ′1, . . . , ζM ′l ]
such that (C1[ζM1, . . . , ζMk] =E C2[ζM ′1 , . . . , ζM ′l ])φ, |C1|, |C2| ≤ cE, the terms Mi
and M ′i are in sat(φ), and fn(C1) ∪ fn(C2) ⊆ {n1, . . . , nK}. Then, for any frame
φ′, φ |= Eq(φ) if and only if φ |= Eq′(φ).
Thus, instead of checking whether φ |= Eq(φ), we can check whether φ |= Eq′(φ).
More precisely, for all contexts C1 and C2 such that |C1|, |C2| ≤ cE and fn(C1) ∪
fn(C2) ⊆ {n1, . . . , nK}, for all Mi,M ′i ∈ sat(φ), we can check whether (C1[ζM1 ,
. . . , ζMk] =E C2[ζM ′1, . . . , ζM ′l ])φ and (C1[ζM1, . . . , ζMk] =E C2[ζM ′1 , . . . , ζM ′l ])φ
′
.
There are at most O((|φ|cE)2) equalities in Eq′(φ). Each term of the form C1[ζM1 ,
. . . , ζMk]φ has a polynomial DAG-size. The equality of two terms represented by
DAGs can be checked in polynomial time: we do not need to expand the DAGs in
order to test for equality. We conclude that φ ≈s φ′ can be decided in polynomial
time in |φ| and |φ′|.
Although this proof is effective, the complexity bounds that we obtain from it ap-
pear rather high. For example, for the equational theory Eenc of Section 2.3, we can
obtain that φ  M is decidable in time O(|M |3|φ|7). It should be possible to do
much better.
5 Deciding knowledge under more general equational theories
Next, we relax our hypotheses on equational theories. Instead of requiring con-
vergence, we consider equational theories with some associative and commutative
symbols that come with a rewriting system R such that a R is convergent mod-
ulo AC rewriting. Moreover, instead of imposing a syntactic condition (such as a
subterm property), we introduce a condition on the set sat(φ) associated with each
frame φ. We present the resulting hypotheses in Section 5.1. We give examples of
theories that satisfy the hypotheses in Section 5.2. Finally, we prove general decid-
ability results in Section 5.3.
5.1 The hypotheses
We establish decidability results for equational theories that satisfy three properties.
The purpose of this section is to define and start to explain these three properties;
Section 5.2 explains them further through examples.
22
5.1.1 AC-convergence
Our first hypothesis is an adaptation of the standard notion of convergence for the-
ories with AC symbols.
Let E be an equational theory, and let⊕1, . . . ,⊕k be the binary functional symbols
such that the equations x⊕i(y⊕iz) = (x⊕iy)⊕iz (associativity) and x⊕iy = y⊕ix
(commutativity) are in E.
For two terms U and V , we write U =AC V if U and V are equal in the theory
induced by the equations x ⊕i (y ⊕i z) = (x ⊕i y) ⊕i z and x ⊕i y = y ⊕i x for
1 ≤ i ≤ k. When this theory is empty (because we have no AC symbols), =AC is
simply syntactic equality.
When R is a rewriting system, we write U →AC V if there exists W such that
U =AC W and W → V . The relation →∗AC denotes the reflexive and transitive
closure of →AC. For every term U , the set of normal forms U↓ (closed modulo AC)
of U is the set of terms V such that U →∗AC V and V has no successor for →AC.
Definition 5 (AC-convergent) An equational theory E is AC-convergent if there
exists a finite rewriting system R such that:
• R is AC-terminating, that is, for every closed term U , there is no infinite se-
quence U →AC U1 →AC · · ·Uk →AC · · · .
• R is AC-confluent, that is, for every closed terms U , U1, and U2 such that U →AC
U1 and U →AC U2, there exist V1 and V2 such that U1 →∗AC V1, U2 →∗AC V2, and
V1 =AC V2.
• For all closed terms U and V , the equality U =E V holds if and only if there
exists a term T ∈ (U↓ ∩ V ↓).
By AC-convergence, the set U↓ is always finite and for all V,W ∈ U↓, the equality
V =AC W holds. AC-convergence immediately implies the decidability of equa-
tions on closed terms.
In what follows, E is an AC-convergent equational theory and R is a rewriting
system associated with E that satisfies the conditions of Definition 5. If R consists
of a finite set of rules ⋃ki=1 {Mi → Ni}, the size cE of the theory E is defined as
cE = max1≤i≤k(|Mi|, |Ni|, ar(Σ)+1). As a special case, cE = ar(Σ)+1 whenR is
empty. As another special case, we obtain the definition of cE given in Section 4.3
for subterm theories.
Note that E need not have AC symbols. A theory defined by a convergent rewriting
system without AC symbol is of course an AC-convergent theory. In that case, we
may simply say that the theory is convergent.
Example 3 As a first example, we consider the theory of an encryption scheme
23
that has an homomorphism property. This property is simply that the encryption
of a pair is the pair of the encryptions; the literature (e.g., [32]) suggests other
homomorphism properties. This property is modeled by the equation:
enc(〈x, y〉, z) = 〈enc(x, z), enc(y, z)〉
We also assume an analogous equation for decryption:
dec(〈x, y〉, z) = 〈dec(x, z), dec(y, z)〉
As usual, we write 〈x, y〉 instead of pair(x, y). The signature Σhomo is {pair, enc, fst,
snd, dec}, and the theory Ehomo is defined by the axioms:
enc(〈x, y〉, z) = 〈enc(x, z), enc(y, z)〉
dec(〈x, y〉, z) = 〈dec(x, z), dec(y, z)〉
fst(〈x, y〉) = x
snd(〈x, y〉) = y
dec(enc(x, y), y) = x
We consider the rewriting systemRhomo obtained from Ehomo by orienting the equa-
tions from left to right. With this choice of Rhomo, the theory Ehomo is convergent:
its only critical pair is joinable.
〈x1, dec(enc(x2, y), y)〉
〈dec(enc(x1, y), y), dec(enc(x2, y), y)〉
〈x1, x2〉 dec(〈enc(x1, y), enc(x2, y)〉, y)
dec(enc(〈x1, x2〉, y), y)
Example 4 The theory of XOR is also AC-convergent. The XOR operator is repre-
sented by the ⊕ function symbol, with the following properties:
Exor =
⎧⎪⎪⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎪⎪⎪⎩
x⊕ (y ⊕ z) = (x⊕ y)⊕ z
x⊕ y = y ⊕ x
x⊕ x = 0
x⊕ 0 = x
⎫⎪⎪⎪⎪⎪⎪⎪⎬
⎪⎪⎪⎪⎪⎪⎪⎪⎭
where 0 is a constant symbol and the signature Σxor is {0,⊕}. We associate to Exor
24
the rewriting system Rxor:
Rxor =
⎧⎪⎨
⎪⎩
x⊕ x → 0
x⊕ 0 → x
⎫⎪⎬
⎪⎭
Using this choice of Rxor, it is easy to verify that Exor is AC-convergent.
5.1.2 Local stability
Our second hypothesis roughly says that, for every frame, there is a finite set of
terms deducible from the frame that satisfies certain closure conditions. Stating this
hypotheses precisely requires a few auxiliary definitions and notations.
Assume that there exists some rule M0 → N0 of the rewriting system R and some
substitution θ such that either there exists a term U1 such that U =AC U1, U1 = M0θ,
and V = N0θ, or there exist terms U1 and U2 such that U =AC U1 ⊕ U2 for some
AC symbol ⊕, U1 = M0θ, and V =AC N0θ ⊕ U2. Then we say that the reduction
U → V occurs in head, and we write U h→ V .
We write α ·⊕M for the term M ⊕· · ·⊕M , α times (for α ∈ N∗). We simply write
αM when the AC symbol is clear from the context. Given a set of terms S and a
set of names n˜, we write sum⊕(S, n˜) for the set of arbitrary sums of terms of S and
other names, closed modulo AC-rewriting:
sum⊕(S, n˜)
def
=
⎧⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎩
(α1 ·⊕ T1)⊕ · · · ⊕ (αn ·⊕ Tn)
⊕
(β1 ·⊕ n1)⊕ · · · ⊕ (βk ·⊕ nk)
∣∣∣∣∣∣∣∣∣∣∣
αi, βi ∈ N∗,
ni /∈ n˜,
Ti ∈ S
⎫⎪⎪⎪⎪⎪⎬
⎪⎪⎪⎪⎪⎭
Typically, the names in n˜ will be private, and the others public. Then we define
sum(S, n˜) as the union of the sum⊕(S, n˜) for any AC symbol ⊕ of the theory.
For convergent subterm theories, the main step of the proof of the decidability of
 and ≈s shows the existence, for each frame φ, of a set sat(φ) that is stable by
application of “small” contexts. We generalize this condition by requiring that the
application of a rewriting rule to a “small” context C applied to arbitrary sums of
terms in sat(φ) is again a “small” context C ′ applied to sums of terms in sat(φ).
The definition of “small” is partly arbitrary; we bound the size of C by cE and the
size of C ′ by cE2, but other finite size bounds may be suitable.
Definition 6 (locally stable) An AC-convergent equational theory E is locally sta-
ble if, for every frame φ = νn˜.{M1/x1, . . . ,Mk/xk}, where the terms Mi are
closed and in normal form, there exists a finite (computable) set sat(φ), closed
modulo AC, such that
25
(1) M1, . . . ,Mk ∈ sat(φ), and n ∈ sat(φ) for every n ∈ fn(φ);
(2) if M1, . . . ,Mk ∈ sat(φ) and f(M1, . . . ,Mk) ∈ st(sat(φ)), then f(M1, . . . ,
Mk) ∈ sat(φ);
(3) if C[S1, . . . , Sl] h→ M , where C is a context such that |C| ≤ cE and fn(C) ∩
n˜ = ∅, and where S1, . . . , Sl ∈ sum⊕(sat(φ), n˜) for some AC symbol ⊕ (or
Si ∈ sat(φ) if there is no AC symbol), then there exist a context C ′, a term
M ′, and S ′1, . . . , S ′k ∈ sum⊕(sat(φ), n˜) (or S ′1, . . . , S ′k ∈ sat(φ) if there is no
AC symbol), such that |C ′| ≤ c2E, fn(C ′) ∩ n˜ = ∅, and M →∗AC M ′ =AC
C ′[S ′1, . . . , S
′
k];
(4) if M ∈ sat(φ) then φ M .
The set sat(φ) need not be unique, nor minimal. Any set that satisfies the four
conditions is adequate for our present purposes.
Example 5 For the equational theory Ehomo of Example 3, given a frame φ in
normal form, the set sat(φ) is simply obtained by adding subterms of φ deducible
from φ. Suppose for example that the attacker gets the messages enc(〈n1, n2〉, k)
and enc(n3, enc(n1, k)). Since enc(〈n1, n2〉, k) =Ehomo 〈enc(n1, k), enc(n2, k)〉, the
corresponding frame can be written
φ2 = νn1, n2, n3, k.{〈enc(n1, k), enc(n2, k)〉/x1, enc(n3, enc(n1, k))/x2}
Then, the deducible subterms of the frame φ2 are enc(n1, k), enc(n2, k), and n3, so
sat(φ2) is the set
{〈enc(n1, k), enc(n2, k)〉, enc(n3, enc(n1, k)), enc(n1, k), enc(n2, k), n3}
In Section 5.2.2 we prove that this construction satisfies the requirements.
In general, establishing that an equational theory is locally stable may be difficult.
We give other examples of locally stable theories in Section 5.2.
5.1.3 Local finiteness and local decidability
For our third hypothesis, we consider a certain set of “small” equations that a frame
satisfies. One of our results says that this set characterizes the frame. The third
hypothesis, which this section presents, pertains to deciding whether another frame
satisfies this set. In fact, this section discusses two versions of the third hypothesis,
called local finiteness and local decidability. Either is sufficient for our purposes;
the former has been more attractive in applications; the latter is more general. As
the use of equations may suggest, we rely on the third hypothesis in the study of
static equivalence but not deduction.
For each frame φ = νn˜.σ, we assume a fixed set of terms ρ(φ) = {ζM | M ∈
sat(φ)} such that for each ζM , fn(ζM) ∩ n˜ = ∅ and ζMσ =E M . Intuitively, the
26
term ζM explains how M may be obtained from the terms of φ. Since all the terms
of sat(φ) are deducible, such a set exists by Proposition 1. For instance, for Ex-
ample 5, the terms associated with enc(n1, k), enc(n2, k), and n3 are respectively
ζenc(n1,k) = fst(x1), ζenc(n2,k) = snd(x1), and ζn3 = dec(x2, fst(x1)).
Much as in Section 4.3, we associate a set of “small” equations Eq(φ) with each
frame φ, in such a way that two frames are equivalent if and only if they satisfy the
equations of each other’s set (see Proposition 17).
Definition 7 Let φ = νn˜.σ be a frame in normal form. The set Eq(φ) is the set of
equations of the form
C1[χ1, . . . , χk] = C2[χ
′
1, . . . , χ
′
l]
where (C1[χ1, . . . , χk] =E C2[χ′1, . . . , χ′l])φ, (fn(C1)∪fn(C2))∩n˜ = ∅, |C1| ≤ cE ,
|C2| ≤ c2E , and the terms χi and χ′i are in the set sum⊕(ρ(φ), n˜) for some AC symbol
⊕ (or χi and χ′i are in ρ(φ) if there is no AC symbol).
When φ and ψ are frames and (M =E N)ψ for every (M = N) ∈ Eq(φ), we say
that ψ satisfies the equations of Eq(φ), and write ψ |= Eq(φ).
Definition 8 (locally decidable) A locally stable equational theory is locally de-
cidable if the question of whether ψ |= Eq(φ), for frames φ and ψ, is decidable.
The set Eq(φ) may in general be infinite since the terms χi may be of arbitrary
size. Local finiteness means that the set Eq(φ) is always equivalent to a finite set of
equations.
Definition 9 (locally finite) A locally stable equational theory is locally finite if,
for every frame φ, there exists a finite (computable) set of equations Eq′(φ) such
that, for every frame ψ:
ψ |= Eq(φ) if and only if ψ |= Eq′(φ)
This property suffices for local decidability:
Proposition 12 Every locally finite equational theory is locally decidable.
Local finiteness is always true when there are no AC symbols since then the set
Eq(φ) contains only finitely many equations up to renaming:
Proposition 13 Let E be a locally stable equational theory with no AC symbols.
Then, for any frame φ, there exists a finite set of equations Eq′(φ) such that for
every frame ψ, we have ψ |= Eq(φ) if and only if ψ |= Eq′(φ). In other words, E is
locally finite.
27
Each equation of Eq(φ) is of the form C1[χ1, . . . , χk] = C2[χ′1, . . . , χ′l] with χi, χ′i
in ρ(φ). Thus it contains a finite number of names (bounded by cE + c2E). The set
Eq′(φ) is obtained from Eq(φ) by renaming the names to a fixed set of names.
In Section 5.2 we present some non-trivial examples of locally finite theories with
AC symbols. Establishing local finiteness is our preferred way of proving local
decidability for such theories. Here we show that at least an (infinite) subset of
Eq(φ) may always be replaced by a finite number of equations.
Definition 10 Let φ = νn˜.σ be a frame. Let N be a set of public names (that
is, such that N ∩ n˜ = ∅). We write EqAC (φ,N) for the set of equations of the
form χ1 = χ2 such that χ1, χ2 ∈ sum⊕(ρ(φ), n˜), fn(χ1) ∪ fn(χ2) ⊆ N , and
(χ1 =E χ2)φ.
Note that EqAC (φ,N) is a subset of Eq(φ). We show that the set EqAC (φ,N) may
always be replaced by a finite number of equations if N is a finite set of public
names.
Proposition 14 Let φ = νn˜.σ be a frame and N a finite set of names such that
N ∩ n˜ = ∅. There exists a finite set EqbAC (φ,N) ⊆ EqAC (φ,N), such that for
every frame ψ:
ψ |= EqAC (φ,N) if and only if ψ |= EqbAC (φ,N)
In addition, the cardinality of EqbAC (φ) is at most the cardinality of sat(φ) plus the
cardinality of N .
This proposition can be proved using an elementary result on Z-modules, namely
that submodules of finitely generated Z-modules are finitely generated. (Facts onZ-
module may be found in [33], for example.) Assume that sat(φ) = {M1, . . . ,Mk},
N = {n1, . . . , nl}, and let Γ ∈ Zk+l. For 1 ≤ i ≤ k + l, Γi denotes the ith
coefficient of Γ, and Γ̂ denotes the equation:
⊕
Γi>0,i≤k
ΓiζMi ⊕
⊕
Γi>0,i>k
Γini =
⊕
Γi<0,i≤k
(−Γi)ζMi ⊕
⊕
Γi<0,i>k
(−Γi)ni
Let Eq′AC (φ,N) = {Γ̂ | Γ ∈ Zk+l, (Γ̂)φ}. It is easy to verify that for any frame
ψ, ψ |= EqAC (φ,N) if and only if ψ |= Eq′AC (φ,N). It is also easy to verify
(simplifying the equations) that Eq′AC (φ,N) is a Z-submodule of Zk+l and thus
can be generated by a finite number of vectors V1, . . . , Vr with r ≤ k+ l. We define
EqbAC (φ,N) = {V̂1, . . . , V̂r}. It is then easy to conclude that, for any frame ψ,
ψ |= EqAC (φ,N) if and only if ψ |= EqbAC (φ,N).
Example 6 Consider for example a pure AC theory with only one AC symbol +
(and no other function symbol), and the frame
φ3 = νn1, n2, n3.{3n1 + 2n2 + 4n3/x1, n2 + 3n3/x2, n1 + 2n3/x3, 3n2 + n3/x4}
28
The set Eq(φ3) consists of the equations of the form α1x1+α2x2+α3x3+α4x4+T =
α′1x1 + α
′
2x2 + α
′
3x3 + α
′
4x4 + T
′ with αi, α′i ∈ N, and T and T ′ sums of names
distinct from n1, n2, and n3. By convention, if αi = 0 (resp. α′i = 0) then the
term αixi (resp. α′ixi) does not appear in the sum. Since the equation is true for
φ3, we must have T = T ′, thus it is sufficient to consider the equations of the form
α1x1+α2x2+α3x3+α4x4 = α
′
1x1+α
′
2x2+α
′
3x3+α
′
4x4 with αi, α′i ∈ N. Adopting
the convention that a negative term αx (with α < 0) in an equation actually appears
on the other side of the equation, it is sufficient to consider the equations of the
form α1x1 + α2x2 + α3x3 + α4x4 = 0, with αi, α′i ∈ Z. For example, the equation
3x1−2x2 +x3 = 0 stands for the equation 3x1 +x3 = 2x2. Then, the set of vectors
(α1, α2, α3, α4) such that the equation α1x1 + α2x2 + α3x3 + α4x4 = 0 holds for
φ3 is exactly the set of vectors U of Z4 such that AU = 0 with
A =
⎛
⎜⎜⎜⎜⎜⎝
3 0 1 0
2 1 0 3
4 3 2 1
⎞
⎟⎟⎟⎟⎟⎠
By using classical elementary operations on rows and columns, we find that AU =
0 if and only if
U = λ
⎛
⎜⎜⎜⎜⎜⎜⎜⎜⎝
1
1
−3
−1
⎞
⎟⎟⎟⎟⎟⎟⎟⎟⎠
for λ ∈ Z. We deduce that the set of equations satisfied by φ3 is exactly the set of
equations of the form: λx1 + λx2 = 3λx3 + λx4. Thus, in order to decide whether
a frame ψ satisfies Eq(φ3), it is sufficient to check whether ψ satisfies the single
equation x1 + x2 = 3x3 + x4.
5.2 Examples
In this section, we give examples of locally stable and locally finite equational
theories. In Section 5.3, we prove that local stability implies the decidability of
deduction, and that local stability and local finiteness imply the decidability of static
equivalence.
Several equational theories related to cryptographic operations are locally stable
and locally finite. In particular, we prove that convergent subterm theories are lo-
cally stable. We show that a theory of homomorphic encryption, a simple theory for
addition, and a theory for blind signatures (which are not subterm theories) are also
locally stable. These equational theories do not have AC symbols, so local finite-
29
ness follows from Proposition 13. As examples of theories with AC symbols, we
prove that the pure AC theory and a theory of the XOR operator are locally stable
and locally finite. The proofs of these properties require only a few lines, and thus
are much simpler than direct proofs of decidability. We have also drafted proofs
that the theory of Abelian groups is locally stable and locally finite, but in that case
the proofs are quite tedious—probably more than direct proofs of the decidability
of deduction and static equivalence.
As the examples may suggest, proving local stability often requires a precise un-
derstanding of the cryptographic primitives represented by an equational theory. In
particular, removing some equations need not always preserve local stability.
5.2.1 Convergent subterm theories
It is easy to verify that the definition of sat(φ) given in Definition 1 fits our require-
ments for local stability.
Proposition 15 Every convergent subterm theory is a locally finite theory.
Consequently, we obtain again that both deducibility and static equivalence are
decidable for convergent subterm theories.
5.2.2 Homomorphism
We consider again the equational theory Ehomo (defined in Example 3), which rep-
resents an encryption scheme with a homomorphism property. The size of the the-
ory is 7.
Comon-Lundh and Treinen have investigated a very similar equational theory [21].
They have shown that its deduction relation is decidable in PTIME. Here we show
that Ehomo is locally stable, and it is obviously locally finite (since it has no AC
symbol). These properties will imply that both deduction and static equivalence are
decidable.
Let φ = νn˜.{M1/x1, . . . ,Mk/xk} be any frame in normal form. We define sat(φ)
to be the smallest set such that:
(1) M1, . . . ,Mk ∈ sat(φ), and n ∈ sat(φ) for every n ∈ fn(φ);
(2) if M1, . . . ,Mk ∈ sat(φ) and f(M1, . . . ,Mk) ∈ st(sat(φ)), then f(M1, . . . ,
Mk) ∈ sat(φ);
(3) if M1,M2 ∈ sat(φ) and dec(M1,M2) h→ M and the rule dec(enc(x, y), y) →
x has been applied, or fst(M1) h→M , or snd(M1) h→ M , then M ∈ sat(φ).
The set sat(φ) is finite since we add only subterms of terms of φ. It trivially satisfies
30
conditions 1, 2, and 4 of Definition 6. Let us show that it satisfies condition 3. Let
M1, . . . ,Mk ∈ sat(φ) and assume that C[M1, . . . ,Mk] h→ M where |C| ≤ 7. The
case where C is a single hole is covered by the fact that the terms are in normal
form. The other cases are covered by rule 3 except in the following cases:
• C = enc( , ), C = enc( , T ), or C = enc(T, ) where fn(T ) ∩ n˜ = ∅ and
|T | ≤ 5.
· For enc(M1,M2) → M with M1,M2 ∈ sat(φ): In this case, M1 must be of the
form M1 = 〈M ′1,M ′2〉 and M = 〈enc(M ′1,M2), enc(M ′2,M2)〉. By rule 3, we
know that both M ′1 and M ′2 are in sat(φ) since fst(M1) →M ′1 and snd(M1) →
M ′2. Thus M is a context over terms of sat(φ) where the context may be chosen
as C ′ = 〈enc( , ), enc( , )〉 since |C ′| = 7 ≤ 72 = 49.
· For enc(M1, T ) → M with M1 ∈ sat(φ), fn(T ) ∩ n˜ = ∅, and |T | ≤ 5: We
have similarly that M = 〈enc(M ′1, T ), enc(M ′2, T )〉with M ′1 and M ′2 in sat(φ).
Thus M is a context over terms of sat(φ) where the context may be chosen as
C ′ = 〈enc( , T ), enc( , T )〉 since |C ′| ≤ 5 + 2|T | ≤ 15 ≤ 72 = 49.
· For enc(T,M2) → M with M2 ∈ sat(φ), fn(T ) ∩ n˜ = ∅, and |T | ≤ 5:
We must have T = 〈T1, T2〉 with |T1| + |T2| ≤ 4. We deduce that M =
〈enc(T1,M2), enc(T2,M2)〉, so M is a context over terms of sat(φ) where the
context may be chosen as C ′ = 〈enc(T1, ), enc(T2, )〉 since |C ′| ≤ 5+ |T1|+
|T2| ≤ 9 ≤ 49.
• C = dec( , ), C = dec( , T ), or C = dec(T, ) where fn(T ) ∩ n˜ = ∅ and
|T | ≤ 5, and the rule dec(〈x, y〉, z) → 〈dec(x, z), dec(y, z)〉 has been applied.
These three cases are very similar to the three cases above.
5.2.3 Addition
We consider a simple theory for addition. Let Σadd be any signature that contains
0, s, pred, and plus, with the equations:
Eadd =
⎧⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎩
plus(x, s(y)) = plus(s(x), y)
plus(x, 0) = x
pred(s(x)) = x
⎫⎪⎪⎪⎪⎪⎬
⎪⎪⎪⎪⎪⎭
The size cEadd of this theory is at least 4 (and possibly higher if Σadd contains
symbols other than 0, s, pred, and plus). We define Radd by simply orienting the
equations from left to right. Using this choice of Radd, it is easy to verify that
Eadd is convergent. (Note that Eadd has no AC symbol.) For local stability, when
φ = νn˜.{M1/x1, . . . ,Mk/xk} is any frame in normal form, we define sat(φ) to be
the smallest set such that:
(1) M1, . . . ,Mk ∈ sat(φ), and n ∈ sat(φ) for every n ∈ fn(φ);
(2) if M1, . . . ,Mk ∈ sat(φ) and f(M1, . . . ,Mk) ∈ st(sat(φ)), then f(M1, . . . ,
31
Mk) ∈ sat(φ);
(3) if pred(M) h→M ′ and M ∈ sat(φ) then M ′ ∈ sat(φ).
The set sat(φ) is finite since we add only subterms of terms of φ. The set sat(φ)
trivially satisfies conditions 1, 2, and 4 of Definition 6. Let us show that it sat-
isfies condition 3. Assume that C[M1, . . . ,Mk] h→ M with Mi ∈ sat(φ) and
|C| ≤ cEadd . The only non-trivial case is the one where plus(M1,M2) h→ M ′ with
M1,M2 ∈ sat(φ) and the rule plus(x, s(y)) → plus(s(x), y) has been applied. We
must have that M2 = s(M ′2). Hence pred(M2)
h→ M ′2, so M ′2 ∈ sat(φ). Now, we
have M ′ = plus(s(M1),M ′2), with M1,M ′2 ∈ sat(φ) and |plus(s( ), )| = 4 ≤ 42,
so condition 3 is satisfied.
Note that, were we to omit the equation pred(s(x)) = x in our equational theory,
the proof of local stability would no longer be valid.
5.2.4 Blind signatures
We consider a theory recently introduced by Kremer and Ryan in order to model
blind signatures and related constructs in their analysis of a protocol for electronic
voting [27]. This theory treats signatures much like that of Section 4, with four
differences: the checking construct is called checksign (rather than check); check-
ing does not require plaintext; there is no separate signature-key computation (no
function sk); and, most importantly, this theory also describes signature blinding
and unblinding functions. Let Σblind be any signature that contains open, commit,
getpk, host, checksign, sign, unblind, and blind, with the equations:
Eblind =
⎧⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩
open(commit(x, y), y) = x
getpk(host(x)) = x
checksign(sign(x, y), pk(y)) = x
unblind(blind(x, y), y) = x
unblind(sign(blind(x, y), z), y) = sign(x, z)
⎫⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎬
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎭
The size cEblind of the theory is at least 7 (and possibly higher if Σblind contains
additional symbols). We define Rblind by simply orienting the equations from left
to right. The theory Eblind is clearly convergent. To prove that Eblind is locally stable,
we extend the definition of subterms by requiring that sign(M1,M3) is a subterm
32
of sign(blind(M1,M2),M3). More formally, we define:
stext(u) = u
stext(sign(blind(M1,M2),M3)) =
{sign(M1,M3)} ∪ {sign(blind(M1,M2),M3)}
∪ stext((blind(M1,M2)) ∪ stext(M3)
stext(f(M1, . . . ,Mk)) =
{f(M1, . . . ,Mk)} ∪ ⋃ki=1 stext(Mi)
otherwise (that is, for other terms)
When φ = νn˜.{M1/x1, . . . ,Mk/xk} is any frame in normal form, we define sat(φ)
to be the smallest set such that:
(1) M1, . . . ,Mk ∈ sat(φ), and n ∈ sat(φ) for every n ∈ fn(φ);
(2) if M1, . . . ,Mk ∈ sat(φ) and f(M1, . . . ,Mk) ∈ st(sat(φ)), then f(M1, . . . ,
Mk) ∈ sat(φ);
(3) if C[M1, . . . ,Mk] h→ M , Mi ∈ sat(φ) and M ∈ stext(sat(φ)) then M ∈
sat(φ).
The set sat(φ) is finite since we add only extended subterms of terms of φ. The
set sat(φ) trivially satisfies conditions 1, 2, and 4 of Definition 6. Let us show that
it satisfies condition 3. Assume that C[M1, . . . ,Mk] h→ M with Mi ∈ sat(φ) and
|C| ≤ cEblind . If one of the four first rules of Rblind has been applied, then M is a
subterm of C[M1, . . . ,Mk]. Thus either M = C ′[M1, . . . ,Mk] for some context
C ′ and condition 3 is satisfied or M is a subterm of one of the terms Mi, thus
M ∈ sat(φ) and condition 3 is satisfied. If the fifth rule of Rblind has been applied,
then three (non-trivial) cases may arise.
• If M2 h→ M then M is an extended subterm of M2, so M ∈ sat(φ) and condi-
tion 3 is satisfied.
• Similarly, if unblind(M1,M2) h→ M then M is an extended subterm of M1, so
M ∈ sat(φ) and condition 3 is satisfied.
• Finally, suppose that unblind(sign(M1,M2),M3) h→ M . It must be the case that
M1 = blind(M
′
1,M3). Since unblind(M1,M3)
h→M ′1 and M ′1 is a subterm of M1,
we have M ′1 ∈ sat(φ). Now, since M = sign(M ′1,M2) and |sign( , )| = 3 ≤ 72,
condition 3 is satisfied.
5.2.5 Pure AC theory
We consider the case where the signature contains only constant symbols and AC
symbols ⊕1, . . . ,⊕k and the equational theory Eac contains only the AC equations
33
for each symbol:
Eac =
k⋃
i=1
⎧⎪⎨
⎪⎩
(x⊕i y)⊕i z = x⊕i (y ⊕i z)
x⊕i y = y ⊕i x
⎫⎪⎬
⎪⎭
With the empty rewriting system Rac = ∅, Eac is an AC-convergent theory. When
φ = νn˜.{M1/x1, . . . ,Mk/xk} is any frame, we define sat(φ) to be the smallest set
such that:
(1) M1, . . . ,Mk ∈ sat(φ), and n ∈ sat(φ) for every n ∈ fn(φ);
(2) if M1,M2 ∈ sat(φ) and M1 ⊕i M2 ∈ st(sat(φ)), then M1 ⊕i M2 ∈ sat(φ);
(3) if M1 =AC M2 and M1 ∈ sat(φ) then M2 ∈ sat(φ).
The set sat(φ) is finite since we add only terms smaller or equal than the maximal
size of the terms of φ. The set sat(φ) trivially satisfies conditions 1, 2, and 4 of
Definition 6. It also satisfies condition 3 since the rewriting system Rac is empty.
Thus Eac is locally stable.
Now, for any frame φ = νn˜.σ, the set of equations Eq(φ) simply consists of
EqAC (φ,N − n˜). Since names that do not appear in φ need not be considered,
EqAC (φ,N − n˜) is equivalent to EqAC (φ,N) where N is the set of free names
of φ, in the sense that for any frame ψ, ψ |= EqAC (φ,N − n˜) if and only if
ψ |= EqAC (φ,N). By Proposition 14, we conclude that the equational theory Eac
is locally finite.
5.2.6 XOR
We consider the theory Exor of the XOR operator (defined in Example 3).
We have seen that Exor is AC-convergent. We wish to verify that Exor is locally
stable. When φ = νn˜.{M1/x1, . . . ,Mk/xk} is any frame in normal form, we define
sat(φ) to be the smallest set, closed under AC, such that:
(1) M1, . . . ,Mk ∈ sat(φ), 0 ∈ sat(φ), and n ∈ sat(φ) for every n ∈ fn(φ);
(2) if M1, . . . ,Mk ∈ sat(φ) and f(M1, . . . ,Mk) ∈ st(sat(φ)), then f(M1, . . . ,
Mk) ∈ sat(φ);
(3) if M1,M2 ∈ sat(φ), then (M1 ⊕M2)↓ ⊆ sat(φ);
(4) if a is a name not in n˜ and if M ⊕ a →AC M ′ with M ′ ∈ st(sat(φ)), then
M ′ ∈ sat(φ).
Let us first show that sat(φ) is finite. Let the set sst(φ) of simple subterms of φ be
the set of subterms of φ whose head symbol is not⊕. Let S = {T1⊕· · ·⊕Tn | Ti ∈
sst(φ), Ti = 0, Ti = Tj ⇒ i = j} be the set of sums of distinct terms of sst(φ). The
set S is finite and sat(φ) ⊆ S. Indeed, it is easy to show that S satisfies the four
conditions above, using that st(S) = S.
34
The set sat(φ) trivially satisfies conditions 1, 2, and 4 of Definition 6. Let us
show that it satisfies condition 3. Let M1, . . . ,Mk ∈ sat(φ) and C be a context
such that fn(C) ∩ n˜ = ∅ and assume that C[M1, . . . ,Mk] h→ M . We have that
C[M1, . . . ,Mk] =AC
⊕k
i=1 Mi ⊕
⊕n
i=1 ai, where each ai is a name not in n˜ or the
constant 0. Let us show that one of the normal forms of C[M1, . . . ,Mk] is a con-
text of terms in sat(φ). Applying recursively rule 3, we obtain that (⊕ki=1 Mi)↓ ⊆
sat(φ). Now, applying recursively rule 4, we obtain that C[M1, . . . ,Mk]↓ =AC
M ′⊕⊕rj=1 aij , with M ′ ∈ sat(φ). By AC-convergence, we know that M →∗AC=AC
M ′⊕⊕rj=1 aij with M ′⊕⊕rj=1 aij ∈ sum⊕(sat(φ), n˜), since no aij is 0 (for other-
wise the term would not be in normal form), so the context C ′ that simply consists
of a hole satisfies the required conditions.
Like in the pure AC case, for any frame φ, the set of equation Eq(φ) simply consists
of EqAC (φ,N − n˜) since the only constant is 0 and 0 is itself in sat(φ). Since
names that do not appear in φ do not need to be considered, EqAC (φ,N − n˜) is
equivalent to EqAC (φ,N) where N is the set of free names of φ, in the sense that
for any frame ψ, ψ |= EqAC (φ,N − n˜) if and only if ψ |= EqAC (φ,N). Thus, by
Proposition 14, the equational theory Exor is locally finite.
Note that, in this example, we can also conclude without using Proposition 14.
Indeed, we can consider the set Eq′(φ) that consists of the equations
k1⊕
j=1
ζMij ⊕
k2⊕
j=1
nij =
l1⊕
j=k1+1
ζMij ⊕
l2⊕
j=k2+1
nij
such that ⎛
⎝ k1⊕
j=1
ζMij ⊕
k2⊕
j=1
nij =E
l1⊕
j=k1+1
ζMij ⊕
l2⊕
j=k2+1
nij
⎞
⎠φ
nij ∈ fn(φ), and l = j =⇒ Mil = Mij , nil = nij . Clearly, Eq′(φ) is finite and it
is easy to verify that, for any frame ψ, ψ |= EqAC (φ, n˜) if and only if ψ |= Eq′(φ).
5.3 Decidability results
In this section, we state and prove our decidability results for deduction and static
equivalence.
5.3.1 Decidability of deduction
Theorem 2 For locally stable equational theories, deduction is decidable. More
precisely, given a frame φ and a term M , once M ↓ and sat(φ) are computed,
φ  M can be decided in polynomial time in |M↓ | and |sat(φ)|.
The proof is based on the following lemma.
35
Lemma 9 Let E be a locally stable theory. Let φ = νn˜.σ be a frame. For every
context C1 such that fn(C1)∩ n˜ = ∅, for every Mi ∈ sat(φ), for every term T such
that C1[M1, . . . ,Mk] →AC T , there exist a context C2 such that fn(C2) ∩ n˜ = ∅,
and terms M ′i ∈ sat(φ), such that T →∗AC C2[M ′1, . . . ,M ′l ].
This lemma is a weak version of Lemma 11 presented in Section 5.3.2. Applying
repeatedly this lemma leads to the following corollary.
Corollary 1 Let E be a locally stable theory. Let φ = νn˜.σ be a frame. For every
context C1 such that fn(C1) ∩ n˜ = ∅, for every Mi ∈ sat(φ), for every term T in
normal form such that C1[M1, . . . ,Mk] →∗AC T , there exist a context C2 such that
fn(C2) ∩ n˜ = ∅, and terms M ′i ∈ sat(φ), such that T =AC C2[M ′1, . . . ,M ′l ].
Assuming Lemma 9, let φ = νn˜.σ be a frame, C1 be a context such that fn(C1) ∩
n˜ = ∅, Mi ∈ sat(φ), and T a term in normal form such that C1[M1, . . . ,Mk] →∗AC
T . Either C1[M1, . . . ,Mk] =AC T and we are done or we have C1[M1, . . . ,Mk]
→AC T ′ →∗AC T . By Lemma 9, there exist a context C2 such that fn(C2) ∩ n˜ = ∅,
and terms M ′i ∈ sat(φ) such that T ′ →∗AC C2[M ′1, . . . ,M ′l ]. By AC-confluence
of the equational theory and since T is in normal form, C2[M ′1, . . . ,M ′l ] →∗AC T .
Since the equational theory is AC-terminating, we repeat this transformation until
we obtain that T =AC C3[M ′′1 , . . . ,M ′′l ] for some terms M ′′i ∈ sat(φ) and some
context C3.
We show that for any term deducible from a frame φ, one of its normal forms is a
context over terms in sat(φ).
Proposition 16 Let φ = νn˜.σ be a frame, M be a closed term, and M↓ its set
of normal forms. Then φ  M if and only if there exist a term T ∈ M↓, a con-
text C, and terms M1, . . . ,Mk ∈ sat(φ) such that fn(C) ∩ n˜ = ∅ and T ==
C[M1, . . . ,Mk].
If there exists T ∈ M↓ such that T == C[M1, . . . ,Mk] with fn(C) ∩ n˜ = ∅, then
T =E C[ζM1 , . . . , ζMk ]σ, by construction of ζM1 , . . . , ζMk . Therefore, by Proposi-
tion 1, φ  T , so φ  M .
Conversely, if φ M , then by Proposition 1, there exists ζ such that fn(ζ)∩ n˜ = ∅
and M =E ζσ. Thus there exists T ′ ∈ (M↓ ∩ (ζσ)↓). Since ζσ →∗AC T ′, applying
Corollary 1, we obtain that T ′ =AC C[M1, . . . ,Mk] for some M1, . . . ,Mk ∈ sat(φ)
and C such that fn(C) ∩ n˜ = ∅. Thus we end the proof by choosing T ==
C[M1, . . . ,Mk].
We derive that φ  M can be decided by checking whether one of the terms in M↓
is of the form C[M1, . . . ,Mk] with Mi ∈ sat(φ). Regarding the complexity, once
M↓ and sat(φ) are computed, φ  M can be decided in polynomial time in |M↓ |
and |sat(φ)| using the same procedure as for Theorem 1.
36
5.3.2 Decidability of static equivalence
Theorem 3 For locally decidable equational theories, static equivalence is decid-
able. A fortiori, for locally finite equational theories, static equivalence is decid-
able.
The complexity of the resulting decision procedure closely depends on the com-
plexity of the procedure that ensures local decidability. For locally decidable equa-
tional theories, this complexity is simply the complexity of checking whether φ |=
Eq(ψ) given the frames φ and ψ. For locally finite equational theories, it depends
polynomially on the time needed to compute Eq′(φ) and the time needed to check
whether ψ satisfies each equation of Eq′(φ).
Our result relies on three hypotheses, namely AC-convergence, locally stability,
and local decidability. We leave as an open problem whether the third hypothesis
is essential. As far as we know, it might be that AC-convergence and local stability
imply local decidability. However, our experience with proofs of local decidability
suggests that this implication does not hold, at least not trivially.
The proof is based on two main lemmas that we prove in Appendix B.
Lemma 10 Let E be a locally stable theory. Let φ = νn˜.σ and ψ = νn˜′.σ′ be
two frames such that ψ |= Eq(φ). For all contexts C1 and C2 such that (fn(C1) ∪
fn(C2)) ∩ n˜ = ∅, for all terms Mi,M ′i ∈ sat(φ), if C1[M1, . . . ,Mk] =AC
C2[M
′
1, . . . ,M
′
l ], then (C1[ζM1 , . . . , ζMk ] =E C2[ζM ′1, . . . , ζM ′l ])ψ.
Lemma 11 Let E be a locally stable theory. Let φ = νn˜.σ be a frame. For every
context C1 such that fn(C1)∩ n˜ = ∅, for every Mi ∈ sat(φ), for every term T such
that C1[M1, . . . ,Mk] →AC T , there exist a context C2 such that fn(C2) ∩ n˜ = ∅,
and terms M ′i ∈ sat(φ), such that T →∗AC C2[M ′1, . . . ,M ′l ] and for every frame
ψ |= Eq(φ), (C1[ζM1, . . . , ζMk] =E C2[ζM ′1, . . . , ζM ′l ])ψ.
As for Corollary 1, applying repeatedly Lemma 11 leads to the following corollary.
Corollary 2 Let E be a locally stable theory. Let φ = νn˜.σ be a frame. For every
context C1 such that fn(C1) ∩ n˜ = ∅, for every Mi ∈ sat(φ), for every term T in
normal form such that C1[M1, . . . ,Mk] →∗AC T , there exist a context C2 such that
fn(C2) ∩ n˜ = ∅, and terms M ′i ∈ sat(φ), such that T =AC C2[M ′1, . . . ,M ′l ] and for
every frame ψ |= Eq(φ), (C1[ζM1, . . . , ζMk] =E C2[ζM ′1, . . . , ζM ′l ])ψ.
In order to check whether two frames satisfy the same equations, we show (us-
ing these two lemmas) that it is sufficient to check whether they satisfy the same
“small” equations.
Proposition 17 Let E be a locally stable theory. For all frames φ and ψ, we have
φ ≈s ψ if and only if φ |= Eq(ψ) and ψ |= Eq(φ).
37
By definition of static equivalence, if φ ≈s ψ then φ |= Eq(ψ) and ψ |= Eq(φ).
Conversely, assume that ψ |= Eq(φ) and consider M and N such that there exist
n˜ and σ such that φ = νn˜.σ, (fn(M) ∪ fn(N)) ∩ n˜ = ∅, and (M =E N)φ. Then
Mσ =E Nσ, so ((Mσ)↓∩(Nσ)↓) = ∅. Let T ∈ ((Mσ)↓∩(Nσ)↓). Since Mσ →∗AC
T , by applying Corollary 2 we obtain that there exist CM and M1, . . . ,Mk ∈ sat(φ)
such that fn(CM) ∩ n˜ = ∅, T =AC CM [M1, . . . ,Mk], and (M =E CM [ζM1, . . . ,
ζMk ])ψ. Since Nσ →∗AC T , we obtain similarly that there exist CN and M ′1, . . . ,
M ′l ∈ sat(φ) such that fn(CN) ∩ n˜ = ∅, T =AC CN [M ′1, . . . ,M ′l ], and (N =E
CN [ζM ′1, . . . , ζM ′l ])ψ. Moreover, since CM [M1, . . . ,Mk] =AC CN [M
′
1, . . . ,M
′
l ], we
derive from Lemma 10 that (CM [ζM1, . . . , ζMk] =E CN [ζM ′1 , . . . , ζM ′l ])ψ, and hence
that (M =E N)ψ. Symmetrically, if (M =E N)ψ and φ |= Eq(ψ), then (M =E
N)φ. We conclude that φ ≈s ψ.
Therefore, given φ and ψ, we may consider Eq(φ) and Eq(ψ) in order to decide
whether φ ≈s ψ. By local decidability of the theory, we can decide whether φ |=
Eq(ψ) and ψ |= Eq(φ).
6 Conclusion
This paper investigates decidability questions for message deducibility and static
equivalence, two formal representations for knowledge in the analysis of security
protocols. This investigation yields a few somewhat negative results, for exam-
ple that static equivalence cannot always be reduced to message deducibility. On
the other hand, the main results are strong, positive ones: message deducibility and
static equivalence are decidable under a wide class of equational theories. This class
includes, in particular, standard theories for basic cryptographic primitives. It also
includes some less standard, more advanced examples: theories of XOR, homo-
morphic encryption, blind signatures, addition, and pure AC theories. We succeed
in giving a unified treatment for this disparate collection of theories, with a body of
techniques that apply to all of them plus special techniques for verifying that par-
ticular theories belong in the class. In addition, for a simple, syntactically defined
subclass of theories, we prove that deducibility and static equivalence are actually
decidable in polynomial time.
The performances of the corresponding decision procedures obviously depend on
the choice of equational theory, and we do not expect them to be very good in many
cases. Nevertheless, for many theories of interest, deciding deducibility and static
equivalence may well be practical. Baudet has recently implemented a variant of
our procedures [6]. The tool ProVerif supports another approach for establishing
static equivalences [13].
As indicated in the introduction, deduction and static equivalence are static no-
38
tions, but they play an important role in analysis with respect to active attacks.
Nevertheless, it remains challenging to obtain decidability results with respect to
active attacks. This problem is addressed in recent and ongoing work. That work is
still largely under way, so detailed descriptions may be premature, but we briefly
mention some interesting developments. Going beyond the work of Delaune and
Jacquemard [22] (described in the introduction), Baudet has proved that both de-
duction and static equivalence are decidable under convergent subterm theories [7].
Comon-Lundh is studying the decidability of deduction under general equational
theories, including associativity and commutativity properties [19]. Overall, this
field appears as a lively one, with increasingly sophisticated techniques and pow-
erful theorems. We may therefore look forward to much progress in algorithmic
reasoning about the knowledge of active attackers in security protocols.
Acknowledgments
We are grateful to Michael Rusinowitch and Mathieu Baudet for very helpful dis-
cussions.
References
[1] Martı´n Abadi and Ve´ronique Cortier. Deciding knowledge in security protocols under
equational theories. In Proc. 31st Int. Coll. Automata, Languages, and Programming
(ICALP’2004), volume 3142 of Lecture Notes in Computer Science, pages 46–58.
Springer, July 2004.
[2] Martı´n Abadi and Ve´ronique Cortier. Deciding knowledge in security protocols under
(many more) equational theories. In Proc. 18th IEEE Computer Security Foundations
Workshop (CSFW’05), pages 62–76. IEEE Comp. Soc. Press, June 2005.
[3] Martı´n Abadi and Ce´dric Fournet. Mobile values, new names, and secure
communication. In Proceedings of the 28th ACM Symposium on Principles of
Programming Languages (POPL’01), pages 104–115, January 2001.
[4] Martı´n Abadi and Andrew D. Gordon. A bisimulation method for cryptographic
protocols. Nordic Journal of Computing, 5(4):267–303, Winter 1998.
[5] Martı´n Abadi and Andrew D. Gordon. A calculus for cryptographic protocols: The
spi calculus. Information and Computation, 148(1):1–70, January 1999.
[6] Mathieu Baudet. Private communication, 2005.
[7] Mathieu Baudet. Deciding security of protocols against off-line guessing attacks. In
Proceedings of the 12th ACM Conference on Computer and Communications Security
(CCS’05), pages 16–25. ACM Press, November 2005.
39
[8] Mathieu Baudet, Ve´ronique Cortier, and Steve Kremer. Computationally sound
implementations of equational theories against passive adversaries. Manuscript,
extended version of [9], 2005.
[9] Mathieu Baudet, Ve´ronique Cortier, and Steve Kremer. Computationally sound
implementations of equational theories against passive adversaries. In Proc. 32nd Int.
Coll. Automata, Languages and Programming (ICALP’2005), volume 3580 of Lecture
Notes in Computer Science, pages 652–663. Springer, July 2005.
[10] Bruno Blanchet. An efficient cryptographic protocol verifier based on Prolog rules. In
14th IEEE Computer Security Foundations Workshop (CSFW-14), pages 82–96, June
2001.
[11] Bruno Blanchet. From secrecy to authenticity in security protocols. In Manuel
Hermenegildo and Germa´n Puebla, editors, 9th Int. Static Analysis Symposium
(SAS’02), volume 2477 of LNCS, pages 342–359. Springer Verlag, September 2002.
[12] Bruno Blanchet. Automatic proof of strong secrecy for security protocols. In IEEE
Symposium on Security and Privacy, pages 86–100, May 2004.
[13] Bruno Blanchet, Martı´n Abadi, and Ce´dric Fournet. Automated verification of selected
equivalences for security protocols. In 20th IEEE Symposium on Logic in Computer
Science (LICS 2005), pages 331–340. IEEE Computer Society, June 2005.
[14] Michele Boreale, Rocco De Nicola, and Rosario Pugliese. Proof techniques for
cryptographic processes. In Proceedings of the Fourteenth Annual IEEE Symposium
on Logic in Computer Science, pages 157–166, July 1999.
[15] Johannes Borgstro¨m. Static equivalence is harder than knowledge. In Jos
Baeten and Iain Phillips, editors, Proceedings of the 12th International Workshop
on Expressiveness in Concurrency (EXPRESS’05), Electronic Notes in Theoretical
Computer Science, pages 44–55. Elsevier Science Publishers, August 2005.
[16] Yannick Chevalier, Ralf Kuester, Michael Rusinowitch, and Mathieu Turuani.
Deciding the security of protocols with Diffie-Hellman exponentiation and products in
exponents. In P. K. Pandya and J. Radhakrishnan, editors, FST TCS 2003: Foundations
of Software Technology and Theoretical Computer Science, 23rd Conference, volume
2914 of LNCS, pages 124–135. Springer Verlag, 2003.
[17] Yannick Chevalier, Ralf Kuester, Michael Rusinowitch, and Mathieu Turuani. An NP
decision procedure for protocol insecurity with xor. In Proceedings of the 18th Annual
IEEE Symposium on Logic In Computer Science (LICS’03), pages 261–270, 2003.
[18] Yannick Chevalier and Michael Rusinowitch. Combining intruder theories. In Proc.
32nd Int. Coll. Automata, Languages and Programming (ICALP’2005), volume 3580
of Lecture Notes in Computer Science, pages 639–651. Springer, July 2005.
[19] Hubert Comon-Lundh. Intruder theories (ongoing work). In Foundations of Software
Science and Computation Structures (FoSSaCS’04), volume 2987 of LNCS, pages 1–4.
Springer, 2004.
40
[20] Hubert Comon-Lundh and Vitaly Shmatikov. Intruder deductions, constraint solving
and insecurity decision in presence of exclusive or. In Proceedings of the 18th Annual
IEEE Symposium on Logic In Computer Science (LICS’03), pages 271–280, 2003.
[21] Hubert Comon-Lundh and Ralf Treinen. Easy intruder deductions. Technical Report
LSV-03-8, Laboratoire Spe´cification et Ve´rification, ENS de Cachan, France, 2003.
[22] Ste´phanie Delaune and Florent Jacquemard. Narrowing-based constraint solving
for the verification of security protocols. Technical Report LSV-04-8, Laboratoire
Spe´cification et Ve´rification, ENS de Cachan, France, April 2004.
[23] Nachum Dershowitz and Jean-Pierre Jouannaud. Handbook of theoretical computer
science, volume B: formal models and semantics, chapter Rewrite systems, pages 243–
320. MIT Press, 1991.
[24] Danny Dolev and Andrew C. Yao. On the security of public key protocols. IEEE
Transactions on Information Theory, IT-29(12):198–208, March 1983.
[25] Shafi Goldwasser and Silvio Micali. Probabilistic encryption. Journal of Computer
and System Sciences, 28:270–299, April 1984.
[26] Richard A. Kemmerer, Catherine Meadows, and Jonathan K. Millen. Three systems
for cryptographic protocol analysis. Journal of Cryptology, 7(2):79–130, Spring 1994.
[27] Steve Kremer and Mark Ryan. Analysis of an electronic voting protocol in the
applied pi calculus. In Proceedings of the 14th European Symposium on Programming
(ESOP’05), volume 3444 of LNCS, pages 186–200, April 2005.
[28] Pascal Lafourcade, Denis Lugiez, and Ralf Treinen. Intruder deduction for ac-like
equational theories with homomorphisms. In Proceedings of the 16th International
Conference on Rewriting Techniques and Applications (RTA’05), volume 3467 of
LNCS, pages 308–322. Springer, April 2005.
[29] Patrick Lincoln, John Mitchell, Mark Mitchell, and Andre Scedrov. A probabilistic
poly-time framework for protocol analysis. In Proceedings of the Fifth ACM
Conference on Computer and Communications Security, pages 112–121, 1998.
[30] Gavin Lowe. Breaking and fixing the Needham-Schroeder public-key protocol using
FDR. In Tools and Algorithms for the Construction and Analysis of Systems, volume
1055 of LNCS, pages 147–166. Springer Verlag, 1996.
[31] Lawrence C. Paulson. The inductive approach to verifying cryptographic protocols.
Journal of Computer Security, 6(1–2):85–128, 1998.
[32] Ronald L. Rivest, Leonard Adleman, and Michael L. Dertouzos. On data banks and
privacy homomorphisms. In R. DeMillo, D. Dobkin, A. Jones, and R. Lipton, editors,
Foundations of Secure Computation, pages 169–180. Academic Press, 1978.
[33] Pierre Samuel. Algebraic Theory of Numbers. Hermann, 1970.
[34] Steve Schneider. Security properties and CSP. In IEEE Symposium on Security and
Privacy, pages 174–187, 1996.
41
Appendix
A Proof of Proposition 6 and additional material on Proposition 5
Proposition 6. The following problem is undecidable.
Input: Two machines M(M1,M2) and M(M ′1,M ′2) and a word w of A∗.
Output: Does the following property (P) hold for M(M1,M2) and M(M ′1,M ′2):
for any sequences s1, s2 ∈ {1, 2}∗, M(M1,M2), w s1→ and M(M1,M2), w s2→
have the same tape if and only if M(M ′1,M ′2), w s1→ and M(M ′1,M ′2), w s2→ have
the same tape?
The halting problem for a deterministic Turing machine can be reduced to this
problem. Given any deterministic Turing machine M = (Q,A, q0, Qf , δ), we con-
struct the deterministic Turing machine T (M) = (Q,A unionmulti {co}, q0, Qf , δ′), where
we modify the transitions for the final states:
⎧⎪⎨
⎪⎩
δ′(q, a) = δ(q, a) ∀a ∈ A, q /∈ Qf
δ′(q, a) = (q, c0, L) ∀a ∈ A, q ∈ Qf .
Then M(M, T (M)), w s1→ and M(M, T (M)), w s2→ have the same tape for any
sequences s1, s2 ∈ {1, 2}∗ if and only if M does not reach its final state on w.
Now, let M0 be any fixed deterministic Turing machine. For any sequences s1, s2 ∈
{1, 2}∗, M(M0,M0), w s1→ and M(M0,M0), w s2→ have the same tape. We de-
duce that M does not reach its final state on w if and only M(M, T (M)) and
M(M0,M0) satisfy the property (P ). This ends the proof of proposition 6.
In order to reduce this undecidable problem to ≈s, we consider the equational the-
ory Etm displayed in figure A.1. By orienting the equations from left to right, we
obtain convergent rewriting rules such that M =Etm M ′ if and only if M↓== M ′↓
where M↓ is the normal form of M for these rewriting rules. Intuitively, we con-
sider terms of the form h(w1, q, w2, sn(0)), where w1 represents the tape before the
machine’s head, w2 represents the tape after the machine’s head, q is the control
state, and sn(0) is a counter that represents the number of rules that have been ap-
plied. A term [(q, a → q1, a1, D1), (q, a → q2, a2, D2)] represents a couple of rules
of two Turing machine. Then the term
Apply(i, [(q, a → q1, a1, D1), (q, a→ q2, a2, D2)], h(w1, q, w2, sn(0))),
where i ∈ {1, 2}, D1, D2 ∈ {L,R}, represents the application of the rule number 1
or 2 (depending on i) on the tape h(w1, q, w2, sn(0)). The result of this application
is given by the equational theory Etm.
42
Apply(1, [(xq, x1 → xq′, x2, R), y], h(z1, xq, x1 · z2, x′))
= h(z1 · x2, xq′, z2, s(x′))
Apply(1, [(xq, x1 → xq′, x2, R), y], h(z1, xq, x1, x′))
= h(z1 · x2, xq′,#, s(x′))
Apply(1, [(xq, x1 → xq′, x2, L), y], h(z1 · x3, xq, x1 · z2, x′))
= h(z1, xq′ , x3 · (x2 · z2), s(x′))
Apply(2, [y, (xq, x1 → xq′ , x2, R)], h(z1, xq, x1 · z2, x′))
= h(z1 · x2, xq′, z2, s(x′))
Apply(2, [y, (xq, x1 → xq′ , x2, R)], h(z1, xq, x1, x′))
= h(z1 · x2, xq′,#, s(x′))
Apply(2, [y, (xq, x1 → xq′ , x2, L)], h(z1 · x3, xq, x1 · z2, x′))
= h(z1, xq′ , x3 · (x2 · z2), s(x′))
Fig. A.1. The equational theory Etm.
Now, to each machine M(M1,M2), we associate the frame φM(M1,M2):
νA∪Q.{h(#, q0,#, 0)/x0}∪
⋃
a∈A,q∈Q
{[(q, a→ δ1(q, a)), (q, a→ δ2(q, a))]/xa,q}
Then we can verify that two machines M(M1,M2) and M(M ′1,M ′2) verify the
property (P) of proposition 6 if and only if φM(M1,M2) ≈s φM(M ′1,M ′2). We deduce
that ≈s is undecidable for the equational theory Etm.
At the same time,  remains decidable: in order to decide whether φ  M , where
φ = νn˜.σ, it is sufficient to decide if there exists ζ such that fn(ζ) ∩ n˜ = ∅
and ζσ =Etm M , that is, ζσ ↓== M ↓. Intuitively, for φ of the form φM(M1,M2)
and for M of the form h(w1, q, w2, sn(0)), we are looking for some sequences of
choices (represented by ζ) such that the tape of the machine M(M1,M2) after this
sequence of choices is equal to M . Since the term M contains the number of rules
that have been applied, it is sufficient to test any sequence of choices of length equal
to this number of rules, so there is a finite number of sequences to check. This idea
can be generalized to any φ and M , establishing that  is decidable. (We do not
give the proof of this generalization, in light of Borgstro¨m’s alternative proof of
Proposition 5.)
43
B Proofs of Lemmas 10 and 11
Definition 11 The set P(M) of paths of a term M is defined inductively by:
P(u)= 
P(f(M1, . . . ,Mn))=  ∪
n⋃
i=1
i · P(Mi) for i ≤ n
The subterm of M at position p ∈ P(M), written M |p, is defined inductively by:
M | =M
f(M1, . . . ,Mn)|i·p =Mi|p for i ≤ n
Lemma 10. Let E be a locally stable theory. Let φ = νn˜.σ and ψ = νn˜′.σ′ be
two frames such that ψ |= Eq(φ). For all contexts C1 and C2 such that (fn(C1) ∪
fn(C2)) ∩ n˜ = ∅, for all terms Mi,M ′i ∈ sat(φ), if C1[M1, . . . ,Mk] =AC
C2[M
′
1, . . . ,M
′
l ], then (C1[ζM1 , . . . , ζMk ] =E C2[ζM ′1, . . . , ζM ′l ])ψ.
This lemma is proved by induction on the sum of the sizes of C1 and C2.
Base case: If |C1|, |C2| ≤ cE , then the equation
(C1[ζM1, . . . , ζMk] = C2[ζM ′1, . . . , ζM ′l ])
is in Eq(φ) since |C1| ≤ cE and |C2| ≤ cE ≤ c2E , so ψ |= Eq(φ) implies
(C1[ζM1, . . . , ζMk] =E C2[ζM ′1 , . . . , ζM ′l ])ψ.
Inductive step: If neither C1 nor C2 is a hole, then C1 == f(C11 , . . . , Cr1) and
C2 == f(C
1
2 , . . . , C
r
2). There are two cases.
• f is not an AC symbol. Then, for every 1 ≤ i ≤ r, C i1[M1, . . . ,Mk] =AC
Ci2[M
′
1, . . . ,M
′
l ]. By applying the induction hypothesis, we obtain
(Ci1[ζM1 , . . . , ζMk ] =E C
i
2[ζM ′1, . . . , ζM ′l ])ψ
so
(C1[ζM1 , . . . , ζMk ] =E C2[ζM ′1, . . . , ζM ′l ])ψ
• f is an AC symbol⊕. We write C1 = C11 ⊕· · ·⊕Cr1 ⊕x1⊕· · ·⊕xp and C2 =
C12⊕· · ·⊕Cr′2 ⊕y1⊕· · ·⊕yp′ in such a way that the head symbol of the contexts
Ci1 and C
j
2 is not ⊕, C i1 and Cj2 are not holes, and the variables xi and yj refer
to the holes of C1 and C2. If the equation can be split, with C1 =AC C ′1 ⊕ C ′′1
and C2 =AC C ′2 ⊕ C ′′2 such that (C ′1[ζM1, . . . , ζMk] =E C ′2[ζM ′1, . . . , ζM ′l ])φ
and (C ′′1 [ζM1 , . . . , ζMk ] =E C ′′2 [ζM ′1, . . . , ζM ′l ])φ, then we conclude as above,
applying the induction hypothesis. On the other hand, if the equation cannot
be split, for every 1 ≤ i ≤ r, Ni def= Ci1[M1, . . . ,Mk] is not equal to some
44
Cj2 [M
′
1, . . . ,M
′
l ] so it must be a subterm of some M ′j . Since each M ′j is in
sat(φ) and by applying recursively rule 2 of Definition 6, we get that Ni is in
sat(φ), thus there exists ζNi ∈ ρ(φ) such that ζNiσ =E Ni. Symmetrically, for
every 1 ≤ j ≤ r, N ′j def= Cj1[M ′1, . . . ,M ′k] is not equal to some C i1[M1, . . . ,Ml],
so N ′j ∈ sat(φ) and there exists ζN ′j ∈ ρ(φ) such that ζN ′jσ =E N ′j .
· From Ni == Ci1[M1, . . . ,Mk] and applying the induction hypothesis,
we get ζNiσ′ =E Ci1[ζM1, . . . , ζMk]σ′ and similarly we obtain ζN ′jσ
′ =E
Cj2 [ζM1, . . . , ζMk]σ
′
.
· Renaming C i1[M1, . . . ,Mk] by Ni in our initial equation, we get N1 ⊕
· · ·⊕Nr⊕M1⊕· · ·⊕Mp = N ′1⊕· · ·⊕N ′r′ ⊕M ′1⊕· · ·⊕M ′p′ . Applying
the base case, we get (ζN1 ⊕ · · ·⊕ ζNr ⊕ ζM1 ⊕ · · ·⊕ ζMp =E ζN ′1 ⊕ · · ·⊕
ζN ′
r′
⊕ ζM ′1 ⊕ · · · ⊕ ζM ′p′ )σ. Since this equation is in Eq(φ), we deduce
(ζN1⊕· · ·⊕ζNr⊕ζM1⊕· · ·⊕ζMp =E ζN ′1⊕· · ·⊕ζN ′r′⊕ζM ′1⊕· · ·⊕ζM ′p′ )σ′.
Combining these equations, we get
(C1[ζM1 , . . . , ζMk ] =E C2[ζM ′1, . . . , ζM ′l ])ψ
If C1 or C2 is a hole, then let us say C1 == f(C11 , . . . , Cr1) and C2 == .
Let M,M1, . . . ,Mk ∈ sat(φ) and assume C1[M1, . . . ,Mk] =AC M . Again we
consider two cases.
• f is not an AC symbol. Then we have
f(C11 [M1, . . . ,Mk], . . . , C
r
1 [M1, . . . ,Mk]) =AC M
For every 1 ≤ i ≤ r, let Ni def= Ci1[M1, . . . ,Mk]. Thus, each Ni is a subterm of
M , so it is in st(sat(φ)). Since each Mj is in sat(φ) and by applying repeatedly
rule 2 of Definition 6, we get that Ni is in sat(φ). Thus there exists ζNi ∈ ρ(φ)
such that ζNiσ =E Ni.
· From Ni == Ci1[M1, . . . ,Mk] and applying the induction hypothesis, we
get ζNiσ′ =E Ci1[ζM1, . . . , ζMk ]σ′.
· From M =AC f(N1, . . . , Nr) and applying the base case, we get ζMσ′ =E
f(ζN1, . . . , ζNr)σ
′
.
Combining these equations, we get
(ζM =E C1[ζM1, . . . , ζMk])ψ
• f is an AC symbol⊕. We write C1 = C11⊕· · ·⊕Cr1⊕x1⊕· · ·⊕xp and C2 = x,
and we have C11 [M1, . . . ,Mk]⊕. . .⊕Cr1 [M1, . . . ,Mk]⊕M ′1⊕. . .⊕M ′p =AC M .
Each Ni def= Ci1[M1, . . . ,Mk] is a subterm of M ∈ sat(φ) thus is in sat(φ).
Again, there exists ζNi ∈ ρ(φ) such that ζNiσ =E Ni.
· From Ni == Ci1[M1, . . . ,Mk] and applying the induction hypothesis, we
get ζNiσ′ =E Ci1[ζM1, . . . , ζMk ]σ′.
· From N1 ⊕ . . . ⊕ Nr ⊕ M ′1 ⊕ . . . ⊕ M ′p =AC M and by the equation
ζN1 ⊕ · · · ⊕ ζNr ⊕ ζM ′1 ⊕ · · · ⊕ ζM ′p =E ζM is in Eq(φ), we get (ζN1 ⊕· · · ⊕ ζNr ⊕ ζM ′1 ⊕ · · · ⊕ ζM ′p =E ζM)σ′.
45
Combining these equations, we get
(C1[ζM1, . . . , ζMk] =E ζM)ψ
Lemma 11. Let E be a locally stable theory. Let φ = νn˜.σ be a frame. For every
context C1 such that fn(C1)∩ n˜ = ∅, for every Mi ∈ sat(φ), for every term T such
that C1[M1, . . . ,Mk] →AC T , there exist a context C2 such that fn(C2) ∩ n˜ = ∅,
and terms M ′i ∈ sat(φ), such that T →∗AC C2[M ′1, . . . ,M ′l ] and for every frame
ψ |= Eq(φ), (C1[ζM1, . . . , ζMk] =E C2[ζM ′1, . . . , ζM ′l ])ψ.
An easy case is when the reduction occurs inside one of the terms Mi: Mi →AC M ′i .
By definition of sat(φ) (since E is locally stable), we know that there exists C such
that |C| ≤ c2E , fn(C) ∩ n˜ = ∅, and M ′i →∗AC C[M ′′1 , . . . ,M ′′l ] where M ′′i ∈ sat(φ).
In addition, the equation ζMi = C[ζM ′′1 , . . . , ζM ′′l ] is in Eq(φ) (since |C| ≤ c2E), thus
(ζMi =E C[ζM ′′1 , . . . , ζM ′′l ])ψ. We obtain that
T == C1[M1, . . . ,Mi−1,M ′i ,Mi+1, . . . ,Mk]
→∗AC C1[M1, . . . , C[M ′′1 , . . . ,M ′′l ], . . . ,Mk]
and ⎛
⎜⎜⎜⎜⎜⎝
(C1[ζM1, . . . , ζMk]
=E
C1[ζM1, . . . , C[ζM ′′1 , . . . , ζM ′′l ], . . . , ζMk]
⎞
⎟⎟⎟⎟⎟⎠ψ
We now consider the case where the reduction does not occur inside the terms Mi.
We can assume that
for every path p of C1,
if C1|p[M1, . . . ,Mk] is in sat(φ), (*)
then C1|p is the single hole context.
Indeed, if there exists a path p of C1 such that T1 def= C1|p[M1, . . . ,Mk] ∈ sat(φ) and
C1|p is not a hole then C1[M1, . . . ,Mk] == C ′1[T1,M1, . . . ,Mk] where T1,Mi ∈
sat(φ) and C ′1 is a context strictly smaller than C1. In that case, we consider C ′1[T1,
M1, . . . ,Mk] instead of C1[M1, . . . ,Mk] and we apply the transformation again
until property (*) holds.
We have
C1[M1, . . . ,Mk] == C3[M
′′ ⊕ M ′ ⊕
r⊕
i=1
C ′i[M1, . . . ,Mk],M1, . . . ,Mk]
where M ′ = M ′1 ⊕ . . . ⊕M ′l , M ′′ = M ′′1 ⊕ . . . ⊕ M ′′l with M ′i ⊕ M ′′i ∈ sat(φ),
the head symbol of the context C ′i is not ⊕, C ′i is not a single hole, and T1 def=
46
M ′ ⊕⊕ri=1 C ′i[M1, . . . ,Mk] is an instance M0θ (modulo AC) of the left-hand side
of some rule M0 → N0 of the rewriting system associated with E.
For each variable x of M0, we consider the occurrences of xθ in T1.
(1) Either xθ occurs as a subterm of one of the terms Mi or M ′i ;
(2) or there exists a subterm of T1 of the form N1 ⊕ . . .⊕ Np with Ni =AC N ′i ⊕
N ′′i ∈ sat(φ) for some N ′′i such that xθ =AC N ′1 ⊕ . . .⊕N ′p;
(3) or there exists a subterm of T1 of the form
N1 ⊕ . . .⊕Np ⊕
r′⊕
i=1
C ′′i [M1, . . . ,Mk]
(modulo AC) where the head symbols of the contexts C ′′i are not ⊕ and the
contexts C ′′i are not a hole, and
xθ =AC N
′
1 ⊕ . . .⊕N ′p ⊕
r′⊕
i=1
C ′′i [M1, . . . ,Mk]
with Ni =AC N ′i ⊕N ′′i ∈ sat(φ) for some N ′′i , thus the terms N ′i are subterms
of terms of sat(φ).
Note that case 3 cannot occur simultaneously with case 1 or case 2 for the same
variable x. If case 3 were to occur simultaneously with case 1 or case 2, we would
have that some C ′′i [M1, . . . ,Mk] is a subterm of some Mi or M ′i , thus applying
recursively rule 2 of Definition 6, we would get that C ′′i [M1, . . . ,Mk] ∈ sat(φ),
which contradicts property (*) (since C ′′i is not a hole).
Without loss of generality, we assume that the variables of M0 are x1, . . . , xk1 , y1,
. . . , yk2 where the variables xi are in case 1 or case 2 and the variables yj are in
case 3. For each variable yj, we consider the l occurrences of yj in T1.
yjθ =AC N
1
1 ⊕ . . .⊕N1k1 ⊕
⊕r1
i=1 C
1
i [M1, . . . ,Mk]
.
.
.
=AC N
l
1 ⊕ . . .⊕N lkl ⊕
⊕rl
i=1 C
l
i [M1, . . . ,Mk]
where the terms N ji are subterms of terms in sat(φ) and the head symbols of the
contexts Cji are not ⊕.
We write cl(Cji [M1, . . . ,Mk]) for the class of C
j
i [M1, . . . ,Mk] modulo AC, and
we associate a fresh name symbol acl(Cji [M1,...,Mk]) with each cl(C
j
i [M1, . . . ,Mk]).
Therefore, a
cl(C
j1
i1
[M1,...,Mk])
and a
cl(C
j2
i2
[M1,...,Mk])
are the same symbol whenever
47
Cj1i1 [M1, . . . ,Mk] =AC C
j2
i2 [M1, . . . ,Mk]. In each equation
N j11 ⊕ . . .⊕N j1kj1 ⊕
rj1⊕
i=1
Cj1i [M1, . . . ,Mk]
=AC N
j2
1 ⊕ . . .⊕N j2kj2 ⊕
rj2⊕
i=1
Cj2i [M1, . . . ,Mk]
every Cj1i [M1, . . . ,Mk] must be equal modulo AC to one of the terms C
j2
i [M1,
. . . ,Mk]. If Cj1i [M1, . . . ,Mk] were equal to some subterm of the terms N
j2
i , then
Cj1i [M1, . . . ,Mk] would be a term of sat(φ), contradicting property (*). Thus, we
obtain that
N11 ⊕ . . .⊕N1k1 ⊕
⊕r1
i=1 aC1i [M1,...,Mk]
.
.
.
=AC N
l
1 ⊕ . . .⊕N lkl ⊕
⊕rl
i=1 aCli [M1,...,Mk]
def
= Tyj
We consider the substitution θ ′ such that xiθ′ = xiθ and yjθ′ = Tyj . We define
θ′′(acl(Cji [M1,...,Mk])) = C
j
i [M1, . . . ,Mk].
We also consider the term T2 that is obtained from
⊕r
i=1 C
′
i[M1, . . . ,Mk] by replac-
ing each Cji [M1, . . . ,Mk] with acl(Cji [M1,...,Mk]).
We have T2 == C2[S1, . . . , Sk] for some context C2 such that | ⊕C2| ≤ |M0| ≤ cE
and Si ∈ sum⊕(sat(φ), n˜). Since M ′′ ⊕ T2 is an instance M0θ′ of M0 we have
M ′ ⊕M ′′ ⊕ T2 →AC M ′ ⊕ N0θ′. Applying condition 3 of Definition 6, there exist
S ′i ∈ sum⊕(sat(φ), n˜), there exists a context C ′, such that |C ′| ≤ c2E, fn(C ′) ∩ n˜ =
∅, and M ′⊕N0θ′ →∗AC C ′[S ′1, . . . , S ′l]. Applying the substitution θ ′′, we deduce that
M ′ ⊕ N0θ =AC M ′ ⊕ N0θ′θ′′ →∗AC C ′[S ′1, . . . , S ′l]θ′′. Note that C ′[S ′1, . . . , S ′l]θ′′ is
a context of terms of sat(φ):
C ′[S ′1, . . . , S
′
l]θ
′′ = C ′′[M1, . . . ,Mk, S ′1, . . . , S
′
l]
To each sum S = α1M1 ⊕ · · · ⊕ αnMn ⊕ β1n1 ⊕ · · · ⊕ βknk in sum⊕(sat(φ), n˜),
we associate the term ζS = α1 ·⊕ ζM1 ⊕· · ·⊕αn ·⊕ ζMn ⊕β1 ·⊕ n1⊕· · ·⊕βk ·⊕ nk.
Now, since the equation ζM ′⊕M ′′ ⊕ C2[ζS1 , . . . , ζSk ] = C ′[ζS′1 , . . . , ζS′l ] is in Eq(φ),
we deduce
(ζM ′⊕M ′′ ⊕ C2[ζS1, . . . , ζSk] = C ′[ζS′1, . . . , ζS′l ])ψ
If a
cl(C
j1
i1
[M1,...,Mk])
= a
cl(C
j2
i2
[M1,...,Mk])
, we have
Cj1i1 [M1, . . . ,Mk] =AC C
j2
i2 [M1, . . . ,Mk]
48
thus (by Lemma 10) we have
(Cj1i1 [ζM1 , . . . , ζMk ] = C
j2
i2 [ζM1, . . . , ζMk ])ψ
So we can reconstruct M ′′ ⊕ T1 and obtain
ζM ′⊕M ′′ ⊕
r⊕
i=1
C ′i[ζM1, . . . , ζMk] = C
′′[ζM1, . . . , ζMk, ζS′1, . . . , ζS′l ])ψ
which allows us to conclude the proof of Lemma 11.
49
