INFORMATIONAND CONTROL(14, 2--22 (1985)

A Taxonomy of Problems with Fast Parallel Algorithms*
STEPHEN A. COOKt
Department of Computer Science, University of Toronto, Toronto, Canada M5S 1A4
The class NC consists of problems solvable very fast (in time polynomial in log n) in parallel with a feasible (polynomial) number of processors. Many natural problems in NC are known; in this paper an attempt is made to identify important subclasses of NC and give interesting examples in each subclass. The notion of NC~-reducibility is introduced and used throughout (problem R is NCl-reducible to problem S if R can be solved with uniform log-depth circuits using oracles for S). Problems complete with respect to this reducibility are given for many of the subclasses of NC. A general technique, the "parallel greedy algorithm," is identified and used to show that finding a minimum spanning forest of a graph is reducible to the graph accessibility problem and hence is in NC 2 (solvable by uniform Boolean circuits of depth O ( l o f n) and polynomial size). The class LOGCFL is given a new characterization in terms of circuit families. The class DET of problems reducible to integer determinants is defined and many examples given. A new problem complete for deterministic polynomial time is given, namely, finding the lexicographically first maximal clique in a graph. This paper is a revised version of S. A. Cook, (1983, in "Proceedings 1983 Intl. Found. Comut. Sci. Conf.," Lecture Notes in Computer Science Vol. 158, pp. 78-93, Springer-Verlag, Berlin/New York). ©1985Academic Press, Inc.

1. INTRODUCTION

In this paper we are concerned with the class of problems solvable very rapidly (in time polynomial in log n) by a parallel computer with a feasible (i.e., polynomial) number of processors. This class was first identified and characterized by Pippenger [1979], and is now commonly called NC for "Nick's Class" (see Cook, 1981; Dymond and Cook, 1980; Ruzzo, 1981). Since then the class has been shown to include a large and interesting variety of problems. Our task here is to give examples of these problems and classify them according to the methods applicable for demonstrating their inclusion in NC.

* This paper is a revised and expanded version of a paper presented at the International Conference on "Foundations of Computation Theory" held in Borgholm, Sweden, August 21-27, 1983.
t Research supported by the Killam Foundation of Canada and the National Sciences and Engineering Research Council of Canada.

0019-9958/85 $3.00
Copyright© 1985 by AcademicPress, Inc. All rightsof reproductionin any formreserved.

2

A TAXONOMY OF PROBLEMS
A great many formal parallel computer models have appeared in the literature (see Cook, 1981; Vishkin, 1983 for surveys). One common kind is the shared memory computer, in which a number of processors work together synchronously and communicate with a common random access memory. In the event of read or write conflicts in this shared memory several conventions are possible. The particular variation we mention here is the SIMDAG introduced in Goldschlager (1977; 1978; 1982) in which both read and write conflicts are allowed, and the lowest numbered processor succeeds in the case of a write conflict. One reason for favoring these conventions is that the circuitry needed to implement them seems not to be substantially more complicated than that needed to implement a machine which disallows read and write conflicts. A more important reason is that the complexity classes defined in terms of SIMDAG time have nice characterizations in terms of the alternion depth required on circuits (Chandra, Stockmeyer, and Vishkin, 1982) or alternating Turing machines (Ruzzo and Tompa, 1982) (see Propositions 4.6 and 4.7 below).
At the present time no large scale general purpose parallel computers have been built. Although the shared memory model seems like a good way to go (see Schwartz, 1980a) the arbitrariness in the detailed definition makes it unappealing for an enduring mathematical theory. A more attractive model for such a theory is uniform Boolean circuit families (Borodin, 1977). It seems that all real computers will be built from circuits, and hence circuits represent a more fundamental model than the others usually considered. Also the circuit complexity of Boolean functions is an appealing mathematical subject that has been studied since Shannon (1949). Finally, the complexity classes defined in terms of circuit families have a precise characterization in terms of alternating Turing machines (Ruzzo, 1981). Furtunately, the parallel class N C remains the same whether uniform circuit families or shared memory computers are used to define it, although the subclasses N C k may be different.
One criticism sometimes heard of this general theory of parallel computers is that real circuits must exist in 3-dimensional space and therefore the communication time for one parallel step must be O(nl/3). Thus it seems to make no sense to talk about solving problems in time O(logk n). The obvious answer to this criticism is that by the same reasoning, even sequential random access memories should have access time D(nl/3), and yet it has proven very useful to assume access time O(l) or O(logn) in mathematical models of such machines.
In this paper we present the following sequence of class inclusions (names to be defined) between NC 1 (the problems solvable by the fastest parallel algorithms) and FP (or "function P," the problems solvable by sequential polynomial time algorithms):

STEPHEN A. COOK

CFL * ~ A C 1

N C ~~_F L c_ N L * ~_

c_NCc_NC~_FP.

DET

(1.1)

In Section 2, uniform circuit families and the classes N C k are defined. In Section 3, examples in the fundamental class N C 1 are given and the notion of N C ~ reduction is introduced. In Section 4 the classes FL, N L * , CFL*, and A C 1 are defined with examples, and the "parallel greedy algorithm" is explained. In Section 5 the class DET of problems reducible to computing integer determinants is introduced with examples. In Section 6, examples of problems in FP which are likely not in NC because they are complete for FP are given. In Section 7 the classes random NC k are defined with examples. Finally, in Section 8 some general remarks and open questions are presented.

2. UNIFORM CIRCUIT FAMILIES

A (Boolean) circuit ~ with n inputs and m outputs is a finite directed acyclic graph with nodes (called gates) labelled as follows. The circuit c~has k "input nodes" with indegree zero labelled x~ ..... x k, respectively. All other nodes of indegree zero are labelled either 0 or 1. All nodes of indegree one are labelled 7 . All other nodes have indegree two and are labelled either/~ or V. Exactly m nodes are labelled output nodes and have labels y~ ..... Ym, respectively. Every input node has at least one path from it to some output node. We use e(c0, complexity of ~, to denote the number of nodes of c¢, and d(e), depth of c~, to denote the length of the longest path from some input to some output. The circuit c~ computes a function f : {0, 1)k--* {0, 1} m in the obvious way.
In general, we are interested in computing a function f = (f,), where fn: {0, 1}g(n)~ {0, 1} h(n), and g(n) is monotone strictly increasing and g(n) = n°(~)(i.e., g ( n ) = O(n C) for some constant c). (The function f will be treated as the union over n off~.) A circuit family with input size g and output size h is a sequence (~n), where ~n is a circuit with g(n) inputs and h(n) outputs. The family ( a n ) computes the f u n c t i o n f i f f ~'o computes f , for all n.
For example, the function "directed graph transitive closure" has g(n) = h ( n ) = n 2. The argument x for f~(x) is a string of n 2 bits representing the n x n adjacency matrix row by row for an n-node digraph G. The value f n ( x ) is a string of n 2 bits representing the transitive closure of G.
In many cases, we do not want our circuit to compute a single-valued function, but rather to find one value of a multiple-valued function. For example, if we want to find a spanning forest in an undirected graph, the solution may not be unique, and any correct answer will do. This motivates the following:

A TAXONOMY OF PROBLEMS
DEFINITION. A problem R (with size parameters g and h) (similar to search problem in Garey and Johnson, 1979) is a family ( R n ) of binary relations such that R,, _c {0, 1}g(n)x {0, 1 }h(,). (The problem R will also be treated as the binary relation whidh is the union over n of R,.) A circuit family (Tn) solves the problem R iff the function ( f , ) computed by (c~n) realizes R in the following sense: For each n and each x in {0, 1} g(n), if Rn(x, y) holds for some y, then Rn(x, fn(x)) holds.
Note that if we identify a function f with the problem which is the graph off, then in particular a circuit family solves the function it computes.
To illustrate the above definition, if the problem R is to find a spanning forest, then R,,(x, y) holds whenever x codes an n-node undirected graph G and y codes a spanning forest for G. The family (c~n) solves R iff for all n, when the inputs to ~, code an n-node graph G, the outputs to % code a spanning forest for G.
In this paper we restrict our attention to "uniform" circuit families; that is, families (c~,,) for which some algorithm, given n, easily generates the nth circuit c~,. There are several reasons for requiring uniformity. First, one may want to exhibit c~, for various values of n, and this will not always be feasible without some uniformity condition. Second, realistic parallel machine models such as SIMDAGs are naturally uniform and their computing power can be compared to uniform circuit families, but not very well with non-uniform families. Finally, uniform circuit families define complexity classes which have interesting relationships with traditional classes defined by time and space.
Postponing for the moment the exact definition of uniform, we will now define NC.
DEFINITION. NC k is the set of all problems R solvable by a uniform circuit family ( ~ , ) with c(~,)=n °~11 (i.e., c(c~) is bounded by some polynomial in n) and d(7,)= O(log k n). N C = Oh NC k.
The definition of uniform we adopt here is the one introduced and called UE, uniform by Ruzzo (1981). The reason for this choice is that it is the weakest definition for which we have a proof of Proposition 2.1 below for all k ~>1. We will not define UE, uniform here, since the discussion in the following paragraphs explains it sufficiently for our purposes.
Proposition 2.1 concerns alternating Turing machines (ATMs) (see Chandra, Kozen, and Stockmeyer, 1981; Ruzzo, 1980). (The reader unfamiliar with ATMs could skip Proposition 2.1.) Our ATMs differ from the usual ones because they compute functions and solve problems instead of recognizing sets. To explain how they do this, let us say that the set Af associated with the function f : {0, 1 } * ~ {0, 1}* is A~= {(x, i ) l t h e ith bit of f ( x ) is l }. (Note that a function f is in NC ~ iff the characteristic

6 STEPHEN A. COOK
function of Ay is in N C k and is polynomially bounded; i.e., If(x)l = Ixl o(1~.) We say that an ATM M computes f iff M recognizes Af and f is polynomially bounded. Finally, M solves a problem R iff M computes some function f which realizes R (see the definition of " ( ~ ) solves R").
PROPOSITION 2.1 (Ruzzo, 1981). For all k >~1, R is in N C k iff R is solved by some A T M in time O(log k n) and space O(log n).
A more common and simpler (though perhaps worse) definition of uniformity is the following: The family ( ~ , ) is log-space uniform iff some deterministic Turing machine will for all n, when presented with n in binary on its input tape, generate a description G of an on its output tape using work-tape space O(logc(~,)). We use the notation NC k (log-space uniform) to refer to NC k when "uniform" means "log-space uniform."
PROPOSITION 2.2 (Ruzzo, 1981). N C 1~_NCl(log-space uniform) and for k >12, N C k = NCk(log-space uniform).
Note that according to Proposition 2.2, N C = N C (log-space uniform). In fact, NC can also be characterized in terms of shared memory computers as those problems solvable in time polynomial in log n by a polynomial number of processors. Thus the class NC is to a large extent independent of the exact parallel computer model used to define it.
When showing that a problem is in NC k for k t> 2 by constructing a circuit family ( " n ) which solves it, log-space uniform is a sufficient uniformity condition. However, for k = 1, the apparently stronger condition of UE. uniform is needed. This stronger condition is usually easily met, although in some cases such as the divisibility predicate (see Sect. 3) we do not know how to meet it. The definition of UE. uniform demands that the so-called "extended connection language" (Ruzzo, 1981) for (c~n) can be recognized by an ATM in time O(log n). A sufficient condition for this is that some deterministic Turing machine, given n in binary, a gate number g, a path_p___ff_{L,R }* of length O(log n), and parameter y, can determine in space ,,/log n whether y describes the gate reached in ~n by tracing the path p back towards the inputs from fate g. Since a Turing machine which is allowed space up to the square root of its input length is very powerful, there is usually no difficulty in verifying this condition for families ( , , ) which are intuitively uniform.
We will have occasion to use a third and weaker notion of uniformity. Let us say that ( " n ) is P-uniform iff the transformation n ~ is computable by a deterministic Turing machine in time bounded by a polynomial in c(~n). Then N C k ~ N C k (log-space uniform)___NCk (Puniform) for all k>~ 1. Probably P-uniform is the most general notion of uniformity consistent with our earlier criterion that one should be able to

A TAXONOMY OF PROBLEMS
feasibly exhibit c~n given n. The integer division problem is in N C ~ (Puniform) (see Sect. 3). In general, we conjecture that N C is a proper subset of NC (P-uniform).
3. THE CLASS N C 1 AND N C 1 REDUCIBILITY
Recall that N C ~ consists of all problems solvable by a uniform circuit family of depth O(logn), where n is the number of input bits (the polynomial size bound is redundant in this case). Examples of functions in N C ~ are: the sum or product of 2 integers of n bits each, the sum of n integers of n bits each, integer or Boolean matrix multiplication, and sorting n integers of n bits each. Circuits for these functions are described in (Savage, 1976; Borodin, Cook, and Pippenger, 1983; Muller and Preparata, 1975).
Integer division (finding the quotient and remainder of two n-bit integers) is not known to be in N C ~ (it is easily in NC2). Recently it has been shown (Beame, Cook, and Hoover, 1984) to be in N C ~ (P-uniform), along with finding the product of n n-bit integers. The smallest depth known for a log-space uniform family of polynomial size circuits for division is O(log n log log n) (Reif, 1983) (these circuits are probably also UE. uniform). Also the divisibility relation and finding the product of n integers modulo a small (of size O(n)) integer are in N C ~ (log-space uniform) (see Beame, Cook, and Hoover, 1984), thus showing these problems are solvable on a deterministic Turing machine in log space.
In the study of sequential time complexity, polynomial time reducibility (in its two forms "Cook" and "Karp" (Garey and Johnson, 1979)) has become standard, and in the study of space complexity log space reducibility (usually in its "Karp" or many-one form) is used (Jones and Laaser, 1977). In the study of parallel computation, it seems to me that N C 1 reducibility is appropriate. One possible definition is to say that a set A is many-one N C ~ reducible to a set B iff there is an N C 1 computable function f such that for all x, x e A iff f ( x ) e B . However, here we are interested not just in sets, but in computing functions and solving problems, so the "Turing" (or "Cook") version of reducibility is most useful.
DEFINITION. A problem R is N C ' reducible to S (written R ~<S) iff there is a UE. uniform family { e , ) of circuits for solving R, where d(~,)= O(log n), and c~n is allowed to have oracle nodes for S. An oracle node for S is a node with some sequence {Yl,..., Yr) of input edges and a sequence (z, ..... Zs) of output edges whose values satisfy

8 STEPHEN A. COOK
S(yl "" Yr, Zl ""zs). For the purpose of defining depth in en, this oracle node counts as depth [-log(r + s)q.
A similar definition for the case of sets is found in (Wilson, 1983). It is not hard to check that ~< is transitive and reflexive. The closure C* of a class C of problems (under ~<) consists of all problems R such that R ~<S for some S in C. The class C is closed iff C = C*.
PROPOSITION 3.1. The class N C k is closed under <~for all k >~1.
Proof Suppose R<<.S and S e N C k. Suppose ( ~ n ) realizes the reduction R ~<S, and (fin) solves S in N C k. Then a family (Tn) for solving R in N C k can be constructed by letting 7n be en with each oracle node for Sm replaced by tim" TO check for example, that d(Tn) = O(log k n), consider any path p in 7~ and suppose p hits instances tim1, tim2 ..... of circuits substituted for oracle nodes in ~n. Then the length of p is at most
d(fimj) + O(log n) = O ( Z log k mj) + O(log n) = O(log k n), where the last bound follows since ~log mj= O(logn). The uniformity of (Tn) can be proved from the uniformity of (c~,) and (fin).
DEFINITION. A problem R is hard (or N C 1 hard) for the class C iff S ~<R for all S in C. Further, R is complete (or NClcomplete) for C iff R is hard for C and R e C.
The following obvious proposition is an abstract analog for NC 1 reducibility of the well-known fact that if a set is N P complete, then its is in P iff P = N P .
PROPOSITION 3.2. I f the class C is closed under <~ and C ~_D, and if the problem R is complete for D, then R e C iff C = D.
Each of the sets C in the list of inclusions (1.1) in Section 1 is in fact closed under ~<. Hence each time we show that a problem R is complete for a class D occurring later in the list we give evidence that R is not in C. At least a proof that R is in C would solve an open question (namely, whether C= D) in the "wrong way."
4. OTHER CLASSES AND THE PARALLEL GREEDY ALGORITHM
Let FL be the class of problems realized by functions computable in space O(logn) on a deterministic Turing machine, where the output is placed on a special write-only tape which does not participate in the space bound. Let L be the class if sets (regarded as 0-1 functions) recognized in space O(log n) on a deterministic Turing machine.

A TAXONOMY OF PROBLEMS
PROPOSITION 4.1. FL = L*, and hence N C 1~_FL.
To show FL ~ L*, note that if a function f is in FL, then the set Ar (defined before Proposition 2.1) is in L, andf~<As. To show L* ~_FL, we use the simulation of depth-bounded circuits by space-bounded Turing machines given in Borodin (1977).
Two examples of problems in FL are (1) undirected graph acyclicity (Cook, 198l), and (2) finding the product of two permutations where input and output permutations are represented as products of disjoint cycles. Both of these are NC 1 complete for FL; the first by an adaptation of a proof in Hong (1980), and the second by an argument in McKenzie and Cook (in preparation). A third problem in FL not known to be in NC 1 is the Boolean formula value problem (Lynch, 1977). This problem is probably not complete for FL, because it can be solved by circuits of depth O(log n log log n) (Gupta, 1985).
Let N L be the class of sets accepted by a nondeterministic machine in space O(log n). Examples of sets complete for N L are the directed graph accessibility problem, directed k-connectivity, and unsatisfiability of 2-CNF Boolean formulas (Jones, Lien, and Laaser, 1976).
Let NL* be the closure of NL (as a class of 0-1 functions) under ~<. Of course every problem complete for NL is also complete for NL*. Examples of problems for NL* which are more naturally expressed as functions than sets are transitive closure of a Boolean matrix (i.e., directed graph transitive closure), and the shortest path problem for graphs with positive edge weights expressed in unary notation.
An example of a problem in NL* which is probably not complete is the knapsack problem with unary weights (Tompa, 1984). An example which may or may not be complete is computing a topological sort of a directed acyclic graph. This problem is certainly complete if one requires the algorithm to state whether or not the input graph is acyclic, but otherwise its completeness is unknown. Topological sort appears in Ruzzo's list (Ruzzo, 1980a) of NC 2 problems and has a published NC 2 algorithm in Dekel, Nassimi, and Sahni, (1981). Recently, Ruzzo (Ruzzo, 1984) devised the following simple NL* algorithm for topological sort: Compute the transitive closure; sum the columns, giving the number of predecessors of each node; then sort nodes by these numbers.
Here is another interesting example.
PROPOSTTION 4.2. The problem of finding a minimum spanning forest for an n-node undirected graph with n-bit positive integer weights is in NL* (and hence in NC2).
The proof is a parallel version of the sequential greedy algorithm (see Papadimitriou and Steiglitz, 1982, for example). Let G = ( V , E ) be the

10 STEPHEN A. COOK
input graph, and for any set E' ___E of edges let rank (E') be the number of edges in a spanning forest for G(E'), the graph spanned by E'. Then rank (E') is the number of vertices in G(E') minus the number of connected components in G(E'). The number of components in G(E') can be computed in NL* by computing the transitive closure of G(E') in NL* and using this to count in NC 1 the number of vertices i in G(E') which are not connected to any vertex j in G(E') with j < i. The parallel greedy algorithm proceeds by first sorting in N C 1 the edges {el, e2..... er} = E of G according to increasing weight and then outputting each edge ei which satisfies the condition:
rank(el ..... ei) > rank(el ..... ei_ 1).
The fact that these edges form a minimum weight spanning forest follows from Proposition4.3 below, and from the fact that the rank function defined above satisfies the matroid axioms in a matroid whose bases are the spanning forests of G. Note that NL* ~_ N C 2 by Borodin (1977).
PROPOSmON 4.3 (Parallel greedy algorithm). Let E be a finite set with a positive weight associated with each element of E, and suppose {el,..., er ) is a list of the elements of E in increasing order of weight. Suppose a function rank(U) is defined on the subsets of E which satisfies the matroid axioms. Then the set B = {ei I rank(el ..... ei) > rank(el ..... el-1)} is a matroid base of minimum total weight.
The proof is similar to the justification of the sequential greedy algorithm (Papadimitriou and Steiglitz, 1982). This proposition is an abstraction of the method described in Borodin, von zur Gathen, and Hopcroft (1982) for finding a column basis for a matrix. The method yields a fast parallel algorithm whenever the rank function can be computed quickly in parallel.
The class LOGCFL consists of all sets log space reducible to the class CFL of context free languages. (Here A is log space reducible to B iff there is some log space computable function f such that for all x, x cA iff f ( x ) e B.) Sudborough (1978) characterized LOGCFL as those sets accepted by a nondeterministic auxiliary pushdown machine in log space and polynomial time. Sudborough's proof that every set accepted by a nondeterministic auxiliary PDM in log space and polynomial time is log-space reducible to CFL actually shows that the reduction is via an N C ~ computable function. Thus L O G C F L = N C I C F L , where the latter class is defined by replacing "log-space reducible" by "many-one NC ~ reducible" (i.e., the reducing function must be N C ~ computable) in the definition of LOGCFL. Note that Sudborough's characterization implies that NL~_LOGCFL. Ruzzo (1980b) further characterized LOGCFL as those

A TAXONOMY OF PROBLEMS

11

sets accepted by an ATM in log space and polynomial tree size, and proved L O G C F L c N C 2.
A third interesting characterization of LOGCFL comes from the work of Skyum and Valiant (1981). A Boolean circuit e with negations only at its leaves (inputs) can be regarded as computing a polynomial in its input variables and their negations over the Boolean semiring in which + is v and • is /x. The degree of this polynomial is then by definition the degree (denoted degree(e)) of the circuit.
In the following proposition, we assume the circuits en have negations only at their leaves.

PROPOSITION 4.4 LOGCFL is the class of sets recognizable by a uniform family ( e n> of Boolean circuits with degree (en)= n °(1) and c(en)= n °~1).
Remark. If the word "uniform" is deleted the class of sets so defined is called pdC in Skyum and Valiant (1981).

Proof That such families <en> compute sets in LOGCFL follows from Ruzzo's (1980b) characterization of LOGCFL mentioned above, using the techniques for ATMs simulating circuits developed in Ruzzo (1981). Conversely, we first note that every context-free language can be recognized by such a circuit family by Example 2 p. 250 of Skyum and Valiant (1981). Hence every set many-one NC 1 reducible to CFL is so recognized (negations can be pushed to the leaves in the reducing NC ~circuit and the degree of the resulting N C 1 circuit is always polynomial in n). Finally, the result follows from the earlier remark that LOGCFL = NCICFL.
The above proof gives rise to an interesting problem complete for LOGCFL under many-one NC 1 reducibility, namely, the circuit value problem for monotone Boolean formulas of degree at most n (the number of inputs).
A second complete problem for LOGCFL is Greibach's hardest contextfree language (Greibach, 1973). Problems in LOGCFL which may not be complete are the monotone planar circuit value problem (Dymond and Cook, 1980), bounded valence subtree isomorphism (Ruzzo, 1981), and basic dynamic programming problems (Goldschlager, 1977, 1978, 1982). The latter are more naturally expressed as relations or functions than sets, so it seems that a natural class to consider is CFL* (the closure of CFL under ~<).

PROPOSITION 4.5. L O G C F L ~_ CFL*.
This follows immediately from the earlier remark that LOGCFL= NC1CFL.
The above inclusion is proper, because CFL* contains functions other

12 STEPHEN A. COOK
than 0 1 functions. In addition, it is reasonable to conjecture that not all 0-1 functions in CFL* are in LOGCFL. This is because the sets (i.e., the 0-1 functions) in CFL* are closed under complementation, but while the graph accessibility problem is in N L and therefore in LOGCFL, its complement does not appear to be in LOGCFL.
An example of a dynamic programming problem in CFL* is computing the minimum cost order of multiplying a string of n matrices (see Aho, Hopcraft, and Ullman, 1974, for a dynamic programming solution to the problem and Goldschlager, 1977, 1978, 1982, for the method of putting such problems into CFL*). Of course, the problems complete for LOGCFL mentioned above are also complete for CFL*.
It turns out that all functions in CFL* can be computed on a SIMDAG (see the Introduction) in time O(log n). To state a more general form of this result we introduce the following terminology.
DEFINITION. A C k, for k = 1, 2,..., is the class of all problems solvable by an ATM in space O(log n) and alternation depth O(log k n).
PROPOSITION 4.6. (Ruzzo and Tompa ). A C k is the class of all functions computable on a SIMDAG in O(log ~ n) time with n °(1) processors.
A sim~l.~r characterization of "nonuniform A C k'', defined in terms of circuits with unbounded fan-in for "and" and "or," appears in Chandra, Stockmeyer, and Vishkin (1982). In fact, A C k itself has a characterization analogous to the definition of N C k (see Proposition 2.1).
Let us say the direct connection language (DCL) (see Ruzzo, 1981), for a family (~n) of circuits with unbounded fan-in for "and" and "or" consists of codes for all triples (n, u, v) such that node u is an input to node v in e~, together with codes for triples (n, u, l), where the label, l indicates what sort of gate node u is in c¢n.We say that (c~n) is uniform if this D C L has deterministic space complexity O(log n).
PROPOSITION 4.7 (Cook and Ruzzo, 1983). A C ~ consists o f those problems solvable by uniform unbounded fan-in circuit families in O(log k n) depth and n°(1)size.
It turns out that the above proposition still holds if the definition of uniform is weakened to simply require that the D C L is in A C k.
By Proposition 2.1 of Ruzzo (1981) it follows that A C ~ ~_NC ~+1. One way to see this using unbounded fan-in circuits is that each "or" gate or "and" gate has fan-in n °(1) and hence can be replaced by a tree of depth O(log n) of fan-in two gates. In particular, A C 1c_ N C 2.
Ruzzo (1980b) showed L O G C F L ~ _ A C 1. Since A C 1 is closed under (as can be seen from Proposition 4.7), we have

A TAXONOMY OF PROBLEMS

13

PROPOSITION 4.8. CFL* c__A C j By putting Propositions 4.6 and 4.8 together we obtain

COROLLARY 4.9. All problems described so far are solvable by SIMDAG's in O(log n) time with n °¢1) processors. This applies in particular to context-free language recognition and finding a minimum spanning forest in an undirected graph (Awerbuch and Shiloach, 1983; Reif, 1982).
An example in A C 1 not known to be in CFL* is the shortest path problem in an undirected graph with positive integer edge weights presented in binary notation. That this is in A C 1 follows by rain-plus matrix powering (Aho, Hopcroft, and Ullman, 1974). If the edge weights are presented in unary notation, the problem is in NL*.

5. THE CLASS D E T
Let intdet be the problem of computing det(A) given an n x n matrix A of n-bit integers, and let matpow be the problem of computing the powers A 1, A 2,..., An, given such an A. Since integer matrix multiplication is in N C ~ it is easy to see that matpow is in N C z.
Csansky (1976) was the first to show that the problem of computing the determinant of an n x n matrix over a field of characteristic zero can be solved using an algebraic circuit of depth O ( l o f n) and polynomial size. This statement does not imply the fact that intdet is in N C 2 because the algebraic circuit charges depth one for plus and times, whereas these operations require log depth for integers using Boolean circuits. However, a study of Csansky's method, using the fact that iterated integer addition is in N C ~, does show that intdet is in N C 2. Recently Berkowitz (1984) gives an alternative algebraic circuit for determinant which makes it clear that intdet<~matpow (recall ~< means "is N C 1 reducible to"). Borodin et al. (1983) gives an explicit construction showing how to adopt Berkowitz's algebraic circuits for determinant to give NC z Boolean circuits not only for intdet, but for bit representations of determinants over other rings, such as the polynomials with integer coefficients. (For a general discussion of the algebraic versus bit points of view in complexity theory, see Borodin, 1982.)
Since many problems in NC 2 are reducible to intdet, we make the following
DEFINITION. D E T = { intdet } * = { R I R <~intdet }.
It is clear that the problem "iterated integer product" (given n-bit

t4 STEPHEN A. COOK
integers al, a2 ..... an compute their product a l a 2 " " a n ) is in D E T by computing the determinant of the matrix with al,..., an on the diagonal and zeroes elsewhere. Since integer division ~<intdet (see Hoover, 1979; Reif, 1983; or Beame, Cook, and Hoover, 1984), it follows that the former problem is in DET.
A large class of problems in DET comes from the following:
PROPOSITION 5.1. N L * ~ DET.
Proof It suffices to show that the graph accessibility problem is reducible to intdet, since the former is complete for NL. Let A be the adjacency matrix of an n-node digraph G and assume A has zeros on the diagonal. Then the i, jth element of Ak, where A is treated as an integer matrix, is the number of paths of length k from i to j in G. For any e with 0 < ~ < IIAII-1 (where HAll is the norm of A) we have, setting M = I - ~ A ,
M-l= (I-eA) -1 =I+eA + (~;A)2 + .".
Therefore, the i, jth element of M - 1 is nonzero iff there is a path from i to j in G. Since M - 1 = adj(M)/det(M), and we can take e = 1In (since I[ALI< n), we have, multiplying M by l/z,
path in G from 1 to n iffdet((nI-A)[n] 1])¢0,
where [n I1] indicates the deletion of the nth row and first column.
PROPOSmON 5.2. The following problems are complete for DET:
(1) intdet (integer determinant) (2) matpow (matrix powering) (3) itmatprod (iterated matrix product)
Input: n n x n matrices with n-bit integer entries Output: their product (4) matinv (integer matrix inverse) Input: n x n matrix A with n-bit integer entries Output: A 1 in the form (adj(A), det(A)), where all entries are integers with n 2 + I-log2 n-I + 1 bits.
Proof (a) intdet <~matpow: (see Berkowitz, 1984). (b) matpow<,matinv: (see Borodin, 1982). Let N be the n 2 x n 2
rffatrix consisting of n x n blocks which are all zero except for n - 1 copies

A TAXONOMY OF PROBLEMS

15

of A above the diagonal of zero blocks. Then N n = 0 and
( I _ N ) - I = I + N + N 2 + ... + N ~ 1=
... An-l]
I i AI AA2

(c) matinv<~intdet: All entries of adj(A) are determinants of minors
of A with appropriate sign.
(d) matpow<~itmatprod: Obvious.
(e) itmatprod<~matpow: Let A1,..., An be n x n matrices, and let B be an (n2+n)x (172 + n ) matrix consisting of n x/7 blocks which are all zero
except for A1,..., An appearing above the diagonal of zero blocks. Then Bn
has the product A1A2""An in the upper right corner.
This completes the proof of Proposition 5.2. Clearly the inverse of matrices over the rationals (expressed as integer pairs (numerator, denominator)) and solutions of nonsingular systems of linear equations
over the rationals are also in DET. It is not clear that these problems are complete for DET (unless they are artificially formulated) because although
the determinant of an integer matrix can be expressed as a quotient of integers using solutions to these problems, I do not see how to reduce integer division to them.
One can add many other problems to DET. The method in Berkowitz
(1984) actually shows how to compute the coefficients of the characteristic polynomial d e t ( 2 I - A ) given an oracle for matrix powering, so this
problem is in DET (and complete). This shows how to compute the coefficients of a polynomial ( x - a l ) ( x - a 2 ) ' " ( x - a n ) in DET, so the Lagrange interpolation polynomials are in DET. Hence polynomial interpolation over the rationals is in DE7: This allows us to solve all the problems listed in Proposition 5.2 in DET even when the matrix entries are
polynomials with a fixed number of variables (or rational functions) over the integers or rationals by polynomial evaluation and interpolation. Hence by Borodin, Cook, and Pippenger (1983) the problems of computing the completion of a stochastic matrix and simulating a log n space-bounded
probabilistic Turing machine are in DET. Another source of problems in DET is Borodin et al (1982) and von zur
Gathen (1983) in which algebraic reductions to computing determinants are given. From these we can conclude, for example, that computing the greatest common divisor of n univariate polynomials over the rationals is
in DET. Also according to Ibarra, Moran, and Rosier (1980) computing
the rank of a matrix over the rationals can be reduced to computing
643/64/1-3-2

16 STEPHEN A. COOK
characteristic polynomials, so this problem is in DET. In Borodin et al. (1982) it is shown how to find a column basis for a matrix (using the parallel greedy algorithm: see Proposition 4.3) once the rank can be computed, and show how this can be used to find a general solution to a singular system of linear equations. Hence this problem is in DET, in case the ground field is the rationals.
6. PROBLEMS N C 1 COMPLETE FOR F P
Let FP be the class of all problems realized (see Sect. 2) by functions computable in polynomial time on a deterministic Turing machine. Since at present we cannot prove FP vaNC ~ the best way to indicate that a problem in FP is probably not in NC is to prove that it is complete for FP. (Such arguments are usually stated with respect to log space reducibility, but in fact the proof usually shows that NC ~ reducibility applies as well.) If R is NC ~ complete for FP and R is in NC,. then FP = NC, an unlikely result (see Proposition 3.2).
Examples of problems complete for FP are the circuit value problem (Ladner, 1975) (either monotone or planar Goldschlager, 1977), linear programming (Khachian, 1979; Dobkin, Lipton, and Reiss, 1979), and maximum network flow (with capacities given .in binary notation) (Goldschlager, Shaw, and Staples, 1982). See Jones and Laaser (1977) for several others. Here is one new one:
PROPOSITION 6.1. Finding the lexicographically first maximal clique in an undirected graph is N C 1 complete for FP.
Proof We show how to reduce the monotone circuit value problem to the above problem. Given a monotone Boolean circuit e (with each input assigned 0 or 1) we construct a graph G such that each gate v of ~ is associated with node v' and v" of G. This will be done in such a way that the lexicographically first clique C of G includes v' iff the value v(v) of v in
is 1, and C includes v" if v(v) = 0. We assume that the gates and inputs of are ordered topologically with the inputs first and the output last. If the gates and inputs are ordered (vl, v2..... vk) then the nodes of G are ordered (vl! , vltt, v2! , v2tt ..... vkt , vkt! ), except the order of (vi! , v~') may be reversed. If v is an input labelled 1 then v' is adjacent to all precding nodes and v" is adjacent to no preceding nodes. If v is an input labelled 0 then these conditions are reversed, except v' and v" are never adjacent. If v is an "and" gate with inputs u and w, then v' is adjacent to all preceding nodes except u" and w", and v" is adjacent to all preceding nodes except v'. If v is an "or"

A TAXONOMY OF PROBLEMS

17

gate, then v" precedes v', v" is adjacent to all preceding nodes except u' and w', and v' is adjacent to all preceding nodes except v".
Proposition 6.1 suggests that finding the first maximal clique in a graph is not solvable in NC. An interesting contrast to this result is provided by the recent result of Karp and Wigderson (1984) who show that finding some maximal clique is in fact in NC.

7. RANDOMN C
The class B P P (Gill, 1977) can be defined as the class of all sets recognizable in polynomial time by a probabilistic Turing machine with error probability at most ¼. Similarly one can define R N C (random N C ) to be the class of problems solvable by probabilistic circuits in polylog depth and polynomial time. More precisely, a problem R is in R N C k iff it is realized by a function f computed by a uniform family (c~n) of probabilistic circuits with bitwise error probability at most ¼, where d(%) = O(log k n) and c(c~n)-= n °(1). Here a probabilistic circuit is a Boolean circuit with ordinary inputs x and "coin tossing" inputs y. The probability that a particular output bit v is 1 is defined to be the fraction of input strings y such that the value of v is 1 when c~n has inputs (x, y). If each bit of f ( x ) is computed correctly with probability at least 3, then one can arrange many circuits in parallel each computing the same bit, and a majority vote can be taken to obtain a reliable value. Thus if R is in R N C k under the above definition, then for each l some other uniform family (fin) of probabilistic circuits with polynomial size and O(log k n) depth computes all bits of the function f realizing R correctly with the probability of one or more errors at most 2-nt
If R is in R N C k, then using the techniques of Adleman (1978) one can show that R is in "nonuniform N C k'', that is, N C k with the uniformity restriction removed.
N C is contained in R N C almost by definition, but it is of course not clear whether R N C is a subclass of NC, or even of FP, although certainly R N C ~_BPP. Since it seems unlikely that F P ~_RNC, a proof that R is hard for F P (under N C 1, N C ~, R N C k, or log-space reducibility) is a strong indication that R is not in RNC. (Equivalently a proof that R is in R N C is a strong indication that R is not hard for FP.)
A number of problems in R N C 2 appear in Borodin et al. (1982, see also von zur Gathen, 1983). Examples are finding the rank of a matrix (and solving possibly singular systems of linear equations) over a finite field, and finding the size of a maximum matching in a bipartite graph (or an arbitrary undirected graph (Feather, 1984). These methods are extended in Feather to show that the size of the maximum flow in a network with edge

18 STEPHEN A. COOK
capacities expressed in unary is in R N C 2. (When edge capacities are expressed in binary the problem is complete for FP (Golschlager et al., 1982). In Schwartz (1980b) it is shown that testing the singularity of a matrix of polynomials in many variables is in R N C 2. Recently it has been shown (McKenzie, 1984; McKenzie and Cook, 1983) that the abelian permutation group membership problem and related problems are in R N C 3.
8. CONCLUSION AND OPEN QUESTIONS
The title of this paper advertises more than I have delivered, since I have mainly discussed problem in N C 2 (and a few in R N C 2) as opposed to problems in general with fast parallel algorithms. We might define the latter class to be those problems which are solvable in parallel in time polynomial in log n ("polylog time") with no restriction on the number of processors (or circuit size, in the circuit model). This class is, by the "parallel computation thesis" (Goldschlager, 1977, 1978, 1982; Pratt and Stockmeyer, 1976; Borodin, 1977), equal to polylog space. I find it interesting that very few natural problems in the last class have come to my attention which are not in NC. One notable exception is the problem of determining whether two groups, presented by their multiplication tables, are isomorphic. This can be solved in space O(log 2n) by taking advantage of the fact that a group with n elements has a set of generators of size at most log2 n (Lipton, Snyder, and Zalcstein, 1976; Miller, 1978). I know of no NC solution to this problem, or even any polynomial time solution. • Within NC (and RNC) I have stuck to NC 2 (and RNC2), partly because when I wrote the earlier version (Cook, 1983) of this paper there were few natural examples known to be RNC and not known to be in RNC. Recently more examples have come to light, and it is worth mentioning some of these (and some earlier ones). First are problems of the form find a maximal (or minimal) subset subject to restrictions. For example, Lev (1980) shows that finding a maximal (not maximum) matching in a bipartite graph is in N C 5, and recently Karp and Wigderson (1984) show that finding a maximal independent set in a graph is in N C 5.1 The techniques in the last paper may well apply to other maximality problems and open up a new field of research: Classifying maximality problems according to their parallel complexity.
Other examples in R N C but maybe not in R N C 2 are the Abelian per-
1Improved to N C 2 in Luby, M. (1985), A simple algorithm for the maximal independent set problem, in "Proc. 17th ACM Sympos. Theory of Comput." pp. 1 10.

A TAXONOMY OF PROBLEMS

19

mutation group membership problem and related problems (shown to be in RNC 3 in McKenzie and Cook (1983), and the problem of recognizing whether a permutation group is nilpotent (shown to be in NC 4 in McKenzie, 1984). In fact, these two references give other such problems, and suggest there may be a rich class of examples.
We summarize below the class inclusions mentioned in this paper:

, C F L * ~_A C ~

N C I ~_FL ~_NL ~_

NC 2 ~ NC

DET

DSPACE((log n) °(~))
c
-FP

Natural examples complete for each of the above classes (suggesting that the inclusion immediately to the left of the class might be proper) have been given, with the exceptions of A C 1, N C 2, NC, and D S P A C E ( ( l o g n)°~l)). There is provably no complete problem for this last class, and there is none either for N C unless N C = N C k for some k. An intriguing open question is to find natural complete problems for A C 1 and N C 2. (The word "natural" precludes having "log n" or "log z n" appear in the statement of a problem. Of course the circuit value problem for circuits of depth at most log2n is complete for NC2). It is interesting to note that all our examples in N C 2 are in fact either in A C ~ or in DET. The question of whether D E T = N C 2 has an interesting algebraic analog (see Valiant, 1979; Valiant, Skyum. Berkowitz, and Rackoff, 1983).
It would be nice to show that DET and CFL* are comparable. It seems unlikely that DET~AC ~ (and hence unlikely that DETc_CFL*), since interger matrix powering is in DET, and if An is computed by repeated squaring then log n stages are required and each stage requires unbounded alternation depth by Furst, Saxe, and Sipser (1981).
Of course it would require a breakthrough in complexity theory to prove NC ~~ FP, and hence a breakthrough to prove any two of the above classes are unequal (excluding DSPACE ((log n)°~l))).
It would be nice to show that the problems in R N C mentioned in Section 7 are in NC. Among the interesting problems in FP not known to be either complete for FP or in (random) NC are integer greatest common divisors, computing a b rood c (a, b, c positive integers presented in binary) and testing membership in an arbitrary permutation group (McKenzie, 1984). Another such problem mentioned in Cook (1983) was solved recently by Karp, Upfal, and Wigderson, (1985). They showed how to find a maximum matching in a graph in RNC.

20 STEPHEN A. COOK
ACKNOWLEDGMENTS
I am indebted to Larry Ruzzo, not only for circulating a list of problems in NC 2 several years ago, but for carefully reading the earlier version of this paper and suggesting many illuminating additions and improvements. My thanks also to Allan Borodin and Martin Tompa who each supplied a good list of improvements, and to Patrick Dymond for helpful discussions, and to Mike Luby for suggesting improved notation.
REFERENCES
ADLEMAN,L. (1978), Two theorems on random polynomial time, in "Proc. 19th IEEE Found. Comput. Sci.," pp. 75-83.
AHO, A. V., HOVCROFT,J. E., ANDUI,LMAN,J. D., (1974), "The Design and Analysis of Computer Algorithms," Addison-Wesley, Reading, Mass.
AWERBUCH, B., AND SI41LOACH, Y. (1983), New connectivity and MSF algorithm for ultracomputer and PRAM, preprint, IBM-Israel Scientific Center, Technion, Haifa.
BERKOWITZ, S. J. (1984), On computing the determinant in small parallel time using a small number of processors, Inform. Process. Lett. 18, 147-150.
BORODIN, A. (1977), On relating time and space to size and depth, SIAM J. Comput. 6, 733-744.
BORODIN,A. (1982) Structured vs. general models in computational complexity, in "Logic and Algorithmic," Enseign. Math. (No. 30) pp. 47-65, Univ. Geneva, Geneva.
BEAME,P. W., COOK, S. A., AND HOOVER,H. J. (1984), Log depth circuits for division and related problems, in "Proc. 17th IEEE Found. Comput. Sci."
BORODIN,A., COOK, S. A., ANDPIPPENGER,N. (1983), Parallel computation for well-endowed rings and space-bounded probabilistic machines, Inform. and Control 58, 113-136.
BORODIN,A., VON ZUR GATttEN,J. AND HOPCROFT,J. (1982), Fast parallel matrix and GCD computations, Inform. and Control 52, 241-256.
CHANDRA,A. K., KOZEN,D. C., AND STOCKMEYER,L. J. (1981), Alternion, J. Assoc. Comput. Mach. 28, No. 1, 114-133.
CHANDRA, A. K., STOCKMEYER, L. J., AND VISHKIN, U. (1982), Complexity theory for unbounded fan-in parallelism, in Proc. 23rd IEEE Found. Comput. Sci.," pp. 1 13.
COOK, S. A., (1981), Towards a complexity theory of synchronous parallel computation, Enseign. Math. 27, 99 124.
COOK, S. A. (1983), The classification of problems which have fast parallel algorithms, in Proc. 1983 International FCT Conference," Lecture notes in Computer Science Vol. 158, pp. 78-93, Springer-Verlag, Berlin/New York.
CooK, S. A., AND Ruzzo, W. L. (1983), unpublished theorem. CSANKY, L. (1976), Fast parallel matrix inversion algorithms, SIAM J. Comput. 5, 618 623. DY~OND, P. W., AND COOK, S. A. (1980), Hardware complexity and parallel computation, in
"Proc. 21st IEEE Found. Comput. Sci.," 360-372. DOBKIN, D., LIPTON, R. J. AND REISS, (1979), Linear programming is log space hard for P,
Inform. Process. Lett. 8 96-97. DEKEL, E., NASSlMI,D., ANDSAEINI,S. (1981), Parallel matrix and graph algorithms, SIAMJ.
Comput. 10 65%675. FEATHER,T., (1984), M.Sc. thesis, Department of Computer Science, University of Toronto. FURSX, M., SAXE, J., AND SIVSER, M. (1981), Parity, circuits, and the polynomial-time
hierarchy, in "Proc. 22nd IEEE Found. Comput. Sci.," pp. 260-270.

A TAXONOMY OF PROBLEMS

21

GAREY, M. R., AND JOHNSON,D. S. (1979), Computers and Intractability: A Guide to the Theory of NP-Completeness," Freeman, San Francisco.
VON ZUR GATHEN,J. (1983), Parallel algorithms for algebraic problems, in "Proc. 15th ACM Sympos. Theory of Comput.," pp. 17-23.
GILL, J. (1977), Computational complexity of probabilistic Turing machines, SIAM J. Cornput. 6, 675-695.
GOLDSCHLAGER,L. M. (1977; 1978; 1982)"Synchronous Parallel Computation," Ph.D. thesis, University of Toronto; in "Proc. ACM Sympos. Theory of Comput.," pp. 89-94; Assoc. Comput. Mach. 29, No. 4, 1073-1086.
GOLDSCHLAGER,L. M. (1977), The monotone and planar circuit value problems are log space complete for P, SIGACT News 9, No. 2, 25-29.
GREIBACH,S. A. (1973), The hardest context-free language, SIAM J. Comput. 2, 304-310. GOLDSCHLAGER~L. M., SHAW, R. A., AND STAPLES,J. (1982), The maximum flow problem is
log space complete for P, Theoret. Comput. Sci. 21, 105-111. GUPTA, A. (1985), M.Sc. thesis, Dept. of Computer Science, University of Toronto. HONG, J. W. (1980), On some space complexity problems about the set of assignments satisfy-
ing a boolean cormula, in "Proc. 12th ACM Sympos. Theory of Comput.," pp. 310-317. HOOVER, H. J. (1979), "Some Topics in Cicrcuit Complexity," M.Sc. thesis, University of
Toronto, Department of Computer Science, Department of Computer Science Technical Report 139/80. IBARRA, O. H., MORAN, S., AND ROSIER, L. E. (1980), A note on the parallel complexity of computing the rank of order n matrices, Inform. Process. Lett. 11, 162. Jg' JA', J., AND SIMON,J. (1982), Parallel algorithms in graph theory: Planarity testing, SIAM J. Comput. 11, 314-328. JONES, N. D., AND LAASER,W. T. (1977), Complete problems for deterministic polynomial time, Theoretical Computer Science 3, 105-117. JONES, N. D., LIEN, Y. E., AND LAASER, W. T. (1976), New problems complete for nondeterministic log space, Math. Systems Theory 10 1-17. KHACHIAN,L. G. (1979), A polynomial time algorithm for linear programming, Dokl. Akad. Nauk SSSR 244 No. 5 1093-96; transl, in Soviet Math. Dokl. 20, 191 194. KARP, R. M., UPEAL, E., AND WIGDERSON,A. (1985), Constructing a perfect matching is in random NC, in "Proc. 17th ACM Sympos. Theory of Comput.," pp. 22-32. KARP, R. M., ANDWIGDERSON,A. (1984), A fast parallel algorithm for the maximal independent set problem, in "Proc. 16th ACM Sympos. Theory of Comput.," pp. 266-272. LADNER, R. E. (1975), The circuit value problem is log space complete for P, SIGACT News 7, No. 1, 18-20. LEV., G~ (1980), "Size Bounds and Parallel Algorithms for Networks," Doctoral thesis, Report CST-8-80, Dept. of Computer Science, University of Edinburgh. LYNCH, N. (1977), Log space recognition and translation of parenthesis languages, J. Assoc. Comput. Mach. 24, No. 4, 583-590. LIPTON, R. J., SNYDER,L., AND ZALCSTEIN,Y. (1976), "The Complexity of the Word and Isomorphism Problems for Finite Groups," Tech. Rep. 91/76, Yale University. MCKENZIE, P. (1984), "Parallel Complexity and Permutation Groups," Ph.D. thesis, University of Toronto, Department of Computer Science. MILLER, G. L. (1978), On the nl°gnisomorphism technique, in "Proc. 10th Sympos. Theory of Comput.," pp. 51-58. MCKENZIE, P., AND COOK, S. A. (1983), The parallel complexity of the Abelian permutation group membership problem, in "Proc. 24th IEEE Found of Comput. Sci.," pp. 154-161. McKENzIE, P., AND COOK, S. A. (1985), The parallel complexity of Abelian Permutation group problems. University of Toronto, Dept. of Computer Science, Technical Report No. 181/85.

22 STEPHEN A. COOK
MULLER,D. E., ANDPREPARATA,F. P. (1975), Bounds to complexities of networks for sorting and switching, J. Assoc. Comput. Mach. 22 No. 2, 195-201.
PIPPENGER, N. (1979), On simultaneous resource bounds (preliminary version), in "Proc. 20th IEEE Found. of Comput. Sci.," pp. 307-311.
PAPADIMITRIOU,C. H., AND STEIGLITZ,K. (1982), "Combinatorial Optimization: Algorithms and Complexity," Prentice-Hall, Englewood Cliffs, N. J.
PRATT, V. R., AND STOCKMEYER,L. J. (1976), A characterization of the power of vector machines, J. Comput. System Sci. 12 198--221.
R~IF, J. H. (1982), Symmetric complementation, in "Proc. 14th ACM Sympos. Theory of Comput." pp. 201-214.
REIF, J. H. (1983), Logarithmic depth circuits for algebraic functions, in "24th IEEE Found. of Comput. Sci.," pp. 138-145; revised version: Preprint (1984).
Ruzzo, W. L. (1980a), unpublished list of problems in NC 2. Ruzzo, W. L. (1980b), Tree-size bounded alternation, J. Comput. System Sci. 21 No. 2,
218-235. Ruzzo, W. L. (1981), On uniform circuit complexity, J. Comput. System Sci. 22 No. 3
365-383. Ruzzo, R. L. (1984), private communication. RUZZO,W. L., ANDTOMPA,M. (1982), unpublished result. See Stockmeyer, L., and Viskin, I.,
"Simulation of Parallel Random Access Machines by Circuits," Report RC-9362. IBM Research, Yorktown Heights, N.Y. SAVAGE,J. E. (1976), "The Complexity of Computing," Wiley, New York. SKYUM, S., AND VALIANT,L. G. (1981), A complexity theory based on Boolean algebra, in "Proc. 22nd IEEE Found. of Comput. Sci.," pp. 244-253. SCHWARTZ, J. T. (1980a), Ultracomputers, A C M Trans. Program. Lang. Systems 2, No. 4 484-521. SCHWARTZ,J. T. (1980b), Probabilistic algorithms for verification of polynomial identities, J. Assoc. Comput. Mach., 27, No. 4 701-717. SHANNON,C. E. (1949), The synthesis of two terminal switching circuits, BSTJ 28 59-98. SUDBOROUGH,I. H. (1978), On the tape complexity of deterministic context-free languages, J. Assoc. Comput. Mach. 25 No. 3, 405-414. TOMPA, M. (1984), private communication. VALIANT,L. G. (1979), Completeness classes in algebra, in "Proc. 11th ACM Sympos. Theory of Comput.," pp. 249-261. VALIANT, L. G., SKYUM,S., BERKOWITZ,S., AND RACKOEF,C. (1983), Fast parallel computation of polynomials using few processors, S l A M J. Comput. 12 No. 4, 641-644. VlSHKIN,U. (1983), Synchronous parallel computation--A survey, preprint Courant Institute, New York University. WILSON, C. (1983), Relativized circuit complexity, in "Proc. 24th IEEE Found. of Comput. Sci.," pp. 329-342.

