NASA/CR-2000-210621 ICASE Report No. 2000-45
Explicit Substitutions and All That
Mauricio Ayala-Rinc6n Universidade de Brasilia, Brasilia D.F., Brasil Cdsar Muhoz ICASE, Hampton, Virginia
November 2000

The NASA STI Program Office...

in Profile

Since its founding, NASA has been dedicated to the advancement of aeronautics and space science. The NASA Scientific and Technical
Information (STI) Program Office plays a key part in helping NASA maintain this important role.

The NASA STI Program Office is operated by Langley Research Center, the lead center for NASA's scientific and technical information.
The NASA STI Program Office provides access to the NASA STI Database, the largest collection of aeronautical and space science STI in the world. The Program Office is also NASA's institutional mechanism for
disseminating the results of its research and development activities. These results are published by NASA in the NASA STI Report Series, which includes the following report types:

TECHNICAL PUBLICATION. Reports of completed research or a major significant phase of research that present the results of NASA programs and include extensive data or theoretical analysis. Includes compilations of significant scientific and technical data and information deemed to be of continuing reference value. NASA's counterpart of peer-reviewed formal professional papers, but having less stringent limitations on manuscript length and extent of graphic presentations.
TECHNICAL MEMORANDUM. Scientific and technical findings that are preliminary or of specialized interest, e.g., quick release reports, working papers, and bibliographies that contain minimal annotation. Does not contain extensive analysis.

CONTRACTOR REPORT. Scientific technical findings by NASA-sponsored contractors and grantees.

and

CONFERENCE PUBLICATIONS.
Collected papers from scientific and technical conferences, symposia, seminars, or other meetings sponsored cosponsored by NASA.

or

SPECIAL PUBLICATION. Scientific, technical, or historical information from NASA programs, projects, and missions, often concerned with subjects having substantial public interest.

TECHNICAL TRANSLATION.
language translations of foreign and technical material pertinent NASA's mission.

Englishscientific to

Specialized services that complement the STI Program Office's diverse offerings include creating custom thesauri, building customized data bases, organizing and publishing research results.., even providing videos.
For more information about the NASA STI Program Office, see the following:

• Access the NASA STI Program Home Page at http://www.sti.nasa.gov

• Email your question via the Internet to help@ sti.nasa.gov

• Fax your question to the NASA STI Help Desk at (301) 621-0134

• Telephone the NASA STI Help Desk at (301) 621-0390

Write to:
NASA STI Help Desk NASA Center for AeroSpace 7121 Standard Drive Hanover, MD 21076-1320

Information

NASA/CR-2000-210621 ICASE Report No. 2000-45

_i__ _

.:i_i!i ....... _/_

Explicit Substitutions

and All That

Mauricio Ayala-Rinc6n Universidade de Brasilia, Brasilia D.F., Brasil
Cdsar Muhoz ICASE, Hampton, Virginia

ICASE NASA Langley Research Hampton, Virginia

Center

Operated by Universities Space Research Association

National Aeronautics and Space Administration
Langley Research Center Hampton, Virginia 23681-2199
November 2000

Prepared for Langley Research Center under Contract NAS 1-97046

Available fi'om tile following:

NASA Center for AeroSpace 7121 Standard Drive
Hanover, MD 21076 1320 (301) 621 0390

hffomlation

(CASI)

National TectHficalhffomlation

5285 Port Royal Road

Spfingfield, VA22161 (703) 487 4650

2171

Service(NTIS)

EXPLICIT SUBSTITUTIONS AND ALL THAT* MAURICIAOYALA-RINCOANNtDCI_SAMRUIIOc,Z$

Abstract. Explicitsubstitutioncalculai reextensionosftheA-calculuwsherethesubstitutionmechanism isinternalizeidntothetheory.Thisfeaturemaketshemsuitablefor implementatioanndtheoreticasltudyof logic-basetodolssuchasstronglytypedprogramminlganguageasndproofassistanstystemsI.n this paper weexplorenewdevelopmenotns twoof the mostsuccessfsutlylesof explicitsubstitutioncalculi:the AaandAs¢-calculi.
Key words, explicitsubstitutionh,igherorderunificationl,ambda-calculutysp,etheoryr,ewriting

Subject

classification.

Computer

Science

1. Introduction.

This paper focuses on the uses of explicit substitutions

in the language of the simply-

typed A-calculus.

Type theories were used at the beginning

of the twentieth

century as a formalism

to deal

with the mathematical

paradoxes

studied at that time and incorporated

in 1940 to the A-calculus by A.

Church [11]. The need of stronger programming

languages

guided type theory to the interest of computer

scientists in the 1970's and 1980's, when new languages based on type theories were developed.

Probably

the most relevant of these languages

is ML [42], developed

by R. Milner.

In the 1990's, several proof

assistant systems based on higher-order

logics, such as Coq [5], HOL [27], and PVS [51], were developed.

The A-calculus is the simplest logical framework

for reasoning about formal properties

of all these systems.

Many of the essential techniques

and computational

procedures

involved in these tools have been developed,

analyzed, techniques

and improved in the context include simple mechanisms

of the simply-typed such as type checking

A-calculus and type

before being implemented.

These

inference,

and more complex ones

such as those used for dealing with the inhabitation basic operation of the A-calculus is the/_-conversion

problem and the higher order unification

problem. The

that was originally defined based on an implicit notion

of substitution

where renaming of variables was informally assumed to avoid "clashes" and "captures".

This

implicitness

of the notion of substitution

was not critical before this theoretical

framework

was used in other

contexts than the ones of computer science, but making the notion of substitution

explicit is essential when

computational

properties

such as time and space complexity

should be analyzed.

We will focus on two styles of explicit substitutions:

Aa and As¢. These calculi use a name-less notation

for variables.

Therefore,

technical

nuisances due to the higher order aspect of A-calculus, such as renaming

and capture of variables, are minimized or completely

eliminated

in Aa and As¢. For these calculi, we will

motivate and illustrate different techniques

developed for important

computational

problems and applications

such as higher order unification,

type inference, and inhabitation

problem.

These kind of problems arise

naturally in many fields of computer science. Some of the current progress in the area of explicit substitution

is recorded in the series of "International

Workshops

on Explicit Substitutions:

Theory and Applications

to

Programs and Proofs" - WESTAPP

that runs yearly together with the Conference on Rewriting Techniques

*Work carried out during the visit of the first author at the ULTRA Group, CEE, Heriot-Watt University, Edinburgh, Scotland, and funded by CAPES (BEX0384/99-2) Brazilian Foundation. For the second author, the work was supported by the National Aeronautics and Space Administration under NASA Contract No. NAS1-97046 while he was in residence at ICASE, NASA Langley Research Center, Hampton, VA 23681-2199, USA.
tDepartamento de Matem_tica, Universidade de Brasflia, 70910-900 Brasflia D.F., Brasil, e-mail: ayala@mat.unb.br $ICASE, Mail Stop 132C, NASA Langley Research Center, Hampton, VA 23681-2199, USA, e-mail: munoz@icase.edu

and Applications - RTA. For other surveys and tutorials on explicit substitution calculi see [38, 56].

Firstly, in section 2 we present basic notions of the A-calculus, its representation

in de Bruijn index

notation, its simply-typed version, and the Curry-Howard isomorphism. Afterwards, in section 3, we motivate

explicit substitutions and present the two before mentioned calculi of explicit substitutions along with their

simply-typed versions. In section 4, we explain briefly the applications of explicit substitutions before

concluding in section 5.

2. The A-calculus.

The A-calculus was developed by Church around 1930 [12] as a formal language for

the foundations of mathematics and logic. Although that foundation was later revealed to be inconsistent,

indeed Russell paradox [58] can be encoded in it, the A-calculus still provides a formal model of computability.

Church and Kleene [37, 10] proved that the class of A-expressions and the class of partial-recursive functions

are the same. This result, along with Turing's own work, shows that the A-calculus is as expressive as Turing machines.

The notation consists of a set A of terms and rules to manipulate them. The set A is built on a countable

set of variables F = {x, y,...} and it is inductively defined as follows: F C A, if M, N E A then (M N) E A, and if x E F and M E A then Ax.M E A. Terms of the form (M N) are called applications and terms of the

form Ax.M are called abstractions. Abstractions are binding structures. As usual for these kind of structures,

a notion of free and bound variables is necessary. The set of free variables of M, denoted _V(M), is defined

by _V(x) = {x}, _V((M N)) = _V(M) U _V(N), and _V(Ax.M) = _V(M) \ {x}. The variable x in

a term Ax.M is said to be bound. Names of bound variables are irrelevant. For instance, Ax.x and Ay.y

represent the same A-term. This implicit equivalence is called a-conversion. Formally, if z ¢ _V(M), then

Ax.M =_ Az.M{z/x}, where for an arbitrary term N, M{N/x} denotes the atomic substitution of the free

occurrences of the variable x in M by N.

Substitution plays a very important role in the A-calculus. In fact, the main computational rule in this

formalism, the /_-rule, is expressed as follows: (Ax.M N) _

M{N/x}.

Informally, it states that the

application of a function Ax.M to an argument N, results in a term M{N/x} where the formal parameter x

has been replaced by the argument N in M (the body of the function). An additional rule, called 7, states that

abstractions computing the same value for the same argument are convertible. Formally, Ax. (M x) _ M,

if x ¢ .TV(M).

The formal definition of substitution is not as simple as it seems. The following one, commonly used in im-

plementations, is wrong: x{M/x} = M, y{M/x} = y, if y _ x, (M1 M2){M/x}

= (MI{M/x}

M2{M/x}),

(Ax.N){M/x}

= Ax.N, and (Ay.N){M/x}

= Ay.N{M/x},

if y _ x. The problem arises in the last

case: the term M may contain a free variable y which becomes a bound variable when the substitution

is applied. A correct definition should avoid this capture; for instance, by modifying the last case with

(Ay.N){M/x} = Az.N{z/y}{M/x},

where z ¢ mV(M).

The A-calculus is not terminating. Indeed, a term like (Ax.(x x) Ax.(x x))/_-reduces to itself and then

it can be always reduced. However, the A-calculus satisfies, the Church-Rosser property i.e., if M1 =Z_ M2,

then there exists N such that M1 _

N and M2 _

N. 1 In consequence: (1) the A-calculus is also

confluent and (2) normal forms, it they exist, are unique. We refer to [3] for a complete description A-calculus and its properties.

of the

R R*

1As usual, if R is a term rewrite system, we denote by _

the relation induced by R and by _

the reflexive,

symmetric, and transitive closure of _ . Furthermore, the equational theory associated to R defines a congruence denoted

by =R.

2.1. de Bruijn indices. At thebeginningofthe seventiedse, Bruijn developeadnamelesnsotation fortheA-calculu[s19].In that notationn, amesofboundvariableasrereplacewd ith indices.
DEFINITION 2.1. The set AdB of A-terms in de Bruijn index notation is defined inductively as

M,N ::= n l (M N) I AM

where n E N >°.

An index counts the number of A-symbols in the binding scope of the bound variable that it represents. For instance, in de Bruijn index notation, the term Ax.x is written A1 since the bound variable x is in the binding scope of one A-symbol. Similarly, the term Ax.(Ay.(x y) x) is written A(A(2 1) 1). Note that the same index appearing in different binding scopes represents different variables. Vice-versa, occurrences of the same variable appearing in different binding scopes are denoted by different indices.

Free variables can also be represented by de Bruijn indices. In that case, it is necessary to fix an enumeration, namely a referential, Xl, x2,..., Xn, of free variable names. If the occurrence of a variable is denoted by an index n and the number of A-symbols in the binding scope of that occurrence is less than n, say m, then that occurrence of n represents the free-variable xn-,_ of the referential. For instance, the term (Ax.(y x) z) can be encoded as (A(2 1) 2) under the referential y, z and as (A(3 1) 1) under the referential z,y.

The formulation of the rules/_ and _ for AdB-terms requires the following functions substitution of indices.

for updating

and

DEFINITION 2.2. Let M E AdB. The i-lift
1. (M1 M2)+i= (M1+_ M_+_),
2. (AN) +i = AN +(i+1);

of M,

denoted

M +i is defined

inductively

as follows

3. n +i =
-

--
nn,+l,ifn_i ifn>i

The lift of a term M is its O-lift and is denoted briefly as M +.

DEFINITION 2.3. The application of the substitution M { N/n} , is defined inductively as follows

with N at the depth n - 1 on a term M, denoted

1. (M1 M2){N/n} = (MI{N/n} M2{N/n}); 2. (AM){N/n} = AM{N+/n + 1};

3. m{N/n} =

N, if m = n m-l, ifm>n
rrt, if rrt _ n

DEFINITION 2.4. The rules _ and _ are defined for the set of AdB-terms

as follows

(AM N) A(M 1_)

_ _

M{N/1} N, i] N + = M

EXAMPLE 2.5. The A-term (Ax.(Ay.(x z) x) (z Az.(x z))) can be translated x,y,z into the AdB-term (A(A(2 5) 1_) (3 A(2 1_))). Furthermore, we have

under the referential

(Ax.(Ay.(x z) x) (_ A_.(x _))) _ (Ay.((_ A_.(x _)) _) (_ A_.(x _))).

We examine in detail the steps of that reduction for AdB-terms:

(_(_(_2_5) 1) (3- _(_21))) _ (_(_2_5)1){(3-_(_21))/!} = ((_(_2_5)){(3_(_21))/!} 1{(3- _(_21))/!}) = (_(_2_5){(3_(_21))+/_2} (3-_(_21)))

---- ()_(_2 5){(3- + )_(_2 +1 1+1))/2}

(3-)_(_2

1)))

= (_(_2_5){(4_(3- 1))/_2} (3- _(_21)))

= (_(_2{(4_(3- 1))/_2}_5{(4_(3- 1))/_2}) (3- _(_21)))

= (_((4 _(3-1)) 4) (3- _(_21)))

TheAdB-term (A((4 A(3_ 1)) 4) (3_ A(_2 1))) represents the given referential.

the term (Ay.((z

Az.(x z)) z) (z Az.(x z))) under

EXAMPLE 2.6. Notice that

A((AA(_(51 _2))4) 1)_ (AA(4(1 _2))3_)

since

(_(4 (1 _2)) 3_)+= ((_(4 (1 _2)))+ 3_+) z (_(_(4 (1 2))) +1 3_+) = (_(4 (1 __))+3__+) = (11(4 +_ (!_2+) 2) 3_+) = (_(4+2 (1+2__+2)3)_+) = (_(__ (1 _2)) 4)

2.2. Slmply-typed

A-calculus.

The A-calculus is a simple, but yet powerful formalism. As we said

before, when used as a logical framework, the A-calculus allows the encoding of paradoxes. To solve that

problem, Church developed a typed version of the A-calculus [11] which happens to be a simplification of the

Type Theory of Whitehead-Russell

[58].

The effect of typed A-calculus can be seen on a term such as lx.(x x) which is a well formed term in the

untyped A-calculus that represents the abstract concept of "self-application".

The meaningfulness of this

concept may be questioned and was involved in many of the logical paradoxes from the beginning of the twentieth century. Thinking about x as a functional variable from A to A or of "type A--+A", the application

(x x) is forbidden, since it's impossible to apply a function of type A--+A to an argument of type A--+A.

This coincides with the conception of functional objects assumed by most mathematicians.

Of course, if z

is a variable of type A, the typed expression lx.(x (x z)) makes sense. For a formal introduction to the

theory of the simply-typed A-calculus and interesting historical remarks see [30].

In a typed A-calculus, A-terms are stratified in several categories, namely types. A type, in the simple

type theory, can be a basic type a,b,.., or a functional type A-+B, where A and B are types. We use

upper-case letters A, B... to range over types. Only terms that follow a type discipline are considered to be

valid. The type discipline is enforced by a set of typing rules. Thanks to the typing rules, Russell's paradox

cannot be expressed in the simple type theory.

X ¢,

(Start)

x:A,: _ x : A

Fx-:AA,x, :A.MF- M: A:-B-+B (Abs)

x ¢, , F- M : B (Weak) x:A,, I-M:B

F-M:A--+B

, F-N:A

, I- (M N):B

(Appl)

F_c. 2.1. The simply-typed A-calculus

l<i<n

(Var)

A1.A2 .... An _ i : Ai

A., F-M:B

(Abs)

, _ AA.M : A--+B

, F-M:A--+B

, F-N:A

, f- (M N) : B

(Appl)

F_c. 2.2. The simply-typed A-calculus for AdB-terms

Typed A-terms are elements of the set of A-terms except that bound variables in abstractions annotations, i.e., they have the form Ax:A.M. Rules/3 and _ are modified accordingly:

have type

(Ax: A.M N) _ M{N/x}

and

Ax: A.(M x) _

M, if x ¢ _V(M)

A typing judgment,

F- M : A denotes that the term M has type A in ,, where, is a context, i.e., a list

Xl :AI,..., xn:An of variable declarations. Henceforth, we use Greek letters, , A,... to range over contexts.

Figure 2.1 shows the typing rules of the simply-typed A-calculus. We say that a A-term M is well typed in

, if and only if there exists a t ype A such that , F- M : A, and we say that a type A is inhabited in, if and

only if there exists a A-term M such that , F- M : A.

The presentation of the typed A-calculus used in this paper corresponds to the Church-style. In this

presentation, typed A-terms are elements of the set of A-terms except for abstractions, which have type

annotations. An alternative presentation, called Curry-style, considers typed A-terms as standard A-terms without type annotations. In that case, type variables should be added to the formalism. Indeed, in a typed

A-calculus d la Curry, the type of Ax.x is a--+a where a denotes any type (See [4]). Type checking is decidable for the simply typed A-calculus. That is, there is a method to decide whether

or not a term has a type in a given context according to the typing rules. As the untyped version of the

A-calculus, the simply-typed A-calculus enjoys the Church-Rosser property and therefore it is also confluent.

Furthermore, it also satisfies the following properties.

• Subject reduction, if, F-M:AandM_

N, then,

F-N:A;

• Type uniqueness, if, F-M:Aand,

F-M:B, thenA=B;

• Strong normalization,

if M is a well typed term, then M has no reductions of infinite length.

Therefore, due to the confluence property, normal-forms of well typed terms always exists and they

are unique.

In the de Bruijn setting of the simply typed A-calculus, a context, is a list of types A1 ..... An where Ai

is the type of the free-variable represented by the index/. The empty context is denoted by e. Simply-typed

AdB-terms are defined by the typing rules of Fig. 2.2.

2.3. Curry-Howard

isomorphism.

There is a strong relation between type theory and intuitionistic

logic. If we identify types with propositions, where an arrow type is an implication, typing rules of the simply-

typed A-calculus correspond one to one to deduction rules of a minimal intuitionistic logic. In other words,

typing rules are logical rules decorated with typed A-terms. This principle is known as the Curry-Howard

isomorphism.

Consider an intuitionistic minimal logic where propositional formulas are built from atomic propositions

a, b,... and the implication, i.e., if A and B are formulas then A--+B is a formula. We use uppercase Greek

letters f_ to range over set of formulas. denotes that A is a logical consequence

We write f_, A as a shorthand for f_ O {A}. A judgment f_ }-I A of f_. A judgment is said provable (in the minimal intuitionistic

logic) if and only if it is derived by top-down application of the following rules:

_, A }-I A (Axiom)

f_, A }-i B (Intro) }-I A--+B

_ }-I A--+B

f_ }-I A (Elim)

_ }-I B

A formula A is a tautology if and only if the judgment }-I A is provable. A--+((A--+B)--+B) is a tautology since it can be derived as follows:

For example,

the formula

A, A-+B

}-I A-+B (Axiom)

A, A--+B

A, A--+B }-I B

A }-I (A--+B)--+B (Intro)

}-I A--+((A--+B)--+A) (Intro)

(Axiom) }-I A (Elim)

Formally, the Curry-Howard isomorphism says that f_ }-I A is provable in the minimal intuitionistic logic if and only if, }- M : A is a valid typing judgment in the simply-typed A-calculus, where , is a list of variable declaration of propositions, seen as types, in f_. The term M is a A-term that represents the proof derivation. For instance, the term decoration of the tree derivation above results in the valid typing judgment }- Ax:A.Ay:A--+B.(y x) : A--+((A--+B)--+A).
The Curry-Howard isomorphism is extended to intuitionistic first order and higher order logics and it is widely studied in proof theory. It is at the base of mathematic formalizations where proofs are just mathematical objects. Such languages are the base of automatic systems for proof construction, program verification and program synthesis.

3. Explicit Substitutions.

Implicitness of substitution is the Achilles heel of the A-calculus. Namely,

the A-calculus is a convenient and compact model of the computable functions but it does not provide any

mechanism for observing essential operational properties of these functions as time and space complexity.

The reason for this is that the substitution involved in fl-reductions does not belong in the calculus, but rather

in an informal meta-level. In practice, fl-reduction is not a primitive operation and is implemented based

on a substitution generally elaborated by renaming variables and/or maintaining some variable convention.

That makes it impossible to determine or bound in time and space the fl-reduction.

The Aa-calculus was the first one presented formally as a mechanism for making explicit substitution

in the A-calculus [1]. But before this, today widely considered seminal work, many empiric and theoretic

efforts were realized in order to solve the problem of implicitness of the substitution operation. From the

theoretical point of view, the Combinatory Logic of Curry and Feys [18] proposed the first solution to this

problem. However, this setting does not remain close to the A-calculus and the number of primitive steps

can be extensively larger than required by explicit substitution calculi. From the empirical point of view,

perhaps the person who provided the foundations to take care of this problem was de Bruijn himself, when

developing his system AUTOMATH from the middle of the 1960's. Part of his primary conceptions was the

previously mentioned nice nameless notation for the A-calculus [19]. His legacy is collected in [50].

Sincethe ha-calculuwsasintroducedin [1],severaolthervariantsof explicitsubstitutioncalculihave beenpropose(dseef,orexample[5, 4,38,32,7,39,1"/,35,43,24,44]).Thesecalculimplemensteverasltyles of explicitsubstitutions.
Wewillfocusourattentionontwoofthesestylest:heha-andthe_s_-stylesB.othofthemuseanameless notationbasedonthedeBruijnindexnotationw, hichis completeliynsensitivteo c_-conversioTnh.atallows a cleanandeleganmt eta-theoreticsatludyof thecalculiwhichmakethemsuitablefor implementatioonf declarativperogramminlganguagehsi,gherorderproofassistantsa,ndautomatedeductivesystemsB. oth styleswereshownincomparabilne [34].
Theha-calculuasndits variantshavebeenproposeadsa generafrl ameworfkorhigherorderunification andtermsynthesi[s21,22,9,36,45,4"/,46,6].Furthermoreca, lculiofthe ha-familyhavebeenincorporated with succesisnto programminlganguageasndproofassistantsF. or examplea,n algorithmfor pattern unificationfor dependentyt pes,basedonha, hasbeenimplementeind the Twelfsystem[52].It hasalso beenrelevanitn theimprovemenotftheexplicitsubstitutionforthe rewrite calculus (p-calculus [14]) of the
ELAN system, which provides a language based on rewrite rules for specifying and prototyping deductive
systems [13].
The _s_-calculus [32, 33] was developed more recently than the ha-calculus and its main claimed ad-
vantage over the ha-calculus is that it remains as close as possible to the _-calculus having only one sort of
objects. There is a close relation, until now only subjectively purposed, between the _s_-calculus and the
rewrite rules developed by Nadathur and Wilson in the early 1990's and used in the implementation of the
higher order logic programming language _Prolog [41]. For instance the laziness in the substitution needed
in implementations of _-reduction, that arises naturally in the _s_-calculus, is provided as the informal but
empirical concept of suspension of substitutions by Nadathur and Wilson rewrite rules, with their notion of substitution being more general than the _s_ one. More recently their rewrite rules were published in the
context of explicit substitution as the suspension calculus [49, 48]. Establishing formally the relations and differences between the _s_-calculus and the suspension calculus remains as important work to be done.

3.1. The )_-calculus.

The ha-calculus is a first order rewrite system with two sorts of expres-

sions: terms and substitutions.

In fact, substitutions inherent to the _-rule in de Bruijn index notation,

(AM N) _

M{N/1}, are delayed and recorded in the ha-calculus as (AM N) _

M[N. ia_. Here,

M[N • ia_ is a ha-expression representing M with a recorded substitution N • id. Additional rules are nec-

essary for applying the recorded substitution to the term M, i.e., replacing all the free occurrences of the

de Bruijn index 1 at M with N and decrementing by one remaining free de Bruijn indices over M. De-

laying application of substitution is widely used in implementations

of functional and logical programming

languages, because immediate substitution may give rise to a size explosion of the expressions.

DEFINITION 3.1 ()_-Calculus). where

The ha-calculus is defined by the rewrite system depicted in Fig. 3.1

TERMS SUBSTITUTIONS

M,N
S,T

::= l l)_M I (M N) IM[S ] ::= id I _ I M. S I S o T

The rewrite system obtained by dropping rules (Beta) and (Eta) of ha is called a.

In ha, de Bruijn indices are encoded by means of the constant 1 and the substitution n-times

$. We write Sn as

a shorthand for $ o ... o $. We overload the notation / to represent the ha-term corresponding to the index

(AM N)
(M N)[S] (AM)[S]
M[S][T]
I[M. S] M[ia_
(S1 0 S2) 0 T
(M . S) o T id o S S oid
o (M. S) 1. $ 1[S]. (_ o S) A(M 1)

-----+ ---+ ---+

M[N. ic_ (M[S] N[S]) AM[1. (S o$)]
M[S oT]

---+ M -----+ M

_
--+ -----+ ---+ ---+ -----+ ---+ ---+

S1 0 (S2 0 T)
M[T] . (S o T) S S S id S N if M =_ N[_]

(Beta) (App) (Abs)
(Clos)
(VarCons) (Id)
(Assoc)
(Map) (IdL) (IdR) (ShiftCons) (VarShiff) (SCons) (Eta)

F_G. 3.1. The Ao'-calculus

[1]

i, i.e.,

i= --
- 11[_ n] iiffii==ln+l.

This one-shift encoding is interesting because involving a built-in deduction mechanism for arithmetic in

implementations

of systems based on the Aa-calculus makes it difficult the analysis of time and space quan-

titative performance. But in any conceivable implementation

one should use full indices at the meta-level

instead of the one-shift encoding.

An explicit substitution denotes a mapping from indices to terms. Thus, id maps each index i to the term/, $ maps each index i to the term i + 1, S o T is the composition of the mapping denoted by T with

the mapping denoted by S (notice that the composition of substitution follows a reverse order with respect

to the usual notation of function composition), and finally, M • S maps the index 1 to the term M, and

recursively, the index i + 1 to the term mapped by the substitution S on the index i.

The Aa-calculus is not a confluent rewrite system [17], however it is confluent on ground expressions [1]

and confluent on substitution-closed

expressions (i.e., expressions without substitution variables) [54]. On

the other hand, the a-calculus, i.e., Aa without (Beta), is confluent and terminating [1].

A term is called pure if it does not contain substitutions.

Notice that the set of pure terms in Aa and

the set of AdB-terms are identifiable. Furthermore, the Aa-calculus simulates the A-calculus [17], i.e., the

relations induced by _

and (Beta_

cr_ (one step of (Beta) followed by a a-normalization)

coincide

on pure terms. However, the Aa-calculus does not preserve strong-normalization

of the A-calculus [40], i.e.,

strongly normalizing A-terms can be reduced forever in Aa.

3.2. The An-calculus.

As pointed out before, the one-shift encoding of indices in Aa is a theoretically

convenient feature, but impractical for implementations.

Nadathur also remarked in [48] that the non-left-

linear rule of Aa, namely (SCons), is difficult to handle in real implementations.

Instead of rule (SCons),

he suggested the meta-rule 1[$ n] • ].n+l _

]-n. Since I n is a shorthand in AG, an infinite set of rules is

(AMN)

---+ M[N. t °]

(Beta)

(AM)[S]

-'---} AM[1. (S o ].1)]

(Abs)

(M N)[S]

---+ (M[S] N[S])

(App)

M[S][T]

--+ M[S o T]

(Clos)

I[M. S]

---+ M

(VarCons)

M[$ °]

---+ M

(Id)

(M . S) o T

---+ M[T] . (S o T)

(Map)

t° oS

---+ S

(IdS)

I-n-F1 0 (M. S) ---+ $_ o S

(ShiftCons)

I-n-F1 0 T m 1" ]-1

----+ T n o I-m-F1
_ ].o

(ShiftShift) (ShiftO)

l[].n+l]. ].n+2 __+ ].n+l

(ShiftS)

A(M 1)

---+ N if M =_ N[] "1] (Eta)

F_G. 3.2. The rewrite

system

A_

represented by this scheme.

Non-left-linear rules are not only annoying to implement, but they are usually responsible for non-

confluence and typing problems. Indeed, AcT is not confluent [17] and it does not preserve typing in a

dependent-type

system [45], both problems because of the non-left-linearity

of the calculus.

The Ac-calculus [44] is a left-linear variant of AcTwhere Sn is a first-class substitution. This allows the

formulation of the rule suggested by Nadathur as a regular first order rule. In fact, instead of (SCons), the

the Ac-calculus has the following rule: 1[] "n+l] • I-n+2 _

I-n+1.

DEFINITION 3.2 (Az-calculus).

The Ac-calculus is defined by the rewrite system depicted in Fig. 3.2

where

NATURAL NUMBERS
TERMS
SUBSTITUTIONS

n M, N S, T

::= 01n+l ::= !] AM ] (M N) ] M[S] ::= T _ IM.SISoT

The E-rewrite system is obtained by dropping rule (Beta) from A£.

We adopt the notation i as a shorthand for ![_ _] when i = n + 1. Substitutions id and _ are written in A£ as t ° and _1, respectively. In general, _n denotes the mapping of each index i to the term i + n. Using _,

the scheme of rule proposed by Nadathur can be encoded in a first order rewrite system. Natural numbers

are constructed with 0 and n + 1. Arithmetic calculations on indices are embedded in the rewrite system.

The Ac-calculus is confluent on substitution-closed as Aa, it does not preserve strong normalization.

expressions and it simulates the A-calculus [45]. Just

Another left-linear variant of Aa is the Aa_-calculus [17]. The Aa_-calculus is a confluent first order

rewrite system, i.e., it is confluent on presence of both term and substitution variables. However, Aa_ raises some technical problem with q-conversions due to the fact that substitutions id and _1 • _ are not

Aa_-convertible.

3.3. The As_-calculus.

The As¢-calculus avoids introducing two different sets of entities as the Aa-

calculus does, insisting in this way on remaining close to the syntax of the A-calculus. Next to abstraction

and application, the As¢-calculus introduces substitution (a) and updating (_) operators.

(AM N)

(AM)

(TiN

(M1 M2) o-iN

--+ M 0"1 N

"--"+

A(M o. i+1 N)

---+ ((M1 o-iN) (M2 o-iN))

(o.-generation) (o.-A-transition) (o.-app-transition)

n_o.iN

U_ (AM) u_(M1

M2)

---+ Uio N if n = i n__-I if n>i n if n<i
i _ A(Uk+ 1 M)

---}

((U_ M1)

(U_ M2))

(o.-destruction)
(U-A-transition) (u-app-transition)

U_ n -
(M1 o.iM2) o. j N
(Uki M) O-j N (Uki M) o.j N U_ (M o.j N) U_ (U_ M)
M)
A(M 1)

--+

-nn-+i-1

iiff nn><k_k

-----+ ---+ ---+
---+ -----+
_

(M1 o-j+l N) o.i (M2 o.j-i+l N) if i _<j

Uki-1 M if k < j < k +i

Uki(M o. j-i+l

N)

if k + i _<j

i (Uk+l

i
M) o-J (Ukwl-j

N) if j < k + 1

i U_ (Ukwl-j

M) if l + j _< k

^j+i-1 M if l <_ k < l + j

N if M=_ugN

(u-destruction)

(o.-o.-transition) (o.-u-transition (o.-u-transition (U-o.-transition) (U-u-transition (U-u-transition (Eta)

1) 2)
1) 2)

F_C. 3.3. Rewriting

system

of the )_se-calculus

DEFINITION 3.3 (As_-calculus). grammar

The As¢-calculus is given by the rewrite system in Fig. 3.3 and the

M,N::=n_I

(M N) IAMIMO'JNIuikM

for n,j,i>_l

and k>_O.

The calculus of substitutions associated with the As¢-calculus, namely s¢, is the rewriting system generated

by the set of rules s¢ = As¢ - {o.-generation, Eta}.

Intuitively, the substitution operator, o., initiates (rule (o.-generation)) one-step of/3-reduction,

from

(AM N), propagating the associated substitution innermost (rules (o.-A) and (o.-app-transition)).

Once this

propagation is finished, when necessary, the updating operator, U, is introduced to make the appropriate liR

over N (rule (o.-destruction)).

Otherwise either free de Bruijn indices are decremented by one or bounded

maintained.

The As¢-calculus [28].

simulates/3-reduction

and is confluent [33]. It does not preserve strong normalization

3.4. Simply-typed

calculi of explicit substitutions.

In this section, we only include the essen-

tial notation of the simply-typed Ac- and As¢-calculi. Properties can be found in detail in [44] and [32],

respectively. Typing rules in both calculi follow the scheme as those of the simply-typed Ao.-calculus [21].

The rewrite rules of the typed Ac- and As¢-calculi are defined by adding to their respective set of rules

the necessary typing information. Thus, for the simply-typed Ac-calculus we have the typed rules:

(AA.M N) (AA.M)[S] AA.(M 1)

---'+ M[N" $o] ----+ AA.M[I" (S 0 ]-1)] -----+ N if M =c N[$1]

(Beta) (Abs) (Eta)

10

A., _-1 : A (Var)

F-M:A--+B

, F-N:A

, F-(M N):B

(App)

, F- _.o _>, (Id)

_M:A

, }-S_>A

, SM.S_A.A

(Cons)

A., F- N : B

(Lambda)

, F- AA.N : A--+B

FS_A

AFM:A

, }- M[S]: A

(Clos)

, I- ].n [> A (Shift)
A., }- $n+1 _ A

}- T _>A2 A2 I- S [> A1 (Comp) , I- S oT[> A1

FIG. 3.4. Typing rules for the A£-calculus

A., _ 1: A (Var)
A., F- N : B (Lambda) , F- AA.N : A--+B
, >i F- N : B , <i.B., >i }- M : A (Sigma) , F-M0.*N:A

, }- n : B

(Varn)

A., }- n+ 1 : B

_N:A--+B , F-(N

, _M:A M):B

(App)

, <k., >k+i F- M : A (Phi) , _- _k_ M : A

FIe. 3.5. Typing rules for the Ass-calculus

and for the typed Ass-calculus:

(AA.M N)

(/_A.M)

(TiN

9_ (AA.M) AA.(M 1)

---+ M 0-1 N
---"+ )_A. (M 0.i+1 N)
---+ AA.(9_+I M) --+ N if M=8_gN

(0.-generation) (0.-A-transition) (9_-A-transition) (Eta)

Typing rules for the At-calculus

and the Ass-calculus

are presented

in the Figures 3.4 and 3.5, respec-

tively. Notice that in the case of the At-calculus,

substitutions

receive contexts as types. This is denoted as

, }- S _ A. Let , be a con text of the form A1.A2...An .A. We use the notation , <k and , >k for denoting

the contexts manner.

A1...Ak and Ak...An.A,

respectively.

This notation is extended for "<" and ">" in the obvious

EXAMPLE 3.4. In order to illustrate the use of the typing rules, we show how to infer the type of the

term AA__+B.AB__+C.AA.(2

(3-- 1)) in Ass.

For short, let, = A.B--+C.A--+B.

Firstly, observe that

(1), }-l:A(Var) Then, we have

(Var)

B-+C.A-+B

F- 1 : B--+C (Varn)

(2), _-2_:_-_c

A--+B F- 1 : A--+B (Vm')

B--+C.A--+t_

2 : A--+B (Varn)

(3), _ 3-: X-_B (yarn)

(3) (1) (2) , V(3- 17." B (App)

, F- (2 (3_-_))iC

(App)

11

Finally, notice that

, I- (2 (3_ 1)): C

(Lambda)

B--+C.A--+B F- AA.(2_ (3_ 1)) : A--+C

A--+B I- )_B--+C.AA.(_2 (3_ !)) : (B--+C)--+(A--+C) (Lambda)

I- AA-+B.AB-+C.AA.(2_ (3_ !)): (A--+B)--+((B--+C)--+(A--+C))

(Lambda)

For the At-calculus the inference is identical except for the first steps; for instance, notice that

B--+C.A--+B F- "F° _, B--+C.A--+B (Id)

A--+B F- "F° _, A--+B (Id)

, f_ ._1 _ B--+C.A--+B

(Shift) B--+C.A--+B , F- $2 _, A--+B

f- ._1 _ A--+B (Shift) (Comp)

Then,

(Vat)

, F-$2 _, A--+B

A-+B F- 1 : A-+B (Clos)

, k3_:A--+B

Remember that the language of the At-calculus simulated using the $n.

only includes the de Bruijn index 1 and the others are

The simply-typed versions of the Ac- and As¢-calculus satisfy, among others, the properties of subject reduction and type uniqueness. Additionally, they are Weakly Normalizing (WN) and Church-Rosser (CR).

4. Applications.

Although in an intuitionistic logic, the concepts of propositions and types are iden-

tiffed, proof construction and term synthesis do not necessarily go in the same direction. For instance, to

prove the proposition A--+(B--+A), one may assume A as an hypothesis and then, recursively, try to prove

(B--+A). Eventually, one gets the axiom A, B F- A and the proof derivation is completed. On the other

hand, the proof synthesis procedure decorates with A-terms the proof-tree derivation from the axioms, i.e.,

x:A, y:B F- x : A, down to the conclusion, i.e., F- Ax:A.Ay:B.x : A--+(B--+A).

In order to synthesize a A-term at the same time as a proof is being developed, it is necessary to represent

incomplete-proofs.

Assume, for example, the proposition A--+(B--+A). The bottom-up application of the rule

(Abs) results in a term Ax:A.X where X is a term to be constructed of type (B--+A). A term as Ax:A.X

is called an open term and the place-holder X denotes a hole to be filled with a term of the right type, in

this case of type (B--+A). Place-holders are also called meta-variables to distinguish them from the variables of the A-calculus. Meta-variables are written as uppercase last letters of the Latin alphabet: X, Y, .... At

some moment during the proof derivation, we get the typing judgment x:A,, F- Ay:B.x : (B--+A). Hence,

to obtain a close term, i.e., a term without meta-variables,

we can instantiate the meta-variable X with

the term Ay:B.x. This results in Ax:A.Ay:B.x.

In contrast to substitution of variables, instantiation

of

meta-variables is a first order replacement of free-variables.

that does not take care of renaming of bound variables or capture

Notice, however, that open terms are not A-terms. In fact, (1) instantiation and /3-reduction do not

commute, and (2) instantiation and typing do not commute. To illustrate the first point, take the open term

(Ax.X y) and the instantiation of X with x. The instantiation results in (Ax.x y), which /3-reduces to

y. However, the original term /3-reduces to X, which gets instantiated as x. To see why instantiation and

typing do not commute, consider the context, = x:A, z:(B--+A)--+C and the open term (z Ax:B.X) of type

C, where X is a meta-variable of type A. If we instantiate X with the variable x of ,, then w e obtain the

ill-typed term (z Ax:B.x).

12

Meta-variablecsanbeencodeidn classicaAl-calculus by using a technique taken from the higher order
unification tradition [31]. This technique uses a functional handle of scope. For instance, the open term

Ax:A.Y, where Y is a meta-variable of type B, is encoded as the A-term Ax:A.(y x), where y is a fresh variable of type A--+B. In this case, the information that the variable x can indeed occur in a subsequent

substitution of y is taking into account by the application (y x). Thus, an instantiation of Y with M in the original problem is translated as a substitution of y by Ax:A--+B.M in the A-calculus. Notice, however that the meta-variable Y has the type B while the corresponding variable y has the type A--+B.

Explicit substitutions and de Bruijn indices allow a simple and natural notation for open terms. First,

in a de Bruijn setting, meta-variables are just variables of the free algebra of terms. Notice that bound and free variables of the A-calculus are represented as indices. And second, explicit substitution calculi as Aa,

A_, and As_, are confluent on open terms (in the case of Aa and A_, on substitution-closed

these calculi, commutation of instantiation and the/_-reduction

is for free.

We will consider meta-variables over a set X.

terms). Thus, in

DEFINITION 4.1. The set AdB(X) of A-terms in de Bruijn index notation with meta-variables over the

set X is defined inductively as

M, N ..= X I (M N) I AM

where n E N >°,XEX.

DEFINITION 4.2. A valuation is a mapping from X to AdB(X). The homeomorphic extension of a

valuation, 0, from its domain X to the domain AdB(X) is called the grafting of 0.

As usual valuations and their corresponding graftings are denoted by the same Greek letters. Application

of a grafting 0 to a term M will be written in postfix notation M0. For explicit representation of a valuation

and its corresponding grafting 0, we use the notation formal concept for meta-variable instantiation.

0 = {X _-+ XO ] X E Dora(O)}.

A grafting is the

The set of Aa-, Az-, and As¢-terms with meta-variables,

and their respective grafting notion, can be

defined in a similar way. The typing rule for meta-variables in these systems is [21]:

, x _ X : Ax (Metax)

where Ax and, x are, respectively, a unique type and a unique context associate to each meta-variable. using this rule, typing and instantiation of meta-variables commute [21].

By

4.1. Higher order unification.

Higher order unification (HOU) is essential in automated reasoning,

where it has formed the basis for generalizations of the Resolution Principle in higher order logics, being

a sine qua non mechanism in the implementation

of higher order proof assistants and higher order logic

programming languages as the ones previously referenced. For a very simple presentation of HOU see [57]

and for a detailed introduction in the context of declarative programming see [53]. As for the first order

case, substitution is the key operation for HOU and its implicitness makes difficult the analysis of important

computational properties. Therefore, use of calculi of explicit substitution in the formal implementation

of

HOU procedures is relevant.

HOU problems are expressed in the language of the simply-typed A-calculus in de Bruijn indices over

a set of meta-variables X, denoted AdB(X).

Meta-variables play the role of unification variables. A simple

example of a H OU problem is to search for function solutions F of the equality F(f (a)) =? f (F(a)). That can

be written in AdB(X) as (X (_2 1)) =_ (_2 (X 1)), where both X and _2are of functional type, say A--+A

13

and1 of atomic type A. A solution for X is the function

(correspondingly,

{F = f, F = f2,...}) are solutions too.

identity,

AA.1 but {AA.(3 1),AA.(3

(3 1)),...}

The first person to present a HOU algorithm of practical interest was Huet [31]. Huet's work was relevant because he realized that to generalize Robinson first order Resolution Principle [55] to higher order theories it is useful to verify the existence of unifiers without computing them explicitly. Huet's algorithm is a semi-decision one that may never stop when the input unification problem has no unifiers, but when the problem has a solution it always presents an explicit unifier. Unification for second-order logic was proved undecidable in general by Goldfarb [26]. Goldfarb's proof is based on a reduction from Hilbert's Tenth Problem. This result shows that there are arbitrary higher order theories where unification is undecidable, but there exist particular higher order languages of practical interest that have a decidable unification problem. In particular, for the second-order case, unification is decidable, when the language is restricted to monadic functions [23]. Another problem of HOU is that the notion of most general unifier does not apply and that a notion more complex than the one of complete set of unifiers is necessary. Huet has showed that equations of the form (Ax.F a) =? (Ax.G b) (called flex-flex) of third-order may not have minimal

complete sets of unifiers and that there may exist an infinite chain of unifiers, one more general than the other, without having a most general one (for references see section 4.1 in [53]).

The general method of HOU via calculi of explicit substitutions was introduced in [21] (for the Aacalculus) and consists mainly in: firstly, a translation or "pre-cooking" from HOU problems in AdB (X) into the language of a calculus of explicit substitutions. Secondly, an application of (first order) unification in the selected calculus of explicit substitutions to solve the translated problems. Finally, translation back of the given grafting solutions into substitution solutions of the original HOU problem. In this way HOU problems are solved via first order unification in the language of calculi of explicit substitution. We will explain with examples how reduction relations from the simply-typed Aa-calculus and As¢-calculus of explicit substitutions are used to solve HOU problems in AdB(X). For a formal presentation of the methods consult [21] and [2].

DEFINITION 4.3. Let 0 = {X1 _-_ al,...,Xn

_ an} be a valuation from the set of recta-variables X

to AdB(X). The corresponding substitution,

{al/Xl,...,an/Xn},

also denoted by 0 but written in a prefix

notation, is defined inductively as follows

1. O(m) = m, for m • N;

2. O(X) = X{X 1 _ al,..., Xn _ an}, for X • X;

3. O(al a2)= (0(al) O(a2));

_. 0(/_al) = )_O+(al);

where 0 + denotes the substitution corresponding to the valuation 0 + = {X1 _ a+,..., Xn _ a+}.

Unifying two terms M and N in AdB (X) consists in finding a grafting 0 such that its corresponding substitution satisfies O(M) =_ O(N). Notice that application of a grafting has a different effect to the application of its corresponding substitution. For instance, although (AX){X _-_ M} -- AM, a unifier of the

problem AX =_v AM is not {M/X}, since (AX){M/X} = A(X{M+/X})

= AM +. However, by translating

appropriately the AdB (?()-terms M, N, the HOU problem M =_ N can be reduced to first order unification

either in the Aa- or in the As¢-calculus. Essentially, the pre-cooking translation from terms in AdB (X) into

the language of the Aa-calculus replaces each occurrence of a meta-variable X with x[$k], where k is the

number of abstractors above the occurrence of X. For the case of the As¢-calculus the pre-cooking translates

each occurrence of a meta-variable X into pk+lx, where k is as before.

EXAMPLE 4.4. Consider the problem _2 =_ (X _2) being _2of type A and X of type A--+A. Introducing a fresh meta-variable Y of type A the problem is translated into _2 =_ (AY _2)A X =_ AY.

14

Inthe As_-calcultuhseproblemisnormalizeidnto_2 =_s, Y0.12AX-

=5,8.* AY, whose solutions are {1/Y}

and {3_/Y} giving as result the solutions {)d/X} and {A3/X}.

In the A0.-calculus the problem is normalized into _2 =_,_ Y[2.ia__ A X =5,_* AY, from which we infer the

solutions above.

EXAMPLE 4.5.

Now consider the HOU problem _2=_v (AZ _2), where _2 and Z are of type A.

In the As,-calculus the problem is pre-cooked into _2 =_,,. (Ag_gZ _2) and then transformed into _2 =_,,.

(9_gZ)0.1_2 and subsequently into _2=_,,. 9_lZ by normalization. The sole possible solution given is {Z _-+ _2}. Observe, on the one side, that (A_gZ _2){Z _ _2} = (A_g_2 _2) =x,. (A3_ _2) =x,. 3o1_2 =Xs. _2. On the other

side, turning back the pre-cooking transformation,

this corresponds to the substitution solution {_2/Z} for

the original problem. In fact, (AZ _2){_2/Z} = (()_Z){_2/Z} _2{_2/Z}) = ()_(Z{_2+/Z}) _2) = (A3- _2). The

previous term fl-reduces into _2.

In the A0.-calculus the problem is pre-cooked into l[T] =_,, (AZ[T] 1[$]) which A0.-reduces into l[T] =_,,

(Z[T])[l[T].id] and subsequently into l[T] =_,, Z[T o(l[T].id)] and into l[T] =_,, Z[ia_ and finally into l[T] =_,,

Z giving the corresponding sole solution {Z _-+ 1[$]}. This corresponds to the above grafting solution in As_. On the one side,(AZ[T] l[t]){Z _ l[t]}= (A((I[T])[T]l)[t])=x_ (AI[T2] l[t])=x_, l[t2][l[t].=ixd_]

![T 2 o(![T].id)] =x, I[T]. On the other side, turning back the pre-cooking transformation,

this corresponds

to the substitution solution {_2/Z} for the original problem in AdB (A2) as above.

Notice that {1/Z} is not a substitution solution of the previous problem, since for any de Bruijn index

n_ we have ()_Z){n_/Z} = )_(Z{n_+/Z} ) = )_(n + 1).

The following example illustrates why pre-cooking of A-terms before applying unification rules is essential. EXAMPLE 4.6. (Continuing example 4.5) In the As¢-calculus, when normalizing the HOU problem _2=_, (AZ _2) before pre-cooking we obtain _2 =_,_. Z0.1_2, whose solutions are the graRings {Z _-+ 1} and {Z _-+ 3_}. As previously mentioned {1/Z} is not a substitution solution of the original HOU problem. Analogously, in the A0.-calculus, when normalizing the corresponding problem l[T] =_,¢ (AZ l[T]) we obtain l[t] =_ AZ[I[T].id], whose solutions are {Z _-+ 1} and {Z _-+ 1[T2]} given rise to the same problem.

4.2. Type inference.

In order to infer types of A-terms (or A0.-terms or As¢-terms) we deal with new

sets of type variables Ti and context variables 7/, i E N. Essentially, we will take as input of a type inference

problem a term without knowing its type and context and as output we will formulate a first order unification

problem on type and context variables. Well-typedness of the input term will then correspond to solvability

of the generated first order unification problem. Here we illustrate the general method mentioned above

using the language of the As¢-calculus. Simple modifications according to the typing rules of the selected

language will adapt this method to other settings.

Let M be a As¢-term. Initially, we introduce new variables for the type and for the context of each

subterm of M. Then M can be seen as a new term M' with all its subterms decorated with one different

type variable as subscript and one different context variable as superscript.

EXAMPLE 4.7.

(/_A.(/_B.(/_C.(2r_--

_

(3 _/2 1_3_4_5_\--T2

--T 3 / T4 / T5

] T6 ] T7

_s] T8 ' where

T/ and

7/, i = 1,...,8

are new mutually

different type and context variables, is the decorated version of the A-term AA.AB.AC.(_2 (3_ 1)).

ARerwards, we apply the set of transformation

rules in Table 4.1 for pairs of the form (R, E), where R

is a set of decorated terms and E a set of equations on type and context variables. The application of these

transformation

rules begin from the par (R0, 0), where R0 is the set of all decorated subterms of M'.

15

Transformation

(Va )

<Ru E>

(Va n) <Ru E>

(Lambda)
(@p) (sig. a)

<Ru
(\_'_T1

T2 IT3

J'

v _'T2

]T3J'

(Phi)

(M ta) <Ru {x/}, E>

TABLE 4.1 rules for type inference

in the Ase-calculus

--+ (R, E U {9/= v.7'}>, where 7' is a fresh context variable;

-"} <R, E U {7 ---- T_... T'n--l" T "7- ,lJ']\, where
fresh context and type variables;

91, and Ti,,... , Tn,_ 1 are

--+ (R, EU{v2 :A---+TI,'/1 ---A.'/2}>;

--+

(R,E U {'/1 ---- _2,_2

---- _3,7-1

---- 7-2-"}7-3}>;

-+ (R,E U {Vl = 73,71 = v_...Vi_!l.V2.72,Ts

= vi!...Vi_!l.72}),

where v_, ...,Ti_1! are fresh type variables and in the case

that i -- 1 the sequence vi.' ..vi1_' is empty;

!!
---} </_, E U {7-1 ---- T2, _2 ---- Ti...Tk__i_

!
1._/, _/1 :

!!

Ti...Tk_

1._!}>,

where 7' and 7_, ..., Tk_1_!i_ are fresh context and type vari-

ables and in the case that k _ 1 respectively k = 0 and

i -- 1 the sequences 7_...7)_1_' respectively empty; -+ (R, EU{_/=,x,v=Ax}>,where,xF-X:Ax;

Tl1..!.Tk+' i_

are

Notice that the transformation

rules in the Table 4.1 are built according to the typing rules of the As¢-

calculus. After the application of each of the transformation

rules the size of the current set of decorated

subterms R decreases by one. Consequently, the application of these rules beginning from the pair (R0, 0>

finishes after a finite number of steps (exactly as many steps as subterms in M) giving as result an empty

set of decorated terms and a set E/of equation on type and context variables. Ey is a first order unification

problem on type and context variables.

Finally, our algorithm terminates by applying any first order unification algorithm to E]. If the unifi-

cation algorithm fails then our term is ill-typed. Otherwise, if the unification algorithm succeeds, the most

general unifier resulting as output gives straightforwardly

a context , and a type A such that , t- M : A.

Of course, the construction of, and A is done from the bindings given in the resulting unifier corresponding

to the outermost context and type variables selected in the decoration of M.

Correctness and completeness of this method is a direct consequence from the correctness and com-

pleteness of the first order unification and of the typing rules of the Ase-calculus used to construct the

transformation

rules in Table 4.1.

EXAMPLE 4.8. (Continuing Example 4.7) The initial input for the set of inference rules is (R0, 0>, where

In the sequel, we show the steps of the application of the transformation

rules. For convenience we

apply the rules in an specific order (from smaller to bigger subterms), but the application of the rules is

nondeterministic.

Applying the rules in any order we will obtain different sets of equations that correspond

16

to the same unification problem.

(Ro, 0>

-+ Vat

(R1 = RO \ L[173J_,-7E3l = {73 = 7.3.7_ }> <R2 = R1 \ {_2_7_}, E2 = E1 U {71 = 7._.7.1.72}}
<R3= R2 \ {3772 2},E3 = E2 u {72= v2' .v3' .v2 . %'}> <R4 = R3 \ {(3-7_ -73173_J7,4_EJ_74= E3 u {72 = 73,73 = 74,7.2 = _3-+_4}>

(R 5 = R 4 \ { (2_

(,-3-72 ±]73_74]_7745]_]75 J' E5 = E4 [-J {71 = 74,74

= 75,7-1 = 7.4-+7.5}>

(R6 -- R5 \ {(Ac.(2_: (3__ -73173E3764_3_7745 3_7_}, -- E5 [2 {7.6 -- C--+7.5,75 -- C.76 }> (R7 -- R6 \ { (AB. (AC. (2_: (3__ -731_7374_73475_7357_)7777¢_ }, E7 --- E6 [2 {7.7 --- B--+7.6,76 --- B.77 }>

<_ = R7 \ {(AA.(A,.(Ac.(2_: --

(37_ 173_74_75_7_77_Ts},Es

k--T2

--T 3 / 74 / T5 / T6 / T7 / T8

= E7 U {7.s = A--+7.7,77 = d.Ts}>

"+Varn
"+Varn
"+ A pp
-+App
-+Lambda -+Lambda -+Lambda

Now the reader is invited to apply his/her preferred first order unification algorithm for resolving the unifi-

cation problem Es = {73 = 7.3.71,71 = 7._.7.1.7_,72 = 7._.7._.7.2.7_, 72 = 73,73 = 74,7.2 = 7.3--+7.4,71 = 74,74 =

75,7.1 = 7.4--+7.5,7.6 = C--+7.5,75 = C.76,7.7 = B--+7.6,76 = B.77,7.s = A--+7.7,77 = A.Ts} and then to resolve

the bindings of the resulting unifier (if it exists) for giving appropriate A-term.

contexts and types for the input

4.3. Inhabitation

and higher order logics. Given a type A and a context of variable declarations ,,

the inhabitation problem consists of finding a term M such that, F- M : A. Using the open term approach,

the problem can be formulated as finding a pure instantiation for the meta-variable X satisfying,

F- X : A.

Thus, the term to instantiate X can be constructed at the same time as the proof derivation of A by applying

the typing rules in a bottom-up manner and introducing new meta-variables for the unknown terms.

For the simply-typed A-calculus this problem is decidable. In fact, since provability in the minimal

propositional intuitionistic logic is decidable, the term M can be built directly from the proof-tree derivation

of _ F-I A, where _ is the set of types in ,, as explained before. However, when we move to a first order or

a higher order intuitionistic logic and, in consequence, we extend the type system to handle quantification,

the problem becomes much more complicated. In [47], a semi-algorithm to solve the inhabitation problem

via the Az-calculus has been presented. It uses the fact that Az is confluent on substitution-closed

terms

and weakly normalizing, even for dependent type settings of the calculus.

Although first and higher order logics are out of the scope of this paper, we give some hints of the

inhabitation problem for these kind of logics. See [20] for a complete description of a term synthesis algorithm

in the Cube of Type Systems and [47] for a similar algorithm via explicit substitutions and open terms.

The Dependent Type theory, namely AH [29], is a conservative extension of the simply-typed A-calculus.

It allows a finer stratification of terms by generalizing the function space type. In fact, in AH, the type of

a function Ax:A.M is Hx:A.B where B (the type of M) may depend on x. Hence, the type A--+B of the

simply-typed A-calculus is just a notation in AH for the product Hx:A.B where x does not appear free in

B. The Calculus of Constructions,

namely CC, [15, 16] extends the AH-calculus with polymorphism and

constructions of types. From a logical point of view, AH and CC allow representation

of proofs in the first

and higher order intuitionistic logic, respectively. Via the types-as-proofs principle, a term of type Hx:A.B

is a proof-term of the proposition Vx:A.B.

Terms in these calculi can be variables, applications,

or abstractions,

like in classical A-calculus, or

two new kind of terms: products (Hx:A.B), and sorts (Type, Kind). Term and types belong to the same

syntactical category. Thus, Hx:A.B is a term, as well as Ax:A.M. However, terms are stratified in several

levels according to a type discipline. For instance, given an appropriate context of variable declarations,

17

x:A,, F- M : B

x:A,, F- B : {Type, Kind} (Abs)

, f- Ax:A.M : IIx:A.B

, _M:IIx:A.B

, _N:A

, I-- (M N): B{N/x}

(Appl)

F_G. 4.1. Rules (Abs) and (Apl) for the CC type system

Ax:A..M : IIx:A..B, IIx:A..B : Type, and Type : Kind. but it is necessary since a circular typing as Type : Type give rules (Abs) and (Appl) for the CC type system.

The term Kind cannot be typed in any context, leads to the Girard's paradox [25]. In Fig. 4.1 we

The At-calculus has been extended with products for the AII and CC-type systems in [45]. These

variants satisfy the same properties as the simply-typed version: confluent on substitution-closed

terms,

weakly-normalizing,

and subject reduction. For further details we refer to [45].

EXAMPLE 4.9. We can proof the first order predicate (Vx.(P x))--+(P c) by finding a term X of type (IIx:A.(P x))--+(P c) in a context where the term c has the type A and P has the type A-+Type. The bottom-up application of rule (Abs) results in a term X having the form Ay:(IIx:A.(P x)).Y where Y is a

term of type (P c) in a context where the variable y has the type IIx:A.(P x). If we instantiate Y with

the term (y c), which is a well typed term of type (P c), we obtain the term Ay:(IIx:A.(P x)).(y c) of

type IIx:(IIx:A.(P

x)).(P c). Notice that in this example we have used the meta-variables X and Y and

the instantiation mechanism of meta-variables to build incrementally a proof.

Typing of meta-variables is more complicated Since meta-variables can appear in terms, types, circular dependences.

in dependent-type systems than in the simply-type case. and contexts, the typing rules should take care of possible

5. Conclusion.

The A-calculus uses an external and atomic operation to compute the substitutions

of variables by terms. Calculi of explicit substitutions improve the substitution mechanism by allowing

substitutions to be part of the formal language by means of special constructors and reduction rules. There

are several versions of calculi of explicit substitutions.

Figure 5.1 summarizes the main characteristics of

some of them. All these calculi implement substitutions.

the /_-reduction

by means of a lazy mechanism

of reduction

of

In this paper we have explored new developments

of explicit substitution:

Aa and As_.

and applications

on two of the most successful styles

REFERENCES

[1] M. ABADI, L. CARDELLI,

P.-L. CURIEN, AND J.-J. Lt_VY, Explicit Substitutions, Journal of Functional

Programming, 1 (1991), pp. 375-416.

[2] M. AYALA-RINCdN AND F. KAMAREDDINE,

Unification via Ase-Style of Explicit Substitution, in 2nd

International Conference on Principles and Practice of Declarative Programming, Montreal, Canada,

September 2000, ACM Press.

[3] H. P. BARENDREGT,

The Lambda Calculus : Its Syntax and Semantics

(revised edition), North Holland,

1984.

[4] -- , A-calculi with types, Handbook of Logic in Computer Science, II (1992). [5] B. BARRAS, S. BOUTIN, C. CORNES, J. COURANT, J. FILLIATRE, E. GIMt_NEZ, H. HERBELIN,

18

Conj_uence Mv Mv _-_ _-_

Normalization

Wk Wk Wk Wk

Composition Finitary 1St-order
Variables
Number of rules 3-reduction

.... **

dB dB 13 12 _._.._..... ___

dB 13t ___

........
dB 19 ___

Reference

[1] [44] [32] [17]

_-_ PEN
dB 13 Z$ [43]

Gad Gad PEN PEN

dB 8 _._.._.....

dB 19 ___

[38] [35]

Gad PEN
**
Nm 6 ___ [8]

Gad PEN
**
Lv 10t ___ [39]

The general property holds.

The property does not hold.

The property holds with restrictions. Mv Confluence on semi-open expressions, i.e. only with meta-variables of terms. Gad Confluence on ground expressions. Wk Weak normalization on typed terms. PSN Preservation of strong normalization. dB De Bruijn indices notation of variables. Nm Vm-iable names. Lv De Bruijn levels notation with variable names.
Restricted composition. In particular, the ,k_-calculus does not allow simultaneous substitutions.

Number of schemes. The ,ks¢-calculus is not finitary.

Big-step semantic of/3-reduction. /3-reduction.

The ,k¢-calculus does not simulate each step of

F_c. 5.1. Some calculi of explicit substitutions

G. HUET,

C. MUI_OZ,

C. MURTHY,

C. PARENT,

C. PAULIN,

A. SAIBI, AND B. WERNER,

The

Coq Proof Assistant Reference Manual - Version V6.1, Tech. Report 0203, INRIA, August 1997.

[6] N. BJ_RNER AND C. MUI_OZ, Absolute explicit unification, in International Conference on Rewriting Techniques and Applications (RTA'2000), vol. 1833 of Lecture Notes in Computer Science, Norwich,

U.K., July 2000, pp. 31-46.

[7] R. BLOO, Preservation ics and Computing

of Termination for Explicit Substitution, PhD thesis, Department Science, Eindhoven University of Technology, 1997.

of Mathemat-

[8] R. BLOO AND K. H. ROSE, Preservation of strong normalisation in named lambda calculi with explicit

substitution 1995.

and garbage collection, in Proc. CSN-95: Computer Science in the Netherlands,

Nov.

[9] D. BRIAUD, Higher order unification as a typed narrowing, tech. report, CRIN 96-R-112, 1996.

[10] A. CHURCH, An unsolvable problem of elementary number theory, American Journal of Mathematics,

58 (1936), pp. 345-363.

[11] --,

A formulation of the simple theory of types, Journal of Symbolic Logic, 5 (1940), pp. 56-68.

[12] --,

The Calculi of Lambda-conversion,

Princeton University Press, 1941.

19

[13] H. CIRSTEA AND C. KIRCHNER,

Combining Higher-order and First-order Computation

Using p-

Calculus: Towards a Semantics of ELAN, in Frontiers of Combining Systems 2, D. M. Gabbay

and M. de Rijke, eds., Studies on Logic and Computation, 7, Research Studies Press/Wiley, 1999,

ch. 6, pp. 95-121.

[14] --,

Introduction to the Rewriting Calculus, Rapport de Recherche 3818, INRIA, Dec. 1999.

[15] T. COQUAND,

Une Thdorie de Constructions, th_se de doctorat, U. Paris VII, 1985.

[16] T. COQUAND AND G. HUET, The Calculus of Constructions, pp. 96-120.

Information and Computation,

"/6 (1988),

[1"/] P.-L. CURIEN, T. HARDIN, AND J.-J. LEVY, Confluence Properties of Weak and Strong Calculi of

Explicit Substitutions, Journal of the ACM, 43 (1996), pp. 362-39"/. Also as Rapport de Recherche

INRIA 161"/, 1992.

[18] g. B. CURRY AND R. FEYS, Combinatory Logic, vol. 1, North Holland, 1958.

[19] N. DE BRUIJN, Lambda-calculus

Notation with Nameless Dummies, a Tool for Automatic

Formula

Manipulation, 392.

with Application to the Church-Rosser

Theorem, Indag. Mat., 34(5) (19"/2), pp. 381-

[20] G. DOWEK, A complete proof synthesis method for type systems of the cube, Journal of Logic and

Computation, 3 (1993), pp. 28"/-315.

[21] G. DOWEK, T. HARDIN, AND C. KIRCHNER, Higher-order Unification via Explicit Substitutions, In-

formation and Computation, 15"/(2000), pp. 183-235.

[22] G. DOWEK, T. HARDIN, C. KIRCHNER, AND F. PFENNING, Unification via explicit substitutions: The

case of higher-order patterns, in Proceedings of the Joint International Conference and Symposium

on Logic Programming, M. Maher, ed., Bonn, Germany, Sept. 1996, MIT Press.

[23] W. FARMER, A Unification Algorithm for Second-order Monadic Terms, Annals of Pure and Applied

Logic, 39 (1988), pp. 131-1"/4.

[24] M. C. F. FERREIRA,

D. KEENER, AND L. PUEL, Lambda-calculi

sition which preserve beta-strong normalization, in Algebraic

with explicit substitutions and Logic Programming,

and compo5th Interna-

tional Conference, ALP'96, M. Hanus and M. Rodrfguez-Artalejo,

eds., vol. 1139 of LNCS, Aachen,

Germany, 25-2"/Sept. 1996, Springer, pp. 284-298.

[25] J.-Y. GIRARD, Interprgtation

FonctioneUe et fi,limination des Computes de l_Arithmgtic d_Ordre

Supgrieur, th_se de doctorat, Universit_ Paris VII, 19"/2.

[26] W. GOLDFARB, The Undecidability of the Second-order Unification Problem, Theoretical Computer

Science, 13 (1981), pp. 225-230.

[2"/] M. GORDON AND T. MELHAM, Introduction to HOL: A Theorem Proving Environment for Higher

Order Logic, Cambridge University Press, 1993.

[28] B. GUILLAUME,

The _Se-calculus Does Not Preserve Strong Normalization, Journal of Functional Pro-

gramming, 10 (2000), pp. 321-325.

[29] R. HARPER, F. HONSELL, AND G. PLOTKIN, A framework for defining logics, Journal of the Association

for Computing Machinery, 40 (1993), pp. 143-184.

[30] J. R. HINDLEY, Basic Simple Type Theory, no. 42 in Cambridge Tracts in Theoretical Computer

Science, Cambridge University Press, 199"/.

[31] G. HUET, A Unification pp. 2"/-57.

Algorithm

for Typed _-Calculus,

Theoretical

Computer Science, 1 (19"/5),

[32] F. KAMAREDDINE AND A. Rfos, A _-calculus it la de Bruijn with Explicit Substitutions, in Proc. of

20

PLILP'95v, ol.982ofLNCS,Springer1,995p, p.45-62. [33]--, Extending a A-calculus with Explicit Substitution which Preserves Strong Normalisation

into a

Confluent Calculus on Open Terms, Journal of Functional Programming, 7 (1997), pp. 395-420.

[34] F. KAMAREDDINE AND A. RIOS, Relating the Aa- and As-Styles of Explicit Substitutions, Journal of

Logic and Computation, 10 (2000), pp. 349-380.

[35] D. KESNER, Confluence properties of extensional and non-extensional

A-calculi with explicit substi-

tutions (extended abstract), in Proceedings of the Seventh International Conference on Rewriting

Techniques and Applications Jersey, 1996, Springer-Verlag,

(RTA-96), H. Ganzinger, pp. 184-199.

ed., vol. 1103 of LNCS, New Brunswick,

New

[36] C. KIRCHNER AND C. RINGEISSEN,

Higher-order Equational Unification via Explicit Substitutions,

Proc. Algebraic and Logic Programming, vol. 1298 of LNCS, Springer, 1997, pp. 61-75.

in

[37] S. C. KLEENE, A-definability and recursiveness, Duke Mathematical Journal, 2 (1936), pp. 340-353.

[38] P. LESCANNE,

From Aa to Av a Journey Through Calculi of Explicit Substitutions, in Proceedings of

the 21st Annual ACM SIGPLAN-SIGACT

Symposium on Principles of Programming Languages,

January 1994, pp. 60-69.

[39] P. LESCANNE AND J. ROUYER-DEGLI,

Explicit substitutions with de Bruijn's levels, in Proceedings of

the International Conference on Rewriting Techniques and Applications (RTA-95), J. Hsiang, ed.,

vol. 914 of LNCS, Chapel Hill, North Carolina, 1995, Springer-Verlag, pp. 294-308.

[40] P.-A. MELLIES,

Typed A-calculi with explicit substitutions may not terminate, LNCS, 902 (1995),

pp. 328-338.

[41] D. MILLER, AProlog: An Introduction to the Language and Its Logic. Draft, Department of Computer

Science and Engineering, The Pennsylvania State University, 1998.

[42] R. MILNER, M. TOFTE, AND R. HARPER, The Definition of Standard ML, MIT Press, Cambridge,

MA, 1991.

[43] C. Mu_oz, Confluence and preservation of strong normalisation in an explicit substitutions calculus (extended abstract), in Proceedings of the Eleventh Annual IEEE Symposium on Logic in Computer Science, New Brunswick, New Jersey, July 1996, IEEE Computer Society Press, pp. 440-447.

[44] --,

A left-linear variant of Aa, in Proc. International Conference PLILP/ALP/HOA'97,

vol. 1298 of

LNCS, Southampton (England), September 1997, Springer, pp. 224-234.

[45] C. Mu_oz, Un calcul de substitutions pour la reprdsentation de preuves partielles en thdorie de types,

PhD thesis, Universit_ Paris 7, 1997. English version in Rapport de recherche INRIA RR-3309, 1997.

[46] C. Mu_oz, Dependent types and explicit substitutions. To appear in Mathematical Structures in Com-

purer Science. It also appears as report NASA/CR-1999-209722,

ICASE No. 99-43, 1999.

[47] --,

Proof-term synthesis on dependent-type systems via explicit substitutions.

To appear in The-

oretical Computer 1999.

Science. It also appears as report NASA/CR-1999-209730,

ICASE No. 99-47,

[48] G. NADATHUR, A fine-grained notation for lambda terms and its use in intensional operations, Journal of Functional and Logic Programming, (1999).
[49] G. NADATHUR AND D. S. WILSON, A Notation for Lambda Terms A Generalization of Environments, Theoretical Computer Science, 198 (1998), pp. 49-98.
[50] R. P. NEDERPELT, J. g. GEUVERS, AND R. C. DE VRIJER, Selected papers on Automath, NorthHolland, Amsterdam, 1994.

[51] S. OWRE, J. M. RUSHBY, AND N. SHANKAR, PVS: A prototype verification system, in 11th Interna-

21

tional Conference on Automated Deduction (CADE), D. Kapur, ed., vol. 607 of Lecture Notes in

Artificial Intelligence, Saratoga,
[52] F. PFENNING AND C. SCHURMANN,

NY, June 1992, Springer-Verlag, pp. 748-752. Twelf user's guide, 1.2. edition, Tech. Report CMU-CS-1998-173,

Carnegie Mellon University, September 1998.
[53] C. PREHOFER, Progress in Theoretical Computer

Science, in Solving Higher-Order

Equations: From

Logic to Programming, R. V. Book, ed., Birkh_user, 1997.
[54] A. Rfos, Contributions _t l'dtude de A-calculs avec des substitutions

explicites, th_se de doctorat, Uni-

versit@ Paris VII, 1993.

[55] J. A. ROBINSON, A Machine-oriented

Logic Based on the Resolution Principle, Journal of the ACM,

12 (1965), pp. 23-41.
[56] K. H. ROSE, Explicit Substitution

- Tutorial _ Survey, BRICS, Lecture Series LS-96-3, Department

of

Computer Science, University of Aarhus, 1996.
[57] W. SNYDER AND J. GALLIER, Higher-order Unification

Revisited:

Complete Sets of Transformations,

Journal of Symbolic Computation,
[58] A. N. WHITEHEAD AND B. RUSSELL,

8 (1989), pp. 101-140. Principia Mathematica,

Cambridge

University Press, Cambridge,

revised ed., 1925-1927. Three volumes. The first edition was published 1910-1913.

22

REPORT

DOCUMENTATION

PAGE

Form Approved OMB No. 0704-0188

Public reporting burden for this collection of information is estimated to average 1 hour per response, including the time for reviewing instructions, searching existing data sources, gathering and maintaining the data needed, and completing and reviewing the collection of information. Send comments regarding this burden estimate or any other aspect of this collection of information, including suggestions for reducing this burden, to Washington Headquarters Services, Directorate for Information Operations and Reports, 1215 Jefferson
Davis Highway, Suite 1204, Arlington, VA 22202-4302, and to the Office of Management and Budget, Paperwork Reduction Project (0704-0188), Washington, DC 20503.

1. AGENCY

USE ONLY(Leave

blank)

2. REPORT DATE
November 2000

3. REPORT TYPE AND DATES
Contractor Report

COVERED

4. TITLE AND SUBTITLE
Explicit substitutions

and all that

5. FUNDING

NUMBERS

C NAS1-97046 WU 505-90-52-01

6. AUTHOR(S) Mauricio Ayala-Rincdn

and C_sar Mufioz

7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) ICASE
Mail Stop 132C NASA Langley Research Center Hampton, VA 23681-2199

9. SPONSORING/MONITORING National Aeronautics and Langley Research Center Hampton, VA 23681-2199

AGENCY NAME(S) AND ADDRESS(ES) Space Administration

8. PERFORMING

ORGANIZATION

REPORT NUMBER

ICASE Report No. 2000-45

10. SPONSORING/MONITORING AGENCY REPORT NUMBER
NASA/CR-2000-210621 ICASE Report No. 2000-45

11. SUPPLEMENTARY

NOTES

Langley Technical Monitor: Final Report To appear in the Colombian

Dennis M. Bushnell Journal of Computation.

12a. DISTRIBUTION/AVAILABILITY

STATEMENT

12b. DISTRIBUTION

CODE

Unclassified-Unlimited

Subject Category 60, 61

Distribution:

Nonstandard

Availability: NASA-CASI

(301) 621-0390

13. ABSTRACT

(Maximum 200 words)

Explicit substitution calculi are extensions of the )_-calculus where the substitution mechanism is internalized into

the theory. This feature makes them suitable for implementation

and theoretical study of logic-based tools such as

strongly typed programming languages and proof assistant systems. In this paper we explore new developments on

two of the most successful styles of explicit substitution calculi: the )_cr- and )_Se-Calculi.

14. SUBJECT

TERMS

explicit substitution,

higher order unification, lambda-calculus,

type theory, rewriting

17. SECURITY

CLASSIFICATION

OF REPORT
Unclassified

NSN 7540-01-280-5500

18. SECURITY

CLASSIFICATIOI_

OF THIS PAGE
Unclassified

19. SECURITY

CLASSIFICATION

OF ABSTRACT

15. NUMBER

OF PAGES

27

16. PRICE CODE
A03

20. LIMITATION OF ABSTRACT

Standard Form 298(Rev. 2-89)
Prescribed by ANSI Std. Z39-18 298-102

