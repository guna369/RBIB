UNIVERSIDADE DE BRASIÂ´LIA
INSTITUTO DE CIEË†NCIAS EXATAS
DEPARTAMENTO DE MATEMAÂ´TICA
FormalizacÂ¸aËœo da Prova do Teorema de ExisteË†ncia de
Unificadores Mais Gerais em Teorias de
Primeira-Ordem
Por
AndreÂ´ia Borges Avelar
BrasÂ´Ä±lia
2009
UNIVERSIDADE DE BRASIÂ´LIA
INSTITUTO DE CIEË†NCIAS EXATAS
DEPARTAMENTO DE MATEMAÂ´TICA
FormalizacÂ¸aËœo da Prova do Teorema de ExisteË†ncia de
Unificadores Mais Gerais em Teorias de
Primeira-Ordem
Por
AndreÂ´ia Borges Avelar1
Orientador: Prof. Dr. Mauricio Ayala RincoÂ´n
Coorientador: Prof. Dr. AndreÂ´ Luiz Galdino
1O autor contou com o apoio financeiro do CNPq.
A HeÂ´lio, AnteÂ´ria e Elaine.
A Sabedoria eÂ´ mais moÂ´vel que qualquer movimento
e, por sua pureza, tudo atravessa e penetra.
As virtudes saËœo seus frutos;
ela ensina a temperancÂ¸a e a prudeË†ncia,
a justicÂ¸a e a fortaleza,
que saËœo, na vida, os bens mais uÂ´teis aos homens.
Sb 7,24; 8,7b
Agradecimentos
AgradecÂ¸o a Deus por ter me concedido forcÂ¸as para concluir este trabalho, consolo nos momentos
difÂ´Ä±ceis, coragem e equilÂ´Ä±brio para vencer os obstaÂ´culos.
AgradecÂ¸o a` minha famÄ±Â´lia, toda a compreensaËœo e apoio, que sem duÂ´vida foram fundamentais
para a conclusaËœo deste trabalho.
AgradecÂ¸o de maneira especial ao meu orientador, Prof. Mauricio Ayala RincoÂ´n, por que foi
paciente, me concedeu um voto de confiancÂ¸a, foi um excelente orientador e amigo.
AgradecÂ¸o ao meu coorientador, Prof. AndreÂ´ Luiz Galdino, a grande ajuda durante a reali-
zacÂ¸aËœo deste trabalho e as valiosas dicas.
AgradecÂ¸o os Profs. FlaÂ´vio e MaÂ´rio Benevides, as valiosas sugestoËœes durante a correcÂ¸aËœo deste
trabalho.
AgradecÂ¸o ao Prof. CeÂ´lius, as conversas animadoras e por muitas vezes ter sido um amigo
que soube ouvir.
AgradecÂ¸o a Prof. CaÂ´tia, porque tambeÂ´m acreditou que eu seria capaz de concluir este trabalho
e me deu o seu apoio.
AgradecÂ¸o ao amigo Martins e a` amiga Luciene, que me concederam um apoio importante
nos momentos mais difÂ´Ä±ceis.
Aos amigos JoaËœo Marcelo e JoaËœo VÄ±Â´tor, a companhia e incentivo durante os estudos para o
exame de qualificacÂ¸aËœo.
AgradecÂ¸o ao amigo Vagner e a` amiga FlaÂ´via, o apoio, as conversas descontraÂ´Ä±das e a com-
panhia taËœo agradaÂ´vel que tornou os estudos das mateÂ´rias que fizemos juntos muito mais faÂ´ceis.
AgradecÂ¸o ao amigo Wagner, porque sempre acreditou que eu concluiria este trabalho e foi
um grande incentivador.
AgradecÂ¸o a` amiga Thaynara, a companhia taËœo alegre que foi muito motivadora nos momentos
conclusivos deste trabalho.
Aos amigos Daniel, Daniele, Leonardo, FaÂ´bio, Ana Cristina e Kaliana, que tameÂ´m estiveram
presentes nos uÂ´ltimos meses e com os quais passei momentos muito agradaÂ´veis.
Por fim, agradecÂ¸o a todos os amigos, professores e funcionaÂ´rios do Departamento de Mate-
maÂ´tica da UnB, que de alguma forma contribuÂ´Ä±ram para a finalizacÂ¸aËœo deste trabalho.
Resumo
Neste trabalho apresenta-se uma formalizacÂ¸aËœo do teorema de existeË†ncia de unificadores
mais gerais em teorias de primeira ordem. Tal formalizacÂ¸aËœo foi desenvolvida na linguagem
de especificacÂ¸aËœo de ordem superior, do assistente de prova PVS. A prova mecaË†nica eÂ´ muito
semelhante a`s provas encontradas em livros-texto, as quais se baseiam na correcÂ¸aËœo do jaÂ´
conhecido algoritmo de unificacÂ¸aËœo de Robinson de primeira ordem. A prova do teorema foi
aplicada dentro de uma teoria completa, desenvolvida em PVS, para sistemas de reescrita
de termos, a fim de obter uma formalizacÂ¸aËœo completa do Teorema dos Pares CrÂ´Ä±ticos de
Knuth-Bendix. Para chegar a esta formalizacÂ¸aËœo foi construÂ´Ä±da uma especificacÂ¸aËœo em PVS
de uma teoria para unificacÂ¸aËœo de primeira ordem, onde foram formalizadas as propriedades
de generalidade e terminacÂ¸aËœo de uma versaËœo do algoritmo de unificacÂ¸aËœo de Robinson
restrito a termos unificaÂ´veis.
Palavras-chave: VerificacÂ¸aËœo formal, unificacÂ¸aËœo de primeira ordem, unificador mais geral,
PVS.
vi
Abstract
This work presents the formalization of the theorem of existence of most general unifiers
in first-order theories. The formalization was developed in the higher-order specification
language, of the proof assistant PVS. The mechanical proof is very similar to that found
in textbooks, which are based on proving the correction of the well-known Robinsonâ€™s
first-order unification algorithm. The proof of the theorem was applied within a complete
theory, also developed in PVS, for term rewriting systems in order to obtain the full
formalization of the Knuth-Bendix Critical Pair theorem. To reach this formalization, it
was build in PVS a specification of a theory for first-order unification, where properties of
generality and termination of a version of the Robinsonâ€™s unification algorithm restricted
to unifiable terms were formalized.
Keywords: Formal verification, first-order unification, most general unifier, PVS.
vii
Lista de Tabelas
4.2.1 Construtor resolving_diff . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
4.2.2 Construtor sub_of_frst_diff . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
4.2.3 Construtor unification_algorithm . . . . . . . . . . . . . . . . . . . . . . . . 47
4.2.4 Lemas sobre resolving_diff . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
4.2.5 Lemas sobre sub_of_frst_diff . . . . . . . . . . . . . . . . . . . . . . . . . . 50
4.2.6 Principais lemas sobre sub_of_frst_diff . . . . . . . . . . . . . . . . . . . . . . 51
4.2.7 Lemas sobre unification_algorithm . . . . . . . . . . . . . . . . . . . . . . . . 52
5.0.1 AnaÂ´lise Quantitativa da sub-teoria unification . . . . . . . . . . . . . . . . . . . 93
viii
Lista de Figuras
2.2.1 Algoritmo de unificacÂ¸aËœo de Robinson . . . . . . . . . . . . . . . . . . . . . . . . 14
2.2.2 VersaËœo do algoritmo de unificacÂ¸aËœo de Robinson . . . . . . . . . . . . . . . . . . . . 15
4.1.1 Estrutura hieraÂ´rquica da sub-teoria unification . . . . . . . . . . . . . . . . . . 44
4.3.1 AÂ´rvore de prova do teorema unification. . . . . . . . . . . . . . . . . . . . . . . 54
4.4.1 InÂ´Ä±cio da aÂ´rvore de prova do lema unification_algorithm_gives_unifier . . . . . . 58
4.4.2 Ramo principal da aÂ´rvore de prova do lema unification_algorithm_gives_unifier . 60
4.4.3 InÂ´Ä±cio da aÂ´rvore de prova do lema unification_algorithm_gives_mg_subs . . . . . . 65
4.4.4 Parte da aÂ´rvore de prova do lema unification_algorithm_gives_mg_subs . . . . . . 67
4.4.5 Parte da aÂ´rvore de prova do lema unification_algorithm_gives_mg_subs . . . . . . 72
4.5.1 InÂ´Ä±cio da aÂ´rvore de prova do lema vars_ext_sub_of_frst_diff_decrease . . . . . . 76
4.5.2 Parte da aÂ´rvore de prova do lema vars_ext_sub_of_frst_diff_decrease . . . . . . 78
4.5.3 Parte da aÂ´rvore de prova do lema vars_ext_sub_of_frst_diff_decrease . . . . . . 80
4.5.4 InÂ´Ä±cio da aÂ´rvore de prova do lema sub_of_frst_diff_unifier_o . . . . . . . . . . . 82
4.5.5 Parte final da aÂ´rvore de prova do lema sub_of_frst_diff_unifier_o . . . . . . . . 85
4.5.6 Parte final da aÂ´rvore de prova do lema sub_of_frst_diff_unifier_o . . . . . . . . 88
ix
IÂ´ndice
Resumo vi
Abstract vii
Lista de Tabelas viii
Lista de Figuras ix
1 IntroducÂ¸aËœo 1
1.1 MotivacÂ¸aËœo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 OrganizacÂ¸aËœo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
2 UnificacÂ¸aËœo de Primeira Ordem 4
2.1 UnificacÂ¸aËœo: VisaËœo Informal do Problema, HistoÂ´ria e AplicacÂ¸oËœes . . . . . . . . . . 4
2.1.1 VisaËœo Informal do Problema de UnificacÂ¸aËœo . . . . . . . . . . . . . . . . . . 4
2.1.2 HistoÂ´ria e AplicacÂ¸oËœes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
2.2 O Problema de UnificacÂ¸aËœo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.2.1 Assinaturas, Termos e SubstituicÂ¸oËœes . . . . . . . . . . . . . . . . . . . . . 8
2.2.2 O Problema de UnificacÂ¸aËœo e as SubstituicÂ¸oËœes mais Gerais . . . . . . . . . 12
2.2.3 O Algoritmo de UnificacÂ¸aËœo . . . . . . . . . . . . . . . . . . . . . . . . . . 14
x
xi
3 SemaË†ntica do PVS 26
3.1 A Linguagem de EspecificacÂ¸aËœo do PVS . . . . . . . . . . . . . . . . . . . . . . . . 26
3.2 O Assistente de Provas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
3.3 A Checagem de Tipos em PVS . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
3.4 As Regras de Prova do PVS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
3.4.1 Regras Estruturais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
3.4.2 Regra de Corte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.4.3 Regras para Axiomas Proposicionais . . . . . . . . . . . . . . . . . . . . . 33
3.4.4 Regras de Contexto . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.4.5 Regras Condicionais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.4.6 Regras de Igualdade . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
3.4.7 Regras de Igualdade Booleana . . . . . . . . . . . . . . . . . . . . . . . . 35
3.4.8 Regras de ReducÂ¸aËœo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
3.4.9 Regras de Extensionalidade . . . . . . . . . . . . . . . . . . . . . . . . . . 36
3.4.10 Regra de RestricÂ¸aËœo de Tipo . . . . . . . . . . . . . . . . . . . . . . . . . . 36
3.5 Sub-teorias da Teoria TRS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
3.5.1 A Sub-teoria term . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
3.5.2 A Sub-teoria positions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
3.5.3 A Sub-teoria subterm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
3.5.4 A Sub-teoria substitution . . . . . . . . . . . . . . . . . . . . . . . . . . 41
4 FormalizacÂ¸aËœo da Teoria de UnificacÂ¸aËœo 43
4.1 Estrutura HieraÂ´rquica da Teoria unification . . . . . . . . . . . . . . . . . . . . 43
4.2 OrganizacÂ¸aËœo da Teoria unification . . . . . . . . . . . . . . . . . . . . . . . . . 44
4.3 FormalizacÂ¸aËœo do Teorema Sobre a ExisteË†ncia de mguâ€™s . . . . . . . . . . . . . . . 53
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm . . . . . . 57
4.4.1 Lema unification_algorithm_gives_unifier . . . . . . . . . . . . . . 58
4.4.2 Lema unification_algorithm_gives_mg_subs . . . . . . . . . . . . . . 65
xii
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff . . 74
4.5.1 Lema vars_ext_sub_of_frst_diff_decrease . . . . . . . . . . . . . . . 75
4.5.2 Lema sub_of_frst_diff_unifier_o . . . . . . . . . . . . . . . . . . . . 81
4.5.3 Lema ext_sub_of_frst_diff_unifiable . . . . . . . . . . . . . . . . . . 89
5 ConclusaËœo e Trabalhos Futuros 92
5.1 Trabalhos Relacionados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
5.2 Trabalhos Futuros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
A O CoÂ´digo da EspecificacÂ¸aËœo 97
B FormalizacÂ¸aËœo do lema sub_of_frst_diff_remove_x 103
RefereË†ncias BibliograÂ´ficas 113
CapÂ´Ä±tulo 1
IntroducÂ¸aËœo
Neste trabalho apresentamos uma especificacÂ¸aËœo no assistente de prova PVS, de uma ver-
saËœo do algoritmo de unificacÂ¸aËœo de Robinson, bem como a formalizacÂ¸aËœo da correcÂ¸aËœo deste
algoritmo. Como resultado da correcÂ¸aËœo do algoritmo, formaliza-se um teorema que esta-
belece a existeË†ncia de unificadores mais gerais para dois termos unificaÂ´veis, em sistemas de
primeira ordem. Para este resultado, jaÂ´ bem estabelecido em computacÂ¸aËœo, encontramos
vaÂ´rias aplicacÂ¸oËœes em loÂ´gica computacional, que vaËœo deste a completude do princÂ´Ä±pio de
resolucÂ¸aËœo de primeira ordem [26] a` correcÂ¸aËœo do procedimento de completacÂ¸aËœo de Knuth-
Bendix [14] para sistemas de reescrita de termos, aleÂ´m de aplicacÂ¸oËœes em linguagens de
programacÂ¸aËœo, como mecanismos de infereË†ncia de tipos. Esta especificacÂ¸aËœo/formalizacÂ¸aËœo
consiste de um desenvolvimento de uma teoria em PVS a qual denominamos unification.
1.1 MotivacÂ¸aËœo
O desenvolvimento de uma teoria em PVS para tratar da existeË†ncia de unificadores mais
gerais foi motivado pela formalizacÂ¸aËœo de uma biblioteca em PVS para sistemas de reescrita
de termos [8], a teoria trs, em que o resultado que estabelece a existeË†ncia e unicidade de
unificadores mais gerais era tratado como um axioma.
A teoria trs foi desenvolvida com o objetivo de fornecer uma formalizacÂ¸aËœo de conceitos
baÂ´sicos, atraveÂ´s dos quais fosse possÂ´Ä±vel especificar e formalizar outros conceitos e resulta-
dos da teoria de sistemas de reescrita de termos. Contudo a teoria trs estava incompleta,
no sentido de que possuia um resultado naËœo formalizado. Assim, o objetivo inicial deste
1
1.2 OrganizacÂ¸aËœo 2
trabalho foi o de obter uma formalizacÂ¸aËœo de um teorema que garantisse a existeË†ncia de
unificadores mais gerais para termos de primeira ordem e com isto ter uma teoria em
PVS para sistemas de reescrita de termos completa. Com este objetivo foi realizado o
desenvolvimento da sub-teoria unification.
A teoria trs eÂ´ composta por um conjunto de sub-teorias. Assim, para chegar a uma
formalizacÂ¸aËœo do teorema que estabelece a existeË†ncia de unificadores mais gerais a teoria
unification foi desenvolvida como uma sub-teoria da teoria trs. Isto significa que a
sub-teoria unification importa algumas sub-teorias da teoria trs, onde encontramos
especificacÂ¸oËœes de conceitos baÂ´sicos, como por exemplo as definicÂ¸oËœes de termos, posicÂ¸oËœes,
substituicÂ¸oËœes, etc., e a formalizacÂ¸aËœo de vaÂ´rios resultados. Assim, nas teorias importadas
encontramos uma base teoÂ´rica completa para o desenvolvimento de uma teoria sobre
unificacÂ¸aËœo.
1.2 OrganizacÂ¸aËœo
No decorrer desta apresentacÂ¸aËœo quando usamos a palavra teoria ou sub-teoria em itaÂ´lico,
estamos nos referindo a` especificacÂ¸aËœo de uma teoria desenvolvida no assistente de prova
PVS, e quando usamos formalizacÂ¸aËœo estamos nos referindo a` prova mecaË†nica feita em
PVS de algum resultado ou teorema.
No CapÂ´Ä±tulo 2 apresentamos a teoria de unificacÂ¸aËœo de primeira ordem, que envolve
a introducÂ¸aËœo e definicÂ¸aËœo de conceitos tratados em unificacÂ¸aËœo como termos, substituicÂ¸oËœes,
unificadores mais gerais, etc., aleÂ´m de apresentarmos uma versaËœo do algoritmo de uni-
ficacÂ¸aËœo de Robinson, para em seguida verificar analiticamente a correcÂ¸aËœo e completude
deste algoritmo. No CapÂ´Ä±tulo 3 apresentamos uma visaËœo geral da semaË†ntica do assistente
de prova PVS, e expomos as especificacÂ¸oËœes, feitas anteriormente em PVS no trabalho de
Galdino e Ayala-RincoÂ´n [8], dos conceitos e definicÂ¸oËœes apresentados no CapÂ´Ä±tulo 2. No
CapÂ´Ä±tulo 4 apresentamos a organizacÂ¸aËœo da teoria unification, os principais aspectos da
especificacÂ¸aËœo e a formalizacÂ¸aËœo dos teoremas da teoria, que saËœo aqueles onde verificamos a
correcÂ¸aËœo do algoritmo de unificacÂ¸aËœo e a existeË†ncia de unificadores mais gerais para termos
unificaÂ´veis, aleÂ´m destes apresentamos a formalizacÂ¸aËœo de alguns lemas importantes para a
1.2 OrganizacÂ¸aËœo 3
verificacÂ¸aËœo da correcÂ¸aËœo do algoritmo. Em seguida, apresentamos a conclusaËœo e trabalhos
futuros, aleÂ´m de alguns trabalhos relacionados. No ApeË†ndice A, apresentamos o coÂ´digo da
especificacÂ¸aËœo da sub-teoria unification, mas o seu desenvolvimento completo encontra-
se disponÂ´Ä±vel em http://ayala.mat.unb.br/publications.html, juntamente com a teoria
trs. No ApeË†ndice B, apresentamos um exemplo de uma formalizacÂ¸aËœo detalhada de um
dos lemas da sub-teoria unification.
Acreditamos que esta seja a primeira formalizacÂ¸aËœo completa de uma teoria em PVS
para unificacÂ¸aËœo de primeira ordem.
CapÂ´Ä±tulo 2
UnificacÂ¸aËœo de Primeira Ordem
O problema de unificacÂ¸aËœo tem sido estudado em vaÂ´rias aÂ´reas da cieË†ncia da computacÂ¸aËœo,
incluindo deducÂ¸aËœo automaÂ´tica, programacÂ¸aËœo loÂ´gica, complexidade computacional, entre
outras. Neste capÂ´Ä±tulo apresentamos o conceito de unificacÂ¸aËœo de uma maneira informal,
seguimos expondo um levantamento histoÂ´rico e algumas aplicacÂ¸oËœes mostrando onde o
problema de unificacÂ¸aËœo foi originalmente introduzido, e entaËœo finalizamos apresentando o
problema de unificacÂ¸aËœo de maneira formal.
2.1 UnificacÂ¸aËœo: VisaËœo Informal do Problema, HistoÂ´-
ria e AplicacÂ¸oËœes
2.1.1 VisaËœo Informal do Problema de UnificacÂ¸aËœo
UnificacÂ¸aËœo eÂ´ um processo fundamental sobre o qual vaÂ´rios meÂ´todos de deducÂ¸aËœo automaÂ´-
tica saËœo baseados. A teoria que envolve o problema de unificacÂ¸aËœo surge da necessidade de
formalizar aplicacÂ¸oËœes especÂ´Ä±ficas deste processo. Esta teoria proveË† definicÂ¸oËœes para nocÂ¸oËœes
importantes como instanciacÂ¸aËœo, termos unificaÂ´veis, unificadores mais gerais, etc., inves-
tiga propriedades destas nocÂ¸oËœes, aleÂ´m de buscar e analizar algoritmos de unificacÂ¸aËœo que
podem ser utilizados em vaÂ´rios contextos.
Em muitas aplicacÂ¸oËœes de unificacÂ¸aËœo o interesse naËœo estaÂ´ apenas em responder o pro-
blema de decisaËœo para unificacÂ¸aËœo, isto eÂ´, dizerâ€œsimâ€ouâ€œnaËœoâ€para responder se dois termos
s e t saËœo unificaÂ´veis. Se estes dois termos saËœo unificaveÂ´is, busca-se tambeÂ´m uma solucÂ¸aËœo,
isto eÂ´, uma substituicÂ¸aËœo que torne estes dois termos ideË†nticos. Tal substituicÂ¸aËœo eÂ´ chamada
4
2.1 UnificacÂ¸aËœo: VisaËœo Informal do Problema, HistoÂ´ria e AplicacÂ¸oËœes 5
um unificador de s e t. Em geral um problema de unificacÂ¸aËœo pode ter vaÂ´rias solucÂ¸oËœes, mas
felizmente nas vaÂ´rias aplicacÂ¸oËœes de unificacÂ¸aËœo, o interesse naËœo estaÂ´ em encontrar todos os
unificadores para um determinado problema, mas sim em determinar um unificador mais
geral, isto eÂ´, um unificador a partir do qual obtem-se todos os outros por instanciacÂ¸aËœo.
Exemplo 2.1.1: Considere os termos f(x, y) e f(y, x). Note que estes dois termos podem
ser unificados substituindo-se x e y pelo mesmo termo s, e como existe uma infinidade de
termos possÂ´Ä±veis, temos que este problema possui infinitas solucÂ¸oËœes. Contudo a substitui-
cÂ¸aËœo dada por Î¸ := {x/y} eÂ´ um unificador mais geral do problema, visto que para qualquer
termo s, temos que {x/s, y/s} = {y/s} â—¦ Î¸.
Portanto, um algoritmo de unificacÂ¸aËœo naËœo deve responder apenas se um dado problema
de unificacÂ¸aËœo tem ou naËœo solucÂ¸aËœo, aleÂ´m disso, se espera que o algoritmo compute um
unificador mais geral para o problema.
AteÂ´ este ponto falamos apenas de unificacÂ¸aËœo sintaÂ´tica de termos de primeira ordem,
isto significa que os termos devem ser sintaticamente iguais e que naËœo temos variaÂ´veis de
segunda ordem, isto eÂ´, variaÂ´veis para funcÂ¸oËœes. Por exemplo, os termos f(x, y) e h(x, y) ob-
viamente naËœo podem ser sintaticamente iguais em unificacÂ¸aËœo de primeira ordem, contudo
se H eÂ´ uma variaÂ´vel de segunda ordem, os termos f(x, y) e H(x, y) podem ser sintati-
camente iguais, via substituicÂ¸oËœes, em unificacÂ¸aËœo de segunda ordem. Mas neste trabalho
estamos interessados apenas em unificacÂ¸aËœo de primeira ordem.
2.1.2 HistoÂ´ria e AplicacÂ¸oËœes
Baseamos esta secÂ¸aËœo nos surveys de Knight [13] e de Baader e Snyder [3], que utilizamos
como fonte para as refereË†ncias bibliograÂ´ficas que citamos.
Em 1930, Jacques Herbrand [10] apresentou em sua tese de doutorado um algoritmo
naËœo determinÂ´Ä±stico para computar um unificador de dois termos. Mas foi em 1965, que o
nome unificacÂ¸aËœo e a primeira investigacÂ¸aËœo formal sobre o assunto aparecem no trabalho de
Robinson [26], que introduziu unificacÂ¸aËœo como sendo a operacÂ¸aËœo baÂ´sica para o seu princÂ´Ä±pio
de resolucÂ¸aËœo, mostrando que termos unificaÂ´veis possuem um unificador mais geral; aleÂ´m
de descrever um algoritmo, veja Figura 2.2.1, para computar tal unificador e provar que
2.1 UnificacÂ¸aËœo: VisaËœo Informal do Problema, HistoÂ´ria e AplicacÂ¸oËœes 6
este algoritmo de fato computa um unificador mais geral para um conjunto unificaÂ´vel
de expressoËœes bem formadas. Em 1964, Jim Guard [9] estudava independentemente o
problema de unificacÂ¸aËœo sob o nome de matching e cinco anos depois, em 1970, Reynolds
[25] discutiu termos de primeira ordem usando teoria de reticulado e mostrou que tambeÂ´m
existe uma uÂ´nica generalizacÂ¸aËœo mais especÂ´Ä±fica de quaisquer dois termos unificaÂ´veis. Em
1970, segundo Baader e Snyder [3], as nocÂ¸oËœes de unificacÂ¸aËœo e unificador mais geral foram
independentemente reinventadas por Knuth e Bendix [14] como uma ferramenta para
testar conflueË†ncia local de sistemas de reescrita de termos atraveÂ´s de pares crÂ´Ä±ticos.
A versaËœo original do algoritmo de unificacÂ¸aËœo de Robinson eÂ´ ineficiente, pois eÂ´ expo-
nencial em tempo de execucÂ¸aËœo e em espacÂ¸o. Por isso surgiu um grande interesse em
obter algoritmos de unificacÂ¸aËœo eficientes. O proÂ´prio Robinson passou a pesquisar sobre a
eficieË†ncia na unificacÂ¸aËœo, e argumentou em [27] que uma representacÂ¸aËœo mais concisa para
os termos era necessaÂ´ria. Com sua nova formulacÂ¸aËœo, Robinson conseguiu uma grande
melhoria na complexidade de espacÂ¸o exigida por seu algoritmo de unificacÂ¸aËœo.
Assim, em pesquisas sobre complexidade computacional, surgem vaÂ´rios trabalhos em
busca de eficieË†ncia no processo de unificacÂ¸aËœo. Em 1972, Boyer e Moore [4] apresentam
um algoritmo de unificacÂ¸aËœo que divide a estrutura dos termos, este algoritmo era eficiente
em espacÂ¸o, mas ainda exponencial em tempo de execucÂ¸aËœo. Em 1975, Venturini-Zilli [31]
consegue reduzir a complexidade de tempo do algoritmo de unificacÂ¸aËœo de Robinson para
tempo quadraÂ´tico. Em 1976, no seu trabalho sobre unificacÂ¸aËœo de ordem superior [11], Huet
apresenta um procedimento baseado em classes de equivaleË†ncia de subtermos, que era
quase linear em tempo de execucÂ¸aËœo. Ainda em 1976, Paterson e Wegman [23], descobrem
um algoritmo de unificacÂ¸aËœo realmente linear, baseado sobre um meÂ´todo que consistia
na propagacÂ¸aËœo da relacÂ¸aËœo de classes de equivaleË†ncia do algoritmo de Huet. Em 1976,
Martelli e Montanari [16], independentemente descobrem outro algoritmo de unificacÂ¸aËœo
linear. Eles chegam a este algoritmo a partir da estrutura de termos proposta por Boyer
e Moore. Mas soÂ´ em [17], no ano de 1982, eÂ´ que Martelli e Montanari apresentam uma
descricÂ¸aËœo completa de um algoritmo de unificacÂ¸aËœo eficiente, mas este uÂ´ltimo algoritmo naËœo
era realmente linear. Em 1983, Corbin e Bidoit [5] reabilitam o algoritmo de unificacÂ¸aËœo
de Robinson usando novas estruturas de dados. Eles conseguem reduzir a complexidade
2.1 UnificacÂ¸aËœo: VisaËœo Informal do Problema, HistoÂ´ria e AplicacÂ¸oËœes 7
de tempo do algoritmo de Robinson, que era exponencial, para O(n2), e afirmam que o
algoritmo eÂ´ mais simples que o proposto por Martelli e Montanari aleÂ´m de ser superior
na praÂ´tica.
O algoritmo de unificacÂ¸aËœo de Robinson usa a representacÂ¸aËœo de termos em loÂ´gica de
primeira ordem dados por uma sequeË†ncia de sÂ´Ä±mbolos, que eÂ´ uma representacÂ¸aËœo bastante
simples, onde os termos podem ser vistos como um arranjo linear. Esta representacÂ¸aËœo
por sequeË†ncia de sÂ´Ä±mbolos eÂ´ equivalente a` representacÂ¸aËœo por aÂ´rvores. Mas este tipo de
representacÂ¸aËœo eÂ´ mais uÂ´til quando os termos naËœo assumem formas muito complicadas. De
fato, nesta representacÂ¸aËœo pode ser necessaÂ´rio gerar estruturas de termos exponencialmente
grandes durante o processo de unificacÂ¸aËœo.
No sentido de contornar este problema, alguns algoritmos de unificacÂ¸aËœo usam uma
representacÂ¸aËœo de termos por grafos, chamamos esta representacÂ¸aËœo de grafo acÂ´Ä±clico direto,
ou pela sigla em ingleË†s DAG, como eÂ´ mais comumente chamada. Esta abordagem dos
termos contorna o problema de duplicacÂ¸aËœo de subtermos gerado por substituicÂ¸oËœes, atraveÂ´s
de uma representacÂ¸aËœo por grafos que podem dividir estruturas. Em tal representacÂ¸aËœo,
todos os veÂ´rtices do grafo saËœo rotulados. A ideÂ´ia central eÂ´ naËœo permitir que subtermos
ideË†nticos aparecÂ¸am em posicÂ¸oËœes distintas de um termo. Isto eÂ´ feito atraveÂ´s de uma atuali-
zacÂ¸aËœo de ponteiros, que passam a indicar um outro subtermo depois de uma instanciacÂ¸aËœo.
Podemos ter mais de um ponteiro direcionado para uma mesma estrututra, isto consiste
em dividir estruturas. Um algoritmo que utiliza tal estrutura de dados, necessita de uma
estrutura adicional para ponteiros que ligam a cada variaÂ´vel um termo que seja sua ins-
taË†ncia por uma substituicÂ¸aËœo. Com esta representacÂ¸aËœo para termos, a complexidade do
algoritmo passa a ser quadraÂ´tica. De fato, Corbin e Bidoit utilizam esta representacÂ¸aËœo
para os termos, a fim de reduzir a complexidade de tempo do algoritmo de unificacÂ¸aËœo de
Robinson para tempo quadraÂ´tico.
2.2 O Problema de UnificacÂ¸aËœo 8
2.2 O Problema de UnificacÂ¸aËœo
Nesta secÂ¸aËœo apresentamos o problema de unificacÂ¸aËœo analiticamente, isto eÂ´, expomos uma
anaÂ´lise algeÂ´brica do problema, primeiro introduzindo as definicÂ¸oËœes e a notacÂ¸aËœo que utiliza-
mos para tratar do problema de unificacÂ¸aËœo, em seguida definimos o problema de unificacÂ¸aËœo
em si, para entaËœo apresentar a versaËœo do algoritmo de unificacÂ¸aËœo de Robinson que utiliza-
mos na formalizacÂ¸aËœo proposta por este trabalho. ConcluÂ´Ä±mos provando analiticamente a
correcÂ¸aËœo deste algoritmo. Na apresentacÂ¸aËœo desta secÂ¸aËœo, utilizamos as notacÂ¸oËœes e definicÂ¸oËœes
de [2] e de [1].
2.2.1 Assinaturas, Termos e SubstituicÂ¸oËœes
Nas secÂ¸oËœes anteriores jaÂ´ temos introduzido alguns elementos presentes na teoria que en-
volve o problema de unificacÂ¸aËœo, sem definÂ´Ä±-los formalmente. Alguns destes elementos, saËœo
o que chamamos de termos, substituicÂ¸oËœes, unificadores, por exemplo. Passemos agora a
uma definicÂ¸aËœo formal destes elementos. Primeiro introduzimos a seguinte notacÂ¸aËœo para
variaÂ´veis, constantes e sÂ´Ä±mbolos de funcÂ¸aËœo:
â€¢ VariaÂ´veis: {u, v, w, x, y, z},
â€¢ Constantes: {a, b, c},
â€¢ SÂ´Ä±mbolos de funcÂ¸aËœo: {f, g, h}.
Os termos saËœo construÂ´Ä±dos a partir de sÂ´Ä±mbolos de funcÂ¸aËœo, associados a um natural n
que representa a sua aridade, e variaÂ´veis. Por exemplo, se g eÂ´ um sÂ´Ä±mbolo de funcÂ¸aËœo de
aridade 3 e u, v e w saËœo variaÂ´veis, entaËœo g(u, v, w) eÂ´ um termo. EntaËœo, antes de definirmos
formalmente o que eÂ´ um termo, vamos introduzir a nocÂ¸aËœo de assinatura.
DefinicÂ¸aËœo 2.2.1: Uma assinatura Î£ eÂ´ um conjunto de sÂ´Ä±mbolos de funcÂ¸aËœo, onde a
cada f âˆˆ Î£ eÂ´ associado a um nuÂ´mero natural n, que chamamos a aridade de f . Para cada
n > 0, denotamos o conjunto de todos os elementos n-aÂ´rios de Î£ por Î£n. Os elementos
de Î£0 saËœo sÂ´Ä±mbolos de constante, isto eÂ´, as constantes saËœo funcÂ¸oËœes com aridade 0.
2.2 O Problema de UnificacÂ¸aËœo 9
Por exemplo, se queremos considerar um grupo G, que eÂ´ um conjunto naËœo vazio de
elementos, munido de uma operacÂ¸aËœo binaÂ´ria associativa, que chamamos de produto; de
uma operacÂ¸aËœo unaÂ´ria para denotar o inverso de um elemento de G; aleÂ´m do elemento
neutro, usamos a seguinte assinatura: Î£G := {e, i, f}, onde e eÂ´ uma constante, isto eÂ´,
uma funcÂ¸aËœo de aridade 0, que denota o elemento neutro, i eÂ´ um sÂ´Ä±mbolo de funcÂ¸aËœo unaÂ´rio
e f eÂ´ um sÂ´Ä±mbolo de funcÂ¸aËœo binaÂ´rio.
Tendo em maËœos a definicÂ¸aËœo de assinatura, podemos agora definir o que vem a ser um
termo. Lembrando que estamos tratando sempre de termos de primeira ordem. A nocÂ¸aËœo
de termo eÂ´ definida recursivamente da seguinte forma:
DefinicÂ¸aËœo 2.2.2: Seja Î£ uma assinatura e V um conjunto de variaÂ´veis, entaËœo o conjunto
T (Î£,V) de todos os Î£-termos, ou simplesmente termos, sobre V eÂ´ dado por:
â€¢ V âŠ‚ T (Î£,V), isto eÂ´, toda variaÂ´vel eÂ´ um termo;
â€¢ Se f âˆˆ Î£n eÂ´ um sÂ´Ä±mbolo de funcÂ¸aËœo de aridade n > 0 e t1, . . . , tn âˆˆ T (Î£,V) saËœo
termos, entaËœo f(t1, . . . , tn) âˆˆ T (Î£,V) eÂ´ um termo, isto eÂ´, para n = 0 temos que toda
constante eÂ´ um termo, e toda aplicacÂ¸aËœo de sÂ´Ä±mbolos de funcÂ¸aËœo de aridade n > 0 em
termos, eÂ´ ainda um termo.
Por exemplo, considerando a assinatura
Î£G = {e, i, f}, temos que se x, y âˆˆ G saËœo
elementos de G, entaËœo f(f(x, y), f(e, i(x))) eÂ´
um Î£G-termo, isto eÂ´, f(f(x, y), f(e, i(x))) âˆˆ
T (Î£G, G). Encontramos na representacÂ¸aËœo
por aÂ´rvores uma forma bastante praÂ´tica de
representar um termo. Para ilustrar veja
ao lado a representacÂ¸aËœo por aÂ´rvore do termo
f(f(x, y), f(e, i(x))). 221
22211211
1 2
Îµ
y i
f
f f
x
x
e
Note que na figura acima utilizamos a numeracÂ¸aËœo por sequeË†ncias de inteiros positivos
para os noÂ´s da aÂ´rvore. Com esta numeracÂ¸aËœo podemos nos referir as posicÂ¸oËœes do termo.
Veja por exemplo que o noÂ´ raiz estaÂ´ rotulado com Îµ, que na nossa notacÂ¸aËœo representa a
sequeË†ncia vazia, e se refere ao primeiro sÂ´Ä±mbolo de funcÂ¸aËœo f que aparece no termo. O
2.2 O Problema de UnificacÂ¸aËœo 10
primeiro noÂ´ a esquerda se refere ao subtermo na posicÂ¸aËœo 1 do termo principal, que eÂ´ dado
por f(x, y). A seguir, temos algumas definicÂ¸oËœes acerca de termos.
Nas definicÂ¸oËœes seguintes sejam Î£ uma assinatura, V um conjunto de variaÂ´veis e s e t
termos de T (Î£,V).
DefinicÂ¸aËœo 2.2.3: O conjunto de posicÂ¸oËœes do termo s, denotado por Pos(s), eÂ´ um con-
junto de sequeË†ncias de nuÂ´meros naturais, que eÂ´ definido indutivamente como segue:
â€¢ Se s âˆˆ V , entaËœo Pos(s) = Îµ.
â€¢ Se s = f(s1, . . . , sn), entaËœo
Pos(s) := {Îµ} âˆª
nâ‹ƒ
i=1
{ip | p âˆˆ Pos(si)}.
O comprimento de um termo s, denotado por |s|, eÂ´ a cardinalidade do conjunto Pos(s).
DefinicÂ¸aËœo 2.2.4: Para cada p âˆˆ Pos(s), o subtermo de s na posicÂ¸aËœo p, denotado por
s|p, eÂ´ definido por inducÂ¸aËœo no comprimento de p como segue:
â€¢ s|Îµ := s, para p = Îµ.
â€¢ f(s1, . . . , sn)|iq := si|q, para p = iq.
Note que, para p = iq, se p âˆˆ Pos(s), entaËœo s eÂ´ da forma f(s1, . . . , sn) com i 6 n.
DefinicÂ¸aËœo 2.2.5: O conjunto de variaÂ´veis que ocorrem em um termo s, denotado
por Vars(s), eÂ´ dado por:
Vars(s) := {x âˆˆ V | âˆƒp âˆˆ Pos(s) tal que s|p = x}.
Dizemos que p âˆˆ Pos(s) eÂ´ uma posicÂ¸aËœo de variaÂ´vel do termo s, se s|p eÂ´ uma variaÂ´vel.
Para falar de unificacÂ¸aËœo ainda precisamos introduzir a nocÂ¸aËœo de substituicÂ¸aËœo. A tÂ´Ä±tulo
de notacÂ¸aËœo, utilizaremos letras gregas minuÂ´sculas {Ïƒ, Î±, Î², . . .}, para denotar substituicÂ¸oËœes.
DefinicÂ¸aËœo 2.2.6: Seja Î£ uma assinatura e V um conjunto enumeraÂ´vel de variaÂ´veis. Uma
T(Î£,V)-substituicÂ¸aËœo, ou simplesmente substituicÂ¸aËœo, eÂ´ uma funcÂ¸aËœo Ïƒ : V â†’ T (Î£,V) tal
que:
2.2 O Problema de UnificacÂ¸aËœo 11
(a) Ïƒ(x) 6= x, somente para um nuÂ´mero finito de variaÂ´veis.
(b) O conjunto de variaÂ´veis para as quais Ïƒ(x) 6= x, eÂ´ chamado o domÄ±Â´nio de Ïƒ, e
denotado por:
Dom(Ïƒ) := {x âˆˆ V | Ïƒ(x) 6= x}.
(c) A imagem de Ïƒ eÂ´ o conjunto composto por todo termo s tal que s = Ïƒ(x) para algum
x no domÄ±Â´nio de Ïƒ. Denotamos tal conjunto por:
Ran(Ïƒ) := {Ïƒ(x) | x âˆˆ Dom(Ïƒ)}.
A substituicÂ¸aËœo Ïƒ para a qual Dom(Ïƒ) = âˆ…, isto eÂ´, Ïƒ(x) = x, âˆ€x âˆˆ V , denominamos
substituicÂ¸aËœo identidade e a denotaremos por id.
Note que, pela DefinicÂ¸aËœo 2.2.6, temos que uma substituicÂ¸aËœo tem domÄ±Â´nio finito. Assim,
podemos usar a seguinte notacÂ¸aËœo de conjunto
Ïƒ := {x1/r1, . . . , xn/rn},
para denotar uma substituicÂ¸aËœo Ïƒ cujo domÄ±Â´nio seja dado por Dom(Ïƒ) = {x1, . . . , xn} e
cuja imagem seja dada por Ran(Ïƒ) = {r1, . . . , rn}.
Observamos que uma substituicÂ¸aËœo Ïƒ pode ser extendida homeomorficamente ao con-
junto de termos T (Î£,V), por uma aplicacÂ¸aËœo ÏƒË† : T (Î£,V)â†’ T (Î£,V), da seguinte forma:
â€¢ Para s = x âˆˆ V , definimos ÏƒË†(s) := Ïƒ(x).
â€¢ Para s = f(s1, . . . , sn), definimos ÏƒË†(s) := f(ÏƒË†(s1), . . . , ÏƒË†(sn)).
No processo proposto pelo algoritmo de unificacÂ¸aËœo saËœo feitas composicÂ¸oËœes entre substi-
tuicÂ¸oËœes ateÂ´ que se chegue a uma solucÂ¸aËœo do problema. Assim, eÂ´ preciso definir o que vem
a ser composicÂ¸aËœo de substituicÂ¸oËœes.
DefinicÂ¸aËœo 2.2.7: Sejam Ïƒ := {x1/r1, . . . , xn/rn} e Î± := {y1/s1, . . . , ym/sm} substitui-
cÂ¸oËœes. EntaËœo definimos a composicÂ¸aËœo Ïƒ â—¦ Î± como sendo a substituicÂ¸aËœo:
Ïƒ â—¦ Î± := {y1/ÏƒË†(s1), . . . , yn/ÏƒË†(sn), x1/r1, . . . , xn/rn},
eliminando qualquer ligacÂ¸aËœo yj/ÏƒË†(sj), para a qual yj = ÏƒË†(sj) e qualquer ligacÂ¸aËœo xi/ri,
para a qual xi âˆˆ {y1, . . . , ym}.
2.2 O Problema de UnificacÂ¸aËœo 12
2.2.2 O Problema de UnificacÂ¸aËœo e as SubstituicÂ¸oËœes mais Gerais
AteÂ´ este ponto todas as definicÂ¸oËœes e notacÂ¸oËœes colocadas, tiveram o objetivo de preparar
a base para podermos falar do que eÂ´ o nosso principal interesse, o problema de unifica-
cÂ¸aËœo. JaÂ´ colocamos na primeira secÂ¸aËœo deste capÂ´Ä±tulo que o problema de unificacÂ¸aËœo eÂ´ mais
geralmente tratado no seguinte contexto: dados dois termos quaisquer queremos saber se
existe uma substituicÂ¸aËœo que torna os dois termos ideË†nticos e estudar formas de obter tal
substituicÂ¸aËœo bem como as propriedades matemaÂ´ticas da mesma. De maneira mais formal,
apresentamos na DefinicÂ¸aËœo 2.2.8 em que consiste o processo de unificacÂ¸aËœo envolvendo dois
termos quaisquer, mais a frente na DefinicÂ¸aËœo 2.2.10, falamos do problema de unificacÂ¸aËœo.
Note que a definicÂ¸aËœo a seguir eÂ´ construÂ´Ä±da sobre a nocÂ¸aËœo de teoria equacional, que
nada mais eÂ´ do que um conjunto de pares (s, t), onde s e t saËœo termos de T (Î£,V), tais
que s e t pertencem a uma mesma classe de equivaleË†ncia induzida por um conjunto de
Î£-identidades E em T (Î£,V). Em notacÂ¸aËœo matemaÂ´tica:
â‰ˆE:= {(s, t) âˆˆ T (Î£,V)Ã— T (Î£,V) | E  s â‰ˆ t}.
DefinicÂ¸aËœo 2.2.8: UnificacÂ¸aËœo eÂ´ o processo de resolver o seguinte problema de satisfa-
zibilidade: Dada uma teoria equacional E e dois termos s e t em T (Î£,V), encontrar
uma substituicÂ¸aËœo Ïƒ tal que ÏƒË†(s) â‰ˆE ÏƒË†(t). Dizemos que Ïƒ eÂ´ um unificador de s e t, e
Ïƒ âˆˆ U(s, t), onde U(s, t) denota o conjunto formado por todos os unificadores dos termos
s e t.
Por exemplo, considere os termos s = f(a, x) e t = f(y, h(b)). Tais termos saËœo ditos
unificaÂ´veis, pois substituir x por h(b) e y por a torna-os ideË†nticos e iguais a f(a, h(b)).
Assim, neste caso um unificador de s e t eÂ´ dado por Ïƒ := {x/h(b), y/a}.
Neste trabalho, nos concentramos no caso em que a teoria equacional E eÂ´ vazia. Este
caso eÂ´ do nosso interesse pois eÂ´ neste contexto que se fala sobre o teorema dos pares
crÂ´Ä±ticos de Knuth-Bendix, formalizado na teoria trs, onde a existeË†ncia de unificadores
mais gerais foi originalmente axiomatizada, e que visamos completar. Quando E = âˆ… o
processo de unificacÂ¸aËœo recebe o nome especial de unificacÂ¸aËœo sintaÂ´tica.
Para estudarmos as propriedades das substituicÂ¸oËœes computadas por um algoritmo de
2.2 O Problema de UnificacÂ¸aËœo 13
unificacÂ¸aËœo, precisamos ainda de algumas nocÂ¸oËœes importantes e que nos interessam acerca
de substituicÂ¸oËœes. Como jaÂ´ colocamos anteriormente, em geral naËœo se estaÂ´ interessado
em um algoritmo que compute todos os unificadores de um dado problema, mas sim em
um unificador especial, um que seja mais geral. Assim, definimos o que vem a ser uma
substituicÂ¸aËœo mais geral.
DefinicÂ¸aËœo 2.2.9: Uma substituicÂ¸aËœo Ïƒ eÂ´ mais geral que uma substituicÂ¸aËœo Ïƒâ€² se existe
uma substituicÂ¸aËœo Î´ tal que Ïƒâ€² = Î´ â—¦ Ïƒ. Neste caso dizemos que Ïƒâ€² eÂ´ uma instaË†ncia de Ïƒ
e denotamos este fato por Ïƒ . Ïƒâ€², onde . eÂ´ uma relacÂ¸aËœo sobre substituicÂ¸oËœes que eÂ´ uma
preÂ´-ordem.
Agora podemos definir o que eÂ´ um problema de unificacÂ¸aËœo.
DefinicÂ¸aËœo 2.2.10: Uma instaË†ncia do problema de unificacÂ¸aËœo eÂ´ um conjunto finito de
equacÂ¸oËœes S = {s1 ?= t1, . . . , sn ?= tn}. O problema eÂ´ determinar se existe uma substituicÂ¸aËœo
Ïƒ tal que Ïƒ(si) = Ïƒ(ti), para todo i = 1, . . . , n.
Note que na definicÂ¸aËœo de problema de unificacÂ¸aËœo, temos n equacÂ¸oËœes, envolvendo pares
de termos que devemos responder se saËœo unificaÂ´veis e em seguida buscar uma substituicÂ¸aËœo
que seja um unificador de todos os n pares de termos. Mas o algoritmo de unificacÂ¸aËœo
apresentado na SecÂ¸aËœo 2.2.3, tem como paraË†metros apenas um par de termos, isto eÂ´, o
algoritmo apresentado busca responder, para dois termos s e t, se existe uma substituicÂ¸aËœo
Ïƒ tal que ÏƒË†(s) = ÏƒË†(t). Contudo, o algoritmo pode ser extendido a uma instaË†ncia do
problema de unificacÂ¸aËœo como definido acima.
DefinicÂ¸aËœo 2.2.11: Dizemos que uma substituicÂ¸aËœo Ïƒ eÂ´ um unificador ou solucÂ¸aËœo de um
problema de unificacÂ¸aËœo S, se ÏƒË†(si) = ÏƒË†(ti) para todo si
?
= ti âˆˆ S, i = 1, . . . , n. Denotamos
ainda por U(S) o conjunto de todos os unificadores de S, e dizemos que S eÂ´ unificaÂ´vel se
U(S) 6= âˆ….
Agora podemos definir o que eÂ´ um unificador mais geral de um problema de unificacÂ¸aËœo.
Por simplicidade, de agora em diante vamos fazer uso da sigla mgu, que vem da expressaËœo
em ingleË†s most general unifier, para significar que estamos falando de um unificador mais
geral.
2.2 O Problema de UnificacÂ¸aËœo 14
InÂ´Ä±cio Unification Algorithm(A: Conjunto naËœo vazio de expressoËœes bem
formadas)
Passo 1. Defina Ïƒ0 = id e k = 0, e vaÂ´ para o passo 2.
Passo 2. Se AÏƒk naËœo eÂ´ unitaÂ´rio, vaÂ´ para o passo 3. Caso contraÂ´rio, defina
ÏƒA = Ïƒk e termine.
Passo 3. Defina Vk como sendo o menor, e Uk como o sendo o proÂ´ximo, na
orden lexicograÂ´fica do conjunto de diferencÂ¸as Bk de AÏƒk. Se Vk
eÂ´ uma variaÂ´vel, e naËœo ocorre em Uk, defina Ïƒk+1 = [Vk/Uk] â—¦ Ïƒk,
adicione 1 a k, e retorne ao passo 2. Caso contraÂ´rio, termine.
Fim
Figura 2.2.1: Algoritmo de unificacÂ¸aËœo de Robinson original encontrado em [26].
DefinicÂ¸aËœo 2.2.12: Dizemos que uma substituicÂ¸aËœo Ïƒ eÂ´ um mgu de um problema de
unificacÂ¸aËœo S se:
â€¢ Ïƒ âˆˆ U(S) e
â€¢ Para todo Ïƒâ€² âˆˆ U(S) vale que Ïƒ . Ïƒâ€².
Em outras palavras, uma substituicÂ¸aËœo Ïƒ eÂ´ um mgu de um problema de unificacÂ¸aËœo S, se
eÂ´ um unificador de S e se para qualquer outra substituicÂ¸aËœo Ïƒâ€² que seja tambeÂ´m unificador
de S, existe uma substituicÂ¸aËœo Î´ tal que Ïƒâ€² = Î´Ïƒ.
2.2.3 O Algoritmo de UnificacÂ¸aËœo
Agora temos material suficiente para apresentar a versaËœo do algoritmo de unificacÂ¸aËœo de
Robinson, em seguida provar a correcÂ¸aËœo e a completude deste algoritmo. Na Figura 2.2.2
temos este algoritmo. Apresentamos tambeÂ´m na Figura 2.2.1 o algoritmo original de
Robinson, extraÂ´Ä±do de [26], para que se possa fazer uma comparacÂ¸aËœo entre os dois e ver
que consistem do mesmo processo.
Antes de partirmos para a verificacÂ¸aËœo da correcÂ¸aËœo da versaËœo do algoritmo de unificacÂ¸aËœo
de Robinson, o algoritmo Robinson-Unification, proposto na Figura 2.2.2, vamos enfatizar
2.2 O Problema de UnificacÂ¸aËœo 15
01: k := 0 (variaÂ´vel global)
Ïƒ0 := id
02: BEGIN Robinson-Unification(s, t)
03: IF s = t THEN Ïƒk+1 := id
04: ELSE
05: pâ† posicÂ¸aËœo da â€œprimeira diferencÂ¸aâ€ entre os termos s e t
(tomada mais externamente e mais a` esquerda)
06: IF s|p /âˆˆ V e t|p /âˆˆ V THEN fail
07: ELSE
08: IF s|p âˆˆ V e s|p âˆˆ V(t|p) THEN fail
09: ELSE
10: IF t|p âˆˆ V e t|p âˆˆ V(s|p) THEN fail
11: ELSE
12: IF s|p âˆˆ V THEN x := s|p e r := t|p
13: ELSE x := t|p e r := s|p
14: Ïƒk+1 := {x/r} (substituicÂ¸aËœo que resolve a primeira diferencÂ¸a)
15: k := k + 1
16: return Robinson-Unification(ÏƒË†k(s), ÏƒË†k(t)) â—¦ Ïƒk
17: END
Figura 2.2.2: VersaËœo do Algoritmo de UnificacÂ¸aËœo de Robinson, onde
k eÂ´ iniciado como zero e Ïƒ0 como a identidade
a notacÂ¸aËœo que seraÂ´ adotada de agora em diante, para termos uma refereË†ncia desta notacÂ¸aËœo
e evitar confusoËœes. Como sugere o algoritmo de unificacÂ¸aËœo, adotamos a seguinte notacÂ¸aËœo:
â€¢ Ïƒk, para k âˆˆ {0, . . . , n, . . .}, denota um conjunto de variaÂ´veis globais, que indicam
a ligacÂ¸aËœo feita no k-eÂ´simo passo do algorimo de unificacÂ¸aËœo, sendo que Ïƒ0 eÂ´ iniciada
globalmente como a substituicÂ¸aËœo identidade;
â€¢ k eÂ´ uma variaÂ´vel global de controle das chamadas recursivas do algoritmo, iniciada
globalmente como zero;
â€¢ Ïƒâ€²k indica a substituicÂ¸aËœo iterada, computada ateÂ´ o k-eÂ´simo passo do algoritmo de
unificacÂ¸aËœo, usada na demonstracÂ¸aËœo;
2.2 O Problema de UnificacÂ¸aËœo 16
â€¢ Ïƒ indica a substituicÂ¸aËœo final, obtida pelo algoritmo de unificacÂ¸aËœo, para dois termos
unificaÂ´veis s e t, usada nas provas.
Observe que, como jaÂ´ mencionamos anteriormente, no algoritmo da Figura 2.2.2, nos
concentramos no caso em que o conjunto de equacÂ¸oËœes S, que define problema de unificacÂ¸aËœo,
eÂ´ unitaÂ´rio. Isto eÂ´, S := {s ?= t}. Note tambeÂ´m que a cada iteracÂ¸aËœo, o algoritmo de
unificacÂ¸aËœo tem um novo conjunto de termos de entrada, obtido a partir do anterior e da
substituicÂ¸aËœo gerada pelo passo anterior. A fim de que o algoritmo esteja correto, desejamos
que estes novos termos tambeÂ´m sejam unificaÂ´veis, caso s e t o sejam. Observe ainda que
o algoritmo eÂ´ um processo que sempre termina, como provaremos adiante, pois a cada
selecÂ¸aËœo da variaÂ´vel x e do termo r, substitui-se todas as ocorreË†ncias de x nos termos s
e t pelo termo r, e como r naËœo possui ocorreË†ncias de x, temos que a cardinalidade do
conjunto dado pela uniaËœo dos conjuntos de variaÂ´veis dos termos em questaËœo, diminui a
cada iteracÂ¸aËœo do algoritmo, e como a uniaËœo dos conjuntos de variaÂ´veis dos termos s e
t eÂ´ um conjunto finito, temos que o algoritmo termina. Em seguida vamos enunciar e
demonstrar cada um destes fatos. ComecÂ¸amos pelo seguinte lema auxiliar:
Lema 2.2.13: Uma equacÂ¸aËœo x
?
= r, onde x âˆˆ Vars(r) e x 6= r, naËœo tem solucÂ¸aËœo.
DemonstracÂ¸aËœo: Observe que naËœo faz sentido considerar o caso em que o termo r eÂ´ uma
variaÂ´vel, pois caso r seja uma variaÂ´vel deve ser, por hipoÂ´tese, diferente de x. Contudo
temos tambeÂ´m que x pertence a Vars(r). Logo, se r eÂ´ uma variaÂ´vel deve ser igual a
x, o que eÂ´ uma contradicÂ¸aËœo. Portanto, suponha que r = f(r1, ..., rn) e que existe uma
substituicÂ¸aËœo Ïƒ tal que ÏƒË†(x) = ÏƒË†(r). Assim,
x âˆˆ Vars(r) â‡’ âˆƒp âˆˆ Pos(r) tal que r|p = x.
â‡’ ÏƒË†(r|p) = ÏƒË†(x) = ÏƒË†(r).
â‡’ ÏƒË†(r|p) = ÏƒË†(r)
â‡’ (ÏƒË†(r))|p = ÏƒË†(r)
â‡’ p = .
Mas se p = , entaËœo r|p = r. Contudo, r|p = x. Logo, r = x. O que eÂ´ um absurdo, pois por
hipoÂ´tese r 6= x. Portanto, temos que naËœo existe uma substituicÂ¸aËœo Ïƒ tal que ÏƒË†(x) = ÏƒË†(r),
isto eÂ´, nas condicÂ¸oËœes das hipoÂ´teses do lema, a equacÂ¸aËœo x
?
= r, naËœo tem solucÂ¸aËœo.
2.2 O Problema de UnificacÂ¸aËœo 17
Nos dois lemas seguintes vamos demonstrar fatos fundamentais para a demonstracÂ¸aËœo
do Teorema 2.2.18, onde provamos que a substituicÂ¸aËœo computada pelo algoritmo de uni-
ficacÂ¸aËœo, tomando como entradas dois termos unificaÂ´veis s e t, eÂ´ de fato um mgu de s e t.
No primeiro lema provamos que para dois termos unificaÂ´veis e diferentes, se tomamos a
substituicÂ¸aËœo que resolve a primeira diferencÂ¸a entre estes termos, onde a primeira diferencÂ¸a
eÂ´ tomada na posicÂ¸aËœo mais externa e mais a` esquerda dos termos, entaËœo as instaË†ncias dos
termos por esta substituicÂ¸aËœo saËœo ainda dois termos unificaÂ´veis. No segundo lema, pro-
vamos um resultado importante para garantir a terminacÂ¸aËœo do algoritmo de unificacÂ¸aËœo,
provamos que a uniaËœo dos conjuntos de variaÂ´veis dos termos obtidos por instanciacÂ¸aËœo nas
chamadas recursivas do algoritmo de unificacÂ¸aËœo sempre diminui. Precisamente, a cada
iteracÂ¸aËœo do algoritmo este conjunto passa a ter uma variaÂ´vel a menos: aquela capturada
na iteracÂ¸aËœo imediatamente anterior do algoritmo de unificacÂ¸aËœo.
Lema 2.2.14: (PreservacÂ¸aËœo da Generalidade) Sejam s e t dois termos unificaÂ´veis
e Ïƒk, para k 6= 0, a ligacÂ¸aËœo computada pelo algoritmo de unificacÂ¸aËœo no k-eÂ´simo passo.
Note que Ïƒk eÂ´ a substituicÂ¸aËœo que resolve a primeira diferencÂ¸a entre os termos ÏƒË†
â€²
kâˆ’1(s) e
ÏƒË†â€²kâˆ’1(t), onde Ïƒ
â€²
kâˆ’1 eÂ´ a substituicÂ¸aËœo iterada computada pelo algoritmo de unificacÂ¸aËœo ateÂ´ o
(k âˆ’ 1)-eÂ´simo passo. EntaËœo, ÏƒË†â€²kâˆ’1(s) e ÏƒË†â€²kâˆ’1(t) saËœo unificaÂ´veis e
âˆ€Î¸ âˆˆ U( ÏƒË†â€²kâˆ’1(s), ÏƒË†â€²kâˆ’1(t) ), âˆƒÎ´ tal que Î¸ = Î´ â—¦ Ïƒk.
DemonstracÂ¸aËœo: Vamos mostrar que a assertiva do lema eÂ´ de fato verdadeira para Î´ = Î¸,
isto eÂ´, âˆ€Î¸ âˆˆ U(ÏƒË†â€²kâˆ’1(s), ÏƒË†â€²kâˆ’1(t)), Î¸ = Î¸ â—¦ Ïƒk. No caso em s = t, temos que Ïƒ1 = id e eÂ´
trivial que Î¸ = Î¸ â—¦ id. O caso em que s 6= t, segue por inducÂ¸aËœo em k:
B.I.: Para k = 1: por hipoÂ´tese temos que Ïƒ0 = id e os termos s e t saËœo unificaÂ´veis. AleÂ´m
disso, âˆ€Î¸ âˆˆ U(s, t), Î¸ = Î¸ â—¦ Ïƒ1. De fato, se p eÂ´ a posicÂ¸aËœo onde ocorre a primeira
diferencÂ¸a entre os termos s e t, e se s|p eÂ´ uma variaÂ´vel que naËœo ocorre em t|p, entaËœo
a seguinte afirmacÂ¸aËœo eÂ´ verdadeira: âˆ€Î¸ âˆˆ U(s, t) e âˆ€y âˆˆ V , Î¸(y) = (Î¸ â—¦Ïƒ1)(y). Vamos
analisar as possibilidades para a variaÂ´vel y:
2.2 O Problema de UnificacÂ¸aËœo 18
y = s|p: Neste caso, temos que:
Î¸(y) = Î¸(s|p), pois y = s|p
= Î¸Ë†(s|p), pela observacÂ¸aËœo da definicÂ¸aËœo de substituicÂ¸aËœo
= Î¸Ë†(t|p), pois Î¸ âˆˆ U(s, t)
= Î¸Ë†(Ïƒ1(s|p)), pois Ïƒ1 = {s|p/t|p}
= (Î¸ â—¦ Ïƒ1)(s|p), por definicÂ¸aËœo
= (Î¸ â—¦ Ïƒ1)(y).
y 6= s|p: Neste caso, temos diretamente que Î¸(y) = (Î¸ â—¦ Ïƒ1)(y). Pois, como y 6= s|p
temos que y /âˆˆ Dom(Ïƒ1), o que implica que Ïƒ1(y) = y.
O caso em que t|p eÂ´ uma variaÂ´vel que naËœo ocorre em s|p eÂ´ anaÂ´logo.
P.I.: Suponha que a hipoÂ´tese seja vaÂ´lida para k, vamos mostrar que tambeÂ´m eÂ´ vaÂ´lida
para k + 1, isto eÂ´, vamos mostrar que:
ÏƒË†â€²kâˆ’1(s) e ÏƒË†
â€²
kâˆ’1(t) saËœo unificaÂ´veis e
âˆ€Î¸ âˆˆ U( ÏƒË†â€²kâˆ’1(s), ÏƒË†â€²kâˆ’1(t) ), Î¸ = Î¸ â—¦ Ïƒk
â‡“
ÏƒË†â€²k(s) e ÏƒË†
â€²
k(t) saËœo unificaÂ´veis e
âˆ€Î¸ âˆˆ U( ÏƒË†â€²k(s), ÏƒË†â€²k(t) ), Î¸ = Î¸ â—¦ Ïƒk+1.
Primeiro, vamos verificar que os termos ÏƒË†â€²k(s) e ÏƒË†
â€²
k(t) saËœo unificaÂ´veis. Isto equivale
a mostrar que o conjunto U(ÏƒË†â€²k(s), ÏƒË†â€²k(t)) eÂ´ naËœo vazio. Observe que Ïƒâ€²k = Ïƒk â—¦ Ïƒâ€²kâˆ’1,
pois a substituicÂ¸aËœo iterada obtida no k-eÂ´simo passo do algoritmo de unificacÂ¸aËœo eÂ´
igual a` composicÂ¸aËœo da ligacÂ¸aËœo obtida neste passo com a substituicÂ¸aËœo iterada obtida
no passo anterior. Assim,
Î¸ âˆˆ U(ÏƒË†â€²kâˆ’1(s), ÏƒË†â€²kâˆ’1(t)) â‡’ Î¸Ë†(ÏƒË†â€²kâˆ’1(s)) = Î¸Ë†(ÏƒË†â€²kâˆ’1(t))
â‡’ (Î¸Ì‚ â—¦ Ïƒk)(ÏƒË†â€²kâˆ’1(s)) = (Î¸Ì‚ â—¦ Ïƒk)(ÏƒË†â€²kâˆ’1(t))
â‡’ Î¸Ë†(( Ì‚Ïƒk â—¦ Ïƒâ€²kâˆ’1)(s)) = Î¸Ë†(( Ì‚Ïƒk â—¦ Ïƒâ€²kâˆ’1)(t))
â‡’ Î¸Ë†(ÏƒË†â€²k(s)) = Î¸Ë†(ÏƒË†â€²k(t))
â‡’ Î¸ âˆˆ U(ÏƒË†â€²k(s), ÏƒË†â€²k(t)).
2.2 O Problema de UnificacÂ¸aËœo 19
Portanto, sabendo que o conjunto U(ÏƒË†â€²k(s), ÏƒË†â€²k(t)) eÂ´ naËœo vazio, resta verificar que
âˆ€Î¸ âˆˆ U(ÏƒË†â€²k(s), ÏƒË†â€²k(t)), Î¸ = Î¸ â—¦ Ïƒk+1. De fato, sabemos que Ïƒk+1 eÂ´ a ligacÂ¸aËœo obtida
no (k + 1)-eÂ´simo passo do algoritmo de unificacÂ¸aËœo e, portanto temos as seguintes
possibilidades exclusivas para Ïƒk+1, onde a primeira possibilidade representa o caso
em que ÏƒË†â€²k(s) = ÏƒË†
â€²
k(t) e as duas uÂ´ltimas possibilidades representam o caso em que
ÏƒË†â€²k(s) 6= ÏƒË†â€²k(t).
i) Ïƒk+1 = id: Neste caso eÂ´ trivialmente verdade que Î¸ = Î¸ â—¦ Ïƒk+1 , pois Î¸ = Î¸ â—¦ id
qualquer que seja a substituicÂ¸aËœo Î¸, em particular para Î¸ âˆˆ U(ÏƒË†â€²k(s), ÏƒË†â€²k(t)) temos
que o resultado tambeÂ´m eÂ´ vaÂ´lido.
ii) Ïƒk+1 = {(ÏƒË†â€²k(s))|p/(ÏƒË†â€²k(t))p}: Neste caso temos que (ÏƒË†â€²k(s))|p eÂ´ uma variaÂ´vel
que naËœo ocorre em (ÏƒË†â€²k(t))|p, e p eÂ´ a posicÂ¸aËœo onde ocorre a primeira diferencÂ¸a
mais externa e mais a` esquerda entre os termos ÏƒË†â€²k(s) e ÏƒË†
â€²
k(t). Assim, para uma
variaÂ´vel y qualquer vamos mostrar que Î¸(y) = (Î¸ â—¦ Ïƒk+1)(y). Analogamente a`
anaÂ´lise de casos feita na base de inducÂ¸aËœo, temos:
y = (ÏƒË†â€²k(s))|p: Neste caso, temos que:
Î¸(y) = Î¸((ÏƒË†â€²k(s))|p)
= Î¸Ë†((ÏƒË†â€²k(s))|p), pela observacÂ¸aËœo da definicÂ¸aËœo de substituicÂ¸aËœo
= Î¸Ë†((ÏƒË†â€²k(t))|p), pois Î¸ âˆˆ U(ÏƒË†â€²k(s), ÏƒË†â€²k(t))
= Î¸Ë†(Ïƒk+1((ÏƒË†
â€²
k(s))|p)), pois Ïƒk+1((ÏƒË†â€²k(s))|p) = (ÏƒË†â€²k(s))|p
= (Î¸ â—¦ Ïƒk+1)((ÏƒË†â€²k(s))|p), por definicÂ¸aËœo
= (Î¸ â—¦ Ïƒk+1)(y).
y 6= (ÏƒË†â€²k(s))|p: Neste caso, temos diretamente que Î¸(y) = (Î¸ â—¦ Ïƒk+1)(y). Pois,
como y eÂ´ diferente de (ÏƒË†â€²k(s))|p, temos que y /âˆˆ Dom(Ïƒk+1), o que implica
que Ïƒk+1(y) = y.
iii) Ïƒk+1 = {(ÏƒË†â€²k(t))|p/(ÏƒË†â€²k(s))p}: Este caso eÂ´ inteiramente anaÂ´logo ao caso (ii)
anterior e portanto naËœo o repetiremos aqui.
Assim, concluÂ´Ä±mos que os termos ÏƒË†â€²k(s) e ÏƒË†
â€²
k(t) saËœo unificaÂ´veis e âˆ€Î¸ âˆˆ U(ÏƒË†â€²k(s), ÏƒË†â€²k(t))
vale que Î¸ = Î¸ â—¦ Ïƒk+1, para todo natural k. Logo, segue a demonstracÂ¸aËœo do lema.
2.2 O Problema de UnificacÂ¸aËœo 20
Note que no Lema 2.2.14, demonstramos que os termos gerados por instanciacÂ¸aËœo dos
termos s e t iniciais, pela substituicÂ¸aËœo iterada Ïƒâ€²kâˆ’1, computada ateÂ´ o (kâˆ’ 1)-eÂ´simo passo,
saËœo ainda unificaÂ´veis pela mesma substituicÂ¸aËœo Î¸ unificador de s e t. Esta demonstracÂ¸aËœo
difere da geralmente encontrada em livros texto e envolve uma discussaËœo sobre o domÄ±Â´nio
de Î¸.
Lema 2.2.15: (TerminacÂ¸aËœo) Sejam s e t dois termos unificaÂ´veis, tais que s 6= t, e
Ïƒâ€²kâˆ’1, para k > 0, a substituicÂ¸aËœo iterada, obtida na (k âˆ’ 1)-eÂ´sima iteracÂ¸aËœo do algoritmo
de unificacÂ¸aËœo, tendo como entrada dois termos unificaÂ´veis s e t. Assim, se Ïƒk eÂ´ a ligacÂ¸aËœo
obtida na k-eÂ´sima iteracÂ¸aËœo do algoritmo e se ÏƒË†â€²kâˆ’1(s) 6= ÏƒË†â€²kâˆ’1(t), entaËœo
Card( Vars(ÏƒË†k(ÏƒË†â€²kâˆ’1(s))) âˆª Vars(ÏƒË†k(ÏƒË†â€²kâˆ’1(t))) )
< Card( Vars(ÏƒË†â€²kâˆ’1(s)) âˆª Vars(ÏƒË†â€²kâˆ’1(t)) ).
DemonstracÂ¸aËœo: De fato, sabemos que se ÏƒË†â€²kâˆ’1(s) 6= ÏƒË†â€²kâˆ’1(t), entaËœo na iteracÂ¸aËœo seguinte
o algoritmo de unificacÂ¸aËœo busca a posicÂ¸aËœo p onde ocorre a primeira diferencÂ¸a entre os
termos ÏƒË†â€²kâˆ’1(s) e ÏƒË†
â€²
kâˆ’1(t), e a partir desta posicÂ¸aËœo computa a ligacÂ¸aËœo Ïƒk, para a qual temos
duas opcÂ¸oËœes:
a) Ïƒk = {(ÏƒË†â€²kâˆ’1(s))|p/(ÏƒË†â€²kâˆ’1(t))|p}, quando (ÏƒË†â€²kâˆ’1(s))|p eÂ´ uma variaÂ´vel que naËœo ocorre em
(ÏƒË†â€²kâˆ’1(t))|p.
b) Ïƒk = {(ÏƒË†â€²kâˆ’1(t))|p/(ÏƒË†â€²kâˆ’1(s))|p}, quando (ÏƒË†â€²kâˆ’1(t))|p eÂ´ uma variaÂ´vel que naËœo ocorre em
(ÏƒË†â€²kâˆ’1(s))|p.
Em ambos os casos a anaÂ´lise eÂ´ a mesma, portanto vamos considerar apenas um caso.
Assim, suponha que Ïƒk seja como no item (a). Como (ÏƒË†
â€²
kâˆ’1(s))|p eÂ´ uma variaÂ´vel que naËœo
ocorre em (ÏƒË†â€²kâˆ’1(t))|p, temos que, denotando (ÏƒË†â€²kâˆ’1(s))|p por x e (ÏƒË†â€²kâˆ’1(t))|p por r:
x /âˆˆ Vars(ÏƒË†k(ÏƒË†â€²kâˆ’1(s))) e x /âˆˆ Vars(ÏƒË†k(ÏƒË†â€²kâˆ’1(t)))
â‡’ x /âˆˆ Vars(ÏƒË†k(ÏƒË†â€²kâˆ’1(s))) âˆª Vars(ÏƒË†k(ÏƒË†â€²kâˆ’1(t))),
pois Ïƒk substitui todas as ocorreË†ncias de x por r. Logo, os termos instanciados por Ïƒk
naËœo possuem a variaÂ´vel x. Por outro lado, temos que:
x âˆˆ Vars(ÏƒË†â€²kâˆ’1(s)) âˆª Vars(ÏƒË†â€²kâˆ’1(t)),
2.2 O Problema de UnificacÂ¸aËœo 21
pois x eÂ´ um subtermo do termo ÏƒË†â€²kâˆ’1(s).
AleÂ´m disso, como r eÂ´ um subtermo do termo ÏƒË†â€²kâˆ’1(t), temos que Ïƒk naËœo introduz no
conjunto Vars(ÏƒË†k(ÏƒË†â€²kâˆ’1(s))) âˆª Vars(ÏƒË†k(ÏƒË†â€²kâˆ’1(t))), variaÂ´veis distintas das que ocorriam no
conjunto Vars(ÏƒË†â€²kâˆ’1(s)) âˆª Vars(ÏƒË†â€²kâˆ’1(t)). Assim,
Card( Vars(ÏƒË†k(ÏƒË†â€²kâˆ’1(s))) âˆª Vars(ÏƒË†k(ÏƒË†â€²kâˆ’1(t))) )
= Card( Vars(ÏƒË†â€²kâˆ’1(s)) âˆª Vars(ÏƒË†â€²kâˆ’1(t)) )âˆ’ 1
â‡“
Card( Vars(ÏƒË†k(ÏƒË†â€²kâˆ’1(s))) âˆª Vars(ÏƒË†k(ÏƒË†â€²kâˆ’1(t))) )
< Card( Vars(ÏƒË†â€²kâˆ’1(s)) âˆª Vars(ÏƒË†â€²kâˆ’1(t)) ).
DaÂ´Ä± segue a demonstracÂ¸aËœo do lema.
Como jaÂ´ comentamos anteriormente, na linha 08 do algoritmo verificamos se o sub-
termo de s na posicÂ¸aËœo p eÂ´ uma variaÂ´vel e se ocorre no subtermo de t na posicÂ¸aËœo p. E
caso a resposta seja negativa, passamos a` linha 10, onde fazemos esta mesma verificacÂ¸aËœo
para o termo t em vez de s. Isto nos garante que quando realizarmos a ligacÂ¸aËœo {x/r}, o
termo r naËœo possui ocorreË†ncias da variaÂ´vel x. Esta verificacÂ¸aËœo eÂ´ importante, pois garante
a correcÂ¸aËœo do algoritmo, contudo torna-o ineficiente, pois pode ser que seja necessaÂ´rio
gerar termos exponencialmente grandes durante o processo de unificacÂ¸aËœo.
Nos teoremas seguintes, verificamos que o algoritmo de unificacÂ¸aËœo eÂ´ correto e completo,
isto eÂ´, para quaisquer dois termos s e t o algoritmo daÂ´ uma resposta, caso s e t naËœo sejam
unificaÂ´veis o algoritmo falha, mas caso s e t sejam unificaÂ´veis o algoritmo computa uma
substituicÂ¸aËœo que eÂ´ de fato um mgu de s e t.
Teorema 2.2.16: (CorrecÂ¸aËœo) Sejam s e t dois termos unificaÂ´veis. Se Ïƒ eÂ´ a substituicÂ¸aËœo
computada pelo algoritmo de unificacÂ¸aËœo, entaËœo Ïƒ âˆˆ U(s, t).
DemonstracÂ¸aËœo: Vamos verificar este fato por inducÂ¸aËœo em n = Card(Vars(s)âˆªVars(t)).
B.I.: Para n = 0, temos que Vars(s) = âˆ… e Vars(t) = âˆ…. Portanto os termos s e t saËœo
termos funcionais, sem ocorreË†ncias de variaÂ´veis, que saËœo unificaÂ´veis. Logo, devemos
2.2 O Problema de UnificacÂ¸aËœo 22
ter s = t, mas neste caso a substituicÂ¸aËœo computada pelo algoritmo de unificacÂ¸aËœo eÂ´
a substituicÂ¸aËœo id. E eÂ´ trivialmente verdade que id(s) = id(t) para s = t. Portanto
Ïƒ = id âˆˆ U(s, t).
P.I.: Suponha que a hipoÂ´tese seja vaÂ´lida para n âˆ’ 1 e vamos mostar que tambeÂ´m seraÂ´
para n. O caso em que s = t eÂ´ trivial e o argumento eÂ´ o mesmo da base de inducÂ¸aËœo,
portanto vamos nos ater ao caso em que s 6= t. Pelo Lema 2.2.15 temos que se Ïƒ1
eÂ´ a substituicÂ¸aËœo computada pelo algoritmo de unificacÂ¸aËœo em um passo de execucÂ¸aËœo,
entaËœo
Card( Vars(ÏƒË†1(s)) âˆª Vars(ÏƒË†1(t)) ) = Card( Vars(s) âˆª Vars(t) ) âˆ’ 1.
Assim, supondo que a substituicÂ¸aËœo computada pelo algoritmo de unificacÂ¸aËœo para os
termos ÏƒË†1(s) e ÏƒË†1(t), que pelo Lema 2.2.14 saËœo unificaÂ´veis, eÂ´ um elemento do conjunto
U(ÏƒË†1(s), ÏƒË†1(t)), vamos mostrar que o mesmo vale para os termos s e t. Note que, se
Î¸ = Robinson-Unification(ÏƒË†1(s), ÏƒË†1(t)), e se Ïƒ = Robinson-Unification(s, t), entaËœo
Ïƒ = Î¸ â—¦ Ïƒ1. De fato, esta eÂ´ a composicÂ¸aËœo retornada pelo algoritmo de unificacÂ¸aËœo.
Assim,
Î¸ âˆˆ U(ÏƒË†1(s), ÏƒË†1(t)) â‡’ Î¸Ë†(ÏƒË†1(s)) = Î¸Ë†(ÏƒË†1(t))
â‡’ Ì‚(Î¸ â—¦ Ïƒ1)(s) = Ì‚(Î¸ â—¦ Ïƒ1)(t)
â‡’ ÏƒË†(s) = ÏƒË†(t)
â‡’ Ïƒ âˆˆ U(s, t).
Com isto concluÂ´Ä±mos a demonstracÂ¸aËœo do teorema.
Acabamos de verificar que a substituicÂ¸aËœo computada pelo algoritmo de unificacÂ¸aËœo
para dois termos unificaÂ´veis s e t eÂ´ de fato um unificador de s e t. No teorema seguinte
verificamos que esta substituicÂ¸aËœo eÂ´ mais geral que qualquer outra substituicÂ¸aËœo que unifique
os termos s e t.
Teorema 2.2.17: (Generalidade) Sejam s e t dois termos unificaÂ´veis. Se Ïƒ eÂ´ a subs-
tituicÂ¸aËœo computada pelo algoritmo de unificacÂ¸aËœo, entaËœo para toda substituicÂ¸aËœo Î¸ âˆˆ U(s, t)
temos que Ïƒ . Î¸.
2.2 O Problema de UnificacÂ¸aËœo 23
DemonstracÂ¸aËœo: Novamente vamos usar inducÂ¸aËœo em n = Card(Vars(s)âˆªVars(t)) para
verificar este fato. Note que queremos mostrar que âˆ€Î¸ âˆˆ U(s, t), âˆƒÎ´ tal que Î¸ = Î´ â—¦ Ïƒ.
B.I.: Pelo mesmo argumento do lema anterior, temos que para n = 0 os termos s e t
devem ser iguais. Neste caso Ïƒ = id. Assim, âˆ€Î¸ âˆˆ U(s, t), Î¸ = Î¸ â—¦ Ïƒ. Logo, Ïƒ eÂ´ mais
geral que Î¸.
P.I.: Suponha que a hipoÂ´tese seja vaÂ´lida para n âˆ’ 1 e vamos mostrar que tambeÂ´m seraÂ´
para n. O caso em que s = t eÂ´ trivial e o argumento eÂ´ o mesmo da base de inducÂ¸aËœo.
Portanto vamos nos ater ao caso em que s 6= t. Pelo Lema 2.2.15 temos que se Ïƒ1
eÂ´ a substituicÂ¸aËœo computada pelo algoritmo de unificacÂ¸aËœo em um passo de execucÂ¸aËœo,
entaËœo
Card( Vars(ÏƒË†1(s)) âˆª Vars(ÏƒË†1(t)) ) = Card( Vars(s) âˆª Vars(t) ) âˆ’ 1.
Assim, supondo que a substituicÂ¸aËœo computada pelo algoritmo de unificacÂ¸aËœo para os
termos ÏƒË†1(s) e ÏƒË†1(t), que pelo Lema 2.2.14 saËœo unificaÂ´veis, eÂ´ mais geral que qualquer
elemento do conjunto U(ÏƒË†1(s), ÏƒË†1(t)), vamos mostrar que o mesmo vale para os
termos s e t.
Primeiro observamos que, pelo Lema 2.2.14, temos:
âˆ€Î¸ âˆˆ U(s, t), âˆƒÎ± tal que Î¸ = Î± â—¦ Ïƒ1.
Afirmamos que Î± âˆˆ U(ÏƒË†1(s), ÏƒË†1(t)). De fato,
Î¸ âˆˆ U(s, t) â‡’ Î¸Ë†(s) = Î¸Ë†(t)
â‡’ (Î±Ì‚ â—¦ Ïƒ1)(s) = (Î±Ì‚ â—¦ Ïƒ1)(t)
â‡’ Î±Ë†(ÏƒË†1(s)) = Î±Ë†(ÏƒË†1(t))
â‡’ Î± âˆˆ U(ÏƒË†1(s), ÏƒË†1(t)).
Observe ainda que se Ïƒâ€²1 = Robinson-Unification(ÏƒË†1(s), ÏƒË†1(t)), e se Ïƒ = Robinson-
Unification(s, t), entaËœo Ïƒ = Ïƒâ€²1 â—¦ Ïƒ1. De fato, esta eÂ´ a composicÂ¸aËœo computada pelo
algoritmo de unificacÂ¸aËœo.
2.2 O Problema de UnificacÂ¸aËœo 24
Assim, temos que para Ïƒâ€²1 = Robinson-Unification(ÏƒË†1(s), ÏƒË†1(t)), existe uma substi-
tuicÂ¸aËœo Î´ tal que Î± = Î´ â—¦ Ïƒâ€²1, por hipoÂ´tese de inducÂ¸aËœo. Logo,
Î¸ = Î± â—¦ Ïƒ1 â‡’ Î¸ = Î´ â—¦ Ïƒâ€²1 â—¦ Ïƒ1
â‡’ Î¸ = Î´ â—¦ Ïƒ.
Ou seja, para todo Î¸ âˆˆ U(s, t), existe Î´ tal que Î¸ = Î´ â—¦ Ïƒ, onde Ïƒ eÂ´ a substituicÂ¸aËœo
computada pelo algoritmo de unificacÂ¸aËœo para os termos s e t. Logo, temos que Ïƒ eÂ´
mais geral que Î¸ seja qual for Î¸ âˆˆ U(s, t). Em outras palavras Ïƒ . Î¸.
Teorema 2.2.18: (Completude) Sejam s e t dois termos quaisquer. Se s e t saËœo
unificaÂ´veis, entaËœo o algoritmo de unificacÂ¸aËœo finaliza apresentando um unificador mais
geral de s e t. Caso s e t naËœo sejam unificaÂ´veis o algoritmo de unificacÂ¸aËœo para reportando
tal fato.
DemonstracÂ¸aËœo: Para verificar a completude do algoritmo de unificacÂ¸aËœo, devemos ana-
lisar o caso em que os termos do paraË†metro de entrada naËœo saËœo unificaÂ´veis, e verificar
que neste caso o processo de unificacÂ¸aËœo falha e o caso em que os termos saËœo unificaÂ´veis, e
verificar que neste caso o algoritmo computa um mgu.
No caso em que s e t naËœo saËœo unificaÂ´veis, nenhum Ïƒ gerado pelo algoritmo seraÂ´ solucÂ¸aËœo
de s
?
= t. Portanto o algoritmo deve parar reportanto tal fato. Isto se daÂ´ nas linhas 06,
08 e 10 do algoritmo.
â€¢ Na linha 06 do algoritmo, verificamos se na posicÂ¸aËœo onde ocorre a primeira diferencÂ¸a
entre os termos s e t, os dois subtermos s|p e t|p naËœo saËœo variaÂ´veis. Caso obtenha-
mos uma resposta positiva para esta verificacÂ¸aËœo, temos que nesta posicÂ¸aËœo ocorrem
apenas sÂ´Ä±mbolos de funcÂ¸aËœo nos dois termos. E como trata-se da posicÂ¸aËœo onde ocorre
a primeira diferencÂ¸a, concluÂ´Ä±mos que estes sÂ´Ä±mbolos de funcÂ¸aËœo saËœo sintaticamente
distintos. Logo, os termos s e t naËœo saËœo unificaÂ´veis e o algoritmo para reportando
tal fato.
â€¢ Na linha 08 do algoritmo verificamos, caso o subtermo s|p seja uma variaÂ´vel, se
s|p ocorre no subtermo t|p. Mas caso tenhamos uma resposta positiva para esta
verificacÂ¸aËœo, entaËœo s|p eÂ´ uma variaÂ´vel diferente do termo t|p e, aleÂ´m disso s|p âˆˆ
2.2 O Problema de UnificacÂ¸aËœo 25
Vars(t|p). Logo, segue do Lema 2.2.13 que a equacÂ¸aËœo s|p ?= t|p naËœo tem solucÂ¸aËœo.
EntaËœo o algoritmo para e reporta que s e t naËœo saËœo unificaÂ´veis.
â€¢ Na linha 10 do algoritmo faz-se a mesma verificacÂ¸aËœo realizada na linha 05, poreÂ´m
agora para saber se t|p âˆˆ Vars(s|p), caso t|p seja uma variaÂ´vel. EntaËœo da mesma
forma, se a resposta para esta verificacÂ¸aËœo eÂ´ positiva, o algoritmo para reportando
que os termos s e t naËœo saËœo unificaÂ´veis.
Caso os termos s e t sejam unificaÂ´veis, a substituicÂ¸aËœo gerada pelo algoritmo de unifi-
cacÂ¸aËœo eÂ´ um mgu de s e t. De fato, devemos demonstrar que se Ïƒ eÂ´ a substituicÂ¸aËœo gerada
pelo algoritmo, entaËœo Ïƒ eÂ´ uma solucÂ¸aËœo da equacÂ¸aËœo s
?
= t e para toda substituicÂ¸aËœo Î± que
tambeÂ´m seja unificador de s e t existe uma substituicÂ¸aËœo Î´ tal que Î± = Î´ â—¦Ïƒ. Mas este fato
segue diretamente dos teoremas 2.2.16 e 2.2.17.
CapÂ´Ä±tulo 3
SemaË†ntica do PVS
O PVS1 (Prototype Verification System) eÂ´ um sistema de especificacÂ¸aËœo e verificacÂ¸aËœo que
proveË† um ambiente integrado para desenvolvimento e anaÂ´lise de especificacÂ¸oËœes formais, e
suporta uma ampla gama de atividades envolvendo criacÂ¸aËœo, anaÂ´lise, modificacÂ¸aËœo, geren-
ciamento e documentacÂ¸aËœo de teorias e provas. O PVS eÂ´ basicamente composto por uma
Linguagem de EspecificacÂ¸aËœo fortemente integrada com um poderoso Assistente de Prova
Interativo, um Typechecker, aleÂ´m de outras ferramentas como bibliotecas de especificacÂ¸aËœo,
dentre outras. Neste capÂ´Ä±tulo apresentamos uma visaËœo geral sobre a semaË†ntica do PVS
e as principais ferramentas utilizadas na especificacÂ¸aËœo que apresentamos no CapÂ´Ä±tulo 4.
Para mais detalhes sobre a semaË†ntica do PVS ver [19], o qual eÂ´ a base das secÂ¸oËœes 3.3 e 3.4
deste capÂ´Ä±tulo. Para mais detalhes sobre a linguagem de especificacÂ¸aËœo do PVS, o provador
e o sistema em si, veja os manuais [21,22,30], os quais formam a base das secÂ¸oËœes 3.1 e 3.2.
Para mais detalhes sobre a teoria trs, brevemente apresentada na secÂ¸aËœo 3.5, ver [8].
3.1 A Linguagem de EspecificacÂ¸aËœo do PVS
A linguagem de especificacÂ¸aËœo do PVS eÂ´ baseada em loÂ´gica de ordem superior simples-
mente tipada, e eÂ´ desenvolvida para permitir especificacÂ¸oËœes suscintas e legÂ´Ä±veis, aleÂ´m de
construcÂ¸oËœes efetivas de prova. Dentro de uma teoria os tipos podem ser definidos a partir
de tipos mais baÂ´sicos, como booleanos, nuÂ´meros naturais, etc.
1DisponÂ´Ä±vel em http://pvs.csl.sri.com
26
3.2 O Assistente de Provas 27
Exemplo 3.1.1: Por exemplo, para definir uma substituicÂ¸aËœo idempotente foi construÂ´Ä±da
a especificacÂ¸aËœo do tipo idempotent_sub, apresentada abaixo. Tal especificacÂ¸aËœo consta da
sub-teoria substitution, e foi definida a partir do tipo boll e tambeÂ´m a partir do tipo
Sub, pois sigma eÂ´ um objeto previamente declarado como sendo de tipo Sub, o que significa
que sigma eÂ´ uma substituicÂ¸aËœo.
idempotent_sub?(sigma): bool = comp(sigma, sigma) = sigma
idempotent_sub: TYPE = (idempotent_sub?)
Uma especificacÂ¸aËœo em PVS consiste de uma colecÂ¸aËœo de teorias. E cada teoria con-
siste de um conjunto de sÂ´Ä±mbolos para os nomes dos tipos e constantes introduzidas na
teoria, aleÂ´m de axiomas, definicÂ¸oËœes e teoremas associados. Como exemplo tomamos a
especificacÂ¸ao da sub-teoria unification, apresentada no ApeË†ndice A.
3.2 O Assistente de Provas
O objetivo principal do assistente de prova do PVS eÂ´ dar suporte a` construcÂ¸aËœo de provas
legÂ´Ä±veis, isto eÂ´, o processo de verificacÂ¸aËœo busca ser proÂ´ximo de uma prova que farÂ´Ä±amos
no papel, logo permite interacÂ¸aËœo humana, de forma que a prova possa ser facilmente
entendida e comunicada a outras pessoas. No sentido de fazer com que as provas sejam
facilmente desenvolvidas, o assistente de prova do PVS proveË† uma colecÂ¸aËœo poderosa de
comandos de prova, que quando combinados corretamente desenvolvem uma estrateÂ´gia
de prova que visa realizar raciocÂ´Ä±nios loÂ´gicos, proposicionais e aritmeÂ´ticos, com o uso de
definicÂ¸oËœes e lemas.
O assistente de prova do PVS foi desenvolvido com base na semaË†ntica usual de Gent-
zen da Teoria da Prova. Isto significa que os objetivos em PVS saËœo apresentados como
sequentes Î“ ` âˆ†, onde Î“ e âˆ† saËœo sequeË†ncias finitas de foÂ´rmulas.
O assistente de prova manteÂ´m uma aÂ´rvore de prova, e o objetivo eÂ´ obter uma aÂ´rvore de
prova que seja completa, isto eÂ´, uma aÂ´rvore em que todos as folhas saËœo reconhecidas como
verdadeiras. Cada noÂ´ da aÂ´rvore eÂ´ um objetivo de prova, representado por um sequente
3.3 A Checagem de Tipos em PVS 28
da forma Î“ ` âˆ† que consiste de uma sequeË†ncia de foÂ´rmulas Î“ chamadas antecedentes e
uma sequeË†ncia de foÂ´rmulas âˆ† chamadas consequentes. A interpretacÂ¸aËœo de um sequente eÂ´
que a conjuncÂ¸aËœo dos antecedentes implica a disjuncÂ¸aËœo dos consequentes, isto eÂ´, para Î“ =
{A1, A2, A3, . . .} e âˆ† = {B1, B2, B3, . . .}, temos que (A1âˆ§A2âˆ§A3 . . .) âŠƒ (B1âˆ¨B2âˆ¨B3 . . .).
3.3 A Checagem de Tipos em PVS
Sabemos que os tipos formam um mecanismo poderoso para detectar erros sintaÂ´ticos e
semaË†nticos, isto eÂ´ feito atraveÂ´s de uma operacÂ¸aËœo de checagem de tipos, que em PVS eÂ´ man-
tida pelo typechecker. A loÂ´gica expressiva do PVS proporciona uma boa integracÂ¸aËœo entre o
typechecker e o assistente de prova. O typechecker, explora o poder dedutivo do assistente
de prova para provar automaticamente as condicÂ¸oËœes de correcÂ¸aËœo de tipos, ou TCCâ€™s do
ingleË†s type correctness conditions, que saËœo obrigacÂ¸oËœes de prova geradas pela operacÂ¸aËœo de
checagem de tipos. Estas obrigacÂ¸oËœes de prova, surgem por exemplo quando realizamos
a checagem de tipos de um termo em confronto com um subtipo de um predicado. Tais
obrigacÂ¸oËœes tambeÂ´m aparecem como sub-objetivos de prova durante uma formalizacÂ¸aËœo.
Em PVS os tipos baÂ´sicos consistem de Booleanos, bool, e nuÂ´meros reais, real. O PVS
eÂ´ uma linguagem de especificacÂ¸aËœo fortemente tipada, onde os tipos saËœo construÂ´Ä±dos a partir
dos tipos baÂ´sicos, atraveÂ´s de funcÂ¸oËœes e produtos de tipos, e expressoËœes saËœo construÂ´Ä±das a
partir das constantes e variaÂ´veis por meio de aplicacÂ¸oËœes, abstracÂ¸oËœes e sequeË†ncias.
A operacÂ¸aËœo de checagem de tipos eÂ´ feita dentro de um contexto. Em PVS, um contexto
Î“ eÂ´ uma sequeË†ncia de declaracÂ¸oËœes, onde cada declaracÂ¸aËœo eÂ´ ou uma declaracÂ¸aËœo de tipo,
s:TYPE, ou uma declaracÂ¸aËœo de constante, c:T, onde T eÂ´ um tipo, ou uma declaracÂ¸aËœo de
variaÂ´vel, x:VAR T. Isto pode ser visto como uma funcÂ¸aËœo parcial que associa a cada sÂ´Ä±mbolo
uma espeÂ´cie que pode ser ou TYPE, ou CONSTANT, ou VARIABLE e um tipo a cada sÂ´Ä±mbolo
de constante e variaÂ´vel. De maneira mais formal, definimos:
DefinicÂ¸aËœo 3.3.1: Seja Î“ um contexto e s um sÂ´Ä±mbolo com declaracÂ¸aËœo D e r um sÂ´Ä±mbolo
qualquer. EntaËœo,
1. (Î“, s : D)(s) = D
3.3 A Checagem de Tipos em PVS 29
2. r 6= sâ‡’ (Î“, s : D)(r) = Î“(r)
3. Se s naËœo eÂ´ declarado em Î“, entaËœo Î“(s) eÂ´ indefinido.
4. Para qualquer sÂ´Ä±mbolo, s a espeÂ´cie de s em Î“ eÂ´ dada por kind(Î“(s)).
5. Se kind(Î“(s)) eÂ´ CONSTANT ou VARIABLE, entaËœo o tipo de Î“(s) eÂ´ o tipo associado a s
em Î“.
As regras de tipos em uma teoria simplesmente tipada saËœo dadas pela definicÂ¸aËœo recur-
siva de uma funcÂ¸aËœo parcial Ï„ que associa:
(i) a um termo a, bem tipado em relacÂ¸aËœo a um contexto Î“, um tipo Ï„(Î“)(a).
(ii) a um tipo A, bem formado em relacÂ¸aËœo a um contexto Î“, a palavra-chave TYPE como
resultado de Ï„(Î“)(A).
(iii) a um contexto âˆ†, bem formado em relacÂ¸aËœo a um contexto Î“, a palavra-chave CONTEXT
como resultado de Ï„(Î“)(âˆ†).
Normalmente, as regras de tipos saËœo apresentadas como regras de infereË†ncia, mas em
PVS uma apresentacÂ¸aËœo funcional eÂ´ mais apropriada, pois desta forma obtemos uma argu-
mentacÂ¸aËœo de correcÂ¸aËœo de provas mais natural e direta. Assim temos a seguinte definicÂ¸aËœo
para as regras de tipo, que em PVS representam a operacÂ¸aËœo de typechecking.
DefinicÂ¸aËœo 3.3.2: Regras de tipos
Ï„()({}) = CONTEXT
Ï„()(Î“, s : TYPE) = CONTEXT, se Î“(s) eÂ´ indefinido e Ï„()(Î“) = CONTEXT
Ï„()(Î“, c : T ) = CONTEXT, se Î“(c) eÂ´ indefinido, Ï„(Î“)(T ) = TYPE
e Ï„()(Î“) = CONTEXT
Ï„()(Î“, x : VAR T ) = CONTEXT, se Î“(x) eÂ´ indefinido, Ï„(Î“)(T ) = TYPE
e Ï„()(Î“) = CONTEXT
Ï„(Î“)(s) = TYPE, se kind(Î“(s)) = TYPE
Ï„(Î“)([Aâ†’ B]) = TYPE, se Ï„(Î“)(A) = Ï„(Î“)(B) = TYPE
Ï„(Î“)([A1, A2]) = TYPE, se Ï„(Î“)(Ai) = TYPE para 1 â‰¤ i â‰¤ 2
3.3 A Checagem de Tipos em PVS 30
Ï„(Î“)(s) = type(Î“(s)), se kind(Î“(s)) âˆˆ {CONSTANT, VARIABLE}
Ï„(Î“)(f a) = B, se Ï„(Î“)(f) = [Aâ†’ B] e Ï„(Î“)(a) = A
Ï„(Î“)(Î»(x : T ) : a) = [T â†’ Ï„(Î“, x : VAR T )(a)], se Î“(x) eÂ´ indefinido
e Ï„(Î“)(T ) = TYPE
Ï„(Î“)((a1, a2)) = [Ï„(Î“)(a1), Ï„(Î“)(a2)]
Ï„(Î“)(pi a) = Ti, onde Ï„(Î“)(a) = [T1, T2]
Exemplo 3.3.1: Seja â„¦ um contexto onde bool : TYPE, TRUE : bool e FALSE : bool. Assim,
neste contexto as regras de tipo saËœo dadas por:
Ï„()({}) = TYPE
Ï„()(â„¦) = TYPE
Ï„(â„¦)([[bool, bool]â†’ bool]) = TYPE
Ï„(â„¦)((TRUE, FALSE)) = [bool, bool]
Ï„(â„¦)(p2(TRUE, FALSE)) = bool
Ï„(â„¦)(Î»(x : boll) : TRUE) = [boolâ†’ bool]
Note que nas regras de tipos a boa formacÂ¸aËœo do contexto em questaËœo naËœo eÂ´ explici-
tamente verificada, contudo tais regras preservam a boa formacÂ¸aËœo do contexto em cada
chamada recursiva, entaËœo se o contexto inicial eÂ´ bem formado, todos os contextos inter-
mediaÂ´rios o seraËœo tambeÂ´m.
Um termo bem tipado s com um tipo designado por Ï„ dentro de um contexto Î“ eÂ´ dito
um termo de tipo Ï„(Î“)(s) no contexto Î“.
Expomos no CapÂ´Ä±tulo 4 a apresentacÂ¸aËœo da formalizacÂ¸aËœo de uma teoria para unificacÂ¸aËœo
de primeira ordem. Obviamente esta teoria passou pela operacÂ¸aËœo de checagem de tipos,
que eÂ´ feita explicitamente atraveÂ´s do comando M-x type-check-prove ou M-x tcp, mas
tambeÂ´m eÂ´ realizada automaticamente pelo PVS durante uma formalizacÂ¸aËœo. Assim, alguns
TCCâ€™s foram gerados e mostraremos abaixo um deles como exemplo.
Exemplo 3.3.2: Na Tabela 4.2.1 apresentamos um dos treË†s construtores, denominado
3.3 A Checagem de Tipos em PVS 31
resolving_diff, especificado com o objetivo de obter uma funcÂ¸aËœo que compute unificado-
res mais gerais. O resultado da checagem de tipos deste construtor gera sete TCCâ€™s, um
deles eÂ´ apresentado aqui para exemplificar a importaË†ncia da checagem de tipos e como
obtemos resultados com o procedimento realizado pelo typechecking representado pelas re-
gras da DefinicÂ¸aËœo 3.3.2. Na SecÂ¸aËœo 4.2, apresentamos este construtor detalhadamente, mas
para entender este exemplo precisamos saber que este construtor age recursivamente em
dois paraË†metros de tipo termo que saËœo diferentes e especificados como tipos dependentes
unificaÂ´veis. Assim, com a operacÂ¸aËœo de checagem de tipos esperamos, durante o processo
de recursaËœo, aplicar este construtor a termos que ainda sejam unificaÂ´veis e diferentes, isto
eÂ´, preserva a tipagem. Portanto, o typechecker gera uma obrigacÂ¸aËœo de prova, um TCC,
apresentado pelo PVS como segue:
Subtype TCC generated (at line 100, column 57) for
subtermOF(t, #(k + 1))
expected type {t: term |
unifiable(subtermOF(s, #(1 + k)), t) &
NOT subtermOF(s, #(1 + k)) = t}
proved - complete
resolving_diff_TCC4: OBLIGATION
FORALL (s: term, (t: term | unifiable(s, t) & s /= t), f: symbol,
st: {args: finite_sequence[term] | argsâ€˜length = arity(f)}):
NOT stâ€˜length = 0 AND s = app(f, st) IMPLIES
(FORALL (fp: symbol,
stp:{args: finite_sequence[term] | argsâ€˜length = arity(fp)}):
t = app(fp, stp) IMPLIES
(FORALL (k: below[stpâ€˜length]):
k = min({kk: below[stpâ€˜length] |
subtermOF(s, #(kk + 1)) /= subtermOF(t, #(kk + 1))})
IMPLIES
unifiable(subtermOF(s, #(1 + k)), subtermOF(t, #(k + 1)))
&
NOT subtermOF(s, #(1 + k)) = subtermOF(t, #(k + 1))));
Este TCC foi gerado para o termo subtermOF(t, #(k + 1)) e o tipo esperado para este
termo eÂ´ que ele seja unificaÂ´vel com o termo subtermOF(s, #(k + 1)) e diferente deste, esta
informacÂ¸aËœo vem descrita no â€œcabecÂ¸alhoâ€ do TCC. Logo no corpo do TCC, onde temos a
obrigacÂ¸aËœo de prova a ser demonstrada, isto eÂ´, sob as hipoÂ´teses de que s e t sejam dois
termos unificaÂ´veis e diferentes, onde o termo s eÂ´ uma aplicacÂ¸aËœo, devemos ter que o termo
subtermOF(t, #(k + 1)) eÂ´ do tipo esperado. Esta verificacÂ¸aËœo se faz necessaÂ´ria devido ao
3.4 As Regras de Prova do PVS 32
caraÂ´ter recursivo do construtor resolving_diff.
O PVS ainda oferece o recurso de declarar tipos dependentes, isto eÂ´, alguns dos tipos
dos paraË†metros de uma especificacÂ¸aËœo podem ser dependentes de paraË†metros anteriores.
Este recurso foi importante na especificacÂ¸aËœo proposta neste trabalho, pois nos permitiu
trabalhar com termos unificaÂ´veis, como observamos no exemplo anterior, onde temos que
sobre o termo t existe a condicÂ¸aËœo unifiable(s, t), que indica que sobre o tipo do termo
t existe a condicÂ¸aËœo de que t seja unificaÂ´vel com o termo s.
3.4 As Regras de Prova do PVS
As regras de prova do PVS saËœo apresentadas em termos de caÂ´lculo de sequentes. Como
mencionamos na SecÂ¸aËœo 3.2, um sequente eÂ´ da forma Î£ `Î“ Î›, onde Î“ eÂ´ o contexto, Î£ eÂ´ o
conjunto das foÂ´rmulas que compoËœem o antecedente e Î› representa o conjunto das foÂ´rmulas
que compoËœem o consequente. Sobre um sequente desta forma devemos fazer a seguinte
leitura: a conjuncÂ¸aËœo das foÂ´rmulas de Î£ implica a disjuncÂ¸aËœo das foÂ´rmulas de Î›.
3.4.1 Regras Estruturais
Com as regras estruturais podemos rearranjar um sequente ou enfraqueceË†-lo, introduzindo
novas foÂ´rmulas na conclusaËœo.
A regra (W ) apresentada em 3.4.1, representa uma poderosa regra de enfraquecimento.
Todas as regras estruturais podem ser expressas em termos desta. Esta regra permite
derivar um sequente mais fraco de um mais forte, por meio de introducÂ¸aËœo de foÂ´rmulas no
antecedente ou no consequente. Este fato eÂ´ expresso pela condicÂ¸aËœo que se impoËœe de que
Î£1 âŠ† Î£2 e Î›1 âŠ† Î›2.
Î£1 `Î“ Î›1
Î£2 `Î“ Î›2 (W ), se Î£1 âŠ† Î£2 e Î›1 âŠ† Î›2 (3.4.1)
As regras de contracÂ¸aËœo (C `) e (` C), apresentadas abaixo, permitem substituir
vaÂ´rias ocorreË†ncias de uma mesma foÂ´rmula no antecedente ou no consequente por uma
3.4 As Regras de Prova do PVS 33
uÂ´nica ocorreË†ncia.
a,Î£ `Î“ Î›
a, a,Î£ `Î“ Î› (C `)
Î£ `Î“ a,Î›
Î£ `Î“ a, a,Î› (` C)
As regras de comutacÂ¸aËœo (X `) e (` X), afirmam que a ordem das foÂ´rmulas tanto do
antecedente quanto do consequente eÂ´ insignificante.
Î£1, b, a,Î£2 `Î“ Î›
Î£1, a, b,Î£2 `Î“ Î› (X `)
Î£ `Î“ Î›1, b, a,Î›2
Î£ `Î“ Î›1, a, b,Î›2 (` X)
3.4.2 Regra de Corte
A regra de corte (Cut) pode ser usada para introduzir a anaÂ´lise de casos sobre uma foÂ´rmula
a, dentro de uma prova de um sequente da forma Î£ `Î“ Î›. Isto leva a dois sub-objetivos
da forma Î£, a `Î“ Î› e Î£ `Î“ a,Î›, que podem ser vistos como assumindo a em um ramo da
prova e Â¬a no outro ramo da prova.
(Ï„(Î“)(a) âˆ¼ bool)Î“ Î£, a `Î“ Î› Î£ `Î“ a,Î›
Î£ `Î“ Î› (Cut)
3.4.3 Regras para Axiomas Proposicionais
Na regra (Ax), simplesmente temos afirmacÂ¸aËœo trivial de que a segue de a.
Î£, a `Î“ a,Î› (Ax)
As regras (FALSE `) e (` TRUE), afirmam que se em um dado sequente existe uma
ocorreË†ncia de FALSE no antecedente ou uma ocorreË†ncia de TRUE no consequente, entaËœo este
sequente eÂ´ um axioma.
Î£, FALSE `Î“ Î› (FALSE `) Î£ `Î“ TRUE,Î› (` TRUE)
3.4 As Regras de Prova do PVS 34
3.4.4 Regras de Contexto
Algumas foÂ´rmulas valem em um contexto simplesmente porque elas jaÂ´ fazem parte do
contexto, ou como uma foÂ´rmula mesmo ou como uma declaracÂ¸aËœo de constante. Nisto
consiste a assertiva das regras (ContextFormula) e (ContextDefinition) abaixo.
`Î“ a (ContextFormula), se a eÂ´ uma foÂ´rmula em Î“.
`Î“ s = a (ContextDefinition), se s : T = a eÂ´ uma definicÂ¸aËœo de constante em Î“
Um contexto Î“ pode ser estendido, atraveÂ´s das regras (Context `) e (` Context), por
foÂ´rmulas no antecedente ou negacÂ¸aËœo de foÂ´rmulas no consequente.
Î£, a `Î“,a Î›
Î£, a `Î“ Î› (Context `)
Î£ `Î“,Â¬a a,Î›
Î£ `Î“ a,Î› (` Context)
A regra (ContextW ), eÂ´ uma regra de enfraquecimento do contexto que eÂ´ bastante uÂ´til,
pois mostra que uma derivacÂ¸aËœo eÂ´ monoÂ´tona em relacÂ¸aËœo a um contexto.
Î£ `Î“ Î›
Î£ `Î“â€² Î› (ContextW ), se Î“ eÂ´ um prefixo de Î“
â€²
3.4.5 Regras Condicionais
As regras (IF `) e (` IF ) teË†m o objetivo de eliminar as ocorreË†ncias de IF-THEN-ELSE em
uma prova. Contudo estas regras naËœo saËœo usuais pois elas aumentam o contexto.
Î£, a, b `Î“,a Î› Î£, c `Î“,Â¬a a,Î›
Î£, IF(a, b, c) `Î“ Î› (IF `)
Î£, a `Î“,a b,Î› Î£ `Î“,Â¬a a, c,Î›
Î£ `Î“ IF(a, b, c),Î› (` IF )
3.4 As Regras de Prova do PVS 35
3.4.6 Regras de Igualdade
As regras de transitividade e simetria para a igualdade podem ser derivadas das regras
de igualdade (Refl) e (Repl) abaixo. Nestas regras a notacÂ¸aËœo a[e] indica uma ou mais
ocorreË†ncias de e na foÂ´rmula a, tal que naËœo existem ocorreË†ncias de variaÂ´veis livres em e.
Similarmente, a notacÂ¸aËœo Î›[e] indica ocorreË†ncias de e em Î›.
Î£ `Î“ a = a,Î› (Refl)
a = b,Î£[b] `Î“ Î›[b]
a = b,Î£[a] `Î“ Î›[a] (Repl)
3.4.7 Regras de Igualdade Booleana
Na regra (Repl TRUE) temos a assercÂ¸aËœo de que uma foÂ´rmula a no antecedente pode ser
tratada como uma foÂ´rmula de igualdade no antecedente da forma a = TRUE. Similarmente
a regra (Repl FALSE) asserta que uma foÂ´rmula a no consequente pode ser vista como uma
igualdade da forma a = FALSE, no antecedente. JaÂ´ a regra TRUE-FALSE, afirma que as
constantes booleanas TRUE e FALSE saËœo distintas.
Î£[TRUE], a `Î“ Î›[TRUE]
Î£[a], a `Î“ Î›[a] (Refl TRUE)
Î£[FALSE], a `Î“ Î›[FALSE]
Î£[a] `Î“ a,Î›[a] (Repl FALSE)
Î£, TRUE = FALSE `Î“ Î› (TRUEâˆ’ FALSE)
3.4.8 Regras de ReducÂ¸aËœo
As regras de reducÂ¸aËœo (Î²) e (pi), saËœo axiomas de igualdade, que nos possibilitam reali-
zar simplificacÂ¸oËœes oÂ´bvias, para aplicacÂ¸oËœes envolvendo lambda abstracÂ¸oËœes e projecÂ¸aËœo de
produtos.
`Î“ (Î»(x : T ) : a)(b) = a[b/x] (Î²) `Î“ pi(a1, a2) = ai (pi), para i = 1, 2
3.4 As Regras de Prova do PVS 36
3.4.9 Regras de Extensionalidade
As regras de extensionalidade (FunExt) e (TupExt), saËœo regras que estabelecem igual-
dade para expressoËœes funcionais e de produto respectivamente. A regra de extensionali-
dade para funcÂ¸oËœes introduz uma constante de Skolem s para estabelecer que duas funcÂ¸oËœes
f e g saËœo iguais quando os resultados das aplicacÂ¸oËœes destas funcÂ¸oËœes a um argumento qual-
quer de s saËœo iguais. A regra de extensionalidade para produto nos diz que dois produtos
saËœo iguais se as suas projecÂ¸oËœes correspondentes saËœo iguais.
Î£ `Î“,s:A (f s) =B[s/x] (g s),Î›
Î£ `Î“ f =[x:Aâ†’B] g,Î› (FunExt), se Î“(s) eÂ´ indefinido
Î£ `Î“ p1(a) =T1 p1(b),Î› Î£ `Î“ p2(a) =T2[(p1 a)/x] p2(b),Î›
Î£ `Î“ a =[x:T1T2] b,Î› (TupExt)
3.4.10 Regra de RestricÂ¸aËœo de Tipo
A regra de restricÂ¸aËœo de tipo (Typepred), eÂ´ usada para suprir a necessidade de uma regra
que introduza a restricÂ¸aËœo de tipo sobre um termo como uma foÂ´rmula no antecedente de
um dado sequente.
Ï„(Î“)(a) = A pi(A)(a),Î£ `Î“ Î›
Î£ `Î“ Î› (Typepred)
Exemplo 3.4.1: Vejamos por exemplo a prova do teorema Vars_is_var, da sub teoria
subterm, onde formalizamos o fato de que o conjunto de variaÂ´veis de um termo que eÂ´
uma variaÂ´vel eÂ´ igual ao proÂ´prio termo. Nesta prova o primeiro sequente eÂ´ apresentado da
seguinte forma:
|-------
{1} FORALL (t: term[variable, symbol, arity]):
vars?(t) => Vars(t) = ({y: (V) | y = t})
3.4 As Regras de Prova do PVS 37
A este sequente aplicamos a regra de prova skeep, a fim de skolemizar as variaÂ´veis
ligadas. Em seguida decompomos a igualdade de conjuntos presente na foÂ´rmula, com a
regra decompose-equality e com isto temos um novo sequente:
[-1] vars?(t)
|-------
{1} Vars(t)(x!1) = (x!1 = t)
Neste ponto a estrateÂ´gia adotada eÂ´ a de converter a igualdade da foÂ´rmula 1 em uma
dupla implicacÂ¸aËœo com a regra iff. Em seguida expandimos a definicÂ¸aËœo de Vars e realizamos
uma simplificacÂ¸aËœo proposicional, o que faz com que a prova se divida em dois sub-objetivos,
o primeiro deles dado por:
{-1} EXISTS (p: positions?(t)): subtermOF(t, p) = x!1
[-2] vars?(t)
|-------
{1} x!1 = t
No objetivo acima, pela foÂ´rmula -1 que existe uma posicÂ¸aËœo p, pertencente ao conjunto
de posicÂ¸oËœes do termo t, tal que o subtermo de t nesta posicÂ¸aËœo eÂ´ igual a` variaÂ´vel x!1. Mas
como o termo t eÂ´ uma variaÂ´vel, temos que esta posicÂ¸aËœo eÂ´ a raiz, o que implica que t eÂ´
igual x!1. Assim, skolemizando a variaÂ´vel da foÂ´mula -1 e expandindo algumas definicÂ¸oËœes,
chegamos a esta conclusaËœo. E isto completa este ramo da prova, pois a foÂ´mula 1 representa
a negacÂ¸aËœo do fato de t ser igual x!1.
No ramo seguinte da prova, temos a outra parte da dupla-implicacÂ¸aËœo, representada
pelo seguinte sequente:
{-1} x!1 = t
[-2] vars?(t)
|-------
{1} EXISTS (p: positions?(t)): subtermOF(t, p) = x!1
Note que agora, sabendo que t eÂ´ igual x!1, pela foÂ´rmula -1, e que t eÂ´ uma variaÂ´vel,
pela foÂ´rmula -2, queremos verificar que existe uma posicÂ¸aËœo p, pertencente ao conjunto
de posicÂ¸oËœes do termo t, tal que o subtermo de t nesta posicÂ¸aËœo eÂ´ igual a` x!1. Mas pela
foÂ´rmula 1, temos que tal posicÂ¸aËœo naËœo existe. EntaËœo a estrateÂ´gia eÂ´ instanciar a foÂ´rmula 1
com a posicÂ¸aËœo raiz. Com isto novamente completamos este ramo da prova, apoÂ´s expandir
a definicÂ¸aËœo de subtermOF. Em seguida provamos em um outro objetivo que a posicÂ¸aËœo raiz
faz parte do conjunto de posicÂ¸oËœes do termo t e com isto completamos a formalizacÂ¸aËœo deste
lema.
3.5 Sub-teorias da Teoria TRS 38
3.5 Sub-teorias da Teoria TRS
Nesta secÂ¸aËœo apresentamos algumas sub-teorias da teoria trs, onde encontramos as especi-
ficacÂ¸oËœes e formalizacÂ¸oËœes dos conceitos iniciais definidos no CapÂ´Ä±tulo 2, como por exemplo
as definicÂ¸oËœes de termos, posicÂ¸oËœes, substituicÂ¸oËœes, etc. A especificacÂ¸aËœo destes conceitos e a
formalizacÂ¸aËœo de vaÂ´rios resultados acerca dos mesmos, compoËœe o que chamamos de uma
aÂ´lgebra de termos e formam base para o desenvolvimento da sub-teoria unification.
3.5.1 A Sub-teoria term
Como vimos na DefinicÂ¸aËœo 2.2.2, termos saËœo definidos recursivamente. Contudo o PVS
naËœo permite definicÂ¸oËœes de tipos recursivos, pois uma definicÂ¸aËœo ou declaracÂ¸aËœo de tipo em
um contexto deve conter somente sÂ´Ä±mbolos previamente declarados no contexto. Para
contornar esta situacÂ¸aËœo o PVS oferece o mecanismo chamado DATATYPE, que eÂ´ uma forma
de definicÂ¸aËœo de tipo recursivo. Para mais informacÂ¸oËœes sobre o mecanismo abstract datatype
do PVS veja [18]. Assim, a forma que se encontrou de especificar a nocÂ¸aËœo de termos em
PVS foi utilizando a ferramenta DATATYPE.
A especificacÂ¸aËœo de termos eÂ´ apresentada na sub-teoria term como abaixo:
term[variable: TYPE+, symbol: TYPE+, arity: [symbol -> nat]] : DATATYPE
BEGIN
vars(v: variable): vars?
app(f:symbol, args:{args:finite_sequence[term] | argsâ€˜length=arity(f)}): app?
END term
Note que os termos saËœo definidos como sendo uma variaÂ´vel, ou uma aplicacÂ¸aËœo de um
sÂ´Ä±mbolo f a um argumento args composto por uma sequeË†ncia finita de termos, sendo
que o sÂ´Ä±mbolo f tem aridade igual ao comprimento da sequeË†ncia de termos. Veja que a
chamada recursiva do DATATYPE eÂ´ promovida por args.
3.5 Sub-teorias da Teoria TRS 39
3.5.2 A Sub-teoria positions
A sub-teoria positions conteÂ´m a especificacÂ¸aËœo da nocÂ¸aËœo de conjunto de posicÂ¸oËœes de um
termo e formalizacÂ¸oËœes de algumas propriedades envolvendo posicÂ¸oËœes.
positionsOF(t: term): RECURSIVE positions =
(CASES t OF
vars(t): only_empty_seq,
app(f, st): IF length(st) = 0
THEN
only_empty_seq
ELSE
union(only_empty_seq,
IUnion((LAMBDA (i: upto?(length(st))):
catenate(i, positionsOF(st(i-1)) ))))
ENDIF
ENDCASES)
MEASURE t BY <<
Note que no construtor positionsOF, obtemos um tipo positions, que eÂ´ um conjunto
de posicÂ¸oËœes. Por sua vez, uma posicÂ¸aËœo eÂ´ definida como um tipo finseq[posnat], isto
eÂ´, uma sequeË†ncia finita de naturais. O conjunto de posicÂ¸oËœes de um termo, obtido pelo
construtor positionsOF, eÂ´ especificado conforme a DefinicÂ¸aËœo 2.2.3.
Dentre os lemas formalizados na sub-teoria positions, os mais importantes para o
desenvolvimento da sub-teoria unification e que foram mais diretamente usados nas
formalizacÂ¸oËœes apresentadas em unification foram os lemas positions_of_terms_finite
e positions_of_arg, cuja especificacÂ¸aËœo apresentamos abaixo:
positions_of_terms_finite : LEMMA is_finite(positionsOF(t))
positions_of_arg : LEMMA
FORALL ( (s : term | app?(s) ), k : below[length(args(s))] ) :
positionsOF(s)( #[posnat]( k+1 ) )
O primeiro estabelece que o conjunto de posicÂ¸oËœes de um termo eÂ´ finito. O segundo
estabelece que se um termo s eÂ´ uma aplicacÂ¸aËœo e se k eÂ´ um natural menor que o comprimento
da sequeË†ncia de argumentos do termo s, entaËœo k+1 pertence ao conjunto de posicÂ¸oËœes do
termo s.
3.5 Sub-teorias da Teoria TRS 40
3.5.3 A Sub-teoria subterm
Na sub-teoria subterm temos a especificacÂ¸aËœo da definicÂ¸aËœo de subtermo, encontrada na
DefinicÂ¸aËœo 2.2.4.
subtermOF(t: term, (p: positions?(t))): RECURSIVE term =
(IF length(p) = 0
THEN
t
ELSE
LET st = args(t),
i = first(p),
q = rest(p) IN
subtermOF(st(i-1), q)
ENDIF)
MEASURE length(p)
A especificacÂ¸aËœo do construtor subtermOF eÂ´ a principal desta teoria, contudo encontra-
mos a especificacÂ¸aËœo de outra definicÂ¸aËœo importante, a de conjunto de variaÂ´veis de um termo
t, denotado por Vars(t).
Temos tambeÂ´m na teoria subterm a formalizacÂ¸aËœo de vaÂ´rios resultados acerca de termos
e subtermos que foram largamente utilizados nas formalizacÂ¸oËœes da sub-teoria unification.
Por exemplo, temos a formalizacÂ¸aËœo dos lemas vars_of_term_finite e term_eq_subterm,
cuja especificacÂ¸aËœo apresentamos abaixo:
vars_of_term_finite: LEMMA is_finite(Vars(t))
term_eq_subterm : LEMMA
positionsOF(s)(p) AND subtermOF(s, p) = s IMPLIES p = empty_seq
O primeiro estabelece que o conjunto de variaÂ´veis de um termo eÂ´ finito. Este resultado
eÂ´ certo, pois como vimos os termos saËœo definidos como sendo finitos. O segundo estabelece
que se p pertence ao conjunto de posicÂ¸oËœes de um termo s e se o subtermo de s nesta posicÂ¸aËœo
eÂ´ o proÂ´prio s, entaËœo a posicÂ¸aËœo p eÂ´ a posicÂ¸aËœo raiz ou, como tratado na especificacÂ¸aËœo, eÂ´ uma
sequeË†ncia vazia.
3.5 Sub-teorias da Teoria TRS 41
3.5.4 A Sub-teoria substitution
Na sub-teoria substitution encontramos as especificacÂ¸oËœes que, de certa forma, saËœo as mais
importantes para o desenvolvimento da sub-teoria unification. Temos nesta subteoria a
especificacÂ¸aËœo das nocÂ¸oËœes de substituicÂ¸aËœo, domÄ±Â´nio e imagem de uma substituicÂ¸aËœo, conforme
apresentado na DefinicÂ¸aËœo 2.2.6, aleÂ´m da definicÂ¸aËœo de conjunto de variaÂ´veis da imagem de
uma substituicÂ¸aËœo.
Dom(sig): set[(V)] = {x: (V) | sig(x) /= x}
Ran(sig): set[term] =
{y: term | EXISTS (x: (V)): member(x, Dom(sig)) & y = sig(x)}
VRan(sig): set[(V)] = IUnion(LAMBDA (x | Dom(sig)(x)): Vars(sig(x)))
Sub?(sig): bool = is_finite(Dom(sig))
Observamos que sig eÂ´ uma variaÂ´vel declarada no preaË†mbulo da sub-teoria substitu-
tion como sendo do tipo [(V) -> term], isto eÂ´, sig eÂ´ uma aplicacÂ¸aËœo de um conjunto de
variaÂ´veis em um conjunto de termos, sem nenhuma restricÂ¸aËœo sobre estes conjuntos. Assim,
a forma escolhida para definir substituicÂ¸aËœo, foi definir um novo tipo Sub, que corresponde
a responder verdadeiro ou falso para a questaËœo de o domÄ±Â´nio de sig ser finito.
Temos ainda na sub-teoria substitution a especificacÂ¸aËœo da definicÂ¸aËœo de extensaËœo ho-
meomoÂ´rfica de uma substituicÂ¸aËœo a um conjunto de termos. Tal especificacÂ¸aËœo foi de grande
importaË†ncia para o desenvolvimento da sub-teoria unification.
3.5 Sub-teorias da Teoria TRS 42
ext(sigma)(t): RECURSIVE term =
CASES t OF
vars(t): sigma(t),
app(f, st): IF length(st) = 0
THEN t
ELSE
LET
sst = (# length := stâ€˜length,
seq := (LAMBDA (n: below[stâ€˜length]):
ext(sigma)(st(n)))#)
IN
app(f, sst)
ENDIF
ENDCASES
MEASURE t BY <<
Encontramos ainda nesta teoria a formalizacÂ¸aËœo de vaÂ´rios resultados sobre substituicÂ¸oËœes
que foram largamente aplicados durante as formalizacÂ¸oËœes da sub-teoria unification. Por
exemplo, temos alguns resultados importantes sobre composicÂ¸aËœo de substituicÂ¸oËœes:
subs_o: LEMMA Sub?(comp(sigma, tau))
ext_o: LEMMA ext(comp(sigma, tau)) = ext(sigma) o ext(tau)
o_ass: LEMMA comp(comp(sigma, delta), tau) = comp(sigma, comp(delta, tau))
O lema subs_o estabelece que a composicÂ¸aËœo de substituicÂ¸oËœes eÂ´ ainda uma substituicÂ¸aËœo.
O lema ext_o estabelece que a extensaËœo homeomoÂ´rfica de uma composicÂ¸aËœo de duas subs-
tituicÂ¸oËœes eÂ´ igual a` composicÂ¸aËœo das extensoËœes homeomoÂ´rficas das substituicÂ¸oËœes. O lema
o_ass estabelece que a composicÂ¸aËœo de substituicÂ¸oËœes eÂ´ associativa.
CapÂ´Ä±tulo 4
FormalizacÂ¸aËœo da Teoria de UnificacÂ¸aËœo
Neste capÂ´Ä±tulo vamos apresentar a especificacÂ¸aËœo da teoria unification, que construÂ´Ä±mos
buscando formalizar o teorema de existeË†ncia de unificadores mais gerais em teorias de pri-
meira ordem. Para tanto, especificamos uma funcÂ¸aËœo composta de treË†s construtores para
representar a versaËœo do algoritmo de unificacÂ¸aËœo de Robinson apresentada no CapÂ´Ä±tulo 2,
restrita a termos unificaÂ´veis. Na SecÂ¸aËœo 4.1, apresentamos a estrutura hieraÂ´rquica da teoria
unification. Na SecÂ¸aËœo 4.2, vamos explicar a organizacÂ¸aËœo desta teoria e os principais cons-
trutores especificados. Na SecÂ¸aËœo 4.3, apresentamos de maneira detalhada a formalizacÂ¸aËœo
do teorema que fala sobre a existeË†ncia de mguâ€™s, que eÂ´ baseado no fato de que o algoritmo
de unificacÂ¸aËœo computa unificadores mais gerais. Na SecÂ¸aËœo 4.4 apresentamos a formaliza-
cÂ¸aËœo dos lemas onde afirmamos que a substituicÂ¸aËœo, computada na especificacÂ¸aËœo proposta,
eÂ´ de fato um mgu de dois termos unificaÂ´veis. Na SecÂ¸aËœo 4.5, apresentamos a formalizacÂ¸aËœo
de lemas importantes, onde temos garantida a terminalidade do algoritmo de unificacÂ¸aËœo,
e que foram fundamentais para a formalizacÂ¸aËœo dos lemas da secÂ¸aËœo anterior. Com estes
teoremas provamos a completude da versaËœo do algoritmo de unificacÂ¸aËœo de Robinson.
4.1 Estrutura HieraÂ´rquica da Teoria unification
Nesta secÂ¸aËœo vamos apresentar a hierarquia da teoria unification, isto eÂ´, veremos so-
bre quais teorias a teoria unification foi construÂ´Ä±da. Na Figura 4.1.1, mostramos esta
estrutura hieraÂ´rquica, onde eÂ´ possÂ´Ä±vel observar quais sub-teorias da teoria trs foram
importadas pela sub-teoria unification, sendo que apenas a sub-teoria substitution eÂ´
importada diretamente. A teoria ars [7], representa um conjunto de sub-teorias para
43
4.2 OrganizacÂ¸aËœo da Teoria unification 44
Sistemas Abstratos de ReducÂ¸aËœo, a hierarquia desta teoria pode ser observada em [8]. As
teorias identity, finite_sets e finite_sequences, saËœo as teorias para definir a funcÂ¸aËœo
identidade, conjuntos finitos e sequeË†ncias finitas, respectivamante, importadas do preluÂ´dio
do PVS. Para mais informacÂ¸oËœes sobre a biblioteca do preluÂ´dio do PVS ver [20].
unification


substitution


identity extending_rename

compatibility
 
replacement

finite_sets ars[term]
subterm
 
IUnion_extra positions

oo

variables_term

finite_sequences_extras

term // finite_sequences
Figura 4.1.1: Estrutura hieraÂ´rquica da sub-teoria unification
4.2 OrganizacÂ¸aËœo da Teoria unification
A fim de especificar uma funcÂ¸aËœo que compute unificadores mais gerais para dois ter-
mos unificaÂ´veis, foram definidos separadamente treË†s construtores. Observe que estamos
considerando termos unificaÂ´veis, isto eÂ´, naËœo consideramos para esta especificacÂ¸aËœo o caso
de falha no processo de unificacÂ¸aËœo. Fazemos isto porque queremos demonstrar especifi-
camente que existe um mgu, computado via algoritmo de unificacÂ¸aËœo, para dois termos
unificaÂ´veis quaisquer, que eÂ´ o resultado necessaÂ´rio na formalizacÂ¸aËœo do teorema dos pares
crÂ´Ä±ticos de Knuth-Bendix [6]. Apresentamos a seguir a descricÂ¸aËœo destes construtores bem
como a especificacÂ¸aËœo de cada um. Depois apresentaremos brevemente as secÂ¸oËœes da teoria
unification onde formalizamos vaÂ´rias propriedades destes construtores.
4.2 OrganizacÂ¸aËœo da Teoria unification 45
Tabela 4.2.1: EspecificacÂ¸aËœo do construtor resolving_diff
resolving_diff(s : term, (t : term | unifiable(s,t) & s /= t ) ):
RECURSIVE position =
(CASES s OF
vars(s) : empty_seq,
app(f, st) :
IF length(st) = 0 THEN empty_seq
ELSE
(CASES t OF
vars(t) : empty_seq,
app(fp, stp) :
LET k : below[length(stp)] =
min({kk : below[length(stp)] |
subtermOF(s,#(kk+1)) /= subtermOF(t,#(kk+1))}) IN
add_first(k+1,
resolving_diff(subtermOF(s,#(k+1)),subtermOF(t,#(k+1))))
ENDCASES)
ENDIF
ENDCASES)
MEASURE s BY <<
resolving diff: Na Tabela 4.2.1 temos a estrutura da especificacÂ¸aËœo deste construtor,
que toma como paraË†metros dois termos unificaÂ´veis e diferentes s e t e retorna uma
posicÂ¸aËœo p, que eÂ´ a posicÂ¸aËœo onde ocorre a primeira diferencÂ¸a entre os termos s e t. Note
que neste construtor os termos do argumento de entrada devem ser, naËœo somente
unificaÂ´veis, mas tambeÂ´m diferentes, isto porque simplesmente naËœo faz sentido buscar
diferencÂ¸as em termos iguais. Esta posicÂ¸aËœo eÂ´ obtida buscando-se a diferencÂ¸a mais a
esquerda e mais externa entre os dois termos. Note que nesta posicÂ¸aËœo, se os termos
saËœo unificaÂ´veis, devemos ter que s|p eÂ´ uma variaÂ´vel ou t|p eÂ´ uma variaÂ´vel. Este
construtor age recursivamente e tem como medida a ordem bem-fundada <<, que
eÂ´ gerada automaticamente pela operacÂ¸aËœo de checagem de tipos (typechecking) da
sub-teoria term. Podemos interpretar esta medida como uma ordem de imersaËœo
de subtermos em termos, isto eÂ´, dado um termo finito s qualquer subtermo de s
tem comprimento menor que s, o que significa que a cardinalidade do conjunto
de posicÂ¸oËœes de qualquer subtermo de s eÂ´ menor que a cardinalidade do conjunto de
posicÂ¸oËœes de s, DefinicÂ¸aËœo 2.2.3. Isto torna a recursaËœo finita, pois consideramos termos
com um conjunto finito de posicÂ¸oËœes, segundo o lema positions_of_terms_finite
formalizado na sub-teoria positions.
4.2 OrganizacÂ¸aËœo da Teoria unification 46
Tabela 4.2.2: EspecificacÂ¸aËœo do construtor sub_of_frst_diff
sub_of_frst_diff(s:term, (t:term | unifiable(s,t) & s /= t )): Sub =
LET k : position = resolving_diff(s,t) IN
LET sp = subtermOF(s,k) , tp = subtermOF(t,k) IN
IF vars?(sp)
THEN (LAMBDA (x : (V)) : IF x = sp THEN tp ELSE x ENDIF)
ELSE (LAMBDA (x : (V)) : IF x = tp THEN sp ELSE x ENDIF)
ENDIF
sub of frst diff: Na Tabela 4.2.2 apresentamos a especificacÂ¸aËœo deste construtor, que
tambeÂ´m toma como argumentos dois termos unificaveÂ´is e diferentes s e t, e retorna
uma substituicÂ¸aËœo. O objetivo deste construtor eÂ´ computar uma substituicÂ¸aËœo que
resolva a primeira diferencÂ¸a entre os termos s e t. Isto eÂ´ feito a partir da posicÂ¸aËœo
computada pelo construtor resolving_diff. Portanto, se p = resolving_diff(s, t)
eÂ´ a posicÂ¸aËœo onde ocorre a primeira diferencÂ¸a mais a direita e mais externa entre
os termos s e t e se Ïƒ = sub_of_frst_diff(s, t), entaËœo ÏƒË†(s|p) = ÏƒË†(t|p). Veja que
os termos do argumento de entrada deste construtor tambeÂ´m devem ser diferentes,
jaÂ´ que partimos da posicÂ¸aËœo encontrada pelo construtor anterior. A forma como
obtemos esta substituicÂ¸aËœo neste construtor eÂ´ a seguinte: se p eÂ´ a posicÂ¸aËœo obtida
em resolving_diff(s, t), fazemos uma verificacÂ¸aËœo para saber se o subtermo s|p eÂ´
uma variaÂ´vel, digamos x, e caso o seja retorna-se uma substituicÂ¸aËœo que liga x ao
subtermo t|p, isto eÂ´, Ïƒ := {x/t|p}. Caso contraÂ´rio, devemos ter que o subtermo t|p
eÂ´ uma variaÂ´vel, digamos x, e neste caso a substituicÂ¸aËœo eÂ´ dada por Ïƒ := {x/s|p}.
unification algorithm: Apresentamos na Tabela 4.2.3 a especificacÂ¸aËœo deste construtor,
que toma como argumentos dois termos unificaÂ´veis s e t, e computa uma substi-
tuicÂ¸aËœo Ïƒ, que eÂ´ um mgu de s e t. Este fato estaÂ´ formalizado em dois lemas que
apresentamos na SecÂ¸aËœo 4.4. Note que agora naËœo exigimos que os termos sejam
diferentes, isto porque neste construtor estamos interessados em considerar a subs-
tituicÂ¸aËœo identidade, que eÂ´ claramente a substituicÂ¸aËœo que soluciona a equacÂ¸aËœo s
?
= t
quando temos s = t. Assim, no caso em que os termos s e t saËœo iguais, unifi-
cation_algorithm retorna a substituicÂ¸aËœo identidade, caso s e t sejam diferentes,
4.2 OrganizacÂ¸aËœo da Teoria unification 47
Tabela 4.2.3: EspecificacÂ¸aËœo do construtor unification_algorithm
unification_algorithm(s : term, (t : term | unifiable(s,t))) :
RECURSIVE Sub =
IF s = t THEN identity
ELSE LET sig = sub_of_frst_diff(s, t) IN
comp( unification_algorithm((ext(sig))(s) , (ext(sig)(t))) , sig)
ENDIF
MEASURE Card(union(Vars(s), Vars(t)))
unification_algorithm retorna uma substituicÂ¸aËœo dada pela composicÂ¸aËœo da substi-
tuicÂ¸aËœo obtida em sub_of_frst_diff, digamos Ïƒ1, com a substituicÂ¸aËœo dada por mais
um passo de unification_algorithm aplicado a ÏƒË†1(s) e ÏƒË†1(t). Portanto, se no k-
eÂ´simo passo o construtor retornar uma substituicÂ¸aËœo Ïƒ tal que ÏƒË†(s) = ÏƒË†(t), entaËœo
devemos ter Ïƒ = id â—¦ Ïƒk â—¦ . . . â—¦ Ïƒ1, onde
Ïƒj = unification_algorithm(ÏƒË†jâˆ’1(. . . ÏƒË†1(s)), ÏƒË†jâˆ’1(. . . ÏƒË†1(t))),
para j = 1, . . . , k. Isto significa que unification_algorithm age recursivamente
e esta recursaËœo eÂ´ finita pois adotamos como medida a cardinalidade do conjunto
Vars(s) âˆª Vars(t), que eÂ´ um conjunto finito, pois o conjunto de variaÂ´veis de um
termo finito eÂ´ finito, e a cada passo eliminamos uma variaÂ´vel de um conjunto finito
de variaÂ´veis. O fato de que para um termo s, Vars(s) eÂ´ finito estaÂ´ formalizado no
lema vars_of_term_finite da sub-teoria subterm.
Assim, com os treË†s construtores apresentados acima, especificamos uma funcÂ¸aËœo para
computar unificadores mais gerais de dois termos unificaÂ´veis. Mas eÂ´ preciso verificar que
a especificacÂ¸aËœo destes construtores estaÂ´ correta e que realmente obtemos um mgu com o
auxÂ´Ä±lio desta especificacÂ¸aËœo.
Para verificar que naËœo haÂ´ falhas na especificacÂ¸aËœo realizamos um procedimento de che-
cagem de tipos, invocado pela rotina type check prove. Ao realizar este procedimento o
PVS tenta verificar automaticamente obrigacÂ¸oËœes de prova geradas pelo typecheker, con-
tudo ocorrem casos em que estas obrigacÂ¸oËœes de prova saËœo geradas mas o provador do PVS eÂ´
incapaz de verificaÂ´-las automaticamente, pois ocorrem situacÂ¸oËœes em que uma estrateÂ´gia de
4.2 OrganizacÂ¸aËœo da Teoria unification 48
prova mais especifica e direcionada faz-se necessaÂ´ria. Nestes casos fazemos a verificacÂ¸aËœo de
tais obrigacÂ¸oËœes de prova, com o auxÂ´Ä±lio das ferramentas de prova que o PVS possui. Estas
obrigacÂ¸oËœes de prova, que tambeÂ´m podem surgir como sub-objetivos de prova durante uma
demonstracÂ¸aËœo, saËœo denominadas type correctness conditions (ou TCC), e surgem quando
um termo passa por uma checagem de tipos confrontada com um subtipo esperado de
predicado.
Para verificar que os treË†s construtores juntos realmente computam um mgu de dois
termos unificaÂ´veis foram formalizados vaÂ´rios teoremas auxiliares, onde provamos vaÂ´rias
propriedades sobre cada um dos construtores. Estes teoremas foram organizados em treË†s
secÂ¸oËœes da teoria unification da seguinte forma:
Lemmas about â€œresolving diffâ€: Como o proÂ´prio nome da secÂ¸aËœo sugere, demonstra-
mos aqui vaÂ´rios lemas sobre o construtor resolving_diff. Para demonstrar os
lemas desta secÂ¸aËœo foram fundamentais os TCCâ€™s gerados pela checagem de tipos
do construtor resolving_diff. Na Tabela 4.2.4, apresentamos a especificacÂ¸aËœo des-
tes lemas, e em seguida, comentamos brevemente em que consiste cada um deles.
Observe que em todos os lemas desta secÂ¸aËœo temos como hipoÂ´tese que os termos s
e t saËœo unificaÂ´veis e diferentes. Na descricÂ¸aËœo dos lemas feita a seguir, denotaremos
a posicÂ¸aËœo onde ocorre a primeira diferencÂ¸a entre os termo s e t por p, isto eÂ´, p =
resolving_diff(s, t).
resol_diff_nonempty_implies_funct_terms: Neste lema provamos que se p naËœo eÂ´ a
posicÂ¸aËœo raiz, entaËœo os dois termos saËœo funcionais.
resol_diff_to_rest_resol_diff: Este eÂ´ um lema construtivo, onde mostramos que
se p naËœo eÂ´ a posicÂ¸aËœo raiz e se p = i â—¦ q, entaËœo a primeira diferencÂ¸a entre os
subtermos s|i e t|i estaÂ´ na posicÂ¸aËœo q.
position_s_resolving_diff e position_t_resolving_diff: Nestes lemas provamos
que p âˆˆ Pos(s) e p âˆˆ Pos(t), respectivamente. Note que precisamos destes dois
lemas porque o termo t possui um tipo dependente em relacÂ¸aËœo ao termo s.
resolving_diff_has_diff_argument: Neste lema provamos que s|p 6= t|p. Note que
este lema eÂ´ importante, pois no construtor sub_of_frst_diff precisamos deste
4.2 OrganizacÂ¸aËœo da Teoria unification 49
Tabela 4.2.4: EspecificacÂ¸aËœo dos lemas sobre o construtor resolving_diff
resol_diff_nonempty_implies_funct_terms : LEMMA
FORALL (s: term, (t: term | unifiable(s, t) & s /= t)):
resolving_diff(s,t) /= empty_seq IMPLIES
(app?(s) AND app?(t))
resol_diff_to_rest_resol_diff : LEMMA
FORALL (s: term, (t: term | unifiable(s, t) & s /= t)):
LET rd = resolving_diff(s,t) IN
rd /= empty_seq IMPLIES
resolving_diff(subtermOF(s,#(first(rd))),
subtermOF(t,#(first(rd)))) = rest(rd)
position_s_resolving_diff : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t, p : position):
p = resolving_diff(s, t) IMPLIES positionsOF(s)(p);
position_t_resolving_diff : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t, p : position):
p = resolving_diff(s, t) IMPLIES positionsOF(t)(p);
resolving_diff_has_diff_argument : LEMMA
FORALL (s : term, t : term | unifiable(s,t) & s /= t,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
p = resolving_diff(s, t) IMPLIES
subtermOF(s, p) /= subtermOF(t, p)
resolving_diff_has_unifiable_argument : LEMMA
FORALL (s : term, t : term | unifiable(s,t) & s /= t,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
p = resolving_diff(s, t) IMPLIES
unifiable(subtermOF(s, p), subtermOF(t, p))
resolving_diff_vars : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
p = resolving_diff(s, t) IMPLIES
vars?(subtermOF(s, p)) OR vars?(subtermOF(t, p))
resultado, que aliaÂ´s surge como um TCC de sub_of_frst_diff.
resolving_diff_has_unifiable_argument: Neste lema provamos que s|p e t|p saËœo
unificaÂ´veis. Da mesma forma que o anterior, este lema tambeÂ´m eÂ´ importante,
pois no construtor sub_of_frst_diff precisamos deste resultado, que tambeÂ´m
surge como um TCC de sub_of_frst_diff.
resolving_diff_vars: Neste lema provamos que ou s|p eÂ´ uma variaÂ´vel, ou t|p eÂ´ uma
4.2 OrganizacÂ¸aËœo da Teoria unification 50
Tabela 4.2.5: EspecificacÂ¸aËœo de alguns lemas sobre o construtor sub_of_frst_diff
dom_sub_of_frst_diff_is : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t, sig : Sub):
sig = sub_of_frst_diff(s, t) AND p = resolving_diff(s, t)
IMPLIES
IF vars?(subtermOF(s, p))
THEN Dom(sig) = singleton(subtermOF(s, p))
ELSE Dom(sig) = singleton(subtermOF(t, p))
ENDIF
var_sub_1stdiff_not_member_term : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s ,t) IN
FORALL ( x | member(x,Dom(sig)), r | member(r,Ran(sig) )) :
NOT member(x, Vars(r))
sub_of_frst_diff_remove_x : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Dom(sig)(x) IMPLIES
(NOT member(x, Vars(ext(sig)(s)))) AND
(NOT member(x, Vars(ext(sig)(t))))
vars_sub_of_frst_diff_s_is_subset_union : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
subset?(Vars(ext(sig)(s)), union( Vars(s), Vars(t)))
vars_sub_of_frst_diff_t_is_subset_union : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
subset?(Vars(ext(sig)(t)), union( Vars(s), Vars(t)))
union_vars_ext_sub_of_frst_diff : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t) :
LET sig = sub_of_frst_diff(s, t) IN
union(Vars(ext(sig)(s)), Vars(ext(sig)(t)))
= difference(union( Vars(s), Vars(t)), Dom(sig))
variaÂ´vel. Trata-se de um resultado simples mas que precisamos formalizar.
Lemmas about â€œsub of frst diffâ€: Nesta secÂ¸aËœo, formalizamos lemas sobre o constru-
tor sub_of_frst_diff. Para demonstrar os lemas desta secÂ¸aËœo foi preciso formali-
zar alguns lemas auxiliares dispostos na secÂ¸aËœo denominada Auxiliary lemmas about
substitutions and unifiers, que encontram-se no ApeË†ndice A. Apresentamos nas
tabelas 4.2.5 e 4.2.6, a especificacÂ¸aËœo dos lemas sobre o construtor sub_of_frst_diff.
4.2 OrganizacÂ¸aËœo da Teoria unification 51
Tabela 4.2.6: EspecificacÂ¸aËœo dos principais lemas sobre o construtor sub_of_frst_diff
sub_of_frst_diff_unifier_o : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
member(rho, U(s, t)) IMPLIES
LET sig = sub_of_frst_diff(s, t) IN
EXISTS theta : rho = comp(theta, sig)
ext_sub_of_frst_diff_unifiable : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
unifiable(ext(sig)(s), (ext(sig)(t)))
vars_ext_sub_of_frst_diff_decrease : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Card(union( Vars(ext(sig)(s)), Vars(ext(sig)(t))))
< Card(union( Vars(s), Vars(t)))
Comentaremos aqui os lemas da Tabela 4.2.5, os lemas apresentados na Tabela 4.2.6
seraËœo descritos e comentados mais detalhadamente na SecÂ¸aËœo 4.5. PoreÂ´m, ressaltamos
que os lemas da Tabela 4.2.6, foram particularmente interessantes de demonstrar e
a formalizacÂ¸aËœo destes foi fundamental para concluÂ´Ä±rmos TCCâ€™s importantes sobre o
construtor unification_algorithm. Novamente, todos os lemas da Tabela 4.2.5 teË†m
como hipoÂ´tese que os termos s e t saËœo unificaÂ´veis e diferentes. Na descricÂ¸aËœo destes
lemas, feita a seguir, Ïƒ indicaraÂ´ a substituicÂ¸aËœo dada por sub_of_frst_diff(s, t) e p
a posicÂ¸aËœo dada por resolving_diff(s, t).
dom_sub_of_frst_diff_is: Neste lema formalizamos um resultado importante so-
bre o domÄ±Â´nio de Ïƒ, afirmamos que aleÂ´m de ser unitaÂ´rio, exitem apenas duas
possibilidades, ou Dom(Ïƒ) = {s|p} ou Dom(Ïƒ) = {t|p}.
var_sub_1stdiff_not_member_term: Neste lema provamos que se uma variaÂ´vel x eÂ´
tal que x âˆˆ Dom(Ïƒ) entaËœo para todo termo r, da imagem de Ïƒ, vale que x naËœo
pertence a Vars(r).
sub_of_frst_diff_remove_x: Neste lema afirmamos que os termos ÏƒË†(s) e ÏƒË†(t) naËœo
possuem ocorreË†ncias da variaÂ´vel x, que pertence ao domÄ±Â´nio de Ïƒ.
vars_sub_of_frst_diff_s_is_subset_union: Neste lema, provamos que o conjunto
Vars(ÏƒË†(s)) eÂ´ subconjunto da uniaËœo dos conjuntos Vars(s) e Vars(t).
4.2 OrganizacÂ¸aËœo da Teoria unification 52
Tabela 4.2.7: EspecificacÂ¸aËœo dos lemas sobre o construtor unification_algorithm
unification_algorithm_gives_unifier : LEMMA
unifiable(s,t) IMPLIES member(unification_algorithm(s, t), U(s, t))
unification_algorithm_gives_mg_subs : LEMMA
member(rho, U(s, t)) IMPLIES unification_algorithm(s, t) <= rho
vars_sub_of_frst_diff_t_is_subset_union: Neste lema formalizamos o mesmo re-
sultado do lema anterior para o termo t, isto eÂ´, mostramos que Vars(ÏƒË†(t)) eÂ´
um subconjunto de Vars(s) âˆª Vars(t).
union_vars_ext_sub_of_frst_diff: Neste lema provamos o fato de que o conjunto
Vars(ÏƒË†(s)) âˆª Vars(ÏƒË†(t)) eÂ´ exatamente igual ao conjunto Vars(s) âˆª Vars(t)
menos uma variaÂ´vel, aquela do domÄ±Â´nio de Ïƒ. Este lema juntamente com os
dois anteriores foram de grande importaË†ncia na formalizacÂ¸aËœo do lema deno-
minado vars_ext_sub_of_frst_diff_decrease (Tabela 4.2.6), o qual garante a
terminalidade do construtor unification_algorithm.
Lemmas about â€œunification algorithmâ€: Nesta secÂ¸aËœo formalizamos dois lemas sobre
o construtor unification_algorithm, onde provamos que a substituicÂ¸aËœo obtida em
unification_algorithm(s, t), sendo s e t dois termos unificaÂ´veis, eÂ´ de fato um mgu
de s e t. E estes dois lemas saËœo o ponto de partida para provar o uÂ´ltimo teorema
que formalizamos, o que garante a existeË†ncia de mguâ€™s para dois termos unificaÂ´veis
e cuja formalizacÂ¸aËœo apresentamos e discutimos na SecÂ¸aËœo 4.3. Na Tabela 4.2.7, apre-
sentamos a especificacÂ¸aËœo desta secÂ¸aËœo. Na SecÂ¸aËœo 4.4 apresentamos a formalizacÂ¸aËœo
destes lemas e aqui uma breve descricÂ¸aËœo de cada um.
unification_algorithm_gives_unifier: Neste provamos que a substituicÂ¸aËœo dada
por unification_algorithm(s, t) eÂ´ um unificador de s e t.
unification_algorithm_gives_mg_subs: Neste provamos que a substituicÂ¸aËœo dada
por unification_algorithm(s, t) eÂ´ mais geral que qualquer substituicÂ¸aËœo que
seja unificador de s e t.
4.3 FormalizacÂ¸aËœo do Teorema Sobre a ExisteË†ncia de mguâ€™s 53
Ainda temos na parte inicial da teoria unification especificacÂ¸oËœes de conceitos impor-
tantes onde definimos elementos fundamentais em teoria de unificacÂ¸aËœo. Tais definicÂ¸oËœes saËœo
as de instaË†ncia de um termo, substituicÂ¸aËœo mais geral, unificacÂ¸aËœo entre dois termos, mgu
aleÂ´m de lemas auxiliares, onde demonstramos que dois termos, funcionais e unificaÂ´veis,
teË†m o mesmo sÂ´Ä±mbolo de funcÂ¸aËœo na posicÂ¸aËœo raiz e o mesmo nuÂ´mero de argumentos. EÂ´
possÂ´Ä±vel observar o coÂ´digo da especificacÂ¸aËœo destes conceitos no ApeË†ndice A. AleÂ´m disso,
foi necessaÂ´rio formalizar outros lemas que, por uma questaËœo de organizacÂ¸aËœo, foram espe-
cificados nas sub-teorias position, substitution e subterm.
Nas secÂ¸oËœes seguintes discutiremos os lemas mais importantes desta especificacÂ¸aËœo, apre-
sentando as suas formalizacÂ¸oËœes.
4.3 FormalizacÂ¸aËœo do Teorema Sobre a ExisteË†ncia de
mguâ€™s
Nesta secÂ¸aËœo vamos apresentar a formalizacÂ¸aËœo do teorema principal deste trabalho. O
teorema unification, que afirma que quaisquer dois termos unificaÂ´veis possuem um uni-
ficador mais geral. A especificacÂ¸aËœo deste teorema encontra-se na secÂ¸aËœo Existence of a
most general unifier da teoria unification. Vejamos abaixo a especificacÂ¸aËœo deste teo-
rema.
unification : LEMMA
unifiable(s,t) => EXISTS theta : mgu(theta)(s,t)
Em seguida vamos enunciar o teorema e apresentar a formalizacÂ¸aËœo de sua prova. Na
Figura 4.3.1 mostramos a aÂ´rvore da prova do teorema unification, onde eÂ´ possÂ´Ä±vel vi-
sualizar de mareira mais intuitiva a estrutura da demonstracÂ¸aËœo do teorema. Na aÂ´rvore
o sÂ´Ä±mbolo ` representa o sequente que temos num dado momento da prova. As regras
de prova adotadas saËœo enunciadas ao longo das arestas da aÂ´rvore, posicionadas depois de
cada sequente que antecede a sua aplicacÂ¸aËœo.
4.3 FormalizacÂ¸aËœo do Teorema Sobre a ExisteË†ncia de mguâ€™s 54
` [raiz]
(skeep)
` [1]
(inst 1 â€œunification algorithm(s,t)â€)
` [2]
(expand â€œmguâ€)
` [3]
(split)
RRRR
RRRR
RRR
mmm
mmm
mmm
m
[4] ` ` [5]
(rewrite â€œunification algorithm gives unifierâ€) (skeep)
` [6]
(rewrite â€œunification algorithm gives mg subsâ€)
Figura 4.3.1: AÂ´rvore de prova do teorema unification.
Teorema 4.3.1: Sejam s e t dois termos unificaÂ´veis, entaËœo existe uma substituicÂ¸aËœo Î¸ que
eÂ´ um mgu de s e t.
Na demonstracÂ¸aËœo deste teorema, utilizamos os lemas sobre o construtor unifica-
tion_algorithm, intitulados unification_algorithm_gives_unifier e unification_algo-
rithm_gives_mg_subs, cuja formalizacÂ¸aËœo apresentaremos na SecÂ¸aËœo 4.4. A utilizacÂ¸aËœo destes
dois lemas torna a demonstracÂ¸aËœo do Teorema 4.3.1 bastante simples. Isto porque no
Teorema 4.3.1 mostramos apenas que dois termos unificaÂ´veis teË†m um mgu, que eÂ´ obtido
via algoritmo de unificacÂ¸aËœo. O fato de que o algoritmo de unificacÂ¸aËœo realmente computa
um mgu, eÂ´ mostrado nos dois lemas que utilizamos nesta prova. EntaËœo vamos apresentar
em detalhes a prova formal do teorema unification.
DemonstracÂ¸aËœo: ComecÂ¸amos a demonstracÂ¸aËœo com o seguinte objetivo de prova,
4.3 FormalizacÂ¸aËœo do Teorema Sobre a ExisteË†ncia de mguâ€™s 55
â€¢ Sequente representado pelo noÂ´ [raiz],
|-------
{1} FORALL (s, t: term[variable, symbol, arity]):
unifiable(s, t) => (EXISTS theta: mgu(theta)(s, t))
Este objetivo eÂ´ o teorema que queremos demonstrar, ou seja, o objetivo principal que
na aÂ´rvore (Figura 4.3.1) de prova estaÂ´ representado pelo noÂ´ [raiz]. O primeiro comando
de prova utilizado eÂ´ o skeep, da biblioteca do PVS Field. Este comando eÂ´ usado para
skolemizar as variaÂ´veis das foÂ´rmulas quantificadas universalmente. Contudo skeep naËœo
introduz novos nomes para constantes, ele manteÂ´m os nomes das variaÂ´veis ligadas. Assim,
depois de aplicar a regra skeep, obtivemos o seguinte sequente:
â€¢ Sequente representado pelo noÂ´ [1],
{-1} unifiable(s, t)
|-------
{1} EXISTS theta: mgu(theta)(s, t)
A este sequente aplicamos a regra (inst 1 â€œunification_algorithm(s, t))â€, que tal-
vez seja a mais importante desta prova, pois fica claro como faremos a demonstracÂ¸aËœo deste
teorema, jaÂ´ que neste momento instanciamos a foÂ´rmula 1 com a substituicÂ¸aËœo obtida pela
aplicacÂ¸aËœo de unification_algorithm aos termos s e t. Isto eÂ´, estamos lancÂ¸ando maËœo do
fato, previamente demonstrado na teoria unification, mas que aqui seraÂ´ apresentado na
SecÂ¸aËœo 4.4, de que unification_algorithm computa unificadores mais gerais. DaÂ´Ä± temos o
sequente:
â€¢ Sequente representado pelo noÂ´ [2],
[-1] unifiable(s, t)
|-------
{1} mgu(unification_algorithm(s, t))(s, t)
Logo em seguida utilizamos a regra (expandâ€œmguâ€), onde expandimos a definicÂ¸aËœo de mgu,
o que nos direciona para a utilizacÂ¸aËœo dos lemas sobre o construtor unification_algorithm.
E temos o sequente:
4.3 FormalizacÂ¸aËœo do Teorema Sobre a ExisteË†ncia de mguâ€™s 56
â€¢ Sequente representado pelo noÂ´ [3],
[-1] unifiable(s, t)
|-------
{1} member(unification_algorithm(s, t), U(s, t)) &
(FORALL tau: member(tau, U(s, t))
IMPLIES unification_algorithm(s, t) <= tau)
Neste ponto, afim de dividir a prova da conjugacÂ¸aËœo do sucedente, utilizamos o comando
de prova split, que seleciona e divide uma foÂ´rmula conjuntiva, neste caso a foÂ´rmula
selecionada eÂ´ a foÂ´rmula 1 do sequente representado pelo noÂ´ [3].
Depois da aplicacÂ¸aËœo da regra split, a aÂ´rvore de prova se divide em dois ramos, isto
significa que a partir deste ponto da prova temos dois sub-objetivos de prova. O primeiro
onde temos que provar que a substituicÂ¸aËœo dada por unification_algorithm eÂ´ um unifica-
dor dos termos s e t e o segundo onde temos que provar que esta mesma substituicÂ¸aËœo eÂ´
mais geral do que qualquer outra substituicÂ¸aËœo que seja um unificador dos termos s e t, mas
como jaÂ´ mencionamos anteriormente, estes dois fatos foram previamente formalizados na
teoria como resultados dos lemas que seraËœo apresentados nas secÂ¸oËœes 4.4.1 e 4.4.2.
Assim, no sequente representado pelo noÂ´ [4], temos que provar que a substituicÂ¸aËœo dada
por unification_algorithm(s, t) eÂ´ um unificador de s e t.
â€¢ Sequente representado pelo noÂ´ [4],
[-1] unifiable(s, t)
|-------
{1} member(unification_algorithm(s, t), U(s, t))
Mas este eÂ´ o resultado do lema unification_algorithm_gives_unifier. Portanto a
regra de prova aplicada a este sequente eÂ´ (rewrite â€œunification_algorithm_gives_uni-
fier)â€, onde o comando de prova rewrite tenta determinar automaticamente as instan-
ciacÂ¸oËœes necessaÂ´rias para combinar a conclusaËœo do lema com as expressoËœes das foÂ´rmulas
que estamos tentando reescrever. ApoÂ´s este comando o provador encontra a devida ins-
tanciacÂ¸aËœo e completa este ramo da prova, isto eÂ´, a folha deste ramo da aÂ´rvore torna-se
verdadeira.
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 57
EntaËœo, automaticamente passamos ao proÂ´ximo objetivo da prova, expresso no sequente
representado pelo noÂ´ [5], onde temos que provar que a substituicÂ¸aËœo dada por unifica-
tion_algorithm(s, t) eÂ´ uma substituicÂ¸aËœo que eÂ´ mais geral do que qualquer outra substi-
tuicÂ¸aËœo que seja um unificador dos termos s e t.
â€¢ Sequente representado pelo noÂ´ [5],
[-1] unifiable(s, t)
|-------
{1} FORALL tau: member(tau, U(s, t))
IMPLIES unification_algorithm(s, t) <= tau
Note que neste sequente a foÂ´rmula 1 eÂ´ universalmente quantificada, portanto o primeiro
comando de prova que aplicamos eÂ´ skeep, o que nos leva ao uÂ´ltimo objetivo da prova, o
sequente representado pelo noÂ´ [6].
â€¢ Sequente representado pelo noÂ´ [6].
{-1} member(tau, U(s, t))
[-2] unifiable(s, t)
|-------
{1} unification_algorithm(s, t) <= tau
Neste ponto, utilizamos novamente o comando de prova rewrite, aplicando o lema
unification_algorithm_gives_mg_subs. Novamente o provador faz a instanciacÂ¸aËœo neces-
saÂ´ria automaticamente e completa este ramo da prova. Com isto completamos a prova
deste teorema.
Completar a aÂ´rvore de prova significa concluir que todas as folhas da aÂ´rvore saËœo ver-
dadeiras. Logo temos uma prova do objetivo principal da prova, representado pelo noÂ´
[raiz]. Portanto, mostramos que se s e t saËœo dois termos unificaÂ´veis, entaËœo existe uma
substituicÂ¸aËœo que eÂ´ um unificador mais geral de s e t.
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor uni-
fication_algorithm
Apresentamos a formalizacÂ¸aËœo dos lemas onde verificamos que a substituicÂ¸aËœo computada
pelo algoritmo de unificacÂ¸aËœo eÂ´ solucÂ¸aËœo do dado problema de unificacÂ¸aËœo e que eÂ´ mais
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 58
geral. Tratam-se dos lemas aplicados diretamente na formalizacÂ¸aËœo do Teorema 4.3.1.
Estes lemas correspondem aos teoremas sobre correcÂ¸aËœo e generalidade do algoritmo de
unificacÂ¸aËœo apresentados na SecÂ¸aËœo 2.2.3.
4.4.1 Lema unification_algorithm_gives_unifier
Nesta secÂ¸aËœo apresentamos a formalizacÂ¸aËœo de um dos lemas sobre o construtor unificati-
on_algorithm, onde provamos que a substituicÂ¸aËœo computada por este construtor aplicado
a dois termos unificaÂ´veis, eÂ´ um unificador destes dois temos. Na Tabela 4.2.7 temos a
especificacÂ¸aËœo deste lema. Este lema corresponde ao Teorema 2.2.16, onde provamos que
o algoritmo de unificacÂ¸aËœo eÂ´ correto. Apresentamos a aÂ´rvore de prova deste lema dividida
nas figuras 4.4.1 e 4.4.2.
Lema 4.4.1: Seja Ïƒ = unification algorithm(s, t), onde s e t saËœo dois termos unifi-
caÂ´veis, entaËœo temos que Ïƒ eÂ´ um unificador de s e t.
` [raiz]
(measure-induct+ â€œCard(union(Vars(s), Vars(t)))â€ (â€œsâ€â€œtâ€))
Figura 4.4.2 ` [7] ?
(hide-all-but 1)
`
(rewrite â€œfinite union[(V)]â€)
fffff
fffff
fffff
f
XXXXX
XXXXX
XXXXX
X
` `
(rewrite â€œvars of term finiteâ€) (rewrite â€œvars of term finiteâ€)
Figura 4.4.1: InÂ´Ä±cio da aÂ´rvore de prova do Lema 4.4.1. Os ramos denotados por ?, que saËœo dois, saËœo
ideË†nticos ao ramo abaixo do noÂ´ [7]. Tais ramos saËœo gerados pela operacÂ¸aËœo de checagem de tipos. O ramo
principal da prova consta da Figura 4.4.2.
DemonstracÂ¸aËœo: Assim, como na apresentacÂ¸aËœo anterior, comecÂ¸amos expondo a aÂ´rvore
de prova gerada pelo PVS. Como jaÂ´ comentamos, dividimos a aÂ´rvore de prova em duas
figuras. Na Figura 4.4.1, mostramos o topo da aÂ´rvore de prova, onde eÂ´ possÂ´Ä±vel visualizar o
noÂ´ [raiz] e o inÂ´Ä±cio das ramificacÂ¸oËœes obtidas pela aplicacÂ¸aËœo da primeira regra utilizada. Na
Figura 4.4.2, mostramos o ramo principal da aÂ´rvore de prova, onde se daÂ´ a formalizacÂ¸aËœo
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 59
do lema propriamente. Os outros ramos, que podemos visualizar na Figura 4.4.1, saËœo
provenientes da checagem de tipos realizada pelo PVS.
Note que no construtor unification_algorithm utilizamos como medida a cardinali-
dade do conjunto dado pela uniaËœo dos conjuntos de variaÂ´veis dos termos s e t, denotada
por: Card(union(Vars(s), Vars(t))). Portanto, a demonstracÂ¸aËœo deste lema seguiraÂ´ por
inducÂ¸aËœo nesta medida. Vamos expor a formalizacÂ¸aËœo deste lema apresentando alguns obje-
tivos de prova, como saËœo mostrados na interface do PVS, fazendo em seguida uma breve
explicacÂ¸aËœo do objetivo e das regras aplicadas a este. O objetivo inicial eÂ´ apresentado da
seguinte forma:
â€¢ Sequente representado pelo noÂ´ [raiz].
|-------
{1} FORALL (s, t: term[variable, symbol, arity]):
unifiable(s, t) IMPLIES
member(unification_algorithm(s, t), U(s, t))
A este objetivo aplicamos a regra measure-induct+ sobre a cardinalidade da uniaËœo do
conjunto de variaÂ´veis dos termos, que quer dizer que a nossa estrateÂ´gia de prova eÂ´ fazer
inducÂ¸aËœo na medida â€œCard(union(Vars(s), Vars(t)))â€. A aplicacÂ¸aËœo desta regra nos leva a
treË†s sub-objetivos: o primeiro deles eÂ´ o nosso objetivo principal, onde provamos por casos
o lema propriamente dito; os dois outros sub-objetivos saËœo resultado de uma checagem de
tipos realizada pelo PVS, onde temos que provar que o conjunto union(Vars(s), Vars(t))
eÂ´ finito.
Assim, no primeiro destes sub-objetivos, provamos a hipoÂ´tese do lema, que seraÂ´ feita
por casos. Este sub-objetivo se apresenta da seguinte forma:
â€¢ Sequente representado pelo noÂ´ [1].
{-1} FORALL (y_1: term[variable, symbol, arity]),
(y_2: term[variable, symbol, arity]):
Card(union(Vars(y_1), Vars(y_2))) <
Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
unifiable(y_1, y_2) IMPLIES
member(unification_algorithm(y_1, y_2), U(y_1, y_2))
{-2} unifiable(x!1, x!2)
|-------
{1} member(unification_algorithm(x!1, x!2), U(x!1, x!2))
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 60
Figura 4.4.1
` [1]
(case â€œx!1 = x!2â€)
fffff
ffff
\\\\\\\\\\\
\\\\\\\\\\\
\\\\
[2] ` ` [4]
(hide -2 -3)
(inst -1 â€œext(sub of frst diff(x!1, x!2))(x!1)â€
â€œext(sub of frst diff(x!1, x!2))(x!2)â€)
ggggg
ggg KKK
` ` `
(expand â€œunification algorithmâ€)
(lemma
â€œvars ext sub of frst diff decreaseâ€)
(assert)
` `
(assert) (inst -1 â€œx!1â€â€œx!2â€)
YYYYYY
YYYY
ffffff
fff
` ` `
(assert) (assert)
(expand* â€œmemberâ€â€œUâ€â€œunifierâ€) `
[3] ` (hide -1)
(assert) `
(lemma â€œext sub of frst diff unifiableâ€)
`
(inst -1 â€œx!1â€â€œx!2â€)
`
(assert)
`
(hide -1)
` [5]
(lema â€œunifier oâ€)
`
(inst -1 â€œx!1â€â€œunification algorithm(
ext(sub of frst diff(x!1, x!1))(x!1),
ext(sub of frst diff(x!1, x!1))(x!2))â€
â€œx!2â€â€œsub of frst diff(x!1, x!2)â€)
`
(assert)
`
(hide -2)
` [6]
(expand â€œunification algorithmâ€ 2)
`
(propax)
Figura 4.4.2: Ramo principal da aÂ´rvore do prova do Lema 4.4.1. A parte inicial da aÂ´rvore consta da
Figura 4.4.1.
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 61
Neste sequente temos a hipoÂ´tese de inducÂ¸aËœo dada pelo antecedente -1, aleÂ´m da hipoÂ´tese
de que os termos x!1 e x!2 saËœo unificaÂ´veis, e o nosso objetivo eÂ´ provar o consequente 1.
Neste ponto da prova aplicamos a regra â€œcaseâ€ que nos leva a considerar dois casos. O
primeiro caso onde â€œx!1 = x!2â€, e no segundo o caso onde â€œx!1 6= x!2â€.
Vejamos rapidamente o primeiro caso, onde â€œx!1 = x!2â€, apresentado pelo provador
do PVS na forma do seguinte sequente:
â€¢ Sequente representado pelo noÂ´ [2].
{-1} x!1 = x!2
[-2] FORALL (y_1: term[variable, symbol, arity]),
(y_2: term[variable, symbol, arity]):
Card(union(Vars(y_1), Vars(y_2))) <
Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
unifiable(y_1, y_2) IMPLIES
member(unification_algorithm(y_1, y_2), U(y_1, y_2))
[-3] unifiable(x!1, x!2)
|-------
[1] member(unification_algorithm(x!1, x!2), U(x!1, x!2))
Neste sequente comecÂ¸amos aplicando a regra (hide -2 -3), onde escondemos as foÂ´r-
mulas -2 e -3, pois elas naËœo seraËœo necessaÂ´rias na demonstracÂ¸aËœo deste ramo da prova.
Assim obtemos um sequente simplificado onde temos apenas as foÂ´rmulas -1 e 1. Neste
ponto da prova utilizamos a estrateÂ´gia de expandir as definicÂ¸oËœes de â€œmemberâ€, â€œunifica-
tion_algorithmâ€, â€œUâ€ e â€œunifierâ€, onde â€œunifierâ€ aparece quando expandimos â€œUâ€. Assim,
obtemos o seguinte sequente:
â€¢ Sequente representado pelo noÂ´ [3]
[-1] x!1 = x!2
|-------
{1} ext(identity)(x!1) = ext(identity)(x!2)
Se olharmos na especificacÂ¸aËœo do construtor unification_algorithm, apresentada na
Tabela 4.2.3, veremos que para x!1 = x!2 este construtor retorna substituicÂ¸aËœo identidade.
DaÂ´Ä±, obtemos na foÂ´rmula 1 a negacÂ¸aËœo do fato de a substituicÂ¸aËœo identidade pertencer ao
conjunto dos unificadores de x!1 e x!2. Mas isto nos leva a uma contradicÂ¸aËœo, visto
que na foÂ´rmula -1 temos que x!1 = x!2. Portanto com a regra assert, que emprega
procedimentos de decisaËœo para simplificar as foÂ´rmulas, completamos este ramo da prova.
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 62
Vejamos agora o caso em que â€œx!1 6= x!2â€. Aqui comecÂ¸amos com o seguinte objetivo
de prova:
â€¢ Sequente representado pelo noÂ´ [4]
[-1] FORALL (y_1: term[variable, symbol, arity]),
(y_2: term[variable, symbol, arity]):
Card(union(Vars(y_1), Vars(y_2))) <
Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
unifiable(y_1, y_2) IMPLIES
member(unification_algorithm(y_1, y_2), U(y_1, y_2))
[-2] unifiable(x!1, x!2)
|-------
{1} x!1 = x!2
[2] member(unification_algorithm(x!1, x!2), U(x!1, x!2))
Neste primeiro sequente deste ramo da prova, note que temos a hipoÂ´tese que diferencia
este caso do anterior na foÂ´rmula 1, que por estar no consequente representa a negacÂ¸aËœo de
â€œx!1 = x!2â€. AleÂ´m disso, temos a hipoÂ´tese de inducÂ¸aËœo na foÂ´rmula -1. Neste ponto da prova,
vamos instanciar a foÂ´rmula -1 com os termos â€œext(sub_of_frst_diff(x!1, x!2))(x!1)â€ e
â€œext(sub_of_frst_diff(x!1, x!2))(x!2)â€. Assim, temos que se
Card(union( Vars(ext(sub_of_frst_diff(x!1, x!2))x!1),
Vars(ext(sub_of_frst_diff(x!1, x!2))x!2) ))
< Card(union( Vars(x!1), Vars(x!2) ))
e se os termos
ext(sub_of_frst_diff(x!1, x!2))x!1 e ext(sub_of_frst_diff(x!1, x!2))x!1
saËœo unificaÂ´veis, entaËœo a substituicÂ¸aËœo dada por
unification_algorithm( ext(sub_of_frst_diff(x!1, x!2)),
ext(sub_of_frst_diff(x!1, x!2)) )
eÂ´ um unificador destes termos.
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 63
Mas estes dois resultados estaËœo previamente formalizados na teoria. Tratam-se dos
lemas vars_ext_sub_of_frst_diff_decrease e ext_sub_of_frst_diff_unifiable da secÂ¸aËœo
Lemmas aboutâ€œsub_of_frst_diffâ€ da teoria unification, cuja formalizacÂ¸aËœo apresentamos
na SecÂ¸aËœo 4.5 e cuja especificacÂ¸aËœo apresentamos na Tabela 4.2.6. Assim, apoÂ´s alguns passos
de prova, onde fazemos a instanciacÂ¸aËœo jaÂ´ mencionada e realizamos alguns procedimentos
de simplificacÂ¸aËœo, obtemos o seguinte sequente de prova:
â€¢ Sequente representado pelo noÂ´ [5].
[-1] member(unification_algorithm(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2)),
U(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2)))
[-2] unifiable(x!1, x!2)
|-------
[1] x!1 = x!2
[2] member(unification_algorithm(x!1, x!2), U(x!1, x!2))
Neste uÂ´ltimo sequente, temos que a foÂ´rmula -1 e a foÂ´rmula 2, saËœo equivalentes. Apenas
temos que nos dar conta do fato de que dadas duas substituicÂ¸oËœes Î± e Î², e dois termos
unificaÂ´veis s e t, se Î± eÂ´ um unificador de Î²Ì‚(s) e Î²Ì‚(t), entaËœo a composicÂ¸aËœo Î± â—¦ Î² eÂ´ um
unificador de s e t. Este resultado estaÂ´ demonstrado no lema unifier_o da secÂ¸aËœo Auxiliary
lemmas about substitutions and unifiers, cuja formalizacÂ¸aËœo apresentamos no ApeË†ndice
A, que vamos aplicar neste momento da prova. Assim, utilizando este lema, fazendo as
devidas instanciacÂ¸oËœes, e apoÂ´s alguns passos de prova para simplificar obtemos o seguinte:
â€¢ Sequente representado pelo noÂ´ [6]
[-1] member(comp(unification_algorithm(
ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2)),
sub_of_frst_diff(x!1, x!2)),
U(x!1, x!2))
|-------
[1] x!1 = x!2
[2] member(unification_algorithm(x!1, x!2), U(x!1, x!2))
Note que agora estaÂ´ clara a equivaleË†ncia entre as foÂ´rmulas -1 e 2. Assim, neste ponto
expandimos a definicÂ¸aËœo de unification_algorithm e com isto completamos este ramo da
prova, desde que x!1 6= x!2.
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 64
Tendo completado a formalizacÂ¸aËœo dos dois ramos de prova gerados pela aplicacÂ¸aËœo
da regra case â€œx!1 = x!2â€, completamos o ramo principal da prova. Ressaltamos que
nestes dois ramos da prova, omitimos alguns sub-objetivos de prova, que temos que provar
principalmente quando usamos a estrateÂ´gia de aplicar um outro lema da teoria, pois nestes
casos o PVS gera sub-objetivos de prova onde temos que verificar assercÂ¸oËœes acerca do tipo
das variaÂ´veis usadas para instanciar os lemas utilizados.
Nos dois ramos seguintes da prova, como jaÂ´ mencionamos anteriormente, temos que
provar que os termos estaËœo bem tipados. Temos dois objetivos de prova, onde â€œquestiona-
seâ€ sobre a finitude da uniaËœo dos conjuntos de variaÂ´veis dos termos, isto eÂ´, temos que
provar que, dados dois termos s e t entaËœo V ars(s) âˆª V ars(t) eÂ´ um conjunto finito.
A demonstracÂ¸aËœo destes dois ramos, novamente segue pela aplicacÂ¸aËœo de dois outros
lemas, um da teoria finite_sets do preluÂ´dio do PVS, denominado finite_union, que
diz que a uniaËœo de dois conjuntos finitos eÂ´ ainda um conjunto finito. Mas ao aplicar
este lema somos levados a provar que os conjuntos de variaÂ´veis dos dois termos em ques-
taËœo saËœo conjuntos finitos, e isto segue de um outro lema da teoria subterm denominado
vars_of_term_finite, que afirma que o conjunto de variaÂ´veis de um termo eÂ´ finito. Assim,
para ilustrar o que acabamos de explicar, apresentamos a seguir o objetivo de um destes
ramos da prova. O outro ramo prova-se com a mesma sequeË†ncia de comandos de prova.
Temos o seguinte sequente inicial:
â€¢ Sequente representado pelo noÂ´ [7]
|-------
{1} is_finite[(V)]
(union[((V))]
(Vars[variable, symbol, arity](s!1),
Vars[variable, symbol, arity](t!1)))
[2] FORALL (s, t: term[variable, symbol, arity]):
unifiable(s, t) IMPLIES
member(unification_algorithm(s, t), U(s, t))
A este sequente aplicamos os lemas mencionados acima, realizamos os procedimentos
de prova necessaÂ´rios para encontrar as devidas instanciacÂ¸oËœes, realizamos as simplificacÂ¸oËœes
necessaÂ´rias e com isto concluÂ´Ä±mos este ramo da prova.
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 65
Tendo completado a formalizacÂ¸aËœo dos ramos de prova gerados pela aplicacÂ¸aËœo da re-
gra measure-induct+â€œCard(union(Vars(s), Vars(t)))â€(â€œsâ€â€œtâ€), concluÂ´Ä±mos a prova do
lema.
4.4.2 Lema unification_algorithm_gives_mg_subs
Nesta secÂ¸aËœo apresentamos a formalizacÂ¸aËœo do lema sobre o construtor unification_algo-
rithm, onde provamos que a substituicÂ¸aËœo computada por este construtor aplicado a dois
termos unificaÂ´veis, eÂ´ uma substituicÂ¸aËœo mais geral que qualquer outra substituicÂ¸aËœo que
seja um unificador destes dois temos. Na Tabela 4.2.7 temos a especificacÂ¸aËœo deste lema.
Este lema corresponde ao Teorema 2.2.17, onde provamos a generalidade da substituicÂ¸aËœo
computada pelo algoritmo de unificacÂ¸aËœo. Apresentamos a aÂ´rvore de prova deste lema nas
figuras 4.4.3, 4.4.4 e 4.4.5.
` [raiz]
(measure-induct+ â€œCard(union(Vars(s), Vars(t)))â€ (â€œsâ€â€œtâ€))
ZZZZZZZZ
ZZZZZZZZ
ZZZZZZZZ
ZZ
Figura 4.4.4 ` ` [13] ?
(hide-all-but (-1 1)) (hide -1 2)
[12] ` `
(expand â€œmemberâ€â€œUâ€â€œunifiableâ€) (rewrite â€œfinite union[(V)]â€)
mmm
mmm
mm
QQQ
QQQ
QQ
` ` `
(inst 1 â€œrho!1â€)
(rewrite
â€œvars of term finiteâ€)
(rewrite
â€œvars of term finiteâ€)
Figura 4.4.3: InÂ´Ä±cio da aÂ´rvore de prova do Lema 4.4.2. A ramificacÂ¸aËœo denotada por ? representa outros
dez sub-objetivos de prova gerados pelo typechecker. Tais objetivos saËœo provados ou da mesma forma que
o ramo abaixo do noÂ´ [12] ou da mesma forma que o ramo abaixo do noÂ´ [13]. O ramo principal consta das
figuras 4.4.4 e 4.4.5.
Lema 4.4.2: Sejam Ïƒ = unification algorithm(s, t) e Î¸ âˆˆ U(s, t), onde s e t saËœo dois
termos unificaÂ´veis, entaËœo existe uma substituicÂ¸aËœo Î´ tal que Î¸ = Î´ â—¦ Ïƒ.
DemonstracÂ¸aËœo: Similarmente ao que foi feito na formalizacÂ¸aËœo do Lema 4.4.1, tambeÂ´m
neste lema a prova se daraÂ´ por inducÂ¸aËœo na medida Card(union(Vars(s),Vars(t))). Assim,
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 66
temos o seguinte objetivo inicial de prova, sobre o qual invocamos o comando de prova
measure-induct+:
â€¢ Sequente representado pelo noÂ´ [raiz].
|-------
{1} FORALL (rho: Sub[variable, symbol, arity],
s, t: term[variable, symbol, arity]):
member(rho, U(s, t)) IMPLIES
unification_algorithm(s, t) <= rho
ApoÂ´s aplicar a regra measure-induct+, o provador gera treze sub-objetivos de prova.
O primeiro destes sub-objetivos consiste do ramo principal da aÂ´rvore de prova, os outros
sub-objetivos saËœo resultado da checagem de tipos realizada pelo PVS. Na Figura 4.4.3, eÂ´
possÂ´Ä±vel visualizar a ramificacÂ¸aËœo inicial da aÂ´rvore de prova do Lema 4.4.2, onde consta o
noÂ´ [raiz] e duas das ramificacÂ¸oËœes geradas pela checagem de tipos. O ramo principal da
prova eÂ´ apresentado nas figuras 4.4.4 e 4.4.5.
Vamos apresentar a formalizacÂ¸aËœo do objetivo principal da prova. Apresentamos a
aÂ´rvore prova do ramo principal por partes. Na Figura 4.4.4 temos a primeira parte deste
ramo. ComecÂ¸amos este ramo da aÂ´rvore de prova com o seguinte sequente:
â€¢ Sequente representado pelo noÂ´ [1].
{-1} FORALL (y_1: term[variable, symbol, arity],
y_2: term[variable, symbol, arity]):
FORALL (rho: Sub[variable, symbol, arity]):
Card(union(Vars(y_1), Vars(y_2))) <
Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
member(rho, U(y_1, y_2)) IMPLIES
unification_algorithm(y_1, y_2) <= rho
|-------
{1} FORALL (rho: Sub[variable, symbol, arity]):
member(rho, U(x!1, x!2)) IMPLIES
unification_algorithm(x!1, x!2) <= rho
Note que este sequente eÂ´ bastante semelhante ao apresentado na posicÂ¸aËœo correspon-
dente na aÂ´rvore de prova do Lema 4.4.1. EntaËœo, temos a hipoÂ´tese de inducÂ¸aËœo apresentada
na foÂ´rmula -1 e o nosso objetivo eÂ´ provar o consequente 1. Assim, comecÂ¸amos aplicando a
regra skeep para skolemizar a foÂ´rmula universalmente quantificada 1. Em seguida usamos
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 67
Figura 4.4.3
[1] `
(skeep)
`
(case â€œx!1 = x!2â€)
dddddddd
dddddddd
ddddddd
VVVVV
VVVVV
VV
[2] ` ` [4]
(hide (-2 -3))
(inst -1 â€œext(sub of frst diff(x!1, x!2))(x!1)â€
â€œext(sub of frst diff(x!1, x!2))(x!1)â€)
jjjj
jjjj
jj
RRRR
RRRR
` [5] ` `
(expand*
â€œunfication algorithmâ€â€œ<=â€)
(lemma â€œsub of frst diff unifier oâ€) (assert)
` ` `
(assert) (inst -1 â€œrhoâ€â€œx!1â€â€œx!2â€)
ggggg
ggggg
g
WWWWW
WWWWW
W (hide 2 3)
` ` ` `
(inst 1 â€œrhoâ€) (assert) (assert)
` ` ` (expandâ€œmemberâ€â€œUâ€â€œunifiableâ€)
(hide -) (skeep -1) (hide -1 2 3) `
[3] ` ` ` (inst 1 â€œrhoâ€)
(inst -2 â€œthetaâ€) (expand â€œmemberâ€â€œUâ€â€œunifiableâ€)
(rewrite â€œsubs o identityâ€) ` [6] `
(lemma â€œvars ext sub of frst diff decreaseâ€) (inst 1 â€œrhoâ€)
`
(inst -1 â€œx!1â€â€œx!2â€)
`
(assert)
`
(hide -1)
Figura 4.4.5
Figura 4.4.4: InÂ´Ä±cio do ramo principal da aÂ´rvore de prova do Lema 4.4.2. A parte final deste ramo da
prova consta da Figura 4.4.5.
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 68
a regra case, para considerar o caso em que x!1 = x!2 e o caso em que x!1 6= x!2. Logo,
neste ponto a prova se divide em dois sub-objetivos que apresentamos a seguir.
No primeiro caso, onde x!1 = x!2, temos o seguinte sub-objetivo de prova:
â€¢ Sequente representado pelo noÂ´ [2].
{-1} x!1 = x!2
[-2] FORALL (y_1: term[variable, symbol, arity],
y_2: term[variable, symbol, arity]):
FORALL (rho: Sub[variable, symbol, arity]):
Card(union(Vars(y_1), Vars(y_2))) <
Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
member(rho, U(y_1, y_2)) IMPLIES
unification_algorithm(y_1, y_2) <= rho
[-3] member(rho, U(x!1, x!2))
|-------
[1] unification_algorithm(x!1, x!2) <= rho
Neste sequente comecÂ¸amos aplicando a regra (hide -2 -3), que significa que estamos
â€œescondendoâ€ as foÂ´rmulas -2 e -3, onde -2 representa a hipoÂ´tese de inducÂ¸aËœo, mas naËœo seraËœo
necessaÂ´rias neste ramo da prova, pois como jaÂ´ comentamos anteriormente, no caso em
que x!1 = x!2 o construtor unification_algorithm retorna a substituicÂ¸aËœo identidade. E
note que a substituicÂ¸aËœo identidade eÂ´ mais geral que qualquer outra substituicÂ¸aËœo. Assim,
o que fazemos neste ramo da prova eÂ´ expandir as definicÂ¸oËœes de unification_algorithm
e da preÂ´-ordem <=, que usamos aqui para dizer que uma substituicÂ¸aËœo eÂ´ mais geral que
outra. Feito isto e depois de realizar algumas simplificacÂ¸oËœes, instanciamos a foÂ´rmula 1
com a substituicÂ¸aËœo rho e obtemos o sequente:
â€¢ Sequente representado pelo noÂ´ [3]
|-------
[1] rho = comp(rho, identity)
Neste sequente apenas temos que nos dar conta de que a composicÂ¸aËœo de qualquer
substituicÂ¸aËœo Î± com a substutuicÂ¸aËœo identidade eÂ´ igual a Î±. Este fato estaÂ´ formalizado no
lema subs_o_identity da sub-teoria substitution. Assim, utilizamos a regra rewrite
que procura uma instanciacÂ¸aËœo para o lema invocado. Com isto completamos este ramo
da prova.
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 69
Passemos ao caso em que x!1 6= x!2, onde comecÂ¸amos com o objetivo de prova, dado
pelo sequente:
â€¢ Sequente representado pelo noÂ´ [4]
[-1] FORALL (y_1: term[variable, symbol, arity],
y_2: term[variable, symbol, arity]):
FORALL (rho: Sub[variable, symbol, arity]):
Card(union(Vars(y_1), Vars(y_2))) <
Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
member(rho, U(y_1, y_2)) IMPLIES
unification_algorithm(y_1, y_2) <= rho
[-2] member(rho, U(x!1, x!2))
|-------
{1} x!1 = x!2
[2] unification_algorithm(x!1, x!2) <= rho
Neste primeiro sequente deste ramo da prova, temos a hipoÂ´tese que diferencia este
caso do anterior na foÂ´rmula 1, que por estar no consequente representa a negacÂ¸aËœo de
x!1 = x!2. AleÂ´m disso, temos a hipoÂ´tese de inducÂ¸aËœo na foÂ´rmula -1. Da mesma forma
que fizemos no Lema 4.4.1, vamos comecÂ¸ar instanciando -1 com os termos dados por
ext(sub_of_frst_diff(x!1, x!2))(x!1) e ext(sub_of_frst_diff(x!1, x!2))(x!2).
Feita esta instanciacÂ¸aËœo, temos o seguinte sequente:
â€¢ Sequente representado pelo noÂ´ [5]
{-1} FORALL (rho: Sub[variable, symbol, arity]):
Card(union(Vars(ext(sub_of_frst_diff(x!1, x!2))(x!1)),
Vars(ext(sub_of_frst_diff(x!1, x!2))(x!2))))
< Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
member(rho,
U(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2)))
IMPLIES
unification_algorithm(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2))
<= rho
[-2] member(rho, U(x!1, x!2))
|-------
[1] x!1 = x!2
[2] unification_algorithm(x!1, x!2) <= rho
Note que depois de instanciar a hipoÂ´tese de inducÂ¸aËœo ainda temos uma foÂ´rmula com
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 70
uma variaÂ´vel quantificada universalmente, esta variaÂ´vel eÂ´ do tipo Sub, isto eÂ´, uma subs-
tituicÂ¸aËœo. EntaËœo precisamos instanciar esta foÂ´rmula com uma substituicÂ¸aËœo especÂ´Ä±fica.
Vemos no corpo da foÂ´rmula que esta substituicÂ¸aËœo deve ser um unificador dos termos
ext(sub_of_frst_diff(x!1, x!2))(x!1) e ext(sub_of_frst_diff(x!1, x!2))(x!2). Para
obter esta substituicÂ¸aËœo, ao inveÂ´s de usar o lema ext_sub_of_frst_diff_unifiable, que
estabelece que os termos saËœo unificaÂ´veis, o que por skolemizacÂ¸aËœo nos daria uma subs-
tituicÂ¸aËœo, escolhemos usar um o lema sub_of_frst_diff_unifier_o, onde afirmamos que
para qualquer unificador dos termos s e t existe uma substituicÂ¸aËœo Î¸, que composta com
a substituicÂ¸aËœo que resolve a primeira diferencÂ¸a daÂ´ este unificador. Usamos esta Î¸ para
instanciar a foÂ´rmula -1, e depois mostramos que Î¸ eÂ´ um unificador dos termos dados por
ext(sub_of_frst_diff(x!1,x!2))(x!1) e ext(sub_of_frst_diff(x!1, x!2))(x!2). As-
sim, apoÂ´s alguns passos de simplificacÂ¸aËœo temos o sequente:
â€¢ Sequente representado pelo noÂ´ [6]
[-1] rho = comp(theta, sub_of_frst_diff(x!1, x!2))
{-2} Card(union(Vars(ext(sub_of_frst_diff(x!1, x!2))(x!1)),
Vars(ext(sub_of_frst_diff(x!1, x!2))(x!2))))
< Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
member(theta,
U(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2)))
IMPLIES
unification_algorithm(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2))
<= theta
[-3] member(rho, U(x!1, x!2))
|-------
[1] x!1 = x!2
[2] unification_algorithm(x!1, x!2) <= rho
Observando a foÂ´rmula -2, que eÂ´ resultado da hipoÂ´tese de inducÂ¸aËœo, temos que se
Card(union( Vars(ext(sub_of_frst_diff(x!1, x!2))x!1),
Vars(ext(sub_of_frst_diff(x!1, x!2))x!2) ))
< Card(union( Vars(x!1), Vars(x!2) ))
(4.4.1)
e se a substituicÂ¸aËœo Î¸, obtida atraveÂ´s do lema usado anteriormente, eÂ´ um unificador dos ter-
mos ext(sub_of_frst_diff(x!1, x!2))(x!1) e ext(sub_of_frst_diff(x!1, x!2))(x!2),
entaËœo a substituicÂ¸aËœo dada por
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 71
unification_algorithm( ext(sub_of_frst_diff(x!1, x!2)),
ext(sub_of_frst_diff(x!1, x!2)) ),
eÂ´ mais geral que Î¸.
Assim, novamente vamos usar o lema vars_ext_sub_of_frst_diff_decrease, que es-
tabelece o resultado 4.4.1. Em seguida, apoÂ´s alguns passos de prova, realizamos uma
simplificacÂ¸aËœo proposicional com o uso da regra prop, o que faz com que tenhamos dois
ramos na aÂ´rvore de prova a partir deste ponto. A segunda parte da aÂ´rvore de prova, que
conteÂ´m estes ramos estaÂ´ representada na Figura 4.4.5. No primeiro sequente do principal
destes ramos temos:
â€¢ Sequente representado pelo noÂ´ [7]
{-1} unification_algorithm(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2))
<= theta
[-2] rho = comp(theta, sub_of_frst_diff(x!1, x!2))
[-3] member(rho, U(x!1, x!2))
|-------
[1] x!1 = x!2
[2] unification_algorithm(x!1, x!2) <= rho
Neste sequente o nosso objetivo eÂ´ provar a assertiva da foÂ´rmula 2. Para isto, expan-
dimos unification_algorithm na foÂ´rmula 2, em seguida expandimos <=, que nos gera
foÂ´rmulas quantificadas existencialmente. Neste ponto temos o sequente:
â€¢ Sequente representado pelo noÂ´ [8]
[-1] unification_algorithm(ext(sig1)(x!1), ext(sig1)(x!2)) = sig2
[-2] sub_of_frst_diff(x!1, x!2) = sig1
{-3} EXISTS tau: theta = comp(tau, sig2)
[-4] rho = comp(theta, sig1)
[-5] member(rho, U(x!1, x!2))
|-------
[1] x!1 = x!2
{2} EXISTS tau: rho = comp(tau, comp(sig2, sig1))
Depois de skolemizar a variaÂ´vel quantificada em -3, instanciamos 2 com esta mesma
variaÂ´vel. Assim, apoÂ´s alguns passos de prova e algumas simplificacÂ¸oËœes, temos o objetivo:
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 72
Figura 4.4.4
`
(prop)
UUUU
UUUU
UUU
eeeeeee
eeeeeee
eeeeeee
ee
[7] ` `
(name-replace â€œsig1â€
â€œsub of frst diff(x!1, x!2)â€ :hide? nil)
(hide 2 3)
`
(name-replace â€œsig2â€
â€œunification algorithm(ext(sig1)(x!1), ext(sig1)(x!2))â€ :hide? nil) `
` (name-replace â€œsig1â€â€œsub of frst diff(x!1, x!2)â€ :hide? nil)
(expand â€œunification algorithmâ€ 2) `
` (replaces -2)
(replace -2 2) ` [10]
` (expand* â€œmemberâ€â€œUâ€â€œunifierâ€)
(replace -1 1) ` [11]
` (rewrite â€œext oâ€)
(expand â€œ<=â€) `
[8] ` (expand â€œoâ€)
(skeep -3) `
` (propax)
(inst 2 â€œtauâ€)
`
(hide -1 -2 -5 1)
`
(replaces -1)
[9] `
(rewrite â€œo assâ€)
Figura 4.4.5: Parte final do ramo principal da aÂ´rvore de prova do Lema 4.4.2. A parte inicial deste
ramo da prova consta da Figura 4.4.4.
4.4 FormalizacÂ¸aËœo dos Lemas Sobre o Construtor unification_algorithm 73
â€¢ Sequente representado pelo noÂ´ [9]
{-1} rho = comp(comp(tau, sig2), sig1)
|-------
{1} rho = comp(tau, comp(sig2, sig1))
Neste sequente, temos que:
sig1 = sub_of_frst_diff(x!1, x!2) e
sig2 = unification_algorithm(ext(sig1)(x!1), ext(sig1)(x!2)).
Note que a foÂ´rmula -1 eÂ´ igual a` foÂ´rmula 1, apenas temos que nos dar conta de que a
composicÂ¸aËœo de substituicÂ¸oËœes eÂ´ associativa, isto eÂ´, dadas as substituicÂ¸oËœes Ï„ , Ïƒ1 e Ïƒ2, vale
que ((Ï„ â—¦ Ïƒ1) â—¦ Ïƒ2) = (Ï„ â—¦ (Ïƒ1 â—¦ Ïƒ2)). Mas este resultado esta formalizado no lema o_ass da
sub-teoria substitution.
No ramo seguinte da prova, temos o seguinte objetivo:
â€¢ Sequente representado pelo noÂ´ [10]
{-1} sub_of_frst_diff(x!1, x!2) = sig1
{-2} member(comp(theta, sig1), U(x!1, x!2))
|-------
{1} member(theta, U(ext(sig1)(x!1), ext(sig1)(x!2)))
Neste sequente devemos verificar que a substituicÂ¸aËœo obtida pela aplicacÂ¸aËœo do lema
sub_of_frst_diff_unifier_o, eÂ´ de fato um unificador dos termos ext(sig1)(x!1) e
ext(sig1)(x!2). Para isto, apenas expandimos as definicÂ¸oËœes de meber, U e unifier que
aparece devido as expansoËœes anteriores. Feito isto, temos o objetivo:
â€¢ Sequente representado pelo noÂ´ [11]
[-1] sub_of_frst_diff(x!1, x!2) = sig1
{-2} ext(comp(theta, sig1))(x!1) = ext(comp(theta, sig1))(x!2)
|-------
{1} ext(theta)(ext(sig1)(x!1)) = ext(theta)(ext(sig1)(x!2))
Onde temos que verificar que dadas duas substituicÂ¸oËœes Î¸ e Ïƒ quaisquer, vale que Î¸Ì‚ â—¦ Ïƒ =
Î¸Ë† â—¦ ÏƒË†. Mas este resultado estaÂ´ formalizado no lema ext_o da sub-teoria substitution.
Assim, reescrevemos com este lema e completamos este ramo da prova.
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 74
Com isto, completamos o ramo principal da prova. Ressaltamos que nos ramos da
prova descritos acima, omitimos alguns sub-objetivos, que aparecem como resultado da
checagem de tipos realizada pelo PVS, usamos a estrateÂ´gia de aplicar um outro lema da
teoria, nestes casos temos que provar assercÂ¸oËœes acerca do tipo dos termos.
Em todos os ramos seguintes da prova, temos que provar assercÂ¸oËœes acerca de tipos.
Em alguns destes objetivos temos que provar que a uniaËœo dos conjuntos de variaÂ´veis dos
termos eÂ´ finita. A demonstracÂ¸aËœo destes ramos, assim como fizemos na demonstracÂ¸aËœo
do Lema 4.4.1, segue pela aplicacÂ¸aËœo de dois outros lemas, um da teoria finite_sets
do preluÂ´dio do PVS, denominado finite_union e um da teoria subterm denominado
vars_of_term_finite. Como jaÂ´ descrevemos este ramo de prova na apresentacÂ¸aËœo da for-
malizacÂ¸aËœo do Lema 4.4.1, naËœo repetiremos aqui. Nos outros ramos da prova, temos apenas
que mostrar que os termos saËœo unificaÂ´veis. Assim, temos sempre um sequente da forma:
â€¢ Sequente representado pelo noÂ´ [12]
[-1] member(rho!1, U(s!1, t!1))
|-------
[1] unifiable(s!1, t!1)
Note que na foÂ´rmula -1 temos que a substituicÂ¸aËœo rho!1 faz parte do conjunto de unifi-
cadores dos termos s!1 e t!1. Assim, expandimos as definicÂ¸oËœes de member, U e unifiable,
em seguida instanciamos a foÂ´rmula 1, que passa a ser quantificada existencialmente, com
a substituicÂ¸aËœo rho!1 o que completa este ramo da prova.
Com isto completamos todos os ramos da prova do lema.
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o
Construtor sub_of_frst_diff
Nesta secÂ¸aËœo apresentamos a formalizacÂ¸aËœo dos lemas sobre o construtor sub_of_frst_diff,
cuja especificacÂ¸aËœo consta na Tabela 4.2.6. A formalizacÂ¸aËœo destes lemas surge da neces-
sidade de verificar que o construtor unification_algorithm estaÂ´ totalmente definido em
relacÂ¸aËœo aos tipos dos termos. AleÂ´m disso, com estes lemas, verificamos propriedades essen-
ciais do algoritmo de unificacÂ¸aËœo, uma delas eÂ´ a de terminacÂ¸aËœo. A terminacÂ¸aËœo do algoritmo
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 75
proposto nesta especificacÂ¸aËœo fica garantida pelo lema que apresentamos primeiro nesta
secÂ¸aËœo, o Lema 4.5.1. Nos lemas 4.5.2 e 4.5.3, apresentados nas secÂ¸oËœes 4.5.2 e 4.5.3, for-
malizamos o fato de que resolver diferencÂ¸as em termos unificaÂ´veis leva a termos ainda
unificaÂ´veis. Estes foram os lemas essenciais no passo indutivo da demosntracÂ¸aËœo de cada
um dos lemas apresentados na SecÂ¸aËœo 4.4. Os lemas desta secÂ¸aËœo correspodem aos lemas
sobre generalidade local e terminacÂ¸aËœo do algoritmo de unificacÂ¸aËœo apresentados na SecÂ¸aËœo
2.2.3.
4.5.1 Lema vars_ext_sub_of_frst_diff_decrease
Como jaÂ´ mencionamos anteriormente, com este lema temos garantida a terminacÂ¸aËœo do
algoritmo de unificacÂ¸aËœo, isto se deve ao fato de que a cada passo do algoritmo retiramos
um elemento de um conjunto finito, o que portanto eÂ´ um processo finito. A especificacÂ¸aËœo
deste lema estaÂ´ apresentada na Tabela 4.2.6. Na SecÂ¸aËœo 2.2, demonstramos o Lema 2.2.15,
onde provamos a terminacÂ¸aËœo do algoritmo de unificacÂ¸aËœo e que corresponde a este cuja
formalizacÂ¸aËœo apresentamos aqui. A aÂ´rvore de prova deste lema eÂ´ apresentada nas figuras
4.5.1, 4.5.2 e 4.5.3.
Lema 4.5.1: Sejam s e t dois termos unificaÂ´veis e Ïƒ = sub_of_frst_diff(s, t), entaËœo
Card(Vars(ÏƒË†(s)) âˆª Vars(ÏƒË†(t))) < Card(Vars(s) âˆª Vars(t)).
DemonstracÂ¸aËœo: Na formalizacÂ¸aËœo deste lema temos o seguinte objetivo de prova, ao
iniciarmos a demonstracÂ¸aËœo:
â€¢ Sequente representado pelo noÂ´ [raiz]
|-------
{1} FORALL (s: term, t: term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Card(union(Vars(ext(sig)(s)), Vars(ext(sig)(t)))) <
Card(union(Vars(s), Vars(t)))
ComecÂ¸amos skolemizando as variaÂ´veis ligadas do consequente com a regra skosimp, que
ao contraÂ´rio da regra skeep, skolemiza introduzindo novos nomes para as constantes, o que
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 76
` [raiz]
(skosimp*)
`
(assert)
`
(name-replace â€œsig1â€
â€œsub of frst diff(s!1, t!1)â€ :hide? nil)
` [1]
(lemma â€œcard diff subset[(V)]â€)
`
(lemma â€œunion vars ext sub of frst diffâ€)
`
(inst -1 â€œs!1â€â€œt!1â€)
`
(assert)
`
(replace -3 -1)
`
(replaces -1)
`
(inst -1 â€œDom(sig1)â€
â€œunion(Vars(s!1), Vars(t!1))â€)
eeeeee
eeeeee
eee
XXXXX
XXXXX
XXX
[2] ` `
(prop) (hide -1 2)
Figura 4.5.2 Figura 4.5.3 `
(typepred â€œsig1â€)
`
(expand â€œSub?â€)
`
(propax)
Figura 4.5.1: InÂ´Ä±cio da aÂ´rvore de prova do Lema 4.5.1. O restante da aÂ´rvore consta das figuras 4.5.2 e
4.5.3.
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 77
evita conflitos entre os nomes. ApoÂ´s poucos passos de prova onde fazemos simplificacÂ¸oËœes,
temos:
â€¢ Sequente representado pelo noÂ´ [1]
{-1} sub_of_frst_diff(s!1, t!1) = sig1
|-------
{1} Card(union(Vars(ext(sig1)(s!1)), Vars(ext(sig1)(t!1)))) <
Card(union(Vars(s!1), Vars(t!1)))
Note que estamos denotando a substituicÂ¸aËœo que resolve a primeira diferencÂ¸a por sig1.
Para chegar a uma contradicÂ¸aËœo a partir de 1, utilizamos a seguinte estrateÂ´gia: mostramos
em um outro lema, denominado union_vars_ext_sub_of_frst_diff, que
Vars(ÏƒË†(s)) âˆª Vars(ÏƒË†(t)) = Vars(s) âˆª Vars(t) \ Dom(Ïƒ),
e utilizamos o lema card_diff_subset da teoria finite_sets da biblioteca do preluÂ´dio do
PVS, onde se afirma que dados dois conjuntos A e B, vale que
A âŠ‚ B â‡’ Card(B \ A) = Card(B)âˆ’ Card(A).
Assim, utilizando estes dois lemas, e apoÂ´s alguns passo de prova, temos:
â€¢ Sequente representado pelo noÂ´ [2]
{-1} subset?(Dom(sig1), union(Vars(s!1), Vars(t!1))) IMPLIES
card(difference(union(Vars(s!1), Vars(t!1)), Dom(sig1))) =
card(union(Vars(s!1), Vars(t!1))) - card(Dom(sig1))
[-2] sub_of_frst_diff(s!1, t!1) = sig1
|-------
[1] Card(difference(union(Vars(s!1), Vars(t!1)), Dom(sig1))) <
Card(union(Vars(s!1), Vars(t!1)))
A este sequente aplicamos a regra prop, que realiza uma simplificacÂ¸aËœo proposicional
e divide a prova neste ponto em dois ramos. O primeiro destes ramos comecÂ¸a com o
seguinte objetivo:
â€¢ Sequente representado pelo noÂ´ [3]
{-1} card(difference(union(Vars(s!1), Vars(t!1)), Dom(sig1))) =
card(union(Vars(s!1), Vars(t!1))) - card(Dom(sig1))
[-2] sub_of_frst_diff(s!1, t!1) = sig1
|-------
[1] Card(difference(union(Vars(s!1), Vars(t!1)), Dom(sig1))) <
Card(union(Vars(s!1), Vars(t!1)))
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 78
Figura 4.5.1
[3] `
(case-replace â€œcard(Dom(sig1)) = 1â€)
hhhh
hhhh XXXXX
XXXXX
` `
(assert) (hide-all-but 1)
`
(rewrite â€œcard oneâ€)
`
(lemma â€œdom sub of frst diff isâ€)
`
(inst -1 â€œresolving diff(s!1, t!1)â€
â€œs!1â€â€œt!1â€â€œsig1â€)
`
(assert)
`
(prop)
ccccccccc
ccccccccc
cccccccc
TTTT
TTTT
` `
(inst 1 â€œsubtermOF(s!1,
resolving diff(s!1, t!1))â€)
vvv SSSS
SS
(lemma â€œresolving diff varsâ€)
` ` `
(expand*
â€œrestrictâ€â€œsingletonâ€)
(expand â€œVâ€)
(inst -1 â€œs!1â€â€œt!1â€
â€œresolving diff(s!1, t!1)â€)
llll
ll PPP
PP
` ` `
(propax) (assert) (hide-all-but 1)
` `
(inst 2 â€œsubtermOF(t!1,
resolving diff(s!1, t!1))â€)
jjjj
jjjj
jj CC
CC
` ` (rewriteâ€œposition t resolving diffâ€)
(expand* â€œrestrictâ€â€œsingletonâ€) (expand â€œVâ€) `
` (lemmaâ€œposition s resolving diffâ€)
(propax) `
(inst -1 â€œs!1â€â€œt!1â€
â€œresolving diff(s!1, t!1)â€)
Figura 4.5.2: Parte da aÂ´rvore de prova do Lema 4.5.1.
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 79
Neste ponto consideramos o caso em que card(Dom(sig1)) = 1. O que nos leva a
outros dois ramos de prova. O primeiro completamos com um assert, pois neste caso -1
eÂ´ uma contradicÂ¸aËœo de 1. E com isto completamos o ramo principal da prova. No segundo
caso, temos que provar que de fato card(Dom(sig1)) = 1, mas jaÂ´ temos formalizado no
lema dom_sub_of_frst_diff_is, o fato de que o domÄ±Â´nio da substituicÂ¸aËœo que resolve a
primeira diferencÂ¸a eÂ´ unitaÂ´rio. Assim, partindo deste lema, completamos este ramo da
prova, e depois de verificar outros ramos gerados pelo typechecker, chegamos ao seguinte:
â€¢ Sequente representado pelo noÂ´ [4]
[-1] sub_of_frst_diff(s!1, t!1) = sig1
|-------
{1} subset?(Dom(sig1), union(Vars(s!1), Vars(t!1)))
[2] Card(difference(union(Vars(s!1), Vars(t!1)), Dom(sig1))) <
Card(union(Vars(s!1), Vars(t!1)))
Este sequente representa o segundo objetivo gerado pela aplicacÂ¸aËœo da regra prop. Neste
queremos concluir que se Ïƒ = sub_of_frst_diff(s, t), entaËœo
Dom(Ïƒ) âŠ‚ Vars(s) âˆª Vars(t). (4.5.1)
Este objetivo esta representado pela foÂ´rmula 1 do sequente acima. Para concluir este
ramo da prova utilizamos novamente o lema dom_sub_of_frst_diff_is, onde mostramos
tambeÂ´m que se p eÂ´ a posicÂ¸aËœo da primeira diferencÂ¸a entre os termos s e t, entaËœo temos
apenas duas possibilidades exclusivas para o dominÂ´Ä±nio de Ïƒ, ou Dom(Ïƒ) = {s|p} ou
Dom(Ïƒ) = {t|p}. Em ambos os casos temos que 4.5.1 eÂ´ satisfeita, pois
Dom(Ïƒ) = {s|p} â‡’ Dom(Ïƒ) âŠ‚ Vars(s)
â‡’ Dom(Ïƒ) âŠ‚ Vars(s) âˆª Vars(t)
ou
Dom(Ïƒ) = {t|p} â‡’ Dom(Ïƒ) âŠ‚ Vars(t)
â‡’ Dom(Ïƒ) âŠ‚ Vars(s) âˆª Vars(t)
Assim, antes de aplicarmos o lema mencionado, realizamos alguns passos de prova,
onde expandimos as definicÂ¸oËœes de subset?, member e union, aplicamos simplificacÂ¸oËœes pro-
posicionais e decompomos uma igualdade chegando ao seguinte objetivo de prova:
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 80
Figura 4.5.1
` [4]
(hide 2)
`
(expand â€œsubset?â€)
`
(skosimp*)
`
(expand* â€œunionâ€â€œmemberâ€)
`
(flatten)
` [5]
(expand â€œVarsâ€)
`
(lemma â€œdom sub of frst diff isâ€)
`
(inst -1 â€œresolving diff(s!1, t!1)â€â€œs!1â€â€œt!1â€â€œsig1â€)
`
(assert)
(expand* â€œrestrictâ€â€œsingletonâ€)
`
(prop)
eeeeee
eeeeee
eee
[[[[[[[[[
[[[[[[[[[
[[[[[[
` `
(decompose-equality -2) (decompose-equality -1)
mmmm
m SSSS
SS
` ` `
(inst -1 â€œx!1â€) (inst -1 â€œx!1â€) (hide-all-but 1)
` ` `
(assert) (assert)
` ` (rewrite â€œposition t resolving diffâ€)
(hide-all-but (-1 2)) (hide-all-but (-1 3))
` `
(inst 1 â€œresolving diff(s!1, t!1)â€) (inst 1 â€œresolving diff(s!1, t!1)â€)
` `
(assert) (assert)
Figura 4.5.3: Parte da aÂ´rvore de prova do Lema 4.5.1.
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 81
â€¢ Sequente representado pelo noÂ´ [5]
[-1] Dom(sig1)(x!1)
[-2] sub_of_frst_diff(s!1, t!1) = sig1
|-------
{1} Vars(s!1)(x!1)
{2} Vars(t!1)(x!1)
A variaÂ´vel x!1 surge quando expandimos a definicÂ¸aËœo de subset? e skolemizamos a
variaÂ´vel da foÂ´rmula quantificada universalmente que obtemos no consequente. Assim, o
que queremos neste objetivo eÂ´ mostrar que se x!1 eÂ´ uma variaÂ´vel do domÄ±Â´nio de sig1
(foÂ´rmula -1), entaËœo ou x!1 eÂ´ uma variaÂ´vel de Vars(s!1) (foÂ´rmula 1) ou x!1 eÂ´ uma variaÂ´vel
de Vars(t!1) (foÂ´rmula 2). Neste ponto utilizamos o lema dom_sub_of_frst_diff_is, e apoÂ´s
alguns passos de prova, onde realizamos simpificacÂ¸oËœes completamos este ramo da prova,
que tambeÂ´m possui sub-ramos onde provamos alguns TCCâ€™s gerados pelo typechecker.
4.5.2 Lema sub_of_frst_diff_unifier_o
Neste lema, provamos que sempre que uma substituicÂ¸aËœo pertence ao conjunto de uni-
ficadores de dois termos unificaÂ´veis, entaËœo existe uma outra substituicÂ¸aËœo que composta
com aquela computada em um passo de execucÂ¸aËœo do algoritmo de unificacÂ¸aËœo, resulta na
primeira. Este lema corresponde ao Lema 2.2.14, sobre generalidade local do algoritmo
de unificacÂ¸aËœo. Na Tabela 4.2.6 temos a especificacÂ¸aËœo do lema seguinte e nas figuras 4.5.4,
4.5.5 e 4.5.6 a sua aÂ´rvore de prova.
Lema 4.5.2: Sejam s e t termos unificaÂ´veis e diferentes e Ïƒ a substituicÂ¸aËœo que resolve a
primeira diferencÂ¸a entre os termos s e t, isto eÂ´, Ïƒ = sub_of_frst_diff(s, t). EntaËœo, para
todo unificador Î¸ âˆˆ U(s, t), existe uma substituicÂ¸aËœo Î´ tal que Î¸ = Î´ â—¦ Ïƒ.
DemonstracÂ¸aËœo: Na demonstracÂ¸aËœo deste lema, basicamente vamos mostrar que as subs-
tituicÂ¸oËœes Î¸ e Î´ â—¦ Ïƒ possuem o mesmo domÄ±Â´nio e a mesma imagem. Temos o seguinte
objetivo inicial de prova:
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 82
` [raiz]
(skosimp)
`
(assert)
`
(name-replace â€œsig!1â€
â€œsub of frst diff(s!1, t!1)â€ :hide? nil)
`
(name â€œp!1â€â€œresolving diff(s!1, t!1)â€)
[1] `
(inst 1 â€œrho!1â€)
`
(lemma â€œunifiable terms unifiable argsâ€)
`
(inst -1 â€œrho!1â€â€œs!1â€â€œt!1â€â€œp!1â€)
XXXXXX
XXXXXX
XXX
ffffff
ffffff
ffff
` `
(assert) (hide-all-but (-1 1))
` `
(expand* â€œmemberâ€â€œUâ€â€œunifierâ€) (rewrite â€œposition t resolving diffâ€)
` `
(decompose-equality -1) (lemma â€œposition s resolving diffâ€)
` `
(expand â€œcompâ€) (inst -1 â€œs!1â€â€œt!1â€â€œp!1â€)
` `
(case â€œvars?(subtermOF(s!1, p!1))â€) (assert)
Figura 4.5.5 Figura 4.5.6
Figura 4.5.4: RamificacÂ¸aËœo inicial da aÂ´rvore de prova do Lema 4.5.2. A parte final da aÂ´rvore de prova
consta das figuras 4.5.5 e 4.5.6.
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 83
â€¢ Sequente representado pelo noÂ´ [raiz]
|-------
{1} FORALL (rho: Sub[variable, symbol, arity], s: term,
t: term | unifiable(s, t) & s /= t):
member(rho, U(s, t)) IMPLIES
LET sig = sub_of_frst_diff(s, t) IN
EXISTS theta: rho = comp(theta, sig)
ComecÂ¸amos skolemizando as variaÂ´veis ligadas da foÂ´rmula 1. ApoÂ´s alguns passos temos
o seguinte sequente, onde eÂ´ possÂ´Ä±vel visualizar de forma mais clara o nosso objetivo de
prova.
â€¢ Sequente representado pelo noÂ´ [1]
{-1} resolving_diff(s!1, t!1) = p!1
[-2] sub_of_frst_diff(s!1, t!1) = sig!1
[-3] member(rho!1, U(s!1, t!1))
|-------
[1] EXISTS theta: rho!1 = comp(theta, sig!1)
Temos uma substituicÂ¸aËœo rho!1, que pela foÂ´rmula -3, eÂ´ um unificador de s!1 e t!1.
Queremos chegar ao resultado da foÂ´rmula 1, isto eÂ´, existe uma substituicÂ¸aËœo theta que
composta com sig!1 resulta em rho!1 e, como vemos em -2, sig!1 eÂ´ a substituicÂ¸aËœo que
resolve a primeira diferencÂ¸a entre s!1 e t!1. A estrateÂ´gia eÂ´ instanciar a foÂ´rmula 1 com a
proÂ´pria rho!1. Mas como rho!1 unifica s!1 e t!1, temos em mente que
member(rho!1, U(s!1, t!1)) IMPLIES
member(rho!1, U(subtermOF(s!1, q!1), subtermOF(t!1, q!1))),
onde q!1 eÂ´ uma posicÂ¸aËœo qualquer dos termos s!1 e t!1. Assim, o que faremos eÂ´ obser-
var o caso particular em que q!1 = p!1, onde vemos na foÂ´rmula -1 que p!1 eÂ´ a posicÂ¸aËœo
onde ocorre a primeira diferencÂ¸a entre os termos s!1 e t!1. Como jaÂ´ sabemos que na
posicÂ¸aËœo p!1 ou o subtermo de s!1 eÂ´ uma variaÂ´vel ou o subtermo de t!1 eÂ´ uma variaÂ´vel,
uma boa estrateÂ´gia eÂ´ analizar cada um destes casos. Assim prosseguimos e temos entaËœo
ramificacÂ¸oËœes na aÂ´rvore de prova. ApoÂ´s alguns passos de prova, comecÂ¸amos pelo caso em
que subtermOF(s!1,p!1) eÂ´ uma variaÂ´vel.
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 84
â€¢ Sequente representado pelo noÂ´ [2]
{-1} vars?(subtermOF(s!1, p!1))
[-2] ext(rho!1)(subtermOF(s!1, p!1)) = ext(rho!1)(subtermOF(t!1, p!1))
[-3] resolving_diff(s!1, t!1) = p!1
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] ext(rho!1)(s!1) = ext(rho!1)(t!1)
|-------
[1] rho!1(x!1) = ext(rho!1)(sig!1(x!1))
Observe que temos uma nova variaÂ´vel x!1 na foÂ´rmula 1, que aparece quando decompo-
mos a igualdade desta foÂ´rmula, isto eÂ´, temos que se rho!1 = comp(theta, sig!1), entaËœo
rho!1(x!1) = ext(rho!1)(sig!1(x!1)), para qualquer variaÂ´vel x!1. EntaËœo neste ponto da
prova, novamente vamos considerar casos. Primeiro o caso em que x!1 = subtermOF(s!1,
p!1). Neste caso, observe que pela definicÂ¸aËœo de sub_of_frst_diff temos que:
â€¢ Sequente representado pelo noÂ´ [3]
{-1} x!1 = subtermOF(s!1, p!1)
[-2] vars?(subtermOF(s!1, p!1))
[-3] ext(rho!1)(subtermOF(s!1, p!1)) = ext(rho!1)(subtermOF(t!1, p!1))
[-4] resolving_diff(s!1, t!1) = p!1
[-5] sub_of_frst_diff(s!1, t!1) = sig!1
[-6] ext(rho!1)(s!1) = ext(rho!1)(t!1)
|-------
[1] rho!1(x!1) = ext(rho!1)(sig!1(x!1))
Deste sequente, tiramos as seguintes conclusoËœes:
Por definicÂ¸aËœo de sig!1, temos que
ext(sig!1)(subtermOF(s!1, p!1)) = subtermOF(t!1, p!1).
AleÂ´m disso, estamos no caso em que x!1 = subtermOF(s!1, p!1) e sendo rho!1 um
unificador de s e t, entaËœo
ext(rho!1)(subtermOF(s!1, p!1)) = ext(rho!1)(subtermOF(t!1,p!1)).
Logo, concluÂ´Ä±mos que
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 85
Figura 4.5.4
(case â€œvars?(subtermOF(s!1, p!1))â€)
ggggg
ggggg
ggggg
[2] ` Figura 4.5.6
(case â€œx!1 = subtermOF(s!1, p!1)â€)
iiii
iiii
iiii
WWWWW
WWWWW
WWWWW
[3] ` ` [5]
(replace -5 1 rl) (replace -4 2 rl)
` `
(expand â€œsub of frst diffâ€ 1) (expand â€œsub of frst diffâ€ 2)
` `
(assert) (assert)
` ` [6]
(replace -4 1) (hide-all-but 2)
` `
(replace -1 -3 rl) (typepred â€œx!1â€)
` `
(hide-all-but -3 1) (expand â€œVâ€â€œextâ€)
[4] ` `
(expand â€œextâ€ -1 1) (assert)
`
(propax)
Figura 4.5.5: Parte da aÂ´rvore de prova do Lema 4.5.2. Representa o caso em que o termo
subtermOF(s!1, p!1) eÂ´ uma variaÂ´vel.
ext(rho!1)(x!1) = ext(rho!1)(subtermOF(t!1, p!1))
â‡’ ext(rho!1)(x!1) = ext(rho!1)(ext(sig!1)(subtermOF(s!1,p!1)))
â‡’ ext(rho!1)(x!1) = ext(rho!1)(ext(sig!1)(x!1)),
onde a uÂ´ltima expressaËœo eÂ´ justamente a foÂ´rmula 1 do sequente anterior. Assim, reali-
zando alguns passos de prova, onde reproduzimos o raciocÂ´Ä±nio descrito acima, obtemos o
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 86
sequente:
â€¢ Sequente representado pelo noÂ´ [4]
[-1] ext(rho!1)(x!1) = ext(rho!1)(subtermOF(t!1, p!1))
|-------
[1] rho!1(x!1) = ext(rho!1)(subtermOF(t!1, p!1))
Note que temos uma contradicÂ¸aËœo pois na foÂ´rmula 1 temos a negacÂ¸aËœo de -1. Para con-
cluir este ramo da prova basta expandir a definicÂ¸aËœo de ext, pois como x!1 eÂ´ uma variaÂ´vel,
entaËœo ext(rho!1)(x!1) = rho!1(x!1). Com isto completamos este ramo da prova.
No proÂ´ximo ramo estamos no caso em que x!1 6= subtermOF(s!1, p!1). O sequente
inicial eÂ´ dado por:
â€¢ Sequente representado pelo noÂ´ [5]
[-1] vars?(subtermOF(s!1, p!1))
[-2] ext(rho!1)(subtermOF(s!1, p!1)) = ext(rho!1)(subtermOF(t!1, p!1))
[-3] resolving_diff(s!1, t!1) = p!1
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] ext(rho!1)(s!1) = ext(rho!1)(t!1)
|-------
{1} x!1 = subtermOF(s!1, p!1)
[2] rho!1(x!1) = ext(rho!1)(sig!1(x!1))
Neste caso a demonstracÂ¸aËœo eÂ´ mais direta, pois como x!1 eÂ´ uma variaÂ´vel que naËœo
pertence ao domÄ±Â´nio de sig!1, entaËœo sig!1(x!1) = x!1. Assim, basta expandir a definicÂ¸aËœo
de sig!1 em 2 e teremos diretamente que rho!1(x!1) = ext(rho!1)(x!1). Portanto, apoÂ´s
alguns passos de prova, temos o sequente:
â€¢ Sequente representado pelo noÂ´ [6]
[-1] vars?(subtermOF(s!1, p!1))
[-2] ext(rho!1)(subtermOF(s!1, p!1)) = ext(rho!1)(subtermOF(t!1, p!1))
[-3] resolving_diff(s!1, t!1) = p!1
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] ext(rho!1)(s!1) = ext(rho!1)(t!1)
|-------
[1] x!1 = subtermOF(s!1, p!1)
{2} rho!1(x!1) = ext(rho!1)(x!1)
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 87
Note que neste sequente a foÂ´rmula principal eÂ´ o consequente 2. Assim, como jaÂ´ men-
cionamos, expandimos ext e com isto completamos este ramo da prova.
No ramo seguinte consideramos o caso em que o termo subtermOF(t!1, p!1) eÂ´ uma
variaÂ´vel. Este ramo eÂ´ inteiramente anaÂ´logo ao que descrevemos acima, e naËœo o exporemos
aqui.
Passando ao ramo seguinte, temos o seguinte sequente:
â€¢ Sequente representado pelo noÂ´ [7].
[-1] ext(rho!1)(subtermOF(s!1, p!1)) = ext(rho!1)(subtermOF(t!1, p!1))
[-2] resolving_diff(s!1, t!1) = p!1
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] ext(rho!1)(s!1) = ext(rho!1)(t!1)
|-------
{1} vars?(subtermOF(t!1, p!1))
[2] vars?(subtermOF(s!1, p!1))
[3] rho!1(x!1) = ext(rho!1)(sig!1(x!1))
Observe que neste ramo estamos considerando o caso em que nenhum dos termos
subtermOF(t!1, p!1) e subtermOF(s!1, p!1) eÂ´ uma variaÂ´vel. Mas jaÂ´ sabemos que este
caso naËœo ocorre, e este fato estaÂ´ formalizado no lema resolving_diff_vars , cuja es-
pecificacÂ¸aËœo apresentamos na Tabela 4.2.4. Assim, com este lema apoÂ´s feitas as devidas
instanciacÂ¸oËœes temos o sequente:
â€¢ Sequente representado pelo noÂ´ [8]
{-1} p!1 = resolving_diff(s!1, t!1) IMPLIES
vars?(subtermOF(s!1, p!1)) OR vars?(subtermOF(t!1, p!1))
[-2] resolving_diff(s!1, t!1) = p!1
|-------
[1] vars?(subtermOF(t!1, p!1))
[2] vars?(subtermOF(s!1, p!1))
Note que temos uma contradicÂ¸aËœo, pois pela foÂ´rmula 1, subtermOF(t!1, p!1) naËœo eÂ´ uma
variaÂ´vel, e pela foÂ´rmula 2, subtermOF(s!1, p!1) naËœo eÂ´ uma variaÂ´vel, mas pela foÂ´rmula -1,
ou subtermOF(s!1, p!1) eÂ´ uma variaÂ´vel ou subtermOF(t!1, p!1) eÂ´ uma variaÂ´vel. Assim,
com uma aplicacÂ¸aËœo da regra assert, completamos este ramo da prova.
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 88
Figura 4.5.4
(case â€œvars?(subtermOF(s!1, p!1))â€)
YYYYYY
YYYYYY
YYYYYY
Figura 4.5.5 `
(case â€œvars?(subtermOF(t!1, p!1))â€)
ffffff
ffffff
ffffff
PPP
PPP
PP
` ` [7]
(case â€œx!1 = subtermOF(t!1, p!1)â€)
iiii
iiii
iiii
RRRR
RRRR
R (hide-all-but (-2 1 2))
` ` `
(replace -5 2 rl) (replace -4 3 rl)
` ` (lemmaâ€œresolving diff varsâ€)
(expand â€œsub of frst diffâ€ 2)
(expand
â€œsub of frst diffâ€ 3) `
` ` (inst -1 â€œs!1â€â€œt!1â€â€œp!1â€)
PPP
PPP
PP


(assert) (assert) [8] ` `
` ` (assert) (hide 2 3)
(replace -4 2) (hide-all-but 3) `
` ` (rewriteâ€œposition t resolving diffâ€)
(replace -1 -3 rl) (typepred â€œx!1â€) `
` ` (lemmaâ€œposition s resolving diffâ€)
(hide-all-but (-3 2)) (expand â€œVâ€â€œextâ€) `
` ` (inst -1 â€œs!1â€â€œt!1â€â€œp!1â€)
(expand â€œextâ€ -1 2) (assert) `
` (assert)
(assert)
Figura 4.5.6: Parte da aÂ´rvore de prova do Lema 4.5.2. Representa o caso em que o termo
subtermOF(s!1, p!1) naËœo eÂ´ uma variaÂ´vel. A ramificacÂ¸aËœo abaixo no noÂ´ [7], representa o caso em que
nem subtermOF(s!1, p!1) e nem subtermOF(t!1, p!1) saËœo variaÂ´veis.
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 89
Novamente apresentamos apenas o ramo principal da formalizacÂ¸aËœo do Lema 4.5.2,
denominado sub_of_frst_unifier_o. Outros ramos gerados pela operacÂ¸aËœo de checagem
de tipos naËœo seraËœo comentados aqui.
4.5.3 Lema ext_sub_of_frst_diff_unifiable
Nesta secÂ¸aËœo apresentamos a formalizacÂ¸aËœo do lema ext_sub_of_frst_diff_unifiable, onde
provamos que os termos obtidos via instanciacÂ¸aËœo, de dois termos unificaÂ´veis e diferentes,
pela substituicÂ¸aËœo computada pelo construtor sub_of_frst_diff aplicado a estes dois ter-
mos, saËœo ainda termos unificaÂ´veis.
O lema sub_of_frst_diff_unifiable foi necessaÂ´rio na formalizacÂ¸aËœo do Lema 4.4.1,
denominado unification_algorithm_gives_unifier. TambeÂ´m foi necessaÂ´rio na demons-
tracÂ¸aËœo de um importante TCC sobre o construtor unification_algorithm, onde deve-se
verificar que o construtor preserva a tipagem dos termos, no sentido de que os novos
termos gerados no processo de recursaËœo devem ser ainda unificaÂ´veis.
O lema sub_of_frst_diff_unifiable corresponde a um dos resultados do Lema 2.2.14,
demonstrado no CapÂ´Ä±tulo 2, onde vimos a sua importaË†ncia na verificacÂ¸aËœo da completude do
algoritmo de unificacÂ¸aËœo. A especificacÂ¸aËœo deste lema consta da Tabela 4.2.6. A formalizacÂ¸aËœo
deste lema eÂ´ bastante simples, pois resulta de uma aplicacÂ¸aËœo direta do Lema 4.5.2. Assim,
apresentaremos a formalizacÂ¸aËœo deste lema sem expor a aÂ´rvore de prova, que possui apenas
um ramo.
Lema 4.5.3: Sejam s e t termos unificaÂ´veis e diferentes e Ïƒ a substituicÂ¸aËœo que resolve a
primeira diferencÂ¸a entre os termos s e t, isto eÂ´, Ïƒ = sub_of_frst_diff(s, t). EntaËœo, os
termos ÏƒË†(s) e ÏƒË†(t) saËœo ainda unificaÂ´veis.
DemonstracÂ¸aËœo: ComecÂ¸amos a demonstracÂ¸aËœo deste lema com o seguinte objetivo de
prova:
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 90
|-------
{1} FORALL (s: term, t: term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
unifiable(ext(sig)(s), (ext(sig)(t)))
Como jaÂ´ mencionamos anteriormente, a formalizacÂ¸aËœo deste lema segue diretamente do
Lema 4.5.2. De fato, o lema ext_sub_of_frst_diff_unifiable eÂ´ um corolaÂ´rio do lema
sub_of_frst_diff_unifier_o. Assim, apoÂ´s skolemizar as variaÂ´veis do sequente acima,
utilizamos a regra lemma, a fim de trazer para as foÂ´rmulas do antecedente a hipoÂ´tese do
lema sub_frst_diff_unifier_o, e com isto obtemos o seguinte:
{-1} FORALL (rho: Sub[variable, symbol, arity], s: term,
t: term | unifiable(s, t) & s /= t):
member(rho, U(s, t)) IMPLIES
LET sig = sub_of_frst_diff(s, t) IN
EXISTS theta: rho = comp(theta, sig)
[-2] sub_of_frst_diff(s!1, t!1) = sig1
|-------
[1] unifiable(ext(sig1)(s!1), (ext(sig1)(t!1)))
Note que a foÂ´rmula -1 esta quantificada universalmente, e devemos instanciaÂ´-la ade-
quadamente com uma substituicÂ¸aËœo que seja um unificador dos termos s!1 s!2. Esta
substituicÂ¸aËœo sairaÂ´ do fato de que estes dois termos saËœo unificaÂ´veis. Assim, apoÂ´s alguns
passos de prova, obtemos:
[-1] unifier(sigma)(s!1, t!1)
{-2} EXISTS theta: sigma = comp(theta, sig1)
[-3] sub_of_frst_diff(s!1, t!1) = sig1
|-------
[1] s!1 = t!1
[2] EXISTS sigma: unifier(sigma)(ext(sig1)(s!1), (ext(sig1)(t!1)))
Neste ponto da prova temos a foÂ´rmula -2, que eÂ´ uma consequeË†ncia direta do lema
sub_frst_diff_unifier_o, onde temos que existe uma substituicÂ¸aËœo que composta com
sig1 resulta no unificador sigma. EntaËœo skolemizamos esta foÂ´rmula e usamos a variaÂ´vel
skolemizada para instanciar a foÂ´rmula 2. ApoÂ´s alguns passos de prova, temos:
4.5 TerminacÂ¸aËœo e FormalizacÂ¸aËœo de Lemas Sobre o Construtor sub_of_frst_diff 91
{-1} ext(comp(theta, sig1))(s!1) = ext(comp(theta, sig1))(t!1)
[-2] sub_of_frst_diff(s!1, t!1) = sig1
|-------
{1} ext(theta)(ext(sig1)(s!1)) = ext(theta)((ext(sig1)(t!1)))
Assim, como feito no Lema 4.4.2, temos que verificar que dadas duas substituicÂ¸oËœes
Î¸ e Ïƒ quaiquer, vale que Î¸Ì‚ â—¦ Ïƒ = Î¸Ë† â—¦ ÏƒË†. Novamente utilizamos o lema ext_o da teoria
substitution. Reescrevemos com este lema, utilizando a regra rewrite, e completamos a
prova.
CapÂ´Ä±tulo 5
ConclusaËœo e Trabalhos Futuros
Neste trabalho apresentamos uma formalizacÂ¸aËœo para a teoria de unificacÂ¸aËœo de primeira
ordem, desenvolvida em PVS como uma sub-teoria da teoria trs [8] para sistemas de
reescrita de termos, denominada unification. A sub-teoria unification foi desenvolvida
com base no algoritmo de unificacÂ¸aËœo de Robinson, onde formalizamos e provamos a cor-
recÂ¸aËœo de uma versaËœo deste algoritmo, que corresponde a` existeË†ncia de mguâ€™s para termos
unificaÂ´veis.
Na teoria trs encontramos uma base soÂ´lida de conceitos, como por exemplo as defi-
nicÂ¸oËœes de termo, posicÂ¸aËœo, substituicÂ¸aËœo, dentre outros, aleÂ´m de vaÂ´rios resultados forma-
lizados sobre tais conceitos que foram essenciais para o desenvolvimento da sub-teoria
unification.
A partir da formalizacÂ¸aËœo da correcÂ¸aËœo do algoritmo de unificacÂ¸aËœo, feita em dois teoremas
onde provamos que a substituicÂ¸aËœo computada pelo algoritmo de unificacÂ¸aËœo, tendo como
entradas dois termos unificaÂ´veis, eÂ´ um elemento do conjunto de unificadores destes dois
termos e eÂ´ tambeÂ´m mais geral que qualquer outro elemento deste conjunto, chegamos a`
formalizacÂ¸aËœo do resultado principal da sub-teoria unification, o teorema que estabelece
a existeË†ncia de substituicÂ¸oËœes mais gerais para dois termos unificaÂ´veis, que completa a
teoria trs, jaÂ´ que isto foi tratado anteriormente como um axioma. Em particular, na
prova do teorema dos pares crÂ´Ä±ticos de Knuth-Bendix eÂ´ necessaÂ´rio, quando da aplicacÂ¸aËœo
de juntabilidade de divergeË†ncias geradas por instaË†ncias de pares crÂ´Ä±ticos. Assim, com a
conclusaËœo da formalizacÂ¸aËœo deste teorema da sub-teoria unification, atingimos o objetivo
inicial deste trabalho que era desenvolver uma sub-teoria para tratar da existeË†ncia e
unicidade de unificadores mais gerais dentro da teoria trs.
92
5.1 Trabalhos Relacionados 93
Na sub-teoria unification foram formalizados 27 lemas. Alguns lemas auxiliares foram
acrescentados a`s sub-teorias substitution, subterm e position, totalizando 14 lemas. Em
seguida apresentamos na Tabela 5.0.1 alguns dados quantitativos acerca da sub-teoria
unification. Estes dados consistem de informacÂ¸oËœes sobre a quantidade de linhas de
especificacÂ¸aËœo e de prova e sobre o tamanho da especificacÂ¸aËœo e do arquivo de provas.
Tabela 5.0.1: AnaÂ´lise Quantitativa da sub-teoria unification
Arquivos Linhas Tamanho
arquivo de especificacÂ¸aËœo 274 9.6 KB
arquivo de provas 11404 637.4 KB
AleÂ´m dos lemas especificados, tivemos um total de 36 TCCâ€™s gerados, isto eÂ´, 36 obri-
gacÂ¸oËœes de prova geradas automaticamente durante a checagem de tipos realizada pelo
typechecker do PVS. Dentre o total de TCCâ€™s, 30 foram provados manualmente e 6 fo-
ram provados diretamente pelo provador, com alguma dependeË†ncia em relacÂ¸aËœo a TCCâ€™s
anteriores.
Um ponto importante e bastante positivo do assistente de provas PVS, eÂ´ que sua
linguagem de especificacÂ¸aËœo permite desenvolver teorias com uma linguagem muito proÂ´xima
da encontrada nos livros texto. Assim, foi possÂ´Ä±vel desenvolver a sub-teoria unification
de forma que, mesmo um leitor naËœo familiarizado com o PVS naËœo encontre dificuldades
em compreender os conceitos formalizados.
5.1 Trabalhos Relacionados
Existem outras verificacÂ¸oËœes de correcÂ¸aËœo de algoritmos de unificacÂ¸aËœo desenvolvidas em
outros assistentes de prova, por exemplo em LCF por Paulson [24], em Booyer-Moore
por Kaufmann [12], em ACL2 por Ruiz-Reina et al [29], em Coq por Joseph Rouyer [28].
HaÂ´ tambeÂ´m uma formalizacÂ¸aËœo em Isabelle, desenvolvida por Konrad Slind, denominada
Unify, e uma versaËœo melhorada desta, desenvolvida por Alexander Krauss, tambeÂ´m em
Isabelle, denominada Unification.
5.1 Trabalhos Relacionados 94
A primeira formalizacÂ¸aËœo do algoritmo de unificacÂ¸aËœo foi a de Paulson, onde fez-se uma
verificacÂ¸aËœo da teoria de Manna e Waldinger [15] para substituicÂ¸oËœes e unificadores mais
gerais. Na teoria de Manna e Waldinger deriva-se um algoritmo de unificacÂ¸aËœo a partir da
prova de que sua especificacÂ¸aËœo eÂ´ possÂ´Ä±vel. Em contraste com a representacÂ¸aËœo de termos
que usamos neste trabalho, dada pela DefinicÂ¸aËœo 2.2.2, Paulson trata os termos como sendo
ou variaÂ´veis ou constantes ou combinacÂ¸oËœes de dois termos, isto eÂ´, os termos saËœo restritos a
serem binaÂ´rios. A estrutura dos termos eÂ´ construÂ´Ä±da recursivamente em LCF da seguinte
forma, onde COMB eÂ´ um combinador binaÂ´rio:
struct axm(â€œ : termâ€, â€˜strictâ€™,
[ â€˜CONSTâ€™, [â€œc : constâ€];
â€˜VARâ€™, [â€œv : varâ€];
â€˜COMBâ€™, [â€œt1 : termâ€; â€œt2 : termâ€]]); ;
A especificacÂ¸aËœo da teoria Unify desenvolvida por Slind em Isabelle segue a mesma
abordagem feita por Paulson, implementando a formalizacÂ¸aËœo de Manna e Waldinger com
algumas simplificacÂ¸oËœes novas, contudo o algoritmo ainda eÂ´ especificado com base em uma
estrutura de termos construÂ´Ä±dos por um combinador binaÂ´rio:
datatype â€™a uterm =
Var â€™a
| Const â€™a
| Comb "â€™a uterm" "â€™a uterm"
JaÂ´ a teoria Unification, que tambeÂ´m eÂ´ uma formalizacÂ¸aËœo de um algoritmo de unifcacÂ¸aËœo
de primeira ordem, eÂ´ basicamente uma versaËœo melhorada da formalizacÂ¸aËœo preÂ´via onde os
termos saËœo tratados da mesma forma que o fazemos neste trabalho.
datatype â€˜a trm =
Var â€˜a
| Const â€˜a
| App "â€˜a trm" "â€˜a trm" (infix "." 60)
Tanto na teoria Unify como na teoria Unification eÂ´ definido um algoritmo de unificacÂ¸aËœo
e depois prova-se a sua correcÂ¸aËœo. Similarmente a` abordagem apresentada neste trabalho,
notamos que nas especificacÂ¸oËœes feitas em Isabelle, a idempoteË†ncia da substituicÂ¸aËœo compu-
tada pelo algoritmo de unificacÂ¸aËœo naËœo eÂ´ necessaÂ´ria para provar que o algoritmo eÂ´ correto
ou que termina.
5.2 Trabalhos Futuros 95
Como observado anteriormente, o algoritmo de unificacÂ¸aËœo de Robinson eÂ´ ineficiente,
pois eÂ´ exponencial em tempo de execucÂ¸aËœo e em complexidade de espacÂ¸o. No trabalho de
Ruiz-Reina et al, eÂ´ apresentada uma verificacÂ¸aËœo de um algoritmo que usa uma estrutura de
dados eficiente, onde os termos saËœo representados como grafos acÂ´Ä±clicos diretos, o resultado
eÂ´ a formalizacÂ¸aËœo da correcÂ¸aËœo de um algoritmo de unificacÂ¸aËœo quadraÂ´tico em tempo de
execucÂ¸aËœo. Esta especificacÂ¸aËœo eÂ´ baseada na exposicÂ¸aËœo de Corbin e Bidoit [5], onde os
autores mostram que uma escolha apropriada de uma estrutura de dados para representar
termos torna a complexidade do algoritmo de unificacÂ¸aËœo de Robinson, que eÂ´ sabidamente
exponencial, quadraÂ´tica.
5.2 Trabalhos Futuros
Neste trabalho apresentamos uma especificacÂ¸aËœo de um algoritmo que tem como entradas
dois termos unificaÂ´veis, isto eÂ´, excluÂ´Ä±mos a possibilidade de falha no processo de unificacÂ¸aËœo,
pois a fim de obter uma teoria em PVS para sistemas de reescrita de termos, era extrita-
mente necessaÂ´rio mostrar a exiteË†ncia de unificadores mais gerais para termos unificaÂ´veis.
Assim, exercÂ´Ä±cios simples de formalizacÂ¸aËœo podem ser propostos, no sentido de especificar
uma nova funcÂ¸aËœo, para representar uma versaËœo completa do algoritmo de unificacÂ¸aËœo, que
seja total no conjunto de termos, pois esta que especificamos eÂ´ total sobre o conjunto de
termos unificaÂ´veis, onde essa restricÂ¸aËœo foi possÂ´Ä±vel devido ao sistema de tipos dependentes
do PVS. Neste sentido, pode-se idealizar um novo operador que segue a mesma estrutura
do operador sub_of_frst_diff, mas detecte falhas. Para isto comecÂ¸a-se propondo uma
adaptacÂ¸aËœo no operador resolving_diff, que consiste em eliminar restricÂ¸oËœes sobre os pa-
raË†metros. As restricÂ¸oËœes sobre os paraË†metros do operador resolving_diff limitam a acÂ¸aËœo
deste operador a termos unificaÂ´veis e diferentes. Assim, eliminariamos a restricÂ¸aËœo que
limita os paraË†metros a termos unificaÂ´veis. Com isto, se a posicÂ¸aËœo p da primeira diferencÂ¸a
entre os termos s e t, obtida pelo operador modificado resolving_diff, eÂ´ tal que uma das
possibilidades ocorre:
â€¢ s|p e t|p saËœo termos funcionais com sÂ´Ä±mbolos de funcÂ¸aËœo principais diferentes,
â€¢ s|p âˆˆ V e s|p âˆˆ Vars(t|p),
5.2 Trabalhos Futuros 96
â€¢ t|p âˆˆ V e t|p âˆˆ Vars(s|p),
entaËœo o operador modificado sub_of_frst_diff iraÂ´ retornar uma substituicÂ¸aËœo que poderia
ser denominada fail. Algumas mudancÂ¸as no operador unification_algorithm tambeÂ´m
seraËœo necessaÂ´rias, para considerar o caso em que a substituicÂ¸aËœo computada por sub_-
of_frst_diff eÂ´ fail. Outra proposta, mais elaborada de um projeto de formalizacÂ¸aËœo, eÂ´
desenvolver uma especificacÂ¸aËœo de um algoritmo de unificacÂ¸aËœo eficiente, como a de Ruiz-
Reina et-al para ACL2.
AleÂ´m disso, temos outras propriedades importantes sobre unificacÂ¸aËœo e mgu que podem
ser formalizadas na sub-teoria unification. Dentre estas temos a propriedade de idem-
poteË†ncia, que como vimos naËœo eÂ´ necessaÂ´ria na demonstracÂ¸aËœo de generalidade. Contudo
jaÂ´ temos especificado o conceito de substituicÂ¸aËœo idempotente bem como a formalizacÂ¸aËœo
de uma propriedade necessaÂ´ria e suficiente para que uma substituicÂ¸aËœo seja idempotente.
Trata-se de um teorema da sub-teoria substitution onde temos que uma substituicÂ¸aËœo
eÂ´ idempotente se, e somente se o conjunto formado pelas variaÂ´veis do domÄ±Â´nio da subs-
tituicÂ¸aËœo e o conjunto formado pelas variaÂ´veis da imagem da substituicÂ¸aËœo saËœo disjuntos.
Assim, partindo deste lema pode-se formalizar um teorema que garanta a idempoteË†ncia
da substituicÂ¸aËœo computada pelo algoritmo de unificacÂ¸aËœo. Outra propriedade ainda naËœo
formalizada eÂ´ a de unicidade dos mguâ€™s. Para formalizar esta propriedade precisamos da
definicÂ¸aËœo de renomeamento, que jaÂ´ estaÂ´ especificada na sub-teoria substitution. Essenci-
almente deve ser formalizado que para qualquer mgu Î¸ âˆˆ U(s, t), se Ïƒ eÂ´ o mgu computado
pelo algoritmo de unificacÂ¸aËœo, entaËœo Ïƒ eÂ´ uma variante de Î¸ no sentido de que Î¸ . Ïƒ e Ïƒ . Î¸.
ApeË†ndice A
O CoÂ´digo da EspecificacÂ¸aËœo
Neste apeË†ndice apresentamos o coÂ´digo completo da especificacÂ¸aËœo da sub-teoria unifica-
tion, que no capÂ´Ä±tulo 4 foi apresentado por partes. Aqui eÂ´ possÂ´Ä±vel ter uma visaËœo geral da
sub-teoria unification, observando todos os lemas formalizados e a disposicÂ¸aËœo de cada
um dentro da especificacÂ¸aËœo, que finaliza com o teorema 4.3.1.
%%-------------------** Term Rewriting System (TRS) **------------------------
%%
%% Authors : Andreia Borges Avelar and
%% Mauricio Ayala Rincon
%% Universidade de Brasilia - Brasil
%%
%% and
%%
%% Andre Luiz Galdino
%% Universidade Federal de Goias - Brasil
%%
%% Last Modified On: September 29, 2009
%%
%%----------------------------------------------------------------------------
unification[variable: TYPE+, symbol: TYPE+, arity: [symbol -> nat]]: THEORY
BEGIN
ASSUMING
IMPORTING variables_term[variable,symbol,arity],
sets_aux@countability[term],
sets_aux@countable_props[term]
var_countable: ASSUMPTION is_countably_infinite(V)
ENDASSUMING
IMPORTING substitution[variable,symbol, arity]
97
98
Vs: VAR set[(V)]
V1, V2: VAR finite_set[(V)]
V3: VAR finite_set[term]
x, y, z: VAR (V)
tau, sig, sigma,
delta, rho, theta: VAR Sub
st, stp: VAR finseq[term]
r, s, t, t1, t2: VAR term
n: VAR nat
p, q, p1, p2: VAR position
R: VAR pred[[term, term]]
%%%% Defining an instance of a term %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
instance(t, s): bool = EXISTS sigma: ext(sigma)(s) = t;
%%%% Defining substitution more general "<=" %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<=(theta, sigma): bool = EXISTS tau: sigma = comp(tau, theta)
mg_po: LEMMA preorder?(<=)
%%%% Defining unification between two terms %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
unifier(sigma)(s,t): bool = ext(sigma)(s) = ext(sigma)(t)
unifiable(s,t): bool = EXISTS sigma: unifier(sigma)(s,t)
U(s,t): set[Sub] = {sigma: Sub | unifier(sigma)(s,t)}
%%%% Defining a most general unifier "mgu" %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
mgu(theta)(s,t): bool = member(theta, U(s,t)) &
FORALL sigma: member(sigma, U(s,t)) IMPLIES theta <= sigma
%%%% Initial auxiliary lemma %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
uni_diff_equal_length_arg : LEMMA
FORALL (s: term, (t: term | unifiable(s, t) & s /= t), f: symbol,
st: {args: finite_sequence[term] | argsâ€˜length = arity(f)}):
NOT stâ€˜length = 0 AND s = app(f, st) IMPLIES
(FORALL (fp: symbol, stp: {args: finite_sequence[term] |
argsâ€˜length = arity(fp)}): t = app(fp, stp) IMPLIES
(f = fp & stâ€˜length = stpâ€˜length))
%%%% Position of the first difference between %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% two unifiable and different terms %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
99
resolving_diff(s : term, (t : term | unifiable(s,t) & s /= t ) ):
RECURSIVE position =
(CASES s OF
vars(s) : empty_seq,
app(f, st) :
IF length(st) = 0 THEN empty_seq
ELSE
(CASES t OF
vars(t) : empty_seq,
app(fp, stp) :
LET k : below[length(stp)] =
min({kk : below[length(stp)] |
subtermOF(s,#(kk+1)) /= subtermOF(t,#(kk+1))}) IN
add_first(k+1,
resolving_diff(subtermOF(s,#(k+1)),subtermOF(t,#(k+1))))
ENDCASES)
ENDIF
ENDCASES)
MEASURE s BY <<
%%%% Lemmas about resolving_diff %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
resol_diff_nonempty_implies_funct_terms : LEMMA
FORALL (s: term, (t: term | unifiable(s, t) & s /= t)):
resolving_diff(s,t) /= empty_seq IMPLIES
(app?(s) AND app?(t))
resol_diff_to_rest_resol_diff : LEMMA
FORALL (s: term, (t: term | unifiable(s, t) & s /= t)):
LET rd = resolving_diff(s,t) IN
rd /= empty_seq IMPLIES
resolving_diff(subtermOF(s,#(first(rd))),
subtermOF(t,#(first(rd)))) = rest(rd)
position_s_resolving_diff : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t, p : position):
p = resolving_diff(s, t) IMPLIES positionsOF(s)(p);
position_t_resolving_diff : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t, p : position):
p = resolving_diff(s, t) IMPLIES positionsOF(t)(p);
resolving_diff_has_diff_argument : LEMMA
FORALL (s : term, t : term | unifiable(s,t) & s /= t,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
p = resolving_diff(s, t) IMPLIES
subtermOF(s, p) /= subtermOF(t, p)
resolving_diff_has_unifiable_argument : LEMMA
FORALL (s : term, t : term | unifiable(s,t) & s /= t,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
p = resolving_diff(s, t) IMPLIES
unifiable(subtermOF(s, p), subtermOF(t, p))
resolving_diff_vars : LEMMA
100
FORALL (s : term, t : term | unifiable(s, t) & s /= t,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
p = resolving_diff(s, t) IMPLIES
vars?(subtermOF(s, p)) OR vars?(subtermOF(t, p))
%%%% Auxiliary lemmas about substitutions and unifiers %%%%%%%%%%%%%%%%%%%%%%%%
unifier_o : LEMMA
member(sig, U(ext(theta)(s), ext(theta)(t))) IMPLIES
member(comp(sig, theta), U(s, t))
mgu_o : LEMMA
sig <= rho IMPLIES comp(sig, theta) <= comp(rho, theta)
unifier_and_subs : LEMMA
member(theta, U(s, t)) IMPLIES
(FORALL (sig: Sub): member(comp(sig, theta), U(s, t)))
idemp_mgu_iff_all_unifier : LEMMA
FORALL (theta: Sub | member(theta, U(s, t))):
mgu(theta)(s, t) & idempotent_sub?(theta) IFF
(FORALL (sig: Sub | member(sig, U(s, t))): sig = comp(sig, theta))
unifiable_terms_unifiable_args : LEMMA
FORALL (s : term, t : term,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
member(sig, U(s, t)) IMPLIES
member(sig, U(subtermOF(s, p), subtermOF(t, p)))
var_term_unifiable_not_var_in_term : LEMMA
FORALL (s : term, t : term ):
vars?(s) & unifiable(s, t) & s /= t IMPLIES
NOT member(s, Vars(t))
%%%% Substitution to fix the %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% first difference %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sub_of_frst_diff(s : term , (t : term | unifiable(s,t) & s /= t )) : Sub =
LET k : position = resolving_diff(s,t) IN
LET sp = subtermOF(s,k) , tp = subtermOF(t,k) IN
IF vars?(sp)
THEN (LAMBDA (x : (V)) : IF x = sp THEN tp ELSE x ENDIF)
ELSE (LAMBDA (x : (V)) : IF x = tp THEN sp ELSE x ENDIF)
ENDIF
%%%% Lemmas about "sub_of_frst_diff" %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
dom_sub_of_frst_diff_is : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t, sig : Sub):
sig = sub_of_frst_diff(s, t) AND p = resolving_diff(s, t)
IMPLIES
IF vars?(subtermOF(s, p))
THEN Dom(sig) = singleton(subtermOF(s, p))
101
ELSE Dom(sig) = singleton(subtermOF(t, p))
ENDIF
var_sub_1stdiff_not_member_term : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s ,t) IN
FORALL ( x | member(x,Dom(sig)), r | member(r,Ran(sig) )) :
NOT member(x, Vars(r))
sub_of_frst_diff_unifier_o : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
member(rho, U(s, t)) IMPLIES
LET sig = sub_of_frst_diff(s, t) IN
EXISTS theta : rho = comp(theta, sig)
ext_sub_of_frst_diff_unifiable : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
unifiable(ext(sig)(s), (ext(sig)(t)))
sub_of_frst_diff_remove_x : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Dom(sig)(x) IMPLIES
(NOT member(x, Vars(ext(sig)(s)))) AND
(NOT member(x, Vars(ext(sig)(t))))
vars_sub_of_frst_diff_s_is_subset_union : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
subset?(Vars(ext(sig)(s)), union( Vars(s), Vars(t)))
vars_sub_of_frst_diff_t_is_subset_union : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
subset?(Vars(ext(sig)(t)), union( Vars(s), Vars(t)))
union_vars_ext_sub_of_frst_diff : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t) :
LET sig = sub_of_frst_diff(s, t) IN
union(Vars(ext(sig)(s)), Vars(ext(sig)(t)))
= difference(union( Vars(s), Vars(t)), Dom(sig))
vars_ext_sub_of_frst_diff_decrease : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Card(union( Vars(ext(sig)(s)), Vars(ext(sig)(t))))
< Card(union( Vars(s), Vars(t)))
%%%% Function to compute a unifier of %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% two unifiable terms %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
unification_algorithm(s : term, (t : term | unifiable(s,t))) : RECURSIVE Sub =
IF s = t THEN identity
ELSE LET sig = sub_of_frst_diff(s, t) IN
102
comp( unification_algorithm(ext(sig)(s) , ext(sig)(t)) , sig)
ENDIF
MEASURE Card(union(Vars(s), Vars(t)))
%%%% Lemmas about "unification_algorithm" %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
unification_algorithm_gives_unifier : LEMMA
unifiable(s,t) IMPLIES member(unification_algorithm(s, t), U(s, t))
unification_algorithm_gives_mg_subs : LEMMA
member(rho, U(s, t)) IMPLIES unification_algorithm(s, t) <= rho
%%%% Existence of a most general unifier %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
unification : LEMMA
unifiable(s,t) => EXISTS theta : mgu(theta)(s,t)
END unification
ApeË†ndice B
FormalizacÂ¸aËœo do lema
sub_of_frst_diff_remove_x
Apresenta-se a formalizacÂ¸aËœo do lema sub_of_frst_diff_remove_x, com o intuito de apre-
sentar uma formalizacÂ¸aËœo completa, explicando cada regra de prova utilizada.
Neste lema formalizamos o fato de que, se s e t saËœo dois termos unificaÂ´veis e se Ïƒ eÂ´
a substituicÂ¸aËœo que resolve a primeira diferencÂ¸a entre os termos s e t entaËœo, se x eÂ´ uma
variaÂ´vel do domÄ±Â´nio de Ïƒ, entaËœo x naËœo eÂ´ membro de Vars(ÏƒË†(s)) e nem de Vars(ÏƒË†(t)). De
fato, sabemos que Ïƒ substitui todas as ocorreË†ncias de x, em um termo instanciado por Ïƒ,
por Ïƒ(x).
Primeiro apresentamos a especificacÂ¸aËœo deste lema, que tambeÂ´m pode ser encontrada
no apeË†ndice A.
sub_of_frst_diff_remove_x : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Dom(sig)(x) IMPLIES
(NOT member(x, Vars(ext(sig)(s)))) AND
(NOT member(x, Vars(ext(sig)(t))))
Durante a apresetacÂ¸aËœo da formalizacÂ¸aËœo, procederemos da seguinte forma: exporemos
um sequente e em seguida a regra aplicada a este sequente assim como vemos em PVS,
em seguida uma breve explicacÂ¸aËœo da regra aplicada.
Assim, comecÂ¸amos com o seguinte sequente:
103
104
|-------
{1} FORALL (x: (V), s: term, t: term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Dom(sig)(x) IMPLIES
(NOT member(x, Vars(ext(sig)(s)))) AND
(NOT member(x, Vars(ext(sig)(t))))
Rule? (skosimp)
Com a regra skosimp skolemizamos as variaÂ´veis ligadas da foÂ´rmula 1. E obtemos:
|-------
{1} LET sig = sub_of_frst_diff(s!1, t!1) IN
Dom(sig)(x!1) IMPLIES
(NOT member(x!1, Vars(ext(sig)(s!1)))) AND
(NOT member(x!1, Vars(ext(sig)(t!1))))
Rule? (assert)
Com a regra assert, realizamos simplificacÂ¸oËœes atraveÂ´s de procedimentos de decisaËœo. E
obtemos:
|-------
{1} Dom(sub_of_frst_diff(s!1, t!1))(x!1) IMPLIES
(NOT member(x!1, Vars(ext(sub_of_frst_diff(s!1, t!1))(s!1)))) AND
(NOT member(x!1, Vars(ext(sub_of_frst_diff(s!1, t!1))(t!1))))
Rule? (name-replace "sig!1" "sub_of_frst_diff(s!1, t!1)" :hide? nil)
Com a regra name-replace, apenas renomeamos e substituimos todas as ocorreË†ncias
de sub_of_frst_diff(s!1, t!1) por sig!1. E obtemos:
{-1} sub_of_frst_diff(s!1, t!1) = sig!1
|-------
{1} Dom(sig!1)(x!1) IMPLIES
(NOT member(x!1, Vars(ext(sig!1)(s!1)))) AND
(NOT member(x!1, Vars(ext(sig!1)(t!1))))
Rule? (prop)
105
A regra prop eÂ´ uma regra de simplificacÂ¸aËœo proposicional. O sequente acima corresponde
a seguinte situcÂ¸aËœo: D â‡’ A â†’ (Â¬B âˆ¨ Â¬C), com a aplicacÂ¸aËœo da regra prop temos uma
ramificacÂ¸aËœo na prova onde saËœo gerados dois objetivos, um da forma B,D,Aâ‡’ e outro da
forma C,D,Aâ‡’. Explicaremos em seguida apenas o primeiro ramo, o segundo eÂ´ ideË†ntico
e isto pode ser observado na sua formalizacÂ¸aËœo que apresentamos sem comentar. Assim,
temos:
{-1} member(x!1, Vars(ext(sig!1)(s!1)))
[-2] sub_of_frst_diff(s!1, t!1) = sig!1
{-3} Dom(sig!1)(x!1)
|-------
Rule? (lemma "vars_subst_not_in")
Com esta regra, apenas trazemos para o antecedente uma nova foÂ´rmula que corres-
ponde ao lema â€œinvocadoâ€, que neste caso eÂ´ o lema vars_subst_not_in. E obtemos:
{-1} FORALL (t: term[variable, symbol, arity],
sigma: Sub[variable, symbol, arity], x: (V)):
(Dom(sigma)(x) AND
(FORALL (r: term[variable, symbol, arity]):
Ran(sigma)(r) IMPLIES NOT member(x, Vars(r))))
IMPLIES NOT member(x, Vars(ext(sigma)(t)))
[-2] member(x!1, Vars(ext(sig!1)(s!1)))
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] Dom(sig!1)(x!1)
|-------
Rule? (inst -1 "s!1" "sig!1" "x!1")
Agora, instanciamos a hipoÂ´tese do lema â€œinvocadoâ€ com as devidas variaÂ´veis. E obte-
mos:
106
{-1} (Dom(sig!1)(x!1) AND
(FORALL (r: term[variable, symbol, arity]):
Ran(sig!1)(r) IMPLIES NOT member(x!1, Vars(r))))
IMPLIES NOT member(x!1, Vars(ext(sig!1)(s!1)))
[-2] member(x!1, Vars(ext(sig!1)(s!1)))
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] Dom(sig!1)(x!1)
|-------
Rule? (assert)
Novamente realizamos simplificacÂ¸oËœes com a regra assert. E obtemos:
[-1] member(x!1, Vars(ext(sig!1)(s!1)))
[-2] sub_of_frst_diff(s!1, t!1) = sig!1
[-3] Dom(sig!1)(x!1)
|-------
{1} FORALL (r: term[variable, symbol, arity]):
Ran(sig!1)(r) IMPLIES NOT member(x!1, Vars(r))
Rule? (skosimp)
Novamente skolemizamos as variaÂ´veis ligadas da foÂ´rmula 1. E obtemos:
{-1} Ran(sig!1)(r!1)
{-2} member(x!1, Vars(r!1))
[-3] member(x!1, Vars(ext(sig!1)(s!1)))
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] Dom(sig!1)(x!1)
|-------
Rule? (hide -3)
Escondemos a foÂ´rmula -3, pois neste momento ela naËœo eÂ´ necessaÂ´ria na derivacÂ¸aËœo, poreÂ´m
continua na memoÂ´ria do provador, caso desejemos reaveË†-la. Assim, temos:
107
[-1] Ran(sig!1)(r!1)
[-2] member(x!1, Vars(r!1))
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] Dom(sig!1)(x!1)
|-------
Rule? (lemma "var_sub_1stdiff_not_member_term")
Novamente usamos a regra lema para trazer a`s foÂ´rmulas do antecedente o lema cha-
mado, que no caso eÂ´ o lema var_sub_1stdiff_not_member_term. E obtemos:
{-1} FORALL (s: term, t: term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
FORALL (x: (V) | member(x, Dom(sig)),
r: term[variable, symbol, arity] | member(r, Ran(sig))):
NOT member(x, Vars(r))
[-2] Ran(sig!1)(r!1)
[-3] member(x!1, Vars(r!1))
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] Dom(sig!1)(x!1)
|-------
Rule? (inst -1 "s!1" "t!1")
Instanciamos a foÂ´rmula -1 com as devidas variaÂ´veis. E obtemos:
{-1} LET sig = sub_of_frst_diff(s!1, t!1) IN
FORALL (x: (V) | member(x, Dom(sig)),
r: term[variable, symbol, arity] | member(r, Ran(sig))):
NOT member(x, Vars(r))
[-2] Ran(sig!1)(r!1)
[-3] member(x!1, Vars(r!1))
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] Dom(sig!1)(x!1)
|-------
Rule? (replaces -4)
Substituimos todas as ocorreË†ncias de sub_of_frst_diff(s!1, t!1) em todas as foÂ´r-
mulas do sequente, por sig!1, e escondemos a foÂ´rmula -4. Com isto, obtemos:
108
{-1} LET sig = sig!1 IN
FORALL (x: (V) | member(x, Dom(sig)),
r: term[variable, symbol, arity] | member(r, Ran(sig))):
NOT member(x, Vars(r))
{-2} Ran(sig!1)(r!1)
{-3} member(x!1, Vars(r!1))
{-4} Dom(sig!1)(x!1)
|-------
Rule? (assert)
Novamente realizamos simplificacÂ¸oËœes com a regra assert. E obtemos:
{-1} FORALL (x: (V) | member(x, Dom(sig!1)),
r: term[variable, symbol, arity] | member(r, Ran(sig!1))):
NOT member(x, Vars(r))
[-2] Ran(sig!1)(r!1)
[-3] member(x!1, Vars(r!1))
[-4] Dom(sig!1)(x!1)
|-------
Rule? (inst -1 "x!1" "r!1")
Istanciamos a foÂ´rmula -1 com as devidas variaÂ´veis. Neste ponto da prova a operacÂ¸aËœo
de checagem de tipos gera outro subobjetivo. Mas antes temos:
[-1] Ran(sig!1)(r!1)
[-2] member(x!1, Vars(r!1))
[-3] Dom(sig!1)(x!1)
|-------
{1} member[term[variable, symbol, arity]]
(r!1, Ran[variable, symbol, arity](sig!1))
Rule? (hide -2 -3)
Escondemos as foÂ´rmulas -2 e -3 e obtemos:
109
[-1] Ran(sig!1)(r!1)
|-------
[1] member[term[variable, symbol, arity]]
(r!1, Ran[variable, symbol, arity](sig!1))
Rule? (expand "member")
Expandimos a definicÂ¸aËœo de member e com isto obtemos:
[-1] Ran(sig!1)(r!1)
|-------
{1} Ran[variable, symbol, arity](sig!1)(r!1)
Neste ponto obtemos uma contradicÂ¸aËœo, o que nos leva a completar este ramo da prova.
Assim, passamos ao objetivo seguinte onde temos:
[-1] Ran(sig!1)(r!1)
[-2] member(x!1, Vars(r!1))
[-3] Dom(sig!1)(x!1)
|-------
{1} member[(V)](x!1, Dom[variable, symbol, arity](sig!1))
Rule? (hide -1 -2)
Escondemos as foÂ´rmulas -1 e -2 e passamos ao sequente:
[-1] Dom(sig!1)(x!1)
|-------
[1] member[(V)](x!1, Dom[variable, symbol, arity](sig!1))
Rule? (expand "member")
Novamente expandimos a definicÂ¸aËœo de member e obtemos:
[-1] Dom(sig!1)(x!1)
|-------
{1} Dom[variable, symbol, arity](sig!1)(x!1)
110
Onde temos uma contradicÂ¸aËœo. Com isto completamos este ramo da prova e passamos
ao objetivo seguinte.
Como comentamos anteriormente, o proÂ´ximo ramo da prova eÂ´ verificado atraveÂ´s da
mesma sequeË†ncia de regras de provas que acabamos de descrever. Assim, mostramos a
prova deste ramo, mas sem comentar novamente cada regra.
{-1} member(x!1, Vars(ext(sig!1)(t!1)))
[-2] sub_of_frst_diff(s!1, t!1) = sig!1
{-3} Dom(sig!1)(x!1)
|-------
Rule? (lemma "vars_subst_not_in")
{-1} FORALL (t: term[variable, symbol, arity],
sigma: Sub[variable, symbol, arity], x: (V)):
(Dom(sigma)(x) AND
(FORALL (r: term[variable, symbol, arity]):
Ran(sigma)(r) IMPLIES NOT member(x, Vars(r))))
IMPLIES NOT member(x, Vars(ext(sigma)(t)))
[-2] member(x!1, Vars(ext(sig!1)(t!1)))
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] Dom(sig!1)(x!1)
|-------
Rule? (inst -1 "t!1" "sig!1" "x!1")
{-1} (Dom(sig!1)(x!1) AND
(FORALL (r: term[variable, symbol, arity]):
Ran(sig!1)(r) IMPLIES NOT member(x!1, Vars(r))))
IMPLIES NOT member(x!1, Vars(ext(sig!1)(t!1)))
[-2] member(x!1, Vars(ext(sig!1)(t!1)))
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] Dom(sig!1)(x!1)
|-------
Rule? (assert)
[-1] member(x!1, Vars(ext(sig!1)(t!1)))
[-2] sub_of_frst_diff(s!1, t!1) = sig!1
[-3] Dom(sig!1)(x!1)
|-------
{1} FORALL (r: term[variable, symbol, arity]):
Ran(sig!1)(r) IMPLIES NOT member(x!1, Vars(r))
Rule? (skosimp)
111
{-1} Ran(sig!1)(r!1)
{-2} member(x!1, Vars(r!1))
[-3] member(x!1, Vars(ext(sig!1)(t!1)))
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] Dom(sig!1)(x!1)
|-------
Rule? (hide -3)
[-1] Ran(sig!1)(r!1)
[-2] member(x!1, Vars(r!1))
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] Dom(sig!1)(x!1)
|-------
Rule? (lemma "var_sub_1stdiff_not_member_term")
{-1} FORALL (s: term, t: term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
FORALL (x: (V) | member(x, Dom(sig)),
r: term[variable, symbol, arity] | member(r, Ran(sig))):
NOT member(x, Vars(r))
[-2] Ran(sig!1)(r!1)
[-3] member(x!1, Vars(r!1))
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] Dom(sig!1)(x!1)
|-------
Rule? (inst -1 "s!1" "t!1")
{-1} LET sig = sub_of_frst_diff(s!1, t!1) IN
FORALL (x: (V) | member(x, Dom(sig)),
r: term[variable, symbol, arity] | member(r, Ran(sig))):
NOT member(x, Vars(r))
[-2] Ran(sig!1)(r!1)
[-3] member(x!1, Vars(r!1))
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] Dom(sig!1)(x!1)
|-------
Rule? (replaces -4)
{-1} LET sig = sig!1 IN
FORALL (x: (V) | member(x, Dom(sig)),
r: term[variable, symbol, arity] | member(r, Ran(sig))):
NOT member(x, Vars(r))
{-2} Ran(sig!1)(r!1)
{-3} member(x!1, Vars(r!1))
{-4} Dom(sig!1)(x!1)
|-------
Rule? (assert)
112
{-1} FORALL (x: (V) | member(x, Dom(sig!1)),
r: term[variable, symbol, arity] | member(r, Ran(sig!1))):
NOT member(x, Vars(r))
[-2] Ran(sig!1)(r!1)
[-3] member(x!1, Vars(r!1))
[-4] Dom(sig!1)(x!1)
|-------
Rule? (inst -1 "x!1" "r!1")
[-1] Ran(sig!1)(r!1)
[-2] member(x!1, Vars(r!1))
[-3] Dom(sig!1)(x!1)
|-------
{1} member[term[variable, symbol, arity]]
(r!1, Ran[variable, symbol, arity](sig!1))
Rule? (hide -2 -3)
[-1] Ran(sig!1)(r!1)
|-------
[1] member[term[variable, symbol, arity]]
(r!1, Ran[variable, symbol, arity](sig!1))
Rule? (expand "member")
[-1] Ran(sig!1)(r!1)
|-------
{1} Ran[variable, symbol, arity](sig!1)(r!1)
which is trivially true.
[-1] Ran(sig!1)(r!1)
[-2] member(x!1, Vars(r!1))
[-3] Dom(sig!1)(x!1)
|-------
{1} member[(V)](x!1, Dom[variable, symbol, arity](sig!1))
Rule? (hide -1 -2)
[-1] Dom(sig!1)(x!1)
|-------
[1] member[(V)](x!1, Dom[variable, symbol, arity](sig!1))
Rule? (expand "member")
[-1] Dom(sig!1)(x!1)
|-------
{1} Dom[variable, symbol, arity](sig!1)(x!1)
which is trivially true.
RefereË†ncias BibliograÂ´ficas
[1] Mauricio Ayala-RincoÂ´n. Fundamentos da ProgramacÂ¸aËœo LoÂ´gica e Funcional - O
princÂ´Ä±pio de resolucÂ¸aËœo e a teoria de reescrita. Notas de aula, Quarta versaËœo,
Departamento de MatemaÂ´tica, Universidade de BrasÂ´Ä±lia, 2008. DisponÂ´Ä±vel em:
http://ayala.mat.unb.br/.
[2] Franz Baader and Tobias Nipkow. Term Rewriting and All That. Cambridge Uni-
versity Press, 1998.
[3] Franz Baader and Wayne Snyder. Unification Theory. In J.A. Robinson and A. Vo-
ronkov, editors, Handbook of Automated Reasoning, volume I, pages 447â€“533. Elsevier
Science Publishers, 2001.
[4] Robert S. Boyer and J. Strother Moore. The Sharing of Structure in Theorem-Proving
Programs. In Machine Intelligence 7, pages 101â€“116. University Press, 1972.
[5] Jacques Corbin and Michel Bidoit. A Rehabilitation of Robinsonâ€™s Unification Algo-
rithm. In IFIP Congress, pages 909â€“914, 1983.
[6] AndreÂ´ Luiz Galdino. Uma FormalizacÂ¸aËœo da Teoria de Reescrita em Linguagem de
Ordem Superior. PhD thesis, Universidade de BrasÂ´Ä±lia, 2008.
[7] AndreÂ´ Luiz Galdino and Mauricio Ayala-RincoÂ´n. A Theory for Abstract Rewriting
Systems in PVS. CLEI - electronic journal, 11(2, paper 4), 2008.
113
114
[8] AndreÂ´ Luiz Galdino and Mauricio Ayala-RincoÂ´n. A PVS Theory for Term Rewriting
Systems. Electronic Notes in Theoretical Computer Science, 247:67â€“83, 2009.
[9] James R. Guard. Automated Logic for Semi-Automated Mathema-
tics. AFCRL, Scientific Report 1:64â€“411, March 1964. DisponÂ´Ä±vel em:
http://handle.dtic.mil/100.2/AD602710.
[10] Jacques Herbrand. Recherches sur la TheÂ´orie de la DeÂ´monstration. Ph.d. thesis,
University of Paris, November 1971.
[11] GeÂ´rard Huet. Resolution Dâ€™Equations Dans Les Langages Dâ€™Ordre 1, 2,..., Ï‰. PhD
thesis, University of Paris, 1976.
[12] Matt Kaufmann. Generalization in the Presence of Free Variables: A Mechanically-
Checked Proof for one Algorithm. Journal of Automated Reasoning, 7(1):109â€“158,
1991.
[13] Kevin Knight. Unification: A Multidisciplinary Survey. ACM Computing Surveys,
21(1), March 1989.
[14] Donald E. Knuth and Peter B. Bendix. Simple Word Problems in Universal Algebra.
Computational Problems in Abstract Algebra, pages 263â€“297, 1970.
[15] Zohar Manna and Richard Waldinger. Deductive Synthesis of the Unification Algo-
rithm. Science of Computer Programming, 1:5â€“48, 1981.
[16] Alberto Martelli and Ugo Montanari. Unification in Linear Time and Space: A
Structured Presentation. Technical Report Internal Report N0B76âˆ’ 16, Ist. di Ela-
borazione delle Informazione, Consiglio Nazionale delle Ricerche, Pisa, Italy, 1976.
[17] Alberto Martelli and Ugo Montanari. An Efficient Unification Algorithm. Transac-
tions on Programming Languages and Systems, 4(2):258â€“282, April 1982.
[18] Sam Owre and Natarajan Shankar. Abstract Datatypes in PVS. Technical Report
SRI-CSL-93-9R, Computer Science Laboratory, SRI International, Menlo Park, CA,
December 1993. Extensively revised June 1997; Also available as NASA Contractor
Report CR-97-206264. DisponÂ´Ä±vel em: http://pvs.csl.sri.com/.
115
[19] Sam Owre and Natarajan Shankar. The Formal semantics of PVS. Technical report,
SRI-CSL-97-2, Computer Science Laboratory, SRI International, Menlo Park, CA,
August 1997. DisponÂ´Ä±vel em: http://pvs.csl.sri.com/.
[20] Sam Owre and Natarajan Shankar. The PVS Prelude Library. Technical report,
SRI-CSL-03-01, Computer Science Laboratory, SRI International, Menlo Park, CA,
March 2003. DisponÂ´Ä±vel em: http://pvs.csl.sri.com/.
[21] Sam Owre, Natarajan Shankar, John M. Rushby, and David W. J. Stringer-Calvert.
PVS Language Reference. Computer Science Laboratory, SRI International, Menlo
Park, CA, September 1999. DisponÂ´Ä±vel em: http://pvs.csl.sri.com/.
[22] Sam Owre, Natarajan Shankar, John M. Rushby, and David W. J. Stringer-Calvert.
PVS System Guide. Computer Science Laboratory, SRI International, Menlo Park,
CA, September 1999. DisponÂ´Ä±vel em: http://pvs.csl.sri.com/.
[23] Mike S. Paterson and Mark N. Wegman. Linear Unification. In Proceedings of the
Symposium on the Theory of Computing. ACM Special Interest Group for Automata
and Computability Theory (SIGACT), 1976. http://sigact.acm.org.
[24] Lawrence C. Paulson. Verifying the Unification Algorithm in LCF. Science of Com-
puter Programming, 5(2):143â€“169, 1985.
[25] John C. Reynolds. Transformational Systems and the Algebraic Structure of Atomic
Formulas. In Machine Intelligence 5, pages 135â€“151. Edinburgh University Press,
1970.
[26] John Alan Robinson. A Machine-Oriented Logic Based on the Resolution Principle.
Journal of the Association for Computing Machinery, 12(1):23â€“41, January 1965.
[27] John Alan Robinson. Computational Logic: The Unification Computation. Machine
Intelligence, 6:63â€“72, 1971.
[28] Joseph Rouyer. DeÂ´veloppement de lâ€™Algorithme dâ€™Unification dans le Calcul des
Constructions. Technical Report 1795, INRIA, November 1997.
116
[29] JoseÂ´-Luis Ruiz-Reina, Francisco-JesuÂ´s MartÂ´Ä±n-Mateos, JoseÂ´-Antonio Alonso, and
MarÂ´Ä±a-JoseÂ´ Hidalgo. Formal Correctness of a Quadratic Unification Algorithm. Jour-
nal of Automated Reasoning, 37(1-2):67â€“92, 2006.
[30] Natarajan Shankar, Sam Owre, John M. Rushby, and David W. J. Stringer-Calvert.
PVS Prover Guide. Computer Science Laboratory, SRI International, Menlo Park,
CA, September 1999. DisponÂ´Ä±vel em: http://pvs.csl.sri.com/.
[31] Marisa Venturini-Zilli. Complexity of the Unification Algorithm for First-Order Ex-
pressions. Calcolo, 12(4):361â€“371, December 1975.
