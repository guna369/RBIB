Explicit Substitutions and All That
Mauricio Ayala-Rincon
y
Cesar Mu~noz
z
July 3, 2000
Abstract
Explicit substitution calculi are extensions of the -calculus where the substitution mechanism is
internalized into the theory. This feature makes them suitable for implementation and theoretical study
of logic based tools as strongly typed programming languages and proof assistant systems. In this paper
we explore new developments on two of the most successful styles of explicit substitution calculi: the -
and s
e
-calculi.
Keywords: Explicit substitution, higher order unication, lambda-calculi, type and rewriting theory
1 Introduction
This paper focuses on the uses of explicit substitutions in the language of the simply-typed -calculus. Type
theories were used at the beginning of the twentieth century as a formalism to deal with the mathematical
paradoxes studied at that time and incorporated in 1940 to the -calculus by A. Church [11]. The need
of stronger programming languages guided type theory to the interest of computer scientists in the 1970's
and 1980's, when new languages based on type theories were developed. Probably the most relevant of
these languages is ML [42], developed by R. Milner. In the 1990's, several proof assistant systems based
on higher-order logics, such as Coq [5], HOL [27], and PVS [52], were developed. The -calculus is the
simplest logical framework for reasoning about formal properties of all these systems and many of the
essential techniques and computational procedures involved in these systems have been developed, analyzed,
and improved in the context of the typed -calculus before being implemented. These techniques include
simple mechanisms as type checking and type inference, and more complex ones as the used for dealing with
the inhabitation problem and the higher order unication problem. The basic operation of the -calculus
is the -conversion that was originally dened based on an implicit notion of substitution were renaming
of variables was informally assumed to avoid \clashes" and \captures". This implicitness of the notion of
substitution was not critical before this theoretical framework was used in other contexts than the ones of
computer science, but making the notion of substitution explicit is essential when computational properties
such as time and space complexity should be analyzed.
We will focus on two styles of explicit substitutions:  and s
e
. These calculi use a name-less notation
for variables. Therefore, technical nuisances due to the higher order aspect of -calculus, as renaming and
capture of variables, are minimized or completely eliminated in  and s
e
. For these calculi, we will motivate
and illustrate dierent techniques developed for important computational problems and applications such as
higher order unication, type inference, and inhabitation problem. These kind of problems arise naturally
in many elds of computer science. Some of the current progress in the area of explicit substitution is
recorded in the series of \International Workshops on Explicit Substitutions: Theory and Applications to
Programs and Proofs" - WESTAPP that runs yearly together with the Conference on Rewriting Techniques
and Applications - RTA. For other surveys and tutorials on explicit substitution calculi see [38, 57].

Departamento de Matematica, Universidade de Braslia, 70910-900 Braslia D.F., Brasil, ayala@mat.unb.br.
y
Work carried out during visit of this author at the ULTRA Group, CEE, Heriot-Watt University, Edinburgh, Scotland
funded by CAPES (BEX0384/99-2) Brazilian Foundation.
z
Institute for Computer Applications in Science and Engineering, Mail Stop 132C, NASA Langley Research Center, Hampton.
VA 23681-2199, USA, munoz@icase.edu.
1
Firstly, in section 2 we present basic notions of the -calculus, its representation in de Bruijn index
notation, its simply-typed version, and the Curry-Howard isomorphism. Afterwards, in section 3, we motivate
explicit substitutions and present the two before mentioned calculi of explicit substitutions along with their
simply-typed versions. In section 4, we explain briey the applications of explicit substitutions before
concluding in section 5.
2 The -calculus
The -calculus was developed by Church around 1930 [12] as a formal language for the foundations of
mathematics and logic. Although that foundation was later revealed to be inconsistent, indeed Russell
paradox [59] can be encoded in it, the -calculus still provides a formal model of computability. Church
and Kleene [37, 10] proved that the class of -expressions and the class of partial-recursive functions are
the same. This result, along with Turing's own work, shows that the -calculus is as expressive as Turing
machines.
The notation consists of a set  of terms and rules to manipulate them. The set  is built on a countable
set of variables V = fx; y; : : : g and it is inductively dened as follows: V  , if M;N 2  then (M N) 2 ,
and if x 2 V and M 2  then x:M 2 . Terms of the form (M N) are called applications and terms of the
form x:M are called abstractions. Abstractions are binding structures. As usual for these kind of structures,
a notion of free and bound variables is necessary. The set of free variables of M , denoted FV (M), is dened
by FV (x) = fxg, FV ((M N)) = FV (M) [ FV (N), and FV (x:M) = FV (M) n fxg. The variable x in
a term x:M is said to be bound. Names of bound variables are irrelevant. For instance, x:x and y:y
represent the same -term. This implicit equivalence is called -conversion. Formally, if z 62 FV (M), then
x:M =

z:Mfz=xg, where for an arbitrary term N , MfN=xg denotes the atomic substitution of the free
occurrences of the variable x in M by N .
Substitution plays a very important role in the -calculus. In fact, the main computational rule in this
formalism, the -rule, is expressed as follows: (x:M N)

-
MfN=xg. Informally, it states that the
application of a function x:M to an argument N , results in a term MfN=xg where the formal parameter x
has been replaced by the argumentN inM (the body of the function). An additional rule, called , states that
abstractions computing the same value for the same argument are convertible. Formally, x:(M x)

-
M ,
if x 62 FV (M).
The formal denition of substitution is not as simple as it seems. The following one, commonly used in im-
plementations, is wrong: xfM=xg =M , yfM=xg = y, if y 6= x, (M
1
M
2
)fM=xg = (M
1
fM=xg M
2
fM=xg),
(x:N)fM=xg = x:N , and (y:N)fM=xg = y:NfM=xg, if y 6= x. The problem arises in the last
case: the term M may contain a free variable y which becomes a bound variable when the substitution
is applied. A correct denition should avoid this capture; for instance, by modifying the last case with
(y:N)fM=xg = z:Nfz=ygfM=xg, where z 62 FV (M).
The -calculus is not terminating. Indeed, a term like (x:(x x) x:(x x)) -reduces to itself and then
it can be always reduced. However, the -calculus satises, the Church-Rosser property i.e., if M
1
=

M
2
,
then there exists N such that M
1


-
N and M
2


-
N .
1
In consequence: (1) the -calculus is also
conuent and (2) normal forms, it they exist, are unique. We refer to [3] for a complete description of the
-calculus and its properties.
2.1 De Bruijn indices
At the beginning of the seventies, de Bruijn developed a nameless notation for the -calculus [19]. In that
notation, names of bound variables are replaced with indices.
Denition 2.1 The set 
dB
of -terms in de Bruijn index notation is dened inductively as
M;N ::= n j (M N) j M
1
As usual, if R is a term rewrite system, we denote by
R
-
the relation induced by R and by
R

-
the reexive,
symmetric, and transitive closure of
R
-
. Furthermore, the equational theory associated to R denes a congruence denoted
by =
R
.
2
where n 2 N
>0
.
An index counts the number of -symbols in the binding scope of the bound variable that it represents.
For instance, in de Bruijn index notation, the term x:x is written 1 since the bound variable x is in the
binding scope of one -symbol. Similarly, the term x:(y:(x y) x) is written ((2 1) 1). Note that the
same index appearing in dierent binding scopes represents dierent variables. Vice-versa, occurrences of
the same variable appearing in dierent binding scopes are denoted by dierent indices.
Free variables can also be represented by de Bruijn indices. In that case, it is necessary to x an
enumeration, namely a referential, x
1
; x
2
; : : : ; x
n
, of free variable names. If the occurrence of a variable is
denoted by an index n and the number of -symbols in the binding scope of that occurrence is less than n,
say m, then that occurrence of n represents the free-variable x
n m
of the referential. For instance, the term
(x:(y x) z) can be encoded as ((2 1) 2) under the referential y; z and as ((3 1) 1) under the referential
z; y.
The formulation of the rules  and  for 
dB
-terms requires the following functions for updating and
substitution of indices.
Denition 2.2 Let M 2 
dB
. The i-lift of M , denoted M
+i
is dened inductively as follows
1. (M
1
M
2
)
+i
= (M
+i
1
M
+i
2
);
2. (N)
+i
= N
+(i+1)
;
3. n
+i
=

n+ 1; if n > i
n; if n  i
The lift of a term M is its 0-lift and is denoted briey as M
+
.
Denition 2.3 The application of the substitution with N at the depth n   1 on a term M , denoted
MfN=ng, is dened inductively as follows
1. (M
1
M
2
)fN=ng = (M
1
fN=ng M
2
fN=ng);
2. (M)fN=ng = MfN
+
=n+ 1g;
3. mfN=ng =
8
<
:
m  1; if m > n
N; if m = n
m; if m < n
Denition 2.4 The rules  and  are dened for the set of 
dB
-terms as follows
(M N)

-
MfN=1g
(M 1)

-
N; if N
+
=M
Example 2.5 The -term (x:(y:(x z) x) (z z:(x z))) can be translated under the referential x; y; z
into the 
dB
-term (((2 5) 1) (3 (2 1))). Furthermore, we have
(x:(y:(x z) x) (z z:(x z)))

-
(y:((z z:(x z)) z) (z z:(x z))):
We examine in detail the steps of that reduction for 
dB
-terms:
(((2 5) 1) (3 (2 1)))

-
((2 5) 1)f(3 (2 1))=1g
= (((2 5))f(3 (2 1))=1g 1f(3 (2 1))=1g)
= ((2 5)f(3 (2 1))
+
=2g (3 (2 1)))
= ((2 5)f(3
+
(2
+1
1
+1
))=2g (3 (2 1)))
= ((2 5)f(4 (3 1))=2g (3 (2 1)))
= ((2f(4 (3 1))=2g 5f(4 (3 1))=2g) (3 (2 1)))
= (((4 (3 1)) 4) (3 (2 1)))
3
The 
dB
-term (((4 (3 1)) 4) (3 (2 1))) represents the term (y:((z z:(x z)) z) (z z:(x z))) under
the given referential. 
Example 2.6 Notice that
(((5 (1 2)) 4) 1)

-
((4 (1 2)) 3)
since
((4 (1 2)) 3)
+
= (((4 (1 2)))
+
3
+
)
= (((4 (1 2)))
+1
3
+
)
= ((4 (1 2))
+2
3
+
)
= ((4
+2
(1 2)
+2
) 3
+
)
= ((4
+2
(1
+2
2
+2
)) 3
+
)
= ((5 (1 2)) 4)

2.2 Simply-typed -calculus
The -calculus is a simple, but yet powerful formalism. As we said before, when used as a logical framework,
the -calculus allows to encode paradoxes. To solve that problem, Church developed a typed version of the
-calculus [11] with happens to be a simplication of the Type Theory of Whitehead-Russell [59].
The eect of typed -calculus can be seen on a term such as x:(x x) which is a well formed term in the
untyped -calculus that represents the abstract concept of \self-application". The meaningfulness of this
concept may be questioned and was involved in many of the logical paradoxes from the beginning of the
twentieth century. Thinking about x as a functional variable from A to A or of \type A!A", the application
(x x) is forbidden, since it's impossible to apply a function of type A!A to an argument of type A!A.
This coincides with the conception of functional objects assumed by most mathematicians. Of course, if z
is a variable of type A, the typed expression x:(x (x z)) makes sense. For a formal introduction to the
theory of the simply-typed -calculus plentiful of interesting historical remarks see [30].
In a typed -calculus, -terms are stratied in several categories, namely types. A type, in the simple type
theory, can be a basic type a; b; : : : or a functional type A!B, where A and B are types. We use upper-case
letters A;B : : : to range over types. Only terms that follow a type discipline are considered to be valid. The
type discipline is enforced by a set of typing rules. Thanks to the typing rules, Russell's paradox cannot be
expressed in the simple type theory.
Typed -terms are elements of the set of -terms except that bound variables in abstractions have type
annotations, i.e., they have the form x:A:M . Rules  and  are modied accordingly:
(x : A:M N)

-
MfN=xg and x : A:(M x)

-
M , if x 62 FV (M)
A typing judgment   `M : A denotes that the term M has type A in  , where   is a context, i.e., a list
x
1
:A
1
; : : : ; x
n
:A
n
of variable declarations. Henceforth, we use Greek letters  ;; : : : to range over contexts.
Figure 1 shows the typing rules of the simply-typed -calculus. We say that a -term M is well typed in  
if and only if there exists a type A such that   ` M : A, and we say that a type A is inhabited in   if and
only if there exists a -term M such that   `M : A.
The presentation of the typed -calculus used in this paper corresponds to the Church-style. In this
presentation, typed -terms are elements of the set of -terms except for abstractions, which have type
annotations. An alternative presentation, called Curry-style, considers typed -terms as standard -terms
without type annotations. In that case, type variables should be considered. Indeed, in a typed -calculus a
la Curry, the type of x:x is ! where  denotes any type (See [4]).
Type checking is decidable for the simply typed -calculus. That is, there is a method to decide whether
or not a term has a type in a given context according to the typing rules. As the untyped version of the
4
x 62  
(Start)
x:A;  ` x : A
x 62     `M : B
(Weak)
x:A;  `M : B
x:A;  `M : B
(Abs)
  ` x:A:M : A!B
  `M : A!B   ` N : A
(Appl)
  ` (M N) : B
Figure 1: The simply-typed -calculus
1  i  n
(Var)
A
1
:A
2
:: : : A
n
` i : A
i
A:  `M : B
(Abs)
  ` 
A
:M : A!B
  `M : A!B   ` N : A
(Appl)
  ` (M N) : B
Figure 2: The simply-typed -calculus for 
dB
-terms
-calculus, the simply-typed -calculus enjoys the Church-Rosser property and therefore it is also conuent.
Furthermore, it also satises the following properties.
 Subject reduction, if   `M : A and M

-
N , then   ` N : A;
 Type uniqueness, if   `M : A and   `M : B, then A = B;
 Strong normalization, ifM is a well typed term, thenM has no reductions of innite length. Therefore,
due to the conuence property, normal-forms of well typed terms always exists and they are unique.
In the de Bruijn setting of the simply typed -calculus, a context   is a list of types A
1
:: : ::A
n
where A
i
is the type of the free-variable represented by the index i. The empty context is denoted by . Simply-typed

dB
-terms are dened by the typing rules of Fig. 2.
2.3 Curry-Howard isomorphism
There is a strong relation between type theory and intuitionistic logic. Indeed, if we identify types with
propositions, where an arrow type is an implication, typing rules of the simply-typed -calculus corresponds
one to one to deduction rules of a minimal intuitionistic logic. In other words, typing rules are logical rules
decorated with typed -terms. This principle is known as the Curry-Howard isomorphism.
Consider an intuitionistic minimal logic where propositional formulas are built from atomic propositions
a; b; : : : and the implication, i.e., if A and B are formulas then A!B is a formula. We use uppercase Greek
letters 
 to range over set of formulas. We write 
; A as a shorthand for 
 [ fAg. A judgment 
 `
I
A
denotes that A is a logical consequence of 
. A judgment is said provable (in the minimal intuitionistic
logic) if and only if it is derived by top-down application of the following rules:
(Axiom)

; A `
I
A

; A `
I
B
(Intro)

 `
I
A!B

 `
I
A!B 
 `
I
A
(Elim)

 `
I
B
A formula A is a tautology if and only if the judgment `
I
A is provable. For example, the formula
A!((A!B)!B) is a tautology since it can be derived as follows:
(Axiom)
A;A!B `
I
A!B
(Axiom)
A;A!B `
I
A
(Elim)
A;A!B `
I
B
(Intro)
A `
I
(A!B)!B
(Intro)
`
I
A!((A!B)!A)
5
Formally, the Curry-Howard isomorphism says that 
 `
I
A is provable in the minimal intuitionistic
logic if and only if   ` M : A is a valid typing judgment in the simply-typed -calculus, where   is a list
of variable declaration of propositions, seen as types, in 
. The term M is a -term that represents the
proof derivation. For instance, the term decoration of the tree derivation above results in the valid typing
judgment ` x:A:y:A!B:(y x) : A!((A!B)!A).
The Curry-Howard isomorphism is extended to intuitionistic rst order and higher order logics and it
is widely studied in proof theory. It is at the base of mathematic formalizations where proofs are just
mathematical objects. Such languages are the base of automatic systems for proof construction, program
verication and program synthesis.
3 Explicit Substitutions
Implicitness of substitution is the Achilles heel of the -calculus. Namely, the -calculus is a convenient and
compact model of the computable functions but it does not provide any mechanism for observing essential
operational properties of these functions as time and space complexity. The reason of this is that the
substitution involved in -reductions does not belong in the calculus, but rather in an informal meta-level.
In the practice, -reduction is not a primitive operation and is implemented based on a substitution generally
elaborated by renaming variables and/or maintaining some variable convention. That makes impossible to
determine or bound in time and space the -reduction.
The -calculus was the rst one presented formally as a mechanism for making explicit substitution
in the -calculus [1]. But before this, today widely considered seminal work, many empiric and theoretic
eorts were realized in order to solve the problem of implicitness of the substitution operation. From the
theoretical point of view, the Combinatory Logic of Curry and Feys [18] proposed the rst solution to this
problem. However, this setting does not remain close to the -calculus and the number of primitive steps
can be extensively larger than the required by explicit substitution calculi. From the empirical point of view,
perhaps the person who provide the foundations to take care of this problem was de Bruijn itself, when
developing his system AUTOMATH from the middle of the 1960's. Part of his primary conceptions was the
previously here mentioned nice nameless notation for the -calculus [19] and his legacy is collected in [51].
Since the -calculus was introduced in [1], several other variants of explicit substitution calculi have
been proposed (see, for example, [55, 38, 32, 7, 39, 17, 35, 43, 24, 44]). These calculi implement several styles
of explicit substitutions.
We will focus our attention on two of these styles: the - and the s
e
-styles. Both of them use a nameless
notation based on the de Bruijn index notation, which is completely insensitive to -conversion. That allows
a clean and elegant meta-theoretical study of the calculi which make them suitable for implementation of
declarative programming languages, higher order proof assistants, and automated deductive systems. Both
styles were shown incomparable in [34].
The -calculus and its variants have been proposed as a general framework for higher order unication
and term synthesis [21, 22, 9, 36, 45, 47, 46, 6]. Furthermore, calculi of the -family have been incorporated
with success into programming languages and proof assistants. For example, an algorithm for pattern
unication for dependent types, based on , has been implemented in the Twelf system [53]. It has also
been relevant in the improvement of the explicit substitution for the rewrite calculus (-calculus [14]) of the
ELAN system, which provides a language based on rewrite rules for specifying and prototyping deductive
systems [13].
The s
e
-calculus [32, 33] was developed more recently than the -calculus and its main claimed advan-
tage over the -calculus is that it remains as close as possible to the -calculus having only one sort of
objects. There is a close relation, until now only subjectively purposed, between the s
e
-calculus and the
rewrite rules developed by Nadathur and Wilson in the early 1990's and used in the implementation of the
higher order logic programming language Prolog [41]. For instance the laziness in the substitution needed
in implementations of -reduction, that arises naturally in the s
e
-calculus, is provided as the informal but
empirical concept of suspension of substitutions by Nadathur and Wilson rewrite rules, being their notion of
substitution more general than the s
e
one. More recently their rewrite rules were published in the context
of explicit substitution as the suspension calculus [49, 50]. Establishing formally the relations and dierences
between the s
e
-calculus and the suspension calculus remains as an important work to be done.
6
(M N)  ! M [N  id] (Beta)
(M N)[S]  ! (M [S] N [S]) (App)
(M)[S]  ! M [1  (S √Ü ")] (Abs)
M [S][T ]  ! M [S √Ü T ] (Clos)
1[M  S]  ! M (VarCons)
M [id]  ! M (Id)
(S
1
√Ü S
2
) √Ü T  ! S
1
√Ü (S
2
√Ü T ) (Assoc)
(M  S) √Ü T  ! M [T ]  (S √Ü T ) (Map)
id √Ü S  ! S (IdL)
S √Ü id  ! S (IdR)
" √Ü (M  S)  ! S (ShiftCons)
1  "  ! id (VarShift)
1[S]  (" √Ü S)  ! S (SCons)
(M 1)  ! N if M =

N ["] (Eta)
Figure 3: The -calculus [1]
3.1 The -calculus
The -calculus is a rst order rewrite system with two sorts of expressions: terms and substitutions. In
fact, substitutions inherent to the -rule in de Bruijn index notation, (M N)

-
MfN=1g, are delayed
and recorded in the -calculus as (M N)
-
M [N  id]. Here, M [N  id] is a -expression representing
M with a recorded substitution N  id. Additional rules are necessary for applying the recorded substitution
to the term M , i.e., replacing all the the free occurrences of the de Bruijn index 1 at M with N and
decrementing by one all the rest of free de Bruijn indices over M . Delaying application of substitution
is widely used in implementations of functional and logical programming languages, because performing
immediately substitution may give rise to a size explosion of the expressions.
Denition 3.1 (-calculus) The -calculus is dened by the rewrite system depicted in Fig. 3 where
Terms M;N ::= 1 j M j (M N) jM [S]
Substitutions S; T ::= id j " jM  S j S √Ü T
The rewrite system obtained by dropping rules (Beta) and (Eta) of  is called .
In , de Bruijn indices are encoded by means of the constant 1 and the substitution ". We write "
n
as
a shorthand for
n-times
z }| {
" √Ü : : : √Ü ". We overload the notation i to represent the -term corresponding to the index
i, i.e.,
i =

1 if i = 1
1["
n
] if i = n+ 1:
This one-shift encoding is interesting because involving a built-in deduction mechanism for arithmetic in
implementations of systems based on the -calculus makes it di√Ücult the analysis of time and space quan-
titative performance. But in any conceivable implementation one should use full indices at the meta-level
instead of the one-shift encoding.
An explicit substitution denotes a mapping from indices to terms. Thus, id maps each index i to the
term i, " maps each index i to the term i+ 1, S √Ü T is the composition of the mapping denoted by T with
the mapping denoted by S (notice that the composition of substitution follows a reverse order with respect
to the usual notation of function composition), and nally, M  S maps the index 1 to the term M , and
recursively, the index i+ 1 to the term mapped by the substitution S on the index i.
7
(M N)  ! M [N  "
0
] (Beta)
(M)[S]  ! M [1  (S √Ü "
1
)] (Abs)
(M N)[S]  ! (M [S] N [S]) (App)
M [S][T ]  ! M [S √Ü T ] (Clos)
1[M  S]  ! M (VarCons)
M ["
0
]  ! M (Id)
(M  S) √Ü T  ! M [T ]  (S √Ü T ) (Map)
"
0
√Ü S  ! S (IdS)
"
n+1
√Ü (M  S)  ! "
n
√Ü S (ShiftCons)
"
n+1
√Ü "
m
 ! "
n
√Ü "
m+1
(ShiftShift)
1  "
1
 ! "
0
(Shift0)
1["
n+1
]  "
n+2
 ! "
n+1
(ShiftS)
(M 1)  ! N if M =
L
N ["
1
] (Eta)
Figure 4: The rewrite system 
L
The -calculus is not a conuent rewrite system [17], however it is conuent on ground expressions [1]
and conuent on substitution-closed expressions (i.e., expressions without substitution variables) [55]. On
the other hand, the -calculus, i.e.,  without (Beta), is conuent and terminating [1].
A term is called pure if it does not contain substitutions. Notice that the set of pure terms in  and
the set of 
dB
-terms are identiable. Furthermore, the -calculus simulates the -calculus [17], i.e., the
relations induced by

-
and
(Beta)
-


-
(one step of (Beta) followed by a -normalization) coincide
on pure terms. However, the -calculus does not preserve strong-normalization of the -calculus [40], i.e.,
strongly normalizing -terms can be reduced forever in .
3.2 The 
L
-calculus
As pointed out before, the one-shift encoding of indices in  is a theoretically convenient feature, but
impractical for implementations. Nadathur also remarked in [48] that the non-left-linear rule of , namely
(SCons), is di√Ücult to handle in real implementations. Instead of rule (SCons), he suggested the meta-rule
1["
n
]  "
n+1
-
"
n
. Since "
n
is a shorthand in , an innite set of rules is represented by this scheme.
Non-left-linear rules are not only annoying to implement, but they are usually responsible for non-
conuence and typing problems. Indeed,  is not conuent [17] and it does not preserve typing in a
dependent-type system [45], both problems because of the non-left-linearity of the calculus.
The 
L
-calculus [44] is a left-linear variant of  where "
n
is a rst-class substitution. This allows the
formulation of the rule suggested by Nadathur as a regular rst order rule. In fact, instead of (SCons), the
the 
L
-calculus has the following rule: 1["
n+1
]  "
n+2
-
"
n+1
.
Denition 3.2 (
L
-calculus) The 
L
-calculus is dened by the rewrite system depicted in Fig. 4 where
Natural numbers n ::= 0 j n+ 1
Terms M;N ::= 1 j M j (M N) jM [S]
Substitutions S; T ::= "
n
jM  S j S √Ü T
The L-rewrite system is obtained by dropping rule (Beta) from 
L
.
We adopt the notation i as a shorthand for 1["
n
] when i = n+1. Substitutions id and " are written in 
L
as "
0
and "
1
, respectively. In general, "
n
denotes the mapping of each index i to the term i+ n. Using "
n
,
the scheme of rule proposed by Nadathur can be encoded in a rst order rewrite system. Natural numbers
are constructed with 0 and n+ 1. Arithmetic calculations on indices are embedded in the rewrite system.
The 
L
-calculus is conuent on substitution-closed expression and it simulates the -calculus [45]. Just
as , it does not preserve strong normalization.
8
(M N)  ! M 
1
N (-generation)
(M)
i
N  ! (M 
i+1
N) (--transition)
(M
1
M
2
)
i
N  ! ((M
1

i
N) (M
2

i
N)) (-app-transition)
n
i
N  !
8
<
:
n  1 if n > i
'
i
0
N if n = i
n if n < i
(-destruction)
'
i
k
(M)  ! ('
i
k+1
M) ('--transition)
'
i
k
(M
1
M
2
)  ! (('
i
k
M
1
) ('
i
k
M
2
)) ('-app-transition)
'
i
k
n  !

n+ i  1 if n > k
n if n  k
('-destruction)
(M
1

i
M
2
)
j
N  ! (M
1

j+1
N) 
i
(M
2

j i+1
N) if i  j (--transition)
('
i
k
M)
j
N  ! '
i 1
k
M if k < j < k + i (-'-transition 1)
('
i
k
M)
j
N  ! '
i
k
(M 
j i+1
N) if k + i  j (-'-transition 2)
'
i
k
(M 
j
N)  ! ('
i
k+1
M)
j
('
i
k+1 j
N) if j  k + 1 ('--transition)
'
i
k
('
j
l
M)  ! '
j
l
('
i
k+1 j
M) if l + j  k ('-'-transition 1)
'
i
k
('
j
l
M)  ! '
j+i 1
l
M if l  k < l + j ('-'-transition 2)
(M 1)  ! N if M =
s
e
'
2
0
N (Eta)
Figure 5: Rewriting system of the s
e
-calculus
Another left-linear variant of  is the 
*
-calculus [17]. The 
*
-calculus is a conuent rst order
rewrite system, i.e., it is conuent on presence of both term and substitution variables. However, 
*
raises some technical problem with -conversions due to the fact that substitutions id and 1  " are not

*
-convertible.
3.3 The s
e
-calculus
The s
e
-calculus avoids introducing two dierent sets of entities as the -calculus does, insisting in this
way on remaining close to the syntax of the -calculus. Next to abstraction and application, the s
e
-calculus
introduces substitution () and updating (') operators.
Denition 3.3 (s
e
-calculus) The s
e
-calculus is given by the rewrite system in Fig. 5 and the grammar
M;N ::= n j (M N) j M jM
j
N j '
i
k
M for n; j; i  1 and k  0:
The calculus of substitutions associated with the s
e
-calculus, namely s
e
, is the rewriting system generated
by the set of rules s
e
= s
e
  f-generation;Etag.
Intuitively, the substitution operator, , initiates (rule (-generation)) one-step of -reduction, from
(M N), propagating the associated substitution innermost (rules (-) and (-app-transition)). Once this
propagation is nished, when necessary, the updating operator, ', is introduced to make the appropriate lift
over N (rule (-destruction)). Otherwise either free de Bruijn indices are decremented by one or bounded
maintained.
The s
e
-calculus simulates -reduction and is conuent [33]. It does not preserve strong normalization
[28].
3.4 Simply-typed calculi of explicit substitutions
In this section, we only include the essential notation of the simply-typed 
L
- and s
e
-calculi. Properties
can be found in detail in [44] and [32], respectively. Typing rules in both calculi follow the scheme as those
of the simply-typed -calculus [21].
9
(Var)
A:  ` 1 : A
A:  ` N : B
(Lambda)
  ` 
A
:N : A!B
  `M : A!B   ` N : A
(App)
  ` (M N) : B
  ` S .   `M : A
(Clos)
  `M [S] : A
(Id)
  ` "
0
.  
  ` "
n
. 
(Shift)
A:  ` "
n+1
. 
  `M : A   ` S . 
(Cons)
  `M  S . A:
  ` T . 
2

2
` S . 
1
(Comp)
  ` S √Ü T . 
1
Figure 6: Typing rules for the 
L
-calculus
(Var)
A:  ` 1 : A
  ` n : B
(Varn)
A:  ` n+ 1 : B
A:  ` N : B
(Lambda)
  ` 
A
:N : A!B
  ` N : A!B   `M : A
(App)
  ` (N M) : B
 
i
` N : B  
<i
:B: 
i
`M : A
(Sigma)
  `M 
i
N : A
 
k
: 
k+i
`M : A
(Phi)
  ` '
i
k
M : A
Figure 7: Typing rules for the s
e
-calculus
The rewrite rules of the typed 
L
- and s
e
-calculi are dened by adding to their respective set of rules
the necessary typing information. Thus, for the simply-typed 
L
-calculus we have the typed rules:
(
A
:M N)  ! M [N  "
0
] (Beta)
(
A
:M)[S]  ! 
A
:M [1  (S √Ü "
1
)] (Abs)

A
:(M 1)  ! N if M =
L
N ["
1
] (Eta)
and for the typed s
e
-calculus:
(
A
:M N)  ! M 
1
N (-generation)
(
A
:M)
i
N  ! 
A
:(M 
i+1
N) (--transition)
'
i
k
(
A
:M)  ! 
A
:('
i
k+1
M) ('--transition)

A
:(M 1)  ! N if M =
s
e
'
2
0
N (Eta)
Typing rules for the 
L
-calculus and the s
e
-calculus are presented in the Figures 6 and 7, respectively.
Notice that in the case of the 
L
-calculus, substitutions receive contexts as types. This is denoted as
  ` S . . Let   be a context of the form A
1
:A
2
:::A
n
:. We use the notation  
k
and  
k
for denoting
the contexts A
1
:::A
k
and A
k
:::A
n
:, respectively. This notation is extended for \<" and \>" in the obvious
manner.
Example 3.4 In order to illustrate the use of the typing rules, we show how to infer the type of the term

A!B
:
B!C
:
A
:(2 (3 1)) in s
e
.
For short, let   = A:B!C:A!B. Firstly, observe that
(Var)
(1)   ` 1 : A
(Var)
B!C:A!B ` 1 : B!C
(Varn)
(2)   ` 2 : B!C
(Var)
A!B ` 1 : A!B
(Varn)
B!C:A!B ` 2 : A!B
(Varn)
(3)   ` 3 : A!B
10
Then, we have
(2)
(3) (1)
(App)
  ` (3 1) : B
(App)
  ` (2 (3 1)) : C
Finally, notice that
  ` (2 (3 1)) : C
(Lambda)
B!C:A!B ` 
A
:(2 (3 1)) : A!C
(Lambda)
A!B ` 
B!C
:
A
:(2 (3 1)) : (B!C)!(A!C)
(Lambda)
` 
A!B
:
B!C
:
A
:(2 (3 1)) : (A!B)!((B!C)!(A!C))
For the 
L
-calculus the inference is identical except for the rst steps; for instance, notice that
(Id)
B!C:A!B ` "
0
. B!C:A!B
(Shift)
  ` "
1
. B!C:A!B
(Id)
A!B ` "
0
. A!B
(Shift)
B!C:A!B ` "
1
. A!B
(Comp)
  ` "
2
. A!B
Then,
  ` "
2
. A!B
(Var)
A!B ` 1 : A!B
(Clos)
  ` 3 : A!B
Remember that the language of the 
L
-calculus only includes the de Bruijn index 1 and the others are
simulated using the "
n
. 
The simply-typed versions of the 
L
- and s
e
-calculus satisfy, among others, the properties of subject
reduction and type uniqueness. Additionally, they are Weakly Normalizing (WN) and Church-Rosser (CR).
4 Applications
Although in an intuitionistic logic, the concepts of propositions and types are identied, proof construction and
term synthesis do not necessarily go in the same direction. For instance, to prove the proposition A!(B!A),
one may assume A as an hypothesis and then, recursively, try to prove (B!A). Eventually, one gets the
axiom A;B ` A and the proof derivation is completed. On the other hand, the proof synthesis procedure,
decorates with -terms the proof-tree derivation from the axioms, to set up the variable declarations, i.e.,
x:A; y:B ` x : A, down to the conclusion.
In order to synthesize a -term at the same time as a proof is being developed, it is necessary to represent
incomplete-proofs. Assume, for example, the proposition A!(B!A). The bottom-up application of the rule
(Abs) results in a term x:A:X where X is a term to be constructed of type (B!A). A term as x:A:X
is called an open term and the place-holder X denotes a hole to be lled with a term of the right type, in
this case of type (B!A). Place-holders are also called meta-variables to distinguish them from the variables
of the -calculus. Meta-variables are written as uppercase (X;Y; : : : ) last letters of the Latin alphabet. At
some moment during the proof derivation, we get the typing judgment x:A;  ` y:B:x : (B!A). Hence, to
obtain a close term, i.e., a term without meta-variables, we can instantiate the meta-variableX with the term
y:B:x. This results in x:A:y:B:x. In contrast to substitution of variables, instantiation of meta-variables
is a rst order replacement that does not care of renaming of bound variables or capture of free-variables.
Notice, however, that open terms are not -terms. In fact, (1) instantiation and -reduction do not
commute, and (2) instantiation and typing do not commute. To illustrate the rst point, take the open term
(x:X y) and the instantiation of X with x. The instantiation results in (x:x y), which -reduces to
y. However, the original term -reduces to X , which gets instantiated as x. To see why instantiation and
11
typing do not commute, consider the context   = x:A; z:(B!A)!C and the open term (z x:B:X) of type
C, where X is a meta-variable of type A. If we instantiate X with the variable x of  , then we obtain the
ill-typed term (z x:B:x).
Meta-variables can be encoded in classical -calculus by using a technique taken from the higher order
unication tradition [31]. This technique uses a functional handle of scope. For instance, the open term
x:A:Y , where Y is a meta-variable of type B, is encoded as the -term x:A:(y x), where y is a fresh
variable of type A!B. In this case, the information that the variable x can indeed occur in a subsequent
substitution of y is taking into account by the application (y x). Thus, an instantiation of Y with M in the
original problem is translated as a substitution of y by x:A!B:M in the -calculus. Notice, however that
the meta-variable Y has the type B while the corresponding variable y has the type A!B.
Explicit substitutions and de Bruijn indices allow a simple and natural notation for open terms. First,
in a de Bruijn setting, meta-variables are just variables of the free algebra of terms. Notice that bound and
free variables of the -calculus are represented as indices. And second, explicit substitution calculi as ,

L
, and s
e
, are conuent on open terms (in the case of  and 
L
, on substitution-closed terms). Thus, in
these calculi, commutation of instantiation and the -reduction is for free.
We will consider meta-variables over a set X .
Denition 4.1 The set 
dB
(X ) of -terms in de Bruijn index notation with meta-variables over the set X
is dened inductively as
M;N ::= n j X j (M N) j M
where n 2 N
>0
; X 2 X .
Denition 4.2 A valuation is a mapping from X to 
dB
(X ). The homeomorphic extension of a valuation,
, from its domain X to the domain 
dB
(X ) is called the grafting of .
As usual valuations and their corresponding graftings are denoted by the same Greek letters. Application
of a grafting  to a term M will be written in postx notation M. For explicit representation of a valuation
and its corresponding grafting , we use the notation  = fX 7! X j X 2 Dom()g. A grafting is the
formal concept for meta-variable instantiation.
The set of -, 
L
-, and s
e
-terms with meta-variables, and their respective grafting notion, can be
dened in a similar way. The typing rule for meta-variables in these systems is [21]:
(Meta
X
)
 
X
` X : A
X
where A
X
and  
X
are, respectively, a unique type and a unique context associate to each meta-variable. By
using this rule, typing and instantiation of meta-variables commute [21].
4.1 Higher order unication
Higher order unication (HOU) is essential in automated reasoning, where it has formed the basis for
generalizations of the Resolution Principle in higher order logics, being a sine qua non mechanism in the
implementation of higher order proof assistants and higher order logic programming languages as the ones
previously referenced. For a very simple presentation of HOU see [58] and for a detailed introduction in the
context of declarative programming see [54]. As for the rst order case, substitution is the key operation for
HOU and its implicitness makes di√Ücult the analysis of important computational properties. Therefore, use
of calculi of explicit substitution in the formal implementation of HOU procedures is relevant.
HOU problems are expressed in the language of the simply-typed -calculus in de Bruijn indices over a
set of meta-variables X , denoted 
dB
(X ). Meta-variables play the role of unication variables. A simple
example of a HOU problem is to search for function solutions F of the equality F (f(a)) =
?
f(F (a)). That can
be written in 
dB
(X ) as (X (2 1)) =
?

(2 (X 1)), where both X and 2 are of functional type, say A!A
and 1 of atomic type A. A solution for X is the function identity, 
A
:1 but f
A
:(3 1); 
A
:(3 (3 1)); : : : g
(correspondingly, fF = f; F = f
2
; : : : g) are solutions too.
12
The rst person to present a HOU algorithm of practical interest was Huet [31]. Huet's work was relevant
because he realized that to generalize Robinson rst order Resolution Principle [56] to higher order theories
it is useful to verify the existence of uniers without computing them explicitly. Huet's algorithm is a semi-
decision one that may never stop when the input unication problem has no uniers, but when the problem
has a solution it always presents an explicit unier. Unication for second-order logic was proved undecidable
in general by Goldfarb [26]. Goldfarb's proof is based on a reduction from Hilbert's Tenth Problem. This
result shows that there are arbitrary higher order theories where unication is undecidable, but there exist
particular higher order languages of practical interest that have a decidable unication problem. In particular,
for the second-order case, unication is decidable, when the language is restricted to monadic functions [23].
Another problem of HOU is that the notion of most general unier does not apply and that a notion more
complex than the one of complete set of uniers is necessary. Huet has showed that equations of the form
(x:F a) =
?
(x:G b) (called ex-ex) of third-order may not have minimal complete sets of uniers and
that there may exist an innite chain of uniers, one more general than the other, without having a most
general one (for references see section 4.1 in [54]).
The general method of HOU via calculi of explicit substitutions was introduced in [21] (for the -
calculus) and consists mainly in: rstly, a translation or \pre-cooking" from HOU problems in 
dB
(X ) into
the language of a calculus of explicit substitutions. Secondly, an application of (rst order) unication in the
selected calculus of explicit substitutions to solve the translated problems. Finally, translation back of the
given grafting solutions into substitution solutions of the original HOU problem. In this way HOU problems
are solved via rst order unication in the language of calculi of explicit substitution. We will explain with
examples how reduction relations from the simply-typed -calculus and s
e
-calculus of explicit substitutions
are used to solve HOU problems in 
dB
(X ). For a formal presentation of the methods consult [21] and [2].
Denition 4.3 Let  = fX
1
7! a
1
; : : : ; X
n
7! a
n
g be a valuation from the set of meta-variables X to

dB
(X ). The corresponding substitution, fa
1
=X
1
; : : : ; a
n
=X
n
g, also denoted by  but written in a prex
notation, is dened inductively as follows
1. (m) = m, for m 2 N;
2. (X) = XfX
1
7! a
1
; : : : ; X
n
7! a
n
g, for X 2 X ;
3. (a
1
a
2
) = ((a
1
) (a
2
));
4. (a
1
) = 
+
(a
1
);
where 
+
denotes the substitution corresponding to the valuation 
+
= fX
1
7! a
+
1
; : : : ; X
n
7! a
+
n
g.
Unifying two terms M and N in 
dB
(X ) consists in nding a grafting  such that its corresponding
substitution satises (M) =

(N). Notice that application of a grafting has a dierent eect to the
application of its corresponding substitution. For instance, although (X)fX 7!Mg = M , a unier of the
problem X =
?

M is not fM=Xg, since (X)fM=Xg = (XfM
+
=Xg) = M
+
. However, by translating
appropriately the 
dB
(X )-termsM;N , the HOU problemM =
?

N can be reduced to rst order unication
either in the - or in the s
e
-calculus. Essentially, the pre-cooking translation from terms in 
dB
(X ) into
the language of the -calculus replaces each occurrence of a meta-variable X with X ["
k
], where k is the
number of abstractors above the occurrence of X . For the case of the s
e
-calculus the pre-cooking translates
each occurrence of a meta-variable X into '
k+1
0
X , where k is as before.
Example 4.4 Consider the problem 2 =
?

(X 2) being 2 of type A and X of type A!A. Introducing a
fresh meta-variable Y of type A the problem is translated into 2 =
?

(Y 2) ^X =
?

Y .
In the s
e
-calculus the problem is normalized into 2 =
?
s
e
Y 
1
2^X =
?
s
e
Y , whose solutions are f1=Y g
and f3=Y g giving as result the solutions f1=Xg and f3=Xg.
In the -calculus the problem is normalized into 2 =
?

Y [2:id] ^ X =
?

Y , from where we infer the
solutions above. 
13
Example 4.5 Now consider the HOU problem 2 =
?

(Z 2), where 2 and Z are of type A.
In the s
e
-calculus the problem is pre-cooked into 2 =
?
s
e
('
2
0
Z 2) and then transformed into 2 =
?
s
e
('
2
0
Z)
1
2 and subsequently into 2 =
?
s
e
'
1
0
Z by normalization. The sole possible solution given is fZ 7! 2g.
Observe, on the one side, that ('
2
0
Z 2)fZ 7! 2g = ('
2
0
2 2) =
s
e
(3 2) =
s
e
3
1
2 =
s
e
2. On the other
side, turning back the pre-cooking transformation, this corresponds to the substitution solution f2=Zg for
the original problem. In fact, (Z 2)f2=Zg = ((Z)f2=Zg 2f2=Zg) = ((Zf2
+
=Zg) 2) = (3 2). The
previous term -reduces into 2.
In the -calculus the problem is pre-cooked into 1["] =
?

(Z["] 1["]) which -reduces into 1["] =
?

(Z["])[1["]:id] and subsequently into 1["] =
?

Z[" √Ü(1["]:id)] and into 1["] =
?

Z[id] and nally into 1["] =
?

Z giving the corresponding sole solution fZ 7! 1["]g. This corresponds to the above grafting solution in
s
e
. On the one side, (Z["] 1["])fZ 7! 1["]g = (((1["])["]) 1["]) =

(1["
2
] 1["]) =

1["
2
][1["]:id] =

1["
2
√Ü(1["]:id)] =

1["]. On the other side, turning back the pre-cooking transformation, this corresponds
to the substitution solution f2=Zg for the original problem in 
dB
(X ) as above.
Notice that f1=Zg is not a substitution solution of the previous problem, since for any de Bruijn index
n we have (Z)fn=Zg = (Zfn
+
=Zg) = (n+ 1). 
The following example illustrates why pre-cooking of -terms before applying unication rules is essential.
Example 4.6 (Continuing example 4.5) In the s
e
-calculus, when normalizing the HOU problem 2 =
?

(Z 2) before pre-cooking we obtain 2 =
?
s
e
Z
1
2, whose solutions are the graftings fZ 7! 1g and fZ 7! 3g.
As previously mentioned f1=Zg is not a substitution solution of the original HOU problem. Analogously, in
the -calculus, when normalizing the corresponding problem 1["] =
?

(Z 1["]) we obtain 1["] =
?

Z[1["
]:id], whose solutions are fZ 7! 1g and fZ 7! 1["
2
]g given rise to the same problem. 
4.2 Type inference
In order to infer types of -terms (or -terms or s
e
-terms) we deal with new sets of type variables 
i
and
context variables 
i
, i 2 N. Essentially, we will take as input of a type inference problem a term without
knowing its type and context and as output we will formulate a rst order unication problem on type and
context variables. Well-typedness of the input term will then corresponds to solvability of the generated
rst order unication problem. Here we illustrate the general method above mentioned using the language
of the s
e
-calculus. Simple modications according to the typing rules of the selected language will adapt
this method to other settings.
Let M be a s
e
-term. Initially, we introduce new variables for the type and for the context of each
subterm of M . Then M can be seen as a new term M
0
with all its subterms decorated with one dierent
type variable as subscript and one dierent context variable as superscript.
Example 4.7 (
A
:(
B
:(
C
:(2

1

1
(3

2

2
1

3

3
)

4

4
)

5

5
)

6

6
)

7

7
)

8

8
, where 
i
and 
i
, i = 1; :::; 8 are new mutually
dierent type and context variables, is the decorated version of the -term 
A
:
B
:
C
:(2 (3 1)). 
Afterwards, we apply the set of transformation rules in Table 1 for pairs of the form hR;Ei, where R is
a set of decorated terms and E a set of equations on type and context variables. The application of these
transformation rules begin from the par hR
0
; ;i, where R
0
is the set of all decorated subterms of M
0
.
Notice that the transformation rules in the Table 1 are built according to the typing rules of the s
e
-
calculus. After the application of each of the transformation rules the size of the current set of decorated
subterms R decreases by one. Consequently, the application of these rules beginning from the pair hR
0
; ;i
nishes after a nite number of steps (exactly as many steps as subterms in M) giving as result an empty
set of decorated terms and a set E
f
of equation on type and context variables. E
f
is a rst order unication
problem on type and context variables.
Finally, our algorithm terminates by applying any rst order unication algorithm toE
f
. If the unication
algorithm fails then our term is ill-typed. Otherwise, if the unication algorithm succeeds, the most general
unier resulting as output gives straightforwardly a context   and a type A such that   `M : A. Of course,
14
Table 1: Transformation rules for type inference in the s
e
-calculus
(Var) hR [ f1


g; Ei ! hR;E [ f = :
0
gi, where 
0
is a fresh context variable;
(Varn) hR [ fn


g; Ei ! hR;E [ f = 
0
1
:::
0
n 1
::
0
gi, where 
0
and 
0
1
; :::; 
0
n 1
are
fresh context and type variables;
(Lambda) hR [ f(
A
:M

1

1
)

2

2
g; Ei ! hR;E [ f
2
= A!
1
; 
1
= A:
2
gi;
(App) hR [ f(M

1

1
N

2

2
)

3

3
g; Ei ! hR;E [ f
1
= 
2
; 
2
= 
3
; 
1
= 
2
!
3
gi;
(Sigma) hR [ f(M

1

1

i
N

2

2
)

3

3
g; Ei ! hR;E [ f
1
= 
3
; 
1
= 
0
1
:::
0
i 1
:
2
:
2
; 
3
= 
0
1
:::
0
i 1
:
2
gi,
where 
0
1
; :::; 
0
i 1
are fresh type variables and in the case
that i = 1 the sequence 
0
1
:::
0
i 1
is empty;
(Phi) hR [ f('
i
k
M

1

1
)

2

2
g; Ei ! hR;E [ f
1
= 
2
; 
2
= 
0
1
:::
0
k+i 1
:
0
; 
1
= 
0
1
:::
0
k 1
:
0
gi,
where 
0
and 
0
1
; :::; 
0
k+i 1
are fresh context and type vari-
ables and in the case that k  1 respectively k = 0 and
i = 1 the sequences 
0
1
:::
0
k 1
respectively 
0
1
:::
0
k+i 1
are
empty;
(Meta) hR [ fX


g; Ei ! hR;E [ f =  
X
;  = A
X
gi, where  
X
` X : A
X
;
the construction of   and A is done from the bindings given in the resulting unier corresponding to the
outermost context and type variables selected in the decoration of M .
Correctness and completeness of this method is a direct consequence from the correctness and com-
pleteness of the rst order unication and of the typing rules of the s
e
-calculus used to construct the
transformation rules in Table 1.
Example 4.8 (Continuing Example 4.7) The initial input for the set of inference rules is hR
0
; ;i, where R
0
=
f2

1

1
; 3

2

2
; 1

3

3
; (3

2

2
1

3

3
)

4

4
; (2

1

1
(3

2

2
1

3

3
)

4

4
)

5

5
; (
C
:(2

1

1
(3

2

2
1

3

3
)

4

4
)

5

5
)

6

6
; (
B
:(
C
:(2

1

1
(3

2

2
1

3

3
)

4

4
)

5

5
)

6

6
)

7

7
;
(
A
:(
B
:(
C
:(2

1

1
(3

2

2
1

3

3
)

4

4
)

5

5
)

6

6
)

7

7
)

8

8
g.
In the sequel, we show the steps of the application of the transformation rules. For convenience we
apply the rules in an specic order (from smaller to bigger subterms), but the application of the rules is
nondeterministic. Applying the rules in any order we will obtain dierent sets of equations that correspond
to the same unication problem.
hR
0
; ;i !
Var
hR
1
= R
0
n f1

3

3
g; E
1
= f
3
= 
3
:
0
1
gi !
Varn
hR
2
= R
1
n f2

1

1
g; E
2
= E
1
[ f
1
= 
0
1
:
1
:
0
2
gi !
Varn
hR
3
= R
2
n f3

2

2
g; E
3
= E
2
[ f
2
= 
0
2
:
0
3
:
2
:
0
3
gi !
App
hR
4
= R
3
n f(3

2

2
1

3

3
)

4

4
g; E
4
= E
3
[ f
2
= 
3
; 
3
= 
4
; 
2
= 
3
!
4
gi !
App
hR
5
= R
4
n f(2

1

1
(3

2

2
1

3

3
)

4

4
)

5

5
g; E
5
= E
4
[ f
1
= 
4
; 
4
= 
5
; 
1
= 
4
!
5
gi !
Lambda
hR
6
= R
5
n f(
C
:(2

1

1
(3

2

2
1

3

3
)

4

4
)

5

5
)

6

6
g; E
6
= E
5
[ f
6
= C!
5
; 
5
= C:
6
gi !
Lambda
hR
7
= R
6
n f(
B
:(
C
:(2

1

1
(3

2

2
1

3

3
)

4

4
)

5

5
)

6

6
)

7

7
g; E
7
= E
6
[ f
7
= B!
6
; 
6
= B:
7
gi !
Lambda
h; = R
7
n f(
A
:(
B
:(
C
:(2

1

1
(3

2

2
1

3

3
)

4

4
)

5

5
)

6

6
)

7

7
)

8

8
g; E
8
= E
7
[ f
8
= A!
7
; 
7
= A:
8
gi
Now the reader is invited to apply his/her preferred rst order unication algorithm for resolving the uni-
cation problem E
8
= f
3
= 
3
:
0
1
; 
1
= 
0
1
:
1
:
0
2
; 
2
= 
0
2
:
0
3
:
2
:
0
3
; 
2
= 
3
; 
3
= 
4
; 
2
= 
3
!
4
; 
1
= 
4
; 
4
=

5
; 
1
= 
4
!
5
; 
6
= C!
5
; 
5
= C:
6
; 
7
= B!
6
; 
6
= B:
7
; 
8
= A!
7
; 
7
= A:
8
g and then to resolve
the bindings of the resulting unier (if it exists) for giving appropriate contexts and types for the input
-term. 
4.3 Inhabitation and higher order logics
Given a type A and a context of variable declarations  , the inhabitation problem consist in nding a term
M such that   ` M : A. Using the open term approach, the problem can be formulated as nding a
pure instantiation for the meta-variable X satisfying   ` X : A. Thus, the term to instantiate X can be
15
x:A;  `M : B x:A;  ` B : fType;Kindg
(Abs)
  ` x:A:M : x:A:B
  `M : x:A:B   ` N : A
(Appl)
  ` (M N) : BfN=xg
Figure 8: Rules (Abs) and (Apl) for the CC type system
constructed at the same time as the proof derivation of A is done by applying the typing rules in a bottom-up
manner and introducing new meta-variables for the unknown terms.
For the simply-typed -calculus this problem is decidable. In fact, since provability in the minimal
propositional intuitionistic logic is decidable, the term M can be built directly from the proof-tree derivation
of 
 `
I
A, where 
 is the set of types in  , as explained before. However, when we move to a rst order or
a higher order intuitionistic logic and, in consequence, we extend the type system to handle quantication,
the problem becomes much more complicated. In [47], it has been presented a semi-algorithm to solve
the inhabitation problem via the 
L
-calculus and open terms. It uses the fact that 
L
is conuent on
substitution-closed terms and weakly normalizing, even for dependent type settings of the calculus.
Although rst and higher order logics are out of the scope of this paper, we give some hints of the
inhabitation problem for these kind of logics. See [20] for a complete description of a term synthesis algorithm
in the Cube of Type Systems and [47] for a similar algorithm via explicit substitutions and open terms.
The Dependent Type theory, namely  [29], is a conservative extension of the simply-typed -calculus.
It allows a ner stratication of terms by generalizing the function space type. In fact, in , the type of
a function x:A:M is x:A:B where B (the type of M) may depend on x. Hence, the type A!B of the
simply-typed -calculus is just a notation in  for the product x:A:B where x does not appear free in
B. The Calculus of Constructions, namely CC, [15, 16] extends the -calculus with polymorphism and
constructions of types. From a logical point of view,  and CC allow representation of proofs in the rst
and higher order intuitionistic logic, respectively. Via the types-as-proofs principle, a term of type x:A:B
is a proof-term of the proposition 8x:A:B.
Terms in these calculi can be variables, applications, or abstractions, like in classical -calculus, or
two new kind of terms: products (x:A:B), and sorts (Type;Kind). Term and types belong to the same
syntactical category. Thus, x:A:B is a term, as well as x:A:M . However, terms are stratied in several
levels according to a type discipline. For instance, given an appropriate context of variable declarations,
x:A::M : x:A::B, x:A::B : Type, and Type : Kind. The term Kind cannot be typed in any context,
but it is necessary since a circular typing as Type : Type leads to the Girard's paradox [25]. In Fig. 8 we
give rules (Abs) and (Appl) for the CC type system.
The 
L
-calculus has been extended with products for the  and CC-type systems in [45]. These
variants satisfy the same properties as the simply-typed version: conuent on substitution-closed terms,
weakly-normalizing, and subject reduction. For further details we refer to [45].
Example 4.9 We can proof the rst order predicate (8x:(P x))!(P c) by nding a term X of type
(x:A:(P x))!(P c) in a context where the term c has the type A and P has the type A!Type. The
bottom-up application of rule (Abs) results in a term X having the form y:(x:A:(P x)):Y where Y is a
term of type (P c) in a context where the variable y has the type x:A:(P x). If we instantiate Y with
the term (y c), which is a well typed term of type (P c), we obtain the term y:(x:A:(P x)):(y c) of
type x:(x:A:(P x)):(P c). Notice that in this example we have used the meta-variables X and Y and
the instantiation mechanism of meta-variables to build incrementally a proof. 
Typing of meta-variables is more complicated in dependent-type systems than in the simply-type case.
Since meta-variables can appear in terms, types, and contexts, the typing rules should take care of possible
circular dependences.
5 Conclusion
The -calculus uses an external and atomic operation to compute the substitutions of variables by terms.
Calculi of explicit substitutions improve the substitution mechanism by allowing substitutions to be part
16
 
L
s
e

*


 
d
x 
Conuence Mv Mv

^

^

^ Gnd Gnd Gnd Gnd
Normalization Wk Wk Wk Wk PSN PSN PSN PSN PSN
Composition

^

^

_

^

_

_


?

_

_
Finitary 1
st
-order

^

^

_

^

^

^

^

_

_
Variables dB dB dB dB dB dB dB Nm Lv
Number of rules 13 12 13
y
19 13 8 19 6 10
y
-reduction

^

^

^

^


z

^

^

^

^
Reference [1] [44] [32] [17] [43] [38] [35] [8] [39]

^ : The general property holds.

_ : The property does not hold.

 : The property holds with restrictions.
Mv : Conuence on semi-open expressions, i.e. only with meta-variables of terms.
Gnd : Conuence on ground expressions.
Wk : Weak normalization on typed terms.
PSN : Preservation of strong normalization.
dB : De Bruijn indices notation of variables.
Nm : Variable names.
Lv : De Bruijn levels notation with variable names.
? : Restricted composition. In particular, the 
d
-calculus does not allow simultaneous
substitutions.
y : Number of schemes. The s
e
-calculus is not nitary.
z : Big-step semantic of -reduction. The 

-calculus does not simulate each step of
-reduction.
Figure 9: Some calculi of explicit substitutions
of the formal language by means of special constructors and reduction rules. There are several versions of
calculi of explicit substitutions. Figure 9 summarizes the main characteristics of some of them. All these
calculi implement the -reduction by means of a lazy mechanism of reduction of substitutions.
In this paper we have explored new developments and applications on two of the most successful styles
of explicit substitution:  and s
e
.
References
[1] M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. Levy. Explicit Substitutions. Journal of Functional
Programming, 1(4):375{416, 1991.
[2] M. Ayala-Rincon and F. Kamareddine. Unication via s
e
-Style of Explicit Substitution. In 2nd
International Conference on Principles and Practice of Declarative Programming, Montreal, Canada,
September 2000. ACM Press.
[3] H. P. Barendregt. The Lambda Calculus : Its Syntax and Semantics (revised edition). North Holland,
1984.
[4] H. P. Barendregt. -calculi with types. Handbook of Logic in Computer Science, II, 1992.
[5] B. Barras, S. Boutin, C. Cornes, J. Courant, J.C. Filliatre, E. Gimenez, H. Herbelin, G. Huet, C. Mu~noz,
C. Murthy, C. Parent, C. Paulin, A. Sabi, and B. Werner. The Coq Proof Assistant Reference Manual
{ Version V6.1. Technical Report 0203, INRIA, August 1997.
17
[6] N. Bjrner and C. Mu~noz. Absolute explicit unication. Accepted for publication. International con-
ference on Rewriting Techniques and Applications (RTA'2000), July 2000.
[7] R. Bloo. Preservation of Termination for Explicit Substitution. PhD thesis, Department of Mathematics
and Computing Science, Eindhoven University of Technology, 1997.
[8] R. Bloo and K. H. Rose. Preservation of strong normalisation in named lambda calculi with explicit
substitution and garbage collection. In Proc. CSN-95: Computer Science in the Netherlands, November
1995.
[9] D. Briaud. Higher order unication as a typed narrowing. Technical report, CRIN report 96-R-112,
1996.
[10] A. Church. An unsolvable problem of elementary number theory. American Journal of Mathematics,
58:345{363, 1936.
[11] A. Church. A formulation of the simple theory of types. Journal of Symbolic Logic, 5:56{68, 1940.
[12] A. Church. The Calculi of Lambda-Conversion. Princeton University Press, 1941.
[13] H. Cirstea and C. Kirchner. Combining Higher-Order and First-Order Computation Using p-Calculus:
Towards a Semantics of ELAN. In D. M. Gabbay and M. de Rijke, editors, Frontiers of Combining
Systems 2, Studies on Logic and Computation, 7, chapter 6, pages 95{121. Research Studies Press/Wiley,
1999.
[14] H. Cirstea and C. Kirchner. Introduction to the Rewriting Calculus. Rapport de Recherche 3818, INRIA,
December 1999.
[15] T. Coquand. Une Theorie de Constructions. These de doctorat, U. Paris VII, 1985.
[16] T. Coquand and G. Huet. The Calculus of Constructions. Information and Computation, 76:96{120,
1988.
[17] P.-L. Curien, T. Hardin, and J.-J. Levy. Conuence Properties of Weak and Strong Calculi of Explicit
Substitutions. Journal of the ACM, 43(2):362{397, 1996. Also as Rapport de Recherche INRIA 1617,
1992.
[18] H. B. Curry and R. Feys. Combinatory Logic, volume 1. North Holland, 1958.
[19] N.G. de Bruijn. Lambda-Calculus Notation with Nameless Dummies, a Tool for Automatic Formula
Manipulation, with Application to the Church-Rosser Theorem. Indag. Mat., 34(5):381{392, 1972.
[20] G. Dowek. A complete proof synthesis method for type systems of the cube. Journal of Logic and
Computation, 3(3):287{315, June 1993.
[21] G. Dowek, T. Hardin, and C. Kirchner. Higher-order Unication via Explicit Substitutions. Information
and Computation, 157(1/2):183{235, 2000.
[22] G. Dowek, T. Hardin, C. Kirchner, and F. Pfenning. Unication via explicit substitutions: The case
of higher-order patterns. In M. Maher, editor, Proceedings of the Joint International Conference and
Symposium on Logic Programming, Bonn, Germany, September 1996. MIT Press.
[23] W. Farmer. A Unication Algorithm for Second-Order Monadic Terms. Annals of Pure and Applied
Logic, 39:131{174, 1988.
[24] M. C. F. Ferreira, D. Kesner, and L. Puel. Lambda-calculi with explicit substitutions and composition
which preserve beta-strong normalization. In Michael Hanus and Mario Rodrguez-Artalejo, editors,
Algebraic and Logic Programming, 5th International Conference, ALP'96, volume 1139 of LNCS, pages
284{298, Aachen, Germany, 25{27 September 1996. Springer.
18
[25] Jean-Yves Girard. Interpretation Fonctionelle et

Elimination des Compures de l'Arithmetic d'Ordre
Superieur. These de doctorat, Universite Paris VII, 1972.
[26] W. Goldfarb. The Undecidability of the Second-Order Unication Problem. Theoretical Computer
Science, 13(2):225{230, 1981.
[27] M.J.C. Gordon and T.F. Melham. Introduction to HOL: A Theorem Proving Environment for Higher
Order Logic. Cambridge University Press, 1993.
[28] B. Guillaume. The s
e
-calculus Does Not Preserve Strong Normalization. Journal of Functional Pro-
gramming, 1999. To appear.
[29] R. Harper, F. Honsell, and G. Plotkin. A framework for dening logics. Journal of the Association for
Computing Machinery, 40(1):143{184, 1993.
[30] J. R. Hindley. Basic Simple Type Theory. Number 42 in Cambridge Tracts in Theoretical Computer
Science. Cambridge University Press, 1997.
[31] G. Huet. A Unication Algorithm for Typed -Calculus. Theoretical Computer Science, 1:27{57, 1975.
[32] F. Kamareddine and A. Ros. A -calculus a la de Bruijn with Explicit Substitutions. In Proc. of
PLILP'95, volume 982 of LNCS, pages 45{62. Springer, 1995.
[33] F. Kamareddine and A. Ros. Extending a -calculus with Explicit Substitution which Preserves Strong
Normalisation into a Conuent Calculus on Open Terms. Journal of Functional Programming, 7:395{
420, 1997.
[34] F. Kamareddine and A. Ros. Relating the - and s-Styles of Explicit Substitutions. Journal of Logic
and Computation, 10(3):349{380, 2000.
[35] D. Kesner. Conuence properties of extensional and non-extensional -calculi with explicit substitu-
tions (extended abstract). In H. Ganzinger, editor, Proceedings of the Seventh International Confer-
ence on Rewriting Techniques and Applications (RTA-96), volume 1103 of LNCS, pages 184{199, New
Brunswick, New Jersey, 1996. Springer-Verlag.
[36] C. Kirchner and C. Ringeissen. Higher-order Equational Unication via Explicit Substitutions. In Proc.
Algebraic and Logic Programming, volume 1298 of LNCS, pages 61{75. Springer, 1997.
[37] S. C. Kleene. -denability and recursiveness. Duke Mathematical Journal, 2:340{353, 1936.
[38] P. Lescanne. From  to  a Journey Through Calculi of Explicit Substitutions. In Proceedings of
the 21st Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, pages
60{69, January 1994.
[39] P. Lescanne and J. Rouyer-Degli. Explicit substitutions with de Bruijn's levels. In J. Hsiang, edi-
tor, Proceedings of the International Conference on Rewriting Techniques and Applications (RTA-95),
volume 914 of LNCS, pages 294{308, Chapel Hill, North Carolina, 1995. Springer-Verlag.
[40] P.-A. Mellies. Typed -calculi with explicit substitutions may not terminate in Proceedings of TLCA'95.
LNCS, 902, 1995.
[41] D. Miller. Prolog: An Introduction to the Language and its Logic. Draft, Department of Computer
Science and Engineering, The Pennsylvania State University, 1998.
[42] Robin Milner, M. Tofte, and R. Harper. The Denition of Standard ML. MIT Press, Cambridge, MA,
1991.
[43] C. Mu~noz. Conuence and preservation of strong normalisation in an explicit substitutions calculus
(extended abstract). In Proceedings of the Eleventh Annual IEEE Symposium on Logic in Computer
Science, pages 440{447, New Brunswick, New Jersey, July 1996. IEEE Computer Society Press.
19
[44] C. Mu~noz. A left-linear variant of . In Proc. International Conference PLILP/ALP/HOA'97, volume
1298 of LNCS, pages 224{234, Southampton (England), September 1997. Springer.
[45] C. Mu~noz. Un calcul de substitutions pour la representation de preuves partielles en theorie de types.
PhD thesis, Universite Paris 7, 1997. English version in Rapport de recherche INRIA RR-3309, 1997.
[46] C. Mu~noz. Dependent types and explicit substitutions. Accepted for publication in the journal Mathe-
matical Structures in Computer Science. It also appears as report NASA/CR-1999-209722 ICASE No.
99-43., 1999.
[47] C. Mu~noz. Proof-term synthesis on dependent-type systems via explicit substitutions. Accepted for
publication in the journal Theoretical Computer Science. It also appears as report NASA/CR-1999-
209730 ICASE No. 99-47. and was presented in the International Workshop on Explicit Substitutions:
Theory and Applications to Programs and Proofs - WESTAPP 98, Tsukuba, Japan, 2000.
[48] G. Nadathur. A ne-grained notation for lambda terms and its use in intensional operations. Technical
Report TR-96-13, Department of Computer Science, University of Chicago, May 30 1996. Accepted for
publication in Journal of Functional and Logic Programming.
[49] G. Nadathur and D. S. Wilson. A Notation for Lambda Terms A Generalization of Environments.
Theoretical Computer Science, 198:49{98, 1998.
[50] G. Nadathur and D. S. Wilson. A Fine-Grained Notation for Lambda Terms and Its Use in Intensional
Operations. The Journal of Functional and Logic Programming, 1999(2):1{62, 1999.
[51] R. P. Nederpelt, J. H. Geuvers, and R. C. de Vrijer. Selected papers on Automath. North-Holland,
Amsterdam, 1994.
[52] S. Owre, J. M. Rushby, and N. Shankar. PVS: A prototype verication system. In D. Kapur, editor, 11th
International Conference on Automated Deduction (CADE), volume 607 of Lecture Notes in Articial
Intelligence, pages 748{752, Saratoga, NY, June 1992. Springer-Verlag.
[53] F. Pfenning and C. Schurmann. Twelf user's guide, 1.2. edition. Technical Report CMU-CS-1998-173,
Carnegie Mellon University, September 1998.
[54] C. Prehofer. Progress in Theoretical Computer Science. In R. V. Book, editor, Solving Higher-Order
Equations: From Logic to Programming. Birkhauser, 1997.
[55] A. Ros. Contributions a l'etude de -calculs avec des substitutions explicites. These de doctorat,
Universite Paris VII, 1993.
[56] J. A. Robinson. A Machine-oriented Logic Based on the Resolution Principle. Journal of the ACM,
12(1):23{41, January 1965.
[57] K. H. Rose. Explicit Substitution - Tutorial & Survey. BRICS, Lecture Series LS-96-3, Department of
Computer Science, University of Aarhus, 1996.
[58] W. Snyder and J. Gallier. Higher-Order Unication Revisited: Complete Sets of Transformations.
Journal of Symbolic Computation, 8:101{140, 1989.
[59] A. N. Whitehead and B. Russell. Principia Mathematica. Cambridge University Press, Cambridge,
revised edition, 1925{1927. Three volumes. The rst edition was published 1910{1913.
20
