Deciding knowledge in security protocols under equational theories
Mart´ın Abadi a,b,1 and Ve´ronique Cortier c,2
aComputer Science Department University of California at Santa Cruz, USA bMicrosoft Research, Silicon Valley, USA
cLoria/CNRS & INRIA Lorraine project Cassis, Nancy, France
Abstract
The analysis of security protocols requires precise formulations of the knowledge of protocol participants and attackers. In formal approaches, this knowledge is often treated in terms of message deducibility and indistinguishability relations. In this paper we study the decidability of these two relations. The messages in question may employ functions (encryption, decryption, etc.) axiomatized in an equational theory. One of our main positive results says that deducibility and indistinguishability are both decidable in polynomial time for a large class of equational theories. This class of equational theories is deﬁned syntactically and includes, for example, theories for encryption, decryption, and digital signatures. We also establish general decidability theorems for an even larger class of theories. These theorems require only loose, abstract conditions, and apply to many other useful theories, for example with blind digital signatures, homomorphic encryption, XOR, and other associative-commutative functions.

1 Introduction

Understanding security protocols often requires reasoning about the knowledge of legitimate protocol participants and attackers. As a simple example, let us consider a protocol in which A sends to B a message that consists of a secret s encrypted under a pre-arranged shared key k. One may argue that, after processing this message,
1 Abadi’s work was partly supported by the National Science Foundation under Grants CCR-0204162, CCR-0208800, and CCF-0524078. 2 Ve´ronique Cortier’s work was partly supported by the RNTL project PROUVE03V360 and the ACI Jeunes Chercheurs JC9005. Corresponding author address: Loria, Campus Scientiﬁque, BP 239, 54506 Vandoeuvre-les-Nancy cedex, Nancy, France; Veronique.Cortier@loria.fr.

Preprint submitted to Elsevier Science

9 April 2006

B knows s. More interestingly, one may also argue than an attacker with bounded computing power that does not know k but eavesdrops on the communications between A and B and sees the message does not learn s.
Accordingly, formal methods for the analysis of security protocols rely on deﬁnitions of the knowledge of protocol participants and attackers. In those methods, the knowledge of an attacker is used to determine what messages the attacker can send at each point in time—it can send only messages it knows. Moreover, security guarantees can be phrased in terms of the knowledge of the attacker. For example, a guarantee might be that, at the end of a protocol run, the attacker does not know a particular key, or that the attacker does not know whether a certain ciphertext contains the plaintext “true” or “false”. For such applications, although the attacker is typically an active entity that can learn by conducting experiments, the deﬁnition of knowledge focuses on a particular point in a protocol execution.
Many formal deﬁnitions explain the knowledge of an attacker in terms of message deduction (e.g., [26,30,34,31]). Usually, a set of messages S indicates what the attacker has invented or received up to a particular point in a protocol execution; these messages may be from multiple protocol sessions and even multiple protocols, and may be obtained legitimately or by other means. Then, given such a set of messages S and another message M, one asks whether M can be computed from S. The messages are represented by expressions, and correspondingly the computations allowed are symbolic manipulations of those expressions. Intuitively these computations can rely on any step that an eavesdropper who has obtained the messages in S can perform on its own in order to derive M. For example, the eavesdropper can encrypt and decrypt using known keys, and it can extract parts of messages.
Despite its usefulness in proofs about protocol behaviors, the concept of message deduction does not always provide a sufﬁcient account of knowledge, and it is worthwhile to consider alternatives. For instance, suppose that we are interested in a protocol that transmits an encrypted boolean value, possibly a different one in each run. We might like to express that this boolean value remains secret by saying that no attacker can learn it by eavesdropping on the protocol. On the other hand, it is unreasonable to say that an attacker cannot deduce the well-known boolean values “true” and “false”. Instead, we may say that the attacker cannot distinguish an instance of the protocol with the value “true” from one with the value “false”. More generally, we may say that two systems are equivalent when an attacker cannot distinguish them, and we may then express security guarantees as equivalences. The use of equivalences is common in computational approaches to cryptography (e.g., [25]), and it also ﬁgures prominently in several formal methods (e.g., [5,29,3]).
Two systems that output messages that an attacker can tell apart are obviously distinguishable. Conversely, in order to establish equivalences between systems, an
2

important subtask is to establish equivalences between the messages that the systems generate (for example, between the encrypted boolean values). These equivalences may be called static equivalences, because they consider only the messages, not the dynamic processes that generate them. Analogously, the deduction relation should perhaps be called static deduction. Despite the static character of these relations, they are useful in analyzing the dynamics of protocols and attacks. In particular, proof methods for properties of protocol behaviors often rely on deduction (e.g., [31]), and process equivalences can be reduced to static equivalences plus fairly standard bisimulation conditions [3] (see also [4,14]).
In this paper we study the decidability of deduction and static equivalence. We deﬁne a relation φ M that means that M can be deduced from φ, and a relation ϕ ≈s ψ that means that ϕ and ψ are statically equivalent; here φ, ϕ, and ψ are all essentially lists of messages, each with a name, represented by formal expressions. For generating these messages, we allow the application of a wide array of functions—pairing, projections, various ﬂavors of encryption and decryption, digital signatures, one-way hash functions, etc.. Indeed, our results do not make any assumption on any particular cryptographic system beyond fairly general hypotheses on the equational theory that is used for deﬁning the properties of the cryptographic operations.
Our results start with basic observations about the decidability of deduction and static equivalence. Speciﬁcally, we demonstrate that, even for decidable equational theories, φ M and ϕ ≈s ψ can be undecidable. Moreover, we establish that deduction can be reduced to static equivalence (not too surprisingly), but that the converse does not hold. Therefore, we investigate hypotheses that would guarantee decidability, allowing for the possibility that the decidability of ϕ ≈s ψ requires more than the decidability of φ M.
We identify a simple, syntactically deﬁned class of theories for which φ M and ϕ ≈s ψ are both decidable in polynomial time. These theories, which we call convergent subterm theories, are given by convergent rewriting systems with a ﬁnite number of rules of the form M → N where N is a proper subterm of M or a constant symbol. Convergent subterm theories appear frequently in applications; in particular, standard axiomatizations of encryption, decryption, and digital signatures yield convergent subterm theories.
Going further, we develop decision methods for φ M and ϕ ≈s ψ under an even larger class of equational theories. For this purpose, we assume only loose, abstract conditions, rather than syntactic criteria on the theories. In this respect, we are inspired by Comon-Lundh’s current investigations [19] (see Section 6). The general decidability theorems that we obtain subsume the previous ones for convergent subterm theories (with more difﬁculties and without the same complexity bounds, hence the separate treatment of convergent subterm theories). They also apply to many other useful theories, for example with blind digital signatures, homomorphic
3

encryption, XOR, and other AC (associative-commutative) functions. Several of the decidability results that we obtain are new.
Checking that a particular theory satisﬁes our abstract conditions may involve some work, though often less than direct proofs of decidability. In some cases, it may also involve some (fairly elementary and pleasant) mathematics, such as facts on Z-modules. We expect that some of the techniques that we employ in our examples may be reused in the study of other theories.
The problem of deciding knowledge is particularly important in the context of algorithms and tools for automated protocol analysis. Often, special techniques are introduced for particular sets of cryptographic operations of interest, on a caseby-case basis. For example, the classic Dolev-Yao result deals with a ﬁxed, limited suite of public-key operations [24]; more recent decidability results deal with XOR and modular exponentiation (e.g., [16,17,20]); many variants and combinations that arise in practice have not yet been explored. On the other hand, other algorithms and tools (e.g., [10–12]) allow much freedom in the choice of cryptographic operations but their analysis of the knowledge of the attacker is not always guaranteed to terminate. Decidability results under general equational theories have been rare. Comon-Lundh and Treinen have studied the decidability of deduction for a class of equational theories in which, for example, they allow the homomorphism property enc( u, v , k) = enc(u, k), enc(v, k) but not the inverse property I(I(x)) = x [21]. These examples illustrate that their class is incomparable with the class of convergent subterm theories; we do not know how their class relates to our results for other theories. Delaune and Jacquemard have shown that deduction is decidable for a subclass of convergent subterm theories, also considering active attacks [22]. Chevalier and Rusinowitch have developed an algorithm for combining decision procedures for equational theories, considering active attacks and a bounded number of sessions [18]. These results do not address static equivalence, nor associativity and commutativity properties. In fact, even results on speciﬁc theories with AC functions have been rare. Three important exceptions are decidability results for deduction with XOR [17,20], in an Abelian group [20], and under certain “AC-like” theories with homomorphisms [28]. We discuss other recent and ongoing related work in Section 6.
The next section, Section 2, introduces notations and deﬁnitions. Section 3 compares and ≈s. Section 4 focuses on convergent subterm theories and gives our main decidability results for these theories. Section 5 considers the larger class of equational theories. Section 6 concludes. The Appendix contains proofs.
Parts of this paper have been presented, in preliminary form, at ICALP 2004 and CSFW 2005 [1,2]. This paper represents a synthesis and an extension of the work presented there. (Basically, Sections 3 and 4 correspond to the ICALP 2004 paper [1] while Section 5 corresponds to the CSFW 2005 paper [2], with improvements in presentation and additional technical material throughout.)
4

2 Basic deﬁnitions

Next we review deﬁnitions from previous work. We mostly adopt the deﬁnitions of the applied pi calculus [3]. In Section 2.1 we give the syntax of expressions. In Section 2.2 we explain a representation for the information available to an observer who has seen messages exchanged in the course of a protocol execution. In Section 2.3 and 2.4 we present the relations and ≈s, which (as explained in the introduction) provide two formalizations of the knowledge that the observer has on the basis of that information.

2.1 Syntax

A signature Σ consists of a ﬁnite set of function symbols, such as enc and pair, each with an arity. We write arity(f ) for the arity of a function symbol f , and let ar(Σ) be the maximal arity of a function symbol in Σ. A function symbol with arity 0 is
a constant symbol.

Given a signature Σ, an inﬁnite set of names N , and an inﬁnite set of variables, the set of terms is deﬁned by the grammar:

L, M, N, T, U, V ::= k, . . . , n, . . . , s x, y, z f (M1, . . . , Ml)

terms name variable function application

where f ranges over the function symbols of Σ and l matches the arity of f . A

term is closed when it does not have free variables (but it may contain names and

constant symbols). We write fn(M) for the set of names that occur in the term M.

We use meta-variables u, v, w to range over names and variables. The size |T | of a

term T is deﬁned by |u| = 1 and |f (T1, . . . , Tl)| = 1 +

l i=1

|Ti|.

The

DAG-size

|T |DAG is the number of distinct subterms of T .

A context C is a term with holes, or (more formally) a term with distinguished
variables that each occur at most once in the context. When C is a context with
n distinguished variables x1, . . . , xn, we may write C[x1, . . . , xn] instead of C in order to show the variables, and when T1, . . . , Tn are terms we may also write C[T1, . . . , Tn] for the result of replacing each variable xi with the corresponding term Ti.

We equip the signature Σ with an equational theory E, that is, an equivalence relation on terms that is closed under application of contexts and under substitutions of terms for both names and variables. (While non-standard, the requirement that E be closed under substitutions of terms for names simpliﬁes some technical details

5

and has been harmless in applications.) We write M =E N when M and N are closed terms and the equation M = N is in E. We use the symbol == to denote syntactic equality of closed terms. As in these deﬁnitions, we often focus on closed
terms for simplicity.

2.2 Assembling terms into frames

At a particular point in time, while engaging in one or more sessions of one or more protocols, an attacker may know a sequence of messages M1, . . . , Ml. This means that it knows each message but it also knows in which order it obtained the messages. So it is not enough for us to say that the attacker knows the set of terms {M1, . . . , Ml}. Furthermore, we should distinguish those names that the attacker knows from those that were freshly generated by others and which may remain
secret from the attacker; both kinds of names may appear in the terms.

In the applied pi calculus, such a sequence of messages is organized into a frame νn.σ, where n is a ﬁnite set of names (intuitively, the fresh names), ν is the restriction operator from the pi calculus, which intuitively introduces fresh names, and σ is a substitution of the form:

{M1/x1, . . . ,Ml/xl} with dom(σ) =def {x1, . . . , xl}

The variables enable us to refer to each Mi, for example for keeping track of their

order of transmission. We always assume that the terms Mi are closed. The size of

a frame φ = νn.{M1/x1, . . . ,Ml /xl} is |φ| =def

l i=1

|Mi|.

The

names

n

are

bound

in

φ

and can be renamed.

2.3 Deduction

Given a frame φ that represents the information available to an attacker, we may ask whether a given closed term M may be deduced from φ. This relation is written φ M (following Schneider [34]). It is axiomatized by the rules:

if ∃x ∈ dom(σ) s.t. xσ = M νn.σ M

s∈n νn.σ s

φ M1 · · · φ Mk f ∈ Σ φ f (M1, . . . , Mk)

φ M M =E M φM

Since the deducible messages depend on the underlying equational theory, we write
E when E is not clear from the context. Intuitively, the deducible messages are the messages of φ and the names that are not protected in φ, closed by equality

6

in E and closed by application of functions. The names that are protected in φ may however appear in deducible messages, as an example illustrates below. When νn.σ M, any occurrences of names from n in M are bound by νn (so νn.σ M could perhaps be written νn.(σ M)).
We have the following characterization of deduction:
Proposition 1 Let M be a closed term and νn.σ be a frame. Then νn.σ M if and only if there exists a term ζ such that fn(ζ) ∩ n = ∅ and ζσ =E M.
As an example, we consider the equational theory of pairing and symmetric encryption. The signature is Σenc = {pair, enc, fst, snd, dec}. As usual, we write x, y instead of pair(x, y). The theory Eenc is deﬁned by the axioms:
fst( x, y ) = x snd( x, y ) = y dec(enc(x, y), y) = x
Let φ =def νk, s.{enc(s, k)/x, k/y}. Then φ k and φ s. Furthermore, we have k =Eenc yφ and s =Eenc dec(x, y)φ.
2.4 Static equivalence
Deduction does not always sufﬁce for expressing the knowledge of an attacker, as discussed in the introduction. For example, consider φ1 =def νk.{enc(0, k)/x, k/y} and φ2 =def νk.{enc(1, k)/x, k/y}, where 0, 1 ∈ Σ are constant symbols. The attacker can deduce the same set of terms from these two frames since it knows 0 and 1. But it could tell the difference between these two frames by checking whether the decryption of x with y produces 0 or 1.
We say that two terms M and N are equal in the frame ϕ for the equational theory E, and write (M =E N )ϕ, if and only if ϕ = νn.σ, Mσ =E N σ, and {n} ∩ (fn(M) ∪ fn(N)) = ∅ for some names n and substitution σ. Then we say that two frames ϕ and ψ are statically equivalent, and write ϕ ≈s ψ, when dom(ϕ) = dom(ψ) and when, for all terms M and N, we have (M =E N)ϕ if and only if (M =E N )ψ. We write ≈sE when E is not clear from the context.
In our example, we have (dec(x, y) =Eenc 0)φ1 but not (dec(x, y) =Eenc 0)φ2. Therefore, φ1 ≈s φ2 although νk.{enc(0, k)/x} ≈s νk.{enc(1, k)/x}.
3 Comparison of deduction and static equivalence
We compare equality, deduction, and static equivalence from the point of view of decidability. There is little hope that deduction or static equivalence would be
7

decidable when equality itself is not. (We note however that, for some artiﬁcial, especially designed equational theories, deduction may be decidable while equality is undecidable.) Therefore, we focus on equational theories for which equality is at least decidable.
3.1 may be undecidable
Unfortunately, the decidability of equality is not sufﬁcient for the decidability of deduction and static equivalence. As evidence, let us consider the signature Σ = {f, ·, [ , ] } where f is a unary functional symbol, · is a binary functional symbol, and [ ] is a ternary functional symbol, and the equational theory Epc deﬁned by:
x · (y · z) = (x · y) · z [x1, y1]z · [x2, y2]z = [x1 · x2, y1 · y2]z
f ([x, x]y) = y
According to these equations, the symbol · is associative and distributes over the symbol [ ], and any term of the form f ([M, M]k) can be collapsed to k. Note that Epc is decidable since orienting the two last equations from left to right leads to a conﬂuent rewriting system. On the other hand, this equational theory enables us to encode the Post Correspondence Problem (PCP) into the deduction problem. The PCP is: given a ﬁnite number of pairs of words (ui, vi)1≤i≤n on the alphabet A ⊂ N , does there exist a sequence s1, . . . , sk ∈ {1..n}∗ such that us1 · · · usk = vs1 · · · vsk ? We have:
Proposition 2 Given the PCP instance (ui, vi)1≤i≤n on the alphabet A ⊂ N , we deﬁne the substitution σ = {[ui, vi]k/xi}. Then there exists a solution to the PCP instance if and only if νk.σ Epc k.
It follows:
Proposition 3 The deduction problem for Epc ( Epc) is undecidable.
In order to prove Proposition 2, we characterize the terms deducible from νk.σ. Let Pub be the set of terms built from the names N \ k and the function symbols f , ·, and [ ] (the public terms). Let L be the set of all terms of the form:
[us1 · · · · · usp, vs1 · · · · · vsp ]k
where s1, . . . , sp ∈ {1..n}. We deﬁne the set WF of well-formed terms by the grammar:
WF := L | Pub | f (WF) | WF · WF | [WF, WF]WF Note that if T ∈ WF then T = k (by induction on the construction of WF).
8

Lemma 1 The terms deducible from νk.σ are, modulo Epc, in the set WF of wellformed terms.
This lemma is proved by induction on the construction of deducible terms.
• For every variable xi, xiσ is well-formed. • For any name n ∈ N , if n = k, then n is well-formed, since n ∈ Pub. • If T1, T2, and T3 are well-formed modulo Epc, then f (T1), T1 · T2, and [T1, T2]T3
are also well-formed modulo Epc. • If T1 is well-formed modulo Epc and T1 =Epc T2, then T2 is also well-formed
modulo Epc.
We also characterize terms equal to k modulo Epc.
Lemma 2 Let T be a term. If k =Epc T and T = k then T is of the form:
f ([T1, T1]Ui · · · [Tm, Tm]Um)
with Ui =Epc k and T1 · · · Tm =Epc T1 · · · Tm.
This lemma is proved by induction on the number of applications of equalities that establish k =Epc T . The only equation that can yield k is f ([x, x]y) = y, which leads to a term of the speciﬁed form in the base case. In the inductive step, if T =Epc T with T = f ([T1, T1]Ui · · · [Tm, Tm]Um), Ui =Epc k, and T1 · · · Tm =Epc T1 · · · Tm, and only one equation has been applied to establish T =Epc T , then
• either the equation has been applied inside one of the terms Ti, Ti or Ui, and in that case, the property holds immediately;
• or the equation has been applied above the terms Ti, Ti , and Ui; and then either T = k or only the two ﬁrst equations can have been applied, and in either case the property holds.
Lemma 3 Let T be a term. If T =Epc k then T contains k as a subterm.
This lemma is proved by induction on the size of T . In the base case, T = k, and the property holds immediately. In the inductive step, T is of the form f ([T1, T1]Ui · · · [Tm, Tm]Um) with Ui =Epc k, by Lemma 2, and by induction hypothesis we obtain that the terms Ui contain k as a subterm, so T contains k as a subterm. An easy consequence of this lemma is that if T =Epc k then T ∈/ Pub.
Returning to Proposition 2, let us assume that there exists a solution to a given PCP instance. This assumption means that there exists a sequence s1, . . . , sp ∈ {1..n}∗ such that us1 · · · usp = vs1 · · · vsp. Then
9

f (xs1 · · · xsk )σ = f ([us1, vs1 ]k · · · [usp, vsp]k) =Epc f ([us1 · · · usp, vs1 · · · vsp]k) =Epc k
so k is deducible.
Conversely, assume that k is deducible. By Lemma 1, k must be equal modulo Epc to some term T ∈ WF. We show by induction on the size of T that there exists a solution to the PCP instance. By Lemma 2 and since T = k (since T ∈ WF), T must be of the form f ([T1, T1]Ui · · · [Tm, Tm]Um) with Ui =Epc k and T1 · · · Tm =Epc T1 · · · Tm. Since T cannot be public, T ∈ WF implies that the term T =def [T1, T1]Ui · · · [Tm, Tm]Um must be well-formed. If one of the terms Ui is wellformed, we conclude by induction hypothesis, since Ui =Epc k. On the other hand, if none of the terms Ui is well-formed, we proceed as follows. Since Ui =Epc k and by Lemma 3, all the terms [Ti, Ti ]Ui contain k as a subterm, so they are not public. By inspection of the cases in the deﬁnition of WF, we deduce that each [Ti, Ti ]Ui must be in WF. Since none of the terms Ui is well-formed, we must have that each [Ti, Ti ]Ui is in L, so T is actually equal (syntactically) to
[us11 · · · · · us1p1 , vs11 · · · · · vs1p1 ]k · · · [usm1 · · · · · usmpm , vsm1 · · · · · vsmpm ]k
with us11 · · · us1p1 · · · usm1 · · · usmpm = vs11 · · · vs1p1 · · · vsm1 · · · vsmpm
for some sji ∈ {1..n}. Therefore, there exists a solution to the PCP instance.
3.2 reduces to ≈s
Next we show that deduction may be reduced to static equivalence by adding only one free unary function symbol (a unary function symbol with no added equations). Thus, the equational theory is basically unchanged in the reduction—it can be given by a ﬁxed set of equational axioms. We leave as an open problem whether the reduction is always possible without even any change to the signature.
Proposition 4 Let E be an equational theory over some signature Σ. We deﬁne Σ =def Σ {h}, where h is unary, and let E be the least equational theory that extends E to terms over Σ . Let φ = νn.{M1/x1, . . . ,Ml/xl} be a frame over Σ, M be a closed term over Σ, and k be a fresh name. Then φ E M if and only if
νn.{M1/x1 , . . . ,Ml/xl,h(M)/xl+1} ≈sE ν(n. ∪ {k}){M1/x1 , . . . ,Ml/xl,k/xl+1}
We derive that if ≈sE is decidable, then E is also decidable (with at most the same complexity).
10

In order to prove the proposition, we ﬁrst introduce some notation. We let σ =

{M1/x1, . . . ,Ml/xl }, so φ = νn.σ, and let φ1 = νn.σ1 with σ1 = {M1/x1, . . . ,Ml/xl ,

h(M

/) xl+1

}

and

φ2

=

ν(n.

∪

{k})σ2

with

σ2

=

{M1/x1 ,

.

.

.

,Ml /xl ,k/xl+1 }.

One direction of Proposition 4 follows easily from Proposition 1. If φ E M then Proposition 1 implies that there exists a term ζ such that fn(ζ) ∩ n = ∅ and ζσ =E M ; then φ1 ≈sE φ2 because (h(ζ) =E xl+1)φ1 while (h(ζ)=E xl+1)φ2.

For the other direction, we use a weak version of a lemma due to Baudet et al. [8]. Given a term U == h(U1) and given a name a, the cutting function cutU,a is deﬁned recursively as follows:

cutU,a

(u)

=

u
⎧

if u is a name or a constant

cutU,a(g(T1,

.

.

.

,

Tk))

=

⎪⎨ ⎪⎩

a if g = h, k g(cutU,a(T1), .

= 1, and U1 =E . . , cutU,a(Tk))

T1 otherwise

Intuitively, cutU,a(T ) is obtained from T by replacing with a the subterms equal to U modulo E and whose head symbol is h. The following lemma (adapted from [8])
states that, if an equality holds between terms that mention h, then the equality still holds after cutting subterms whose head symbol is h.

Lemma 4 Let U == h(U1). If M =E N then cutU,a(M ) =E cutU,a(N ).
This lemma relies on the following characterization of E : it is the least transitive relation that contains the equations L =E R for which there exists an equation L =E R, a substitution θ, and a position p such that L |p == Lθ and R == L [Rθ]p. (As usual, a position is formalized as a sequence of integers that indicates a path in a term; M|p represents the subterm of M at position p, and M[Rθ]p is obtained by replacing that subterm with Rθ; see Deﬁnition 11 in Appendix B.) The lemma is proved by induction on the number of applications of equalities L =E R required for obtaining M =E N . For the base case, we assume assume that M =E N and that there exists an equation L =E R, a substitution θ, and a position p such that M|p == Lθ and N == M[Rθ]p. We consider two cases, distinguished by whether the cutting function cutU,a cuts a subterm of M above p or not:

(1) In the ﬁrst case, there exists a strict preﬁx p of p such that M|p == h(T1) with U1 =E T1. We consider the smallest p that satisﬁes this property, and let p = p .1.p , so N == M [h(T1[Rθ]p )]p . Since T1[Rθ]p =E T1[Lθ]p == T1 =E U1, both h(T1) and h(T1[Rθ]p ) are replaced with a by the cutting function, so cutU,a(M ) == cutU,a(N ).
(2) In the second case, any p such that M|p = h(T1) with U1 =E T1 is at least as long as p or incomparable. Therefore, cutU,a(M [x]p) == cutU,a(N [x]p) and cutU,a(M ) == cutU,a(M [x]p)[cutU,a(Lθ)]p, where x is a fresh variable. Moreover, cutU,a(Lθ) == LcutU,a(θ) and cutU,a(Rθ) == RcutU,a(θ) since h

11

does not occur in L nor R. We deduce
cutU,a(M ) == cutU,a(M [x]p)[cutU,a(Lθ)]p
== cutU,a(N [x]p)[LcutU,a(θ)]p
=E cutU,a(N [x]p)[RcutU,a(θ)]p
== cutU,a(N )
The inductive step of the proof of Lemma 4 is straightforward.
Lemma 4 yields the following conservativity property, whose converse is evident:
Lemma 5 If φ1 E M then φ E M .
By Proposition 1, we establish this conservativity property by assuming that there exists a term ζ over Σ such that fn(ζ ) ∩ n = ∅ and ζ σ1 =E M and proving that there then exists a term ζ over Σ such that fn(ζ)∩n = ∅ and ζσ =E M. The symbol h does not appear in M since M is over Σ, but it may appear in ζ . Intuitively, we obtain ζ from ζ by cutting subterms where h appears, as follows. Suppose that h appears in ζ σ1, so there exists a subterm U == h(V ) of ζ σ1. Let a be a fresh name. We apply the cutting function cutU,a to the equality ζ σ1 =E M, and derive cutU,a(ζ σ1) =E cutU,a(M ) == M by Lemma 4. Moreover, we can write cutU,a(ζ σ1) in the form ζ σ1 where ζ is a term over Σ such that fn(ζ ) ∩ n = ∅. (We construct ζ from ζ in the following way: for each path p such that ζ σ1|p == h(M ) with M =E V , p must be a path of ζ since neither M nor the terms Mi contain h, so we deﬁne ζ by replacing ζ |p with a at each such position p.) Applying this transformation to all occurrences of h, we eventually obtain ζ over Σ and also eliminate any occurrences of xl+1. We thus reduce to the case in which h does not appear in ζ σ1. In this case, we obtain ζ σ1 == ζ σ (because xl+1 cannot occur in ζ in this case) and ζ σ1 =E M (because E does not equate any more terms over Σ than E), so ζ σ =E M.
In order to establish Proposition 4, it remains to prove that if φ1 ≈sE φ2 then φ E M . For this purpose, we assume that φ EM and show that φ1 ≈sE φ2, using Lemma 4 as follows. Let V1 and V2 be two terms that do not contain the names n ∪ {k}.
• Assume that V1σ2 =E V2σ2. By substituting k with h(M) in the equality, we get V1σ1 =E V2σ1 since k occurs only in σ2, and any equation that holds for a fresh name such as k holds for any term.
• Conversely, assume that V1σ1 =E V2σ1. Let U == h(M). We apply the cutting function cutU,k to the equality, and derive cutU,k(V1σ1) =E cutU,k(V2σ1) by Lemma 4. Let us show that cutU,k(V1σ1) == V1cutU,k(σ1). We argue by contradiction, and assume that cutU,k(V1σ1) == V1cutU,k(σ1) does not hold. This assumption means that there exists a subterm V1 of V1 such that V1 is not a vari-
12

able and V1 σ1 == h(T ) with T =E M. Since V1 is not a variable, V1 must be of the form h(V1 ) with V1 σ1 == T =E M. Since V1 does not contain the names n, neither do V1 and V1 , so V1 σ1 =E M . Therefore, we have φ1 E M by Proposition 1, and hence φ EM by Lemma 5, contradicting our assumption that φ EM . We obtain cutU,k(V1σ1) == V1cutU,k(σ1), and similarly we obtain cutU,k(V2σ1) == V2cutU,k(σ1), so V1cutU,k(σ1) =E V2cutU,k(σ1). Finally, since cutU,k(σ1) == σ2, we deduce that V1σ2 =E V2σ2.
We conclude that φ1 ≈sE φ2.

3.3 ≈s does not reduce to in general

The converse is not true: may be decidable while ≈s is not. Indeed, we can encode an undecidable problem into the static equivalence problem in such a way that the deduction problem remains decidable.

Proposition 5 There exists an equational theory such that ≈s is undecidable while is decidable.

A preliminary presentation of our work [1] includes a ﬁrst construction of a suitable equational theory, with only a brief proof sketch. Following our work, Borgstro¨m has recently provided an alternative construction, based on context-free grammars, with a complete proof [15]. In what follows we describe our original construction, as it may remain instructive, but refer the reader to Borgstro¨m’s paper for a rigorous argument.

We consider the following construction: Given two deterministic Turing machines
M1 = (Q, A, q0, Qf , δ1) and M2 = (Q, A, q0, Qf , δ2) with the same control states, where δ1, δ2 : Q × A → Q × A × {L, R}, we construct the machine M(M1, M2) = (Q, A, q0, Qf , δ) where δ : {1, 2}×Q×A → Q×A×{L, R} such that δ(1, q, a) = δ1(q, a) and δ(2, q, a) = δ2(q, a). At each step, the machine M(M1, M2) plays a transition of either M1 or M2. Since the machines M1 and M2 are deterministic, a run of the machine M(M1, M2) on a word w may be described by a word s of {1, 2}∗, which gives the list of choices made by M(M1, M2) at each step. M(M1, M2), w →s denotes the machine (with its current tape) after the sequence of choices s on the word w. We assume that the local control state is written on the
tape.

Proposition 6 The following problem is undecidable.

Input: Two machines M(M1, M2) and M(M1, M2) and a word w of A∗.

Output: Does the any sequences s1

following , s2 ∈ {1,

property hold for 2}∗, M(M1, M2),

M(M1, M2) and w →s1 and M(M1

M(M1, , M2), w

M→s22)h: afover

the same tape if and only if M(M1, M2), w →s1 and M(M1, M2), w →s2 have the

same tape?

13

We reduce this undecidable problem to the ≈s problem under an equational theory Etm such that remains decidable. The intuitive idea of our encoding is that a frame φ represents a machine of the form M(M1, M2), a term M represents a sequence of choices such that Mφ represents the tape of the machine (and the number of choices) after this sequence of choices. Then, for two “machines” φ and φ , it is undecidable whether there exists two sequences of choices M1, M2 such that (M1 =Etm M2)φ and (M1 =Etm M2)φ , that is, whether φ ≈s φ .
On the other hand, it is possible to decide whether there exists a sequence of choices M such that Mφ =Etm N , that is, whether φ N ) for a given term N . The term N contains the number of choices, so it is sufﬁcient to test any sequence of choices of length equal to this number of choices.
Appendix A contains a proof of Proposition 6, as well as details on how we use the problem in question.

4 Deciding knowledge under convergent subterm theories

In this section, in order to obtain decidability results for both and ≈s, we restrict attention to subterm theories, deﬁned by a ﬁnite set of equations of the form M = N where N is a proper subterm of M or a constant symbol. In Section 4.1, we motivate and introduce a convergence condition on subterm theories. Convergent subterm theories are quite common in applications, as we illustrate with examples in Section 4.2. We present our main decidability results for these theories in Section 4.3.

4.1 Convergence

The deﬁnition of subterm theories is almost vacuous on its own. Even equality may be undecidable for subterm theories. Any equational theory deﬁned by a ﬁnite set of equations M = M with variables can be encoded as a subterm theory, with the two equations:

Whichever(M, M ) = M Whichever(M, M ) = M

for each original equation M = M . In light of this encoding, we should add the assumption that, by orienting the equations that deﬁne a subterm theory from left to right, we obtain a convergent rewriting system:

Deﬁnition 1 An equational theory E, deﬁned by a ﬁnite set of equations ni=1{Mi

= Ni} where fn(Mi) = fn(Ni) = ∅, is a convergent subterm theory if the set of

rewriting rules R =def

n i=1

{Mi

→

Ni}

is

convergent

and

if

each

Ni

is

a

proper

14

subterm of Mi or a constant. We write U → V if U and V are closed terms and U may be rewritten to V (in one step) using a rule of R. As usual, if R is convergent then for all terms U and V we have U =E V if and only if U↓= V ↓, where U↓ and V ↓ are the normal forms of U and V . We write →E instead of → when the equational theory is not clear from the context.
4.2 Examples

Important destructor-constructor rules like those for pairing, encryption, and signature may be expressed in subterm theories (typically convergent ones):

fst(< x, y >) = x

dec(enc(x, y), y) = x

snd(< x, y >) = y check(x, sign(x, sk(y)), pk(y)) = ok

Additional examples can be found in previous work (e.g., [3,12]). Convergent subterm theories also enable us to capture sophisticated but sensible properties, as in:

Einv : {I(I(x)) = x, I(x) × x = 1, x × I(x) = 1}
Eidem : {h(h(x)) = h(x)}
Esym : {enc(enc(x, y), y) = x}
The theory Einv models an inverse function. The theory Eidem models a hash function that is idempotent on small inputs (since the hash of a hash gives the same hash). The theory Esym represents an encryption function that also decrypts: the encryption of a plaintext, twice with the same key, returns the plaintext.
A rewriting system is convergent if and only if it is terminating and locally conﬂuent (by Newmann’s Lemma [23]). For theories with the subterm property, termination holds immediately, so it sufﬁces to examine critical pairs in order to establish convergence. For example, the theory Eenc has no critical pairs, so it is convergent; the theory Esym allows rewriting enc(enc(enc(x, y), y), y) in two different ways, but they both yield enc(x, y), so Esym is convergent as well; on the other hand, the theory Eenc ∪ Esym is not convergent because of the critical pair that consists of dec(enc(enc(x, y), y), y) → enc(x, y) and dec(enc(enc(x, y), y), y) → dec(x, y).

4.3 Decidability results

For convergent subterm theories, both and ≈s become decidable. 15

Theorem 1 For any frames φ and φ , for any closed term M, we can decide φ M and φ ≈s φ in polynomial time in |φ|, |φ |, and |M|.
In order to obtain a polynomial bound, we have to consider DAG representations of terms. We deﬁne and study them in the next section.
4.3.1 DAG representation for terms
Let us deﬁne what is a DAG representation of a term.
Deﬁnition 2 (DAG representation) A DAG representation of a term is a direct acyclic graph (V, l, E, v0), where V is the set of vertices, l : V → Σ a labeling function, E ⊆ V × V × {1..ar(Σ)} the set of edges, and v0 ∈ V the root of the graph. In addition, we assume that for every v ∈ V , for every integer i such that 0 ≤ i ≤ arity(l(v)), there exists a unique v (denoted by E(v, i)) such that (v, v , i) is in E and that there is no edge of the form (v, v , i) for i > arity(l(v)).
The size of R, written |R|, is the number of vertices of R.
The term t(V, l, E, v0) represented by a DAG (V, l, E, v0) is deﬁned recursively by t(V, l, E, v0) = l(v0)(t(V, l, E, e(v0, 1)), . . . , t(V, l, E, e(v0, arity(l(v0))))).
A DAG representation (V, l, E, v0) is minimal if there are no distinct vertices v1 and v2 such that t(V, l, E, v1) = t(V, l, E, v2).
Although the memory size needed for representing a DAG R is larger than |R|, it is polynomial (actually quadratic) in |R|. Thus the measure |R| is sufﬁcient for our purposes. Furthermore, with each term T , we can associate a unique minimal DAG representation of T such that its number of vertices is equal to the number |T |DAG of subterms of T . See ﬁgure 1 for examples.
Proposition 7 Given a DAG representation R, we can compute the minimal DAG representation of t(R) in polynomial time in |R|. Therefore, checking whether t(R1) == t(R2) where R1 and R2 are two DAG-representations can be done in polynomial time in |R1| and |R2|.
Given a DAG representation R, we repeatedly check (at most |R| times) whether there exist two distinct vertices v1 and v2 (at most |R|2 possibilities) such that l(v1) = l(v2) and for every i such that 0 ≤ i ≤ arity(l(v1)), E(v1, i) = E(v2, i). When such v1 and v2 exist, we suppress v1 in the set of vertices and replace each occurrence of v1 in E by v2. We end with the minimal representation of t(R). The total cost of this procedure is at most O(|R|3).
Proposition 8 Given a convergent subterm equational theory and a minimal DAG representation R of a term T , we can compute a (minimal) DAG representation of
16

T= f

ff

ab f

b

ab

f
1 1
f
12

2
f
2

ab R

f

2

1

1

f
2

f

12

b

ab

f
12

f 2 1f

2

1

f
1

a 2b

R1 R2

The DAG R is the minimal representation of T but R1 and R2 are also DAG representations of T .

Fig. 1. Examples of DAG representations.
the normal form T ↓ of T in polynomial time in |R|. Therefore, checking whether t(R1) =E t(R2) where R1 and R2 are two minimal DAG-representations can be done in polynomial time in |R1| and |R2|.

Let R = (V, l, E, v0) be a minimal DAG representation of a term T . For every rewriting rule of the form C[x1, . . . , xn] → C [x1, . . . , xn] or C[x1, . . . , xn] → c of the theory, we check (from the root) if the pattern C appears in R (with at
most |C||R| tests). If it is the case, that is, there exists some v ∈ V such that
t(V, l, E, v) == C[x1, . . . , xn]θ for some θ, then we replace the vertex v by one of the vertices that represents C [x1, . . . , xn]θ or we add the a vertex that represents c. We minimize the resulting DAG, via Proposition 7, in time O(|R|3). At each step
(except for a constant number of cases), one of the vertices is suppressed, so this
procedure stops after at most |R| steps. We end with a DAG-representation of T ↓, in time O(|R|4).

4.3.2 Proof of Theorem 1
The end of this section is devoted to the proof of the theorem.
Let E be a convergent subterm theory given by ni=1{Mi = Ni}. The size of the theory is given by cE = max1≤i≤n(|Mi|, ar(Σ) + 1). For example, we have that cEinv = 4, cEidem = 3, and cEsym = 5. By convention, when n = 0, we set cE = ar(Σ) + 1.

Step 1 of the proof: saturating a frame φ. We ﬁrst associate with each frame φ the set of subterms of messages in φ that may be deduced from φ by applying
17

only small contexts. We prove that this set can be computed in polynomial time. In addition, we show that each term in this set has a “recipe” whose DAG-size is polynomial.
Deﬁnition 3 Let φ = νn.{M1/x1, . . . , Ml/xl} be a frame. Let st(φ) be the set of subterms of the terms Mi. The saturation sat(φ) of φ is the minimal set such that:
(1) M1, . . . , Mk ∈ sat(φ); (2) if M1, . . . , Mk ∈ sat(φ) and f (M1, . . . , Mk) ∈ st(φ), then f (M1, . . . , Mk) ∈
sat(φ); (3) if M1, . . . , Mk ∈ sat(φ) and C[M1, . . . , Mk] → M, where C is a context,
|C| ≤ cE, fn(C) ∩ n = ∅, and M ∈ st(φ), then M ∈ sat(φ).
Proposition 9 Let φ be a frame, φ = νn.σ.
(1) The set sat(φ) can be computed in time O(|φ|cE+2). (2) For every M ∈ sat(φ), there exists a term ζM such that fn(ζM ) ∩ n = ∅,
|ζM |DAG ≤ cE|φ|, and ζM σ =E M . The term ζM is called a recipe of M and is chosen arbitrarily from among the terms that verify these properties.
The set sat(φ) is obtained by saturating the set {M1, . . . , Mk} by applying the rules 2 and 3 of Deﬁnition 3. Since sat(φ) ⊆ st(φ), this set is saturated in at most |φ| steps. At each step, we compute:
• Every closed term of the form C[M1, . . . , Mk] (up to renamings in C), where |C| ≤ cE and the terms Mi are already in the set. For each such term, we check whether it is an instance of some left-hand side of a rule. Thus we need at most O(|φ|cE+1) computations.
• Every term f (M1, . . . , Mk) that is also in st(φ), where the terms Mi are already in the set. In other words, for every term of the form f (M1, . . . , Mn) in st(φ) (at most |φ| terms), we check whether each Mi is already in the set. Thus we need at most O(|φ|2) computations.
Since 1 ≤ cE, each step takes at most O(|φ|cE+1). Since there are at most |φ| steps, sat(φ) can be computed in time O(|φ|cE+2). For the second part of Proposition 9, we know by Proposition 1 that for each term M of sat(φ) there exists ζM such that fn(ζM ) ∩ n = ∅ and ζM σ =E M. By construction of sat(φ), the term ζM may be chosen so that:
(1) ζM = xi if σ(xi) = M ; (2) ζM = f (ζM1, . . . , ζMk) with Mi ∈ sat(φ) if M is obtained by the rule 2; (3) ζM = C[ζM1, . . . , ζMk] with Mi ∈ sat(φ) if M is obtained by the rule 3.
Assume that we build a graph that contains every DAG that corresponds to the chosen terms ζM for M ∈ sat(φ).
18

(1) For every 1 ≤ i ≤ l, there is a vertex vi, labeled by xi. (2) If ζM = f (ζM1, . . . , ζMk) with Mi ∈ sat(φ), we add a vertex labeled by f and
connect this vertex to the vertices that correspond to ζM1, . . . , ζMk. (3) If ζM = C[ζM1, . . . , ζMk] with Mi ∈ sat(φ), we add a graph that corresponds
to C[ 1, . . . , k] (at most |C| ≤ cE vertices) connected to the vertices that correspond to ζM1, . . . , ζMk.
Each step costs one vertex or cE vertices. Since there are at most |sat(φ)| ≤ |φ| steps (one for each term M), the maximal DAG-size of a term ζM embedded in this graph is cE|φ|. Therefore, choosing the recipes from among those terms yields the desired size bound. In what follows, for each φ, we assume ﬁxed the set of recipes that corresponds to the terms of sat(φ).
Example 1 We consider again the equational theory Eenc deﬁned in Section 2.3. We have CEenc = 5, Let φ =def νk, s.{enc(s, k)/x, k/y}. By application of rule 1 of Deﬁnition 3, we have {M1, M2} ⊆ sat(φ), where M1 = enc(s, k) and M2 = k. By application of the rule 3 with the context C = dec( , ) (|C| ≤ 5), we have dec(M1, M2) == dec(enc(s, k), k) → s and s ∈ st(φ). Thus s ∈ sat(φ). Let M3 =def s. Since {M1, M2, M3} ⊆ sat(φ) ⊆ st(φ) ⊆ {M1, M2, M3}, we deduce that sat(φ) = {M1, M2, M3}.
The recipes for each term of sat(φ) may be chosen in the following way: ζM1 = x, ζM2 = y, and ζM3 = dec(x, y).
Step 2 of the proof: Introducing a ﬁnite set of equalities to characterize a frame. With each frame φ, we associate a set of equalities Eq(φ) (ﬁnite modulo renaming) such that two frames are equivalent if and only if they satisfy the equalities from each other’s set: φ satisﬁes the equalities Eq(φ) and φ satisﬁes the equalities Eq(φ ).
Deﬁnition 4 Let φ = νn.σ be a frame. The set Eq(φ) is the set of equalities
C1[ζM1, . . . , ζMk ] = C2[ζM1, . . . , ζMl ]
such that (C1[ζM1, . . . , ζMk] =E C2[ζM1, . . . , ζMl ])φ, |C1|, |C2| ≤ cE, and the terms Mi and Mi are in sat(φ). If φ is a frame such that (M =E N )φ for every (M = N) ∈ Eq(φ), we write φ |= Eq(φ).
Example 2 We continue Example 1. Recall that M1 = enc(s, k), M2 = k, and M3 = s. We are looking for equalities between small contexts over these terms, modulo the equational theory Eenc. By removing trivial or redundant equalities, we obtain that Eq(φ) = {enc(ζM3, ζM2) = ζM1}, that is, Eq(φ) = {enc(dec(x, y), y) = x}. Intuitively, this equality corresponds to the ability of an intruder that can check whether the ﬁrst message enc(s, k) is an encrypted message whose encryption key
19

is the second message k, by decrypting and re-encrypting the ﬁrst message with the second.
Although Eq(φ) may be inﬁnite since the contexts C1 and C2 may contain arbitrary names, Eq(φ) is ﬁnite modulo some renamings that we explain at the end of the section.
Two crucial lemmas show that it is sufﬁcient to consider these equalities:
Lemma 6 Let φ = νn.σ and φ = νn .σ be two frames such that φ |= Eq(φ). For all contexts C1 and C2 such that (fn(C1) ∪ fn(C2)) ∩ n = ∅, for all terms Mi, Mi ∈ sat(φ), if C1[M1, . . . , Mk] == C2[M1, . . . , Ml ], then (C1[ζM1, . . . , ζMk] =E C2[ζM1, . . . , ζMl ])φ .
Lemma 7 Let φ = νn.σ be a frame. For every context C1 such that fn(C1)∩n = ∅, for every Mi ∈ sat(φ), for every term T such that C1[M1, . . . , Mk] →∗E T , there exist a context C2 such that fn(C2) ∩ n = ∅, and terms Mi ∈ sat(φ), such that T == C2[M1, . . . , Ml ] and for every frame φ |= Eq(φ), (C1[ζM1, . . . , ζMk] =E C2[ζM1, . . . , ζMl ])φ .
These two lemmas are proved in a more general setting in Appendix B. How these lemmas are used for proving the decidability of deduction and static equivalence is explained in steps 3 and 4 of the proof, respectively.
Step 3 of the proof: decidability of . Here we show that any message deducible from a frame φ is actually a context over terms in sat(φ).
Proposition 10 Let φ = νn.σ be a frame, M be a closed term and M↓ its normal form. Then φ M if and only if there exist C and M1, . . . , Mk ∈ sat(φ) such that fn(C) ∩ n = ∅ and M↓== C[M1, . . . , Mk].
If M ↓== C[M1, . . . , Mk] with fn(C) ∩ n = ∅, then M =E C[ζM1, . . . , ζMk]σ, by construction of the terms ζMi. Thus, by Proposition 1, φ M. Conversely, if φ M, then by Proposition 1, there exists ζ such that fn(ζ)∩ n = ∅ and M =E ζσ. Thus M↓== (ζσ)↓. Applying Lemma 7, we obtain that (ζσ)↓== C[M1, . . . , Mk] for some M1, . . . , Mk ∈ sat(φ) and C such that fn(C) ∩ n = ∅.
We derive that φ M can be decided by checking whether M ↓ is of the form C[M1, . . . , Mk] with Mi ∈ sat(φ). Given a term M, M ↓ can be computed in polynomial time. Once sat(φ) is computed (in polynomial time by Proposition 9), checking whether there exist C and M1, . . . , Mk ∈ sat(φ) such that fn(C) ∩ n = ∅ and M ↓== C[M1, . . . , Mk] may be done in time O(|M||φ|2). The procedure is basically as follows:
• Sort sat(φ) by the size of the terms (with cost |sat(φ)|2).
20

• For each term T of sat(φ) (from terms of maximal size to terms of minimal size), check whether T is equal to a subterm of M. When it is the case, delete this subterm from M. There are |M| subterms in M, the equality test costs |T | ≤ |φ| computations, so this loop can be done in |M||φ|2.
• Check whether the remaining part of M still contains private names in n. If it is not the case, we have found a context C and M1, . . . , Mk ∈ sat(φ) such that fn(C) ∩ n = ∅ and M ↓== C[M1, . . . , Mk]; otherwise such a context does not exist.
This procedure is correct because, when cutting subterms of M equal to terms in sat(φ), we start with terms in sat(φ) of maximal size. We conclude that φ M is decidable in polynomial time.
Step 4 of the proof: decidability of ≈s.
Proposition 11 For all frames φ and φ , we have φ ≈s φ if and only if φ |= Eq(φ ) and φ |= Eq(φ).
By deﬁnition of static equivalence, if φ ≈s φ then φ |= Eq(φ ) and φ |= Eq(φ). Conversely, assume that φ |= Eq(φ) and consider M and N such that there exist n and σ such that φ = νn.σ, (fn(M) ∪ fn(N)) ∩ n = ∅, and (M =E N)φ. Then Mσ =E Nσ, so (Mσ) ↓== (Nσ) ↓. Let T = (Mσ) ↓. Applying Lemma 7, we obtain that there exist M1, . . . , Mk ∈ sat(φ) and CM such that fn(CM ) ∩ n = ∅ and
T == CM [M1, . . . , Mk] and M σ =E CM [ζM1, . . . , ζMk]σ
Since T == (N σ)↓, we obtain similarly that there exist M1, . . . , Ml ∈ sat(φ) and CN such that fn(CN ) ∩ n = ∅ and
T == CN [M1, . . . , Ml ] and N σ =E CN [ζM1, . . . , ζMl ]σ
Moreover, since CM [M1, . . . , Mk] == CN [M1, . . . , Ml ], we derive from Lemma 6 that CM [ζM1, . . . , ζMk]σ =E CN [ζM1, . . . , ζMl ]σ , thus (M =E N )φ . Conversely, when (M =E N )φ and φ |= Eq(φ ), we also have that (M =E N )φ. We conclude that φ ≈s φ .
Therefore, given φ and φ , in order to decide whether φ ≈s φ we construct sat(φ) and sat(φ ). This construction can be done in polynomial time by Proposition 9. For each term M of sat(φ) or sat(φ ), the term ζM has a polynomial DAG-size.
As noted previously, Eq(φ ) may be inﬁnite since the equalities may contain arbitrary names. However, each equation of Eq(φ) is of the form (C1[ζM1, . . . , ζMk] =E C2[ζM1, . . . , ζMl ]) with |C1|, |C2| ≤ cE, so each equality of Eq(φ) contains at most 2cE distinct names besides the names of the recipes. The following lemma, whose proof is easy, says that those 2cE names can be ﬁxed:
21

Lemma 8 Let K = 2cE and {n1, . . . , nK} be any set of K distinct names, distinct from the names of the recipes for the terms of sat(φ). Let Eq (φ) be the set consisting on the all the equalities
C1[ζM1, . . . , ζMk ] = C2[ζM1, . . . , ζMl ]
such that (C1[ζM1, . . . , ζMk] =E C2[ζM1, . . . , ζMl ])φ, |C1|, |C2| ≤ cE, the terms Mi and Mi are in sat(φ), and fn(C1) ∪ fn(C2) ⊆ {n1, . . . , nK}. Then, for any frame φ , φ |= Eq(φ) if and only if φ |= Eq (φ).
Thus, instead of checking whether φ |= Eq(φ), we can check whether φ |= Eq (φ). More precisely, for all contexts C1 and C2 such that |C1|, |C2| ≤ cE and fn(C1) ∪ fn(C2) ⊆ {n1, . . . , nK}, for all Mi, Mi ∈ sat(φ), we can check whether (C1[ζM1, . . . , ζMk] =E C2[ζM1, . . . , ζMl ])φ and (C1[ζM1, . . . , ζMk] =E C2[ζM1, . . . , ζMl ])φ .
There are at most O((|φ|cE )2) equalities in Eq (φ). Each term of the form C1[ζM1, . . . , ζMk]φ has a polynomial DAG-size. The equality of two terms represented by DAGs can be checked in polynomial time: we do not need to expand the DAGs in order to test for equality. We conclude that φ ≈s φ can be decided in polynomial time in |φ| and |φ |.
Although this proof is effective, the complexity bounds that we obtain from it appear rather high. For example, for the equational theory Eenc of Section 2.3, we can obtain that φ M is decidable in time O(|M|3|φ|7). It should be possible to do much better.
5 Deciding knowledge under more general equational theories
Next, we relax our hypotheses on equational theories. Instead of requiring convergence, we consider equational theories with some associative and commutative symbols that come with a rewriting system R such that a R is convergent modulo AC rewriting. Moreover, instead of imposing a syntactic condition (such as a subterm property), we introduce a condition on the set sat(φ) associated with each frame φ. We present the resulting hypotheses in Section 5.1. We give examples of theories that satisfy the hypotheses in Section 5.2. Finally, we prove general decidability results in Section 5.3.
5.1 The hypotheses
We establish decidability results for equational theories that satisfy three properties. The purpose of this section is to deﬁne and start to explain these three properties; Section 5.2 explains them further through examples.
22

5.1.1 AC-convergence

Our ﬁrst hypothesis is an adaptation of the standard notion of convergence for theories with AC symbols.

Let E be an equational theory, and let ⊕1, . . . , ⊕k be the binary functional symbols such that the equations x⊕i(y⊕iz) = (x⊕iy)⊕iz (associativity) and x⊕iy = y⊕ix (commutativity) are in E.

For two terms U and V , we write U =AC V if U and V are equal in the theory induced by the equations x ⊕i (y ⊕i z) = (x ⊕i y) ⊕i z and x ⊕i y = y ⊕i x for 1 ≤ i ≤ k. When this theory is empty (because we have no AC symbols), =AC is
simply syntactic equality.

When R is a rewriting system, we write U →AC V if there exists W such that U =AC W and W → V . The relation →∗AC denotes the reﬂexive and transitive closure of →AC. For every term U, the set of normal forms U↓ (closed modulo AC) of U is the set of terms V such that U →∗AC V and V has no successor for →AC.
Deﬁnition 5 (AC-convergent) An equational theory E is AC-convergent if there exists a ﬁnite rewriting system R such that:

• R is AC-terminating, that is, for every closed term U, there is no inﬁnite se-
quence U →AC U1 →AC · · · Uk →AC · · · . • R is AC-conﬂuent, that is, for every closed terms U, U1, and U2 such that U →AC
U1 and U →AC U2, there exist V1 and V2 such that U1 →∗AC V1, U2 →∗AC V2, and V1 =AC V2. • For all closed terms U and V , the equality U =E V holds if and only if there exists a term T ∈ (U↓ ∩ V ↓).

By AC-convergence, the set U↓ is always ﬁnite and for all V, W ∈ U↓, the equality V =AC W holds. AC-convergence immediately implies the decidability of equations on closed terms.

In what follows, E is an AC-convergent equational theory and R is a rewriting

system associated with E that satisﬁes the conditions of Deﬁnition 5. If R consists

of a ﬁnite set of rules

k i=1

{Mi

→

Ni},

the

size

cE

of

the

theory

E

is

deﬁned

as

cE = max1≤i≤k(|Mi|, |Ni|, ar(Σ)+1). As a special case, cE = ar(Σ) +1 when R is

empty. As another special case, we obtain the deﬁnition of cE given in Section 4.3

for subterm theories.

Note that E need not have AC symbols. A theory deﬁned by a convergent rewriting system without AC symbol is of course an AC-convergent theory. In that case, we may simply say that the theory is convergent.

Example 3 As a ﬁrst example, we consider the theory of an encryption scheme

23

that has an homomorphism property. This property is simply that the encryption of a pair is the pair of the encryptions; the literature (e.g., [32]) suggests other homomorphism properties. This property is modeled by the equation:
enc( x, y , z) = enc(x, z), enc(y, z)

We also assume an analogous equation for decryption:
dec( x, y , z) = dec(x, z), dec(y, z)
As usual, we write x, y instead of pair(x, y). The signature Σhomo is {pair, enc, fst, snd, dec}, and the theory Ehomo is deﬁned by the axioms:

enc( x, y , z) = enc(x, z), enc(y, z) dec( x, y , z) = dec(x, z), dec(y, z)
fst( x, y ) = x snd( x, y ) = y dec(enc(x, y), y) = x

We consider the rewriting system Rhomo obtained from Ehomo by orienting the equations from left to right. With this choice of Rhomo, the theory Ehomo is convergent: its only critical pair is joinable.
dec(enc( x1, x2 , y), y)

x1, x2 dec( enc(x1, y), enc(x2, y) , y)

dec(enc(x1, y), y), dec(enc(x2, y), y)

x1, dec(enc(x2, y), y)

Example 4 The theory of XOR is also AC-convergent. The XOR operator is represented by the ⊕ function symbol, with the following properties:

⎧⎫

⎪⎪⎪⎪⎪⎪⎪⎪⎨

x

⊕

(y ⊕ z) x⊕y

= =

(x ⊕ y) y⊕x

⊕

z

⎪⎪⎪⎪⎪⎪⎪⎪⎬

Exor = ⎪⎪⎪⎪⎪⎪⎪⎪⎩

x⊕x = 0 x⊕0 = x

⎪⎪⎪⎪⎪⎪⎪⎪⎭

where 0 is a constant symbol and the signature Σxor is {0, ⊕}. We associate to Exor

24

the rewriting system Rxor:

⎧⎫
⎪⎨ x ⊕ x → 0 ⎪⎬ Rxor = ⎪⎩ x ⊕ 0 → x ⎪⎭

Using this choice of Rxor, it is easy to verify that Exor is AC-convergent.

5.1.2 Local stability

Our second hypothesis roughly says that, for every frame, there is a ﬁnite set of terms deducible from the frame that satisﬁes certain closure conditions. Stating this hypotheses precisely requires a few auxiliary deﬁnitions and notations.

Assume that there exists some rule M0 → N0 of the rewriting system R and some
substitution θ such that either there exists a term U1 such that U =AC U1, U1 = M0θ, and V = N0θ, or there exist terms U1 and U2 such that U =AC U1 ⊕ U2 for some AC symbol ⊕, U1 = M0θ, and V =AC N0θ ⊕ U2. Then we say that the reduction U → V occurs in head, and we write U →h V .

We write α ·⊕ M for the term M ⊕ · · · ⊕ M, α times (for α ∈ N∗). We simply write αM when the AC symbol is clear from the context. Given a set of terms S and a
set of names n, we write sum⊕(S, n) for the set of arbitrary sums of terms of S and other names, closed modulo AC-rewriting:

⎧

⎪⎪⎪⎪⎪⎨ (α1 ·⊕ T1) ⊕ · · · ⊕ (αn ·⊕ Tn)

sum⊕(S,

n)

=def

⎪⎪⎪⎪⎪⎩

(β1

⊕ ·⊕ n1)

⊕

·

·

·

⊕

(βk

·⊕

nk )

⎫
αi, βi ∈ N∗, ⎪⎪⎪⎪⎪⎬

ni ∈/ n, Ti ∈ S

⎪⎪⎪⎪⎪⎭

Typically, the names in n will be private, and the others public. Then we deﬁne sum(S, n) as the union of the sum⊕(S, n) for any AC symbol ⊕ of the theory.
For convergent subterm theories, the main step of the proof of the decidability of and ≈s shows the existence, for each frame φ, of a set sat(φ) that is stable by
application of “small” contexts. We generalize this condition by requiring that the application of a rewriting rule to a “small” context C applied to arbitrary sums of terms in sat(φ) is again a “small” context C applied to sums of terms in sat(φ). The deﬁnition of “small” is partly arbitrary; we bound the size of C by cE and the size of C by cE2, but other ﬁnite size bounds may be suitable.
Deﬁnition 6 (locally stable) An AC-convergent equational theory E is locally stable if, for every frame φ = νn.{M1/x1, . . . , Mk/xk}, where the terms Mi are closed and in normal form, there exists a ﬁnite (computable) set sat(φ), closed modulo AC, such that

25

(1) M1, . . . , Mk ∈ sat(φ), and n ∈ sat(φ) for every n ∈ fn(φ); (2) if M1, . . . , Mk ∈ sat(φ) and f (M1, . . . , Mk) ∈ st(sat(φ)), then f (M1, . . . ,
Mk) ∈ sat(φ); (3) if C[S1, . . . , Sl] →h M, where C is a context such that |C| ≤ cE and fn(C) ∩
n = ∅, and where S1, . . . , Sl ∈ sum⊕(sat(φ), n) for some AC symbol ⊕ (or Si ∈ sat(φ) if there is no AC symbol), then there exist a context C , a term M , and S1, . . . , Sk ∈ sum⊕(sat(φ), n) (or S1, . . . , Sk ∈ sat(φ) if there is no AC symbol), such that |C | ≤ c2E, fn(C ) ∩ n = ∅, and M →∗AC M =AC C [S1, . . . , Sk]; (4) if M ∈ sat(φ) then φ M.
The set sat(φ) need not be unique, nor minimal. Any set that satisﬁes the four conditions is adequate for our present purposes.
Example 5 For the equational theory Ehomo of Example 3, given a frame φ in normal form, the set sat(φ) is simply obtained by adding subterms of φ deducible from φ. Suppose for example that the attacker gets the messages enc( n1, n2 , k) and enc(n3, enc(n1, k)). Since enc( n1, n2 , k) =Ehomo enc(n1, k), enc(n2, k) , the corresponding frame can be written
φ2 = νn1, n2, n3, k.{ enc(n1, k), enc(n2, k) /x1, enc(n3, enc(n1, k))/x2}
Then, the deducible subterms of the frame φ2 are enc(n1, k), enc(n2, k), and n3, so sat(φ2) is the set
{ enc(n1, k), enc(n2, k) , enc(n3, enc(n1, k)), enc(n1, k), enc(n2, k), n3}
In Section 5.2.2 we prove that this construction satisﬁes the requirements.
In general, establishing that an equational theory is locally stable may be difﬁcult. We give other examples of locally stable theories in Section 5.2.
5.1.3 Local ﬁniteness and local decidability
For our third hypothesis, we consider a certain set of “small” equations that a frame satisﬁes. One of our results says that this set characterizes the frame. The third hypothesis, which this section presents, pertains to deciding whether another frame satisﬁes this set. In fact, this section discusses two versions of the third hypothesis, called local ﬁniteness and local decidability. Either is sufﬁcient for our purposes; the former has been more attractive in applications; the latter is more general. As the use of equations may suggest, we rely on the third hypothesis in the study of static equivalence but not deduction.
For each frame φ = νn.σ, we assume a ﬁxed set of terms ρ(φ) = {ζM | M ∈ sat(φ)} such that for each ζM , fn(ζM ) ∩ n = ∅ and ζM σ =E M. Intuitively, the
26

term ζM explains how M may be obtained from the terms of φ. Since all the terms of sat(φ) are deducible, such a set exists by Proposition 1. For instance, for Example 5, the terms associated with enc(n1, k), enc(n2, k), and n3 are respectively ζenc(n1,k) = fst(x1), ζenc(n2,k) = snd(x1), and ζn3 = dec(x2, fst(x1)).
Much as in Section 4.3, we associate a set of “small” equations Eq(φ) with each frame φ, in such a way that two frames are equivalent if and only if they satisfy the equations of each other’s set (see Proposition 17).
Deﬁnition 7 Let φ = νn.σ be a frame in normal form. The set Eq(φ) is the set of equations of the form
C1[χ1, . . . , χk] = C2[χ1, . . . , χl]
where (C1[χ1, . . . , χk] =E C2[χ1, . . . , χl])φ, (fn(C1)∪fn(C2))∩n = ∅, |C1| ≤ cE, |C2| ≤ c2E, and the terms χi and χi are in the set sum⊕(ρ(φ), n) for some AC symbol ⊕ (or χi and χi are in ρ(φ) if there is no AC symbol).
When φ and ψ are frames and (M =E N)ψ for every (M = N) ∈ Eq(φ), we say that ψ satisﬁes the equations of Eq(φ), and write ψ |= Eq(φ).
Deﬁnition 8 (locally decidable) A locally stable equational theory is locally decidable if the question of whether ψ |= Eq(φ), for frames φ and ψ, is decidable.
The set Eq(φ) may in general be inﬁnite since the terms χi may be of arbitrary size. Local ﬁniteness means that the set Eq(φ) is always equivalent to a ﬁnite set of equations.
Deﬁnition 9 (locally ﬁnite) A locally stable equational theory is locally ﬁnite if, for every frame φ, there exists a ﬁnite (computable) set of equations Eq (φ) such that, for every frame ψ:
ψ |= Eq(φ) if and only if ψ |= Eq (φ)
This property sufﬁces for local decidability:
Proposition 12 Every locally ﬁnite equational theory is locally decidable.
Local ﬁniteness is always true when there are no AC symbols since then the set Eq(φ) contains only ﬁnitely many equations up to renaming:
Proposition 13 Let E be a locally stable equational theory with no AC symbols. Then, for any frame φ, there exists a ﬁnite set of equations Eq (φ) such that for every frame ψ, we have ψ |= Eq(φ) if and only if ψ |= Eq (φ). In other words, E is locally ﬁnite.
27

Each equation of Eq(φ) is of the form C1[χ1, . . . , χk] = C2[χ1, . . . , χl] with χi, χi in ρ(φ). Thus it contains a ﬁnite number of names (bounded by cE + c2E). The set Eq (φ) is obtained from Eq(φ) by renaming the names to a ﬁxed set of names.

In Section 5.2 we present some non-trivial examples of locally ﬁnite theories with AC symbols. Establishing local ﬁniteness is our preferred way of proving local decidability for such theories. Here we show that at least an (inﬁnite) subset of Eq(φ) may always be replaced by a ﬁnite number of equations.

Deﬁnition 10 Let φ = νn.σ be a frame. Let N be a set of public names (that is, such that N ∩ n = ∅). We write EqAC (φ, N) for the set of equations of the form χ1 = χ2 such that χ1, χ2 ∈ sum⊕(ρ(φ), n), fn(χ1) ∪ fn(χ2) ⊆ N , and (χ1 =E χ2)φ.
Note that EqAC (φ, N ) is a subset of Eq(φ). We show that the set EqAC (φ, N ) may always be replaced by a ﬁnite number of equations if N is a ﬁnite set of public names.

Proposition 14 Let φ = νn.σ be a frame and N a ﬁnite set of names such that
N ∩ n = ∅. There exists a ﬁnite set EqbAC (φ, N ) ⊆ EqAC (φ, N ), such that for every frame ψ:

ψ |= EqAC (φ, N ) if and only if ψ |= EqbAC (φ, N )
In addition, the cardinality of EqbAC (φ) is at most the cardinality of sat(φ) plus the cardinality of N.

This proposition can be proved using an elementary result on Z-modules, namely
that submodules of ﬁnitely generated Z-modules are ﬁnitely generated. (Facts on Z-
module may be found in [33], for example.) Assume that sat(φ) = {M1, . . . , Mk}, N = {n1, . . . , nl}, and let Γ ∈ Zk+l. For 1 ≤ i ≤ k + l, Γi denotes the ith coefﬁcient of Γ, and Γ denotes the equation:

ΓiζMi ⊕

Γini =

(−Γi)ζMi ⊕

(−Γi)ni

Γi>0,i≤k

Γi>0,i>k

Γi<0,i≤k

Γi <0,i>k

Let EqAC (φ, N ) = {Γ | Γ ∈ Zk+l, (Γ)φ}. It is easy to verify that for any frame ψ, ψ |= EqAC (φ, N ) if and only if ψ |= EqAC (φ, N ). It is also easy to verify (simplifying the equations) that EqAC (φ, N ) is a Z-submodule of Zk+l and thus can be generated by a ﬁnite number of vectors V1, . . . , Vr with r ≤ k + l. We deﬁne
EqbAC (φ, N ) = {V1, . . . , Vr}. It is then easy to conclude that, for any frame ψ, ψ |= EqAC (φ, N ) if and only if ψ |= EqbAC (φ, N ).

Example 6 Consider for example a pure AC theory with only one AC symbol + (and no other function symbol), and the frame

φ3 = νn1, n2, n3.{3n1 + 2n2 + 4n3/x1, n2 + 3n3/x2, n1 + 2n3/x3, 3n2 + n3/x4}

28

The set Eq(φ3) consists of the equations of the form α1x1+α2x2+α3x3+α4x4+T =
α1x1 + α2x2 + α3x3 + α4x4 + T with αi, αi ∈ N, and T and T sums of names distinct from n1, n2, and n3. By convention, if αi = 0 (resp. αi = 0) then the term αixi (resp. αixi) does not appear in the sum. Since the equation is true for φ3, we must have T = T , thus it is sufﬁcient to consider the equations of the form
α1x1 +α2x2 +α3x3 +α4x4 = α1x1 +α2x2 +α3x3 +α4x4 with αi, αi ∈ N. Adopting the convention that a negative term αx (with α < 0) in an equation actually appears

on the other side of the equation, it is sufﬁcient to consider the equations of the

form α1x1 + α2x2 + α3x3 + α4x4 = 0, with αi, αi ∈ Z. For example, the equation 3x1 − 2x2 + x3 = 0 stands for the equation 3x1 + x3 = 2x2. Then, the set of vectors
(α1, α2, α3, α4) such that the equation α1x1 + α2x2 + α3x3 + α4x4 = 0 holds for φ3 is exactly the set of vectors U of Z4 such that AU = 0 with

⎛⎞

A

=

⎜⎜⎜⎜⎜⎝

3 2

0 1

1 0

0 3

⎟⎟⎟⎟⎟⎠

4321

By using classical elementary operations on rows and columns, we ﬁnd that AU =

0 if and only if

⎛⎞

U

=

λ

⎜⎜⎜⎜⎜⎜⎜⎜⎝

1 1 −3

⎟⎟⎟⎟⎟⎟⎟⎟⎠

−1

for λ ∈ Z. We deduce that the set of equations satisﬁed by φ3 is exactly the set of equations of the form: λx1 + λx2 = 3λx3 + λx4. Thus, in order to decide whether a frame ψ satisﬁes Eq(φ3), it is sufﬁcient to check whether ψ satisﬁes the single equation x1 + x2 = 3x3 + x4.

5.2 Examples

In this section, we give examples of locally stable and locally ﬁnite equational theories. In Section 5.3, we prove that local stability implies the decidability of deduction, and that local stability and local ﬁniteness imply the decidability of static equivalence.
Several equational theories related to cryptographic operations are locally stable and locally ﬁnite. In particular, we prove that convergent subterm theories are locally stable. We show that a theory of homomorphic encryption, a simple theory for addition, and a theory for blind signatures (which are not subterm theories) are also locally stable. These equational theories do not have AC symbols, so local ﬁnite-

29

ness follows from Proposition 13. As examples of theories with AC symbols, we prove that the pure AC theory and a theory of the XOR operator are locally stable and locally ﬁnite. The proofs of these properties require only a few lines, and thus are much simpler than direct proofs of decidability. We have also drafted proofs that the theory of Abelian groups is locally stable and locally ﬁnite, but in that case the proofs are quite tedious—probably more than direct proofs of the decidability of deduction and static equivalence.
As the examples may suggest, proving local stability often requires a precise understanding of the cryptographic primitives represented by an equational theory. In particular, removing some equations need not always preserve local stability.
5.2.1 Convergent subterm theories
It is easy to verify that the deﬁnition of sat(φ) given in Deﬁnition 1 ﬁts our requirements for local stability.
Proposition 15 Every convergent subterm theory is a locally ﬁnite theory.
Consequently, we obtain again that both deducibility and static equivalence are decidable for convergent subterm theories.
5.2.2 Homomorphism
We consider again the equational theory Ehomo (deﬁned in Example 3), which represents an encryption scheme with a homomorphism property. The size of the theory is 7.
Comon-Lundh and Treinen have investigated a very similar equational theory [21]. They have shown that its deduction relation is decidable in PTIME. Here we show that Ehomo is locally stable, and it is obviously locally ﬁnite (since it has no AC symbol). These properties will imply that both deduction and static equivalence are decidable.
Let φ = νn.{M1/x1, . . . , Mk/xk} be any frame in normal form. We deﬁne sat(φ) to be the smallest set such that:
(1) M1, . . . , Mk ∈ sat(φ), and n ∈ sat(φ) for every n ∈ fn(φ); (2) if M1, . . . , Mk ∈ sat(φ) and f (M1, . . . , Mk) ∈ st(sat(φ)), then f (M1, . . . ,
Mk) ∈ sat(φ); (3) if M1, M2 ∈ sat(φ) and dec(M1, M2) →h M and the rule dec(enc(x, y), y) →
x has been applied, or fst(M1) →h M, or snd(M1) →h M, then M ∈ sat(φ).
The set sat(φ) is ﬁnite since we add only subterms of terms of φ. It trivially satisﬁes
30

conditions 1, 2, and 4 of Deﬁnition 6. Let us show that it satisﬁes condition 3. Let M1, . . . , Mk ∈ sat(φ) and assume that C[M1, . . . , Mk] →h M where |C| ≤ 7. The case where C is a single hole is covered by the fact that the terms are in normal
form. The other cases are covered by rule 3 except in the following cases:
• C = enc( , ), C = enc( , T ), or C = enc(T, ) where fn(T ) ∩ n = ∅ and |T | ≤ 5. · For enc(M1, M2) → M with M1, M2 ∈ sat(φ): In this case, M1 must be of the form M1 = M1, M2 and M = enc(M1, M2), enc(M2, M2) . By rule 3, we know that both M1 and M2 are in sat(φ) since fst(M1) → M1 and snd(M1) → M2. Thus M is a context over terms of sat(φ) where the context may be chosen as C = enc( , ), enc( , ) since |C | = 7 ≤ 72 = 49. · For enc(M1, T ) → M with M1 ∈ sat(φ), fn(T ) ∩ n = ∅, and |T | ≤ 5: We have similarly that M = enc(M1, T ), enc(M2, T ) with M1 and M2 in sat(φ). Thus M is a context over terms of sat(φ) where the context may be chosen as C = enc( , T ), enc( , T ) since |C | ≤ 5 + 2|T | ≤ 15 ≤ 72 = 49. · For enc(T, M2) → M with M2 ∈ sat(φ), fn(T ) ∩ n = ∅, and |T | ≤ 5: We must have T = T1, T2 with |T1| + |T2| ≤ 4. We deduce that M = enc(T1, M2), enc(T2, M2) , so M is a context over terms of sat(φ) where the context may be chosen as C = enc(T1, ), enc(T2, ) since |C | ≤ 5 + |T1| + |T2| ≤ 9 ≤ 49.
• C = dec( , ), C = dec( , T ), or C = dec(T, ) where fn(T ) ∩ n = ∅ and |T | ≤ 5, and the rule dec( x, y , z) → dec(x, z), dec(y, z) has been applied.
These three cases are very similar to the three cases above.

5.2.3 Addition

We consider a simple theory for addition. Let Σadd be any signature that contains 0, s, pred, and plus, with the equations:

⎧⎫

⎪⎪⎪⎪⎪⎨ plus(x, s(y)) = plus(s(x), y) ⎪⎪⎪⎪⎪⎬

Eadd = ⎪⎪⎪⎪⎪⎩

plus(x, 0) = x pred(s(x)) = x

⎪⎪⎪⎪⎪⎭

The size cEadd of this theory is at least 4 (and possibly higher if Σadd contains symbols other than 0, s, pred, and plus). We deﬁne Radd by simply orienting the equations from left to right. Using this choice of Radd, it is easy to verify that Eadd is convergent. (Note that Eadd has no AC symbol.) For local stability, when φ = νn.{M1/x1, . . . , Mk/xk} is any frame in normal form, we deﬁne sat(φ) to be the smallest set such that:
(1) M1, . . . , Mk ∈ sat(φ), and n ∈ sat(φ) for every n ∈ fn(φ); (2) if M1, . . . , Mk ∈ sat(φ) and f (M1, . . . , Mk) ∈ st(sat(φ)), then f (M1, . . . ,

31

Mk) ∈ sat(φ); (3) if pred(M) →h M and M ∈ sat(φ) then M ∈ sat(φ).
The set sat(φ) is ﬁnite since we add only subterms of terms of φ. The set sat(φ) trivially satisﬁes conditions 1, 2, and 4 of Deﬁnition 6. Let us show that it satisﬁes condition 3. Assume that C[M1, . . . , Mk] →h M with Mi ∈ sat(φ) and |C| ≤ cEadd. The only non-trivial case is the one where plus(M1, M2) →h M with M1, M2 ∈ sat(φ) and the rule plus(x, s(y)) → plus(s(x), y) has been applied. We must have that M2 = s(M2). Hence pred(M2) →h M2, so M2 ∈ sat(φ). Now, we have M = plus(s(M1), M2), with M1, M2 ∈ sat(φ) and |plus(s( ), )| = 4 ≤ 42, so condition 3 is satisﬁed.
Note that, were we to omit the equation pred(s(x)) = x in our equational theory, the proof of local stability would no longer be valid.

5.2.4 Blind signatures

We consider a theory recently introduced by Kremer and Ryan in order to model blind signatures and related constructs in their analysis of a protocol for electronic voting [27]. This theory treats signatures much like that of Section 4, with four differences: the checking construct is called checksign (rather than check); checking does not require plaintext; there is no separate signature-key computation (no function sk); and, most importantly, this theory also describes signature blinding and unblinding functions. Let Σblind be any signature that contains open, commit, getpk, host, checksign, sign, unblind, and blind, with the equations:

⎧⎫

⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨

open(commit(x, y), y) = x getpk(host(x)) = x

⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎬

Eblind

=

⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩unbchliencdk(susiinggbnnl((insbidlgi(nnbd(lx(inx,d,y(y)x,),,pyzk))(,,yyy))))

= = =

x x sign(x,

z)⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎭

The size cEblind of the theory is at least 7 (and possibly higher if Σblind contains additional symbols). We deﬁne Rblind by simply orienting the equations from left to right. The theory Eblind is clearly convergent. To prove that Eblind is locally stable, we extend the deﬁnition of subterms by requiring that sign(M1, M3) is a subterm
32

of sign(blind(M1, M2), M3). More formally, we deﬁne:

stext(u) = u

stext(sign(blind(M1, M2), M3)) =

{sign(M1, M3)} ∪ {sign(blind(M1, M2), M3)}

∪ stext((blind(M1, M2)) ∪ stext(M3)

stext(f (M1, . . . , Mk)) =

{f (M1, . . . , Mk)} ∪

k i=1

stext(Mi)

otherwise (that is, for other terms)

When φ = νn.{M1/x1, . . . , Mk/xk} is any frame in normal form, we deﬁne sat(φ) to be the smallest set such that:

(1) M1, . . . , Mk ∈ sat(φ), and n ∈ sat(φ) for every n ∈ fn(φ);
(2) if M1, . . . , Mk ∈ sat(φ) and f (M1, . . . , Mk) ∈ st(sat(φ)), then f (M1, . . . , Mk) ∈ sat(φ);
(3) if C[M1, . . . , Mk] →h M , Mi ∈ sat(φ) and M ∈ stext(sat(φ)) then M ∈ sat(φ).

The set sat(φ) is ﬁnite since we add only extended subterms of terms of φ. The set sat(φ) trivially satisﬁes conditions 1, 2, and 4 of Deﬁnition 6. Let us show that it satisﬁes condition 3. Assume that C[M1, . . . , Mk] →h M with Mi ∈ sat(φ) and |C| ≤ c .Eblind If one of the four ﬁrst rules of Rblind has been applied, then M is a subterm of C[M1, . . . , Mk]. Thus either M = C [M1, . . . , Mk] for some context C and condition 3 is satisﬁed or M is a subterm of one of the terms Mi, thus M ∈ sat(φ) and condition 3 is satisﬁed. If the ﬁfth rule of Rblind has been applied, then three (non-trivial) cases may arise.
• If M2 →h M then M is an extended subterm of M2, so M ∈ sat(φ) and condition 3 is satisﬁed.
• Similarly, if unblind(M1, M2) →h M then M is an extended subterm of M1, so M ∈ sat(φ) and condition 3 is satisﬁed.
• Finally, suppose that unblind(sign(M1, M2), M3) →h M. It must be the case that M1 = blind(M1, M3). Since unblind(M1, M3) →h M1 and M1 is a subterm of M1, we have M1 ∈ sat(φ). Now, since M = sign(M1, M2) and |sign( , )| = 3 ≤ 72, condition 3 is satisﬁed.

5.2.5 Pure AC theory We consider the case where the signature contains only constant symbols and AC symbols ⊕1, . . . , ⊕k and the equational theory Eac contains only the AC equations
33

for each symbol:

⎧⎫

Eac

=

k ⎪⎨ (x
i=1 ⎪⎩

⊕i

y) ⊕i x ⊕i

z y

= =

x ⊕i y ⊕i

(y x

⊕i

z) ⎪⎬
⎪⎭

With the empty rewriting system Rac = ∅, Eac is an AC-convergent theory. When φ = νn.{M1/x1, . . . , Mk/xk} is any frame, we deﬁne sat(φ) to be the smallest set such that:

(1) M1, . . . , Mk ∈ sat(φ), and n ∈ sat(φ) for every n ∈ fn(φ); (2) if M1, M2 ∈ sat(φ) and M1 ⊕i M2 ∈ st(sat(φ)), then M1 ⊕i M2 ∈ sat(φ); (3) if M1 =AC M2 and M1 ∈ sat(φ) then M2 ∈ sat(φ).

The set sat(φ) is ﬁnite since we add only terms smaller or equal than the maximal size of the terms of φ. The set sat(φ) trivially satisﬁes conditions 1, 2, and 4 of Deﬁnition 6. It also satisﬁes condition 3 since the rewriting system Rac is empty. Thus Eac is locally stable.

Now, for any frame φ = νn.σ, the set of equations Eq(φ) simply consists of
EqAC (φ, N − n). Since names that do not appear in φ need not be considered, EqAC (φ, N − n) is equivalent to EqAC (φ, N ) where N is the set of free names of φ, in the sense that for any frame ψ, ψ |= EqAC (φ, N − n) if and only if ψ |= EqAC (φ, N ). By Proposition 14, we conclude that the equational theory Eac
is locally ﬁnite.

5.2.6 XOR
We consider the theory Exor of the XOR operator (deﬁned in Example 3).
We have seen that Exor is AC-convergent. We wish to verify that Exor is locally stable. When φ = νn.{M1/x1, . . . , Mk/xk} is any frame in normal form, we deﬁne sat(φ) to be the smallest set, closed under AC, such that:
(1) M1, . . . , Mk ∈ sat(φ), 0 ∈ sat(φ), and n ∈ sat(φ) for every n ∈ fn(φ); (2) if M1, . . . , Mk ∈ sat(φ) and f (M1, . . . , Mk) ∈ st(sat(φ)), then f (M1, . . . ,
Mk) ∈ sat(φ); (3) if M1, M2 ∈ sat(φ), then (M1 ⊕ M2)↓ ⊆ sat(φ); (4) if a is a name not in n and if M ⊕ a →AC M with M ∈ st(sat(φ)), then
M ∈ sat(φ).
Let us ﬁrst show that sat(φ) is ﬁnite. Let the set sst(φ) of simple subterms of φ be the set of subterms of φ whose head symbol is not ⊕. Let S = {T1 ⊕ · · ·⊕ Tn | Ti ∈ sst(φ), Ti = 0, Ti = Tj ⇒ i = j} be the set of sums of distinct terms of sst(φ). The set S is ﬁnite and sat(φ) ⊆ S. Indeed, it is easy to show that S satisﬁes the four conditions above, using that st(S) = S.

34

The set sat(φ) trivially satisﬁes conditions 1, 2, and 4 of Deﬁnition 6. Let us

show that it satisﬁes condition 3. Let M1, . . . , Mk ∈ sat(φ) and C be a context

such that fn(C) ∩ n = ∅ and assume that C[M1, . . . , Mk] →h M. We have that

C[M1, . . . , Mk] =AC

k i=1

Mi

⊕

n i=1

ai,

where

each

ai

is

a

name

not

in

n

or

the

constant 0. Let us show that one of the normal forms of C[M1, . . . , Mk] is a con-

text of terms in sat(φ). Applying recursively rule 3, we obtain that (

k i=1

Mi)↓

⊆

sat(φ). Now, applying recursively rule 4, we obtain that C[M1, . . . , Mk]↓ =AC

M⊕

r j=1

aij

,

with

M

∈ sat(φ). By AC-convergence, we know that M →∗AC=AC

M⊕

r j=1

aij

with

M

⊕

r j=1

aij

∈

sum⊕(sat(φ), n),

since

no

aij

is

0

(for

other-

wise the term would not be in normal form), so the context C that simply consists

of a hole satisﬁes the required conditions.

Like in the pure AC case, for any frame φ, the set of equation Eq(φ) simply consists
of EqAC (φ, N − n) since the only constant is 0 and 0 is itself in sat(φ). Since names that do not appear in φ do not need to be considered, EqAC (φ, N − n) is equivalent to EqAC (φ, N) where N is the set of free names of φ, in the sense that for any frame ψ, ψ |= EqAC (φ, N − n) if and only if ψ |= EqAC (φ, N ). Thus, by Proposition 14, the equational theory Exor is locally ﬁnite.

Note that, in this example, we can also conclude without using Proposition 14. Indeed, we can consider the set Eq (φ) that consists of the equations

k1 k2

l1

l2

ζMij ⊕ nij =

ζMij ⊕

nij

j=1 j=1 j=k1+1 j=k2+1

such that

⎛⎞

k1 k2

l1

l2

⎝ ζMij ⊕

nij =E

ζMij ⊕

nij ⎠ φ

j=1 j=1

j=k1+1

j=k2+1

nij ∈ fn(φ), and l = j =⇒ Mil = Mij , nil = nij . Clearly, Eq (φ) is ﬁnite and it is easy to verify that, for any frame ψ, ψ |= EqAC (φ, n) if and only if ψ |= Eq (φ).

5.3 Decidability results

In this section, we state and prove our decidability results for deduction and static equivalence.

5.3.1 Decidability of deduction
Theorem 2 For locally stable equational theories, deduction is decidable. More precisely, given a frame φ and a term M, once M ↓ and sat(φ) are computed, φ M can be decided in polynomial time in |M↓ | and |sat(φ)|.
The proof is based on the following lemma.

35

Lemma 9 Let E be a locally stable theory. Let φ = νn.σ be a frame. For every context C1 such that fn(C1) ∩ n = ∅, for every Mi ∈ sat(φ), for every term T such that C1[M1, . . . , Mk] →AC T , there exist a context C2 such that fn(C2) ∩ n = ∅, and terms Mi ∈ sat(φ), such that T →∗AC C2[M1, . . . , Ml ].
This lemma is a weak version of Lemma 11 presented in Section 5.3.2. Applying repeatedly this lemma leads to the following corollary.
Corollary 1 Let E be a locally stable theory. Let φ = νn.σ be a frame. For every context C1 such that fn(C1) ∩ n = ∅, for every Mi ∈ sat(φ), for every term T in normal form such that C1[M1, . . . , Mk] →∗AC T , there exist a context C2 such that fn(C2) ∩ n = ∅, and terms Mi ∈ sat(φ), such that T =AC C2[M1, . . . , Ml ].
Assuming Lemma 9, let φ = νn.σ be a frame, C1 be a context such that fn(C1) ∩ n = ∅, Mi ∈ sat(φ), and T a term in normal form such that C1[M1, . . . , Mk] →∗AC T . Either C1[M1, . . . , Mk] =AC T and we are done or we have C1[M1, . . . , Mk] →AC T →∗AC T . By Lemma 9, there exist a context C2 such that fn(C2) ∩ n = ∅, and terms Mi ∈ sat(φ) such that T →∗AC C2[M1, . . . , Ml ]. By AC-conﬂuence of the equational theory and since T is in normal form, C2[M1, . . . , Ml ] →∗AC T . Since the equational theory is AC-terminating, we repeat this transformation until we obtain that T =AC C3[M1 , . . . , Ml ] for some terms Mi ∈ sat(φ) and some context C3.
We show that for any term deducible from a frame φ, one of its normal forms is a context over terms in sat(φ).
Proposition 16 Let φ = νn.σ be a frame, M be a closed term, and M↓ its set of normal forms. Then φ M if and only if there exist a term T ∈ M↓, a context C, and terms M1, . . . , Mk ∈ sat(φ) such that fn(C) ∩ n = ∅ and T == C[M1, . . . , Mk].
If there exists T ∈ M↓ such that T == C[M1, . . . , Mk] with fn(C) ∩ n = ∅, then T =E C[ζM1, . . . , ζMk]σ, by construction of ζM1, . . . , ζMk. Therefore, by Proposition 1, φ T , so φ M.
Conversely, if φ M, then by Proposition 1, there exists ζ such that fn(ζ) ∩ n = ∅ and M =E ζσ. Thus there exists T ∈ (M↓ ∩ (ζσ)↓). Since ζσ →∗AC T , applying Corollary 1, we obtain that T =AC C[M1, . . . , Mk] for some M1, . . . , Mk ∈ sat(φ) and C such that fn(C) ∩ n = ∅. Thus we end the proof by choosing T == C[M1, . . . , Mk].
We derive that φ M can be decided by checking whether one of the terms in M↓ is of the form C[M1, . . . , Mk] with Mi ∈ sat(φ). Regarding the complexity, once M↓ and sat(φ) are computed, φ M can be decided in polynomial time in |M↓ | and |sat(φ)| using the same procedure as for Theorem 1.
36

5.3.2 Decidability of static equivalence
Theorem 3 For locally decidable equational theories, static equivalence is decidable. A fortiori, for locally ﬁnite equational theories, static equivalence is decidable.
The complexity of the resulting decision procedure closely depends on the complexity of the procedure that ensures local decidability. For locally decidable equational theories, this complexity is simply the complexity of checking whether φ |= Eq(ψ) given the frames φ and ψ. For locally ﬁnite equational theories, it depends polynomially on the time needed to compute Eq (φ) and the time needed to check whether ψ satisﬁes each equation of Eq (φ).
Our result relies on three hypotheses, namely AC-convergence, locally stability, and local decidability. We leave as an open problem whether the third hypothesis is essential. As far as we know, it might be that AC-convergence and local stability imply local decidability. However, our experience with proofs of local decidability suggests that this implication does not hold, at least not trivially.
The proof is based on two main lemmas that we prove in Appendix B.
Lemma 10 Let E be a locally stable theory. Let φ = νn.σ and ψ = νn .σ be two frames such that ψ |= Eq(φ). For all contexts C1 and C2 such that (fn(C1) ∪ fn(C2)) ∩ n = ∅, for all terms Mi, Mi ∈ sat(φ), if C1[M1, . . . , Mk] =AC C2[M1, . . . , Ml ], then (C1[ζM1, . . . , ζMk ] =E C2[ζM1, . . . , ζMl ])ψ.
Lemma 11 Let E be a locally stable theory. Let φ = νn.σ be a frame. For every context C1 such that fn(C1) ∩ n = ∅, for every Mi ∈ sat(φ), for every term T such that C1[M1, . . . , Mk] →AC T , there exist a context C2 such that fn(C2) ∩ n = ∅, and terms Mi ∈ sat(φ), such that T →∗AC C2[M1, . . . , Ml ] and for every frame ψ |= Eq(φ), (C1[ζM1, . . . , ζMk] =E C2[ζM1, . . . , ζMl ])ψ.
As for Corollary 1, applying repeatedly Lemma 11 leads to the following corollary.
Corollary 2 Let E be a locally stable theory. Let φ = νn.σ be a frame. For every context C1 such that fn(C1) ∩ n = ∅, for every Mi ∈ sat(φ), for every term T in normal form such that C1[M1, . . . , Mk] →∗AC T , there exist a context C2 such that fn(C2) ∩ n = ∅, and terms Mi ∈ sat(φ), such that T =AC C2[M1, . . . , Ml ] and for every frame ψ |= Eq(φ), (C1[ζM1, . . . , ζMk] =E C2[ζM1, . . . , ζMl ])ψ.
In order to check whether two frames satisfy the same equations, we show (using these two lemmas) that it is sufﬁcient to check whether they satisfy the same “small” equations.
Proposition 17 Let E be a locally stable theory. For all frames φ and ψ, we have φ ≈s ψ if and only if φ |= Eq(ψ) and ψ |= Eq(φ).
37

By deﬁnition of static equivalence, if φ ≈s ψ then φ |= Eq(ψ) and ψ |= Eq(φ).
Conversely, assume that ψ |= Eq(φ) and consider M and N such that there exist n and σ such that φ = νn.σ, (fn(M) ∪ fn(N)) ∩ n = ∅, and (M =E N)φ. Then Mσ =E N σ, so ((Mσ)↓∩(N σ)↓) = ∅. Let T ∈ ((Mσ)↓∩(N σ)↓). Since Mσ →∗AC T , by applying Corollary 2 we obtain that there exist CM and M1, . . . , Mk ∈ sat(φ) such that fn(CM ) ∩ n = ∅, T =AC CM [M1, . . . , Mk], and (M =E CM [ζM1, . . . , ζMk])ψ. Since N σ →∗AC T , we obtain similarly that there exist CN and M1, . . . , Ml ∈ sat(φ) such that fn(CN ) ∩ n = ∅, T =AC CN [M1, . . . , Ml ], and (N =E CN [ζM1, . . . , ζMl ])ψ. Moreover, since CM [M1, . . . , Mk] =AC CN [M1, . . . , Ml ], we derive from Lemma 10 that (CM [ζM1, . . . , ζMk] =E CN [ζM1, . . . , ζMl ])ψ, and hence that (M =E N )ψ. Symmetrically, if (M =E N )ψ and φ |= Eq(ψ), then (M =E N )φ. We conclude that φ ≈s ψ.
Therefore, given φ and ψ, we may consider Eq(φ) and Eq(ψ) in order to decide whether φ ≈s ψ. By local decidability of the theory, we can decide whether φ |= Eq(ψ) and ψ |= Eq(φ).
6 Conclusion
This paper investigates decidability questions for message deducibility and static equivalence, two formal representations for knowledge in the analysis of security protocols. This investigation yields a few somewhat negative results, for example that static equivalence cannot always be reduced to message deducibility. On the other hand, the main results are strong, positive ones: message deducibility and static equivalence are decidable under a wide class of equational theories. This class includes, in particular, standard theories for basic cryptographic primitives. It also includes some less standard, more advanced examples: theories of XOR, homomorphic encryption, blind signatures, addition, and pure AC theories. We succeed in giving a uniﬁed treatment for this disparate collection of theories, with a body of techniques that apply to all of them plus special techniques for verifying that particular theories belong in the class. In addition, for a simple, syntactically deﬁned subclass of theories, we prove that deducibility and static equivalence are actually decidable in polynomial time.
The performances of the corresponding decision procedures obviously depend on the choice of equational theory, and we do not expect them to be very good in many cases. Nevertheless, for many theories of interest, deciding deducibility and static equivalence may well be practical. Baudet has recently implemented a variant of our procedures [6]. The tool ProVerif supports another approach for establishing static equivalences [13].
As indicated in the introduction, deduction and static equivalence are static no-
38

tions, but they play an important role in analysis with respect to active attacks. Nevertheless, it remains challenging to obtain decidability results with respect to active attacks. This problem is addressed in recent and ongoing work. That work is still largely under way, so detailed descriptions may be premature, but we brieﬂy mention some interesting developments. Going beyond the work of Delaune and Jacquemard [22] (described in the introduction), Baudet has proved that both deduction and static equivalence are decidable under convergent subterm theories [7]. Comon-Lundh is studying the decidability of deduction under general equational theories, including associativity and commutativity properties [19]. Overall, this ﬁeld appears as a lively one, with increasingly sophisticated techniques and powerful theorems. We may therefore look forward to much progress in algorithmic reasoning about the knowledge of active attackers in security protocols.
Acknowledgments
We are grateful to Michael Rusinowitch and Mathieu Baudet for very helpful discussions.
References
[1] Mart´ın Abadi and Ve´ronique Cortier. Deciding knowledge in security protocols under equational theories. In Proc. 31st Int. Coll. Automata, Languages, and Programming (ICALP’2004), volume 3142 of Lecture Notes in Computer Science, pages 46–58. Springer, July 2004.
[2] Mart´ın Abadi and Ve´ronique Cortier. Deciding knowledge in security protocols under (many more) equational theories. In Proc. 18th IEEE Computer Security Foundations Workshop (CSFW’05), pages 62–76. IEEE Comp. Soc. Press, June 2005.
[3] Mart´ın Abadi and Ce´dric Fournet. Mobile values, new names, and secure communication. In Proceedings of the 28th ACM Symposium on Principles of Programming Languages (POPL’01), pages 104–115, January 2001.
[4] Mart´ın Abadi and Andrew D. Gordon. A bisimulation method for cryptographic protocols. Nordic Journal of Computing, 5(4):267–303, Winter 1998.
[5] Mart´ın Abadi and Andrew D. Gordon. A calculus for cryptographic protocols: The spi calculus. Information and Computation, 148(1):1–70, January 1999.
[6] Mathieu Baudet. Private communication, 2005.
[7] Mathieu Baudet. Deciding security of protocols against off-line guessing attacks. In Proceedings of the 12th ACM Conference on Computer and Communications Security (CCS’05), pages 16–25. ACM Press, November 2005.
39

[8] Mathieu Baudet, Ve´ronique Cortier, and Steve Kremer. Computationally sound implementations of equational theories against passive adversaries. Manuscript, extended version of [9], 2005.
[9] Mathieu Baudet, Ve´ronique Cortier, and Steve Kremer. Computationally sound implementations of equational theories against passive adversaries. In Proc. 32nd Int. Coll. Automata, Languages and Programming (ICALP’2005), volume 3580 of Lecture Notes in Computer Science, pages 652–663. Springer, July 2005.
[10] Bruno Blanchet. An efﬁcient cryptographic protocol veriﬁer based on Prolog rules. In 14th IEEE Computer Security Foundations Workshop (CSFW-14), pages 82–96, June 2001.
[11] Bruno Blanchet. From secrecy to authenticity in security protocols. In Manuel Hermenegildo and Germa´n Puebla, editors, 9th Int. Static Analysis Symposium (SAS’02), volume 2477 of LNCS, pages 342–359. Springer Verlag, September 2002.
[12] Bruno Blanchet. Automatic proof of strong secrecy for security protocols. In IEEE Symposium on Security and Privacy, pages 86–100, May 2004.
[13] Bruno Blanchet, Mart´ın Abadi, and Ce´dric Fournet. Automated veriﬁcation of selected equivalences for security protocols. In 20th IEEE Symposium on Logic in Computer Science (LICS 2005), pages 331–340. IEEE Computer Society, June 2005.
[14] Michele Boreale, Rocco De Nicola, and Rosario Pugliese. Proof techniques for cryptographic processes. In Proceedings of the Fourteenth Annual IEEE Symposium on Logic in Computer Science, pages 157–166, July 1999.
[15] Johannes Borgstro¨m. Static equivalence is harder than knowledge. In Jos Baeten and Iain Phillips, editors, Proceedings of the 12th International Workshop on Expressiveness in Concurrency (EXPRESS’05), Electronic Notes in Theoretical Computer Science, pages 44–55. Elsevier Science Publishers, August 2005.
[16] Yannick Chevalier, Ralf Kuester, Michael Rusinowitch, and Mathieu Turuani. Deciding the security of protocols with Difﬁe-Hellman exponentiation and products in exponents. In P. K. Pandya and J. Radhakrishnan, editors, FST TCS 2003: Foundations of Software Technology and Theoretical Computer Science, 23rd Conference, volume 2914 of LNCS, pages 124–135. Springer Verlag, 2003.
[17] Yannick Chevalier, Ralf Kuester, Michael Rusinowitch, and Mathieu Turuani. An NP decision procedure for protocol insecurity with xor. In Proceedings of the 18th Annual IEEE Symposium on Logic In Computer Science (LICS’03), pages 261–270, 2003.
[18] Yannick Chevalier and Michael Rusinowitch. Combining intruder theories. In Proc. 32nd Int. Coll. Automata, Languages and Programming (ICALP’2005), volume 3580 of Lecture Notes in Computer Science, pages 639–651. Springer, July 2005.
[19] Hubert Comon-Lundh. Intruder theories (ongoing work). In Foundations of Software Science and Computation Structures (FoSSaCS’04), volume 2987 of LNCS, pages 1–4. Springer, 2004.
40

[20] Hubert Comon-Lundh and Vitaly Shmatikov. Intruder deductions, constraint solving and insecurity decision in presence of exclusive or. In Proceedings of the 18th Annual IEEE Symposium on Logic In Computer Science (LICS’03), pages 271–280, 2003.
[21] Hubert Comon-Lundh and Ralf Treinen. Easy intruder deductions. Technical Report LSV-03-8, Laboratoire Spe´ciﬁcation et Ve´riﬁcation, ENS de Cachan, France, 2003.
[22] Ste´phanie Delaune and Florent Jacquemard. Narrowing-based constraint solving for the veriﬁcation of security protocols. Technical Report LSV-04-8, Laboratoire Spe´ciﬁcation et Ve´riﬁcation, ENS de Cachan, France, April 2004.
[23] Nachum Dershowitz and Jean-Pierre Jouannaud. Handbook of theoretical computer science, volume B: formal models and semantics, chapter Rewrite systems, pages 243– 320. MIT Press, 1991.
[24] Danny Dolev and Andrew C. Yao. On the security of public key protocols. IEEE Transactions on Information Theory, IT-29(12):198–208, March 1983.
[25] Shaﬁ Goldwasser and Silvio Micali. Probabilistic encryption. Journal of Computer and System Sciences, 28:270–299, April 1984.
[26] Richard A. Kemmerer, Catherine Meadows, and Jonathan K. Millen. Three systems for cryptographic protocol analysis. Journal of Cryptology, 7(2):79–130, Spring 1994.
[27] Steve Kremer and Mark Ryan. Analysis of an electronic voting protocol in the applied pi calculus. In Proceedings of the 14th European Symposium on Programming (ESOP’05), volume 3444 of LNCS, pages 186–200, April 2005.
[28] Pascal Lafourcade, Denis Lugiez, and Ralf Treinen. Intruder deduction for ac-like equational theories with homomorphisms. In Proceedings of the 16th International Conference on Rewriting Techniques and Applications (RTA’05), volume 3467 of LNCS, pages 308–322. Springer, April 2005.
[29] Patrick Lincoln, John Mitchell, Mark Mitchell, and Andre Scedrov. A probabilistic poly-time framework for protocol analysis. In Proceedings of the Fifth ACM Conference on Computer and Communications Security, pages 112–121, 1998.
[30] Gavin Lowe. Breaking and ﬁxing the Needham-Schroeder public-key protocol using FDR. In Tools and Algorithms for the Construction and Analysis of Systems, volume 1055 of LNCS, pages 147–166. Springer Verlag, 1996.
[31] Lawrence C. Paulson. The inductive approach to verifying cryptographic protocols. Journal of Computer Security, 6(1–2):85–128, 1998.
[32] Ronald L. Rivest, Leonard Adleman, and Michael L. Dertouzos. On data banks and privacy homomorphisms. In R. DeMillo, D. Dobkin, A. Jones, and R. Lipton, editors, Foundations of Secure Computation, pages 169–180. Academic Press, 1978.
[33] Pierre Samuel. Algebraic Theory of Numbers. Hermann, 1970.
[34] Steve Schneider. Security properties and CSP. In IEEE Symposium on Security and Privacy, pages 174–187, 1996.
41

Appendix

A Proof of Proposition 6 and additional material on Proposition 5

Proposition 6. The following problem is undecidable.

Input: Two machines M(M1, M2) and M(M1, M2) and a word w of A∗.

Output: for any

Does the following sequences s1, s2 ∈

property {1, 2}∗,

(P) hold M(M1,

for M(M1 M2), w →s1

, M2 and

)Man(dMM1, M(M2)1,,wM2→s)2:

have the same tape if and only if M(M1, M2), w →s1 and M(M1, M2), w →s2 have

the same tape?

The halting problem for a deterministic Turing machine can be reduced to this
problem. Given any deterministic Turing machine M = (Q, A, q0, Qf , δ), we construct the deterministic Turing machine T (M) = (Q, A {co}, q0, Qf , δ ), where we modify the transitions for the ﬁnal states:

⎧
⎪⎨ δ (q, a) = δ(q, a) ⎪⎩ δ (q, a) = (q, c0, L)

∀a ∈ A, q ∈/ Qf ∀a ∈ A, q ∈ Qf .

Then M(M, T (M)), w →s1 and M(M, T (M)), w →s2 have the same tape for any sequences s1, s2 ∈ {1, 2}∗ if and only if M does not reach its ﬁnal state on w.
Now, let M0 be any ﬁxed deterministic Turing machine. For any sequences s1, s2 ∈ {1, 2}∗, M(M0, M0), w →s1 and M(M0, M0), w →s2 have the same tape. We deduce that M does not reach its ﬁnal state on w if and only M(M, T (M)) and M(M0, M0) satisfy the property (P ). This ends the proof of proposition 6.
In order to reduce this undecidable problem to ≈s, we consider the equational theory Etm displayed in ﬁgure A.1. By orienting the equations from left to right, we obtain convergent rewriting rules such that M =Etm M if and only if M↓== M ↓ where M ↓ is the normal form of M for these rewriting rules. Intuitively, we consider terms of the form h(w1, q, w2, sn(0)), where w1 represents the tape before the machine’s head, w2 represents the tape after the machine’s head, q is the control state, and sn(0) is a counter that represents the number of rules that have been applied. A term [(q, a → q1, a1, D1), (q, a → q2, a2, D2)] represents a couple of rules of two Turing machine. Then the term

Apply(i, [(q, a → q1, a1, D1), (q, a → q2, a2, D2)], h(w1, q, w2, sn(0))),

where i ∈ {1, 2}, D1, D2 ∈ {L, R}, represents the application of the rule number 1 or 2 (depending on i) on the tape h(w1, q, w2, sn(0)). The result of this application
is given by the equational theory Etm.

42

Apply(1, [(xq, x1 → xq , x2, R), y], h(z1, xq, x1 · z2, x )) = h(z1 · x2, xq , z2, s(x ))
Apply(1, [(xq, x1 → xq , x2, R), y], h(z1, xq, x1, x )) = h(z1 · x2, xq , #, s(x ))
Apply(1, [(xq, x1 → xq , x2, L), y], h(z1 · x3, xq, x1 · z2, x )) = h(z1, xq , x3 · (x2 · z2), s(x ))
Apply(2, [y, (xq, x1 → xq , x2, R)], h(z1, xq, x1 · z2, x )) = h(z1 · x2, xq , z2, s(x ))
Apply(2, [y, (xq, x1 → xq , x2, R)], h(z1, xq, x1, x )) = h(z1 · x2, xq , #, s(x ))
Apply(2, [y, (xq, x1 → xq , x2, L)], h(z1 · x3, xq, x1 · z2, x )) = h(z1, xq , x3 · (x2 · z2), s(x ))
Fig. A.1. The equational theory Etm.

Now, to each machine M(M1, M2), we associate the frame φM(M1,M2):

νA ∪ Q.{h(#, q0, #, 0)/x0} ∪

{[(q, a → δ1(q, a)), (q, a → δ2(q, a))]/xa,q}

a∈A,q∈Q

Then we can verify that two machines M(M1, M2) and M(M1, M2) verify the property (P) of proposition 6 if and only if φM(M1,M2) ≈s φM(M1,M2). We deduce that ≈s is undecidable for the equational theory Etm.
At the same time, remains decidable: in order to decide whether φ M, where φ = νn.σ, it is sufﬁcient to decide if there exists ζ such that fn(ζ) ∩ n = ∅ and ζσ =Etm M , that is, ζσ ↓== M ↓. Intuitively, for φ of the form φM(M1,M2) and for M of the form h(w1, q, w2, sn(0)), we are looking for some sequences of choices (represented by ζ) such that the tape of the machine M(M1, M2) after this sequence of choices is equal to M. Since the term M contains the number of rules that have been applied, it is sufﬁcient to test any sequence of choices of length equal to this number of rules, so there is a ﬁnite number of sequences to check. This idea can be generalized to any φ and M, establishing that is decidable. (We do not give the proof of this generalization, in light of Borgstro¨m’s alternative proof of Proposition 5.)

43

B Proofs of Lemmas 10 and 11

Deﬁnition 11 The set P(M) of paths of a term M is deﬁned inductively by:

P(u) = P(f (M1, . . . , Mn)) =

n
∪ i · P(Mi)
i=1

for i ≤ n

The subterm of M at position p ∈ P(M), written M|p, is deﬁned inductively by:

M| =M f (M1, . . . , Mn)|i·p = Mi|p for i ≤ n

Lemma 10. Let E be a locally stable theory. Let φ = νn.σ and ψ = νn .σ be two frames such that ψ |= Eq(φ). For all contexts C1 and C2 such that (fn(C1) ∪ fn(C2)) ∩ n = ∅, for all terms Mi, Mi ∈ sat(φ), if C1[M1, . . . , Mk] =AC C2[M1, . . . , Ml ], then (C1[ζM1, . . . , ζMk ] =E C2[ζM1, . . . , ζMl ])ψ.
This lemma is proved by induction on the sum of the sizes of C1 and C2.

Base case: If |C1|, |C2| ≤ cE, then the equation

(C1[ζM1, . . . , ζMk] = C2[ζM1, . . . , ζMl ])

is in Eq(φ) since |C1| ≤ cE and |C2| ≤ cE ≤ c2E, so ψ |= Eq(φ) implies

(C1[ζM1, . . . , ζMk] =E C2[ζM1, . . . , ζMl ])ψ. Inductive step: If neither C1 nor C2 is a hole,

then

C1

==

f (C11, . . . , C1r)

and

C2 == f (C21, . . . , C2r). There are two cases.

• f is not an AC symbol. Then, for every 1 ≤ i ≤ r, C1i[M1, . . . , Mk] =AC

C2i[M1, . . . , Ml ]. By applying the induction hypothesis, we obtain

(C1i[ζM1, . . . , ζMk ] =E C2i[ζM1, . . . , ζMl ])ψ

so
(C1[ζM1, . . . , ζMk ] =E C2[ζM1, . . . , ζMl ])ψ • f is an AC symbol ⊕. We write C1 = C11 ⊕ · · · ⊕ C1r ⊕ x1 ⊕ · · · ⊕ xp and C2 =
C21 ⊕· · ·⊕C2r ⊕y1 ⊕· · ·⊕yp in such a way that the head symbol of the contexts C1i and C2j is not ⊕, C1i and C2j are not holes, and the variables xi and yj refer to the holes of C1 and C2. If the equation can be split, with C1 =AC C1 ⊕ C1 and C2 =AC C2 ⊕ C2 such that (C1[ζM1, . . . , ζMk] =E C2[ζM1, . . . , ζMl ])φ and (C1 [ζM1, . . . , ζMk] =E C2 [ζM1, . . . , ζMl ])φ, then we conclude as above, applying the induction hypothesis. On the other hand, if the equation cannot be split, for every 1 ≤ i ≤ r, Ni =def C1i[M1, . . . , Mk] is not equal to some

44

C2j[M1, . . . , Ml ] so it must be a subterm of some Mj. Since each Mj is in

sat(φ) and by applying recursively rule 2 of Deﬁnition 6, we get that Ni is in

sat(φ), every 1

thus ≤j

there ≤ r,

Nexj is=detfsCζ1Nj [iM∈1

ρ(φ) ,...,

such Mk ]

that ζNiσ =E is not equal to

Ni. Symmetrically, for some C1i[M1, . . . , Ml],

so Nj ∈ sat(φ) and there exists ζNj ∈ ρ(φ) such that ζNj σ =E Nj. · From Ni == C1i[M1, . . . , Mk] and applying the induction hypothesis, we get ζNiσ =E C1i[ζM1, . . . , ζMk]σ and similarly we obtain ζNj σ =E C2j[ζM1, . . . , ζMk]σ . · Renaming C1i[M1, . . . , Mk] by Ni in our initial equation, we get N1 ⊕

· · · ⊕ Nr ⊕ M1 ⊕ · · · ⊕ Mp = N1 ⊕ · · · ⊕ Nr ⊕ M1 ⊕ · · · ⊕ Mp . Applying

the base case, we get (ζN1 ⊕ · · · ⊕ ζNr ⊕ ζM1 ⊕ · · · ⊕ ζMp =E ζN1 ⊕ · · · ⊕ ζNr ⊕ ζM1 ⊕ · · · ⊕ ζMp )σ. Since this equation is in Eq(φ), we deduce

(ζN1 ⊕· · ·⊕ζNr ⊕ζM1 ⊕· · ·⊕ζMp =E ζN1 ⊕· · ·⊕ζNr ⊕ζM1 ⊕· · ·⊕ζMp )σ .

Combining these equations, we get

(C1[ζM1, . . . , ζMk ] =E C2[ζM1, . . . , ζMl ])ψ
If C1 or C2 is a hole, then let us say C1 == f (C11, . . . , C1r) and C2 == . Let M, M1, . . . , Mk ∈ sat(φ) and assume C1[M1, . . . , Mk] =AC M . Again we consider two cases. • f is not an AC symbol. Then we have

f (C11[M1, . . . , Mk], . . . , C1r[M1, . . . , Mk]) =AC M
For every 1 ≤ i ≤ r, let Ni =def C1i[M1, . . . , Mk]. Thus, each Ni is a subterm of M, so it is in st(sat(φ)). Since each Mj is in sat(φ) and by applying repeatedly rule 2 of Deﬁnition 6, we get that Ni is in sat(φ). Thus there exists ζNi ∈ ρ(φ) such that ζNiσ =E Ni.
· From Ni == C1i[M1, . . . , Mk] and applying the induction hypothesis, we get ζNiσ =E C1i[ζM1, . . . , ζMk ]σ .
· From M =AC f (N1, . . . , Nr) and applying the base case, we get ζM σ =E f (ζN1, . . . , ζNr )σ .
Combining these equations, we get
(ζM =E C1[ζM1, . . . , ζMk])ψ
• f is an AC symbol ⊕. We write C1 = C11 ⊕· · ·⊕C1r ⊕x1 ⊕· · ·⊕xp and C2 = x, and we have C11[M1, . . . , Mk]⊕. . .⊕C1r[M1, . . . , Mk]⊕M1 ⊕. . .⊕Mp =AC M . Each Ni =def C1i[M1, . . . , Mk] is a subterm of M ∈ sat(φ) thus is in sat(φ). Again, there exists ζNi ∈ ρ(φ) such that ζNiσ =E Ni. · From Ni == C1i[M1, . . . , Mk] and applying the induction hypothesis, we get ζNiσ =E C1i[ζM1, . . . , ζMk ]σ . · From N1 ⊕ . . . ⊕ Nr ⊕ M1 ⊕ . . . ⊕ Mp =AC M and by the equation ζN1 ⊕ · · · ⊕ ζNr ⊕ ζM1 ⊕ · · · ⊕ ζMp =E ζM is in Eq(φ), we get (ζN1 ⊕ · · · ⊕ ζNr ⊕ ζM1 ⊕ · · · ⊕ ζMp =E ζM )σ .

45

Combining these equations, we get

(C1[ζM1, . . . , ζMk] =E ζM )ψ
Lemma 11. Let E be a locally stable theory. Let φ = νn.σ be a frame. For every context C1 such that fn(C1) ∩ n = ∅, for every Mi ∈ sat(φ), for every term T such that C1[M1, . . . , Mk] →AC T , there exist a context C2 such that fn(C2) ∩ n = ∅, and terms Mi ∈ sat(φ), such that T →∗AC C2[M1, . . . , Ml ] and for every frame ψ |= Eq(φ), (C1[ζM1, . . . , ζMk] =E C2[ζM1, . . . , ζMl ])ψ.
An easy case is when the reduction occurs inside one of the terms Mi: Mi →AC Mi . By deﬁnition of sat(φ) (since E is locally stable), we know that there exists C such that |C| ≤ c2E, fn(C) ∩ n = ∅, and Mi →∗AC C[M1 , . . . , Ml ] where Mi ∈ sat(φ). In addition, the equation ζMi = C[ζM1 , . . . , ζMl ] is in Eq(φ) (since |C| ≤ c2E), thus (ζMi =E C[ζM1 , . . . , ζMl ])ψ. We obtain that

T == C1[M1, . . . , Mi−1, Mi , Mi+1, . . . , Mk] →∗AC C1[M1, . . . , C[M1 , . . . , Ml ], . . . , Mk]

and ⎛

⎞

⎜⎜⎜⎜⎜⎝

(C1

[ζM1 , =E

.

.

.

,

ζMk

]

⎟⎟⎟⎟⎟⎠ ψ

C1[ζM1, . . . , C[ζM1 , . . . , ζMl ], . . . , ζMk]

We now consider the case where the reduction does not occur inside the terms Mi. We can assume that

for every path p of C1, if C1|p[M1, . . . , Mk] is in sat(φ), then C1|p is the single hole context.

(*)

Indeed, if there exists a path p of C1 such that T1 =def C1|p[M1, . . . , Mk] ∈ sat(φ) and
C1|p is not a hole then C1[M1, . . . , Mk] == C1[T1, M1, . . . , Mk] where T1, Mi ∈ sat(φ) and C1 is a context strictly smaller than C1. In that case, we consider C1[T1, M1, . . . , Mk] instead of C1[M1, . . . , Mk] and we apply the transformation again
until property (*) holds.

We have
r
C1[M1, . . . , Mk] == C3[M ⊕ M ⊕ Ci[M1, . . . , Mk], M1, . . . , Mk]
i=1
where M = M1 ⊕ . . . ⊕ Ml , M = M1 ⊕ . . . ⊕ Ml with Mi ⊕ Mi ∈ sat(φ), the head symbol of the context Ci is not ⊕, Ci is not a single hole, and T1 =def

46

M⊕

r i=1

Ci[M1,

.

.

.

,

Mk ]

is

an

instance

M0θ

(modulo

AC)

of

the

left-hand

side

of some rule M0 → N0 of the rewriting system associated with E.

For each variable x of M0, we consider the occurrences of xθ in T1.

(1) Either xθ occurs as a subterm of one of the terms Mi or Mi ; (2) or there exists a subterm of T1 of the form N1 ⊕ . . . ⊕ Np with Ni =AC Ni ⊕
Ni ∈ sat(φ) for some Ni such that xθ =AC N1 ⊕ . . . ⊕ Np; (3) or there exists a subterm of T1 of the form

r
N1 ⊕ . . . ⊕ Np ⊕ Ci [M1, . . . , Mk]
i=1

(modulo AC) where the head symbols of the contexts Ci are not ⊕ and the contexts Ci are not a hole, and

r
xθ =AC N1 ⊕ . . . ⊕ Np ⊕ Ci [M1, . . . , Mk]
i=1

with Ni =AC Ni ⊕ Ni ∈ sat(φ) for some Ni , thus the terms Ni are subterms of terms of sat(φ).

Note that case 3 cannot occur simultaneously with case 1 or case 2 for the same variable x. If case 3 were to occur simultaneously with case 1 or case 2, we would have that some Ci [M1, . . . , Mk] is a subterm of some Mi or Mi , thus applying recursively rule 2 of Deﬁnition 6, we would get that Ci [M1, . . . , Mk] ∈ sat(φ), which contradicts property (*) (since Ci is not a hole).
Without loss of generality, we assume that the variables of M0 are x1, . . . , xk1, y1, . . . , yk2 where the variables xi are in case 1 or case 2 and the variables yj are in case 3. For each variable yj, we consider the l occurrences of yj in T1.

yjθ =AC N11 ⊕ . . . ⊕ Nk11 ⊕

r1 i=1

Ci1

[M1,

.

.

.

,

Mk

]

...

=AC N1l ⊕ . . . ⊕ Nkll ⊕

rl i=1

Cil[M1,

.

.

.

,

Mk]

where the terms Nij are subterms of terms in sat(φ) and the head symbols of the contexts Cij are not ⊕. We write cl (Cij[M1, . . . , Mk]) for the class of Cij[M1, . . . , Mk] modulo AC, and we associate a fresh name symbol acl(Cij[M1,...,Mk]) with each cl (Cij[M1, . . . , Mk]). Therefore, acl(Cij11 [M1,...,Mk]) and acl(Cij22 [M1,...,Mk]) are the same symbol whenever

47

C j1 i1

[M1

,

.

.

.

,

Mk ]

=AC

C j2 i2

[M1,

.

.

.

,

Mk].

In

each

equation

rj1

N1j1

⊕

...

⊕

N j1 kj1

⊕

Cij1[M1, . . . , Mk]

i=1

rj2

=AC

N1j2

⊕

.

.

.

⊕

N j2 kj2

⊕

i=1

Cij2 [M1 ,

..

.,

Mk ]

every

Cij1[M1, . . . , Mk]

must

be

equal

modulo

AC

to

one

of

the

terms

C

j2 i

[M1

,

. . . , Mk]. If Cij1[M1, . . . , Mk] were equal to some subterm of the terms Nij2, then

Cij1[M1, . . . , Mk] would be a term of sat(φ), contradicting property (*). Thus, we

obtain that

N11 ⊕ . . . ⊕ Nk11 ⊕ ...

ar1
i=1

Ci1 [M1 ,...,Mk ]

=AC N1l ⊕ . . . ⊕ Nkll ⊕

a = Trl
i=1

def
Cil[M1,...,Mk]

yj

We consider the substitution θ such that xiθ = xiθ and yjθ = Tyj . We deﬁne θ (acl(Cij[M1,...,Mk])) = Cij[M1, . . . , Mk].

We also consider the term T2 that is obtained from

r i=1

Ci

[M1

,

.

.

.

,

Mk

]

by

replac-

ing each Cij[M1, . . . , Mk] with a .cl(Cij[M1,...,Mk])

We have T2 == C2[S1, . . . , Sk] for some context C2 such that | ⊕C2| ≤ |M0| ≤ cE
and Si ∈ sum⊕(sat(φ), n). Since M ⊕ T2 is an instance M0θ of M0 we have
M ⊕ M ⊕ T2 →AC M ⊕ N0θ . Applying condition 3 of Deﬁnition 6, there exist Si ∈ sum⊕(sat(φ), n), there exists a context C , such that |C | ≤ c2E, fn(C ) ∩ n = ∅, and M ⊕N0θ →∗AC C [S1, . . . , Sl]. Applying the substitution θ , we deduce that M ⊕ N0θ =AC M ⊕ N0θ θ →∗AC C [S1, . . . , Sl]θ . Note that C [S1, . . . , Sl]θ is a context of terms of sat(φ):

C [S1, . . . , Sl]θ = C [M1, . . . , Mk, S1, . . . , Sl]

To each sum S = α1M1 ⊕ · · · ⊕ αnMn ⊕ β1n1 ⊕ · · · ⊕ βknk in sum⊕(sat(φ), n), we associate the term ζS = α1 ·⊕ ζM1 ⊕ · · · ⊕ αn ·⊕ ζMn ⊕ β1 ·⊕ n1 ⊕ · · · ⊕ βk ·⊕ nk.

Now, since the equation ζM ⊕M ⊕ C2[ζS1, . . . , ζSk] = C [ζS1, . . . , ζSl] is in Eq(φ), we deduce
(ζM ⊕M ⊕ C2[ζS1, . . . , ζSk] = C [ζS1, . . . , ζSl ])ψ If acl(Cij11 [M1,...,Mk]) = a ,cl(Cij22 [M1,...,Mk]) we have

C j1 i1

[M1

,

.

.

.

,

Mk ]

=AC

C j2 i2

[M1

,

.

.

.

,

Mk]

48

thus (by Lemma 10) we have

(Cij11[ζM1 ,

.

.

.

,

ζMk ]

=

C j2 i2

[ζM1

,

.

.

.

,

ζMk ])ψ

So we can reconstruct M ⊕ T1 and obtain
r
ζM ⊕M ⊕ Ci[ζM1, . . . , ζMk] = C [ζM1, . . . , ζMk, ζS1, . . . , ζSl ])ψ i=1

which allows us to conclude the proof of Lemma 11.

49

