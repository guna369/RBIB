Universidade de Bras´ılia
Instituto de Cieˆncias Exatas
Departamento de Matema´tica
Comparando Ca´lculos de Substituic¸o˜es
Expl´ıcitas com Eta-conversa˜o
por
Fla´vio Leonardo Cavalcanti de Moura
Bras´ılia, 05 de abril de 2002
Aos meus pais,
Jose´ Leonardo de Moura e Petru´cia de Holanda Cavalcanti .
Agradecimentos
Este trabalho se tornou poss´ıvel devido ao apoio de Deus e de diversas pessoas
dentre as quais gostaria de destacar:
O professor Mauricio Ayala Rinco´n pela pacieˆncia, est´ımulo, incentivo, amizade
e, principalmente, por ter me iniciado no campo da pesquisa. Todo este aprendizado
sera´ de fundamental importaˆncia para futura conduta profissional.
O professor Nora´ı Romeu Rocco pelo apoio e incentivo vitais no in´ıcio do pro-
grama de mestrado.
A` meus pais pelo apoio sempre incondicional e pelos ensinamentos de vida.
A`s minhas irma˜s Ana Cla´udia e Renata pelos diversos momentos de alegria.
Aos colegas, professores e funciona´rios do Departamento de Matema´tica da UnB.
A` CAPES pelo suporte financeiro e a` todos que de uma forma ou de outra
contribuiram durante a realizac¸a˜o desta dissertac¸a˜o.
Resumo
O λ-ca´lculo e´ uma importante ferramenta teo´rica no campo da computac¸a˜o, essencial
para o desenvolvimento de noc¸o˜es como computabilidade assim como para a imple-
mentac¸a˜o de linguagens de programac¸a˜o funcional tipadas e assistentes de prova.
A noc¸a˜o de substituic¸a˜o utilizada para a definic¸a˜o da β-conversa˜o e´ uma meta-
operac¸a˜o que na˜o esta´ formalmente definida no λ-ca´lculo. Por esta raza˜o, apesar
de termos uma notac¸a˜o concisa para algoritmos, na˜o estamos aptos para analisar
complexidade de tempo ou espac¸o dos mesmos. Na intenc¸a˜o de resolver esse pro-
blema foram criadas algumas variac¸o˜es do λ-ca´lculo, que manipulam a operac¸a˜o de
substituic¸a˜o explicitamente, como, por exemplo, λσ, λse, λu, etc. Neste trabalho
estamos interessados em comparar treˆs desses ca´lculos: o λσ, o λse e o Ca´lculo de
Suspensa˜o, que aqui denotaremos por λSusp. Inicialmente introduzimos uma regra
Eta para o λSusp e mostramos que o ca´lculo de substituic¸o˜es expl´ıcitas obtido ao
se incluir esta nova regra e´ convergente. Depois mostramos que o λSusp e o λσ sa˜o
incompara´veis entre si e, que o λse e´ mais adequado que o λSusp. Utilizamos a lin-
guagem de programac¸a˜o funcional Ocaml, para implementarmos um ambiente que
simula os sistemas de reescrita dos ca´lculos λσ, λse e λSusp.
Abstract
The λ-calculus is an important theoretical tool in the field of computation that has
been essencial for the development of fundamental notions as the one of computa-
bility as well as for the implementation of functional typed programming languages
and proof assistants. The basic notion of substituition used for the definition of
β-conversion is a meta-operation that is not formally defined in the λ-calculus. For
this reason, although we have a concise notation for algorithms, we are not able to
analyse their time or space complexity. Trying to solve this question some varia-
tions of the λ-calculus, that explicity manipulate the operation of substitution, were
created like λσ, λse, λu, etc. In this work we are concerned to relate three of these
calculi, named λσ, λse and the Suspension Calculus, that we call λSusp. First of all
we introduce an Eta rule for the λSusp and we prove that the new rewriting system
obtained by the inclusion of this new rule is convergent. After this we show that
λSusp and λσ are incomparable and that λse is more adequate than λSusp. Finally,
using the Ocaml functional programming language we construct an implementation
that simulate the rewriting system of the calculi λσ, λse and λSusp.
Introduc¸a˜o
O λ-ca´lculo surgiu no in´ıcio do se´culo XX com os trabalhos de Alonzo Church
[Chu32] e [Chu33]. Esses estudos faziam parte de teorias mais gerais de func¸o˜es e
lo´gica de ordem superior, cujo intuito era servir como fundamento para a Matema´tica.
Quando Kleene & Rosser [KR35] mostraram a inconsisteˆncia dessas teorias, Church
abandonou o programa de fundamentos e extraiu a subteoria referente a` parte fun-
cional que hoje corresponde ao que chamamos de λ-ca´lculo, cuja consisteˆncia foi
mostrada por [CR36].
Conhecido como o primeiro sistema de reescrita no contexto computacional, o λ-
ca´lculo e´ uma teoria que modela func¸o˜es computa´veis, com uma notac¸a˜o compacta
para algoritmos, mas que no entanto, na˜o nos fornece meios para estimar impor-
tantes noc¸o˜es da computac¸a˜o como, por exemplo, complexidade de tempo ou espac¸o
para estes algoritmos. As operac¸o˜es ba´sicas do λ-ca´lculo sa˜o a β-conversa˜o e a η-
conversa˜o, sendo a primeira um mecanismo ba´sico para aplicar func¸o˜es abstratas a
argumentos e, a segunda uma simples abstrac¸a˜o para a equivaleˆncia funcional. Ale´m
disso, uma terceira operac¸a˜o, denominada a α-conversa˜o, permite mudar nomes de
varia´veis.
A operac¸a˜o de substituic¸a˜o utilizada para definir a β-conversa˜o do λ-ca´lculo e´
uma operac¸a˜o impl´ıcita que na˜o esta´ definida formalmente. Muito trabalho tem
sido desenvolvido desde enta˜o no intuito de tentar controlar melhor essa operac¸a˜o
como, por exemplo, [CF58] e [Cur86]. O trabalho de Curien [Cur86] constituiu a
base para o trabalho de Abadi et al. [ACCL91] onde foi apresentado o primeiro
ca´lculo de substituic¸o˜es expl´ıcitas, chamado de λσ. Os ca´lculos de substituic¸o˜es
expl´ıcitas constituem uma variac¸a˜o do λ-ca´lculo onde se tenta controlar explicita-
mente a operac¸a˜o de substituic¸a˜o. Aqui estudaremos treˆs desses ca´lculos: o λσ, o
λse [KR97] e o Ca´lculo de Suspensa˜o [NW98], que aqui denotaremos por λSusp. O
λSusp foi desenvolvido por Nadathur e Wilson quando eles estavam interessados em
utilizar λ-termos como dispositivos computacionais em questo˜es pertinentes a` im-
vi
plementac¸a˜o do λProlog [NM88], uma linguagem de programac¸a˜o lo´gica que utiliza
λ-termos como estrutura de dados.
Nosso objetivo e´ comparar o λSusp com os ca´lculos λσ e λse. Compararemos no
estilo de [KR00], onde Kamareddine e R´ıos mostraram, entre outras coisas, que os
ca´lculos λσ e λs (uma versa˜o restrita do λse para termos sem meta-varia´veis) sa˜o
incompara´veis.
O λSusp foi apresentado sem a regra Eta
†. Aqui introduziremos uma regra Eta
que preserva a terminalidade e a conflueˆncia da parte de substituic¸a˜o deste ca´lculo.
Posteriormente mostraremos a correspondeˆncia entre as regras Eta desses ca´lculos.
Outra parte interessante deste trabalho consiste de uma implementac¸a˜o desen-
volvida com o intuito de simular as derivac¸o˜es de um termo no λSusp, no λse ou no
λσ. A linguagem utilizada para esta implementac¸a˜o foi o Ocaml, da famı´lia ML, e
que utiliza tipagem impl´ıcita. Aqui apresentaremos os primeiros resultados obtidos
com essa implementac¸a˜o, em particular, mostraremos que a implemetac¸a˜o da regra
Eta para cada um dos ca´lculos aqui tratados e´ correta.
A presente dissertac¸a˜o esta´ dividida em quatro cap´ıtulos de acordo com a seguinte
ordem:
O primeiro cap´ıtulo conte´m os resultados e noc¸o˜es importantes sobre teoria de re-
escrita e λ-ca´lculo. Um cuidado especial e´ dado para a sec¸a˜o que trata da notac¸a˜o de
De Bruijn haja vista que esta notac¸a˜o e´ utilizada pelos ca´lculos tratados. Na notac¸a˜o
de De Bruijn, varia´veis sa˜o substitu´ıdas por ı´ndices representados por nu´meros na-
turais. Esses ı´ndices representam o nu´mero de abstratores que envolvem aquela
varia´vel. Uma consequeˆncia imediata e´ que termos em notac¸a˜o de De Bruijn sa˜o
insens´ıveis a α-conversa˜o. Por esse motivo podemos citar aqui, fora as vantagens
computacionais o´bvias dessa indexac¸a˜o, pelo menos duas grandes vantagens em se
utilizar essa notac¸a˜o. A primeira diz respeito ao fato de que a equivaleˆncia entre
λ-termos, mo´dulo renomeamento de varia´veis, e´ imediata enquanto que na notac¸a˜o
convencional estabelecer a dita equivaleˆncia, em geral, tem um alto custo computa-
cional. A segunda vantagem esta´ no fato de que na˜o precisamos nos preocupar com
captura de varia´veis livres apo´s β-converso˜es.
O segundo cap´ıtulo versa sobre substituic¸o˜es expl´ıcitas. Apresentaremos os
ca´lculos de substituic¸o˜es expl´ıcitas com os quais trabalharemos assim como suas
propriedades. Ainda no cap´ıtulo 2 introduziremos a regra Eta para o λSusp e
mostraremos a terminalidade e conflueˆncia da parte de substituic¸a˜o deste ca´lculo
†Restringiremos o uso do nome η ao λ-ca´lculo puro
com a Eta-conversa˜o. Em seguida estabeleceremos a equivaleˆncia entre as regras
Eta dos ca´lculos aqui tratados.
No terceiro cap´ıtulo utilizaremos a noc¸a˜o de adequabilidade de [KR00] para
compararmos o λSusp, λσ e λse. Esta comparac¸a˜o e´ importante para que possamos
ter uma boa ide´ia do comportamento de cada um desses ca´lculos verificando suas
vantagens e desvantagens.
Por fim, o quarto cap´ıtulo se refere a uma implementac¸a˜o para as regras dos
sistemas de reescrita dos ca´lculos aqui estudados. Vale salientar que implementamos
a regra Eta para cada um dos ca´lculos aqui tratados. Apresentamos um pouco da
estrutura da implementac¸a˜o de forma que se possa observar as vantagens de se
trabalhar com λ-termos no ambiente da linguagem Ocaml. Ale´m disso, veremos a
corretude das regras Eta aqui implementadas.
I´ndice
Introduc¸a˜o vi
1 Sistemas de Reescrita e o λ-Ca´lculo 1
1.1 Sistemas de Reescrita . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 O λ-Ca´lculo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.3 O λ-Ca´lculo em Notac¸a˜o de De Bruijn . . . . . . . . . . . . . . . . . 8
2 Substituic¸o˜es Expl´ıcitas 11
2.1 Alguns Ca´lculos de Substituic¸o˜es Expl´ıcitas . . . . . . . . . . . . . . 12
2.1.1 O Ca´lculo λσ . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.1.2 O Ca´lculo λse . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
2.1.3 O Ca´lculo λSusp . . . . . . . . . . . . . . . . . . . . . . . . . . 16
2.2 Adic¸a˜o da regra Eta para o Ca´lculo λSusp . . . . . . . . . . . . . . . . 22
2.3 A Correspondeˆncia entre as Regras Eta . . . . . . . . . . . . . . . . . 32
3 Adequabilidade 34
3.1 Noc¸o˜es de Adequabilidade para Comparac¸a˜o de Ca´lculos de Substi-
tuic¸o˜es Expl´ıcitas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.2 Incomparabilidade entre Ca´lculos de Substituic¸o˜es Expl´ıcitas . . . . . 35
3.2.1 Os Ca´lculos λσ e λse sa˜o Incompara´veis . . . . . . . . . . . . 35
3.2.2 Os Ca´lculos λSusp e λσ sa˜o Incompara´veis. . . . . . . . . . . . 37
3.3 O Ca´lculo λse e´ mais adequado do que o λSusp. . . . . . . . . . . . . 39
4 Uma Implementac¸a˜o para os Ca´lculos λσ, λse e λSusp com a Eta-
conversa˜o 46
4.1 A implementac¸a˜o da regra Eta . . . . . . . . . . . . . . . . . . . . . 51
Conclusa˜o 62
Bibliografia 64
ix
Cap´ıtulo 1
Sistemas de Reescrita e o
λ-Ca´lculo
1.1 Sistemas de Reescrita
Iniciaremos este trabalho fazendo uma breve introduc¸a˜o aos sitemas de reescrita
com eˆnfase especial para o λ-ca´lculo a t´ıtulo de motivac¸a˜o. Iniciaremos com as
definic¸o˜es ba´sicas de sistemas de reescrita que podem ser encontradas com mais
detalhes em [AR00] e [BN98].
Definic¸a˜o 1.1 O nu´mero de argumentos de um s´ımbolo de func¸a˜o e´ denominado a
“aridade” da func¸a˜o. Um s´ımbolo de func¸a˜o de aridade n e´ denominado um s´ımbolo
n-a´rio.
Definic¸a˜o 1.2 Um termo e´ definido indutivamente por:
• Uma varia´vel e´ um termo;
• Uma constante e´ um termo;
• Se f e´ um s´ımbolo de func¸a˜o de aridade n e, t1, . . . , tn sa˜o termos enta˜o
f(t1, . . . , tn) e´ um termo.
Definic¸a˜o 1.3 Uma substituic¸a˜o θ e´ um conjunto finito da forma {t1/v1, . . . , tn/vn},
onde cada vi e´ uma varia´vel distinta e cada ti e´ um termo distinto de vi.
Observac¸a˜o. Utilizaremos = para denotar a igualdade semaˆntica e ≡ para denotar
a igualdade sinta´tica.
1
2Definic¸a˜o 1.4 Sejam θ = {t1/v1, . . . , tn/vn} uma substituic¸a˜o e E um expressa˜o.
Enta˜o Eθ, a instaˆncia de E por θ, e´ a expressa˜o obtida de E substituindo si-
multaneamente cada ocorreˆncia das varia´veis vi respectivamente por ti, para i =
1, 2, . . . , n.
Definic¸a˜o 1.5 Seja S um conjunto finito de expresso˜es. Uma substituic¸a˜o θ e´ de-
nominada um unificador de S se Sθ e´ um conjunto unita´rio.
Definic¸a˜o 1.6 Um unificador θ para um conjunto finito S de expresso˜es e´ deno-
minado um unificador mais geral de S, denotado por mgu(S), se para todo
unificador σ de S, existe uma substituic¸a˜o γ tal que σ = θγ.
Definic¸a˜o 1.7 (Posic¸o˜es Va´lidas) O conjunto O(t) das posic¸o˜es va´lidas de um
termo t e´ definido indutivamente por:
(1) Se t e´ uma constante ou varia´vel enta˜o O(t) = λ, onde λ denota a sequeˆncia
vazia.
(2) Se t e´ um termo da forma f(t1, . . . , tn) enta˜o O(t) = {i.pi | 1 ≤ i ≤ n e
pi ∈ O(ti)} ∪ {λ} e t |i.pi≡ ti |pi, onde t |i denota o subtermo de t que se
encontra na posic¸a˜o i.
Definic¸a˜o 1.8 (Sistema de Reescrita) Seja M um conjunto e → uma relac¸a˜o
bina´ria sobre M . Um sistema de reescrita e´ um par (M, → ) onde → e´ denomi-
nada a relac¸a˜o de reduc¸a˜o ou relac¸a˜o de reescrita correspondente ao sistema.
Notac¸a˜o. Seja R = (M, → ) um sistema de reescrita. Denotamos por:
• ← a relac¸a˜o inversa de → , de forma que u← v se e somente se v→ u;
• ↔= →∪ ←, de forma que u↔ v se e somente se u→ v ou u← v;
• →n a relac¸a˜o que e´ definida indutivamente por
u→0v se e somente se u ≡ v e,
u→n+1v se e somente se ∃w, u→nw→ v;
3Intuitivamente →n pode ser vista como a aplicac¸a˜o de n passos da relac¸a˜o
→ . Neste caso dizemos que temos uma derivac¸a˜o de comprimento n. Uma
derivac¸a˜o de um u´nico passo e´ denominada uma reduc¸a˜o.
A mesma relac¸a˜o indutiva tambe´m pode ser extendida, de maneira o´bvia, para
←n e ↔n. Por elegaˆncia na notac¸a˜o, ←n e´ substitu´ıdo por n←.
• →∗ o fecho reflexivo transitivo da relac¸a˜o → ;
• ↔∗ o fecho reflexivo sime´trico transitivo da relac¸a˜o → . Ou seja,↔∗ e´ a menor
relac¸a˜o de equivaleˆncia que conte´m a relac¸a˜o → .
Notac¸a˜o. Para o sistema de reescritaR = (M, → ), essa relac¸a˜o de equivaleˆncia
sera´ denotada por =R.
Definic¸a˜o 1.9 Uma relac¸a˜o bina´ria e´ uma ordem parcial se for anti-reflexiva e
transitiva.
Definic¸a˜o 1.10 Uma ordem parcial e´ dita bem-fundada (do ingleˆs, well-founded)
quando na˜o gera cadeias de reduc¸a˜o infinitas.
Definic¸a˜o 1.11 Seja R = (M, → ) um sistema de reescrita. Um elemento u ∈
M e´ denominado irredut´ıvel se na˜o existe nenhum v ∈ M tal que u→ v; caso
contra´rio u e´ dito redut´ıvel. Se u→∗v e v e´ irredut´ıvel, enta˜o v e´ denominado
uma forma normal de u, que denotaremos por R-norm(u). Dois termos u e v sa˜o
ditos junta´veis se existe um w ∈M tal que u→∗ w ∗← v e, denotamos por u ↓ v.
Definic¸a˜o 1.12 Uma relac¸a˜o de reescrita → sobre um conjunto M e´ dita termi-
nante se na˜o existem cadeias infinitas de derivac¸a˜o u0→u1→ . . .. Um sistema de
reescrita associado com uma relac¸a˜o de reescrita terminante sera´ tambe´m denomi-
nado terminante.
Definic¸a˜o 1.13 Um sistema de reescrita e´ dito confluente se
(∗← ◦→∗) ⊆ (→∗ ◦ ∗←).
Isto significa que para todo u, v, w ∈M com v ∗← u→∗ w, existe algum r ∈M com
v→∗ r ∗← w.
4Definic¸a˜o 1.14 Um sistema de reescrita R = (M, → ) e´ localmente confluente
ou local confluente se e somente se (← ◦→ ) ⊆ (→∗ ◦ ∗←).
Definic¸a˜o 1.15 Um sistema de reescrita R = (M, → ) satisfaz a propriedade de
Church-Rosser (CR) se e somente se ↔∗ ⊆ (→∗ ◦ ∗←).
Observac¸a˜o. E´ bem conhecido que Conflueˆncia e a Propriedade de Church-Rosser
sa˜o equivalentes.
Notac¸a˜o. Por analogia, as situac¸o˜es v ∗← u→∗ w e v ← u→w sa˜o denominadas
divergeˆncia e divergeˆncia local, respectivamente.
Definic¸a˜o 1.16 Um sistema de reescrita R = (M, → ) e´ denominado convergente
se e´ terminante e confluente.
Lema 1.17 Seja R = (M, → ) um sistema de reescrita convergente. Enta˜o u↔∗ v
se e somente se R-norm(u) =R R-norm(v).
Lema 1.18 (do Diamante de Newman, 1942). Seja R = (M, → ) um sis-
tema de reescrita terminante. Enta˜o a relac¸a˜o → e´ confluente se e somente se e´
localmente confluente.
Definic¸a˜o 1.19 (Pares Cr´ıticos) Sejam l1→ r1 e l2→ r2 regras de um sistema de
reescrita R. Suponha que V ar(l1)∩V ar(l2) = ∅, onde V ar(t) denota o conjunto das
varia´veis que ocorrem no termo t. Seja pi ∈ O(l1), tal que o termo na posic¸a˜o pi de
l1, isto e´, l1 |pi, na˜o seja uma varia´vel, e σ = mgu(l1 |pi, l2). Enta˜o o par ordenado
de termos
〈r1σ, (l1[pi ← r2])σ〉
e´ um par cr´ıtico de R das regras l1→ r1 e l2→ r2. Denotamos por CP (R) o
conjunto dos pares cr´ıticos de R.
Pelo Lema do Diamante de Newman [New42], sob a hipo´tese de terminac¸a˜o,
conflueˆncia e conflueˆncia local sa˜o equivalentes. Esse resultado e´ de grande interesse
teo´rico, mas na pra´tica na˜o pode ser aplicado diretamente ja´ que testar conflueˆncia
local e´, em geral, um processo infinito. Para solucionar esse problema, enunciaremos
5o conhecido Lema dos Pares Cr´ıticos de Knuth-Bendix. Esse lema nos permitira´
concluir a conflueˆncia de um sistema de reescrita pela simples ana´lise dos seus pares
cr´ıticos.
Lema 1.20 (Pares Cr´ıticos de Knuth-Bendix, 1970) Seja R um sistema de
reescrita de termos. Se t1 ← t→ t2 enta˜o t1 ↓ t2 ou t1 ↔CP (R) t2, onde ↔CP (R) e´ o
fecho sime´trico da relac¸a˜o dada pelo conjunto de pares cr´ıticos de R.
1.2 O λ-Ca´lculo
O λ-ca´lculo surgiu no in´ıcio do se´culo XX com os trabalhos de Alonzo Church
[Chu32] e [Chu33]. Esses estudos faziam parte de teorias mais gerais de func¸o˜es
e lo´gica de ordem superior, cujo intuito era o de servir como fundamento para a
Matema´tica. Quando Kleene e Rosser [KR35] mostraram a inconsisteˆncia dessas
teorias, Church abandonou o programa de fundamentos e extraiu a subteoria refe-
rente a` parte funcional que hoje corresponde ao que chamamos de λ-ca´lculo, cuja
consisteˆncia foi mostrada por [CR36].
O λ-ca´lculo e´ o primeiro sistema de reescrita conhecido no contexto computa-
cional. E´ tambe´m um modelo conveniente para representar func¸o˜es computa´veis e,
ale´m disso possui uma notac¸a˜o compacta para algoritmos, sendo por esse motivo a
base do paradigma de programac¸a˜o funcional.
O λ-ca´lculo e´ uma teoria que modela func¸o˜es e seu comportamento aplicativo,
tendo, por isso, a aplicac¸a˜o como operac¸a˜o ba´sica. Dada uma func¸a˜o f e um ar-
gumento a denotamos o resultado da aplicac¸a˜o da func¸a˜o f ao argumento a por
f a.
O λ-ca´lculo possui uma outra operac¸a˜o ba´sica que, num certo sentido, corres-
ponde a` operac¸a˜o inversa da aplicac¸a˜o. Essa operac¸a˜o e´ chamada de abstrac¸a˜o. O
significado da abstrac¸a˜o pode ser compreendido da seguinte forma, se g(x) repre-
senta uma expressa˜o, possivelmente contendo a varia´vel x, enta˜o representamos por
λx.g(x) a func¸a˜o que associa a cada argumento a o valor g(a). Dado um abstrator
qualquer λx.M , dizemos que M e´ o corpo do abstrator. Em geral, o corpo de um
abstrator inicia apo´s o ponto ligado a esse abstrator e, quando necessa´rio, e´ delimi-
tado por pareˆnteses. Por exemplo, em (λx.(λy.M) N) o corpo do abstrator λy e´ M
enquanto que o corpo do abstrator λx e´ λy.M . Os pareˆnteses podem ser eliminados
quando a abrangeˆncia dos abstratores e´ evidente como em λx.M .
6Nesse ponto podemos definir varia´vel livre e varia´vel ligada:
Definic¸a˜o 1.21 O conjunto das varia´veis livres do termo M , denotado por V L(M),
e´ definido indutivamente por:
(i) VL(x) = {x}, para qualquer varia´vel x;
(ii) V L((M N)) = V L(M) ∪ V L(N);
(iii) V L(λx.M) = V L(M)\{x}.
As ocorreˆncias da varia´vel x na expressa˜o λx.M sa˜o ditas ligadas.
Por exemplo, na expressa˜o λx.2x + 1 dizemos que x e´ uma varia´vel ligada pois
ela ocorre no corpo do abstrator λx. Ja´ na expressa˜o λx.2x + y, dizemos que x e´
varia´vel ligada enquanto que y e´ uma varia´vel livre porque a mesma na˜o esta´ no
corpo de nenhum abstrator da forma λy. Note que uma varia´vel pode ocorrer tanto
livre quanto ligada em um mesmo termo. De fato, no termo a(λa.a) a primeira
ocorreˆncia da varia´vel a e´ livre enquanto que a segunda ocorreˆncia e´ ligada.
Em [Bar97], Barendregt explica o aparecimento do s´ımbolo λ para denotar a
abstrac¸a˜o de func¸a˜o: “Em Principia Mathematica [RW13], a notac¸a˜o para func¸a˜o
f com f(x) = 2x + 1 e´ 2x̂ + 1. Church originalmente pretendia utilizar a notac¸a˜o
x̂.2x + 1. No entanto, o tipo´grafo na˜o conseguiu posicionar o s´ımbolo ̂ em cima
da letra x, e o colocou em frente da mesma resultando em x̂.2x + 1. Depois outro
tipo´grafo mudou x̂.2x+ 1 para λx.2x+ 1”.
A seguir definimos formalmente os λ-termos:
Definic¸a˜o 1.22 O λ-ca´lculo opera sobre termos definidos pela seguinte sintaxe:
Termos M, N ::= a | λ.M | (M N) onde a e´ uma varia´vel.
Notac¸a˜o. (i) M N1 . . . Nk e´ o mesmo que (. . . ((M N1)N2) . . . Nk) e,
(ii) λx1 . . . xk.M significa (λx1.(λx2.(. . . (λxk.M) . . .)))
As substituic¸o˜es desempenham um papel fundamental no λ-ca´lculo. De fato, a
principal regra computacional desse formalismo, a β-conversa˜o, pode ser represen-
tada da seguinte maneira:
(β) ((λx.M) N)→M{N/x} (1.1)
De acordo com a definic¸a˜o 1.4, M{N/x} representa a substituic¸a˜o por N de
todas as ocorreˆncias da varia´vel x no termo M, no entanto, adaptada ao contexto
7do λ-ca´lculo, devemos substituir N apenas pelas ocorreˆncias livres da varia´vel x.
Note que na˜o queremos com essa substituic¸a˜o que alguma varia´vel livre venha a
se tornar ligada apo´s a substituic¸a˜o. Por exemplo, (λy.x){yy/x} 6= (λy.yy). As-
sim, sempre que necessa´rio podemos fazer um renomeamento de varia´veis de forma
que (λy.x){yy/x}→ β(λz.yy). Esse renomeamento e´ denominado α-conversa˜o na
linguagem do λ-ca´lculo. Fazer um renomeamento como descrito acima na˜o e´ uma
regra formal e, assim como a substituic¸a˜o {N/x}, ambas operac¸o˜es esta˜o fora da
linguagem do λ-ca´lculo, ou seja, estas operac¸o˜es sa˜o na verdade meta-operac¸o˜es.
Adicionalmente, o λ-ca´lculo possui uma outra regra chamada η-conversa˜o. In-
tuitivamente essa regra nos diz que abstrac¸o˜es que computam o mesmo valor para
o mesmo argumento sa˜o convert´ıveis. Formalmente a regra η e´ dada por:
(η) λx.(M x)→M , sempre que x 6∈ V L(M) (1.2)
Informalmente podemos dizer que a regra η esta´ intimamente ligada a` noc¸a˜o
de igualdade extendida de func¸o˜es que pode ser melhor compreendida atrave´s da
seguinte afirmac¸a˜o: “Se f(x) = g(x), para todo x, enta˜o f = g”. Agora se tentarmos
traduzir esta afirmac¸a˜o para a linguagem do λ-ca´lculo, obteremos exatamente a regra
η. De fato, de acordo com nossa hipo´tese precisamos tomar dois λ-termos f e g que
sejam “iguais” sempre que aplicados ao mesmo argumento, isto e´, f x =λ g x. Ate´
o presente momento a u´nica “igualdade” que temos e´ a obtida pela regra β (equac¸a˜o
1.1). Sendo assim, podemos escrever
(λa.M a) x→ β(M a){a/x} = M x
onde o segundo passo acima se justifica pelo fato de que x 6∈ V L(M).
Enta˜o temos que (λa.M a) x→M x, isto e´, (λa.M a)→M .
A estrutura do λ-ca´lculo pode ser associada a uma teoria de tipos e, nesse caso
temos o chamado λ-ca´lculo tipado. Nesse trabalho exploraremos apenas aspectos
do λ-ca´lculo na˜o tipado.
Essa diferenciac¸a˜o entre λ-ca´lculo simplesmente tipado e, λ-ca´lculo na˜o tipado
e´ importante porque suas propriedades sa˜o diferentes. De fato, apesar de ambos
serem confluentes, o λ-ca´lculo simplesmente tipado e´ terminante enquanto que o
λ-ca´lculo na˜o tipado e´ na˜o terminante. O contra-exemplo cla´ssico para mostrar a
na˜o terminalidade do λ-ca´lculo na˜o tipado consiste em considerar a β-reduc¸a˜o do
λ-termo ((λx.(x x)) (λx(x x))) ja´ que este se β-reduz a si mesmo.
81.3 O λ-Ca´lculo em Notac¸a˜o de De Bruijn
No ı´nicio dos anos 70, De Bruijn desenvolveu uma notac¸a˜o que elimina a neces-
sidade de se realizar qualquer tipo de α-conversa˜o, pois nessa notac¸a˜o varia´veis sa˜o
substituidas por ı´ndices [dB72]. Esses ı´ndices sa˜o nu´meros naturais que denotaremos
por n. Os ı´ndices de De Bruijn, a grosso modo, indicam o abstrator a que aquela
varia´vel esta´ ligada, ou melhor, o ı´ndice de De Bruijn n indica que n representa uma
varia´vel que esta´ dentro do corpo de n abstratores. Por exemplo, o termo λx.x e´
representado na notac¸a˜o de De Bruijn por λ1. Ja´ λx.λy.(x y) e´ representado por
λλ(2 1). As varia´veis livres tambe´m podem ser representadas na notac¸a˜o de De
Bruijn. Para isto precisamos estabelecer um referencial e, a contagem sobre esse
referencial se faz de maneira similar ao caso de varia´veis ligadas. Como exemplo
considere o termo (λx.(λy.(x z) x) (z λz.(x z))). Sua representac¸a˜o no referencial
x, y, z e´ (λ(λ(2 5) 1) (3 λ(2 1))).
Daqui em diante utilizaremos termos na notac¸a˜o de De Bruijn. E´ importante
salientar que as propriedades do λ-ca´lculo em notac¸a˜o de De Bruijn sa˜o ideˆnticas
a`s do λ-ca´lculo puro. Este e´ um dos motivos para o fato de que, neste trabalho, os
termos do λ-ca´lculo sejam representados nesta notac¸a˜o.
A notac¸a˜o de De Bruijn tem vantagens importantes, ale´m, e´ claro, das vantagens
computacionais o´bvias. De fato, existem pelo menos duas razo˜es importantes para
se utilizar a notac¸a˜o de De Bruijn. A primeira diz respeito quanto a dificuldade com-
putacional de se evitar a captura de varia´veis livres ao se realizar β-reduc¸o˜es. Essa
dificuldade pode ser controlada, de forma muito custosa em termos computacionais,
via α-converso˜es. A segunda raza˜o diz respeito a` dificuldade de se estabelecer a
equivaleˆncia entre λ-termos. Na pra´tica essa dificuldade tambe´m e´ resolvida via
α-conversa˜o. Como termos na notac¸a˜o de De Bruijn sa˜o insens´ıveis a α-conversa˜o,
essas dificuldades desaparecem ao se utilizar essa notac¸a˜o.
Podemos definir formalmente os termos na notac¸a˜o de De Bruijn da seguinte
maneira:
Definic¸a˜o 1.23 O conjunto ΛdB dos λ-termos na notac¸a˜o de De Bruijn e´ definido
indutivamente como se segue:
Termos M, N ::= n | λM | (M N)
9A pergunta que surge naturalmente agora e´: Como ficam as regras β e η para
termos na notac¸a˜o de De Bruijn? Para responder a essa pergunta precisaremos de
algumas definic¸o˜es para substituic¸a˜o e atualizac¸a˜o dos ı´ndices de De Bruijn.
Definic¸a˜o 1.24 ([ARM00]) Seja M ∈ ΛdB. Enta˜o a i-elevac¸a˜o do termo M ,
denotada por M+i, e´ definida indutivamente como segue:
1. (M N)+i = (M+i N+i)
2. (λM)+i = λM+(i+1)
3. n+i =
{
n + 1 se n > i
n se n ≤ i
A elevac¸a˜o de um termo M e´ a sua 0-elevac¸a˜o denotada por M+
Definic¸a˜o 1.25 ([ARM00]) A substituic¸a˜o pelo termo N no n´ıvel n− 1 do termo
M , denotada por M{N/n}, e´ definida indutivamente com segue:
1. (M1 M2){N/n} = (M1{N/n} M2{N/n})
2. (λM){N/n} = λM{N+/n + 1}
3. m{N/n} =
{
m− 1 se m > n
N se m = n
m se m ≤ n
Agora podemos definir as regras β e η na notac¸a˜o de De Bruijn.
Definic¸a˜o 1.26 ([ARM00]) As regras β e η sa˜o definidas para o conjunto dos
ΛdB-termos como segue:
(β) (λM N)→ βM{N/1}
(η) λ(M 1)→ ηN , se N+ = M
Para exemplificar a aplicac¸a˜o destas regras considere a seguinte β-conversa˜o
do λ-ca´lculo puro: ((λx.(λy.(x y))) z)→ β λy.(z y). A equivalente β-conversa˜o na
notac¸a˜o de De Bruijn e´ dada como mostraremos a seguir. Considerando o referencial
x, y, z o termo ((λx.(λy.(x y))) z) pode ser escrito como ((λ(λ(2 1))) 3). Aplicando
as regras dadas pelas definic¸o˜es anteriores temos:
10
((λ(λ(2 1))) 3)→
(λ(2 1)){3/1}→
λ(2 1){3+/2}→
λ(2 1){4/2}→
λ(2{4/2} 1{4/2})→
λ(4 1)
No cap´ıtulo seguinte estudaremos alguns ca´lculos que tentam simular, computa-
cionalmente falando, o λ-ca´lculo. Como veremos isto na˜o e´ uma tarefa fa´cil mas
que, por outro lado e´ muito interessante. As ide´ias que surgiram nessa a´rea criaram
um novo campo de trabalho em Teoria de Reescrita que chamamos de Substituic¸o˜es
Expl´ıcitas.
Cap´ıtulo 2
Substituic¸o˜es Expl´ıcitas
O λ-ca´lculo e´ um importante modelo teo´rico equivalente a`s Ma´quinas de Turing.
No entanto, a operac¸a˜o de substituic¸a˜o utilizada na definic¸a˜o da β-conversa˜o do
λ-ca´lculo, por se tratar de uma meta-operac¸a˜o, na˜o nos permite analisar noc¸o˜es
computacionais importantes como, por exemplo, complexidade de tempo ou espac¸o.
Como vimos anteriormente, isto acontece porque a operac¸a˜o de substituic¸a˜o na˜o
esta´ definida formalmente no λ-ca´lculo.
Para solucionar esse problema Abadi et al. desenvolveram em [ACCL91] uma
variac¸a˜o do λ-ca´lculo, chamado de λσ. No λσ substituic¸o˜es sa˜o manipuladas explici-
tamente, mas como veremos adiante esse ca´lculo ainda na˜o resolve completamente
esse problema pois na˜o satisfaz todas as propriedades necessa´rias.
De fato, um ca´lculo de substituic¸o˜es expl´ıcitas λξ adequado para os propo´sitos
de ser uma variac¸a˜o do λ-ca´lculo (que preserve suas principais caracter´ısticas) deve
possuir as seguintes propriedades:
1. Simulac¸a˜o da β-conversa˜o: Essa condic¸a˜o e´ essencial haja vista que o ob-
jetivo maior de um ca´lculo de substituic¸o˜es expl´ıcitas e´ simular o λ-ca´lculo.
Formalmente, considere A,B ∈ ΛdB tal que A→ βB. Uma simulac¸a˜o dessa β-
conversa˜o no ca´lculo λξ, e´ uma λξ-derivac¸a˜o da forma A→ rC→ ξξ-norm(C) =
B, onde r e´ a regra que inicia a simulac¸a˜o da β-conversa˜o, aplicando-a ao
mesmo redex que em A→ βB. Dizemos que o ca´lculo λξ simula um passo de
β-conversa˜o se qualquer β-conversa˜o A→ βB tem uma simulac¸a˜o no ca´lculo
λξ.
2. Terminac¸a˜o: Para um ca´lculo de substituic¸o˜es expl´ıcitas λξ, considere o
ca´lculo de substituic¸a˜o subjacente ξ, isto e´, considere o conjunto de regras
11
12
do sistema de reescrita de λξ retirando-se a regra Eta e a regra que inicia a
simulac¸a˜o da β-conversa˜o. A questa˜o e´ saber se o ca´lculo ξ e´ terminante.
3. Conflueˆncia (CR): A ana´lise da conflueˆncia de um ca´lculo de substituic¸o˜es
expl´ıcitas e´ subdividida em:
(a) Conflueˆncia em termos fechados, isto e´, termos sem a ocorreˆncia de
meta-varia´veis. As meta-varia´veis sa˜o varia´veis que pertencem a um contexto
mais amplo do λ-ca´lculo; elas podem, por exemplo, representar λ-termos em
um problema de unificac¸a˜o de ordem superior. Dessa forma, termos fechados
sa˜o termos cujas varia´veis pertencem exclusivamente ao conjunto ΛdB.
(b) Conflueˆncia em termos abertos, isto e´, termos com a ocorreˆncia de
meta-varia´veis.
4. Preservac¸a˜o da Terminac¸a˜o Forte (PSN): Seja A um termo tal que qual-
quer derivac¸a˜o a partir de A no λ-ca´lculo seja sempre finita. A questa˜o e´
saber se qualquer derivac¸a˜o a partir do termo A, via o ca´lculo de substituic¸o˜es
expl´ıcitas λξ, e´ tambe´m finita.
Posteriormente surgiram outros ca´lculos de substituic¸o˜es expl´ıcitas, como por
exemplo, o λσ⇑, λv, λs, λse, λt, λu e o λSusp. Neste trabalho nos restringiremos
a analisar treˆs desses ca´lculos: o λσ, λse [KR95b] e o λSusp [NW98]. Na pro´xima
sec¸a˜o apresentaremos esses ca´lculos e suas propriedades.
2.1 Alguns Ca´lculos de Substituic¸o˜es Expl´ıcitas
2.1.1 O Ca´lculo λσ
Originalmente proposto por [ACCL91], o ca´lculo λσ surge como uma variac¸a˜o
do λ-ca´lculo onde as substituic¸o˜es sa˜o manipuladas explicitamente. O λσ e´ um
sistema de reescrita cujas expresso˜es podem ser de um dos seguintes tipos: termos
ou substituic¸o˜es. Esses tipos podem ser assim definidos:
Termos M, N ::= 1 | X | λM | (M N) |M [S]
Substituic¸o˜es S, T ::= id |↑|M.S | S ◦ T
O sistema de reescrita do ca´lculo λσ e´ mostrado na figura 2.1. Nessa figura, a re-
gra (Beta) inicia a simulac¸a˜o de um passo de β-conversa˜o, a regra Etaσ corresponde
a` η-conversa˜o do λ-ca´lculo, enquanto que as outras regras sa˜o necessa´rias para a
13
(Beta) (λM N)→M [N.id]
(App) (M N)[S]→ (M [S] N [S])
(Abs) (λM)[S]→λM [1.(S◦ ↑)]
(Clos) M [S][T ]→M [S ◦ T ]
(VarCons) 1[M.S]→M
(Id) M [id]→M
(Assoc) (S1 ◦ S2) ◦ T →S1 ◦ (S2 ◦ T )
(Map) (M.S) ◦ T →M [T ].(S ◦ T )
(IdL) id ◦ S→S
(IdR) S ◦ id→S
(ShiftCons) ↑ ◦(M.S)→S
(VarShift) 1. ↑ → id
(SCons) 1[S].(↑ ◦S)→S
(Etaσ) λ(M 1)→N se M =σ N [↑]
Figura 2.1: As regras do ca´lculo λσ
manipulac¸a˜o dos termos do λσ. Sendo assim, como foi citado anteriormente deno-
taremos por λσ ao sistema de reescrita representado pelas regras dadas na figura
2.1, enquanto que σ denotara´ o mesmo sistema λσ retirando-se as regras (Beta) e
(Etaσ). Como podemos observar, esse ca´lculo utiliza apenas o ı´ndice de De Bruijn
1. Todos os outros ı´ndices sa˜o codificados da seguinte forma: 2 = 1[↑], 3 = 1[↑][↑]
e assim sucessivamente. Ou seja, denotando ↑ ◦ ↑ ◦ . . . ◦ ↑︸ ︷︷ ︸
n vezes
por ↑n, podemos escrever
n = 1[↑n−1]. Intuitivamente a substituic¸a˜o ↑ e´ utilizada para atualizar ı´ndices de De
Bruijn. O ponto “.”, por sua vez, separa os termos de uma lista que conte´m termos
que devem substituir ı´ndices de De Bruijn. Isto e´, o primeiro termo da lista substitui
as ocorreˆncias do ı´ndice 1, o segundo, as ocorreˆncias de 2, e assim sucessivamente.
Os ı´ndices n, onde n e´ maior do que o comprimento desta lista, sa˜o incrementados de
acordo com o u´ltimo termo dessa lista, ja´ que os mesmos correspondem a varia´veis
livres.
14
Quanto a`s propriedades deseja´veis para um ca´lculo de substituic¸o˜es expl´ıcitas
apresentadas na pa´gina 11, [ACCL91] mostra que o ca´lculo λσ satisfaz as pro-
priedades 1, 2 e 3a. Em [DHK00] estende-se o λσ para lidar com meta-varia´veis,
obtendo conflueˆncia local. Em [Mel95], Mellie`s mostra que o ca´lculo λσ na˜o preserva
terminac¸a˜o forte, isto e´, na˜o e´ PSN e portanto na˜o satisfaz a propriedade 4.
Para exemplificar uma simulac¸a˜o de um passo de β-conversa˜o no λσ considere o
seguinte exemplo: ((λx.(λy.(x y))) z)→ β λy.(z y). Como ja´ vimos anteriormente,
esta β-conversa˜o em notac¸a˜o de De Bruijn, considerando o referencial x, y, z, equivale
a ((λ(λ(2 1))) 3)→ βλ(4 1). No ca´lculo λσ, precisamos inicialmente codificar o
termo ((λ(λ(2 1))) 3) obtendo ((λ(λ(1[↑] 1))) 1[↑2]). Aplicando agora as regras
dadas pela figura 2.1, temos, por exemplo, a seguinte derivac¸a˜o:
((λ(λ(1[↑] 1))) 1[↑2])→ Beta
(λ(1[↑] 1))[1[↑2].id]→ Abs
λ(1[↑] 1)[1.((1[↑2].id)◦ ↑)]→Map
λ(1[↑] 1)[1.(1[↑2][↑].(id◦ ↑))]→ Clos
λ(1[↑] 1)[1.(1[↑3].(id◦ ↑))]→ App
λ(1[↑][1.(1[↑3].(id◦ ↑))] 1[1.(1[↑3].(id◦ ↑))])→ V arCons
λ(1[↑][1.(1[↑3].(id◦ ↑))] 1)→ Clos
λ(1[↑ ◦(1.(1[↑3].(id◦ ↑)))] 1)→ ShiftCons
λ(1[1[↑3].(id◦ ↑)] 1)→ V arCons
λ(1[↑3] 1)
E este u´ltimo termo, como podemos ver corresponde a λ(4 1) como quer´ıamos.
2.1.2 O Ca´lculo λse
Em [KR95a], Kamareddine e R´ıos apresentam um novo ca´lculo de substituic¸o˜es
expl´ıcitas: o λs. Diferentemente do λσ, as expresso˜es do λs sa˜o de apenas um tipo,
denominado termos. Isto faz com que o λs mantenha uma estrutura sinta´tica mais
pro´xima do λ-ca´lculo. Os termos do ca´lculo λs sa˜o definidos por:
Termos M, N ::= n | λM | (M N) |M σi N | ϕik M , para k ≥ 0 e i ≥ 1
Esse ca´lculo satisfaz as propriedades 1, 2, 3a e 4. As regras do λs sa˜o dadas pela
figura 2.2. Pouco depois, em [KR95b], Kamareddine e R´ıos estendem o ca´lculo λs
para termos abertos. Essa extensa˜o e´ denominada λse. Ate´ esse ponto sabia-se que
15
o ca´lculo λse satisfazia as propriedades 1, 2 e 3. Kamareddine e R´ıos conjecturaram,
enta˜o, que o ca´lculo λse preservava a terminac¸a˜o forte ate´ que em [Gui00], Guillaume
mostrou falsa essa conjectura. As regras do λse sa˜o formadas pela unia˜o das regras
dadas pelas figuras 2.2 e 2.3. Aqui, denotaremos por se ao sistema λse (figuras 2.2
e 2.3) retirando-se a regra (Etase) e a regra que inicia a propagac¸a˜o da β-conversa˜o,
ou seja, a (σ-generation).
A noc¸a˜o intuitiva dos operadores σi e ϕik pode ser vista da seguinte forma:
o operador σi e´ um operador que faz substituic¸o˜es, como podemos observar pela
regra σ-destruction. O super-´ındice i deste operador vai sendo incrementado a`
medida em que o mesmo entra dentro de novos abstratores (veja σ-λ-transition).
O operador ϕik e´ responsa´vel pela atualizac¸a˜o de ı´ndices de De Bruijn. O super-
ı´ndice de ϕik e´ herdado do super-´ındice de σ
i por meio de uma σ-destruction. O
sub-´ındice, por sua vez, e´ incrementado ao entrar dentro de novos abstratores como
podemos observar em ϕ-λ-transition. A atualizac¸a˜o de ı´ndices e´ feita pela regra
ϕ-destruction, considerando-se que todos os ı´ndices n maiores do que o sub-´ındice k
sa˜o varia´veis livres e, portanto precisam ser atualizados em i− 1. Os outros ı´ndices
permanecem inalterados.
(σ-generation) (λM N)→M σ1 N
(σ-λ-transition) (λM) σi N→λ(M σi+1 N)
(σ-app-transition) (M1 M2) σ
i N→ ((M1 σi N)(M2 σi N))
(σ-destruction) nσiN→
{
n− 1 se n > i
ϕi0N se n = i
n se n < i
(ϕ-λ-transition) ϕik(λM)→λ(ϕik+1M)
(ϕ-app-transition) ϕik(M1 M2)→ ((ϕikM1) (ϕikM2))
(ϕ-destruction) ϕikn→
{
n + i− 1 se n > k
n se n ≤ k
Figura 2.2: Regras do ca´lculo λs
16
(σ-σ-transition) (M1 σ
i M2)σ
jN→ (M1 σj+1 N)σi(M2 σj−i+1 N) se i ≤ j
(σ-ϕ-transition1) (ϕikM)σ
jN→ϕi−1k M se k < j < k + i
(σ-ϕ-transition2) (ϕikM)σ
jN→ϕik(Mσj−i+1N) se k + i ≤ j
(ϕ-σ-transition) ϕik(Mσ
jN)→ (ϕik+1M)σj(ϕik+1−jN) se j ≤ k + 1
(ϕ-ϕ-transition1) ϕik(ϕ
j
lM)→ϕjl (ϕik+1−jM) se l + j ≤ k
(ϕ-ϕ-transition2) ϕik(ϕ
j
lM)→ϕj+i−1l M se l ≤ k < l + j
(Etase) λ(M 1)→N se M =Se ϕ20N
Figura 2.3: Regras para manipulac¸a˜o de termos abertos no λse
Como exemplo de simulac¸a˜o de um passo de β-conversa˜o via λse considere:
((λ(λ(2 1))) 3)→ β λ(4 1). Note que a seguinte simulac¸a˜o no λse e´ u´nica:
((λ(λ(2 1))) 3)→ σ-gen
(λ(2 1)) σ1 3→ σ-λ
λ((2 1) σ2 3)→ σ-app
λ((2 σ2 3) (1 σ2 3))→ 2σ-destr
λ(ϕ203 1)→ ϕ-destr λ(4 1)
Como podemos observar aqui, o λse opera diretamente com todos os ı´ndices de
De Bruijn sem a necessidade da codificac¸a˜o utilizada pelo ca´lculo λσ.
2.1.3 O Ca´lculo λSusp
O Ca´lculo de Suspensa˜o, que aqui denominamos λSusp, foi desenvolvido por
Nadathur e Wilson [NW98] com a intensa˜o de tratar λ-termos como dispositivos
computacionais. Esse interesse foi motivado inicialmente por questo˜es de imple-
mentac¸a˜o relativas ao λProlog, uma linguagem de programac¸a˜o lo´gica que utiliza
termos do λ-ca´lculo tipado como estrutura de dados [NM88].
As expresso˜es do λSusp podem ser dos seguintes tipos: termos suspensos, con-
textos ou termos de contexto. Esses tipos sa˜o definimos como a seguir:
Termos Suspensos M , N ::= Cons | n | λM | (M N) | [[M, i, j, e1]]
Contextos e1, e2 ::= nil | et :: e1 | { e1, i, j, e2}
Termos de Contexto et ::= @i | (M, i) | 〈〈et, i, j, e1〉〉
17
onde Cons denota uma constante qualquer e i, j sa˜o nu´meros naturais.
Veja que os termos suspensos podem conter constantes e ı´ndices de De Bruijn.
Essas constantes podem ser vistas como meta-varia´veis e, portanto, os termos aber-
tos fazem parte da linguagem do λSusp.
Os contextos aqui teˆm um papel semelhante a`s listas que sa˜o separadas pelos
pontos no λσ. Os termos de contexto, por sua vez constituem os termos dessa lista,
ou seja, do contexto.
Observac¸a˜o. Denotaremos por . a subtrac¸a˜o truncada, que pode ser considerada
da seguinte forma: n . m = ma´x{n−m, 0}.
Como acontece em geral nos ca´lculos de substituic¸o˜es expl´ıcitas, o λSusp possui
uma regra que inicia a simulac¸a˜o de um passo de β-conversa˜o, chamada de βs e um
conjunto de regras utilizadas para manipular os termos suspensos. Estas regras sa˜o
dadas pelas figuras 2.4, 2.5 e 2.6. As regras (m9) e (m10) da figura 2.6 dependem
de uma func¸a˜o denominada ı´ndice que pode ser encontrada na definic¸a˜o 2.3. Para
manter a uniformidade de notac¸a˜o com o λσ e λse, denotaremos por Susp ao ca´lculo
de substituic¸a˜o subjacente a` λSusp retirando-se a regra βs.
(βs) ((λ t1) t2)→ [[t1, 1, 0, (t2, 0) :: nil]]
Figura 2.4: Regra que inicia a simulac¸a˜o de um passo de β-conversa˜o
(r1) [[c, ol, nl, e]]→ c, onde c e´ uma constante.
(r2) [[i, 0, nl, nil]]→ i + nl.
(r3) [[1, ol, nl,@l :: e]]→nl− l.
(r4) [[1, ol, nl, (t, l) :: e]]→ [[t, 0, (nl − l), nil]].
(r5) [[i, ol, nl, et :: e]]→ [[i− 1, (ol − 1), nl, e]], para i > 1.
(r6) [[(t1 t2), ol, nl, e]]→ ([[t1, ol, nl, e]] [[t2, ol, nl, e]]).
(r7) [[(λ t), ol, nl, e]]→ (λ [[t, (ol + 1), (nl + 1),@nl :: e]]).
Figura 2.5: Regras para manipulac¸a˜o dos termos suspensos
18
(m1) [[[[t, ol1, nl1, e1]], ol2, nl2, e2]]→ [[t, ol′, nl′, { e1, nl1, ol2, e2} ]],
onde ol′ = ol1 + (ol2 . nl1) e nl′ = nl2 + (nl1 . ol2).
(m2) {nil, nl, 0, nil} →nil.
(m3) {nil, nl, ol, et :: e} →{nil, (nl − 1), (ol − 1), e} ,
para nl, ol ≥ 1.
(m4) {nil, 0, ol, e} → e.
(m5) { et :: e1, nl, ol, e2} →〈〈et, nl, ol, e2〉〉 :: { e1, nl, ol, e2} .
(m6) 〈〈et, nl, 0, nil〉〉→ et.
(m7) 〈〈@m,nl, ol,@l :: e〉〉→@(l + (nl . ol)),
para nl = m+ 1.
(m8) 〈〈@m,nl, ol, (t, l) :: e〉〉→ (t, (l + (nl . ol))),
para nl = m+ 1.
(m9) 〈〈(t, nl), nl, ol, et :: e〉〉→ ([[t, ol, l′, et :: e]],m),
onde l′ = ind(et) e m = l′ + (nl . ol).
(m10) 〈〈et, nl, ol, et′ :: e〉〉→ 〈〈et, (nl − 1), (ol − 1), e〉〉,
para nl 6= ind(et).
Figura 2.6: Regras para imersa˜o em termos suspensos
Observac¸o˜es.
(1) Denotaremos por → r e →m a relac¸a˜o de reduc¸a˜o definida pelas regras das
figuras 2.5 e 2.6, respectivamente. A unia˜o de ambos os sistemas sera´, natu-
ralmente, denotada por → rm.
(2) O fecho reflexivo transitivo sime´trico de → rm sera´ denotado por =rm.
Como vimos anteriormente, existem algumas propriedades deseja´veis para um
ca´lculo de substituic¸o˜es expl´ıcitas. O λSusp, por sua vez, satisfaz as propriedades 1,
2 e 3 [NW98]. Em [Nad99] Nadathur conjectura que o λSusp preserva terminac¸a˜o
forte, ou seja, e´ PSN.
Vejamos agora, como exemplo, uma simulac¸a˜o de um passo de β-conversa˜o no
λSusp. Considere a seguinte β-conversa˜o: ((λ(λ(2 1))) 3)→ βλ(4 1). Uma poss´ıvel
simulac¸a˜o e´ dada por:
19
((λ(λ(2 1))) 3)→ βs
[[(λ(2 1)), 1, 0, (3, 0) :: nil]]→ r7
λ[[(2 1), 2, 1,@0 :: (3, 0) :: nil]]→ r6
λ([[2, 2, 1,@0 :: (3, 0) :: nil]] [[1, 2, 1,@0 :: (3, 0) :: nil]])→ r3
λ([[2, 2, 1,@0 :: (3, 0) :: nil]] 1)→ r5
λ([[1, 1, 1, (3, 0) :: nil]] 1)→ r4
λ([[3, 0, 1, nil]] 1)→ r2
λ(4 1)
As definic¸o˜es a seguir determinam as condic¸o˜es que devem existir sobre as ex-
presso˜es que trabalharemos no λSusp.
Definic¸a˜o 2.1 ([NW98]) Uma expressa˜o e´ dita simples quando na˜o possui subex-
pressa˜o da forma 〈〈et, j, k, e〉〉 ou { e1, j, k, e2} . Se a expressa˜o em questa˜o e´ um
termo, um contexto ou um termo de contexto, enta˜o dizemos termo simples, con-
texto simples ou termo de contexto simples, respectivamente.
Definic¸a˜o 2.2 ([NW98]) O comprimento de um contexto e, denotado por len(e),
e´ dado por:
(a) se e = nil enta˜o len(e) = 0;
(b) se e = et :: e′ enta˜o len(e) = len(e′) + 1;
(c) se e = { e1, i, j, e2} enta˜o len(e) = len(e1) + (len(e2) . i).
Definic¸a˜o 2.3 ([NW98]) O ı´ndice de um termo de contexto et, denotado por
ind(et), e para cada nu´mero natural l, o ı´ndice do l-e´simo elemento do contexto
e, denotado por indl(e), sa˜o definidos simultaneamente por induc¸a˜o sobre a estrutura
das expresso˜es da seguinte maneira:
(i) Se et = @m enta˜o ind(et) = m+ 1;
(ii) Se et = (t′,m) enta˜o ind(et) = m;
(iii) Se et = 〈〈et′, j, k, e〉〉, seja m = (j−˙ind(et′)).
Enta˜o ind(et) =
{
indm(e) + (j−˙k) se len(e) > m
ind(et′) caso contra´rio.
20
(iv) Se e = nil enta˜o indl(e) = 0
(v) Se e = et :: e′ enta˜o ind0(e) = ind(et) e indl+1(e) = indl(e′)
(vi) Se e = { e1, j, k, e2} , seja m = (j−˙indl(e1)) e l1 = len(e1).
Enta˜o indl(e) =
{
indm(e2) + (j−˙k) se l < l1 e len(e2) > m
indl(e1) se l < l1 e len(e2) ≤ m
indl−l1+j(e2) se l ≥ l1
O ı´ndice de um contexto, denotado por ind(e), e´ o ind0(e).
Definic¸a˜o 2.4 ([NW98]) Uma expressa˜o do λSusp e´ dita bem-formada se as
seguintes condic¸o˜es sa˜o verdadeiras para toda subexpressa˜o s da expressa˜o dada:
(i) Se s e´ da forma [[t, ol, nl, e]] enta˜o len(e) = ol e ind(e) ≤ nl;
(ii) Se s e´ da forma et :: e enta˜o ind(e) ≤ ind(et);
(iii) Se s e´ da forma 〈〈et, j, k, e〉〉 enta˜o len(e) = k e ind(et) ≤ j;
(iv) Se s e´ da forma { e1, j, k, e2} enta˜o len(e2) = k e ind(e1) ≤ j
Definic¸a˜o 2.5 ([NW98]) A(s) subexpressa˜o(o˜es) imediata(s) de uma expressa˜o
x sa˜o dadas por:
(1) Se x e´ um termo enta˜o,
(a) se x e´ da forma (t1 t2) enta˜o t1 e t2 sa˜o suas subexpresso˜es imediatas;
(b) se x e´ da forma (λt) enta˜o t e´ sua subexpressa˜o imediata;
(c) se x e´ da forma [[t, ol, nl, e]] enta˜o t e e sa˜o suas subexpresso˜es imedia-
tas;
(2) se x e´ um contexto enta˜o,
(a) se x e´ da forma et :: e enta˜o et e e sa˜o suas subexpresso˜es imediatas;
(b) se x e´ da forma { e1, i, j, e2} enta˜o e1 e e2 sa˜o suas subexpresso˜es
imediatas;
(3) se x e´ um termo de contexto enta˜o,
(a) se x e´ da forma (t, l) enta˜o t e´ sua subexpressa˜o imediata;
(b) se x e´ da forma 〈〈et, i, j, e〉〉 enta˜o et e e sa˜o suas subexpresso˜es ime-
diatas.
21
Definic¸a˜o 2.6 ([NW98]) Duas expresso˜es teˆm a mesma estrutura externa se
ambas sa˜o constantes, ı´ndices de De Bruijn, abstrac¸o˜es, aplicac¸o˜es ou termos sus-
pensos ou se ambas sa˜o da forma nil, et :: e, { e1, i, j, e2} , @l, (t, l) ou 〈〈et, i, j, e〉〉.
Se duas expresso˜es na linguagem do λSusp teˆm a mesma estrutura externa, enta˜o
existe uma correspondeˆncia o´bvia entre suas subexpresso˜es.
O lema a seguir caracteriza a importante noc¸a˜o de forma rm-normal.
Lema 2.7 ([NW98]) Uma expressa˜o bem-formada x esta´ na sua forma rm-normal
se e somente se uma das seguintes afirmac¸o˜es e´ verdadeira:
(a) x e´ um termo puro na notac¸a˜o de De Bruijn;
(b) x e´ um termo de contexto da forma @l ou (t, l) onde t e´ um termo em sua
forma rm-normal;
(c) x e´ um contexto da forma nil ou et :: e onde et e e sa˜o, respectivamente, um
termo de contexto e um contexto na forma rm-normal.
Demonstrac¸a˜o.(Esquema)
A demonstrac¸a˜o e´ feita por inspec¸a˜o direta das regras contidas nas figuras 2.5
e 2.6. Note que termos puros na notac¸a˜o de De Bruijn na˜o podem ser reduzidos
por nenhuma das regras citadas acima, e portanto, os termos puros ja´ esta˜o na
sua forma rm-normal. Para termos de contexto da forma @l ou (t, l) tambe´m
na˜o temos nenhuma reduc¸a˜o poss´ıvel desde que t esteja em sua forma rm-normal.
Analogamente, para contextos simples da forma nil ou et :: e como na˜o temos
nenhuma regra de reescrita que se aplique a eles conclu´ımos que os mesmos esta˜o
na sua forma rm-normal.
Logo expresso˜es bem-formadas que tenham subexpresso˜es da forma [[t, i, j, e]],
{ e1, i, j, e2} ou 〈〈et, i, j, e〉〉 podem ser reescritas utilizando as regras (r1)-(r7) e (m1)-
(m10) e, portanto essas expresso˜es na˜o podem estar na sua forma rm-normal. 2
Observac¸a˜o. Para um termo A qualquer do λSusp, denotaremos por rm-norm(A),
a sua forma rm-normal.
22
2.2 Adic¸a˜o da regra Eta para o Ca´lculo λSusp
O ca´lculo λSusp foi originalmente proposto sem a regra Eta. Aqui vamos intro-
duz´ı-la e compara´-la com as regras Eta correspondentes dos ca´lculos λσ e λse a fim
de entendermos melhor as relac¸o˜es entre os mesmos. Nos ca´lculos λσ e λse as regras
Eta foram introduzidas, respectivamente, em [DHK00] e [ARK01b], para aplicac¸a˜o
no tratamento de problemas de unificac¸a˜o de ordem superior.
A relac¸a˜o → rm e´ terminante e confluente [NW98]. E´, portanto, de fundamen-
tal importaˆncia que a inclusa˜o da regra Eta que estamos propondo preserve estas
propriedades.
A regra Eta do λSusp e´ dada pela figura 2.7. Denotaremos esta regra por EtaSusp.
(EtaSusp) (λ (t1 1))→ t2, se t1 =rm [[t2, 0, 1, nil]]
Figura 2.7: A Regra Eta do λSusp
Intuitivamente a regra EtaSusp pode ser interpretada da seguinte maneira: sem-
pre que for poss´ıvel aplicar a regra EtaSusp a` raiz do redex λ(t1 1) obteremos um
termo t2 que consiste exatamente do termo t1 com todas as suas varia´veis livres
decrementadas em 1. Sera´ poss´ıvel aplicar a regra EtaSusp ao redex λ(t1 1) sempre
que na˜o tivermos a ocorreˆncia de 1 como varia´vel livre em t1. A proposic¸a˜o 2.9
mostra a corretude dessa regra. Antes disso vejamos o seguinte:
Lema 2.8 Seja A um termo bem-formado. Enta˜o a Susp-normalizac¸a˜o do termo
[[A, k, k + 1,@k :: @k − 1 :: . . . :: @1 :: nil]] nos fornece um novo termo, obtido a par-
tir de A incrementando todas as suas varia´veis livres maiores do que k em 1 e
deixando todas as outras varia´veis inalteradas.
Demonstrac¸a˜o.
Por induc¸a˜o sobre a estrutura do termo A, temos que:
1. Se A = n enta˜o,
(a) se n > k enta˜o [[n, k, k + 1,@k :: . . . :: @1 :: nil]]→ kr5
[[n− k, 0, k + 1, nil]]→ r2n + 1;
(b) se n ≤ k enta˜o [[n, k, k + 1,@k :: . . . :: @1 :: nil]]→ n−1r5
[[1, k − n+ 1, k + 1,@k − n+ 1 :: . . . :: @1 :: nil]]→ r3n;
23
2. Se A = (B C) enta˜o aplicamos (r6) e utilizamos a hipo´tese de induc¸a˜o para
os termos B e C;
3. Se A = (λB), para B um termo bem-formado, enta˜o, como o termoB esta´ limi-
tado por um abstrator adicional, apenas as varia´veis livres de B maiores do que
k+1 e´ que devem ser incrementadas em 1, enquanto que as outras varia´veis de-
vem permanecer inalteradas. Como [[(λB), k, k + 1,@k :: . . . :: @1 :: nil]]→ r7
λ[[B, k + 1, k + 2,@k + 1 :: . . . :: @1 :: nil]], aplicando a hipo´tese de induc¸a˜o so-
bre este u´ltimo termo e obtemos o resultado desejado.
4. Se A = [[t, ol, nl, e]] enta˜o primeiro rm-normalizamos o termo A. Pelo lema 2.7
temos que a ana´lise do termo assim obtido recai em um dos casos anteriores.
2
Proposic¸a˜o 2.9 Uma aplicac¸a˜o da regra EtaSusp, sempre que poss´ıvel, ao redex
λ(t1 1), produz efetivamente o termo t2, obtido a partir do termo t1 da seguinte
forma: t2 consiste do termo t1 com todas as suas varia´veis livres decrementadas em
1.
Demonstrac¸a˜o.
A demonstrac¸a˜o e´ feita por induc¸a˜o sobre a estrutura do termo t2 considerando-
se a premissa t1 =rm [[t2, 0, 1, nil]]. Veremos que o efeito da rm-normalizac¸a˜o de
[[t2, 0, 1, nil]] e´ incrementar as varia´veis livres de t2 em 1. Sendo assim, quando:
(a) t2 = n temos [[n, 0, 1, nil]]→ r2n + 1 =rm t1, ou seja, t2 e´ obtido de t1 decre-
mentando em 1 sua u´nica varia´vel livre, a saber, n + 1.
(b) t2 = (A B), podemos assumir sem perda de generalidade que os termos A e B
esta˜o rm-normalizados. Agora, assumindo a hipo´tese de induc¸a˜o va´lida para
os termos A e B, temos que [[(A B), 0, 1, nil]]→ r6 [[A, 0, 1, nil]] [[B, 0, 1, nil]],
onde o termo suspenso [[A, 0, 1, nil]] incrementa em 1 todas as varia´veis livres
de A. Da mesma forma, [[B, 0, 1, nil]] incrementa em 1 todas as varia´veis livres
do termo B. Como as ocorreˆncias de varia´veis livres no termo A na˜o teˆm inter-
fereˆncia sobre as ocorreˆncias de varia´veis livres no termo B, podemos concluir
que o termo suspenso [[(A B), 0, 1, nil]] incrementa em 1 todas as varia´veis
livres do termo (A B) = t2, ou seja, t1 e´ obtido de t2 decrementando em 1
todas as suas varia´veis livres.
24
(c) t2 = (λA), como no caso anterior, assumiremos que o termo A esta´ na sua
forma rm-normal. Assim, [[(λA), 0, 1, nil]]→ r7(λ[[A, 1, 2,@1 :: nil]]). Agora
aplicamos o lema 2.8 ao termo [[A, 1, 2,@1 :: nil]] para concluir que todas as
varia´veis livres de A maiores que 1 sa˜o incrementadas em 1 enquanto que as
outras permanecem inalteradas. Ou seja, t2 e´ obtido de t1 decrementando em
1 todas as suas varia´veis livres maiores que 1.
(d) t2 = [[t, i, j, e]], para t rm-normalizado temos que [[t, i, j, e]]→ ∗rmt′ onde t′ e´ um
termo puro na notac¸a˜o de De Bruijn de acordo com o lema 2.7. A ana´lise do
termo assim obtido recai nos casos anteriores.
2
Os resultados a seguir sera˜o importantes no sentido de se estabelecer a termina-
lidade do λSusp com a regra EtaSusp.
Lema 2.10 ([NW98]) Seja et um termo de contexto tal que ind(et) ≤ nl. Enta˜o
para j ≥ 1, 〈〈et, nl + j, ol + j, et1 :: . . . :: etj :: e〉〉 → ∗rm〈〈et, nl, ol, e〉〉.
Demonstrac¸a˜o. (Esquema)
Induc¸a˜o em j e repetidas aplicac¸o˜es da regra (m10). 2
Lema 2.11 ([NW98]) Seja e1 um contexto simples. Ale´m disso, suponha que nl e
ol sejam nu´meros naturais tais que (nl−ind(e1)) ≥ ol. Enta˜o { e1, nl, ol, e2} → ∗rme1.
Demonstrac¸a˜o. (Esquema)
Sem perda de generalidade assumiremos que e2 e´ um contexto simples, pois caso
contra´rio, podemos rm-reduz´ı-lo a um tal contexto. A demonstrac¸a˜o se da´ por
induc¸a˜o sobre o comprimento de e1, len(e1).
• Se len(e1) = 0 enta˜o e1 = nil. Como ind(nil) = 0 e nl ≥ ol temos por induc¸a˜o
sobre ol que { e1, nl, ol, e2} → ∗rmnil
• Se len(e1) > 0 enta˜o e1 e´ da forma et1 :: e′1. Portanto
{ e1, nl, ol, e2} →m5 〈〈et1, nl, ol, e2〉〉 :: { e′1, nl, ol, e2}
25
Temos que ind(et1) = ind(e1) pela definic¸a˜o de ı´ndice, e adicionalmente como
estamos trabalhando com termos bem-formados temos que ind(e′1) ≤ ind(e1).
O resultado desejado e´ consequeˆncia do lema 2.10 e da regra (m6) juntamente
com a hipo´tese de induc¸a˜o.
2
Construiremos agora uma ordem parcial bem-fundada a fim de estabelecermos
a terminalidade de λSusp com a regra EtaSusp.
A ide´ia fundamental por tra´s dessa ordem parcial esta´ na definic¸a˜o de duas
medidas δ e µ que calculam o trabalho que ainda precisa ser feito ao se propagar
as substituic¸o˜es. Se considerarmos, por exemplo, um termo suspenso da forma
[[t, ol, nl, e]] e´ de se esperar que essas medidas computem a complexidade da estrutura
do termo t, ja´ que as substituic¸o˜es devem ser propagadas dentro do mesmo, e tambe´m
devem computar a complexidade do contexto e, pois estes constituem substituic¸o˜es
que, em geral, precisam ser propagadas como evidencia a regra (r4).
Definic¸a˜o 2.12 ([NW98]) As medidas δ, sobre expresso˜es, e µ, sobre termos, sa˜o
dadas pela tabela abaixo:
Categoria Expressa˜o δ(exp) µ(exp)
constante 0 1
i 0 1
Termo (t1 t2) max(δ(t1), δ(t2)) max(µ(t1), µ(t2)) + 1
(λt) δ(t) µ(t) + 1
[[t, ol, nl, e]] µ(t) + δ(e) µ(t) + δ(e) + 1
Contexto nil 0 -
et :: e max(δ(et), δ(e)) -
{ e1, nl, ol, e2} δ(e1) + δ(e2) + 1 -
Termo @l 0 -
de (t, l) µ(t) -
Contexto 〈〈et, nl, ol, e〉〉 δ(et) + δ(e) + 1 -
Infelizmente a medida δ ainda na˜o constitui a relac¸a˜o de ordem que desejamos
por dois motivos. Primeiro, para algumas regras de reescrita, em particular para
(r5), (m1), (m3), (m5) e (m10), na˜o temos uma simplificac¸a˜o das expresso˜es obtidas
pois os termo do lado esquerdo e direito de cada regra teˆm o mesmo valor de δ.
Segundo, ao substituirmos uma subexpressa˜o t1 de t por outra subexpressa˜o t2 com
δ(t2) < δ(t1) na˜o necessariamente obtemos uma expressa˜o t
′ com δ(t′) < δ(t). Para
resolver esses problemas extendemos a medida δ sobre a estrutura das expresso˜es.
Os resultados seguintes caminham nessa direc¸a˜o.
26
Definic¸a˜o 2.13 ([NW98]) Dadas duas expresso˜es x1 e x2, dizemos que x1 = x2
se δ(x1) > δ(x2) ou se δ(x1) = δ(x2) e uma das seguintes afirmac¸o˜es e´ verdadeira:
(1) x1 = i e x2 = j onde i > j;
(2) x1 = [[t1, ol1, nl1, e1]], x2 = [[t2, ol2, nl2, e2]] e δ(t1) > δ(t2);
(3) x1 = { e1, nl, ol, e2} , x2 = et :: e e x1 = e;
(4) x1 e x2 teˆm a mesma estrutura externa e tambe´m teˆm subexpresso˜es imediatas
tais que cada subexpressa˜o imediata de x1 e´ ideˆntica a correspondente subex-
pressa˜o imediata de x2 exceto por um par de subexpresso˜es imediatas x
′
1 de x1
e x′2 de x2 tais que x
′
1 = x
′
2.
(5) x2 e´ uma subexpressa˜o imediata de x1.
A relac¸a˜o = na˜o e´ transitiva, logo, na˜o e´ uma ordem parcial. Considere enta˜o a
seguinte:
Definic¸a˜o 2.14 ([NW98]) A relac¸a˜o  define-se sobre expresso˜es da linguagem
do λSusp como o fecho transitivo da relac¸a˜o =.
Lema 2.15 ([NW98]) Na˜o existem cadeias infinitas de reduc¸a˜o de expresso˜es x1, x2,
. . . , xn, . . . tais que x1 = x2 = . . . = xn = . . .
Demonstrac¸a˜o.(Esquema) A prova e´ feita por induc¸a˜o sobre δ(x1). Note que se
x = y enta˜o δ(x) ≥ δ(y). Enta˜o precisamos mostrar que na˜o existem cadeias infinitas
de reduc¸a˜o de expresso˜es x1, x2, . . . , xn, . . ., com δ(xi) ≥ δ(xj), para i, j ≥ 1. Note
que o caso estrito e´ imediato. Quando δ(x) = δ(y) a demonstrac¸a˜o e´ feita por
induc¸a˜o sobre a estrutura de x considerando sua categoria sinta´tica. 2
Proposic¸a˜o 2.16 ([NW98]) A relac¸a˜o  e´ uma ordem parcial bem-fundada definida
sobre expresso˜es do λSusp.
Demonstrac¸a˜o.(Esquema)
Precisamos mostrar que e´ anti-reflexiva para que seja uma ordem parcial. Ale´m
disso, precisamos mostrar que  e´ bem fundada. Ambos os fatos sa˜o consequeˆncia
imediata do fato de na˜o existirem cadeias infinitas de reduc¸a˜o para a relac¸a˜o  (lema
2.15). 2
27
Lema 2.17 ([NW98]) Sejam x1 e x2 expresso˜es da mesma categoria sinta´tica tais
que δ(x1) ≥ δ(x2) e, se x1 e x2 sa˜o termos enta˜o µ(x1) ≥ µ(x2). Se x resulta de
y substituindo a subexpressa˜o x1 por x2 enta˜o δ(y) ≥ δ(x) e, se x e y sa˜o termos,
µ(y) ≥ µ(x).
Demonstrac¸a˜o.(Esquema) Induc¸a˜o sobre a estrutura das expresso˜es e inspec¸a˜o da
definic¸a˜o 2.12. 2
Lema 2.18 ([NW98]) Se l→ r e´ uma instaˆncia de alguma das regras das figuras
2.5 ou 2.6 enta˜o δ(l) ≥ δ(r) e, se l e r sa˜o termos, enta˜o µ(l) ≥ µ(r).
Demonstrac¸a˜o.(Esquema) Inspec¸a˜o direta das regras em questa˜o. 2
Lema 2.19 ([NW98]) Sejam x1 e x2 expresso˜es bem-formadas. Se x1→ ∗rmx2
enta˜o δ(x1) ≥ δ(x2).
Demonstrac¸a˜o.(Esquema) Consequeˆncia imediata dos lemas 2.17 e 2.18. 2
Lema 2.20 ([NW98]) Se l→ r e´ uma instaˆncia de alguma das regras das figuras
2.5 ou 2.6 enta˜o l  r.
Demonstrac¸a˜o.(Esquema) A ide´ia que esta´ por tra´s da demonstrac¸a˜o segue do
fato que para qualquer instaˆncia l→ r das regras citadas, o termo r e´ mais simples
do que o termo l, no seguinte sentido: O termo r e´ mais simples do que o termo l
quando µ(l) > µ(r). Analogamente, a expressa˜o r e´ mais simples do que a expressa˜o
l quando δ(l) > δ(r). 2
Lema 2.21 Seja M uma expressa˜o bem-formada do λSusp. Se λ(M 1)→ EtaSuspN
enta˜o µ(λ(M 1)) ≥ µ(N).
Demonstrac¸a˜o.
A ide´ia que aqui utilizaremos foi desenvolvida por [Bor95] para o λσ e por
[ARK01a] para o λse. Essa ide´ia e´ um algoritmo para aplicac¸a˜o da regra Eta
que pode ser assim resumida: Para M ∈ ΛdB sabemos que a regra η se aplica ao
redex λ(M 1) se M na˜o possui ocorreˆncias livres da varia´vel 1. Por outro lado isto
equivale a normalizar o termo ((λM) 3) onde 3 e´ um s´ımbolo “dummy” que na˜o
28
pertence a linguagem do λSusp. Esse s´ımbolo “dummy” pode ser considerado como
uma constante que estende a linguagem do λSusp. Essa ide´ia, que sera´ desenvolvida
com detalhes no cap´ıtulo 4, pode ser resumida atrave´s da seguinte regra:
λ(M 1)→ EtaSuspN onde N = rm-norm([[M, 1, 0, (3, 0) :: nil]])
se 3 na˜o ocorre em rm-norm([[M, 1, 0, (3, 0) :: nil]]).
Por um lado, como M e´ um termo, µ(λ(M 1)) = µ((M 1))+1 = ma´x(µ(M), 1)+
2 = µ(M) + 2.
Por outro lado, µ([[M, 1, 0, (3, 0) :: nil]]) = µ(M) + δ((3, 0) :: nil) + 1 = µ(M) +
ma´x(δ((3, 0), δ(nil)) + 1 = µ(M) + δ((3, 0)) + 1 = µ(M) + µ(3) + 1 = µ(M) + 2.
Portanto, µ(λ(M 1)) = µ([[M, 1, 0, (3, 0) :: nil]]) e, pelo lema 2.17 concluimos que
µ([[M, 1, 0, (3, 0) :: nil]]) ≥ µ(rm-norm([[M, 1, 0, (3, 0) :: nil]])) = N . 2
Notac¸a˜o. Para simplificar a notac¸a˜o vamos nos referir ao sistema rm + EtaSusp
como sendo Sp.
Lema 2.22 Sejam x1 e x2 expresso˜es bem-formadas. Se x1→ Spx2 enta˜o x1  x2.
Demonstrac¸a˜o.
Por induc¸a˜o sobre a estrutura de x1, temos que se x1 e´ uma instaˆncia de uma das
regras de Sp enta˜o o resultado e´ consequeˆncia imediata dos lemas 2.20 e 2.21 e da
definic¸a˜o 2.13. Caso contra´rio, se x1 e x2 teˆm a mesma estrutura externa enta˜o, pelo
lema 2.17, temos δ(x1) ≥ δ(x2). No caso em que δ(x1) > δ(x2) o resultado e´ imediato
a partir da definic¸a˜o de . Quando δ(x1) = δ(x2), temos por hipo´tese de induc¸a˜o
e aplicac¸a˜o da relac¸a˜o Sp que existe uma subexpressa˜o imediata x′1 de x1 e uma
correspondente subexpressa˜o imediata x′2 de x2 tais que x
′
1  x′2 e qualquer outra
subexpressa˜o imediata de x1 e´ ideˆntica a` correspondente subexpressa˜o imediata de
x2. Usando a definic¸a˜o de  concluimos enta˜o que x1  x2 2
Proposic¸a˜o 2.23 A relac¸a˜o Sp e´ terminante.
Demonstrac¸a˜o.
O resultado e´ consequeˆncia imediata dos lemas 2.16 e 2.22. 2
29
A terminalidade da relac¸a˜o Sp nos garante a existeˆncia de formas normais, cuja
notac¸a˜o obedece a` forma determinada pela definic¸a˜o 2.7.
Proposic¸a˜o 2.24 A relac¸a˜o Sp e´ local-confluente.
Demonstrac¸a˜o.
Sabemos que a relac¸a˜o rm e´ local-confluente [NW98]. Para mostrar que a nova
relac¸a˜o Sp e´ tambe´m local-confluente basta verificar que todos os pares cr´ıticos
gerados pela regra EtaSusp com alguma das regras de rm sa˜o junta´veis. Para isso
utilizamos o crite´rio dos pares cr´ıticos de Knuth-Bendix [KB70], dado pelo lema
1.20.
Inicialmente note que na˜o ha´ sobreposic¸a˜o da regraEtaSusp com ela mesma, assim
como entre as regras dadas nas figuras 2.6 e 2.7. Temos uma u´nica sobreposic¸a˜o
poss´ıvel da regra EtaSusp com a regra (r7) da figura 2.5.
Na figura 2.8 podemos observar o termo obtido com esta sobreposic¸a˜o, assim
como a divergeˆncia ao se aplicar (r7) por um lado e EtaSusp por outro.
[[λ(t1 1), ol, nl, e]]
+ sr7 EtaSusp
λ[[(t1 1), ol + 1, nl + 1,@nl :: e]] [[t2, ol, nl, e]]
onde t1 =rm [[t2, 0, 1, nil]].
?
r6 + r3
λ([[t1, ol + 1, nl + 1,@nl :: e]] 1)
Figura 2.8: Divergeˆncia gerada pelas regras (r7) e EtaSusp
Considerando os termos t1 e t2 rm-normalizados, vejamos que esta divergeˆncia
e´ junta´vel. A demonstrac¸a˜o se da´ pela ana´lise da estrutura do termo t1:
1. t1 = n. Aqui precisamos que n > 1 para que a regra EtaSusp possa ser aplicada.
Neste ponto estamos com λ([[n, ol + 1, nl + 1,@nl :: e]] 1). De acordo com o
comprimento do contexto @nl :: e temos os seguintes casos:
(a) Se ol + 1 < n temos a seguinte cadeia de reduc¸a˜o:
30
λ([[n, ol + 1, nl + 1,@nl :: e]] 1)→ ol+1r5
λ([[n− ol− 1, 0, nl + 1, nil]] 1)→ r2
λ(n− ol + nl 1)→ EtaSusp
n− ol + nl− 1.
Por outro lado, temos que t1 =rm [[t2, 0, 1, nil]] e portanto, t2 = n− 1. Logo,
[[t2, ol, nl, e]] =
[[n− 1, ol, nl, e]]→ olr5
[[n− 1− ol, 0, nl, nil]]→ r2
n− ol + nl− 1
(b) Quando ol + 1 ≥ n temos
λ([[n, ol + 1, nl + 1,@nl :: e]] 1)→ n−1r5
λ([[1, ol − n+ 2, nl + 1, e1 :: e′]] 1).
A reduc¸a˜o a partir desse ponto depende da estrutura de e1: quando e1 =
@l aplicamos (r3) obtendo λ(nl + 1− l 1)→ EtaSusp nl− l. Por outro lado,
temos
[[t2, ol, nl, e]] =
[[n− 1, ol, nl, e]]→ n−2r5
[[1, ol − n+ 2, nl, e1 :: e′]] =
[[1, ol − n+ 2, nl,@l :: e′]]→ r3 nl− l
A outra possibilidade e´ e1 = (t, l), onde, sem perda de generalidade, podemos
considerar t rm-normalizado. Neste caso,
λ([[1, ol − n+ 2, nl + 1, (t, l) :: e′]] 1)→ r4
λ([[t, 0, nl − l + 1, nil]] 1)→ EtaSusp
rm-norm([[[[t, 0, nl + 1− l, nil]], 1, 0, (3, 0) :: nil]])→ m1
rm-norm([[t, 0, nl − l, {nil, nl + 1− l, 1, (3, 0) :: nil} ]])→ m3
rm-norm([[t, 0, nl − l, {nil, nl − l, 0, nil} ]])→ m2
rm-norm([[t, 0, nl − l, nil]]).
Por outro lado,
31
[[t2, ol, nl, e]] = [[n− 1, ol, nl, e]]→ n−2r5
[[1, ol − n+ 2, nl, (t, l) :: e′]]→ r4 [[t, 0, nl − l, nil]].
como rm-norm([[t, 0, nl − l, nil]]) e [[t, 0, nl − l, nil]] sa˜o obviamente junta´veis,
temos a convergeˆncia.
2. t1 = (A B).
Temos λ([[t1, ol + 1, nl + 1,@nl :: e]] 1) =rm λ([[(A B), ol + 1, nl + 1,@nl :: e]] 1).
Agora note que (A B) =rm [[t2, 0, 1, nil]] e, portanto podemos fazer a seguinte
reduc¸a˜o:
λ([[(A B), ol + 1, nl + 1,@nl :: e]] 1) =
λ([[[[t2, 0, 1, nil]], ol + 1, nl + 1,@nl :: e]] 1)→m1
λ([[t2, ol, nl + 1, {nil, 1, ol + 1,@nl :: e} ]] 1)→m3
λ([[t2, ol, nl + 1, {nil, 0, ol, e, } ]] 1)→m4
λ([[t2, ol, nl + 1, e]] 1)→ EtaSusp
rm-norm([[[[t2, ol, nl + 1, e]], 1, 0, (3, 0) :: nil]])→m1
rm-norm([[t2, ol, nl, { e, nl + 1, 1, (3, 0) :: nil} ]])→ lema2.11
rm-norm([[t2, ol, nl, e]])
Por outro lado t´ınhamos o termo [[t2, ol, nl, e]], mas esses dois u´ltimos termos
se juntam trivialmente.
3. t1 = (λA). Neste caso, temos λ([[(λA), ol + 1, nl + 1,@nl :: e]] 1) onde λA =rm
[[t2, 0, 1, nil]]. Fazendo essa substituic¸a˜o, temos:
λ([[[[t2, 0, 1, nil]], ol + 1, nl + 1,@nl :: e]] 1)→m1
λ([[t2, ol, nl + 1, {nil, 1, ol + 1,@nl :: e} ]] 1)→m3
λ([[t2, ol, nl + 1, {nil, 0, ol, e} ]] 1)→m4
λ([[t2, ol, nl + 1, e]] 1)→ EtaSusp
rm-norm([[[[t2, ol, nl + 1, e]], 1, 0, (3, 0) :: nil]])→m1
rm-norm([[t2, ol, nl, { e, nl + 1, 1, (3, 0) :: nil} ]])→ lema2.11
rm-norm([[t2, ol, nl, e]])
Por outro lado t´ınhamos o termo [[t2, ol, nl, e]], mas esses dois u´ltimos termos
se juntam trivialmente.
32
2
Proposic¸a˜o 2.25 A relac¸a˜o Sp e´ confluente.
Demonstrac¸a˜o.
Aplicando o Lema do Diamante de Newman (lema 1.18) tendo como hipo´tese a
proposic¸a˜o 2.23 e o lema anterior, obtemos o resultado desejado. 2
2.3 A Correspondeˆncia entre as Regras Eta
Nesta sec¸a˜o veremos a correspondeˆncia entre as regras Etaσ, Etase e EtaSusp.
Em [ARK01b], Ayala-Rinco´n e Kamareddine mostram a correspondeˆncia entre
as regras Eta do λσ e do λse, isto e´, a correspondeˆncia entre as condic¸o˜es t1[↑] =σ M
e ϕ20t1 =se M , onde t1 ∈ ΛdB, como veremos a seguir.
Lema 2.26 ([ARK01b]) Seja n um ı´ndice de De Bruijn. Enta˜o para k ≥ 0 a
forma se-normal de ϕ
2
kn e a forma σ-normal de n[1.1[↑].1[↑2]. . . . .1[↑k−1]. ↑k+1] sa˜o
ı´ndices de De Bruijn correspondentes entre si.
Lema 2.27 ([ARK01b]) Seja λt1 uma abstrac¸a˜o sobre a linguagem ΛdB. Enta˜o
temos, para k ≥ 0, que o termo (λt1)[1.1[↑].1[↑2]. . . . .1[↑k−1]. ↑k+1] σ-reduz-se para
λ(t1[1.1[↑].1[↑2] . . .1[↑k]. ↑k+2]).
A correspondeˆncia entre t1[↑] e ϕ20t1 e´ o caso k = 0 do seguinte lema:
Lema 2.28 ([ARK01b]) Seja t1 ∈ ΛdB e t′1 sua codificac¸a˜o na linguagem do
ca´lculo λσ, onde todos os ı´ndices n ∈ N que ocorrem em t1 sa˜o substituidos por
1[↑n−1]. Enta˜o, para k ≥ 0, a forma σ-normal de t′1[1.1[↑].1[↑2]. . . . .1[↑k−1]. ↑k+1]
corresponde a` forma se-normal de ϕ
2
kt1.
De forma ana´loga estabeleceremos a correspondeˆncia entre as regras Eta do λSusp
e do λse. Isto corresponde a` equivaleˆncia entre as condic¸o˜es [[t1, 0, 1, nil]] =Susp M e
ϕ20t1 =se M para t1 ∈ ΛdB. A correspondeˆncia desejada corresponde ao caso k = 0
da seguinte proposic¸a˜o:
33
Proposic¸a˜o 2.29 Seja t1 ∈ ΛdB. Enta˜o, para todo k ≥ 0, a forma Susp-normal de
[[t1, k, k + 1,@k :: @k − 1 :: . . . :: @1 :: nil]] corresponde a` forma se-normal de ϕ2kt1.
Demonstrac¸a˜o.
A demonstrac¸a˜o e´ feita por induc¸a˜o sobre a estrutura do termo t1. No caso em
que:
• t1 = n. De fato, pelo lema 2.8 temos que para todo k ≥ 0,
[[n, k, k + 1,@k :: @k − 1 :: . . . :: @1 :: nil]]→
{
n + 1 se n > k
n se n ≤ k
Por outro lado, temos ϕ2kn→ ϕ-destr
{
n + 1 se n > k
n se n ≤ k
• t1 = (A B) aplicamos a hipo´tese de induc¸a˜o a A e a B. De fato,
Susp-norm([[(A B), k, k + 1,@k :: @k − 1 :: . . . :: @1 :: nil]])→ r6 Susp-norm(
[[A, k, k + 1,@k :: . . . :: @1 :: nil]] [[B, k, k + 1,@k :: . . . :: @1 :: nil]])
HI≡
se-norm(ϕ
2
kA ϕ
2
kB) ≡ se-norm(ϕ2ka)
• t1 = (λA) temos
Susp-norm([[(λA), k, k + 1,@k :: @k − 1 :: . . . :: @1 :: nil]])→ r7
Susp-norm((λ[[A, k + 1, k + 2,@k + 1 :: . . . :: @1 :: nil]]))
HI≡
se-norm((λϕ
2
k+1A)).
Por outro lado, ϕ2k(λA)→ σλ-trans(λϕ2k+1A). 2
Aqui vale salientar que essa correspondeˆncia na˜o ocorre de maneira o´bvia para
termos abertos. De fato, seja c uma constante qualquer. Por um lado, no λSusp,
temos que [[c, k, k + 1,@k :: . . . :: @1 :: nil]]→ r1 c. Mas por outro lado, no ca´lculo
λse temos que ϕ
2
kc e´ irredut´ıvel. Esses dois termos podem, num certo sentido,
serem considerados iguais pois a func¸a˜o ϕ2k na˜o vai modificar a constante c e esta
equivaleˆncia pode ser estabelecida num contexto mais amplo como, por exemplo,
em unificac¸a˜o de ordem superior.
Cap´ıtulo 3
Adequabilidade
Neste cap´ıtulo compararemos os ca´lculos λSusp, λse e λσ. Essa comparac¸a˜o
e´ feita no estilo de [KR00]. Isto nos permitira´ concluir que, num certo sentido, o
λse simula um passo de β-conversa˜o de maneira mais adequada que o λSusp. Intui-
tivamente, esta noc¸a˜o de adequabilidade esta´ relacionada com o comprimento das
simulac¸o˜es de um passo de β-conversa˜o. De forma que se um ca´lculo de substi-
tuic¸o˜es expl´ıcitas simula um passo de β-conversa˜o com derivac¸o˜es mais curtas ele
sera´ considerado mais adequado. A seguir definiremos formalmente adequabilidade.
Veremos que os ca´lculos λSusp e λσ sa˜o incompara´veis assim como tambe´m o sa˜o
o λse e o λσ. Informalmente isto significa que, no caso do λSusp e λσ, para algumas
simulac¸o˜es o λSusp se comporta de maneira mais adequada enquanto que para outras
o λσ e´ mais adequado.
3.1 Noc¸o˜es de Adequabilidade para Comparac¸a˜o
de Ca´lculos de Substituic¸o˜es Expl´ıcitas
Definic¸a˜o 3.1 ([KR00]) Dizemos que λξ1 e´ mais adequado que λξ2 (na simu-
lac¸a˜o de um passo de β-conversa˜o), denotado por λξ1 ≺ λξ2 se:
1. Para toda β-reduc¸a˜o A→ βB e para toda λξ2-simulac¸a˜o A→ nλξ2B existe uma
λξ1-simulac¸a˜o A→mλξ1B tal que m ≤ n.
2. Existe uma β-reduc¸a˜o A→ βB e uma λξ1-simulac¸a˜o A→mλξ1B tal que para toda
λξ2-simulac¸a˜o A→ nλξ2B temos m < n.
E´ fa´cil verificar que ≺ e´ transitiva e anti-sime´trica. De fato, suponha que λξ1 ≺
λξ2 e λξ2 ≺ λξ3 . De λξ2 ≺ λξ3 , temos que para toda β-conversa˜o A→ βB e para toda
34
35
λξ3-simulac¸a˜o A→ pλξ3B existe uma λξ2-simulac¸a˜o A→
n
λξ2
B com n ≤ p. Por outro
lado, como λξ1 ≺ λξ2 , para a mesma λξ2-simulac¸a˜o A→ nλξ2B citada acima existe
uma λξ1-simulac¸a˜o A→mλξ1B com m ≤ n. Sendo assim, para toda λξ3-simulac¸a˜o
A→ pλξ3B existe uma λξ1-simulac¸a˜o A→
m
λξ1
B com m ≤ p pois m ≤ n e n ≤ p. O
caso estrito e´ tratado de forma semelhante.
Para verificar que ≺ e´ anti-sime´trica, precisamos verificar que na˜o e´ o caso de
termos simultaneamente λξ1 ≺ λξ2 e λξ2 ≺ λξ1 . De fato, suponha verdadeiro λξ1 ≺
λξ2 , enta˜o, pela condic¸a˜o 2 da definic¸a˜o temos que existe uma β-conversa˜o A→ βB
e uma λξ1-simulac¸a˜o A→mλξ1B tal que para toda λξ2-simulac¸a˜o A→
n
λξ2
B temos
m < n. Suponha, por absurdo, que λξ2 ≺ λξ1 . Enta˜o, pela condic¸a˜o 1 da definic¸a˜o
podemos tomar a β-conversa˜o do caso anterior, obtendo que n ≤ m. Absurdo! Pois
m < n.
Segundo a definic¸a˜o de adequabilidade dada acima, para mostrar que dois ca´lculos,
por exemplo λξ1 e λξ2 , na˜o podem ser comparados basta encontrarmos duas β-
converso˜es cla´ssicas A→ βB e C→ βD tais que:
1. Existe uma simulac¸a˜o A→ λξ1B mais curta do que a mais curta das simulac¸o˜es
A→ λξ2B.
2. Existe uma simulac¸a˜o C→ λξ2D mais curta do que a mais curta das simulac¸o˜es
C→ λξ1D.
Neste caso dizemos que os ca´lculos λξ1 e λξ2 sa˜o incompara´veis.
3.2 Incomparabilidade entre Ca´lculos de Substi-
tuic¸o˜es Expl´ıcitas
3.2.1 Os Ca´lculos λσ e λse sa˜o Incompara´veis
Iniciaremos definindo duas func¸o˜es importantes para estimar comprimentos de
derivac¸o˜es nos ca´lculos que estamos trabalhando.
Definic¸a˜o 3.2 Sejam A,B ∈ ΛdB. Definimos a func¸a˜o M : ΛdB→N indutivamente
como segue:
• M(n) = 1
36
• M(A B) = M(A) +M(B) + 1
• M(λA) = M(A) + 1
Definic¸a˜o 3.3 Sejam A,B,C ∈ ΛdB e k ≥ 0. Definimos a func¸a˜o Qk : ΛdB ×
ΛdB→N indutivamente como segue:
• Qk(n, B) =
{
n se n < k
n+M(B) se n = k
k + 1 se n > k
• Qk(A B,C) = Qk(A,C) +Qk(B,C) + 1
• Qk(λA,B) = Qk+1(A,B) + 1
Em [KR00], Kamareddine e R´ıos mostraram que os ca´lculos λs e λσ sa˜o incom-
para´veis. Aqui extenderemos esse resultado para o λse:
Proposic¸a˜o 3.4 Os ca´lculos λse e λσ sa˜o incompara´veis.
Antes da demonstrac¸a˜o dessa proposic¸a˜o consideremos alguns lemas que sera˜o
importantes para estabelecer o resultado desejado. Os lemas a seguir foram tratados
por [KR00] apenas para o ca´lculo λs. Os enunciados aqui propostos extendem o
resultado para o λse. Note, no entanto, que essa extensa˜o e´ imediata ja´ que estamos
considerando termos puros do λ-ca´lculo.
Lema 3.5 ([KR00]) Para A ∈ ΛdB, toda se-derivac¸a˜o de ϕikA para sua forma
se-normal tem comprimento M(A).
Demonstrac¸a˜o.
Induc¸a˜o sobre a estrutura do termo A. 2
Lema 3.6 ([KR00]) Toda λse-derivac¸a˜o de (λλ(2 2)) 1
n para sua forma λse-normal
tem comprimento 4n+ 3
Demonstrac¸a˜o.
Considere a seguinte derivac¸a˜o (λλ(2 2)) 1n→ (λ(2 2))σ11n→ λ((2 2)σ21n)→
λ((2σ21n) (2σ21n)). Como as duas ocorreˆncias de (2σ21n) na˜o interagem entre si,
37
e´ suficiente mostrar que todas as derivac¸o˜es de (2σ21n) teˆm comprimento 2n. De
fato, (2σ21n) se reduz diretamente para ϕ20(1
n) cujo comprimento, de acordo com
o lema 3.5 e´ M(1n) que por sua vez e´ igual a 2n − 1. A derivac¸a˜o total, portanto,
tem comprimento 4n+ 3. 2
Lema 3.7 ([KR00]) Existe uma derivac¸a˜o de (λλ(2 2)) 1n para sua forma λσ-
normal cujo comprimento e´ n+ 9.
Demonstrac¸a˜o.
Basta considerar a seguinte derivac¸a˜o:
(λλ(2 2)) 1n =
(λλ(1[↑] 1[↑])) 1n→ Beta
(λ(1[↑] 1[↑]))[1n.id]→ Abs
λ((1[↑] 1[↑])[1.((1n.id)◦ ↑)])→Map
λ((1[↑] 1[↑])[1.(1n[↑].(id◦ ↑))])→ n−1App
λ((1[↑] 1[↑])[1.((1[↑])n.(id◦ ↑))])→ App
λ((1[↑][1.((1[↑])n.(id◦ ↑))]) (1[↑][1.((1[↑])n.(id◦ ↑))]))→ Clos
λ((1[↑ ◦(1.(1[↑])n.(id◦ ↑))]) (1[↑][1.((1[↑])n.(id◦ ↑))]))→ ShiftCons
λ((1[(1[↑])n.(id◦ ↑)]) (1[↑][1.((1[↑])n.(id◦ ↑))]))→ V arCons
λ((1[↑])n (1[↑][1.((1[↑])n.(id◦ ↑))]))→ 3
λ((1[↑])n (1[↑])n) = λ(2n 2n)
2
Demonstrac¸a˜o (da proposic¸a˜o 3.4)
Pelos lemas 3.6 e 3.7 temos que, para n ≥ 3, λse 6≺ λσ.
Por outro lado, e´ fa´cil ver que o termo (λ2) 1→ β1 tem simulac¸a˜o u´nica tanto no
λse quanto no λσ, cujos comprimentos sa˜o respectivamente iguais a 2 e 4. Portanto,
λσ 6≺ λse. 2
3.2.2 Os Ca´lculos λSusp e λσ sa˜o Incompara´veis.
Vejamos agora que os ca´lculos λSusp e λσ tambe´m sa˜o incompara´veis entre si.
Lema 3.8 Toda λSusp-derivac¸a˜o de (λλ(2 2))1
n para sua forma λSusp-normal tem
comprimento 4n+ 5.
38
Demonstrac¸a˜o.
De fato, note que a derivac¸a˜o a seguir e´ u´nica:
(λλ(2 2))1n→ βs
[[(λ(2 2)), 1, 0, (1n, 0) :: nil]]→ r7
λ[[(2 2), 2, 1,@0 :: (1n, 0) :: nil]]→ r6
λ([[2, 2, 1,@0 :: (1n, 0) :: nil]] [[2, 2, 1,@0 :: (1n, 0) :: nil]])→ 2r5
λ([[1, 1, 1, (1n, 0) :: nil]] [[1, 1, 1, (1n, 0) :: nil]])→ 2r4
λ([[1n, 0, 1, nil]] [[1n, 0, 1, nil]])→ 2(n−1)r6
λ(([[1, 0, 1, nil]])n ([[1, 0, 1, nil]])n)→ 2nr2
λ(2n 2n).
2
Lema 3.9 Todas as derivac¸o˜es de (λλ2) 1 para sua forma λσ-normal teˆm compri-
mento maior ou igual a 6.
Demonstrac¸a˜o.
De fato, as poss´ıveis derivac¸o˜es de (λλ2) 1 sa˜o:
• (λλ1[↑]) 1→ Beta (λ1[↑])[1.id]→ Abs λ1[↑][1.((1.id)◦ ↑)]→ Clos
λ1[↑ ◦(1.((1.id)◦ ↑))]→ ShiftCons λ1[(1.id)◦ ↑]→Map
λ1[1[↑].(id◦ ↑)]→ V arCons λ1[↑] = λ2;
• (λλ1[↑]) 1→ Beta (λ1[↑])[1.id]→ Abs λ1[↑][1.((1.id)◦ ↑)]→ Clos
λ1[↑ ◦(1.((1.id)◦ ↑))]→ ShiftCons λ1[(1.id)◦ ↑]→Map
λ1[1[↑].(id◦ ↑)]→ IdL λ1[1[↑]. ↑]→ V arCons λ1[↑] = λ2;
• (λλ1[↑]) 1→ Beta (λ1[↑])[1.id]→ Abs λ1[↑][1.((1.id)◦ ↑)]→ Clos
λ1[↑ ◦(1.((1.id)◦ ↑))]→Map λ1[↑ ◦(1.(1[↑].(id◦ ↑)))]→ ShiftCons
λ1[1[↑].(id◦ ↑)]→ V arCons λ1[↑] = λ2;
• (λλ1[↑]) 1→ Beta (λ1[↑])[1.id]→ Abs λ1[↑][1.((1.id)◦ ↑)]→ Clos
λ1[↑ ◦(1.((1.id)◦ ↑))]→Map λ1[↑ ◦(1.(1[↑].(id◦ ↑)))]→ ShiftCons
λ1[1[↑].(id◦ ↑)]→ IdL λ1[1[↑]. ↑]→ V arCons λ1[↑] = λ2;
• (λλ1[↑]) 1→ Beta (λ1[↑])[1.id]→ Abs λ1[↑][1.((1.id)◦ ↑)]→Map
λ1[↑][1.(1[↑].(id◦ ↑))]→ Clos λ1[↑ ◦(1.(1[↑].(id◦ ↑)))]→ ShiftCons
λ1[1[↑].(id◦ ↑)]→ V arCons λ1[↑] = λ2;
39
• (λλ1[↑]) 1→ Beta (λ1[↑])[1.id]→ Abs λ1[↑][1.((1.id)◦ ↑)]→Map
λ1[↑][1.(1[↑].(id◦ ↑))]→ Clos λ1[↑ ◦(1.(1[↑].(id◦ ↑)))]→ ShiftCons
λ1[1[↑].(id◦ ↑)]→ IdL λ1[1[↑]. ↑]→ V arCons λ1[↑] = λ2;
• (λλ1[↑]) 1→ Beta (λ1[↑])[1.id]→ Abs λ1[↑][1.((1.id)◦ ↑)]→Map
λ1[↑][1.(1[↑].(id◦ ↑))]→ IdL λ1[↑][1.(1[↑]. ↑)]→ Clos
λ1[↑ ◦(1.(1[↑]. ↑))]→ ShiftCons λ1[1[↑]. ↑]→ V arCons λ1[↑] = λ2.
2
Proposic¸a˜o 3.10 Os ca´lculos λSusp e λσ sa˜o incompara´veis.
Demonstrac¸a˜o.
Pelos lemas 3.8 e 3.7 temos que existe uma simulac¸a˜o (λλ(2 2)) 1n→ ∗λσ λ(2n 2n)
mais curta que a mais curta das simulac¸o˜es (λλ(2 2)) 1n→ ∗λSusp λ(2n 2n) sempre
que n > 1. Isto nos permite concluir que λSusp 6≺ λσ.
Por outro lado, considere a seguinte simulac¸a˜o no λSusp:
(λλ2)1→ βs
[[(λ2), 1, 0, (1, 0) :: nil]]→ r7
λ[[2, 2, 1,@0 :: (1, 0) :: nil]]→ r5
λ[[1, 1, 1, (1, 0) :: nil]]→ r4
λ[[1, 0, 1, nil]]→ r2λ2
Podemos, agora, utilizar o fato da derivac¸a˜o acima ter 5 passos juntamente com
o lema 3.9 para concluirmos que existe uma simulac¸a˜o (λλ2) 1→ ∗λSusp (λ2) mais
curta que a mais curta das simulac¸o˜es (λλ2) 1→ ∗λσ (λ2). Ou seja, λσ 6≺ λSusp. Isto
conclui a prova. 2
3.3 O Ca´lculo λse e´ mais adequado do que o λSusp.
Os lemas e proposic¸o˜es a seguir caminham no sentido de estimar os comprimen-
tos de derivac¸o˜es de termos no λSusp e λse.
Lema 3.11 Sejam A ∈ ΛdB, i ≥ 0 e [[A, i, i,@i− 1 :: . . . :: @0 :: nil]] um termo
bem-formado. Enta˜o toda Susp-derivac¸a˜o de [[A, i, i,@i− 1 :: . . . :: @0 :: nil]] para
sua forma Susp-normal tem comprimento maior ou igual a M(A).
40
Demonstrac¸a˜o.
Por induc¸a˜o sobre a estrutura do termo A temos que:
(1) A = n. Neste caso, temos que se n > i enta˜o [[n, i, i,@i− 1 :: . . . :: @0 :: nil]]→ ir5
[[n− i, 0, i, nil]]→ r2 n. Aqui a derivac¸a˜o tem comprimento i+ 1 ≥M(A).
Se n ≤ i enta˜o [[n, i, i,@i− 1 :: . . . :: @0 :: nil]]→ n−1r5
[[1, i− n+ 1, i,@i− n :: . . . :: @0 :: nil]]→ r3 n. O comprimento da derivac¸a˜o
acima e´ n ≥ 1 = M(A), como quer´ıamos.
(2) A = (B C). Neste caso, temos [[(B C), i, i,@i− 1 :: . . . :: @0 :: nil]]→ r6
[[B, i, i,@i− 1 :: . . . :: @0 :: nil]] [[C, i, i,@i− 1 :: . . . :: @0 :: nil]]. Agora utili-
zamos a hipo´tese de induc¸a˜o e concluimos que o comprimento da derivac¸a˜o
acima e´ maior ou igual a 1 +M(B) +M(C) = M(B C) = M(A).
(3) A = (λB). Agora temos [[(λB), i, i,@i− 1 :: . . . :: @0 :: nil]]→ r7
λ[[B, i+ 1, i+ 1,@i :: . . . :: @0 :: nil]]. Agora aplicamos a hipo´tese de induc¸a˜o
e conclu´ımos que a derivac¸a˜o acima tem comprimento maior ou igual a 1 +
M(B) = M(λB) = M(A).
2
Lema 3.12 Para B ∈ ΛdB e i, j ≥ 0, a derivac¸a˜o do termo bem-formado
[[B, i, j,@j − 1 :: e]] para sua forma Susp-normal tem comprimento maior ou igual
a M(B).
Demonstrac¸a˜o.
De fato, se B = n enta˜o [[n, i, j,@j − 1 :: e]] se reduz a sua forma Susp-normal
em 1 ou mais passos conforme n seja 1 ou maior do que 1, respectivamente. Como
M(B) = 1 temos o resultado desejado.
Quando B = (C D) temos
[[(C D), i, j,@j − 1 :: e]]→ r6 [[C, i, j,@j − 1 :: e]] [[D, i, j,@j − 1 :: e]].
Agora aplicando a hipo´tese de induc¸a˜o temos o resultado desejado.
Por fim, quando B = (λC) temos
[[(λC), i, j,@j − 1 :: e]]→ r7 λ[[C, i+ 1, j + 1,@j :: e′]].
41
Aplicando a hipo´tese de induc¸a˜o temos o resultado desejado. 2
Proposic¸a˜o 3.13 Sejam A,B ∈ ΛdB e k ≥ 0. Enta˜o toda Susp-derivac¸a˜o do termo
bem-formado
[[A, k, k − 1,@k − 2 :: . . . :: @0 :: (B, l) :: nil]]
para sua forma Susp-normal tem comprimento maior ou igual a Qk(A,B).
Demonstrac¸a˜o.
Por induc¸a˜o sobre a estrutura de A temos que:
(1) A = n. Temos o termo [[n, k, k − 1,@k − 2 :: . . . :: @0 :: (B, l) :: nil]].
Se n < k enta˜o [[n, k, k − 1,@k − 2 :: . . . :: @0 :: (B, l) :: nil]]→ n−1r5
[[1, k − n+ 1, k − 1,@k − n− 1 :: . . . :: @0 :: (B, l) :: nil]]→ r3 n. O compri-
mento dessa derivac¸a˜o foi n ≥ Qk(n, B) como quer´ıamos.
Se n = k enta˜o [[n, k, k − 1,@k − 2 :: . . . :: @0 :: (B, l) :: nil]]→ n−1r5
[[1, 1, k − 1, (B, l) :: nil]]→ r4 [[B, 0, k − 1− l, nil]]. Pelo lema 3.12 este u´ltimo
termo se reduz a sua forma Susp-normal em M(B) ou mais passos. Logo a
derivac¸a˜o completa tem comprimento maior ou igual a n+M(B) = Qk(n, B) =
Qk(A,B).
Se n > k enta˜o [[n, k, k − 1,@k − 2 :: . . . :: @0 :: (B, l) :: nil]]→ kr5
[[n− k, 0, k − 1, nil]]→ r2 n− 1. O comprimento dessa derivac¸a˜o foi k + 1 ≥
Qk(n, B) = Qk(A,B) como quer´ıamos.
(2) A = (C D). Temos [[(C D), k, k − 1,@k − 2 :: . . . :: @0 :: (B, l) :: nil]]→ r6
[[C, k, k − 1,@k − 2 :: . . . :: @0 :: (B, 0) :: nil]]
[[D, k, k − 1,@k − 2 :: . . . :: @0 :: (B, 0) :: nil]].
Aplicando a hipo´tese de induc¸a˜o temos que a derivac¸a˜o completa tem compri-
mento maior ou igual a 1 +Qk(C,B) +Qk(D,B) = Qk(C D,B) = Qk(A,B).
(3) A = (λC). Temos [[(λC), k, k − 1,@k − 2 :: . . . :: @0 :: (B, l) :: nil]]→ r7
λ[[C, k + 1, k,@k − 1 :: . . . :: @0 :: (B, l) :: nil]]. Agora aplicamos a hipo´tese de
induc¸a˜o e concluimos que esta derivac¸a˜o tem comprimento maior ou igual a
1 +Qk+1(C,B) = Qk(λC,B) = Qk(A,B).
42
2
Proposic¸a˜o 3.14 Quaisquer que sejam A,B ∈ ΛdB e k ≥ 0, toda se-derivac¸a˜o de
Aσk+1B para sua forma se-normal tem comprimento menor ou igual a Qk+1(A,B).
Demonstrac¸a˜o.
A demonstrac¸a˜o e´ feita por induc¸a˜o sobre a estrutura do termo A:
• A = n. Temos nσk+1B→
 n− 1 se n > k + 1ϕk+10 B se n = k + 1n se n < k + 1
Nos casos n > k+1 e n < k+1 a derivac¸a˜o tem comprimento 1 e, claramente,
1 ≤ Qk+1(n, B),∀n, pois Qk+1(n, B) ≥ 1,∀n. Portanto a derivac¸a˜o com-
pleta tem comprimento menor ou igual a Qk+1(n, B) = Qk+1(A,B). Quando
n = k + 1 utilizamos o lema 3.5 para concluirmos que ϕk+10 B se reduz a sua
forma se-normal em M(B) passos. Assim, a derivac¸a˜o completa tem compri-
mento 1 +M(B). Observando a definic¸a˜o da func¸a˜o Qk+1 concluimos que esse
comprimento e´ sempre menor ou igual a Qk+1(n, B) = Qk+1(A,B).
• A = (C D). Temos (C D)σk+1B→ Cσk+1B Dσk+1B. Aplicando a hipo´tese
de induc¸a˜o concluimos que esta derivac¸a˜o tem comprimento menor ou igual a
1 +Qk+1(C,B) +Qk+1(D,B) = Qk+1(C D,B) = Qk+1(A,B).
• A = (λC). Temos (λC)σk+1B→ λCσk+2B. Agora aplicamos a hipo´tese de
induc¸a˜o e concluimos que essa derivac¸a˜o tem comprimento menor ou igual a
1 +Qk+2(C,B) = Qk+1(λC,B) = Qk+1(A,B).
2
Teorema 3.15 O ca´lculo λse e´ mais adequado do que o ca´lculo λSusp.
Demonstrac¸a˜o.
Precisamos mostrar que para qualquer β-conversa˜o A→ βB, com A,B ∈ ΛdB,
toda λSusp-simulac¸a˜o A→ βs B′→mSuspSusp-norm(B′) = B, existe n ≤ m tal que
A→ σ−genC→ ns s-norm(C) = B.
43
No λSusp para qualquer redex onde possamos aplicar a regra βs temos (λD) E→ βs
[[D, 1, 0, (E, 0) :: nil]]→mSusp Susp-norm([[D, 1, 0, (E, 0) :: nil]]), onde pela proposic¸a˜o
3.13, temos que
m ≥ Q1(D,E) (3.1)
Por outro lado, no λse temos (λD) E→ σ−genDσ1E→ ns s-norm(Dσ1E), onde
pela proposic¸a˜o 3.14 temos que toda se-derivac¸a˜o de Dσ
1E para a sua forma se-
normal satisfaz
n ≤ Q1(D,E) (3.2)
De 3.1 e 3.2 concluimos que para qualquer λSusp-simulac¸a˜o A→ βsB′→mSuspSusp-
norm(B′) = B, toda λse-simulac¸a˜o A→ σ−genC→ ns se-norm(C) = B tem compri-
mento n ≤ m.
Para que a segunda condic¸a˜o de adequabilidade seja satisfeita precisamos apre-
sentar uma β-conversa˜o do λ-ca´lculo cuja λse-simulac¸a˜o seja estritamente menor do
que sua respectiva λSusp-simulac¸a˜o. Considere, portanto, a seguinte β-conversa˜o:
(λ2) 1→ β1.
No λSusp esta β-conversa˜o pode ser simulada de maneira u´nica, em 3 passos,
como podemos ver abaixo:
(λ2) 1→ βs [[2, 1, 0, (1, 0) :: nil]]→ r5 [[1, 0, 0, nil]]→ r21.
Ja´ no λse a mesma simulac¸a˜o se da´ de forma u´nica, em apenas 2 passos:
(λ2) 1→ σ−gen 2σ11→ σ−destr1. Isto finaliza a demonstrac¸a˜o. 2
Note que aqui demonstramos muito mais do que a noc¸a˜o de adequabilidade de
[KR00]. De fato, provamos que o comprimento de qualquer λse-simulac¸a˜o e´ sempre
menor ou igual que qualquer λSusp-simulac¸a˜o de um passo de β-conversa˜o.
Vejamos um exemplo que nos mostra claramente como as simulac¸o˜es de um
passo de β-conversa˜o no λse sa˜o mais curtas que no λSusp. O exemplo que escolhe-
mos constitui-se de um β-redex simples onde so´ e´ poss´ıvel aplicar a regra que inicia
a simulac¸a˜o de uma β-conversa˜o, este redex e´ dado por ((λ(λn i)) j), onde n ≥ 0
e i, j ≥ 1. Veja que este e´ um exemplo adequado porque termos que contenham
aplicac¸o˜es adicionais va˜o apenas duplicar o trabalho a ser feito e, termos com cons-
tantes, ou meta-varia´veis, na˜o nos interessam agora. Termos que possuem diversos
abstratores sa˜o importantes porque ambos os ca´lculos trabalham da mesma forma
ao entrar dentro de abstratores. A diferenc¸a se da´ quando atingimos ı´ndices de
De Bruijn. Vejamos, enta˜o, a simulac¸a˜o de um passo de β-conversa˜o para o redex
44
((λ(λn i)) j) no λSusp. No caso em que i < n+ 1, temos
((λ(λn i)) j)→ βs
[[(λni), 1, 0, (j, 0) :: nil]]→ nr7
λn[[i, n+ 1, n,@n− 1 :: . . . :: @0 :: (j, 0) :: nil]]→ i−1r5
λn[[1, n− i+ 2, n,@n− i :: . . . :: @0 :: (j, 0) :: nil]]→ r3 λni.
Esta reduc¸a˜o tem um total de n+ i+ 1 passos.
Quando i = n+ 1, temos
((λ(λn i)) j)→ βs [[(λni), 1, 0, (j, 0) :: nil]]→ nr7
λn[[i, n+ 1, n,@n− 1 :: . . . :: @0 :: (j, 0) :: nil]]→ i−1r5
λn[[1, 1, n, (j, 0) :: nil]]→ r4 λn[[j, 0, n, nil]]→ r2 λnj + n.
Aqui a reduc¸a˜o total tem comprimento n+ i+ 2.
Por fim quando, i > n+ 1 temos
((λ(λn i)) j)→ βs [[(λni), 1, 0, (j, 0) :: nil]]→ nr7
λn[[i, n+ 1, n,@n− 1 :: . . . :: @0 :: (j, 0) :: nil]]→ n+1r5
λn[[i− n− 1, 0, n, nil]]→ r2 λni− 1.
Aqui a reduc¸a˜o tem comprimento 2n+ 3.
A mesma simulac¸a˜o no λse pode ser vista da seguinte forma:
((λ(λn i)) j)→ σ-gen (λni)σ1j→ nσ-λ λniσn+1j.
Agora se i < n + 1 ou i > n + 1, com uma aplicac¸a˜o de σ-destruction o termo
anterior reduz-se, respectivamente, para λni e λni− 1. Note que ambas reduc¸o˜es
teˆm comprimento n+ 2.
No caso em que i = n+1, apo´s uma aplicac¸a˜o de σ-destruction o termo λniσn+1j
se reduz para λnϕn+10 j, que apo´s uma aplicac¸a˜o de ϕ-destruction se reduz para
λnj + n. Isto nos da´ um reduc¸a˜o cujo comprimento total e´ igual a n+ 3.
Os comprimentos das derivac¸o˜es em cada caso podem ser melhor visualizados
pela tabela abaixo:
45
λse λSusp
i < n+ 1 n+ 2 n+ i+ 1
i = n+ 1 n+ 3 n+ i+ 2
i > n+ 1 n+ 2 2n+ 3
Como i ≥ 1 e´ fa´cil ver que qualquer simulac¸a˜o de um passo de β-conversa˜o do
redex dado acima tem sempre comprimento menor no λse, exceto quando i = 1,
pois neste caso os comprimentos das reduc¸o˜es sa˜o iguais. Em todos os outros casos
e´ evidente a vantagem do λse sobre o λSusp ja´ que o primeiro consegue reduzir
ı´ndices de De Bruijn de qualquer valor em um u´nico passo (via regra σ-destruction),
enquanto que o λSusp precisa reduz´ı-los um a um por meio da regra r5 ate´ que o
contexto fique vazio e seja poss´ıvel aplicar r2, ou ate´ que os ı´ndices de De Bruijn
sejam decrementados ate´ 1 e seja poss´ıvel aplicar a regra r3.
Cap´ıtulo 4
Uma Implementac¸a˜o para os
Ca´lculos λσ, λse e λSusp com a
Eta-conversa˜o
Uma outra contribuic¸a˜o deste trabalho e´ a implementac¸a˜o de um ambiente que
simula β-converso˜es e η-converso˜es de λ-termos via ca´lculo λσ, λse ou λSusp. A
importaˆncia de uma tal implementac¸a˜o esta´, ale´m do tempo e confiabilidade que
se ganham em uma simulac¸a˜o de um passo de β-conversa˜o, no fato de que muito
se pode aprender sobre a estrutura interna dos ca´lculos utilizados. Adicionalmente,
a construc¸a˜o dessa implementac¸a˜o foi um bom exerc´ıcio sobre tipagem impl´ıcita,
ja´ que a linguagem utilizada para a mesma foi o Ocaml, da famı´lia ML, que uti-
liza este tipo de tipagem. A escolha dessa linguagem se deu basicamente pela fa-
cilidade de se trabalhar com λ-termos e pela simplicidade no manuseio de tipos
para termos, substituic¸o˜es, contextos e listas de contextos dos ca´lculos tratados.
Uma versa˜o pre´-compilada e o co´digo dessa implementac¸a˜o podem ser obtidos em
http://www.mat.unb.br/~ayala/TCgroup/.
Nossa implementac¸a˜o consiste basicamente de treˆs ambientes, distintos e inde-
pendentes entre si, onde foram implementadas as regras dos treˆs ca´lculos citados
acima. Assim, dado um λ-termo t qualquer podemos simular a reduc¸a˜o de t a
sua forma ξ-normal, onde ξ ∈ {σ, se, Susp}, passo a passo em qualquer um desses
ca´lculos. A regra Eta tambe´m foi implementada nos treˆs casos.
Observe que esta implementac¸a˜o foi constru´ıda com o objetivo de simular alguns
exemplos simples de β-conversa˜o e η-conversa˜o. Portanto, como o mesmo na˜o faz
parte de um sistema maior, na˜o nos preocupamos muito em construir um co´digo
que fosse o mais eficiente poss´ıvel. Nossa preocupac¸a˜o fundamental foi em relac¸a˜o
46
47
a` corretude do mesmo. Nesse sentido sabemos que algumas modificac¸o˜es podem ser
feitas para melhorar a eficieˆncia do programa.
Para o λσ considere, por exemplo, a regra Abs, que e´ dada por
(λM)[S]→λM [1.(S◦ ↑)]
Devemos observar que o ca´lculo λσ trabalha com dois tipos de objetos, a saber,
termos e substituic¸o˜es. Portanto nossa implementac¸a˜o deve diferenciar esses tipos
e trabalhar de forma correta com cada um deles. Como sabemos, os termos do λσ
sa˜o da forma 1, λM , (M N) ou M [S] que representamos, na linguagem Ocaml,
respectivamente por One, L(M), A(M,N) ou Sb(M,S). Ja´ as substituic¸o˜es podem ser
da forma id, ↑, M.S ou S ◦ T , representadas, respectivamente por Id, Up, Pt(M,S)
ou Cp(S,T). A implementac¸a˜o das regras de uma forma geral e´ constitu´ıda de dois
passos. Primeiro fazemos uma busca sobre o termo dado a procura de poss´ıveis
re´dices onde a regra possa ser aplicada. O segundo passo constitui da aplicac¸a˜o da
regra propriamente dita ao redex encontrado e selecionado. No caso em que existam
mais de um redex na mesma expressa˜o, o usua´rio deve escolher em qual posic¸a˜o
a reduc¸a˜o deve ser feita. A busca por re´dices para a regra Abs e´ feita pela func¸a˜o
matchingAbs de tipo lista de posic¸o˜es, onde exp e´ a expressa˜o, l acumula as posic¸o˜es
dos re´dices e pos e´ a posic¸a˜o atual.
let rec matchingAbs exp l pos =
match exp with
Dummy -> l |
One -> l |
Vr c -> l |
A(e1,e2) -> append (matchingAbs e1 l (append pos [1]))
(matchingAbs e2 [] (append pos [2])) |
L(e1) -> matchingAbs e1 l (append pos [1]) |
Sb(L(e1),sb) -> pos :: append
(matchingAbs e1 l (append pos [1;1]))
(matchingAbsSb sb [] (append pos [2])) |
Sb(e1,sb) -> append (matchingAbs e1 l (append pos [1]))
(matchingAbsSb sb [] (append pos [2]))
and
matchingAbsSb subs l pos =
match subs with
Up -> l |
Id -> l |
Pt(e1,sb) -> append (matchingAbs e1 l (append pos [1]))
(matchingAbsSb sb [] (append pos [2])) |
Cp(s1,s2) -> append (matchingAbsSb s1 l (append pos [1]))
(matchingAbsSb s2 [] (append pos [2]));;
Note que a busca e´ dividida em duas etapas: a busca sobre expresso˜es do tipo
termo e a busca sobre expresso˜es do tipo substituic¸a˜o.
48
A aplicac¸a˜o da regra Abs a` expressa˜o exp na posic¸a˜o pr e´ dada pela func¸a˜o
absreduction abaixo:
let rec absreduction exp pr =
match pr with
[] -> (match exp with
Sb(L(e1),sb) -> L(Sb(e1,Pt(One,Cp(sb,Up)))) | _ -> exp) |
1 :: tail -> (match exp with
Dummy -> exp |
One -> exp |
Vr c -> exp |
A(e1,e2) -> A((absreduction e1 tail),e2) |
L(e1) -> L(absreduction e1 tail) |
Sb(e1,s2) -> Sb((absreduction e1 tail),s2)) |
2 :: tail -> (match exp with
Dummy -> exp |
One -> exp |
Vr c -> exp |
L(e1) -> exp |
A(e1,e2) -> A(e1,(absreduction e2 tail)) |
Sb(e1,s2)-> Sb(e1,(absreductionSb s2 tail))) |
_ -> exp
and
absreductionSb subs pr =
match pr with
[] -> subs |
1 :: tail -> (match subs with
Id -> subs |
Up -> subs |
Cp(s1,s2) -> Cp((absreductionSb s1 tail),s2) |
Pt(e1,s2) -> Pt((absreduction e1 tail),s2)) |
2 :: tail -> (match subs with
Id -> subs |
Up -> subs |
Cp(s1,s2) -> Cp(s1,(absreductionSb s2 tail)) |
Pt(e1,s2)-> Pt(e1,(absreductionSb s2 tail))) |
_ -> subs ;;
Aqui, da mesma forma, o trabalho e´ dividido em duas partes, uma para reduc¸a˜o
sobre termos e outra sobre substituic¸o˜es. Isto ilustra a facilidade de se lidar com
tipagem impl´ıcita no Ocaml. As outras regras sa˜o implementadas de forma ana´loga.
No λse a construc¸a˜o e´ feita de forma semelhante com a observac¸a˜o de que agora
na˜o temos mais dois tipos de expresso˜es, mas apenas um. De fato, as expresso˜es do
λse sa˜o da forma n, (M N), λM , Mσ
iN ou ϕikM que representamos, em Ocaml,
respectivamente, por DB n, A(M,N), L(M), S(i,M,N) ou P(k,i,M). A estrutura da
func¸a˜o para a busca de re´dices para a regra σ-λ-transition e´:
let rec matchingSLtransition exp l pos =
match exp with
Dummy -> l|
DB i -> l |
49
Vr c -> l |
A(e1,e2) -> append
(matchingSLtransition e1 l (append pos [1]))
(matchingSLtransition e2 [] (append pos [2])) |
L(e1) -> (matchingSLtransition e1 l (append pos [1])) |
S(i,L(e1),e2) -> pos :: append
(matchingSLtransition e1 l (append pos [1;1]))
(matchingSLtransition e2 [] (append pos [2])) |
S(i,e1,e2) -> append
(matchingSLtransition e1 l (append pos [1]))
(matchingSLtransition e2 [] (append pos [2])) |
P(j,k,e1) -> (matchingSLtransition e1 l (append pos [1]));;
Ja´ a func¸a˜o de aplicac¸a˜o da regra σ-λ-transition e´:
let rec sltransition exp pr =
match pr with
[] -> (match exp with
S(i,L(e1),e2) -> L(S(i+1,e1,e2)) | _ -> exp) |
1 :: tail -> (match exp with
A(e1,e2) -> A((sltransition e1 tail),e2) |
L(e1) -> L(sltransition e1 tail) |
S(i,e1,e2)-> S(i,(sltransition e1 tail),e2) |
P(j,k,e1) -> P(j,k,(sltransition e1 tail)) |
_ -> exp ) |
2 :: tail -> (match exp with
A(e1,e2) -> A(e1,(sltransition e2 tail)) |
S(i,e1,e2)-> S(i,e1,(sltransition e2 tail)) |
_ -> exp ) |
_ -> exp;;
O ca´lculo λSusp ja´ possui uma estrutura mais complicada que a dos ca´lculos an-
teriores. De fato, as expresso˜es no λSusp podem ser de treˆs tipos distintos: termos
suspensos, contextos ou termos de contextos. Os termos suspensos, por sua vez,
podem ser C, n, (M N), λM ou [[t, i, j, e]] que representamos, em Ocaml, respecti-
vamente por Vr c, DB n, A(M,N), L(M) ou Sp(t,i,j,e). Os contextos podem ser
nil, et :: e ou { env1, i, j, env2} , que representamos, respectivamente, por Nilen,
Con(et,e) ou Ck(env1,i,j,env2). Os termos de contexto podem ser @n, (t, l)
ou 〈〈envt, i, j, env〉〉 que representamos, respectivamente, por Ar(n), Paar(t,l) ou
LG(envt,i,j,env).
A func¸a˜o de busca de re´dices para a regra (r7) e´ dada por:
let rec matching_r7 exp l pos =
match exp with
Dummy -> l |
DB i -> l |
Vr c -> l |
A(e1,e2) -> append (matching_r7 e1 l (append pos [1]))
(matching_r7 e2 [] (append pos [2])) |
50
L(e1) -> (matching_r7 e1 l (append pos [1])) |
Sp(L(e1),_,_,env) -> pos :: append
(matching_r7 e1 l (append pos [1;1]))
(matchingEnv_r7 env [] (append pos [2])) |
Sp(e1,_,_,env) -> append (matching_r7 e1 l (append pos [1]))
(matchingEnv_r7 env [] (append pos [2]))
and matchingEnv_r7 env l pos =
match env with
Nilen -> l |
Con(envt, env1) -> append
(matchingEt_r7 envt l (append pos [1]))
(matchingEnv_r7 env1 [] (append pos [2])) |
Ck(env1,_,_,env2) -> append
(matchingEnv_r7 env1 l (append pos [1]))
(matchingEnv_r7 env2 [] (append pos [2]))
and matchingEt_r7 envt l pos =
match envt with
Ar i -> l |
LG(envt1,_,_,env1) -> append
(matchingEt_r7 envt1 l (append pos [1]))
(matchingEnv_r7 env1 [] (append pos [2]))|
Paar(e1,i) -> (matching_r7 e1 l (append pos [1]));;
E a func¸a˜o para reduc¸a˜o da expressa˜o exp na posic¸a˜o pr da regra (r7) e´ dada
por:
let rec r7_reduction exp pr =
match pr with
[] -> (match exp with
Sp(L(e1),i,j,env) -> L(Sp(e1,i+1,j+1,Con(Ar(j),env)))|
_ -> exp ) |
1 :: tail -> (match exp with
A(e1,e2) -> A((r7_reduction e1 tail),e2) |
L(e1) -> L(r7_reduction e1 tail) |
Sp(e1,i,j,env) -> Sp((r7_reduction e1 tail),i,j,env) |
_ -> exp) |
2 :: tail -> (match exp with
A(e1,e2) -> A(e1,(r7_reduction e2 tail)) |
Sp(e1,i,j,env) -> Sp(e1,i,j,(r7_reductionEnv env tail)) |
_ -> exp)
and
r7_reductionEnv env pr =
match pr with
1 :: tail -> (match env with
Con(envt,env1) ->
Con((r7_reductionEt envt tail),env1) |
Ck(env1,i,j,env2) ->
Ck((r7_reductionEnv env1 tail),i,j,env2) |
_ -> env) |
2 :: tail -> (match env with
Con(envt,env1) ->
Con(envt,(r7_reductionEnv env1 tail)) |
Ck(env1,i,j,env2) ->
Ck(env1,i,j,(r7_reductionEnv env2 tail)) |
_ -> env)
and
r7_reductionEt envt pr =
match pr with
51
1 :: tail -> (match envt with
Paar(e1,i) ->
Paar((r7_reduction e1 tail),i) |
LG(envt1,i,j,env1) ->
LG((r7_reductionEt envt1 tail),i,j,env1) |
_ -> envt) |
2 :: tail -> (match envt with
LG(envt1,i,j,env1) ->
LG(envt1,i,j,(r7_reductionEnv env1 tail)) |
_ -> envt);;
4.1 A implementac¸a˜o da regra Eta
Um aspecto interessante que vale a pena ser ressaltado e´ a maneira como a
regra Eta foi implementada para os treˆs ca´lculos. Essa etapa contribuiu muito para
uma melhor compreensa˜o da estrutura desses ca´lculos, pois que a implementac¸a˜o
desta regra na˜o e´ trivial. De fato, observe que dado um termo qualquer t ∈ ΛdB e´
sempre fa´cil decidir qual regra do sistema de reescrita (λσ, λse, λSusp) que devemos
utilizar, pois essas regras sa˜o incondicionais ou possuem apenas uma condic¸a˜o arit-
me´tica simples que pode ser resolvida por algum algoritmo de deduc¸a˜o aritme´tica
usualmente pre´-constru´ıdo nas linguagens de programac¸a˜o modernas. O mesmo, no
entanto, na˜o acontece com a regra Eta pois a condic¸a˜o de aplicac¸a˜o da mesma e´ mais
complexa. Para contornar esse problema apresentamos um teste para implementac¸a˜o
da regra Eta desenvolvido a partir das ide´ias de [Bor95] para o λσ e [ARK01a] para
o λse. Essa ide´ia foi comentada superficialmente ao considerarmos a prova do lema
2.21.
Para entendermos melhor o que sera´ feito, observe que, a η-conversa˜o λ(M 1)→ η
N deve nos fornecer um termo N , obtido de M decrementando todas as suas
varia´veis livres em 1. Mas isto, segundo a ide´ia de [Bor95], consiste exatamente
em normalizar o termo ((λM) 3), no caso em que 3 na˜o ocorra na forma normal
de ((λM) 3), onde 3 e´ um s´ımbolo de constante que na˜o pertenc¸a a` linguagem
do ca´lculo considerado. Isto pode ser resumido de forma mais objetiva atrave´s da
seguinte regra: Seja genλξ(M, pos) o resultado de se aplicar a regra que inicia a
simulac¸a˜o de um passo de β-conversa˜o ao termo M na posic¸a˜o pos. Enta˜o
λ(M 1)→ EtaN se N = norm(genλξ(((λM) 3), raiz))
e 3 na˜o ocorre em N , para ξ ∈ {σ, se, Susp}.
Essa ide´ia ja´ foi mostrada correta para o λσ [Bor95] e para o λse [ARK01a].
52
Vejamos agora que esta implementac¸a˜o tambe´m e´ correta para o λSusp.
Proposic¸a˜o 4.1 A implementac¸a˜o descrita acima pela regra (EtaSusp) e´ “correta”
no sentido expresso na proposic¸a˜o 2.9.
Antes de demonstrarmos essa proposic¸a˜o consideremos o seguinte:
Lema 4.2 Sejam A e B termos bem-formados e k ≥ 0. Enta˜o a rm-normalizac¸a˜o
do termo bem-formado [[A, k, k − 1,@k − 2 :: . . . :: @0 :: (B, l) :: nil]] nos fornece um
novo termo que decrementa em 1 todas as varia´veis livres de A maiores do que k,
substitui a k-e´sima varia´vel de A pelo termo B atualizado de forma correta de acordo
com sua estrutura e, deixa inalteradas todas as varia´veis de A menores do que k.
Demonstrac¸a˜o.
Por induc¸a˜o sobre a estrutura do termo A, temos:
1. Se A = n enta˜o,
(a) se n > k enta˜o [[n, k, k − 1,@k − 2 :: . . . :: @0 :: (B, l) :: nil]]→ kr5
[[n− k, 0, k − 1, nil]]→ r2n− 1;
(b) se n = k enta˜o [[n, k, k − 1,@k − 2 :: . . . :: @0 :: (B, l) :: nil]]→ k−1r5
[[1, 1, k − 1, (B, l) :: nil]]→ r4 [[B, 0, k − l − 1, nil]];
(c) se n < k enta˜o [[n, k, k − 1,@k − 2 :: . . . :: @0 :: (B, l) :: nil]]→ n−1r5
[[1, k − n+ 1, k − 1,@k − n− 1 :: . . . :: @0 :: (B, l) :: nil]]→ r3n;
2. Se A = (C D) enta˜o aplicamos a hipo´tese de induc¸a˜o para os termos C e D;
3. Se A = (λC), como o termo C esta´ limitado por um abstrator adicional,
enta˜o apenas as varia´veis livres de C maiores do que k + 1 e´ que devem ser
decrementadas em 1, a k+ 1-e´sima varia´vel deve ser substituida pelo termo B
atualizado de forma correta de acordo com sua estrutura e, as outras varia´veis
devem permanecer inalteradas.
Como [[(λC), k, k − 1,@k − 2 :: . . . :: @0 :: (B, l) :: nil]]→ r7
λ[[C, k + 1, k,@k − 1 :: . . . :: @0 :: (B, l) :: nil]], aplicamos a hipo´tese de induc¸a˜o
para o termo [[C, k + 1, k,@k − 1 :: . . . :: @0 :: (B, l) :: nil]] e obtemos o resul-
tado desejado.
53
4. Se A = [[t, ol, nl, e]] enta˜o primeiro determinamos a forma rm-normal do termo
A. Pelo lema 2.7 temos que rm-norm(A) e´ um termo puro na notac¸a˜o de De
Bruijn e, portanto a ana´lise desse caso recai em um dos casos anteriores.
2
Demonstrac¸a˜o da proposic¸a˜o 4.1. Inicialmente observe que o termo
[[M, 1, 0, (3, 0) :: nil]] e´ obtido a partir da aplicac¸a˜o da regra βs na raiz do termo
((λM) 3). Apo´s a propagac¸a˜o do s´ımbolo 3, todas as varia´veis livres de M sa˜o
decrementadas em 1 exceto aquelas que correspondam ao abstrator externo que
devera˜o ser substitu´ıdas pelo s´ımbolo 3. A demonstrac¸a˜o desse fato e´ feita por
induc¸a˜o sobre a estrutura do termo M :
• Se M = n enta˜o,
(a) se n = 1 temos [[n, 1, 0, (3, 0) :: nil]]→ r4 [[3, 0, 0, nil]]→ r13, como era
esperado pois 3 pode ser considerado como um s´ımbolo de constante;
(b) se n > 1 temos [[n, 1, 0, (3, 0) :: nil]]→ r5 [[n− 1, 0, 0, nil]]→ r2n− 1.
• Se M = (A B) enta˜o aplicamos a hipo´tese de induc¸a˜o aos termos A e B e o
resultado e´ imediato ja´ que as ocorreˆncias de varia´veis no termo A na˜o teˆm
interfereˆncia junto as varia´veis do termo B.
• Se M = (λA) enta˜o [[(λA), 1, 0, (3, 0) :: nil]]→ r7 λ[[A, 2, 1,@0 :: (3, 0) :: nil]].
Pelo lema 4.2 todas as varia´veis livres de A maiores que 2 sa˜o decrementadas
em 1, a segunda varia´vel livre, que corresponde ao abstrator que foi eliminado
na βs-reduc¸a˜o, e´ substituida pelo s´ımbolo 3 enquanto que todas as outras
varia´veis permanecem inalteradas.
• Se M = [[t, ol, nl, e]] enta˜o primeiro rm-normalizamos o termo M . Como, pelo
lema 2.7, o termo rm-norm(M) e´ um termo puro na notac¸a˜o de De Bruijn,
temos que a ana´lise desse caso recai em um dos casos anteriores.
Ale´m disso, quando o termo rm-norm([[M, 1, 0, (3, 0) :: nil]]) na˜o possui o s´ımbolo
3, ao incrementarmos todas as suas varia´veis livres, obteremos um termo rm-
equivalente ao termo M . Isto corresponde a condic¸a˜o original para aplicac¸a˜o da
regra η. A demonstrac¸a˜o dessa rm-equivaleˆncia e´ feita por induc¸a˜o sobre a estru-
tura do termo M de maneira equivalente ao caso anterior. Assim, temos que ao
54
incrementarmos todas as varia´veis livres de rm-norm([[M, 1, 0, (3, 0) :: nil]]), obte-
remos um termo rm-equivalente ao termo M . 2
Vejamos agora como foram constru´ıdas as func¸o˜es, em Ocaml, para implementac¸a˜o
das regras Etaξ para ξ ∈ {σ, se, Susp}. Seja M um termo qualquer pertencente a`
linguagem do ca´lculo λξ. Nossa proposta consiste em uma adaptac¸a˜o da ide´ia an-
teriormente apresentada onde a normalizac¸a˜o do termo ((λM) 3) deve ser feita de
forma apropriada, isto e´, para λ(M 1)→ ηN , queremos uma normalizac¸a˜o que nos
fornec¸a exatamente o termo N acima. Se simplesmente ξ-normalizarmos ((λM) 3),
obteremos provavelmente um termo mais simples do que N porque foram aplicadas
regras adicionais que na˜o eram necessa´rias. Nossa normalizac¸a˜o deve apenas propa-
gar o s´ımbolo 3, e deixar inalterados subtermos que na˜o contenham este s´ımbolo.
Como esta e´ uma normalizac¸a˜o especial, a denominaremos a partir de agora de
ξ-pseudo-normalizac¸a˜o.
A implementac¸a˜o de nossas regras Etaξ, como todas as demais, se subdivide em
duas etapas. A primeira busca um redex onde a regra se aplique. A segunda etapa
faz a ξ-pseudo-normalizac¸a˜o propriamente dita. Para que um subtermo da forma
λ(M 1) seja um redex para a regra Etaξ e´ necessa´rio e suficiente que o termo M
na˜o contenha a varia´vel livre 1. Isto pode ser feito da seguinte forma: no caso em
que essa forma ξ-pseudo-normal possua o s´ımbolo 3, que caracteriza a ocorreˆncia da
varia´vel livre 1 no termo t1, a regra Etaξ na˜o se aplica. Caso contra´rio a mesma se
aplica e o termo obtido apo´s a aplicac¸a˜o dessa regra consiste exatamente da forma
ξ-pseudo-normal de ((λt1) 3) como descrito acima.
Vejamos como isto ocorre em cada um dos ca´lculos que estamos considerando.
O primeiro ambiente de nossa implementac¸a˜o e´ o ca´lculo λσ. Neste caso,
((λt1) 3)→ Beta t1[3.id]. Agora precisamos σ-pseudo-normalizar o termo t1[3.id].
Essa σ-pseudo-normalizac¸a˜o, que denotaremos por sig-norm foi implementada da
forma mostrada a seguir. O nome das regras foi colocado entre os s´ımbolos (∗ e ∗)
para facilitar a leitura. As func¸o˜es occurdummy* que aparecem nos co´digos abaixo
buscam a ocorreˆncia de s´ımbolos 3 na expressa˜o dada como argumento e teˆm custo
linear em func¸a˜o do tamanho da entrada.
let rec sig-norm exp =
match exp with
Dummy -> Dummy | One -> One | Vr c -> Vr c |
(* App *) Sb(A(e1,e2),sb)-> (if (occurdummy1(e1)||occurdummy1(e2)||
occurdummy1sb(sb)) then
A(sig-norm(Sb(e1,sb)),sig-norm(Sb(e2,sb))) else exp) |
55
(* Abs *) Sb(L(e1),sb)-> (if (occurdummy1(e1)||occurdummy1sb(sb))
then L(sig-norm(Sb(e1,Pt(One,Cp(sb,Up))))) else exp) |
(* Clos *) Sb(Sb(e1,s1),s2)-> sig-norm(Sb(e1,sig-normsb(Cp(s1,s2)))) |
(*VarCons*) Sb(One,Pt(e1,sb))-> (if (occurdummy1(e1)||occurdummy1sb(sb))
then sig-norm(e1) else exp) |
(* Id *) Sb(e1,Id) -> (if occurdummy1(e1) then sig-norm(e1) else exp) |
_ -> exp
and
sig-normsb subs =
match subs with
Up -> Up | Id -> Id |
(*ShiftCons*) Cp(Up,Pt(e1,sb)) ->
(if (occurdummy1(e1) || occurdummy1sb(sb))
then sig-normsb(sb) else subs) |
(* IdL *) Cp(Id,sb) -> sig-normsb(sb) |
(* IdR *) Cp(sb,Id) -> sig-normsb(sb) |
(* Map *) Cp(Pt(e1,s1),s2) ->
(if (occurdummy1(e1) || occurdummy1sb(s1) ||
occurdummy1sb(s2)) then sig-normsb(Pt(sig-norm(Sb(e1,s2)),
sig-normsb(Cp(s1,s2)))) else subs) |
(*Assoc*) Cp(Cp(s1,s2),s3) ->
(if (occurdummy1sb(s1) || occurdummy1sb(s2) ||
occurdummy1sb(s3)) then
sig-norm(Cp(sig-normsb(s1),sig-normsb(Cp(s2,s3))))
else subs) |
(*SCons*) Pt(Sb(One,s1),Cp(Up,s2)) ->
(if ((s1 = s2)&&(occurdummy1sb(s1))) then
sig-normsb(s1) else subs) | _ -> subs;;
Note que em sig-norm as reduc¸o˜es na˜o-triviais esta˜o sempre ligadas a um condi-
cional if, com excec¸a˜o das regras IdL, IdR e Clos. Uma das justificativas para esse
fato pode ser vista na seguinte reduc¸a˜o (feita via sig-norm):
((λ1[↑2]) 3)→ βs 1[↑2][3.id]→ Clos 1[↑2 ◦(3.id)]→ Assoc 1[↑ ◦(↑ ◦(3.id))]→ ShiftCons
1[↑ ◦id]→ IdR 1[↑].
Caso as regras IdR e IdL tivessem um condicional como as outras, na˜o seria
poss´ıvel obter o resultado desejado. De fato, elas na˜o poderiam ser aplicadas, por
exemplo, em 1[↑ ◦id] ja´ que esse termo na˜o possui ocorreˆncias do s´ımbolo 3 mas
precisa ser simplificado. Como nosso objetivo inicial era apenas propagar subtermos
com alguma ocorreˆncia do s´ımbolo 3, a implementac¸a˜o de Etaσ acaba por utilizar
passos adicionais durante a derivac¸a˜o.
No λse temos, ((λM) 3)→ σ−gen Mσ13. Precisamos, enta˜o, se-pseudo-normali-
zar Mσ13. Denotaremos essa se-pseudo-normalizac¸a˜o por se-norm que e´ dada por:
let rec se-norm exp =
match exp with
Dummy -> Dummy |
DB i -> DB i |
Vr c -> Vr c |
S(i,Vr c,Dummy) -> exp |
56
(*sigma-destruction*) S(i,DB j,Dummy) ->
(if j<i then DB j else
(if j>i then (DB (j-1))
else P(0,i,Dummy))) |
(*sigma-app*) S(i,A(e1,e2),Dummy) ->
A((se-norm (S(i,e1,Dummy))),
(se-norm (S(i,e2,Dummy)))) |
(*sigma-lambda*) S(i,L(e1),Dummy) ->
L(se-norm (S(i+1,e1,Dummy))) |
(*sigma-sigma*) S(i,S(j,e1,e2),Dummy) ->
(if i >= j then
S(j, (se-norm (S(i+1,e1,Dummy))),
(se-norm (S(i-j+1,e2,Dummy))))
else exp) |
(*sigma-phi*) S(i,P(k,n,e),Dummy) ->
(if i>=k+n then
P(k,n,(se-norm (S(i-n+1,e,Dummy))))
else (if i>k then
P(k,n-1,e) else exp)) |
_ -> exp ;;
Como podemos observar, a implementac¸a˜o acima e´ mais simples que a anterior
ja´ que o λse preserva a estrutura do termo, ou seja, o s´ımbolo 3 permanece sempre
como o u´ltimo argumento do subtermo a ser normalizado quando simulamos uma
η-conversa˜o de um λ-termo puro. Como consequeˆncia desta regularidade, a imple-
mentac¸a˜o dessas regras poˆde ser feita sem a necessidade de nenhum condicional.
Isto, claramente, e´ uma grande vantagem para o λse ja´ que nos outros ca´lculos a
verificac¸a˜o da func¸a˜o occurdummy* tem custo linear no tamanho do termo para cada
aplicac¸a˜o da regra.
No λSusp a implementac¸a˜o se assemelha muito a` implementac¸a˜o do λσ. Aqui
temos que ((λM) 3)→ βs [[M, 1, 0, (3, 0) :: nil]]. Denotaremos por susp-norm a
Susp-pseudo-normalizac¸a˜o do termo [[M, 1, 0, (3, 0) :: nil]]. A func¸a˜o susp-norm e´
dada por:
let rec susp-norm exp =
match exp with
Dummy -> Dummy |
DB i -> DB i |
Vr c -> Vr c |
(*r_1*) Sp(Dummy,i,j,env) -> Dummy |
(*r_2*) Sp(DB i,0,j,Nilen) -> DB (i+j) |
(*r_3*) Sp(DB 1,i,j,Con(Ar(k),env)) -> DB (j-k) |
(*r_4*) Sp(DB 1,i,j,Con(Paar(e1,k),env)) ->
(if (occurdummy3 e1)
then susp-norm(Sp(e1,0,j-k,Nilen))
else exp) |
(*r_5*) Sp(DB i,j,k,Con(envt,env)) ->
(if ((occurdummy3_Et envt) ||
(occurdummy3_Env env))
then susp-norm(Sp(DB (i-1),j-1,k,env))
57
else exp) |
(*r_6*) Sp(A(e1,e2),i,j,env) -> (if ((occurdummy3 e1) ||
(occurdummy3 e2) || (occurdummy3_Env env))
then A(susp-norm(Sp(e1,i,j,env)),
susp-norm(Sp(e2,i,j,env))) else exp) |
(*r_7*) Sp(L(e1),i,j,env) -> (if ((occurdummy3 e1) ||
(occurdummy3_Env env))
then L(susp-norm(Sp(e1,i+1,j+1,Con(Ar(j),env))))
else exp) |
_ -> exp;;
As observac¸o˜es para a implementac¸a˜o da susp-norm sa˜o ana´logas a`s feitas para
sig-norm. Ou seja, observamos aqui as mesmas dificuldades encontradas para o λσ
pois as regras r2 e r3 sa˜o implementadas sem nenhum condicional if.
Em func¸a˜o de todas essas observac¸o˜es conclu´ımos que a implementac¸a˜o da regra
Eta no ca´lculo λse e´ mais eficiente que nos ca´lculos λσ e λSusp.
Apesar de estarem corretas, no´s na˜o temos a completude dessas implementac¸o˜es.
Isto e´, as implementac¸o˜es so´ funcionam da forma esperada para termos puros do λ-
ca´lculo e na˜o para termos quaisquer como acredita´vamos inicialmente. Um contra-
exemplo, para o λse pode ser visto na figura a seguir:
(4σ11)σ13
(4σ23)σ1(1σ13)
3σ1(ϕ103)
3σ13
2
2
σ-destruction σ-destruction
σ-destruction σ-σ-transition
O ramo esquerdo corresponde a` reduc¸a˜o segundo a ide´ia original de Borovansky´[Bor95],
enquanto que o ramo direito corresponde a` reduc¸a˜o via se-pseudo-normalizac¸a˜o.
Como podemos ver esses u´ltimos termos obtidos na˜o sa˜o junta´veis via se-pseudo-
normalizac¸a˜o.
Concluiremos este cap´ıtulo apresentando os resultados que mostram a corretude
das implementac¸o˜es das regras Etaξ, onde ξ ∈ {σ, se, Susp} mostradas acima, para
termos puros.
58
Lema 4.3 Seja M ∈ ΛdB. Enta˜o a σ-pseudo-normalizac¸a˜o de
M [1.1[↑]. . . . .1[↑k−2].3[↑k−1]. ↑k−1]
nos fornece um novo termo que mante´m todas as varia´veis do termo M menores
que k inalteradas, substitui a k-e´sima varia´vel por 3[↑k−1] e decrementa em 1 todas
as varia´veis maiores do que k.
Demonstrac¸a˜o.
Por induc¸a˜o sobre a estrutura de M temos que:
• Se M = n e n < k enta˜o 1[↑n−1][1.1[↑]. . . . .1[↑k−2].3[↑k−1]. ↑k−1]→ Clos
1[↑n−1 ◦(1.1[↑]. . . . .1[↑k−2].3[↑k−1]. ↑k−1)]→ n−2Assoc
1[↑ ◦(↑ ◦(. . . (↑ ◦(1.1[↑]. . . . .1[↑k−2].3[↑k−1]. ↑k−1)]→ n−1ShiftCons 1[↑n−1].
Se n = k enta˜o 1[↑n−1][1.1[↑]. . . . .1[↑k−2].3[↑k−1]. ↑k−1]→ Clos
1[↑n−1 ◦(1.1[↑]. . . . .1[↑k−2].3[↑k−1]. ↑k−1)]→ n−2Assoc
1[↑ ◦(↑ ◦(. . . (↑ ◦(1.1[↑]. . . . .1[↑k−2].3[↑k−1]. ↑k−1)]→ n−1ShiftCons 3[↑n−1].
Se n > k enta˜o 1[↑n−1][1.1[↑]. . . . .1[↑k−2].3[↑k−1]. ↑k−1]→ Clos
1[↑n−1 ◦(1.1[↑]. . . . .1[↑k−2].3[↑k−1]. ↑k−1)]→ n−2Assoc
1[↑ ◦(↑ ◦(. . . (↑ ◦(1.1[↑]. . . . .1[↑k−2].3[↑k−1]. ↑k−1)]→ n−1ShiftCons
1[↑n−1−k ◦ ↑k−1] = 1[↑n−2].
• Para M = (A B) aplicamos diretamente a hipo´tese de induc¸a˜o.
• Se M = (λA) enta˜o (λA)[1.1[↑]. . . . .1[↑k−2].3[↑k−1]. ↑k−1]→ Abs
λA[1.((1.1[↑]. . . . .1[↑k−2].3[↑k−1]. ↑k−1)◦ ↑)]→ kMap
λA[1.(1[↑].1[↑][↑]. . . . .1[↑k−2][↑].3[↑k−1][↑].(↑k−1 ◦ ↑))]→ Clos
λA[1.1[↑].1[↑2]. . . . .1[↑k−1].3[↑k]. ↑k]. Agora utilizamos a hipo´tese de induc¸a˜o
para concluirmos o resultado desejado.
2
Proposic¸a˜o 4.4 Seja M ∈ ΛdB. Se λ(M 1)→ ηN enta˜o a implementac¸a˜o da regra
Eta no ca´lculo λσ simula esta η-conversa˜o, isto e´, λ(M 1)→ EtaσN .
Demonstrac¸a˜o.
A caracterizac¸a˜o da regra Etaσ e´ dada pela func¸a˜o sig-norm mostrada anterior-
mente. A demonstrac¸a˜o e´ feita por induc¸a˜o sobre a estrutura do termo M .
59
• Se M = n e n 6= 1 enta˜o por um lado temos que λ(n 1)→ ηn− 1. Queremos
mostrar que n[3.id] = 1[↑n−1][3.id] tambe´m σ-pseudo-reduz a n− 1. De fato,
1[↑n−1][3.id]→ Clos 1[↑n−1 ◦(3.id)]→ Assoc 1[↑n−2 ◦(↑ ◦(3.id))]→ ShiftCons
1[↑n−2 ◦(id)]→ IdR 1[↑n−2] = n− 1.
• Se M = (A B) com A e B sem ocorreˆncias da varia´vel livre 1 enta˜o, pela
condic¸a˜o de aplicac¸a˜o da regra η ao par (A B), temos que λ(A 1)→ ηA′ e
λ(B 1)→ ηB′, onde A′ e B′ sa˜o obtidos de A e B respectivamente, decremen-
tando todas as suas varia´veis livres em 1.
Por outro lado, (A B)[3.id]→ App A[3.id] B[3.id]. Mas por hipo´tese de indu-
c¸a˜o temos que a σ-pseudo-normalizac¸a˜o de A[3.id] e B[3.id] corresponde,
respectivamente, a A′ e B′.
• SeM = (λA) eA na˜o possui ocorreˆncias da varia´vel livre 2 enta˜o λ((λA) 1)→ η
λA′′, onde A′′ consiste do termo A com todas as suas varia´veis livres decre-
mentadas em 1.
Por outro lado, aplicando o lema 4.3 ao termo M [3.id], e lembrando que
↑0= id, obtemos o resultado desejado.
2
Lema 4.5 Seja M ∈ ΛdB. Enta˜o a se-pseudo-normalizac¸a˜o do termo Mσi3 nos
fornece um novo termo tal que todas as varia´veis de M menores do que i permanecem
inalteradas, a i-e´sima varia´vel e´ substitu´ıda por ϕi03 e todas as varia´veis maiores
do que i sa˜o decrementadas em 1.
Demonstrac¸a˜o.
Por induc¸a˜o sobre a estrutura do termo M temos:
• Se M = n e n < i enta˜o nσi3→ σ-destrn.
Quando n = i enta˜o nσi3→ σ-destrϕi03.
Quando n > i enta˜o nσi3→ σ-destrn− 1.
• Se M = (A B) enta˜o (A B)σi3→ σ-app (Aσi3) (Bσi3). Agora pela hipo´tese
de induc¸a˜o temos o resultado desejado.
60
• Se M = (λA) enta˜o (λA)σi3→ σ-λ λAσi+13. Agora utilizamos a hipo´tese de
induc¸a˜o para obtermos o resultado desejado.
2
Proposic¸a˜o 4.6 Seja M ∈ ΛdB. Se λ(M 1)→ ηN enta˜o a implementac¸a˜o da regra
Eta no ca´lculo λse simula esta η-conversa˜o, isto e´, λ(M 1)→ EtaseN .
Demonstrac¸a˜o.
Por induc¸a˜o sobre a estrutura de M , temos que:
• Se M = n e n > 1 enta˜o, de maneira ana´loga ao proposic¸a˜o anterior precisamos
mostrar que nσ13→n− 1. De fato, isto acontece apo´s a aplicac¸a˜o da regra
σ-destruction.
• Se M = (A B) com A e B sem ocorreˆncias da varia´vel livre 1 enta˜o, pela
condic¸a˜o de aplicac¸a˜o da regra η ao par (A B), temos que λ(A 1)→ ηA′ e
λ(B 1)→ ηB′, onde A′ e B′ sa˜o obtidos de A e B respectivamente, decremen-
tando todas as suas varia´veis livres em 1.
Por outro lado, temos que (A B)σ13→ σ−app (Aσ13) (Bσ13), e por hipo´tese
de induc¸a˜o temos que (Aσ13)→ EtaseA′ e (Bσ13)→ EtaseB′.
• SeM = (λA) eA na˜o possui ocorreˆncias da varia´vel livre 2 enta˜o λ((λA) 1)→ η
λA′′, onde A′′ consiste do termo A com todas as suas varia´veis livres, exceto
1, decrementadas em 1.
Por outro lado temos que (λA)σ13→ σ-λ λAσ23. Utilizando o lema 4.5 temos
que este u´ltimo termo tera´ todas as suas varia´veis livres decrementadas em 1.
2
Proposic¸a˜o 4.7 Seja M ∈ ΛdB. Se λ(M 1)→ ηN enta˜o a implementac¸a˜o da regra
Eta no ca´lculo λSusp simula esta η-conversa˜o, isto e´, λ(M 1)→ EtaSuspN .
Demonstrac¸a˜o.
Por induc¸a˜o sobre a estrutura de M , temos:
61
• Se M = n e n > 1 enta˜o, de maneira ana´loga a`s proposic¸o˜es anteriores pre-
cisamos mostrar que [[n, 1, 0, (3, 0) :: nil]]→ ∗n− 1. De fato,
[[n, 1, 0, (3, 0) :: nil]]→ r5 [[n− 1, 0, 0, nil]]→ r2n− 1.
• Se M = (A B) com A e B sem ocorreˆncias da varia´vel livre 1 enta˜o, pela
condic¸a˜o de aplicac¸a˜o da regra η ao par (A B), temos que λ(A 1)→ ηA′ e
λ(B 1)→ ηB′, onde A′ e B′ sa˜o obtidos de A e B respectivamente, decremen-
tando todas as suas varia´veis livres em 1.
Por outro lado temos que
[[(A B), 1, 0, (3, 0) :: nil]]→ r6 [[A, 1, 0, (3, 0) :: nil]] [[B, 1, 0, (3, 0) :: nil]]
e, aplicando a hipo´tese de induc¸a˜o que nos diz que
[[A, 1, 0, (3, 0) :: nil]]→ EtaSuspA′ e [[B, 1, 0, (3, 0) :: nil]]→ EtaSuspB′
temos o resultado desejado.
• SeM = (λA) eA na˜o possui ocorreˆncias da varia´vel livre 2 enta˜o λ((λA) 1)→ η
λA′′, onde A′′ consiste do termo A com todas as suas varia´veis livres,exceto 1,
decrementadas em 1.
Por outro lado, [[(λA), 1, 0, (3, 0) :: nil]]→ r7 λ[[A, 2, 1,@0 :: (3, 0) :: nil]]. Apli-
cando o lema 4.2 temos o resultado desejado.
2
Conclusa˜o
A a´rea de Substituic¸o˜es Expl´ıcitas tem crescido rapidamente nos u´ltimos anos
devido a um grande interesse em se poder controlar explicitamente as operac¸o˜es do
λ-ca´lculo. Va´rios sabores de ca´lculos de substituic¸o˜es expl´ıcitas teˆm sido propostos
devido a` dificuldade em se conseguir um que seja confluente (tanto em termos abertos
quanto em termos fechados), que simule a β-conversa˜o, que preserve a terminac¸a˜o
forte (PSN) e cujo ca´lculo de substituic¸o˜es expl´ıcitas subjacente seja terminante.
Aqui estudamos treˆs ca´lculos de substituic¸o˜es expl´ıcitas: o λσ, λse e o λSusp.
O λσ tem um papel importante por ter sido o primeiro ca´lculo de substituic¸o˜es
expl´ıcitas a ser apresentado a` comunidade cient´ıfica. Vimos que ele e´ local-confluente
(para termos abertos), e que simula a β-conversa˜o. O ca´lculo de substituic¸a˜o sub-
jacente σ e´ terminante, mas [Mel95] mostrou que λσ na˜o e´ PSN.
O λSusp foi desenvolvido por Nadathur e Wilson [NW98], e ate´ enta˜o na˜o tinha
sido comparado com nenhum outro ca´lculo de substituic¸o˜es expl´ıcitas. Aqui intro-
duzimos uma regra Eta para esse ca´lculo e vimos que o sistema Susp + EtaSusp e´
terminante e confluente (para termos abertos e fechados). Ate´ o presente momento
na˜o sabemos se esse ca´lculo e´ PSN ou na˜o. Ale´m disso, vimos tambe´m que λSusp e´
incompara´vel, no sentido de [KR00], com o λσ.
O λse, uma extensa˜o para termos abertos do λs, e´ confluente, simula a β-
conversa˜o, mas, como mostrou [Gui00] na˜o e´ PSN. Uma questa˜o em aberto consiste
em saber se o ca´lculo de substituic¸a˜o subjacente, se, e´ terminante. Mostramos que
o λse e´ mais adequado que o λSusp. Na verdade, obtivemos aqui muito mais do
que a noc¸a˜o de adequabilidade de [KR00], pois qualquer simulac¸a˜o de um passo de
β-conversa˜o no λse tem comprimento menor ou igual a` correspondente simulac¸a˜o
no λSusp.
Paralelamente aos estudos teo´ricos, desenvolvemos uma implementac¸a˜o com o
objetivo de simular as derivac¸o˜es de um λ-termo em qualquer dos ca´lculos aqui trata-
62
63
dos. Essa implementac¸a˜o foi feita na liguagem de programac¸a˜o funcional Ocaml, da
famı´lia ML, que utiliza tipagem impl´ıcita. A escolha desta linguagem se deu basica-
mente pela sua facilidade em se trabalhar com λ-termos. No cap´ıtulo 4 apresentamos
a ide´ia geral desse programa com exemplos das estruturas utilizadas na construc¸a˜o
da implementac¸a˜o das regras de reescrita dos ca´lculos λσ, λse e λSusp. A construc¸a˜o
das regras Etaσ, Etase e EtaSusp foi uma etapa importante do trabalho haja vista
que a condic¸a˜o de aplicac¸a˜o da η-conversa˜o no λ-ca´lculo na˜o e´ trivial. Apresentamos
as ide´ias utilizadas para a implementac¸a˜o dessas regras e mostramos a corretude das
mesmas. Pudemos observar tambe´m que a implementac¸a˜o da regra Eta no λse e´
muito mais eficiente do que no λSusp ou no λσ. Essa eficieˆncia se deve ao fato de a
propagac¸a˜o do s´ımbolo 3 ser feita apenas sobre termos da forma Mσi3. Como esta
propagac¸a˜o mante´m sempre o s´ımbolo 3 como segundo argumento da func¸a˜o σ i,
na˜o necessitamos estruturas com condicionais if que elevam o custo computacional
da implementac¸a˜o.
Interessantes questo˜es teo´ricas resultaram da experieˆncia implementacional. Em
particular e´ necessa´rio um refinamento da implementac¸a˜o que permita uma ana´lise
detalhada de poss´ıveis alternativas para uma implementac¸a˜o eficiente da regra Eta
que na˜o misture a normalizac¸a˜o com passos isolados e independentes de reescrita do
ca´lculo de substituic¸o˜es associado. Ale´m disso, a interface com o usua´rio pode ser
melhorada assim como podem ser acrescentadas algumas opc¸o˜es como, por exemplo,
a possibilidade de se efetuar a mesma simulac¸a˜o automaticamente nos treˆs ca´lculos.
Um refinamento do co´digo para o tratamento de excec¸o˜es, isto e´, dados incorretos
fornecidos pelo usua´rio, tambe´m e´ necessa´rio.
Outro trabalho futuro diz respeito a conjectura que Nadathur apresentou em
[Nad99] referente a` preservac¸a˜o da terminac¸a˜o forte (PSN) para o λSusp. Acredita-
mos que uma ana´lise cuidadosa dos resultados obtidos nesta dissertac¸a˜o no que diz
respeito a maior adequabilidade do λse na simulac¸a˜o de um passo de β-conversa˜o
pode ser um bom ponto de partida para se concluir ou na˜o a preservac¸a˜o da ter-
minac¸a˜o forte (PSN) para o λSusp.
Refereˆncias
[ACCL91] M. Abadi, L. Cardelli, P.-L. Curien, and J.-J. Le´vy. Explicit Substitu-
tions. Journal of Functional Programming, 1(4):375–416, 1991.
[AR00] M. Ayala-Rinco´n. Fundamentos da programac¸a˜o lo´gica e funcional
- o princ´ıpio da resoluc¸a˜o e a teoria da reescrita. Departamento
de Matema´tica, Universidade de Bras´ılia, 2000. Dispon´ıvel em:
http://www.mat.unb.br/˜ayala/academics.html.
[ARK01a] M. Ayala-Rinco´n and F. Kamareddine. On Applying the λse-Style of Uni-
fication for Simply-Typed Higher Order Unification in the Pure lambda
Calculus. In R.J.G.B. de Queiroz and M. Ayala-Rinco´n, editors, Pre-
Proceedings Eighth Workshop on Logic, Language, Information and Com-
putation - WoLLIC 2001, pages 41–54, 2001.
[ARK01b] M. Ayala-Rinco´n and F. Kamareddine. Unification via the λse-Style of
Explicit Substitution. Logical Journal of the Interest Group in Pure and
Applied Logics - IGPL, 9(4):521–555, 2001.
[ARM00] M. Ayala-Rinco´n and C. Mun˜oz. Explicit Substitutions and All That.
Revista Colombiana de Computacio´n, 1(1):47–71, 2000.
[Bar97] Henk Barendregt. The impact of the lambda calculus in logic and com-
puter science. Bulletin of Simbolic Logic, 3(3):181–215, 1997.
[BN98] F. Baader and T. Nipkow. Term Rewriting and All That. Cambridge
University Press, 1998.
[Bor95] P. Borovansky´. Implementation of Higher-Order Unification Based on
Calculus of Explicit Substitutions. In M. Bartosˇek, J. Staudek, and
J. Wiedermann, editors, Proceedings of the SOFSEM’95: Theory and
64
65
Practice of Informatics, volume 1012 of Lecture Notes on Computer Sci-
ence, pages 363–368. Springer Verlag, 1995.
[CF58] H. B. Curry and R. Feys. Combinatory Logic, volume 1. North Holland,
1958.
[Chu32] A. Church. A set of postulates for the foundation of logic. Annals of
Math., 33(2):346–366, 1932.
[Chu33] A. Church. A set of postulates for the foundation of logic (second paper).
Annals of Math., 34(2):839–864, 1933.
[CR36] A. Church and J. B. Rosser. Some properties of conversion. Trans. Amer.
Math. Soc., 39:472–482, 1936.
[Cur86] P.-L. Curien. Categorical Combinators, Sequential Algorithms and Func-
tional Programming. Pitman, 1986. Revised edition : Birkha¨user (1993).
[dB72] N.G. de Bruijn. Lambda-Calculus Notation with Nameless Dummies,
a Tool for Automatic Formula Manipulation, with Application to the
Church-Rosser Theorem. Indag. Mat., 34(5):381–392, 1972.
[DHK00] G. Dowek, T. Hardin, and C. Kirchner. Higher-order Unification via
Explicit Substitutions. Information and Computation, 157(1/2):183–235,
2000.
[Gui00] B. Guillaume. The λse-calculus Does Not Preserve Strong Normalization.
Journal of Functional Programming, 10(4):321–325, july 2000.
[KB70] D. Knuth and P. Bendix. Simple Word Problems in Universal Algebras.
In J. Leech, editor, Computational Problems in Abstract Algebra, pages
263–297. Pergamon Press, 1970.
[KR35] Stephen Kleene and Barkley Rosser. The inconsistency of certain formal
logics. Annals of Math., 36(2):630–636, 1935.
[KR95a] F. Kamareddine and A. R´ıos. A λ-calculus a` la de Bruijn with Explicit
Substitutions. In Proc. of PLILP’95, volume 982 of LNCS, pages 45–62.
Springer, 1995.
66
[KR95b] F. Kamareddine and A. R´ıos. The λs-calculus: its typed and its extended
versions. Technical report, Department of Computing Science, University
of Glasgow, 1995.
[KR97] F. Kamareddine and A. R´ıos. Extending a λ-calculus with Explicit Sub-
stitution which Preserves Strong Normalisation into a Confluent Calculus
on Open Terms. Journal of Functional Programming, 7:395–420, 1997.
[KR00] F. Kamareddine and A. R´ıos. Relating the λσ- and λs-Styles of Explicit
Substitutions. Journal of Logic and Computation, 10(3):349–380, 2000.
[Mel95] P.-A. Mellie`s. Typed λ-calculi with explicit substitutions may not ter-
minate in Proceedings of TLCA’95. LNCS, 902:328–349, 1995.
[Nad99] G. Nadathur. A Fine-Grained Notation for Lambda Terms and Its Use in
Intensional Operations. The Journal of Functional and Logic Program-
ming, 1999(2):1–62, 1999.
[New42] M. H. A. Newman. On theories with a combinatorial definition of equiv-
alence. Ann. of Math., 43(2):223–243, 1942.
[NM88] G. Nadathur and D. Miller. An overview of λProlog. In R.A. Kowal-
ski (Eds.) In: K.A. Bowen, editor, Proc. 5th Internat. Logic Programming
Conf. Seattle, Washington, Cambridge, MA, pages 810–827. MIT Press,
1988.
[NW98] G. Nadathur and D. S. Wilson. A Notation for Lambda Terms A Gen-
eralization of Environments. Theoretical Computer Science, 198:49–98,
1998.
[RW13] B. A. W. Russel and A. N. Whitehead. Principia Mathematica, volume
1 and 2. Cambridge University Press, 1910-1913.
