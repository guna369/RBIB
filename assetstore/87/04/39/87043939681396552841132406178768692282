??


t t

t
t

S
S
S
S S
S S
S
Abstract.
1 Introduction
need-
edness
stability
(open) components
any
Relative Normalization in Orthogonal
Expression Reduction Systems
normalizing
needed
needed
Normalization Theorem
strongly sequential
head-needed
School of Information Systems, UEA
Norwich NR4 7TJ England
jrwg@sys.uea.ac.uk, zurab@sys.uea.ac.uk
We study reductions in orthogonal (left-linear and non-am-
biguous) Expression Reduction Systems, a formalism for Term Rewrit-
ing Systems with bound variables and substitutions. To generalise the
normalization theory of Huet and Levy, we introduce the notion of
with respect to a set of reductions or a set of terms so that
each existing notion of neededness can be given by specifying or . We
imposed natural conditions on , called , that are sucient and
necessary for each term not in -normal form (i.e., not in ) to have at
least one -needed redex, and repeated contraction of -needed redexes
in a term to lead to an -normal form of whenever there is one. Our
relative neededness notion is based on tracing , which
are occurrences of contexts not containing bound variable, rather
than tracing redexes or subterms.
This work was supported by the Engineering and Physical Sciences Research Council
of Great Britain under grant GR/H 41300
John Glauert and Zurab Khasidashvili
Since a normalizable term, in a rewriting system, may have an innite reduction,
it is important to have a strategy which enables one to construct
reductions to normal form. It is well known that the leftmost-outermost strat-
egy is normalizing in the -calculus. For Orthogonal Term Rewriting Systems
(OTRSs), a general normalizing strategy, called the strategy, was found
by Huet and Levy in [HuLe91]. The needed strategy always contracts a
redex { a redex whose residual is to be contracted in any reduction to normal
form. Huet and Levy showed that any term not in normal form has a needed
redex, and that repeated contraction of needed redexes in leads to its normal
form whenever there is one; we refer to it as the . They
also dened the class of OTRSs where a needed redex can
eciently be found in any term.
Barendregt et al. [BKKS87] generalized the concept of neededness to the -
calculus. They studied neededness not only w.r.t. normal forms, but also w.r.t.
head-normal forms { a redex is if its residuals are contracted in each
reduction to a head-normal form. The authors proved correctness of the two
u


u
u


t
t
t
P t o Q t e P=Q P
Q e o
e o u e
S
S
S
S S S
S
S
S 62 S
! 2 S !
S !
62 S 2 S
S S
S S
essential
essential descendants
residual
Persistent
all
complete
neededness
Huet&Levy-neededness
Maranget-neededness head-
neededness
stability
closed under parallel moves
closed under unneeded expansion
hypernormalizing
needed strategies for computing normal forms and head-normal forms, respec-
tively. Khasidashvili dened a similar normalizing strategy, called the
strategy, for the -calculus [Kha88] and OTRSs [Kha93]. The strategy contracts
redexes { the redexes that have under any reduction. The
notion of descendant is a renement of that of { the descendant of a
contracted redex is its contractum, while it does not have residuals. This rened
notion allows for much simpler proofs of correctness of the essential strategy in
OTRSs and the -calculus, which generalize straightforwardly to all Orthogonal
Expression Reduction Systems (OERSs). Kennaway and Sleep [KeSl89] used a
generalization of Levyâ€™s labelling for the -calculus [Lev78] to adapt the proof
from [BKKS87] to the case of Klopâ€™s OCRSs [Klo80], which can also be ap-
plied to OERSs. Khasidashvili [Kha94] showed that in OERSs, where
redex-creation is limited, one can nd needed redexes in any term. Gard-
ner [Gar94] described a way of encoding neededness information using
a type assignment system in the sense that using the principal type of a term
one can nd all the needed redexes in it (the principal type cannot be found e-
ciently, as one might expect). Antoy et al. [AEH94] designed a needed narrowing
strategy.
In [Mar92], Maranget introduced a dierent notion of neededness, where a
redex is needed if it has a residual under any reduction that does not contract
the residuals of . This neededness notion makes sense also for terms that do
not have a normal form, and coincides with the notion of essentiality [Kha93]
(essentiality makes sense for all subterms, not only for redexes). In [Mar92],
Maranget studied also a strategy that computes a (in fact, the â€˜minimalâ€™ in
some sense) weak head-normal form of a term in an OTRS. Normalization w.r.t.
another interesting set of â€˜normal formsâ€™, that of constructor head-normal forms
in constructor OTRSs, is studied by NoÂ¨cker [NoÂ¨k94].
A question arises naturally: what are the properties that a set of terms must
possess in order for the neededness theory of Huet and Levy still to make sense?
The main contribution of this paper is to provide a solution to that question.
We introduce the notion of w.r.t. a set of reductions or a set of
terms so that each existing notion of neededness can be given by specifying
or . For example, is neededness w.r.t. the set of
normal forms, is neededness w.r.t. all fair reductions,
is neededness w.r.t. the set of head-normal forms, etc. We impose
natural conditions on , called , that are sucient and necessary for
each term not in -normal form (i.e., not in ) to have at least one -needed
redex, and repeated contraction of -needed redexes in a term to lead to an
-normal form of whenever there is one.
A set of terms is stable if it is : for any ,
any : , and any : , the nal term of , the residual of
under , is in ; and is : for any such that
and , a residual of is contracted in any reduction from to a term
in . We present a counterexample to show that the -needed strategy is not
for every stable , i.e., an -normalizable term may possess
1 m
Denition 2.1
S S
S
S S
S
S
S S S
S
62 S S
S S
S
S S
2
6
t

 x; y; z
k N 
m; n m; n x ; : : : ; x
2 Orthogonal Expression Reduction Systems
multistep
irregular
(open) components
any
descendant resid-
ual
-needed
-needed
family-relation
Combinatory Reduction Systems
Expression Reduction Systems
alphabet variables
function symbols simple operators operator signs quantier
signs arity
arity
a reduction which never reaches a term in even though -needed redexes
are contracted innitely many times, but -unneeded redexes are contracted
as well. Therefore, -needed reductions need not be -normalizing.
This is because a â€˜non-standardâ€™ situation { when a component under an -
unneeded component is -needed { may occur for some, call it stable
sets . However, if is a regular stable set, then the -needed strategy is again
hypernormalizing, and the multistep -needed strategy is normalizing.
Our relative neededness notion is based on tracing , which
are occurrences of contexts not containing bound variable, rather than trac-
ing redexes or subterms. We therefore introduce notions of and
for components that are invariant under Levy-equivalence. A component of
a term is called if at least one descendant of it is â€˜involvedâ€™ in any
-normalizing reduction; a redex is if so is its pattern. Besides gener-
ality, this approach to dening the neededness notion via components is crucial
from a technical point of view, because components of a term in an OERS enjoy
the same â€˜disjointnessâ€™ property that subterms of a term in an OTRS possesses:
residuals of disjoint components of a term in an OERS remain disjoint, and this
allows for simpler proofs.
The rest of the paper is organized as follows. In the next section, we review
Expression Reduction Systems (ERS), a formalism for higher order rewriting
that we use here [Kha90, Kha92]; dene the descendant relation for components,
and show that it is invariant under Levy-equivalence. Section 3 establishes equiv-
alence of Marangetâ€™s neededness and our essentiality for OERSs. In section 4, we
introduce the relative notion of neededness. In section 5, we sketch some prop-
erties of the labelling system of Kennaway&Sleep [KeSl89] for OERSs needed to
dene a among redexes. We prove correctness of the -needed
strategy for nding terms of , for all stable , in section 6. The conclusions
appear in section 7.
Klop introduced (CRSs) in [Klo80] to provide a
uniform framework for reductions with substitutions (also referred to as higher-
order rewriting) as in the -calculus [Bar84]. Restricted rewriting systems with
substitutions were rst studied in Pkhakadze [Pkh77] and Aczel [Acz78]. Several
interesting formalisms have been introduced later [Nip93, Wol93, OR94]. We
refer to Klop et al. [KOR93] and van Oostrom [Oos94] for a survey. Here we
use a system of higher order rewriting, (ERSs),
dened in Khasidashvili [Kha90, Kha92] (ERSs are called CRSs in [Kha92]); the
present formulation is simpler.
Let be an , comprising , denoted by ;
, also called ; and or
. Each function symbol has an , and each operator sign has
an ( ) with = 0 such that, for any sequence of pairwise
R RR
Denition 2.2
m
m m
m
m l
m m
n n j
i
n n
n n
t
s
1
1 1
1
1 1
1 1
1 1 0
0
1 1 0
1 1 0
!
2
2
2
!
!
62
! 9
2
! 9 ! 9 ! 9 ^ 8 8 ^
)
compound operator quantier arity
binding variables
scope indicator
Terms
Metaterms terms metavariables
metasubstitutions
scope
simple metaterms
assignment
instance
Expression Reduction System
alphabet rewrite rules
admissible assignments
redex redex contractum
simple
x : : : x
n x ; : : : ; x x : : : x
x : : : x 
x : : : x k ; : : : ; k
x : : : x x ; : : : ; x
A;B; : : :
t =x ; : : : ; t =x t t
x t
 t 
 t t t

t =x ; : : : ; t =x t
t ; : : : ; t x ; : : : ; x t
  Ap x t; s Ap

f x dx x s t f x
;R
 R
r t s t s
t
s t
r AA r
 AA r A t s
x FV A A r
x r
 AA r t r R s
t R R
 
Ap xA;B B=x A; A B
 x Ax A 
x A x A
x Ax f A x A
 x A
 xA  xA =x A xA x A =x A xA xA x y A
y=x A x y
distinct variables, is a or a with
. Occurrences of in are called . Each
quantier , as well as the corresponding quantier sign and binding
variables , has a ( ) to specify the arguments in
which binds all free occurrences of . are constructed
from variables using functions and quantiers in the usual way.
are constructed similarly from and ,
which range over terms. In addition, , expressions of the form
( ) , with arbitrary metaterms, are allowed, where the
of each is . Metaterms without metasubstitutions are . An
maps each metavariable to a term over . If is a metaterm and is
an assignment, then the - of is the term obtained from by replacing
metavariables with their values under , and by replacing metasubstitutions
( ) , in right to left order, with the result of substitution of
terms for free occurrences of in .
For example, a -redex in the -calculus appears as ( ), where is
a function symbol of arity 2, and is an operator sign of arity (1,1) and scope
indicator (1). Integrals such as ( ) can be represented as ( ) using
an operator sign of arity (1,3) and scope indicator (3).
An (ERS) is a pair ( ), where
is an , described in Denition 2.1, and is a set of
: , where and are closed metaterms (i.e., no free variables) such that
is a simple metaterm and is not a metavariable, and each metavariable that
occurs in occurs also in .
Further, each rule has a set of ( ) which, in order
to prevent undesirable confusion of variable bindings, must satisfy the condition
that:
(a) for any assignment ( ), any metavariable occurring in or ,
and any variable ( ), either every occurrence of in is in the scope
of some binding occurrence of in , or no occurrence is.
For any ( ), is an - or an - , and is the
of . We call if right-hand sides of -rules are simple metaterms.
Our syntax is similar to that of Klopâ€™s CRSs [Klo80], but is closer to the syntax
of the -calculus and of First Order Logic. For example, the -rule is written
as ( ) ( ) where and can be instantiated by any terms;
the -rule is written as ( ) which requires that an assignment is
admissible i ( ), otherwise an occurring in and therefore bound in
( ) would become free. A rule like ( ) ( ) is also allowed, but an
assignment with is not. The recursor rule from [AsLa93] is written as
( ) ( ( ) ) . ( ( ) ) and ! (
( ) = ) are rules corresponding to familiar denitions.
Below we restrict ourselves to the case of non-conditional ERSs, i.e., ERSs
where an assignment is admissible i the condition (a) of Denition 2.2 is sat-
ised. We ignore questions relating to renaming of bound variables. As usual,
f
0 0
0 0
Notation 2.1
!

 !
! ! !
j j
! 2
!
[ !
! ! !
!

 
!
+1
1 1 0 1 1 0
+1
1 1 0
+1
+1
+1
1 1 0
+1
1 1 0
2
+1
1 1 0 1 1 0
0
n
n n n n
n
n n
n
u
P
f
n
f
n
n n
n
n n f
fS def f def
fS def f
u
R S fS S
u
f
n
n n
u
n n
i
i
operator sign of substitution
arguments
pattern
pattern-subterms
descendant
TRS-part substitution-
part
renement
renement
descendants
descendant descen-
dants descendant descendant
descendant
descendant
S
S x : : :x A : : :A A A =x ; : : : ; A =x A ; n ; ; : : :
S n; n
n x ; : : : ; x A ; : : : ; A ; A
S
 S 

a; b; c; d t; s; e; o
u; v; w N; P;Q s t s
t u t t s
t s u P t s t s P t
s P P P Q P Q
r t s R  AA r
v t t v
v v
v R
s v

R R
S R S
R R S
t =x ; : : : ; t =x t S x : : : x t : : : t t 
Ap xA;B S xBA R R R R
R R S C t C s R
P C t C s  C s R C s  C s
S P
u R
t s R e u s
o u e u
o i i > o
u; i o o
u;
u e
s t u u; s
S C S x : : :x t : : : t t C t =x ; : : : ; t =x t
t
x t i
a rewrite step consists of replacement of a redex by its contractum. Note that
the use of metavariables in rewrite rules is not really necessary { free variables
can be used instead, as in TRSs. We will indeed do so at least when giving TRS
examples.
To express substitution, we use the -reduction rules
( ) = 1 2 ,
where is the with arity ( +1) and scope in-
dicator ( +1), and and are pairwise distinct variables
and metavariables. Thus binds free variables only in the last argument. The
dierence with -rules is that -reductions can only perform -developments of
-terms [Kha92].
We use for constants, for terms and metaterms,
for redexes, and for reductions. We write if is a subterm of
. A one-step reduction in which a redex is contracted is written as
or or just . We write : or if denotes a reduction of
to . denotes the length of . + denotes the concatenation of and .
Let : be a rule in an ERS and let ( ). Subterms of a
redex = that correspond to metavariables of are the of ,
and the rest is the of . Subterms of rooted in the pattern are called
the of . If is a simple ERS, then arguments, pattern, and
pattern-subterms are dened analogously in the contractum of .
We now recall briefly the denition of of subterms as introduced
in [Kha88, Kha93, Kha92] for the -calculus, TRSs, and ERSs, respectively.
First, we need to split an ERS into a and the
. For any ERS , which we assume does not contain symbols ,
is the ERS obtained from by adding symbols in the alphabet and
by replacing in right-hand sides of the rules all metasubstitutions of the form
( ) by , respectively. For example, the
rule would be ( ) . If is simple, then = = .
Otherwise = . For each step [ ] [ ] in there is a re-
duction : [ ] [ ] [ ] in , where [ ] [ ] is
the rightmost innermost normalizing -reduction. We call the of
. The notion of generalizes to -reductions with 0 or more steps.
Let be an -reduction step and let be the contractum of in . For
each argument of there are 0 or more arguments of . We will call them -
of . We refer to the -th (from the left, 0) descendant of also as
the ( )- of . Correspondingly, subterms of have 0 or more
. By denition, the , referred to also as the ( )- , of
each pattern-subterm of is . It is clear what is to be meant by the
of a subterm that is not in . We call it also the ( )- of .
In an -reduction step [ ] [( ) ], the
argument and its subterms have the same number of descendants as the num-
ber of free occurrences of in ; the -th descendant is referred to as the
00 0
0
1
0
1
n
fS
fS
n
u
fS
j


v
!

\ ;
  

Denition 2.3
u; i t u;
u; x ; : : : ; x
t u;
u u; i u;
R
P R P
P
context; path
; path ; path
path
C
C
C s
s ; path
t e t path e
C s; t; e; o
s t s t
R C t R
s C s ; : : : ; s C t t t R
o t u u pat u
cpat u u C
u C
C u C C u
u; C u; s u;
s C ; path u;
C o u
u; i C u; i
o o u C
u u; i C u; i
s o
descendant
descendent
descendent
indexes
residuals
descendant residual
indexes
ancestor
component any
position
empty component empty occurrence
connection top
corresponding subterm
arguments
in non-top
descendent
-descendants
( )- . Every subterm of has exactly one descendant, the ( 0)-
(in particular, the ( 0)-descendants of free occurrences of
in are the substituted subterms). The descendant or ( )- of the
contracted redex itself is its contractum. The pairs ( ) and ( ) are called
the of corresponding descendants. The descendants of all redexes except
the contracted one are called .
The notions of and extend by transitivity to arbitrary
-reductions; of descendants and residuals are sequences of indexes of
immediate (i.e., under one step) descendants and residuals in the chain leading
from the initial to the nal subterm. If is an -reduction, then descen-
dants are dened to be the descendants under the renement of . The
relation is the converse of the descendant relation.
We call a an occurrence of a context that does not contain
bound variables; that is, neither variables bound from above in the term, nor
variables for which the binder is in the component, belong to the component.
Since we also consider occurrences of the empty context [ ], which has an arity 1,
we will think of a component as a pair ( ), where the path charac-
terizes the of the component in the term (usually, a position is a chain
of natural numbers). Thus an or is a pair
([ ] ). If terms are represented by trees, then the empty occurrence ([ ] )
can be seen as the at the of the symbol at the position .
Obviously, a component can be considered as its
(the subterm rooted at the position of ), with some subterms (the
of ), removed. In particular, a subterm with itself removed becomes the empty
occurrence at the position of . We say that an empty occurrence ([ ] ) in a
term is a subterm or component in if is a position of . We
use and the letters used for terms to denote components as well. We
write if is a component of .
The concept of can be extended to components in the following
way:
Let be an ERS, be a component of a term in , let
= [ ] be the corresponding subterm of in , let in , and
let be the contractum of . The pattern of will be denoted by ( )
and the pattern of the contractum by ( ). We dene of by
considering all relative positions of and .
(1) = (so if is an empty component, is not in ). Then the
( )-descendant of is the ( )-descendant of with the ( )-descendants
of removed. (If is an empty occurrence ([ ] ), then its ( )-descendant
is the same pair.)
(2) is the empty occurrence at the top of an argument of . Then the
( )-descendant of is the empty occurrence at the top-position of the ( )-
descendant of , if the latter exists; if doesnâ€™t have -descendants, then
doesnâ€™t have -descendants either. (Thus, the ( )-descendant of is the ( )-
descendant of its corresponding subterm = with itself removed.)
Rf
cpat(u)
C
pat(u)
AA
AA
A
A
x x
s1
s2
S
CeCe
Co
Co
s2
s1 s1
s3
s3
C'
C
Sx
Ce
0
0
0




; 
 
2
1
2
+1
2
+1
Fig. 1.
Fig. 2.
f
j
j
f
j
e k l o l m n
e o e k l o l m
j e
e o
-descendant
collapsed
-descendants
collapsed
u R C u u; i
C u; i s u; i s i
u S C u u; i
C u; i s u; i s i
u R pat u C u; C
u; s s
C pat u C cpat u u;
C o
u S u S x e o
C s C s ; : : : ; S xC s ; : : : ; s C s ; : : : ; s ; : : : ; s
C C : : : ; S xC C ; : : : ; e C s ; : : : ; s o C s ; : : : ; s
u; C u; s
s C
k l l m C Pat u S
C C C
u
(3) is an -redex and is in an argument of . Then the ( )-descendant
of is the ( )-descendant of with the ( )-descendants of removed ( 1).
(4) is an -redex and is in an argument of . Then the ( )-descendant of
is the ( )-descendant of with the ( )-descendants of removed ( 0).
(5) is an -redex and ( ) is in . Then the ( ) of is
the ( )-descendant of with the descendants of removed (see Figure 1). In
particular, if is , i.e. ( ) = and ( ) = , then the ( )-
descendant of is the empty occurrence at the position of .
(6) is an -redex, say with two arguments (for simplicity) = , with
the top in , and let = [ [ ] [ ] ],
with = [ [ ] [ ] ] = [ ], and = [ ].
Then, the ( ) of are the ( )-descendant of with the descen-
dants of the subterms removed, and the descendants of , as dened in (4)
(see Figure 2, where = = 1 and +1 = = 2). Note that if = ( ) = ,
then and are empty components, is , and its descendants are
the empty occurrences at the top positions of the descendants of and its argu-
ments.
Rf
C
sn sn
pat(u) cpat(u)
s1
s1
s1
pat(u)
Rf
C
s1
cpat(u)
s1s1
0
0
0
0
f
i
f
i
f
 


 



Fig. 3.
Fig. 4.
u R pat u C
u C
u; C u; s
u C s
pat u
o u; C
o u; C
u R pat u C C
u u; C u; s
s pat u
u C
o u;
C o u; C
u R pat u C C
u; C u
(7) is an -redex, ( ) and partially overlap (i.e., neither contains
another), and the top of is (not necessarily strictly) below the top of . Then
the ( )-descendant of is the ( )-descendant of with the descendants
of the arguments of that do not overlap with and the descendants of
that do not overlap with ( ) removed (see Figure 3). In addition, if the top
symbol of doesnâ€™t belong to the (above) ( )-descendant of , then the empty
component at the top of is also a ( )-descendant of .
(8) is an -redex, ( ) and partially overlap, and the top of is
below the top of . Then the ( )-descendant of is the ( )-descendant of
with the descendants of that do not overlap with ( ) and the descendants
of the arguments of that do not overlap with removed (see Figure 4). In
addition, if the top symbol of doesnâ€™t belong to the (above) ( )-descendant
of , then the empty component at the top of is also a ( )-descendant of .
(9) is an -redex and ( ) contains ( may be an empty component).
Then the ( )-descendant of is the contractum-pattern of (the latter may
also be empty) (see Figure 5).
Rf
cpat(u)pat(u)
C

Fig. 5.
fS
H
K
st st
! !


 
!
Denition 2.4
Denition 2.5
R R
S
S S u
u
o
o
o
P t s Q t e
P Q s e
t P Q P Q
P Q
P Q P Q s e P Q
t s
e
t s R t
t R R
descendant of (an occurrence
of) a symbol
all
Hindley-equivalent
Klop-
equivalent, strictly equivalent strictly* equivalent
left-linear
left-linear
The notion of descendant for components generalises by transitivity to all
reductions and via renements to all -reductions.
In [Klo92], Klop also introduced a notion of
for the case of TRSs. According to Klopâ€™s denition, descendants
of every symbol in the pattern of the contracted redex are symbols in the
contractum pattern. We extend this also to empty occurrences in the pattern
of the contracted redex. If the rule is collapsing, i.e., the right-hand side is a
variable, then Klop denes the descendant of pattern-symbols of the contracted
redex to be the topmost symbol of the contractum. We dene the descendant
of the pattern-symbols in that case to be the empty occurrence at the position
of the contractum. We can dene the notion of descendant of a symbol in the
same spirit for -reduction steps by declaring that the descendants of the top
-symbol of a contracted -redex are the empty occurrences at the positions of
the descendant of and the descendants of its arguments. We dene the descen-
dants of other symbols, in particular of bound variables, to be the top-symbols
of the descendants of the corresponding subterms. This gives us a denition
of descendant for symbols for all ERSs. Now, it is not dicult to check that
descendants of a component are composed of the â€˜correspondingâ€™ descendants
of its symbols and occurrences, and similarly for the descendants of subterms.
Note that, according to Klopâ€™s denition, the descendants of a pattern-subterm
are all subterms rooted in the contractum-pattern, not just the contractum
of the redex, as in our denition; so descendants of need not be composed of
descendants of the symbols in , which is less natural.
Co-initial reductions : and : are called
, written , if = and the residuals of a redex of
under and are the same occurrences. We call and respectively
[Kha92], or , written ,
, or , if = and -descendants and -descendants of respec-
tively any symbol, subterm, or component of are the same occurrences in
and .
A rewrite rule in an ERS is if is linear, i.e.,
no metavariable occurs more than once in . is if each rule in is
0 0
0
0 0
0 0

i
i j
L
L
L
H
st
K
st
f j 2 g
6
 ; 
 







j j j j
!
3 Neededness, Essentiality and Unabsorbedness
Theorem 2.1
: Church-Rosser for residuals
: Church-Rosser for subterms
: Church-Rosser for symbols
: Church-Rosser for components
Denition 3.1
Denition 3.2
Denition 3.3
R r i I
r u r u i j u
u i j u
u R
 P Q
P Q P=Q
P Q P=Q P Q
P Q P Q
Q P = P Q
P P =Q P=Q P = Q=P
P= Q Q P=Q =Q
P Q R
CR res P Q=P Q P=Q
CR sub P Q=P Q P=Q
CR sym P Q=P Q P=Q
CR com P Q=P Q P=Q
P Q
u t
t u
u u
t u
s t ES s; t s
t
IE s; t
s t P t e
s P
P s t
t t
non-ambiguous non-overlapping
orthogonal
residual of under
development
Levy-embedding
Levy-equivalent permutation-equivalent
Proof.
Huet&Levy-needed
Maranget-needed
essential
inessential
unabsorbed in a reduction
absorbed in unabsorbed in
absorbed in
so. = is or if in no term redex-
patterns can overlap, i.e., if -redex contains an -redex and = , then
is in an argument of , and the same holds if = and is a proper subterm
of . is (OERS) if it is left-linear and non-overlapping.
As in the the -calculus [Bar84], for any co-initial reductions and , one
can dene in OERSs the notion of , written , due
to Levy [Lev80], via the notion of of a set of redexes in a term.
We write if = ( is the relation); and are
called or (written ) if
and . It follows immediately from the denition of that if and are
co-initial reductions in an OERS, then ( + ) + ( ) and
( + ) ( ) .
Let and be co-initial reductions in an OERS . Then:
(1) ( ( ) ) + + .
(2) ( ( ) ) + + .
(3) ( ( ) ) + + .
(4) ( ( ) ) + + .
(1) is proved in [Klo80]. (2) is obtained in [Kha92]. The proof of (3)
is routine (it is enough to consider the case when = = 1). (4) follows
both from (3) and (2), since descendants of a component can be dened both
via descendants of symbols and via descendants of subterms. (Note that (2) can
also be derived from (3) for the same reason.)
In this section, we recall Huet&Levy and Marangetâ€™s notion of neededness, and
relate them to the notion of essentiality, in OERSs. We also prove existence of
an essential redex in any term, in an OERS, not in normal form.
A redex in is [HuLe91, Lev80] if in each
reduction of to normal form (if any) at least one residual of is contracted;
is [Mar92] if has at least one residual under any reduction
starting from that does not contract residuals of .
A subterm in is (written ( )) if has at least
one descendant under any reduction starting from and is (written
( )) otherwise [Kha93, Kha88].
A subterm of a term is :
if none of the descendants of appear in redex-arguments of terms in , and is
otherwise; is if it is unabsorbed in any reduction
starting from and otherwise [Kha93].
20 1 0
1
0 0
0 0
0
0
0
i
j
i
st
u
n n n
n
n n
v v
fS
u
u
f n
f n
n
n
1
1 1 1
1
1 1
0 1 0
1
0 1
0 0 0
0 1
1 0
0 0
0
0 1 0

!
! ! 
!
! !

! 
!  
 

! ! k !
!
;
;
external
deletes
erased
fair
strictly conal
Proof.
Remark 3.1
Denition 3.4
Denition 3.5
Lemma 3.1
Lemma 3.2
Notation
Denition 3.6
u t u
t
P t s o t
P o o P
P t t : : : u t u
P j > i u t P
t P
P t Q t e
P t s P Q e s
P Q Q
P t
t
CR sub
CR sub
P t t s t IE s; t P
s t
t t e s t u e
u s
e s t ES e; t ES s; t
s u t ES u; t ES s; t
t t ==s ; : : : ; t ==s s s ; : : : ; s
s t s t ; : : : ; t
t t ==s ; : : : ; t ==s s R P s
e e : : : R P t t o
o : : :
v R s ; : : : ; s
u v t o
v R s ; : : : ; s
s ; : : : ; s u
v S u
S t
v s ; : : : ; s u
It is easy to see that a redex is unabsorbed i is
[HuLe91] in . Clearly, unabsorbedness implies essentiality, and Huet&Levy- and
Maranget-neededness coincide for normalizable terms.
Let : and be a subterm or a component in . Then
we say that if doesnâ€™t have -descendants.
(1) Let : and . Then is called in
if there is such that does not have residuals in . is if each
redex in any is erased in [Klo92].
(2) We call a reduction starting from if for any :
there is an initial part : of , and a reduction : such that
+ .
Any strictly conal reduction starting from deletes all inessen-
tial subterms of .
Immediate from Denitions 3.2 and 3.5.
For example, fair reductions are strictly conal: Klopâ€™s proof of conality of
fair reductions (Theorem 12.3 in [Klo80]) can be modied to a proof of strict
conality of fair reductions by using ( ) (Theorem 2.1.(2)) instead of the
CR theorem.
The following lemma from [Kha94] follows from ( ) (Theorem 2.1.(2));
the proofs are same as for OTRS [Kha93].
(1) Let : and . Then ( ) i all -descendants
of are inessential in .
(2) Let and . Then any -descendant of is contained in some
-descendant of .
(3) Let and ( ). Then ( ).
(4) Let be a pattern-subterm of a redex . Then ( ) i ( ).
We write = ( ) if are disjoint subterms
in and is obtained from by replacing them with , respectively.
Let = ( ) in an OERS and let : =
be an -reduction. We dene the reduction ( ) : =
as follows.
(1) If is an -redex and its pattern does not overlap with , then
is the corresponding subterm of in = .
(2) If is an -redex that is not inside the subterms and its
pattern does overlap with some of , then = .
(3) If is an -redex that is outside the replaced subterms, then is the
corresponding -redex in .
(4) If is in some of subterms , then = .
0 0 0
0
0 0
k
j j !
k
!
k !
( f g
Proof.
Proof.
Proof.
n n
i
i
n n
n
n
k
n
n n n
fS
n n
v
m n
i
m
n
n
n
n
n n
Lemma 3.3
Corollary 3.1
Proposition 3.1
1 1
1 1
1 1 0
0
0
1 1
1 1
1 1 1
1 1
1
1
1
1 1 1
1 1
1 1
1
1
1
1
1
1 1
o e
s ; : : : ; s t ; : : : ; t
o e v
o
s v
t o e
s ; : : : ; s t ; : : : ; t
o e s ; : : : ; s
t ; : : : ; t o
u P t P
t s ; : : : ; s
s ; : : : ; s s R t
t ==s ; : : : ; t ==s s t ; : : : ; t t
Q R Q s o
s ; : : : ; s Q t t ; : : : ; t Q
Q v Q s e s ; : : : ; s v s ; : : : ; s
s e v t t o o
e s ; : : : ; s
t ; : : : ; t o
o
t ; : : : ; t o
t ; : : : ; t t
t
t R u t
u t t
IE u; t FV u x ; : : : ; x f
n
s f x ; : : : ; x ==u t IE f x ; : : : ; x ; s
In the rst case, is obtained from by replacing the descendants of
with the corresponding descendants of , respectively; in the
second case, is obtained from by replacing the descendant of by the
descendant of its corresponding subterm in , and by replacing the descendants
of the subterms that do not overlap with by the corresponding descendants
of ; in the third case, is obtained from by replacing outermost descen-
dants of with the corresponding descendants of ; in the fourth
case, is obtained from by replacing the descendants of with the
corresponding descendants of , respectively. Thus, in we can choose
the redex analogously, and so on. (Note that ( ) depends not only on
and , but also on the choice of , but the notation does not give rise to
ambiguity.)
Let be inessential in , in an OERS , and let =
( ) . Then are inessential in .
We show by induction on that if an -reduction : deletes
, then ( ) deletes ; such a exists by Lemma 3.1. Let
= + , , and be all the -descendants of . By
Lemma 3.2.(1), are inessential in . By Denition 3.6, if ( ) : , then
is obtained from by replacing some inessential subterms that contain ,
and all the descendants of also are in the replaced subterms of . By
the induction assumption, the replaced subterms in are inessential. Hence,
by Lemma 3.2.(3), all the descendants of in are inessential and, by
Lemma 3.2.(1), are inessential in .
It follows immediately from Denition 3.6 and the proof of Lemma 3.3 that
replacement of inessential subterms in a term does not eect its normal form.
Any term not in normal form, in an OERS, contains an essential
redex.
If all redexes in were inessential, their replacement by fresh variables
would yield a term in normal form containing inessential subterms, a contradic-
tion.
Existence of an unabsorbed redex in any term not in normal form can be
proved exactly as in OTRSs [Kha93] (the proof does not use the proof of Corol-
lary 3.1).
Let be a term in an OERS and let be a redex in . Then
is essential in i it is Maranget-needed in .
( ) Let ( ). Further, let ( ) = , let be a fresh
-ary function symbol that does not occur in the left-hand sides of rewrite
rules (we can safely add such a symbol to the alphabet, if necessary), and let
= ( ( ) ) . By Lemma 3.3, ( ( ) ), i.e., there is some
SS
1
1
( )
n
n
st
L L
P;;M
Denition 4.1
4 Relative Notions of Neededness
! !
[f g 
)
S
S S
S S
S S
S S S
v

v 2
v h i h i
S S
S v S
 S

S
! S v S
S  S
S
S S S
v !
 !
S
S
S S S
stability
external
external
needed
unneeded
-(un)needed
-normalizing
-(un)needed
-(un)needed
unneeded needed
all
unneeded needed
-suppresses
-suppresses
residuals
trivially -needed
P s f x ; : : : ; x P
r f x ; : : : ; x u Q s t r
R r P Q=P Q P=Q u
P=Q P=Q u
u

 
t
t
P t R
e t P
e e P
u t P pat u P u
 e t  P 
t e 
e t P P P
P
R 
e t

o t o P;; Int o
o
u t
P;;
P t o e t P
e P u t pat u
u
NE e; t UN e; t e P;;M
o t P t s o o
o
u t P t s
pat u P u
pat v v P
pat u pat u pat v u
t
reduction starting from such that ( ) does not have -descendants.
Let : ( ) be a rule and : be the -reduction step. Obvi-
ously, is orthogonal. Hence + + and therefore does
not have -descendants. But does not contract the residuals of . Thus
is not Maranget-needed. ( ) From Denitions 3.2 and 3.1.
In this section, we introduce notions of neededness relative to a set of reductions
and to a set of terms . We show how all existing notions of neededness can
be obtained by specifying or ; -neededness is also a special case of -
neededness. We introduce of a set of terms, in an OERS, and show that
if is not stable, contraction of -needed redexes in a term need not terminate
at a term in even if can be reduced to a term in . It is the aim of the last
section to show that if is stable, then a -needed strategy is -normalizing.
(1) We call a reduction starting from a term in an OERS
to a component if there is no redex executed in whose pattern
overlaps with a descendant of ( can be empty). We call to a redex
if is external to ( ), i.e., if doesnâ€™t contract the residuals of .
(2) Let be a set of reductions. We call - if there is no
starting from that is external to , and call it - otherwise.
(3) We call if it is -(un)needed, where is the
set of all reductions Levy-equivalent to .
(4) Let be a set of terms in , and let be the set of
reductions, i.e., reductions that end at a term in . We call
if it is .
(5) If , then we call ( -) ( ) if so is ( ), the
component obtained from the subterm by removing bound variables. How-
ever, if not otherwise stated, we say that a redex (which is a subterm) is
( -) ( ) if so is its pattern.
(6) We say that : if is -normalizing and
is external to . We say that if it -suppresses ( ),
i.e., is -normalizing and is external to . (Obviously, a redex or component is
-unneeded i it is -suppressed by some -normalizing reduction.)
We write ( ) ( ( )) if is ( )-needed (unneeded).
If and : is external to , then we call the descendants of
also the of . A component that does overlap with the pattern of a
contracted redex does not have residuals. Note that if , then : is
external to ( ) i does not contract the residuals of , because orthogonality
of the system implies that if the pattern ( ) of a redex contracted in does
overlap with a residual of ( ), then ( ) = ( ). Hence is -needed i
at least one residual of it is contracted in each reduction from to a term in
(the intended notion of neededness). Obviously, any redex in a term that is not
-normalizable is -needed; we call such redexes .
2( )
u
s
I x
-
+



 Q
Q
Q
Q
Qs
Q
Q
Q
Q
Qs +




?
-
Denition 4.2
Remark 4.1
g a a
g b b
S
S 62 S ! 2 S
! S
S ! 62 S
2 S S
f ! ! g S f g
S ! ! !
! S
S
S S !
2 S 62 S
S S
f g
!
S S
S S
S S
S
stable
closed under parallel moves
closed under unneeded expansion
none
closed under ( )-normalization
t P t o
Q t e P=Q
e o e
o u
R f x g x; x ; a b g a; a ; g b; b
g a; b g b; b g b; a g b; b f a g a; a
f b g b; b
g b; b
g a; a g b; a
g a; a g b; a a g a; a
g b; a
f a ;
g a; b g b; a
f b ;
G s s
G I x ; x I x
I I x I x
I I x x I I x
The following denition introduces the property of sets of terms for which it
is possible to generalise the Normalization Theorem:
We call a set of terms if:
(a) is : for any , any : , and
any : , the nal term of is in ; and
(b) is : for any such that and
, is -needed.
Of course, a set closed under reduction is closed under paral-
lel moves as well. But a set closed under parallel moves, even if closed un-
der unneeded expansion, need not be closed under reduction. Indeed, consider
= ( ) ( ) , and take = ( ) ( ) . The only one-step
-normalizing reductions are ( ) ( ), ( ) ( ), ( ) ( ),
and ( ) ( ). Therefore, one can check that is closed under unneeded
expansion. Also, is closed under parallel moves, since the right-bottom term
( ) in the diagram below, which is the only non-trivial diagram to be checked,
is in . However, is not closed under reduction, since, e.g., ( ) ( ),
( ) , but ( ) . Note that the second occurrence of in ( ) is
-unneeded, but its residual in ( ) is -needed.
( ) ( )
( ) ( )
( ) ( )
The most appealing examples of stable sets, for an OERS, are the set of
normal forms [HuLe91], the set of head-normal forms [BKKS87], the set of weak-
head-normal forms (a partial result is in [Mar92]), and the set of constructor-
head-normal forms for constructor TRSs [NoÂ¨k94]. The sets of terms having (resp.
not having) (head-, constructor-head-) normal forms are stable as well. The
graph of a term (which consists of terms to which is reducible) is closed
under reduction, but need not be closed under unneeded expansion. For example,
the graph = ( ) of ( ) is closed under reduction but is not closed
under unneeded expansion: ( ( )) can be reduced to ( ) by reducing either
-redex (according to the rule ( ) ). Hence of the redexes in ( ( ))
are -needed. Thus the closure of under unneeded expansion is a necessary
condition for the normalization theorem.
We say that a set of terms is if any reduct
of every -normalizable term is still -normalizable. Obviously, sets closed un-
der parallel moves are closed under normalization as well. Even if is closed
20  0

Proof.
Example 4.1
g a b
Proposition 4.1
-
+



3 kQ
Q
Q
Q
Qs
kQ
Q
Q
Q
Qs +



3
?
6
-
- -
?
-
?
?
-
?
S
S f !
! g S f g ! !
S S S !
S
S S
S
S
f ! ! ! g S f g
S
S
S
! ! ! S
S S
S

)
(
!
R f x
g x; x ; a b g a; b t f a t g a; a g a; b
t f b
f b f b
R f x g x; x ; a b; b a g a; b
f a g a; a
; g b; a
f b g b; b
f a f b
f a f b f a : : :
f a g a; a g a; b
f b g b; b g b; b
u t
t
u t P t
u u
Q t e u
u Q Q Q Q
u Q
under unneeded expansion, closure of under normalization is also necessary
for the normalization theorem to be valid for . Indeed, consider = ( )
( ) , take = ( ) , and take = ( ). Then ( ) ( )
is an -needed -normalizing reduction, while after the -needed step ( ),
the term ( ) is not -normalizable any more (the only redex in ( ) is only triv-
ially -needed). However, the following example shows that closure of under
normalization (even in combination with closure of under unneeded expansion)
is not enough; closure of under parallel moves is necessary.
Let = ( ) ( ) and = ( ) .
Since the reduction preserves the height of a term and the property to be a
ground term, only the terms in the following diagram are -normalizable.
( ) ( )
( ) ( )
( ) ( )
Therefore, it is clear from the diagram that is closed under normalization.
It is easy to see that, in ( ) and ( ), all the redexes are -needed; hence
( ) ( ) ( ) is an innite -needed reduction that never reaches
(there are many others). One can check that is closed under unneeded
expansion. Thus the reason for the failure of the normalization theorem is that,
as it can be seen from the following diagram, is not closed under parallel
moves.
( ) ( ) ( )
( ) ( ) ( )
A redex is Maranget-needed i it is needed w.r.t. the
set of all fair reductions starting from .
( ) Let be Maranget-needed in . Then any fair starting from
should contract a residual of (to erase it). ( ) If is not Maranget-needed,
i.e., there is a reduction : in which is erased and that does not
contract the residuals of , then there is a reduction such that = +
is fair and obviously is not -needed, a contradiction.
l1
1


 0
0
0 0
0
00

0  00
n
n
L
L
u
l lu l
L l
l l l l

! v 

( )
k k
! 
!
 
5 A Labelling for OERSs
Proposition 4.2
Lemma 4.1
Proposition 4.3
Proposition 5.1
Proof.
Proof.
Proof.
label
base
string
initial
signature
redex-index
index
u t u pat u
t
P t s e t o t
e o P
P e
P e
s t
Int s
x ; : : : ; x
s f n
t
f x ; : : : ; x ==s t IE s; t Q t s
P Q t t Int s

R R
R
R R
Ind P
P
t s R v s
t t t s
R v l l u
Ind u < Ind v w s w t w
w Ind w Ind w
A redex is essential i (or ( )) is needed w.r.t. the
set of all fair reduction starting from .
An immediate corollary of Proposition 3.1 and Proposition 4.1.
Let : be external to , and let be the subterm
corresponding to . Then any descendant of along is the subterm corre-
sponding to some -descendant of .
Immediate from Denition 2.3, since is external to .
A subterm is inessential i there is a reduction that is
external to ( ) and deletes it.
( ) Immediate from Lemma 4.1. ( ) Let be the list of oc-
currences of bound variables in from left to right, let be a fresh -ary
function symbol not occurring in left-hand sides of rewrite rules, and let =
( ( ) ) . Since ( ), there is starting from that deletes .
Therefore, it follows from Denition 3.6 that = (( ) ) is external to ( )
and deletes it.
In Kennaway&Sleep [KeSl89] a labelling is introduced for OCRSs, based on the
labelling system of Klop [Klo80], which is in turn a generalization of the la-
belling system for the -calculus introduced by Levy [Lev78]. Each of Ken-
naway&Sleep [KeSl89] is a tuple of labels, built up from a set of labels.
For any OERS , terms in the corresponding labelled OERS are those of
where each subterm has one or more labels, represented as a of labels.
A labelling of a term is if all its subterms are labelled by dierent base
labels. The of a labelled term is the tuple of all its labels, from left
to right. Rules of are those of where pattern-symbols in left-hand sides
are labelled by a string of labels except for the head-symbol, which has just one
label (a string of length one). Each subterm (including metavariables) in the
right-hand side of a rule bears the signature of the corresponding left-hand side.
Further, a of a redex is the maximal depth of nesting in the labels
of the corresponding left-hand side of the rule. The ( ) of a reduction
is the maximal redex-index of redexes contracted in it.
The crucial properties of the labelling are given by the following propositions.
[KeSl89] If a step in an OERS creates a redex ,
then, for any labelling of , the corresponding step in the corresponding
labelled OERS creates a redex whose label contains the label of .
Thus ( ) ( ). If is a residual of a redex , then and
have the same labels, thus ( ) = ( ).
2L z
w
v
0
0 0 0

 â€™
S
!  v \ ; 
v \ ;
2
v
! ! v
6 The Relative Normalization Theorem
with history copy
zig-zag
family
-family
Proof.
Corollary 5.1
Proposition 5.2
Remark 5.1
Denition 5.1
Lemma 6.1
Corollary 6.1
Lemma 6.2
P Q P
u Q t
P u= Q=P P=Q Q=P
u
P Q Qv
Q v Q Pu P Q
P Q=P Q v Q=P u
P Q Qv Pu
labelling P Q
t s v t o t pat v o v s
w v o s w o pat v o
F t v F
s t F s
t s P t o e t v e v=P
P e
[KeSl89] Let and be co-initial reductions such that creates
a redex and does not contract residuals of any redex of having a residual
contracted in . Then the redexes in ( ) are created by and is
external to .
[Klo80, Lev78] Any reduction in which only redexes with a
bounded redex-index are contracted is terminating.
The above propositions are obtained for OCRS, but it is straight-
forward to carry them over OERSs.
(1) For any co-initial reductions and , the redex in the
nal term of (read as ) is called a of a redex if ,
i.e., + , and is a -residual of ; the relation is the
symmetric and transitive closure of the copy relation [Lev80]. A relation
is an equivalence relation among redexes with histories containing the zig-zag
relation.
(2) For any co-initial reductions and , the redexes and are in the
same if for any initial labelling of the initial term of and ,
they bear the same labels.
Proposition 5.1 implies that the labelling-family relation is indeed a family
relation. As pointed out in [AsLa93], for OERSs in general the zig-zag and la-
belling family relations do not coincide. Below by family we always mean the
labelling-family.
In this section, we present a uniform proof of correctness of the needed strategy
that works for all stable sets of â€˜normal formsâ€™. Our proof is dierent from
all known proofs because properties of needed and unneeded components are
dierent in the general case (the main dierence is that a component under an
unneeded component may be needed). However, the termination argument we
use is the same as in [KeSl89] and in [Mar92], and is based on Proposition 5.2.
The main idea and a proof in the same spirit is already in [Lev80].
Below in this section always denotes a stable set of terms.
Let , , , and let ( ) = . Further, let
be a -residual of and be a -descendant of . Then ( ) = .
Immediate from Denition 2.3.
Let be a set of redexes in , and let every redex be
external to . Then any development of is external to .
Let , : , , and be external to . Then is
external to every -descendant of .
- --
?
?
--
?
?
--
?
?
1
1 1 1
1
1 1
1
1 1 1
1 1
1
1
1
n
n m n
m
n m
l
n k l
k m
k
m
m
u
Proof.
Proof.
Proof.
Lemma 6.3
Corollary 6.2
Lemma 6.4
v ! 6 ;
!
!
S S
j j
S
S 62 S S
S 62 S S
! v v
v v
 v
S S
v v
f ! ! g S
S S
    
     
 
0 0 0
0 0  0 0
0 0   
0  0 0
     0 
 
0




0 


0
S S
S S
S
S
P v P
e
s ; : : : ; s s P s e
s ; : : : ; s P s s s ; : : : ; s P s ; : : : ; s
s Q P=P s e Q s ; : : : ; s
P s ; : : : ; s Q s ; : : : ; s
P P v P s ; : : : ; s v
s ; : : : ; s s ; : : : ; s P =v s ; : : : ; s CR com
s ; : : : ; s v=P s ; : : : ; s
P = P =v s ; : : : ; s
v=P s ; : : : ; s P=P v=P P = P =v
s ; : : : ; s
s
v P
e
s
P
v=P
P =v
P = P =v
e
P =P
t
t
t t e s t u e
u s
e s t NE e; t NE s; t
u t s pat u NE u; t NE s; t
s
u
pat u pat u
s
s t o t UN o; t
UN s; t
o e
R f x g x ; a b
a a f a f a
By Lemma 6.1, every -residual of is externa to each -descendant of
, and the lemma follows from Corollary 6.1.
(1) Let be disjoint, let : = be external
to , let : , let be all -descendants of
in , and let = : . Then is external to .
(2) If -suppresses , then -suppresses .
(1) By induction on . Let = + , let be -descendants
of , and let be -descendants of . By ( )
(Theorem 2.1.(4)), are -descendants of . By the in-
duction assumption, ( ) is external to . But by Lemma 6.2
is external to ; hence = + ( ) is external to
.
( )
(2) By (1) and closure of under parallel moves.
(1) Descendants of -unneeded redexes of remain -
unneeded.
(2) Residuals of -unneeded redexes of remain -unneeded.
(1) Let and . Then any -descendant of is con-
tained in some -descendant of .
(2) Let and ( ). Then ( ).
(3) Let and let ( ). Then ( ) i ( ).
(1) By Denition 2.3.
(2) By (1) and Denition 4.1.
(3) From Denition 4.1, since a reduction -suppresses i it -suppresses
(orthogonality of the system implies that any redex whose pattern contains
a symbol from a residual of ( ) coincides with ( ) and hence contains a
symbol from a residual of as well).
Note that if a component is below , then ( ) does not
necessarily imply ( ), although the inessentiality of the subterm corre-
sponding to implies that of the subterm corresponding to (Lemma 3.2.(3)).
Take for example = ( ) ( ) , and take for the set of terms not
containing occurrences of . Then is stable, is -needed in ( ), but ( ) is
not.
âˆ’i
0 1
0 1 1
0 1
1
1
+1
+1
0
S
0 0
S
0 0
S
0
0
S
--
?
?
--
?
?
?
--
?
?
?
?
--
?
?
u
u
u u
i
u u u
i i i
i i
i i
i i
i
i
i
i
i
i
u
Proof.
-needed
Proof.
Proof.
Lemma 6.5
Theorem 6.1 Relative Normalization
Lemma 6.6
62 S ! 
! S
S
S S
! ! S S
S
S 62 S S
62 S S S
S
! ! S
S S S
S
! S
S ! ! S
! ! ! 
 S S
S
 
S ! v \
; S S
 S
! S S
S S
S
t t t UN u; t u t u
UN u ; t
UN u; t P t e pat u
P u P=u u P=u
u
P t t : : :
R
t R
t t
P t s e
e u
s
P t s
e Q t t : : :
Q t t : : : t P P=Q i
Ind P Ind P Q P
u P
Ind u Ind P Ind Q Ind P
Q
t
P
s
t
Q
P
t
u
P
t t s e t NE e; t pat u e
e u s
v t u
P s o
u e P
u P e
Let , , ( ), and let be a -new redex. Then
( ).
( ) implies existence of : that -suppresses ( ); thus
is external to . By Corollary 5.1, is external to . Also, is -
normalizing since is closed under parallel moves. Hence is -unneeded.
We call : if it contracts only -needed redexes.
( ) Let be a stable set of terms in an
OERS .
(1) Any -normalizable term in contains an -needed redex.
(2) If is -normalizable, then any -needed reduction starting from
eventually ends at a term in .
(1) Let : be an -normalizing reduction that doesnâ€™t contain
terms in except for . By the stability of , is -needed. By Corollary 6.2.(2)
and Lemma 6.5, it is either created by or is a residual of an -needed redex in
, and (1) follows by repeating the argument.
(2) Let : be an -normalizing reduction that doesnâ€™t contain
terms in except for , and let : be an -needed reduction. Fur-
ther, let : and = ( 1). By Proposition 5.1,
( ) ( ). Since is -needed and is -normalizing (by the closure
of under parallel moves), at least one residual of is contracted in . There-
fore, again by Proposition 5.1, ( ) ( ). Hence ( ) ( ) and
is terminating by Proposition 5.2.
Let be -normalizable, let , , ( ), and ( ) =
. Then has at least one -needed -residual in . In particular, any -needed
redex dierent from has an -needed residual.
Let : be an -needed -normalizing reduction; there is one by
Theorem 6.1. Then if all -residuals of were -unneeded, would -suppress
them, and + would -suppress , a contradiction.
S S S
S S S
S
S
S f ! ! g
S
! ! ! !
! S
! S S
S
S
S S
7 Conclusions and Future Work
Acknowledgements
References
R f x h f x ; f x ; a b
a
f a h f a ; f a h f b ; f a h f b ; h f a ; f a
h f b ; h f b ; f a : : :
f a f b

[Acz78] Aczel P. A general Church-Rosser theorem. Preprint, University of Manch-
ester, 1978.
regular
-hypernormalizing
minimal optimal
Deterministic Residual Structures Family Structures
We call a stable set if -unneeded redexes cannot duplicate -
needed ones. One can show using Lemma 6.6 (e.g., as in [KeSl89] or in [Kha88])
that, for any regular stable , the -needed strategy is .
That is, a term is -normalizing i it does not have a reduction which contracts
innitely many -needed redexes. However, this is not the case for some irreg-
ular stable . Indeed, consider the OTRS = ( ) ( ( ) ( ))
and take for the set of terms not containing occurrences of . Then the
reduction ( ) ( ( ) ( )) ( ( ) ( )) ( ( ) ( ( ) ( )))
( ( ) ( ( ) ( ))) contracts innitely many -needed redexes, while
( ) ( ) is -normalizing. This example shows also that multistep -needed
reductions need not be -normalizing | just omit in the above reduction the
initial step and group each pair of consecutive steps as a single multistep. Recall
that multistep needed reductions are normalizing in the -calculus [Lev80]. The
same holds for all regular stable ; this follows immediately from hypernormal-
ization of the -needed strategy for such .
We have introduced a relative notion of neededness and proved the Relative
Normalization Theorem in OERSs. We expect that this and other results of
this paper can be proved for other higher-order rewriting systems too. Analo-
gous questions arise for other strategies. For example, how can one construct
reductions that avoid head-normal forms? Besides strong sequentiality for nor-
mal forms studied in Huet&Levy [HuLe91], strong sequentiality is studied w.r.t.
head-normal forms in Kennaway [Ken94]. Investigation of relative strong sequen-
tiality and related to it strictness analysis (see e.g., [NoÂ¨k94]) seems also as an
interesting topic for future research. In forthcoming papers, we extend the the-
ory of relative normalization in two directions: we study and
relative normalization in OERSs, and study relative normalization in an abstract
setting (in and in ).
We thank J. R. Kennaway, F. van Raamsdonk, and M. R. Sleep for useful dis-
cussions, and J.-J. Levy, L. Maranget, and P.-A. Mellies for help in overcoming
diculties in an early version of the paper. The use of empty descendants in the
denition of descendants of components was suggested by L. Maranget. Some of
the diagrams were drawn using P. Taylorâ€™s diagram package.
  
st
nd
th
th
[AEH94] Antoy S., Echahed R., Hanus M. A needed narrowing strategy. In: Proc. of
the 21 ACM Symposium on Principles of Programming Languages, POPLâ€™94,
Portland, Oregon, 1994.
[AsLa93] Asperti A., Laneve C. Interaction Systems I: The theory of optimal reduc-
tions. Mathematical Structures in Computer Science, vol. 11, Cambridge Univer-
sity Press, 1993, p. 1-48.
[Bar84] Barendregt H. P. The Lambda Calculus, its Syntax and Semantics. North-
Holland, 1984.
[BKKS87] Barendregt H. P., Kennaway J. R., Klop J. W., Sleep M. R. Needed Reduc-
tion and spine strategies for the lambda calculus. Information and Computation,
v. 75, no. 3, 1987, p. 191-231.
[DeJo90] Dershowitz N., Jouannaud J.-P. Rewrite Systems. In: J. van Leeuwen ed.
Handbook of Theoretical Computer Science, Chapter 6, vol. B, 1990, p. 243-320.
[Gar94] Gardner P. Discovering needed reductions using type theory. In: Proc. of
the 2 International Symposium on Theoretical Aspects of Computer Software,
TACSâ€™94, Springer LNCS, v. 789, M. Hagiya, J. C. Mitchell, eds. Sendai, 1994,
p. 555-574.
[HuLe91] Huet G., Levy J.-J. Computations in Orthogonal Rewriting Systems. In:
Computational Logic, Essays in Honor of Alan Robinson, J.-L. Lassez and
G. Plotkin, eds. MIT Press, 1991.
[Ken94] Kennaway J. R. A conflict between call-by-need computation and parallelism.
Workshop on conditional (and typed) term rewriting systems, Jerusalem, 1994.
[KeSl89] Kennaway J. R., Sleep M. R. Neededness is hypernormalizing in regular com-
binatory reduction systems. Preprint, School of Information Systems, University
of East Anglia, Norwich, 1989.
[Kha88] Khasidashvili Z. -reductions and -developments of -terms with the least
number of steps. In: Proc. of the International Conference on Computer Logic
COLOGâ€™88, Tallinn 1988, Springer LNCS, v. 417, P. Martin-LoÂ¨f and G. Mints,
eds. 1990, p. 105{111.
[Kha90] Khasidashvili Z. Expression Reduction Systems. Proceedings of I. Vekua Insti-
tute of Applied Mathematics of Tbilisi State University, vol. 36, 1990, p. 200-220.
[Kha92] Khasidashvili Z. The Church-Rosser theorem in Orthogonal Combinatory Re-
duction Systems. Report 1825, INRIA Rocquencourt, 1992.
[Kha93] Khasidashvili Z. Optimal normalization in orthogonal term rewriting systems.
In: Proc. of the 5 International Conference on Rewriting Techniques and Appli-
cations, RTAâ€™93, Springer LNCS, vol. 690, C. Kirchner, ed. Montreal, 1993, p. 243-
258.
[Kha94] Khasidashvili Z. On higher order recursive program schemes. In: Proc. of the
19 International Colloquium on Trees in Algebra and Programming, CAAPâ€™94,
Springer LNCS, vol. 787, S. Tison, ed. Edinburgh, 1994, p. 172-186.
[Klo80] Klop J. W. Combinatory Reduction Systems. Mathematical Centre Tracts
n. 127, CWI, Amsterdam, 1980.
[Klo92] Klop J. W. Term Rewriting Systems. In: S. Abramsky, D. Gabbay, and
T. Maibaum eds. Handbook of Logic in Computer Science, vol. II, Oxford Uni-
versity Press, 1992, p. 1-116.
[KOR93] Klop J. W., van Oostrom V., van Raamsdonk F. Combinatory reduction sys-
tems: introduction and survey. In: To Corrado BoÂ¨hm, J. of Theoretical Computer
Science 121, 1993, p. 279-308.
[Lev78] Levy J.-J. Reductions correctes et optimales dans le lambda-calcul, These de
lâ€™Universite de Paris VII, 1978.
ast
rd
[Lev80] Levy J.-J. Optimal reductions in the Lambda-calculus. In: To H. B. Curry:
Essays on Combinatory Logic, Lambda-calculus and Formalism, Hindley J. R.,
Seldin J. P. eds, Academic Press, 1980, p. 159-192.
[Mar92] Maranget L. La strategie paresseuse. These de lâ€™Universite de Paris VII, 1992.
[Nip93] Nipkow T. Orthogonal higher-order rewrite systems are confluent. In: Proc.
of the 1 International Conference on Typed Lambda Calculus and Applications,
TLCAâ€™93, Springer LNCS, vol. 664, Bazem M., Groote J.F., eds. Utrecht, 1993,
p. 306-317.
[NoÂ¨k94] NoÂ¨cker E. Ecient Functional Programming. Compilation and Programming
Techniques. Ph. D. Thesis, Katholic University of Nijmegen, 1994.
[Oos94] Van Oostrom V. Confluence for Abstract and Higher-Order Rewriting. Ph. D.
Thesis, Free University of Amsterdam, 1994.
[OR94] Van Oostrom V., van Raamsdonk F. Weak orthogonality implies confluence:
the higher-order case. In: Proc. of the 3 International Conference on Logical
Foundations of Computer Science, â€˜Logic at St. Petersburgâ€™, LFCSâ€™94, Springer
LNCS, vol. 813, Narode A., Matiyasevich Yu. V. eds. St. Petersburg, 1994. p. 379-
392.
[Pkh77] Pkhakadze Sh. Some problems of the Notation Theory (in Russian). Pro-
ceedings of I. Vekua Institute of Applied Mathematics of Tbilisi State University,
Tbilisi, 1977.
[Wol93] Wolfram D.A. The Clausal Theory of Types. Cambridge Tracts in Theoretical
Computer Science, vol. 21, Cambridge University Press, 1993.
This article was processed using the LTEX macro package with LLNCS style
