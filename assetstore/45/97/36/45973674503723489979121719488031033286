Theoretical Improvements in Algorithmic Efficiency
for Network Flow Problems
JACK EDMONDS
University of Waterloo, Waterloo, Ontario, Canada
AND
RICHARD M. KARP
University of California, Berkeley, California
ABSTRACT. This paper presents new algorithms for t h e m a x i m u m flow problem, the Hitchcock transportation problem, and the general minimum-cost flow problem. Upper bounds on the numbers of steps in these algorithms are derived, and are shown to compale favorably with upper bounds on the numbers of steps required by earlier algorithms.
First, the paper states the maximum flow problem, gives the Ford-Fulkerson labeling method for its solution, and points out that an improper choice of flow augmenting paths can lead to severe computational difficulties. Then rules of choice that avoid these difficulties are given. We show that, if each flow augmentation is made along an augmenting path having a minimum number of arcs, then a maximum flow in an n-node network will be obtained after no more than ~(na - n) augmentations; and then we show that if each flow change is chosen to produce a maximum increase in the flow value then, provided the capacities are integral, a maximum flow
will be d e t e r m i n e d within at most 1 + logM/(M--1) if(t, S) augmentations, wheref*(t, s) is the
value of the maximum flow and M is the maximum number of arcs across a cut. Next a new algorithm is given for the minimum-cost flow problem, in which all shortest-path
computations are performed on networks with all weights nonnegative. In particular, this
a l g o r i t h m solves the n X n assigmnent problem in O(n3) steps. Following t h a t we explore a
"scaling" technique for solving a minimum-cost flow problem by treating a sequence of derived problems with "scaled down" capacities. It is shown that, using this technique, the solution of a Iiitchcock transportation problem with m sources and n sinks, m ~ n, and maximum flow B,
requires at most (n + 2) log2 (B/n) flow augmentations. Similar results are also given for the
general minimum-cost flow problem. An abstract stating the main results of the present paper was presented at the Calgary
I n t e r n a t i o n a l Conference on C o m b i n a t o r i a l Structures and T h e i r Applications, J u n e 1969. In a paper by l)inic (1970) a result closely related to the main result of Section 1.2 is obtained. Dinic shows that, in a network with n nodes and p arcs, a maximum flow can be computed in 0 (n2p) primitive operations by an algorithm which augments along shortest augmenting paths.
KEY WOl¢l)S AND PHP~ASES: network flows, t r a n s p o r t a t i o n problem, analysis of algorithms
CR CATEGOI{.IES: 5.3, 5.4, 8.3
Copyright © 1972, Association for C o m p u t i n g Machinery, Inc. General permission to republish, but not for profit, all or part of this material is granted, provided that reference is made to this publication, to its date of issue, and to the fact that reprinting privileges were granted by permission of the Association for Computing Machinery. Authors' addresses : J. Edmonds, Department of Combinatorics and Optimization, University of Waterloo, Waterloo, Ontario, Canada; R. M. Karp, College of Engineering, Operations Research Center, University of California, Berkeley, CA 94720; the latter author's research has been partially supported by the National Science Foundation raider Grant GP-15473 with the University of California.
Jc~urnalof the Associationfor Computing Machinery, Vol. 19, No. 2, Apri| 1972.pp. 248-264.

Theoretical Improvements in Algorithmic E~ciency for Network Flow Problems 249
1. The Maximum Flow Problem
1.1. THE LABELING METHOD. A network N is a finiteset {u, v, - • • } called the nodes and a subset of the ordered pairs (u, v), u # v, called the arcs. N e t w o r k N has a special return arc (t, s). Node s is called the source in N and node t is called the sink in N. The set of all arcs of N, except (t, s), we denote by A. For each (u, v) ~ A there is given a number c(u, v) > 0 called the capacity of arc (u, v).
A nonnegative function f(u, v), ranging over all arcs (u, v) of N, is called a flow in N if
(i) for every (u, v) C A, f(u, v) < c(u, v); and (ii) for every node u,
f(u, v) -- ~ f(v, u) = O,
vv
where each sum is over every v for which the summand is defined. For each arc (u, v) of N, f(u, v) represents the amount of flow in arc (u, v), and
also represents the net amount of flow from v to u in the rest of the network "N - (u, v)."
The maximum network flow problem is to find a flow f in N such that f(t, s), the net amount of flow in N - (t, s) from s to t, is maximum.
Let u~, u2, • • • , u, be a sequence of distinct nodes such that, for each i = l, 2, • .. , p - 1, either (u~, u~+~) or (u~+~, u~) is an arc. Singling out, for each i, one of these possibilities, we call the resulting sequence of arcs a path from Ul to Up. Arcs (u~, u~+~) t h a t belong to the p a t h are called forward ares of the p a t h ; the other arcs of the path are called reverse arcs.
Relative to a n y given flow f in N, a (flow) augme~ti~tg path is a p a t h from s to t such that :
Case (a): If (ui, ui+l) C A and (ui+i, ui) ~ A, then
~i ~" C ( U i , Ui+i) - - f ( u i , ui+l) > 0;
Case (b): If (ui, ui+l) C A and (ui+l, ui) C A, then
ei = f(ui+l, ui) > 0;
Case (c): If (u,., ui+l) ~ A and (ui+l, u,.) C A, then
~i = e ( u i , n i T 1 ) - - f ( u i , Ui+1) -~ f(ui+,, u~) > O.
For a given a u g m e n t i n g p a t h P , let e = rain e, > 0. Call each arc (ui, u~+~) or (u~+~, u~) in P such t h a t ei = e a bottleneck arc relative to P and the flow f.
Now alter the flow f as followsI : increase f by e on the return arc (t, s) ; in Case (a), increase the flow on arc (ui, Ui+l) by e; in Case (b), decrease the flow on arc (ui+~, u~) by e; in Case (c), increase the flow on arc (ui, ui+i) by min (e, c(ui, ui+i) - f ( u l , ui+l)) and decrease the flow on arc (ui+l, ui) by max (0, e - c (ui, u~+l) + f ( u i , ui+l)). It is easily checked that t h e f ~thus defined is a flow in N. Thus, since f~ (t, s) = f(t, s) + e, the flow f is not maximum. I t can
1The method of augmentation presented here differs [in Case (c)] from the method originally given by Ford and Fulkerson (cf. [5]). The results of this paper apply, with minor changes, to the Ford-Fulkerson method as well.
Journal of the Association for C o m p u t i n g Maclainery, Vol. 19, No. 2, April 1972

250 J. EDMONDS AND R. M. KARP
be shown that, conversely, a flow f in N is not maximum only if there is an augmenting path with respect to f.
The labeling method constructs a sequence F = fo, fl, f2, . . . of flows in N, starting
with, say, the zero flow, by finding an augmenting path with respect to f if one exists, and then augmenting to obtain fk+l. The sequence terminates only when a maximum flow has been obtained.
Assuming that all the capacities c (u, v) are integers, then clearly for any augmenting path P relative to any integer-valued flow f, e is a positive integer. Thus, since f0 is integer-valued, all the later flows fk in the sequence F are integer-valued. It follows that the sequence terminates after a number of labelings not greater than the final value of f (t, s).
The following example illustrates that this upper bound on the number of labelings can actually occur.
11
st
V
Suppose that the arc (u, v) has capacity 1, and the capacity of each of the other arcs in A is M, a positive integer. Then the maximum value of f(t, s) is 2M, and 2M
labelings will be required if the labeling process alternates between selecting (s, u)(u, v)(v, t) and (s, v)(v, u)(u, t) as an augmenting path. For, in each case, either (u, v) or (v, u) is a bottleneck arc, and e = 1.
Assuming that all the capacities are mutually commensurable, we can obtain an equivalent integer-valued problem by multiplying all the capacities by a large constant. Thus, in this case also, the sequence F is finite.
Ford and Fulkerson show by an example that if the capacities are not commensurable then the sequence F need not terminate, and in fact, may converge to a nonmaximum flow.
Since numerical computation is always, in practice, performed on numbers expressed to a finite precision, this nonfiniteness is not from a practical viewpoint a very serious matter. It does serve as another indication of the tendency of the number of augmentations to grow as the precision to which the capacities are expressed increases.
We will show that these theoretical difficulties, which could conceivably be a practically serious matter, can be avoided. In particular, by making a certain refinement of the labeling method which is so simple that it is likely to be incorporated
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972

Theoretical hnprovements in, Algorithmic E~ciency for Network Flow Problems 251
innocently into a computer implementation, we get a bound of at most ~ (Q - n) terms in the sequence F (regardless of commensurability), where n is the number of nodes. In addition, a second refinement of the labeling m e t h o d is shown to yield a bound on the length of F, applicable only in the case of integer capacities, of 1 10gM/(M--:)f*(t, S), where f*(t, s) is the value of a m a x i m u m flow, and M < n2/2.
1.2. A REFINEMENT. T h e labeling m e t h o d requires as a subroutine a labeling process for finding, if one exists, an a u g m e n t i n g p a t h P relative to a given flow f in N. This is essentially a method for finding, in a certain network N I having the same nodes as N, a directed p a t h from s to t. A directed path from s to t is a p a t h such that all arcs are forward arcs. The ordered pair (u, v) is an arc of N I if and only if either
(u,v) C A and c(u,v) -f(u,v) > 0
or
(v,u) ~ A and f(v,u) > 0.
The arcs of any directed path pI from s to t in N i are in one-one correspondence with the arcs of an augmenting path P in N relative to f. The arc of p I corresponding to a bottleneck arc of P is also referred to as a bottleneck arc.
The labeling process for finding a directed path in N I from s to t is as follows: First s gets "labeled." Then at each successive step of the process some labeled but "unscanned" node gets scanned. To scan a labeled node u means to label every node v not already labeled and such that the arc (u, v) is in N I. If v gets labeled when u is scanned, then u is the predecessor of v in the labeling.
As soon as the sink t gets labeled, then t, the predecessor of t, the predecessor of that predecessor, and so on back to s, is the reverse sequence of a directed path in NI from s to t. On the other hand, if every labeled node gets scanned w i t h o u t t getting labeled, then there is evidently no directed p a t h in N I from s to t. Clearly the labeling process terminates in one or the other of these two situations.
The refinement treated here, which gives an upper bound of [ (n3 -- n) on the number of applications of the labeling process before obtaining a maximum flow, is the following: I n the labeling process, scan on a "first-labeled first-scanned" basis. T h a t is, before scanning a labeled node u, scan the nodes t h a t got labeled before u.
It can be shown that a directed path in N l from s to t, obtained by this version of the labeling process, is one which contains a minimum number of arcs. Thus, the upper bound can be stated as follows:
THEORE~I 1. If, in the labeling method for finding a maximum flow in a network on n nodes, each flow augmentation is done along an augmenting path having fewest arcs, then a maximum flow will be obtained after no more than :1 (n3 - n) augmentations.
For present purposes, we will regard the number of arcs in a path as its length. The "distance" from a node u to a node v in N I is the minimum length of a directed path from u to v in N I, or else ~ if there is no such path.
Let F = fo, fl, f2, . . . be any sequence of flows in N such that fk+l is obtained from by an a u g m e n t a t i o n corresponding to a shortest directed p a t h pk in N Ik. Let N k denote N Sk , and let 5k (u, v) denote the di•stance from u to v m• N k .
LEMMA 1. If k < m and (u, v) is a bottleneck arc relative to pk and fk, and also relative to pm and f f , then, for some 1such that k < 1 < m, (v, u) C pZ.
LEMMA2. I l k < l, (u, v) ~ pk and (v, u) C pt, then ~(s, t) > ~k(s, t) + 2.
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972

252

J. EDMONDS AND R. M. KARP

Given these lemmas, the proof of T h e o r e m 1 is at hand. Let {u, v} be any pair of nodes such t h a t (u, v) ~ A or (v, u) ~ A. Let the sequence {ki} consist of all indices
ki such t h a t either (u, v) or (v, u ) is a bottleneck arc relative to P ~ a n d f ~. B y L e m m a
1, one can find a sequence {l~}, containing {kl} as a subsequence, such that
(u, v) ~ P*~, j odd and (v, u ) ~ Pt~, j even
or
(u, v) ~ P*~, j even and (v, u) ~ Pt~, j odd.
B y L e m m a 2, 6zj+'(s, t) > 6Zj(s, t) + 2, j = 1, 2, • • • . Thus, ~t*j(s, t) > 2 ( j - 1). B u t the length of any directed p a t h in N k is at most n - 1 so t h a t 6*j (s, t) < n - 1 for all j. T h e length of the sequence {/j} is therefore at most ½(n - 1) + 1 = ½(n -+ 1), and thus the n u m b e r of occurrences of (u, v) or (v, u) as a bottleneck arc throughout the entire labeling method is at most ½(~ + 1). The number of occurrences of bottleneck arcs altogether is therefore bounded by

n+2 l(n12 - n3-n4

And, since every augmentation determines a bottleneck arc, the number of augmentations is also bounded by z1 (n3 - n).
The proof of Lemma 1 employs two simple propositions.
PROPOSITION 1. If (u, v) is a bottleneck arc relative to pk and f~, then (u, v) ~ N k+l.
PROOF. T h e augmentation f r o m f k t o f k+l is such that, if (u, v) C A t h e n f k+l (u, v) = c (u, v), and if (v, u) ~ A then fk+l (y, U) = 0; hence, (u, v) ~ N *+1. II
PROPOSITmN2. If (U,V) C N k+lthen (u,v) ~ N kor (v,u) C pk.
PROOF. Suppose (u, v) C N k+l and (u, v) ~ Nk; then, either fk+1(u, v) ~ fk(u, v)
orffl +~(v, u) ~ fk (v, u). In either case, (u, v) or (v, u) must be in pk. But (u, v) ~ pk, since (u, v) ~ N*; thus, (v, u) ~ pk.
We can now prove L e m m a 1. B y Proposition 1, (u, v) C Nk+I; since (u, v) ~ p,n, ( u , v ) C N m. Let 1 + 1 = m i n { t I t > /~and (u,v) ~ N t } . T h e n ( u , v ) ~ N ~+~, (u, v) ~ N~; hence, by Proposition 2, (v, u) ~ P~. This completes the proof of L e m m a 1. II
The proof of Lemma 2 will make use of the following proposition.
PROPOSITION" 3. For t~ = O, 1, 2, • • • , and for all u,

~(s, u) < ~+~(s, u)

(1)

and

6~ (u, t) < /t~+~(u, t).

(2)

PROOF. We prove (1), the proof of (2) being similar. If 6k+~(s, u) = ~ , the result is evident. Assuming 6k+~(s, u) = h is finite, let s = u0, u~, . . . , uh = u be the node sequence of a shortest directed p a t h from s to u. T h e n 6k (s, u0) = 0 and we claim that

6k(s, ui+l) _~ 1 + 6k(s, ui), i = 0 , - " , h - 1.

(3)

For, since (ui, u~+~) ~ N ~+1, Proposition 2 tells us that (u,, ui+~) ~ N ~ or (ui+~, u~) ~ P~. In the former case, fi~(s, u~+~) < 1 + 6~(s, ui), since the arc (ui, ui+~) enables us to get a directed path from s to Ui+l in N ~ having no more t h a n 1 + 6~(s, u~) arcs. In the latter case, ~i~(s, ui) = 1 + 6~(s, ui+~), so fi~(s, u~+i) =

Journal of the Association for C o m p u t i n g Machinery, Vol. 19, No. 2, April 1972

Theoretical Improvements in, Algorithmic Ei~ciency for Network Flow Problems 253

- 1 + ~(s, ul) < 1 -F 5k (s, ui). Summing the inequalities given in (3),

~k(s,u) < h + g ( s , u0) = h = g+1(s,u),

and (1) is proved. II To prove Lemma 2 note that, since (u, v) ~ pk, ~k(s, t) = ~k(s, u) + 1 -b (3k(v, t).
Also, ~k(s, v) = 1 + ~tk(s, u) and/tk (u, t) = 1 + ~k(v, t). Since (v, u) C pZ, ~tl(s, t) = ~Z(s, v) ÷ 1 + ~tZ(u, t). But, by Proposition 3, St(s, v) _> ~*(s, v) and 5Z(u, t) _> ~k(u, t), so that ~l(s, t) > ~ik(s,v) -t- 1 -t- ~k(u,t) = (1 + ~k(s,u)) + 1 -I- (1 + ~k(v,t)) = 2 + ~tk(s, t). Thus, Lemma 2 is proved, and we are done. II
The proof of Theorem 1 can be modified quite simply to supply bounds on the numbers of augmentations required in certain other refinements of the FordFulkcrson labeling method. Let a (u, v) be a real-valued function defined whenever (u, v) C A or (v, u) C A, such that b (u, v) = a(u, v) + a(v, u) > 0. Let theweight of a path P in N having the node sequence ul, u2, .." , % be ~_--~ a(ui, Ui+l). Consider a variant of the labeling method in which each augmentation is along a flow-augmenting path of minimum weight. Then the number of augmentations cannot exceed (S ,'~(u.v)c a 1/[b (u, v )] ) -I- I A [, where S is the maximum weight of a path from source to sink. Theorem 1 corresponds to the ease where a (u, v) = 1 for all pairs (u, v). Another ease, corresponding to the rule: "select a flow-augmenting path with as few reverse ares as possible," has a(u, v) = 1 if (v, u) C A, and a(u, v) = 0 otherwise. A bound on the number of iterations in this ease is ~1 (n3 -- n2).
1.3. A SECOND REFINEMENT. In this section we consider the following refinement of the labeling method: at each iteration choose a flow-augmenting path which gives the largest possible augmentation.
Let N be a network in which every capacity is an integer. Let M > 1 be a positive integer such that, for any partition of the nodes of N into two sets, X and X, with s C X and t { 2 , the number of ares with one end in X and the other in 2 is less than or equal to M. Let f* (t, s) denote the value of a maximum flow.
THEORmr 2. If, in the labeling method for finding a maximun flow in N, a network with all capacities integral, each augmentation is done along an augmenting path giving the maximum possible augmentation, then a maximum flow will be obtained after no more than 1 -~- lOgM/(M--1)f* (t, S) augmentations.
Before proving Theorem 2, we show how the rule under consideration can be implemented. Suppose we arc seeking a flow-augmenting path in N relative to a flow f. Associate with each arc (u, v) C N f a number e (u, v) equal to the value of e that would result if (u, v) were a bottleneck arc in a flow-augmenting path relative to N and f. Specifically,

(i) if (u,v) C A and (v,u) ~, A, (it) if (u,v) ~ A and (v,u) C A, (iii) if (u,v) C A and (v,u) ~ A,

then e(u,v) = c(u,v) - f(u,v), then e(u,v) = f(u,v),
then e(u,v) = e(u,v) -f(u,v) q-
/(v, u).

Then the labeling method seeks a directed path from s to t in N z in which the mallest value of e (u, v) is as large as possible. This is a bottleneck problem of the ype studied in [4]. One method of finding such a path is to label s, and then to repeat he following step until t is labeled: find an are (u', v') ~ N I such that u' is labeled, ' is not labeled, and for any are (u, v) from a labeled node to an unlabeled node, (u', v') _> e (u, v). Label v' and record u' as the predecessor of v'. When t is labeled,

Journal of the Association for C o m p u t i n g Machinery, Vol. 19, No. 2, April 1972

254 J . E D M O N D S A N D R. M. K A R P

tracing the sequence of predecessors back from t gives a maximum-e flow-augmenting path. If, at some step, there is no arc from a labeled node to an unlabeled one, then no flow-augmenting path exists.
PROOF OF THEOREM 2. Consider a partition of the nodes of N into two sets, X and 2, such that s E X and t E X. Define

c(X, 2) and
Then, for any flow f,

= ~ c(u,v),f(X,X)
uE._" vE X
(u,v) EA

= ~ f(u,v)
uEx vEX (u,v) EA

f(X,X)

= ~ f(u,v).
uE£ vEX (u,v)EA

c(X, X) > f(X, X) -- f(X, X) = f(t, s).

Suppose the labeling method using maximum augmentations produces the sequence of flows f0, fl, . . . , fk, . . . . Let ek = f + l (t, s) - fk (t, s). Consider the augmentation fromff to f+~. Let the set X consist of s together with all nodes which can be reached from s by a directed path in N k consisting of arcs (u, v) such that e(u, v) > k; let X denote the remaining nodes. Then t C 2 and every arc (u, v) in N k such that u E Xandv E 2satisfiese(u,v) < ek.
c(X, 2) - [f*(X, 2) -- f~(2, X)] _< ~kl {(u,v) lu E X , v C 2 , (u,v) ~ A or (v,u) C A]} 1 _< ekM.

Now f* (t, s) < c (X, 2 ) and ~ (t, s) = fk (X, 2 ) - fk (2, X), so

f*(t, s) - fk(t, S) < cAM; i.e. f*(t, s) -- fk(t, s) < [fk+'(t, s) -- fk(t, s)]M. Equivalently,
f*(t, s) -- f~+~(t, s) < [f*(t, s) -- fk(t, s)](1 -- /~-1). Thus, by induction,
f*(t, s) -- ff(t, s) < f*(t, s)(1 -- M-l) k. Now, since all the capacities are integers, each flow is integral. Thus, if f is not a maximum flow, then

f * ( t , s ) - f ( t , s ) >_ 1,
SO
f*(t, s)(1 -- M-l) k >_ 1 and

k _~ --logl--1/Mf* (t, S) ---- IOgM/(M--1)f*(t, S ), SO the total number of augmentations cannot exceed
1 -t- IOgM/(M--1)f (t, S). Let 6 denote the average capacity of an arc in A. Then f* (t, s) < 6n2 and M < ~1 n2,
SO

iOgM/(M--1)f*(t, S) < logl+2/(~2-2)(n26) =

in n26

In (1 + 2/(n ~ -- 2))"

Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972

Theoretical Improvements in Algorithmic E~ciency for Network Flow Problems 255

But

( 2 )> in(i+ 2) 2 1(2) 2

In 1--~-n~---~-

_

~ >n--~-- ~ ~ .

Using these estimates we find that the number of augmentations cannot exceed

2 In n + In 5

n4

1 -t- 2(1/n 2 - 1/n 4) = 1 + -2n2- - 2 ( 2 1 n n -k ln~)

= n21nn+½n 21nS-t-O(n 21nn+n21no).

Thus, although the present bound depends on the capacities and requires their integrality, it is superior to the bound of Section 1.2 in approximately the range 0 < g < e~/4.

2. The Minimum-Cost Flow Problem
2.1. A LABELINGMETHOD. In this section we turn to the problem of finding a maximum flow of minimum cost. Given a network N, associate with each arc (u, v) E A a nonnegative cost d(u, v) as well as the usual positive capacity c(u, v). Let the cost of a flow f be ~(~,,)e ~ d(u, v)f(u, v) and let its value be f(t, s). We seek
flow of minimum cost among those with value f*(t, s). Call a flow f extreme if it is of minimum cost among flows with value f(t, s). We mention some well-known characterizations of extreme flows. In doing so, we make use of the network N s associated with f. We recall that a network, by definition, has at most one are from one given node to another. For convenience we also assume that (u, v) C A ~ (v, u) ~ A. Obvious devices using "fictitious nodes" can be used to enforce this restriction if it does not originally hold. Associate with any arc (u, v) of N s a weight ~ (u, v) as follows:

~d(u, v), A(u, v) = ~-d(v, u),

(u, v) C A, (v, u) E A.

Define the weight of a subgraph of N s as the sum of the weights of its arcs. Define a labeling function as a function from the nodes to the real numbers.
THEORE~I 3. 2 Let f be a flow. Then the following are equivalent: (i) f is extreme, (ii) every directed cycle in N s has nonnegative weight,
(iii) there exists a labeling function 7r such that, for every arc (u, v) of N s, ~(u) + ~(u, v) - ~r(v) _> 0.
A restatement of (iii) in terms of the network N is: for (u, v) ~ A,

~r(u) -- 7r(v) + d(u, v) > 0 ~ f(u, v) = O, 7r(u) -- z'(v) + d(u, v) < 0 ~ f(u, v) = c(u, v).

(4)

If the flow f and the labeling function 7r together satisfy (4), then f and 7r are called compatible.
Another basic result is the following.

2 The e q u i v a l e n c e of (i) and (iii), s t a t e d in a s o m e w h a t different f o r m , can be f o u n d in [5, pp. 114-115].

Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972

2 5 6 J. EDMONDS AND R. M. KARP

THEORE:U 4. ([5, p. 121]). I f f i8 extreme and P is a path of m i n i m u m weight in N s from 8 to t, then a flow f' obtained by augmenting along P is extreme.
For brevity call a path of minimum weight a "shortest path." Theorem 4 suggests the following method of solving the minimum-cost flow problem: starting with an extreme flow f0, compute a sequence of extreme flows J~, fl, . . . , fk, fk+l, . . . obtaining fk+l from fk by augmenting along a shortest path from 8 to t in N sk. A shortest path can be determined using the following algorithm.

ALGORITHM A: S h o r t e s t - P a t h A l g o r i t h m
Let N fk h a v e the set of arcs A k, and let A(u, v) be t h e w e i g h t of arc (u, v) C A k. (1) Set a(s) = 0 and set ~(u) = -k-~, u ~ s. (2) Set S = {s}. (3) If S = 4~, h a l t ; o t h e r w i s e choose u* s u c h t h a t u* E S and or(u*) = m i n u Es,r(u)(4) F o r each v s u c h t h a t (u*, v) C A k, s e t
,r(v) = rain (a(v), a(u*) A- A(u*, v)).
If this process decreases a(v), adjoin v to the set S. (5) Delete u* from S and go to (3).

Algorithm A has the following properties: (1) Upon its termination, a(u) gives the weight of a shortest path from s to u; (2) If A (u, v) >_ 0 for every arc (u, v), then each vertex accessible from s enters the set S exactly once, so that the total amount of computation is proportional to the number of ares;
(3) If no cycle is of negative weight, then each vertex accessible from 8 enters the set S at most n - 1 times, so that the total amount of computation has a bound proportional to n - 1 times the number of ares;
(4) If there is a negative-weight cycle accessible from 8, then the algorithm is nonterminating. One way to detect this is to keep a subgraph T of tentative shortest paths. T contains arc (u, v) if v last entered S during an application of Step (4) with
$
u = u. Any cycle in T has negative weight; if a negative-weight cycle is accessible from 8, then such a cycle will occur in T by the time an5' vertex enters S for the nth time.
The discussion of the shortest-path algorithm shows the efficiency to be gained in eases when all weights are nonnegative. Too little attention has been paid to this essential point in the development of algorithms for minimum-cost flows. We present in this section an algorithm designed so that all shortest-path calculations are done on networks with all weights nonnegative.
Let f be a flow and let ~- be a labeling function. Assign each arc (u, v) of N ] a weight X ( u , v ) = ~r(u) -4- A ( u , v ) -- 7r(v).
Then clearly

(i) if C is a directed cycle, then

5(u,~)= ~ a(u,~);

(u,v) ~ C

(u,v) CC

(ii) if P is a directed p a t h f r o m u* to v*, then

~(u, ~) = ~-(u*) - ~-(~*) + ~ ~(u, ~).

(u,v) ~P

(u,v) EP

Thus, N s has a cycle of negative weight with respect to the weights A (u, v) if

Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972

Theoretical Improvements in Algorithmic Efficiency for Network Flow Problems 257
and only if N I has a cycle of negative weight with respect to the weights A (u, v). Also, P is a shortest path from s to t with respect to the weights A (u, v) if and only if P is a shortest path from s to t with respect to the weights A (u, v). Consider the implications of these facts when f and ~r are compatible. Then A (u, v) > 0, and a minimum-weight flow-augmenting path (relative to the weights A(u, v)) can be found by a shortest-path calculation using the nonnegative weights A(u, v).
A variant of the algorithm suggested by Theorem 4 is now apparent which performs all shortest-path calculations on networks with all weights nonnegative.
ALGORITHMB: Minimum-Cost Flow Algorithm (1) Set f0 equal to the zero flow, and set 7r° equal to the identically zero labeling function; (2) Given fk and 7rk, determine fk+l by augmenting along a minimum-weight path from s to t
in N/k with respect to the (nonnegative) weights
ak(u, v) = ~-k(u) + ,~(u, v) - ~-k(v).
If several minimum-weight paths exist, choose one with the fewest arcs. (3) If ak(u) d e n o t e s t h e w e i g h t of a s h o r t e s t p a t h f r o m s to u w i t h r e s p e c t to the w e i g h t s
Ak, set lr~+l(u) = ~k(u) + aS(u); t a k e ¢k(u) = 7rk+l(u) = -]-~ if u is inaccessible f r o m s in N/k .
(4) Halt when, for some k, no flow-augmenting path exists with respect to fk
Some properties of the algorithm are given in the following theorem. THEORE~ 5. For each k, fk and 7rE are compatible. For eaeh k and u, 7rk (u ) gives the weight of a shortest path from s to u in N Ik with respect to the weights A (u, v) and
~'~÷'(u ) _> ~'~ (u ).
We present two bounds on the number of flow augmentations required by the minimum-cost flow algorithm.
THEOREM 6. /f all the capacities are integers, then the computation terminates after
at most f* (t, s) flow augmentations. PROOF. Each flow fk is integral, and each augmentation increases the flow by a
positive integer. [r THEORE~r 7. Suppose the costs d (u, v) are integers less than or equal to an integer D.
Then the computation terminates after at most 1 + ~ (n3 - n ) (n - 1 )D flow augmentations.
PROOF. We show that the overall computation can be regarded as a sequence of at most (n - 1)D + 1 phases, each consisting of a maximum flow computation. Each phase corresponds to a period during which 7rk (t) remains constant. Suppose 7rk (t) is constant for k~ < k < k2. Then the flow augmentations involved in passing from fk~ to fk: are along directed paths in the subnetwork N ' containing those arcs (u, v) i n N Ik' such that ~rk~(u) + A(u, v) -- 7r~ (v) = 0. Hence, these augmentations Ltre part of a maximum-flow computation in N ' . The bound of Section 1.2 is applicable, since the algorithm selects, at each step, a path with fewest arcs among those of minimum weight. Hence, the number of augmentations per phase is at most
(n3 - n). Now, except at the last step, when t is inaccessible by a flow-augmenting 9ath and ~rk~) = oc, 7rk (t) is the weight of some path in N from s to t, and hence is ~n integer between 0 and (n - 1 )D. Thus, noting that 7rk(t) is nondecreasing with ~, we see that the number of phases, excluding the last step, is at most (n -- 1)D, md the theorem follows. [I
COROLLARY 1. Algorithm B solves any minimum-cost flow problem in a finite nTm)er of steps (even when neither the capacities nor the costs are commensurable).
Journal of the Association for Computing Machinery, Vol. 19. No. 2, April 1972

2 5 8 J. EDMONDS AND R. M. KARP
PROOF. The first half of the proof of Theorem 7 is applicable in this case, and shows that there is a finite bound on the number of successive flow augmentations without an increase in ~rk(t). But, for any k, ~.k(t) is the weight of some directed path from s to t in N f~, corresponding to some path without repeated vertices in N. Since the number of such paths is finite ~-~(t) increases only a finite number of times, so that the entire process must be finite. I]
Although it is comforting to know that the minimum-cost flow algorithm terminates, the bounds on the number of augmentations are most unfavorable. The scaling method of the next two sections is a variant of this algorithm in which the bound depends logarithmically, rather than linearly, on the capacities. A challenging open problem is to emulate the results of Section 1.2 for the maximum-flow problem by giving a method for the minimum-cost flow problem having a bound on computation which is a polynomial in the number of nodes, and is independent of both costs and capacities.
2.2. A SCALING METHOD FOR THE HITCHCOCK TRANSPORTATION PROBLEM. In this section and the following one, we present a technique for solving a minimumcost flow problem by treating a sequence of problems with the same cost as the given problem, but with "scaled down" capacities which approximate those of the given problem to successively more digits of precision. The efficiency of this scaling method is based on the following two features:
(1) the capacities, and hence the flow augmentations, in the approximate problems are on a coarser scale than in the original problem;
(2) the final solution of each approximate problem yields a good initial flow for the next approximate problem.
We prove that the number of computation steps required by the scaling method is proportional not to the capacities (as in the method of Section 2.1) but to the numbers of digits in the binary representations of the capacities. Roughly speaking, the scaling method is related to the original method as binary arithmetic is to unary arithmetic (i.e. counting).
First we consider a special case in which the scaling technique is particularly
simple. The Hitchcock transportation problem asks for a maximum flow of minimum
cost through a network of the type shown in Figure 1. The costs and capacities are as follows:
arc (s, si) has cost 0 and capacity al, i = 1, 2, • • • , m; arc (t~., t) has cost 0 and capacity bj, j = 1, 2, . . . , n; arc (sl, tj) has cost d~j and capacity % oo, i = 1, 2, • .. , m, j = 1, 2, • • • , n; the return arc (t, s) has cost 0 and capacity + ~o.
It is assumed that ~i'21 al = ~ - 1 bj. The value of a maximum flow is clearly
The standard interpretation of this problem is well known. Each vertex s~ corresponds to a "source" at which ai units of a commodity are available; each vertex t~. corresponds to a "desffnation" which demands b~. units of the commodity. The cost per unit of shipping from s~ to tj is dlj, and a shipping pattern is sought which minimizes the cost of meeting the demands at the destinations from the supplies at the sources.
In the following specialization of the criteria for an extreme flow given in eq.
(4), ui denotes 7r(s~) and vj denotes lr(tj); also, fii denotes f(s~, tj) when i >_ 1
a n d j > 1; foi denotes f (s, si) and fio denotes f ( t j , t).
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972

Theoretical I m p r o v e m e n t s in A l g o r i t h m i c E giciency for N e t w o r k Flow Problems 259

__._____..o

~,

.....

° ~t

FIG, 1

THEOREM N. The flow f is extreme among maximum flows for the network of Figure 1, i f a ~ d o n l y i f there e x i s t uo , u l , • •. ,Um a n d vo , vl , • • • , v~ s u c h that

u~-- wj-t-d~j_> 0, i = ~,2, . . - , m ; j = 1,2, . . - , n ,

(5a)

ui -- v; -~- di; > 0 ~ L j = 0, i = 1, 2, . . . , m ; j = 1, 2, . . . ,~t, (5b)

Uo > u i ~ foi = 0, Uo < ui ~ f 0 i = a,, vi > Vo~ f ~ o = O,

(5c) (Sd) (5e)

vj < Vo~ j ~ o = b;

(5f)

Call a flow f for the Hitchcock problem pseudo-extreme if there exist ui and v; satisfying (5a) and (5b). A pseudo-extreme maximum flow is extreme; for a maximum flow has f0i = ai, i = 1, 2, . . . , m andfj0 = b i , j = 1, . . . , n. Thus, if (5a) and (5b) are satisfied, we may satisfy (5c)-(5f) by setting Uo = mini=l.2.., mU~ and w0 = maxj=l.2....,,, v;. For a problem of the Hitchcock type with ~ a~ ~ ~ bj, a pseudo-extreme maximum flow is not, in general, extreme.
Algorithm B can, of course, be used to solve the Hitchcock problem. An alternate method is based on the fact that a maximum pseudo-extreme flow is extreme. A sequence of pairs (f0, ~.0), (fl, ~.1), " " , (fk, ~.k) is computed where, for each k, (fk. ~_k) satisfies (Sa) and (Sb), so that fk is pseudo-extreme. The determination of (fk+l, ~_k+l) from (fk, ~.k) differs from the corresponding ste~ in the previous algorithm in only one respect: if f~i < ai then arc (s, s~) in N j is assigned cost
(s, s~) = 0, regardless of ~.k similarly ~ (tj, t) = 0 iffj0 < b;. It is easily checked that, if (fk, ~.k) satisfies (5a) and (Sb), then so does (f~+~,~_k+~); thus, fk+~ is pseudoextreme if fk is. If the capacities a~ and bj are integers then an upper bound on the number of flow augmentations is ~ l a ~ .
Now we are prepared to present the scaling method. For any nonnegative integer p, define Problem p to have the same nodes, arcs, and costs as the given problem, but with the capacities changed as follows: the capacity of (s, s~) is [ai/2 p] and the capacity of (re, t) is [bff2v].3Thus, the original problem is Problem 0 and, in general, the capacities in Problem p are obtained by deleting the p low-order digits in the binary representations of the original capacities.
3 ,, [x]" m e a n s " g r e a t e s t i n t e g e r l e s s t h a n o r e q u a l t o x . "

Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972

260 J. EDMONDS AND R. M. KARP

LEMMA 3. I f f is a pseudo-extreme flow in Problem p, then 2f is a pseudo-extreme

flow in Problem p - 1.

Choose 1 such that every finite capacity has at most 1 digits in its binary expan-

sion; i.e.a~ < 2 *, i = 1,2, - . - , m , a n d b i < 2 t, j = 1,2, . . . , n . T h e n the scaling

method computes maximum pseudo-extreme flows successively for Problems l -- 1,

1 - 2, • • • , 0. If f is the maximum pseudo-extreme flow computed in Problem p,

and 7r is the associated labeling function, then 2f is taken as the initial pseudo-

extreme flow in Problem p - l, with rr as its associated labeling function.

The following theorem bounds the number of flow augmentations in the solution

of a transportation problem by the scaling method.

THEOREM 9. The number of flow augmentations in applyi~g the scaling method to

a transportation problem with integral "supplies" a~, a~, . . . , am and integral "de-

mands" bl, b2, • • • , bn is less than or equal to
(I •= ai
max (m, n) 2 + logs ,na~'~.7, n)

"

PROOF. Let fv* denote the value of a maximum flow in Problem p. The initial flow in Problem 1 - 1 is 0 and, for p < 1, the initial flow in Problem p - 1 is 2fp*. Recalling that each augmentation gives a positive integral increase in the flow, the total number of augmentations is bounded above by

l--1 l--1
ft*-i q- ~_, (f*-~ -- '2fp*) = fo* -- E f p * "
p=l p=l

(6)

Now

fv" = m i n ( ~,I:=a,~ ~71 '

~
j=

I
l

b

3,1_5)7

>_o.

We can write ai = 2p[ai/2 ~] + ri~,, where 0 _< rip < 2p - 1. Hence,

Similarly,

~[a~] i=x

~ai- ~rip ~al i=l i=1 > i = 1
2P -- '2P

~bj
j=l
i = l 2v n .
Let B denote the common value of ~ i ~ , ai and Ejn=l bj, and let L denote
[log2 (B/max (m, n))]. Then

,> fp/-

max

(

0,

B 2--7

-

max (m, n))

and

fp* >_
p=l p=l

)-- max (m, n) .

Journal of tile Association for C o m p u t i n g Machinery, Vol. 19, No. 2, April 1972

Theoretical Improvements in Algorithmic Efficiency for Network Flow Problems 261

Applying this inequality to (6), and noting that fo* = B, we find that an upper bound on the total number of flow augmentations is
B / 2 L + L m a x (re, n) _< (L + 2) max (re, n).

This completes the proof, ll We remark that this bound on the number of flow augmentations is approxi-
mately equal to the number of binary digits required to encode the data of the transportation problem. Each augmentation requires O(m, n) computation steps, so that the number of computation steps in the entire process is bounded by a lowdegree polynomial in the size of the problem, as measured by the length of the input text. In this sense the scaling method is a "good" algorithm.4
2.3. A SCALING M E T H O D FOR THE ~'~INIMUM-CosT FLOW PROBLEM. R e f e r e n c e s [6] and [7] give a simple method of converting any minimum-cost flow problem having IA I arcs and n nodes into an "equivalent" Hitchcock transportation problem with
IA [ sources, n destinations, and a maximum flow of ~(~.,)c i C(U, V). By Theorem 9, the application of the scaling method to such a derived transportation problem requires at most

(L + 2)[ A I

flow augmentations where L = log2 (~(u.~.)c(u, v)/[ A I). Thus, the approach of converting to an equivalent transportation problem which is solved by the scaling method yields a good algorithm for the minimum-cost flow problem.
In this section, we consider the direct application of the scaling method to the minimum-cost flow problem. The general approach is clear. Given a minimumcost flow Problem on a network N with costs d (u, v) and capacities c (u, v), define Problem p as a problem identical with the given one except that the capacity of arc (u, v) is given by [e(u, v)/2v]. Choose 1 as the least integer such that 2l > e(u, v) for all (u, v) C A. Then the plan is to solve Problems 1 - 1, 1 - 2, . . . , 0 successively using Algorithm B, taking twice the final flow in Problem p as the initial flow in Problem p - 1. There is a major difficulty, however. If.fp* is a minimum-cost maximum flow in Problem p, then 2fv* is a flow in Problem p - l, but not, in general, an extreme flow. In the case of the transportation problem this difficulty was not serious, since it was possible to work with pseudo-extreme flows instead of extreme flows. For general minimum-cost flow problems the remedy for this difficulty is somewhat more complex.
We begin by showing that if f is extreme in Problem p, then 2fis "almost extreme" in Problem p - 1. Since f is extreme in Problem p, there is a labeling function 7r such that

~-(u) + d(u, v) - ~-(v) > 0 ~ f(u, v) = 0,

(u, v) C A,

~'(u) + d(u, v) - ~'(v) < 0 ~ f(u, v) = [c(u, v)/2P], (u, v) C A.

Using the inequalities
Fe(u, )1 Fe( ,v)l
2 L - ~ - - J -< L~T-'-J -< 2 L 2 G - - J + 1,

4 The concept of a " g o o d a l g o r i t h m " is discussed in detail in [2].

Journal of the Associationfor Computing Machinery, Vol. 19, No. 2, April 1972

262 z. EDMONDS AND R. M. KARP

we have

~r(u) + d(u, v) -- ~'(v) > 0 ~ 2f(u, v) = O,

(7)

7r(u) + d(u, v) -- ~r(v) < 0 ~ 2f(u, v) < [c(u, v ) / 2 p-'] < 2f(u, v) + 1.

B u t compatibility of f and ~r in P r o b l e m p - 1 requires

~r(u) + d(u, v) - ~r(v) < 0 ~ 2f(u, v) = [c(u, v)/2P-1].

Thus, 2f and ~r fail to be compatible in P r o b l e m p - 1 b y at most one unit of flow on any arc. We give an efficient method of transforming 2f to a flow which has the same value and is extreme in P r o b l e m p -- 1. T h e m e t h o d can be regarded as a v a r i a n t of the Fulkerson out-of-kilter algorithm [5] in which the "flow c h a n g e " and "potential change" phases are combined into a single computation.
We state the method as it applies to an arbitrary integral feasible flow g in Problem p -- 1, and an a r b i t r a r y labeling function 0. Dcfine el(u, v) = O ( u ) + d(u, v) -- 0 (v). Define Kg.o (u, v), the kilter number of ~rc (u, v) relative to g and 0, as

g(u, v),

if d(u, v) > 0,

0, if d(u,v) = 0,

Ic- ~(u-,j ~)~ - g(u, v),

if d(u, v) < 0.

Thus, g and 0 are compatible if and only if each arc has kilter number zero. Also, relative to 2f and 0, the kilter n u m b e r of each arc is 0 or 1.
The following algorithm derives, from an incompatible pair (g, 0), a new pair (gt, 0'), in such a w a y t h a t

(i) Kg,,o,(U, v) < Ko,o(U, v), (u, v) E A, and
(ii) ~_,(u,~)caKo,,o,(U, v) < ~_,(u,v)caK~,o(u, v) - 1.

ALGORITHM C: K i l t e r N u m b e r R e d u c t i o n
(1) F o r m t h e a u g m e n t a t i o n n e t w o r k N °, h a v i n g A rJ as its set of arcs. F o r each arc (u, v) E A g' define

~(u, v), 7~(u,v) = [-d(u,v),

if (u, v) E A and g(u, v) < [c(u, v)/2p-ll, if ( v , u ) E A and g(v,u) > O.

Label each are (u, v) E A g with the weight

B(u, v) = max (~(u, v), 0).

(2) Choose an arc (u*, v*) of N g such t h a t

(a) (u*, v*) E A, or (b) (v*,u*) E A,

a(u, v) < 0 and g(u, v) < [~(u, v)/2P-l], ~ ( u , v ) > 0 a n d g(u, v) > O.

(3) L e t N* = {x [ x = v* or N * has a d i r e c t e d p a t h from v* to x}. F o r x E N*, set 6(x) equal to t h e m i n i m u m w e i g h t of a d i r e c t e d p a t h f r o m v* to x. F o r x (~ N* set

~(x) = max [0(u) - ~(v, u)].
{(v,u)EAOIv~:N*, uEN*}

Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972

Theoretical Improvements in Algorithmic E~ciency for Network Flow Problems 263

For each node z, let O'(x) = O(x) + 8(x). (4) If u* ~ N*, then q' = g.
If u* C N*, choose a cycle C of N g consisting of (u*, v*) together with a minimum-weight path from v* to u*. Obtain g' from g by performing a flow augmentation around the cycle C.
We make the following assertions (omitting proofs):
(i) For each arc (u, v), Kg,,v (u, v) < Kg,0 (u, v) ; (ii) if (u*, v*) C A,
Ko,,v(u*, v*) _< Ko,e(u*, v*) - 1;
(iii) if (v*, u*) C A,
Ko,.o' (v*, u*) < Ko,e(v*, u*) - 1.
By iteration of Algorithm C, the pair (2f, ~-) can be converted to an extreme flow for Problem p - 1 having the same value as 2f. Since each iteration reduces the sum of the kilter numbers by an integer, the number of iterations will not exceed ~(~,,)ea K i n , ((u, v)). But, since K2i., (u, v) C {0, 1}, the number of iterations is bounded b y ]A [.
We are now in a position to give a complete statement of the scaling algorithm.
ALGORZTHM n: Scaling A l g o r i t h m for M i n i m u m - C o s t F l o w s
(1) Set f = 0 and ~- = 0. Choose ! such that, for all (u, v) E A, c(u, v) < 2Z. Set p = 1 - 1. (2) Solve Problem p by the algorithm of Section 2.1, using f as the initial flow and ~r as the
initial labeling function. After this step] is a maximum flow of minimum cost in Problem p, and ~r is compatible with f in Problem p. (3) If p = 0, halt. Otherwise replace p by p - 1 and replace f by 2f. (4) Apply Algorithm C repeatedly, starting with the pair (f, ~r), until a compatible pair (g, 8) is obtained. Set f = g and ~- = 0. Go to 2.

The number of steps required in applying this algorithm can easily be bounded. The number of executions of Algorithm C in Step (4) is at most ]Al(l - 1).
The number of flow augmentations (each requiring an application of Algorithm A to a network with nonnegative weights) is bounded above by

1--1 l--1
fz*-i + ~ fv*-1 -- 2fp* = f 0 * - - ~ f v * .

(8)

The number of applications of Algorithm A to networks with nonnegative weights to verify that a m a x i m u m flow has been reached is I.
T o put an upper bound on (8) we establish a lower bound on fp*. Let T be an upper bound on the number of arcs in a cut-set separating s from t;i.e.if the nodes are partitioned into sets X and X such that s C S and t E X, then the number of arcs directed from a node in X to a node in X is lessthan or equal to T. According to the max-flow rain-cut theorem ([5])
fv* = min .E~ LP(u2~")Jl=~7"YLP(u2p")Jl

for some partition (Y, 1~). N o w
e(u, ")7 > e(u, ,)
---~--A -- 2P

1,

Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972

264 J. EDMONDS AND R. M. KARP
so
1 1,
fp* >_ ~ ~ c(u, v) -- T _> ~ f o -- T.
uEY vET"
Substituting this inequality in (8) gives, as an upper bound on the number of flow augmentations,
]0-- ~~p-=~l( 1~,f o -- T) = : ~1f o , + ( l - - 1 ) T < 1T.
The following theorem sums up our conclusions. THEOREM 10. Let N be a network with n nodes, I A [ arcs, and at most T arcs in a
cut-set separating s from t. Let l be the number of binary digits needed to represent the largest arc capacity. Then the scaling method solves the minimw~t-cost flow problem for N using not more than I A I (l - 1) applications of Algorithm C and not more than l -- 1 + lT applications of Algorithm A to networks with ~wnnegative weights. Each network considered in the algorithm has n nodes and at most I A [ arcs. REFERENCES (Note. References [1, 3, 6, 7] are not cited in the text.) 1. DINIC, E . A . Algorithm for solution of a problem of maximum flow in a network with
power estimation. Soy. Math. Dokl. 11 (1970), 1277-1280. 2. EDMONDS, J. Paths, trees and flowers. Canadian J. Math. 17 (1965), 449 467. 3. EDMONDS, J., AND KARP, R . M . Theoretical improvements in algorithmic efficiency for
network flow problems. Combinatorial Structures and Their Applications. Gordon and Breach, New York, 1970,pp. 93-96 (abstract presented at Calgary International Conference on Combinatorial Structures and Their Applications, June 1969). 4. EDMONDS, J., AND FULKERSON, D. R. Bottleneck extrema. RAND Corp. Memorandum RM-5375-PR (Jan. 1968). 5. FORD,L. I{., AND FULKERSON,I). R. Flows in Networks. Princeton U. Press, Princeton, N.J., 1962. 6. FULKERSON, D. ll. On the equivalence of the capacity-constrained transshipment problem and the Hitchcock problems. RAND Corp. Memorandum RM-2480 (Jan. 1960). 7. WAGNER, H.M. On a class of capacitated transportation problems. Manag. Sci. 5 (1959), 304 318.
RECEIVED SEPTEMBER 1970; REVISED AUGUST 1971
Journal of the Association for Computing Machinery, Vo|. 19, No. 2, April 1972

