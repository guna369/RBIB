Theoretical Computer Science 318 (2004) 373–408
www.elsevier.com/locate/tcs
The decidability of a fragment of BB′IW-logic
Sabine Brodaa ;∗ , Lu)*s Damasa , Marcelo Fingerb , Paulo Silva e Silvab
aDCC-FC, Universidade do Porto, Rua do Campo Alegre 823,
4150 Porto, Portugal
bDepartamento de Cieˆncia da Computac"a˜o, Instituto de Matem&atica e Estat&(stica,
Universidade de Sa˜o Paulo, Brazil
Received 11 November 2002; received in revised form 19 January 2004; accepted 5 February 2004
Communicated by D. Plotkin
Abstract
Despite its simple formulation, the decidability of the logic BB′IW has remained an open
problem. We present here a decision procedure for a fragment of it, called the arity-1 formulas.
The decidability proof is based on a representation of formulas called formula-trees, which is
coupled with a proof method that computes long normal -terms that inhabit a formula.
A rewriting-system is associated with such -terms, and we show that a formula admits a
BB′IW--term if and only if the associated rewriting-system terminates. The fact that termination
is decidable is proved using a result on the 8niteness of non-ascending sequences of n-tuples in
Nn, which is equivalent to Kripke’s Lemma.
c© 2004 Elsevier B.V. All rights reserved.
1. Introduction
The Hilbert-style logic T→ of “ticket entailment”, introduced and motivated by
Anderson and Belnap [1], is the system of implicational propositional logic based
on the axiom schemes
B : (→ )→ (→ )→ → ;
B′ : (→ )→ ( → )→ → ;
I : → ;
W : (→ → )→ → 
∗ Corresponding author.
E-mail address: sbb@ncc.up.pt (S. Broda).
0304-3975/$ - see front matter c© 2004 Elsevier B.V. All rights reserved.
doi:10.1016/j.tcs.2004.02.002
374 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
and the rule
→  

(→ e):
Surprisingly, the problem of decidability of this logic remains unsolved, although
several studies have been carried out leading to a better insight on its nature.
Due to the fact that the axiom schemes of T→, or BB′IW-logic, are the principal
types of
B : xyz:x(yz);
B′ : xyz:y(xz);
I : x:x;
W : xy:xyy;
the problem is in fact equivalent to 8nding an algorithm to decide whether a given
type=formula has any inhabitants that are applicative combinations of these four terms.
Also BB′IW-proofs are represented by closed BB′IW-de8nable -terms. In [12], a precise
characterisation of the class of BB′IW-abstractable terms was presented. That approach
was developed in terms of combinators but it can easily be transposed to -terms, as
in [5], leading to the decidable class of BB′IW--terms. Consequently, a type=formula
 is a theorem of T→ iJ there is a BB′IW--term to which the type  can be assigned.
Based on this characterisation, Bunder presented an algorithm in [5] that, applied to a
type , produces in 8nite time a (long) normal BB′IW-inhabitant if there is one, but
that may run forever if  is not BB′IW-inhabited. So, his algorithm does not, in general,
provide a decision procedure.
In this paper, we solve the problem of decidability for a restricted class of formulas,
called arity-1 formulas. In Section 2, we 8x the notation and point to some results and
methods that will be used in the remainder of the paper. We then present the class
of arity-1 formulas, a fragment of the →-language. In Section 3, we de8ne the no-
tion of terminating rewriting-systems over typed sequences that will be used to prove
BB′IW decidability for arity-1 formulas. Our proof is based on a mapping R( ) from
arity-1 formulas to rewriting-systems. It will be shown in Section 4 that an arity-1
formula  is BB′IW-inhabited if and only if the rewriting-system R() is terminating.
Decidability of termination of rewriting-systems over typed sequences is proved in Sec-
tion 5 using a result on non-ascending Nn-sequences equivalent to Kripke’s Lemma,
cf. [1].
2. Preliminaries
We assume familiarity with the basic notions in -calculus and use standard notation
from [2] and [8]. Our notation diJers from that in [2], since we denote type-variables
(atoms) by “A;B;C; : : :” and arbitrary types by lower-case Greek letters. For type
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 375
assignment, we consider the system TA of simply typed -calculus Ma la Curry (for an
introduction see [8] or [2]). A term M has a bound-variable clash iJ M contains an
abstractor x and a occurrence of x that is not in its scope. Note that for any -term M
exists a -term N = M without bound-variable clashes. In this paper we will generally,
but for the result of Algorithm 2.18, consider -terms without bound-variable clashes.
2.1. BB′IW--terms
In the following, we describe the set of -terms that can be de8ned in terms of the
combinators B, B′, I and W. We call these terms BB′IW--terms since they represent
BB′IW-proofs. Furthermore, a formula  is a BB′IW-theorem if and only if there is
some BB′IW--term to which the type  can be assigned.
Denition 2.1. Let x˜= x1; : : : ; xn, where n¿0, be a 8nite sequence of distinct variables
and let  represent the empty sequence. The implicit order ≺ induced by a constant ⊥
and x˜ is ⊥≺ x1≺ · · · ≺ xn. The x˜-index of a -term P, Ind˜x (P), is the ≺-maximum
of x1; : : : ; xn in FV (P), or ⊥ if none of x1; : : : ; xn occurs in FV (P).
Denition 2.2. The set of hereditary right-maximal terms relative to x˜, HRMx˜, is
de8ned as:
• every variable is in HRMx˜;
• if P ∈HRMx˜y and y∈FV (P), then y:P ∈HRMx˜;
• if P;Q∈HRMx˜ and Ind˜x(P)4 Ind˜x(Q), then PQ∈HRMx˜.
The notion of hereditary right-maximal terms was introduced in [12], and we note
that our de8nition of HRMx˜ corresponds to HRM(1;:::; n) ∩Once+(1;:::; n) in that work. The
following characterisation of the set of BB′IW--terms results mainly from the work
in [12].
Proposition 2.3. A closed -term P is a BB′IW-term if and only if P ∈HRM.
A BB′IW-term to which a type  can be assigned is called a BB′IW-inhabitant of .
The following result, together with the subject-reduction property, reduces the existence
of BB′IW-inhabitants to the case of -normal forms.
Property 2.4. Consider a BB′IW-term M and a term N such that M→ N . Then, N
is a BB′IW-term.
Proof. It is suPcient to show that for any sequence x˜ and redex (y:P)Q∈HRMx˜
we have FV ((y:P)Q)=FV (P[Q=y]) and P[Q=y]∈HRMx˜. The former is trivial since
y∈FV (P), and for the latter we will show that for every subterm M of P such that
M ∈HRMx˜yz˜, for some sequence of variables z˜, one has M [Q=y]∈HRMx˜ z˜. Then, since
P ∈HRMx˜y, it follows that P[Q=y]∈HRMx˜.
376 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
First note that Q∈HRMx˜ and no element of z˜ occurs in it. Now, we proceed
by structural induction on M . The result is trivial if M is a variable. Now, sup-
pose that M =(P1P2)∈HRMx˜yz˜, hence P1; P2 ∈HRMx˜yz˜ and Ind˜xyz˜ (P1)4 Ind˜xyz˜ (P2).
By the induction hypothesis, P1[Q=y]; P2[Q=y]∈HRMx˜ z˜. Thus, in order to prove that
(P1P2)[Q=y]∈HRMx˜ z˜ it suPces to show that Ind˜x z˜ (P1[Q=y])4 Ind˜x z˜ (P2[Q=y]). For
that, consider the cases:
• Ind˜x z˜ (P1[Q=y])=⊥. The result is trivial.
• Ind˜x z˜ (P1[Q=y])∈ x˜. Then no z ∈ z˜ occurs in P1 and from Ind˜xyz˜ (P1)4 Ind˜xyz˜ (P2)
we obtain the result.
• Ind˜x z˜ (P1[Q=y])= zi ∈ z˜. Since no z ∈ z˜ occurs in Q, it follows from Ind˜xyz˜ (P1)4
Ind˜xyz˜ (P2) that Ind˜x z˜ (P2[Q=y])= zj and zi4 zj, which gives us the result.
Finally, if M = u:P1 ∈HRMx˜yz˜, then P1 ∈HRMx˜yz˜u and u∈FV (P1). Thus, by the
induction hypothesis, P1[Q=y]∈HRMx˜ z˜u. Then, it follows from u∈FV (P1[Q=y]) and
from De8nition 2.2 that (u:P1)[Q=y] = (u:(P1[Q=y])∈HRMx˜ z˜.
A -normal inhabitant M of a type  is called a long normal inhabitant of  iJ
every variable-occurrence z in M is followed by the longest sequence of arguments
allowed by its type, i.e. iJ each component with form (zP1 : : : Pn), (n¿0), that is not in
a function position has atomic type. The 8nite set of all terms obtained by "-reducing
a -term M zero or more times is called the "-family of M and denoted by {M}".
It has been shown (cf. [3,8]) that the "-families of the long normal inhabitants of 
partition the set of normal inhabitants of  into non-overlapping 8nite subsets, each
"-family containing just one long member. Furthermore, Ben-Yelles (cf. [3,8]) showed
that every normal inhabitant of a type  can be "-expanded to one unique (up to -
conversion) long normal inhabitant of . A simple expansion-algorithm can be found
in [8]. The following result implies that when looking for -normal BB′IW-inhabitants
of a type, one can just search for long normal BB′IW-inhabitants from which all other
-normal inhabitants can be obtained by "-reduction.
Property 2.5. Consider two -terms M and N such that M→" N . Then, M is a
BB′IW-term if and only if N is.
Proof. Let x˜ be a sequence of variables and y:Py a term such that y =∈FV (P).
Then, FV (y:Py)=FV (P) and consequently Ind˜x(y:Py)= Ind˜x(P). On the other
hand, y:Py∈HRMx˜ if and only if Py∈HRMx˜y and since y =∈FV (P) this holds if
and only if P ∈HRMx˜.
In the following, we describe the straight relation that exists between subterms and
variables in a long normal inhabitant of a type ’ and the subtypes of ’. It is well
known that for every (long) normal inhabitant M of a type ’ there is exactly one
deduction in the system TA that assigns the type ’ to M . Thus, in the remaining we
sometimes refer to the types that are assigned to variables and subterms of a normal
inhabitant during this unique deduction as their types. We begin recalling the rather
standard de8nition of polarities of occurrences of subtypes=subformulas.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 377
Denition 2.6. An occurrence of a subtype in a type is de8ned as positive or negative
as follows:
• ’ occurs positively in ’;
• if an occurrence of a subtype is positive (negative) in ’, then it is negative (resp.
positive) in ’→ ;
• if an occurrence of a subtype is positive (negative) in , then it is positive (resp.
negative) in ’→ .
The following properties of long normal inhabitants follow almost directly from the
de8nitions and give us some insight on the relation between the structure of a type and
the structure of their long normal inhabitants (an exhaustive analysis of this relationship
can be found in [8], cf. Section 8E—The structure of an nf-scheme).
Lemma 2.7. Consider a long normal inhabitant M of a type ’ and let P be a subterm
of M .
(i) If P= x1 : : : xn:N , with n¿1 and such that N is no abstraction, then there is
some positive occurrence of a subtype of the form = 1→· · ·→ n→A in ’ and
P is of type . Furthermore, x1; : : : ; xn are respectively of type 1; : : : ; n, which
are negative occurrences of subtypes of ’, while N is of atomic type A.
(ii) If P=yM1 : : : Mn, with n¿0 and such that M1; : : : ; Mn are all the arguments
applied to y, then there is some negative occurrence of a subtype of the form
= 1→· · ·→ n→A in ’, y has type  and P;M1; : : : ; Mn have respectively types
A; 1; : : : ; n.
We conclude mainly that variables in abstraction sequences correspond to negative
occurrences of subtypes and that subterms in argument position correspond to positive
occurrences of subtypes. Also, every variable x with a type 1→· · ·→ n→A occurs
always with exactly n arguments in a long normal inhabitant, i.e. in an expression
of the form xP1 : : : Pn of type A and such that P1; : : : ; Pn are, respectively, of types
1; : : : ; n. Moreover, if i = 1→· · ·→ k→B, i∈{1; : : : ; n}, then Pi is of the form
y1 : : : yk :N such that y1; : : : ; yk have types 1; : : : ; k which are negative occurrences
of subtypes, and N has type B.
2.2. The formula-tree proof method
A central element in our decidability proof is the tree-like representation of types
called formula-tree representation, 8rst introduced in [4]. 1 In this representation, every
type ’ is split into primitive parts, and the primitive parts themselves form a tree-
like structure, which is called the formula-tree of ’, and that de8nes some kind of
hierarchy over the primitive parts of the formula. Here, every primitive part, except the
1 A short presentation of the method together with an implementation as a Java applet can be found at
http://www.ncc.up.pt/~sbb/FTLab/ftlab.
378 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
one in the root of the formula-tree, represents together with the subtree rooted in it
a subtype of ’ that, during the construction of a long normal inhabitant of ’, may
be assigned to variables. 2 The formula-tree of ’, tree(’), can then be used to build
proof-trees for ’, each proof-tree being a representation of a 8nite non-empty set of
long normal inhabitants of ’. Since ’ may have none, a 8nite or an in8nite number
of long normal inhabitants it may consequently be possible to build none, a 8nite or
even an in8nite number of diJerent proof-trees for ’.
Primitive parts (frequently represented inside of boxes) are items of either one of
the following forms (P1), (P2) or (P3), where A; B; B1; : : : ; Bn; C denote type-variables:
(P1) :
|
A
(P2) : (n¿ 1) (P3):
C
|
Here, A; B1; : : : ; Bn are called the tail-variables of the respective primitive part, while
B and C are head-variables. The arity of a primitive part is the number of its tail-
variables. Moreover, we will always associate with each primitive part a unique label
pi which allow us to have distinct primitive parts with the same appearance.
Denition 2.8. A formula-tree is a tree-like structure with primitive parts as nodes,
but such that subtrees descend from the branches (or tail-variables) of primitive parts
rather than from the whole primitive parts as nodes. Then, such a structure is called a
formula-tree iJ
• the root of the formula-tree is the only primitive part of form (P1);
• every node of form (P2) or (P3) in the formula-tree descends from a tail-variable
in another primitive part;
• every (labeled) primitive part occurs only once in a formula-tree.
The following algorithm computes the formula-tree tree(’) of a type ’. We use
dashed lines for the edges of the formula-tree in order to distinguish them from the
edges in the primitive parts (nodes) of the formula-tree. Furthermore, we will use
the expression branch only when referring to edges in primitive parts, but not when
referring to (dashed) edges of formula-trees.
Formula-tree Algorithm 2.9.
Input: A type ’= 1→· · ·→ n→A, where A is an atom and n¿0.
Output: ’’s formula-tree tree(’).
The formula-tree tree(’) is given by the following.
• If n=0, i.e. ’≡A, then tree(’)= |
A
.
2 In [8], these subtypes are also called negative subpremises.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 379
• If n¿1, then tree(’)=
where t(A)=
A
|
and for k¿1 and m1; : : : ; mk¿0 we recursively de8ne
t((11→· · ·→1m1 →A1)→· · ·→(k1→· · ·→ kmk →Ak)→A)=
Furthermore, for 16j6k, we call the primitive parts in the top of t(j1); : : : ; t(jmj)
the descendents of primitive part
at branch j (or tail-variable Aj). Note, that in case mj =0, branch j, i.e. tail-variable
Aj, has no children=descendents.
We assume that all primitive parts introduced above are given distinct labels, thus
ensuring that each primitive part occurs only once as required in the de8nition of a
formula-tree.
In the following we exemplify the formula-tree algorithm as well as the notion of
descendents of a primitive part at a branch (tail-variable).
Example 2.10. The formula
’ = (((A→ A)→ (A→ (A→ B)→ A)→ A)→ A)→ ((B→ A)→ B)→ A
has formula-tree
tree(’) =
tree((((A→A)→ (A→ (A→B)→A)→A)→A)→ ((B→A)→B)→A) =
380 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
with primitive parts
p0 =
|
A
; p1 =
A
|
A
; p2 =
B
|
A
; p3 =
A
|
A
; p4 = ;
p5 =
B
| and p6 =
A
| :
In the formula-tree tree(’), p0 has descendents p1 and p2 at p0’s branch 1 (p0’s
only branch), p1 has descendents p3 and p4 at p1’s branch 1 (p1’s only branch),
p2 has descendent p5 at its only branch 1, p4 has descendent p6 at branch 2 and no
descendent at branch 1, and 8nally p3, p5 and p6 have no descendents at all.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 381
It is easy to see that for every negative occurrence of a subtype  of a type ’ there
will be a subtree t() of tree(’), suggesting the following relation between subtrees
and the types of variables in long normal inhabitants (cf. Lemma 2.7): given a long
normal inhabitant M of a type ’ and a variable x in M of type  there is exactly one
subtree t() of tree(’) corresponding to x. Any such subtree can be identi8ed by
the primitive part in its top position. So, from now on we call this the primitive part
corresponding to the variable x in M . Note that, while every variable in M has exactly
one corresponding primitive part in tree(’), given a primitive part p in tree(’) there
may be more than one variable in M for which p is the corresponding primitive part,
or there may even be no such variable. The result below follows from the de8nition
of corresponding primitive part and from the observations made after Lemma 2.7.
Lemma 2.11. Let M be a long normal inhabitant of a type ’ with formula-tree
tree(’), consider any variable x in M and let p be the primitive part in tree(’)
corresponding to x. If p is of arity k¿0, then x occurs always with exactly k argu-
ments in M . Furthermore, for k¿1, if i∈{1; : : : ; k} and p has descendents p1; : : : ; pm
at branch=tail-variable i in tree(’), then the ith argument of x is of the form
y1 : : : ym:N and the primitive parts in tree(’) corresponding to y1; : : : ; ym are,
respectively, p1; : : : ; pm.
Furthermore, one can easily de8ne an inverse algorithm, which given a formula-tree
FT computes the unique type ’ such that tree(’)= FT. In the following example, we
give some intuition on the meaning of primitive parts and the hierarchy de8ned on
them.
Example 2.12. The formula ’=((A→B)→A→B)→(A→B)→A→B has formula-
tree
tree(’) = tree(((A→ B)→ A→ B)→ (A→ B)→ A→ B) =
382 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
p3 =
A
| and p4 =
A
| :
Note that part p4 connects to the branch 1 of part p1 with tail variable B.
Then we get the following information from this representation: during the construc-
tion of a long normal inhabitant of ’ there may appear variables of type (A→B)→
A→B, of type A→B or of type A, which are the negative subtypes of ’, cf.
Lemma 2.7. These are represented, respectively, by the subtrees t((A→B)→A→B),
t(A→B) and t(A) (the latter occurs twice). As such, using a variable x of type
(A→B)→A→B, corresponding to the subtree t((A→B)→A→B) with primitive part
at its top, allows us to construct a term of type B—the head-variable of p1. Furthermore,
in order to complete the construction of this term, two other terms of type B and of
type A, respectively,—the tail-variables of p1—have to be constructed. Also x will
appear with two—the arity of p1—arguments, and for the construction of the 8rst
there will appear a new variable of type A represented by t(A), i.e. corresponding to
p4—the descendent of the 8rst branch of p1. Actually, all this parallels the fact, cf.
Lemma 2.7, that every long normal term beginning with a variable x of type (A→B)→
A→B is of the form x(y:M)N of type B, where y, M and N are, respectively, of
type A, B and A, and 8nally in M there may appear a new variable y of type A.
The previous discussion illustrates that we can associate to each variable in a long
normal inhabitant M of a type ’ a subtree t(i) of tree(’) with primitive part pi
at its top (the corresponding primitive part). Now, consider M ′ obtained from M by
replacing each variable in M with the name of the corresponding primitive part and by
erasing abstractions. For example, for the long normal inhabitant M = xyz:x(w:yw)z
of ’ as above we obtain M ′=p1(p2p4)p3, which represented as a tree gives, after
inserting a top level node p0, the following tree of primitive parts
It turns out that one can characterise precisely the trees of primitive parts that corre-
spond to long normal inhabitants of a type and which will be called valid proof-trees.
We now describe the set of rules that allows us to build proof-trees and then give two
conditions to be satis8ed by a proof-tree in order for it to be valid. In the remaining
we will often use the notation To to refer to a speci8c occurrence of an object o.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 383
Denition 2.13 (Proof-tree structure). A proof-tree for a type ’ is a tree-like structures
whose nodes are primitive parts in pp(’)= {p0; : : : ; pn}, the set of (labels of the)
primitive parts in the formula-tree of ’ and where p0 denotes the primitive part in the
root of tree(’) (thus the only primitive part of form (P1) in pp(’)). In the following,
we shall use the notation to designate a proof-tree that has in a leaf a primitive
part with a tail-variable A.
Then, the set of proof-trees for ’ is given by the following:
• If p0 = |A ∈ pp(’), then
|
A
is a proof-tree for ’;
• if is a proof-tree for ’ and ∈ pp(’) where k¿1,
then is a proof-tree for ’;
• if is a proof-tree for ’ and B| ∈ pp(’), then is a proof-tree for ’.
Denition 2.14 (Valid proof-trees). Given a proof-tree PT for a type ’, we call it a
valid proof-tree for ’ iJ
• the number of subtrees rooted in any node=primitive part in PT equals the arity of
that primitive part;
• if
p′ =
with k¿1 is a primitive part in the formula-tree tree(’), and p is a descendent
of p′ in tree(’) at branch i, with 16i6k, then above every occurrence Tp of p
in PT there is at least one occurrence Tp′ of p′ in PT, such that the occurrence Tp
occurs in the subtree of PT rooted in the i’th branch of Tp′.
This last item corresponds to the hierarchy of tree(’) being imposed on the con-
struction of a valid proof-tree and will be illustrated by the following example. From
384 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
now on, we will usually, and for the sake of saving space, represent valid proof-trees
without drawing edges between primitive parts explicitly. As such, the tree of primitive
parts at the end of Example 2.12 will be represented by
p0
p1
p2 p3
p4
:
Due to the 8rst condition in the de8nition of a valid proof-tree (De8nition 2.14) there
will be no ambiguity regarding descendents=parents in the tree. Also, for the sake of
saving space, we will unify the head variable and tail variables of two parts that are
linked in a proof-tree.
Example 2.15. A valid proof-tree for the formula ’ in Example 2.12 is
p0
‖
p2
‖
p3
i.e.
|
B
‖
B
|
A
‖
A
|
:
Using the compact representation this proof-tree will be represented by
p0
p2
p3
and has
appearance
|
B
|
A
|
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 385
after unifying=overlapping the linked variables. On the other hand, the tree
p0
p2
p4
is
not a valid proof-tree for ’ (though it would have the same appearance), since it
does not respect the hierarchy given by the formula-tree of ’, which requires that in
a valid proof-tree all occurrences of p4 occur in some subtree that is rooted in the
left branch of an occurrence of p1. Moreover, there are exactly three proof-trees with
appearance
; that are
p0
p1
p2 p3
p4
;
p0
p1
p2 p3
p3
and
p0
p1
p2 p4
p4
:
Only the 8rst two of these proof-trees are valid proof-trees, since the third does again
not satisfy the second condition of De8nition 2.14.
Another valid proof-tree is
p0
p1
p1 p3
p2 p4
p4
with appearance
:
Note that these again are, respectively, the compact representations of
386 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
:
The following example will give some intuition on the fact that, given a formula ’,
the search for a valid proof-tree, and consequently the search for normal inhabitants,
is 8nite. A sketch of a search-algorithm is given after the example.
Example 2.16. Consider again the formula ’ and its formula-tree tree(’) from
Example 2.10. We will now attempt to build a valid proof-tree for this formula, ap-
plying the rules for constructing proof-trees, in such a way that none of the conditions
in De8nition 2.14 is violated:
1. The only primitive part that can be used in the beginning is p0, leading to the
tree p0 with appearance
|
A
. This is no valid proof-tree, since p0 has arity 1 and
consequently there has to be a subtree rooted in A.
2. Now, in order to build that subtree, applying one of the other two construction-rules
for proof-trees, we have to use a primitive part with head-variable A. The primitive
parts in the formula-tree with head-variable A are p1, p3, p4 and p6. But, actually
the only primitive part that can be used without violating the second condition in
De8nition 2.14 is p1. Being a descendent of p0 at branch 1, this primitive part, as
well as p2, has been made available by the use of p0. The resulting proof-tree is
p0
p1
with appearance
|
A
|
A
;
that is still not complete.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 387
3. Again a subtree rooted in type-variable A has to be constructed, but now there are
two more primitive parts that may be used. In fact, p3 and p4 (the descendents of
p1 at branch 1) have been made available by the use of p1, and so one may now
choose between p1, p3 or p4 (p2 is available, but its head-variable does not 8t).
Using p1 again would lead to the still incomplete proof-tree
p0
p1
p1
with appearance
|
A
|
A
|
A
:
Again a subtree rooted in A has to be constructed and the use of p1 does not allow us
to use any primitive part diJerent from those available in the step before. The same
will happen if we choose to use p3 instead of p1. In fact, p3 has no descendents
and consequently there will be no further primitive parts available, but the same as
in the step before. Furthermore, p3 has also tail-variable A and consequently we will
still be attempting to construct a subtree rooted in A. Finally, we can use part p4
which leads us to the incomplete proof-tree
p0
p1
p4
with appearance
:
Now, we have to construct two subtrees. One rooted in type-variable A and another
rooted in type-variable B. Note, that p4 has no descendent at branch 1 and the
descendent p6 at branch 2. Although, p6 is now available for the construction of
the subtree rooted in B, there is no new primitive part available for the construction
of the subtree rooted in A. Consequently, again one of our tasks is the same as
before and we conclude that there is no valid proof-tree for this formula.
Based on the argument used in the previous example, one can de8ne a search al-
gorithm for a valid proof-tree as follows. Begin the construction of a valid proof-tree
388 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
with p0, the unique primitive part of form (P1) in the formula-tree. Proceed, building
a complete subtree rooted at the tail-variable of p0. During the construction of subtrees
only use primitive parts that are allowed by the second condition in De8nition 2.14.
Call these the available parts at a certain stage. During the construction, explore all
possibilities, using all available primitive part with the matching head-variable. The
search stops in one of two ways. With success, if a valid proof tree is obtained. With
failure, whenever trying to build a complete subtree rooted in the same type-variable
and with the same set of available primitive parts as in one of the steps before; this
means that there is no need to construct proof-trees with depth greater than the num-
ber of diJerent type-variables (in the type) times the number of primitive parts (in the
formula-tree). Eventually, one of the two halting conditions will be obtained, since the
number of atoms and primitive parts found in ’ is 8nite.
In order to establish the relation between the long normal inhabitants of a type and
its valid proof-trees, we now describe an algorithm PT( ) that given a long inhabitant
M of a type ’ computes a valid proof-tree for PT(M) for ’. The de8nition of this
algorithm parallels the construction of a proof-tree from a long normal inhabitant in
Example 2.12. In the following algorithm, we use the notion of erasing abstractions in
a term, which consists of removing all pre8xes x in the term, obtaining as a result a
purely applicative term.
Proof-tree Algorithm 2.17.
Input: a type ’ and M , a long normal inhabitant of ’.
Output: a valid proof-tree PT(M) for ’.
Let M ′ be the term obtained from M by erasing abstractions in M and replacing
each variable with the name of the corresponding primitive part in tree(’). Then,
PT(M) is the graphical representation of M ′ after inserting a top level node p0 (the
root-node of tree(’)).
We now examine an “inverse” algorithm which computes, given a type ’ and any
valid proof-tree PT for ’, a 8nite non-empty set Terms(PT) of long closed normal
inhabitants of ’. The algorithm consists of three parts.
In the 8rst two parts, the common structure of the lambda-terms that correspond
to a certain valid proof-tree is recovered by a -term, that we call a term-scheme.
These term-schemes resemble lambda-terms (possibly with bounded-variable clashes)
in the simple type-system with the total discharge convention, or Prawitz-style natural
deduction system [10], but actually they diJer from them in the following way. While
all free (distinct) variables in a subterm of a term in Prawitz’ system have distinct
types, distinct (free or bounded) variables in a subterm of a term-scheme may have
the same type as long as they correspond to diJerent primitive parts (or equivalently
to diJerent negative occurrences of the type as a subtype).
In the last part, we compute the set of all terms from which a given term-scheme
may be obtained, by identifying in these terms all variables, that correspond to the
same primitive part in the formula-tree. For example, for xy:x (z :x(z:yzz)) the
term-scheme of type ((B→A)→A)→(B→B→A)→A, the two bounded z′s are given
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 389
distinct names and all possibilities explored for the subterms in their scope, leading to
the following set of terms:
{xy:x(z:x(z′:yzz)); xy:x(z:x(z′:yzz′)); xy:x(z:x(z′:yz′z));
xy:x(z:x(z′:yz′z′))}:
Terms Algorithm 2.18.
Input: a type ’ and a valid proof-tree PT for ’.
Output: a 8nite non-empty set Terms(PT) of long closed normal inhabitants of ’.
Let p0; : : : ; pn be the primitive parts in tree(’), where p0 is the root-part and n¿0.
The set Terms(PT) is constructed in the following way.
(a) Represent PT as an application using for 06i6n the variable name xi instead of
pi. Then, for each variable-occurrence xi in this application, such that the primitive
part pi has arity ki¿0, insert a (possibly empty) abstraction sequence before each
of its ki arguments. Here, the variable names in an abstraction sequence xj1 : : : xjlj
to be inserted before the jth argument, 16j6ki, correspond to the descendents
pj1 : : : pjlj at branch j of pi in tree(’).
(b) Now, erase the variable x0 at the top.
(c) Finally, for term-scheme T obtained in the previous step compute Terms(PT)=
T 0:::0x1 :::xn de8ned below, where x
0 = x for any variable x.
• xik1 :::0:::knx1 ::: xi :::xn = { Txi}; 3
• x
i
k1 :::ki :::kn
x1 ::: xi ::: xn
= {xi; x′i ; x′′i ; : : : ; xki−1i }; ki¿1;
• (ST )k1 :::knx1 ::: xn = {SiTj | Si ∈ Sk1 :::knx1 ::: xn ; Tj ∈Tk1 :::knx1 ::: xn};
• (xi:T )k1 :::knx1 ::: xn = {xkii :Ti |Ti ∈Tk1 :::(ki+1):::knx1 ::: xi ::: xn }.
The following example illustrates the application of the algorithm.
Example 2.19. Consider again ’=((A→B)→A→B)→(A→B)→A→B from Exam-
ple 2.12 with formula-tree
3 This case corresponds to the renaming of free occurrences of variables in T .
390 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
Let PT be the last valid proof-tree for ’ in Example 2.15, i.e.
PT = p0
p1
p1 p3
p2 p4
p4
:
In the 8rst step of the Terms algorithm, PT is represented by the application x0(x1(x1(x2
x4)x4)x3). Then, since p0 has arity 1 and descendents p1, p2 and p3 at branch 1,
the abstraction sequence x1x2x3 is inserted before the 8rst argument of x0, lead-
ing to x0(x1x2x3:x1(x1(x2x4)x4)x3). As p1 has arity 2, descendent p4 at branch 1
and no descendent at branch 2, the abstraction sequence x4 has to be inserted be-
fore the 8rst argument of (every occurrence of) x1 and no (or the empty) abstrac-
tion sequence will be inserted before the second argument of (all occurrences of)
x1, leading to x0(x1x2x3: x1(x4:x1(x4:x2x4)x4)x3). Neither p2, p3 or p4 have
descendents; thus no further abstraction sequence has to be inserted. After erasing
x0 at the top we obtain the term-scheme T = x1x2x3:x1(x4:x1(x4:x2x4)x4)x3. Finally,
Terms(PT) = T 0000x1x2x3x4 = {x1x2x3:x1(x4:x1(x′4:x2x4)x4)x3; x1x2x3:x1(x4:x1(x′4:x2x′4)
x4)x3}.
The following result proves the correctness of Algorithms 2.17 and 2.18 and will
be used in the proof of Theorem 4.10. Note that the set of long normal inhabitants
produced by Algorithm 2.18 may contain terms with bounded-variable clashes, but is
of course equivalent (modulo -conversion) to a set of long normal inhabitants without
bounded-variable clashes.
Proposition 2.20. (i) If M is a long normal inhabitant of a type ’, then PT(M) is a
valid proof-tree for ’.
(ii) If PT is a valid proof-tree for a type ’, then every member of Terms(PT) is a
closed long normal inhabitant of ’.
Furthermore, the two algorithms are complementary in the sense that for every closed
long normal inhabitant M of ’ there is M ∈ Terms(PT(M)).
Proof. We begin the proof of (i) showing that PT(M) can in fact be obtained ap-
plying the rules for constructing proof-trees in De8nition 2.13, and showing that both
conditions in De8nition 2.14 are satis8ed by PT(M). For that, consider any occurrence
Tx (not in an abstraction-sequence) of a variable x in M . Suppose that x has type
=(11→· · ·→ 1m1 →A1)→· · ·→(k1→· · ·→ kmk →Ak)→A, let p be the primi-
tive part in tree(’) that corresponds to x, i.e. p is the primitive part in the top of
t(), and 8nally let Tp be the occurrence of p in PT(M) created by the replacement
of occurrence Tx of x by p during the application of algorithm PT( ).
It follows from the Formula-tree Algorithm and from the structure of , that p has
arity k¿0 with head-variable A and tail-variables A1; : : : ; Ak . Furthermore, for 16j6k,
p has exactly mj descendents at branch j. Thus, by Lemma 2.11, the occurrence Tx of x
in M occurs exactly with k arguments, which for 16j6k are respectively of the form
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 391
yj1 : : : yjmj :Nj and such that Nj is of atomic type Aj. Due to their atomic type, each
Nj has to be of the form zjPj1 : : : Pjsj , sj¿0. Thus, Tp will have exactly k arguments,
Tp1; : : : ; Tpk , in PT(M) which are respectively the primitive parts corresponding to z1 in
N1; : : : and to zk in Nk . This, satis8es the 8rst condition in De8nition 2.14. Furthermore,
since N1; : : : ; Nk have types A1; : : : ; Ak , respectively, we infer that the primitive parts
corresponding to z1; : : : ; zk , i.e. Tp1; : : : ; Tpk , have head-variables A1; : : : ; Ak , respectively,
so, by the formation rules in De8nition 2.13, they 8t as arguments for Tp.
Finally, we have to show that also the second condition in De8nition 2.14 is satis8ed
by PT(M). Consider Tp; we have to show that if p is a descendent at branch i of some
primitive part p′ in tree(’), then there is some occurrence of Tp′ in PT(M), such that
Tp occurs in the subtree of PT(M) rooted in the ith branch of Tp′.
Suppose p=p0, the primitive part in the root of tree(’), then there is no such p′
and the second condition in De8nition 2.14 is trivially true.
Suppose p =p0 and let x be the variable corresponding to p. Since M is closed, Tx
occurs in the scope of some abstraction sequence x˜ containing x. If x˜ is the initial
abstraction sequence in M , then p descends from p′=p0 at branch 1 in tree(’) and
the second condition in De8nition 2.14 is satis8ed, since p0 is the primitive part in
the root of PT(M). Otherwise, x˜ is the initial abstraction sequence of the ith argument
of a subterm of M of the form yN1 : : : Nk and i∈{1; : : : ; k}, k¿1. Then, p descends
in tree(’) from the ith branch=tail-variable of the primitive part p′ that corresponds
to y. Since, Tx occurs in the ith argument of an occurrence of y, we conclude that Tp
occurs in the subtree rooted at the ith branch of an occurrence of p′ in PT(M).
For (ii) we begin by noting that the only occurrence of p0 in PT is in its root and
that p0 has arity 1. Therefore the expression constructed in part (a) of Algorithm 2.18
is of the form x0(T ) and that T = xi1 : : : xik :N , where pi1 ; : : : ; pik are the descendents
of p0 (at branch 1) in tree(’) and such that N corresponds to the subtree beneath
p0 in PT.
The term x0(T ) was constructed starting from an application of variables, by intro-
duction of abstraction-sequences before subterms in argument position, but never in
function position. So it is surely a -term in -normal form and consequently the same
is true for the term-scheme T , which is the result after step (b).
Now, consider any occurrence Txi (not in an abstraction-sequence) of a variable xi
in T , which is due to an occurrence Tpi in PT. Let pm be the primitive part of arity
l¿1 such that, in tree(’), pi is a descendent of pm at some branch j. The second
condition in the de8nition of valid proof-trees guarantees that there is at least one
occurrence Tpm in PT such that the Tpi is in the subtree rooted in the jth branch of pm.
This is reVected in T as an occurrence of the variable xm with l arguments and such
that the occurrence Txi is in the jth argument of xm, which begins with an abstraction
sequence in which xi occurs, binding thus the occurrence Txi (if not already binded 4 ).
We conclude that T is closed.
Finally, denote by ’i, for 16i6n, the subtype of ’ such that the subtree t(’i)
in tree(’) has primitive part pi at its top (cf. Algorithm 2.9). Now, consider any
4 The same variable name may appear in more than one abstraction, corresponding to diJerent occurrences
of the same primitive part.
392 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
occurrence Tps of a primitive part ps of arity l¿1 in PT, let PT
′ be the subtree of
PT rooted in branch j∈{1; : : : ; l} of Tps, let A be the jth tail-variable of ps (and con-
sequently the head-variable of the primitive part in the top of PT′) and 8nally let
pj1 ; : : : ; pjt , t¿0, be the descendents of ps at branch j in tree(’). It follows from the
algorithm Terms that the jth argument of the occurrence Txs in x0(T ), created due to Tps,
is of the form T ′= xj1 : : : xjt :P. We will show by induction on the number of occur-
rences of type-variables in PT′ that, for the type-context /= {x1 : ’1; : : : ; xn : ’n} there
is /− xj1 : : : xjt :P : ’j1 →· · ·→’jt →A in TA, i.e. given / the type ’j1 →· · ·→’jt
→A can be assigned to xj1 : : : xjt :P, cf. [8, Chapter 2]. Then, taking for Tps the unique
occurrence of p0 in PT, one has /− xi1 : : : xik :N : ’i1 →· · ·→’ik →A0, where A0 is
the tail-variable of p0, i.e. /−T : ’. Furthermore, since T is closed, we conclude that
also −T : ’ is true in TA. On the other hand, T is clearly long, since every variable
xi of type ’1→· · ·→’l→A appears always with exactly l arguments, due to the fact
that the corresponding primitive part pi has l tail-variables.
We begin the induction proof with the case PT′=pi, i∈{1; : : : ; n} and
pi =
A
| ;
hence ’i =A. Since pi has no tail-variable, there are no primitive parts descending from
pi in tree(’), thus xj1 : : : xjt :P= xj1 : : : xjt : xi and /− xj1 : : : xjt : xi : ’j1 →· · ·→
’jt →A is true in TA.
Now, let the primitive part in the top of PT′ be pi of arity l¿1. Furthermore,
for 16s6l let ps1 ; : : : ; psls be the descendents (in tree(’)) from pi at branch s=tail-
variable As, let  x˜s be the abstraction-sequence xs1 : : : xsls and let ’
s=’s1 →· · ·→
’sls→As. Then, ’i =’1→· · ·→’l→A and P= xi( x˜1:P1) : : : ( x˜l:Pl), where each
˜xs:Ps is constructed from subtree PTs rooted in the sth tail-variable of pi. In or-
der to show that /− xj1 : : : xjt :P : ’j1 →· · ·→’jt →A is true in TA, it suPces to
show that for 16s6l, given context / the type ’s can be assigned to  x˜s:Ps in TA.
This follows from the induction hypothesis applied to PTs, thus 8nishing the induction.
To 8nish the proof of part (ii) 8rst note that for n¿1 and T resulting from (b)
of Terms Algorithm, every term M ∈T 0:::0x1 ::: xn is a closed term (for this it suPces to
show by structural induction on N , that for any term N with variables in {x1; : : : ; xn},
if M ∈Nk1 :::knx1 ::: xn , then for the set FV (M) of free variables of M , one has FV (M)⊆{xji |
16i6n; 06j6ki − 1}∪ { Txi | 16i6n; xi ∈FV (N ); ki =0}, and consequently for
M ∈T 0:::0x1 ::: xn there is FV (M)= ∅). On the other hand, we know that there is a deduc-
tion of T : ’ in TA. This deduction can then easily be changed into a deduction of
M : ’, assigning identical types to variables with the same index.
The remaining claim that for every closed long normal inhabitant M of ’ there is
M ∈ Terms(PT(M)), included here for the sake of completeness, is a consequence of
the symmetry of the two algorithms, and will actually not be used in this paper.
2.3. Arity-1 formulas
In this subsection, we identify the class of formulas for which decidability of BB′IW-
inhabitation will be shown.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 393
Denition 2.21. A primitive part p in a formula-tree is called terminating iJ it is of
the form
A
| . It is called composed of arity n¿1 iJ it is of the form
:
We call a formula an arity-1 formula iJ every composed primitive part in its formula-
tree is of arity 1.
Another simple characterisation of arity-1 formulas, that does not rely on the formula-
tree approach can be given using the notion of polarities of occurrences of subformulas,
cf. De8nition 2.6. Then, it follows that arity-1 formulas are exactly the formulas such
that all negative occurrences of subformulas are of the form →A or A, where  is a
type and A a type-variable.
Example 2.22. The arity-1 formula
 = (A→ B)→ (((B→ B)→ B)→ A)→ (((B→ A)→ A→ A)→ B)→ A
has the following formula-tree
with primitive parts p0 =
|
A
, p1 =
B
|
A
, p2 =
A
|
B
, p3 =
B
|
A
, p4 =
B
|
B
,
p5 =
A
|
B
, and p6 =
A
| . A valid proof-tree for this formula is
394 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
p0
p2
p3
p6
with appearance |
A
|
B
|
A
|
:
It is important to note that a proof-tree for an arity-1 formula is not really a tree,
but it degenerates into a sequence=chain of parts p0; : : : ; pf. This is due to the fact that
each internal primitive part in an arity-1 formula must always be of the form
X
|
Y
;
as can be seen in the two previous examples. Furthermore, note that whenever a
primitive part p descends from another primitive part p′, then p′ must have arity 1
and p descends from p′ at branch 1. So, in the remaining, where we deal with arity-1
formulas, we will usually just say that p descends from p′ and no longer specify the
branch which is necessarily branch 1.
The following properties or arity-1 formulas will be used later on. Here, we call a
term compound if there occurs at least one application in it.
Lemma 2.23. Let M be a long normal BB′IW-inhabitant of an arity-1 formula ’ and
such that M contains a compound subterm N . Then, N is of the form x1 : : : xn:yP,
with n¿0. Moreover, x1; : : : ; xn−1 are all of non-atomic type. Furthermore, there are
abstractions in P if and only if xn is of non-atomic type.
Proof. First note that neither M nor any subterm of M can be of the form x:x. The
former is due to the fact that M has to contain at least one application in order to have
a compound subterm N . The latter follows from the fact that if M has a subterm of the
form x:x then there must be another subterm of M of the form zU1 : : : (x:x) : : : Ul,
l¿0, covered by abstraction sequences s˜1; : : : ; s˜t , with t¿1, in which z occurs. This
subterm then violates the condition imposed on BB′IW-inhabitants that there should
be Inds˜1 ;:::; s˜t (z)4 Inds˜1 ;:::; s˜t (x:x) which is not the case since z 4⊥. Furthermore, note
that every variable x in M is of some type , where  is a negative occurrence of
a subformula of ’, also called a negative subpremise in [8]. Since ’ is an arity-1
formula, it follows that  is either of the form →A or A, where  is a type and A
a type-variable. Thus, it follows from M being a long inhabitant that every variable
occurs always with one argument if its type is of the form →A and always with zero
arguments if its type is of the form A. We conclude that every compound subterm of
M is of the form x1 : : : xn:yP, with n¿0. Since P cannot be of the form x:x we
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 395
gain enough insight to conclude that M is necessarily of the form
s˜1:z11(z
2
1(: : : z
k1
1 (s˜2:z
1
2(: : : z
k2
2 (s˜3: : : : (s˜m:z
1
m(: : : (z
km
m z) : : :)) : : :) : : :)) : : :))
with non-empty abstraction sequences s˜1; : : : ; s˜m, m¿1, k1; : : : ; km¿1, such that every
variable zji is of non-atomic type and occurs in one of s˜1; : : : ; s˜i, with 16i6m and
16j6kj, while the only variable of atomic type is z. Finally, it follows from De8ni-
tion 2.2 that z has to be the last variable in s˜m, which concludes the proof.
Lemma 2.24. Every BB′IW-inhabitated arity-1 formula has exactly one terminating
primitive part in its formula-tree.
Proof. This result follows from the analysis made in the proof of the previous lemma
together with the fact that negative occurrences of atomic subformulas in a formula
correspond to terminating primitive parts in its formula-tree.
Due to Lemma 2.24, from now on we only consider arity-1 formulas with exactly
one terminating primitive part in their formula-trees.
3. Rewriting-systems over typed sequences
In this section, we de8ne the notion of rewriting-systems over typed sequences that
will be used in order to prove decidability for arity-1 formulas. In fact, decidability
will be shown using a mapping from arity-1 formulas to rewriting-systems. The main
goal of these rewriting-systems is to describe the important steps during the search of
a long normal BB′IW-inhabitant of an arity-1 formula. As such, remember that each
variable x of type  in a long normal inhabitant of a formula ’ corresponds to a
negative occurrence of  in ’, and is represented by the subtree t() of the formula-
tree tree(’). The primitive part, say px, in the top of this subtree t() describes the
consequences of using x during the construction of a subterm M : if
px =
A
|
B
and has descendents p1; : : : ; pn (at branch 1) in tree(’), then M is of the form
x(x1 : : : x n:N ) of atomic type A, where N of atomic type B has to be constructed.
Furthermore, all the new variables x1; : : : ; x n have to be used in N . Also all the variables
in the abstraction sequence over M that have not been used before have to appear in
N , as well as the last variable in this sequence (even if it was already used, as will be
seen in Lemma 4.5). All this will be represented as a rewriting system. Here sequences
of variables juxtaposed will be used to represent the whole abstraction sequence of
variables over the subterm that is actually being constructed, i.e. all the variables, in
order from the left, that have the subterm in their scope. A type-variable assigned to
this sequence represents the type of this subterm, and rewriting-rules will describe the
change of the current task due to the use of variables.
396 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
Denition 3.1. A typed sequence is a 8nite sequence of variables juxtaposed x1 : : : xn,
with n¿0, to which a type-variable A has been assigned, and will be represented by
x1 : : : xn ::A.
The meaning of a typed sequence x1 : : : xn ::A (where x1 : : : xn represents a sequence,
in which variables may occur more than once, and not as in -calculus an application of
variables) is the following. Given a type ’ there will be a variable name associated with
each primitive part in tree(’), or equivalently to each negative subformula of ’. Then,
during the construction of a long normal BB′IW-inhabitant of ’ the typed sequence
x1 : : : xn ::A represents an intermediate step such that so far the sequence of variables
that have been introduced in abstractions have types corresponding to x1, to x2; : : :,
to xn. Also, in order to obtain a long normal BB′IW-inhabitant a subterm of type A
still has to be constructed. Note that although variables may occur more than once in
a typed sequence, this does not imply a clash of bounded-variables. In fact, it rather
describes the construction of a term in which (at least) two distinct variables have the
same corresponding primitive part.
Denition 3.2. A rewriting-system over typed sequences is a tuple R=(4; R; xf ::Cf)
such that
• xf is a variable and Cf a type-variable;
• 4 is a typed sequence;
• R is a 8nite set of rules of the form x ::A → x1 : : : xn ::B, where x; x1; : : : ; xn are
term-variables, A and B are type-variables and n¿0.
Denition 3.3. The expansion rule ⇒R of typed sequences with a rewriting-system
R=(4; R; xf ::Cf) is de8ned as follows:
• If z1 : : : zm ::A is a typed sequence and zi ::A → x1 : : : xn ::B ∈R, for some 16i6m,
then
z1 : : : zm :: A⇒R z1 : : : zmx1 : : : xn :: B:
The corresponding occurrence of zi in z1 : : : zm is said to be used in this expansion-
step. Furthermore, if i =m, we call it to be used in a non-=nal position.
A typed sequence 5 expands to 5˜ iJ 5⇒?R 5˜, where ⇒?R denotes the reVexive, transitive
closure of ⇒R. A typed sequence 5 expands successfully with R=(4; R; xf ::Cf) iJ
there is some expansion from 5 to a typed sequence 5˜= z1 : : : zM ::Cf such that
• zM = xf and zi = xf for any other zi ∈{z1; : : : ; zM−1};
• every one of the occurrences of variables in z1; : : : ; zM−1 has been used in a non-8nal
position at least once during the expansion of 5 to 5˜.
If the initial sequence 4 expands successfully with R=(4; R; xf ::Cf), then R is also
called a terminating rewriting-system.
In the following, we de8ne a function R( ) that maps formulas into rewriting-
systems. In Section 4, it will be shown that BB′IW-theorems are associated
with terminating rewriting-systems, while formulas that are not BB′IW-theorems are
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 397
associated with non-terminating rewriting-systems. A decision algorithm for termina-
tion of rewriting-systems will be given in Section 5.
Denition 3.4. Given an arity-1 formula , consider its formula-tree FT () with prim-
itive parts p0; : : : ; pn; pf, where p0 is the root of FT () and
pf =
Cf
|
its unique terminating primitive part. We associate with  a rewriting-system R()=
(4; R; xf ::Cf) by the following:
• 4 is the typed sequence x1 : : : xm ::A, where p1; : : : ; pm are the primitive parts de-
scending from the root
p0 =
|
A
in tree();
• for every primitive part pi of the form
B
|
C
and with descendents pi1 ; : : : ; pimi in tree(), where mi¿0, there is a rule
xi ::B → xi1 : : : ximi ::C in R (occasionally abbreviated by xi ::B → x˜i ::C).
Example 3.5. For  from Example 2.22, we have R()= (4; R; x6 ::A), where
• 4= x1x2x3 ::A
• and
R : x1 :: B →  :: A
x2 :: A → x4 :: B
x3 :: B → x5x6 :: A
x4 :: B →  :: B
x5 :: A →  :: B:
The following expansion sequence shows that R() is terminating, since 4 expands
successfully with R() to 5= x1x2x3x4x4x5x6 ::A.
x1x2x3 :: A ⇒ x1x2x3x4 :: B
⇒ x1x2x3x4 :: A
⇒ x1x2x3x4x4 :: B
⇒ x1x2x3x4x4 :: B
⇒ x1x2x3x4x4x5x6 :: A
⇒ x1x2x3x4x4x5x6 :: B
⇒ x1x2x3x4x4x5x6 :: B
⇒ x1x2x3x4x4x5x6 :: A:
398 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
Note, that for sake of readability in every step of this expansion we underlined
the occurrence of the variable used to obtain the next sequence. Furthermore, we
omitted reference to R() during this expansion, writing ⇒ rather than ⇒R(). This
will be done whenever there is no ambiguity concerning the rewriting-system we
refer to.
4. BB′IW-inhabitation and terminating rewriting-systems
4.1. BB′IW-inhabitation implies terminating rewriting-system
In this subsection, we show that every BB′IW-inhabitated arity-1 formula  gives rise
to a terminating rewriting-system R()= (4; R; xf ::Cf). For this, we prove that given
a BB′IW-inhabitant M of , the initial sequence 4 expands successfully to the typed
sequence Seq(M) de8ned below, in De8nition 4.2.
First, consider the unique long inhabitant M+ of  to which M "-expands. Every
variable in M+ corresponds exactly to one primitive part, diJerent from p0, in the
formula-tree tree() with primitive parts p0; p1; : : : ; pn; pf, where n¿0. Now, let N be
any term obtained by renaming variables in M+ in the following way: all occurrences
of variables corresponding to a primitive part pi, with i∈{1; : : : ; n; f}, are named xji
for some j¿1. Here, occurrences of the same variable are given the same exponent j
(i.e. the same name) and diJerent variables are given diJerent exponents (i.e. receive
diJerent names). Obviously, there is N ≡ M+ and N is a long normal BB′IW-inhabitant
of .
Example 4.1. Consider the arity-1 formula
 = (((A→ A)→ (B→ A)→ A)→ A)→ ((B→ A)→ B)→ A
with formula-tree
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 399
with primitive parts
p0 =
|
A
; p1 =
A
|
A
; p2 =
B
|
A
; p3 =
A
|
A
; p4 =
A
|
B
and p5 =
B
| :
A (long) normal BB′IW-inhabitant of  is
M = xy:x(zu:x(vs:u(y(t:z(v(st))))));
where x corresponds to p1, y to p2, z and v to p3, u and s to p4, and 8nally t to p5.
After renaming we obtain the term
N = x11x
1
2 :x
1
1(x
1
3x
1
4 :x
1
1(x
2
3x
2
4 :x
1
4(x
1
2(x
1
5 :x
1
3(x
2
3(x
2
4x
1
5)))))):
Denition 4.2. Let M be a long inhabitant of an arity-1 formula  and consider a
term N ≡ M as above, i.e. a long normal inhabitant of  where variables are indexed
according to the primitive part in tree() they correspond to. Furthermore, let Cf
be the type-variable in the (unique) terminating primitive part in tree(). We de-
8ne Seq(M)= x1 : : : xn ::Cf, where x1 : : : xn is the sequence of variables in successive
abstractions in N after erasing superscripts=exponents.
Example 4.3. For the term from Example 4.1 we have Seq(M)= x1x2x3x4x3x4x5 ::B.
Below we will show that for every type  with normal inhabitant M the rewriting-
system R() is terminating, since its initial sequence 4 expands successfully to Seq(M).
During the proof, we will also need the notion of eJective occurrences of variables in
terms.
Denition 4.4. We call the underlined occurrence of x in a term of the form x:y1(: : :
yk(xP) : : :), with k¿0, ine>ective. Every ineJective occurrence of a variable x in a
subterm of a term M is an ineJective occurrence of x in M . An occurrence of a
variable in a term (but not in an abstraction sequence) that is not ineJective is called
e>ective.
In other words, an occurrence of a variable x in a long normal BB′IW-term is always
eJective, unless it is the 8rst x in a subterm of the form xP covered by an abstraction
sequence whose last variable is x. The following result shows that all variables in a
long normal BB′IW-term have at least one eJective occurrence.
Lemma 4.5. If Q= x:y1(: : : yk(xP) : : :) is a subterm of a long normal BB′IW-term
M , then there is at least one e>ective occurrence of x in P.
Proof. Consider the sequence of the variables x˜= x1; : : : ; xn; x, n¿0, that occur in ab-
stractions in M which have the subterm y1(: : : yk(xP) : : :) in their scope, together with
the induced implicit order ⊥≺ x1≺ · · ·≺ xn≺ x. From De8nitions 2.1 and 2.2, we con-
clude that Ind˜x(P)= x, thus x∈FV (P). We now prove the result by induction on the
400 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
length of P. If P= x, this occurrence of x is an eJective occurrence. If P=yP′, then
x∈FV (P′) (for y = x as well as for y= x) and by the induction hypothesis x has an
eJective occurrence in P′. Otherwise, P= y:P′, where x∈FV (P′). All occurrences
of x in P′ are clearly eJective.
Theorem 4.6. For every BB′IW-inhabitant M of an arity-1 formula , the initial se-
quence 4 expands successfully with R()= (4; R; xf ::Cf) to Seq(M).
Proof. Consider N ≡ M as before, i.e. obtained from the unique long normal inhabi-
tant of  to which M "-expands by renaming variables according to the primitive parts
they correspond to.
First note that for Seq(M)= s1 : : : sl ::A there is exactly one occurrence of xf
in s1 : : : sl, which is sl and that A=Cf. The latter results from the de8nition of
Seq(M) and the former from xf being the only variable of atomic type and from
Lemma 2.23.
Now let P be any long subterm of N that is not an abstraction and which is in the
scope of variables x˜P = x1; : : : ; xn and let B be the atomic type of P, for P is long.
Let y˜P =y1; : : : ; yk be the subsequence of x1; : : : ; xn obtained by deleting all variables
xj such that P occurs as a subterm of the argument of an eJective occurrence of xj.
Note that all of y1; : : : ; yk occur at least once (cf. Lemma 4.5) in P. For example, if
P=y(zu) is a subterm of xyz:z(y(x(u:y(zu))) there is x˜= x; y; z; u and y˜P = z; u;
if we consider P′= x(u:y(zu)), then x˜= x; y; z and y˜P′ = x; z.
We now prove by induction on the number of applications in P, that the typed
sequence x1 : : : xn ::B expands to Seq(M), thus Seq(M)= x1 : : : xn5 ::Cf, and during
this expansion all occurrences of variables in y1; : : : ; yk and 5, diJerent from xf, are
used in a non-8nal position.
First suppose that P= x is a variable. Since it has atomic type B, we conclude
from Lemma 2.23 that x= xn= xf, thus B=Cf, as well as Seq(M)= x1 : : : xn ::Cf. On
the other hand, we know from Lemma 4.5 that all of y1; : : : ; yk have to occur at
least once in P. Thus, y1; : : : ; yk is just xf. The result becomes trivially true. In fact,
x1 : : : xn ::B expands in zero steps to Seq(M), and there are no variables diJerent from
xf in y1; : : : ; yk .
Otherwise, by Lemma 2.23, P= x(u1 : : : ut :Q) such that Q, of type D, is not an
abstraction and t¿0. Note that the 8rst occurrence of x in P is eJective if and
only if x = xn, i.e. the corresponding occurrence of x is in a non-8nal position in
x1 : : : xn. From the correspondence between variables and primitive parts we conclude
that there is the rule x ::B → u1 : : : ut ::D in R. Thus, x1 : : : xn ::B⇒ x1 : : : xnu1 : : : ut ::D.
Now, it is suPcient to apply the induction hypothesis to the term Q, typed sequence
x˜Q = x1 : : : xnu1 : : : ut ::D and y˜Q de8ned as before, which means that
y˜Q =


y1 : : : yku1 : : : ut if x =∈ {y1; : : : ; yk}
or if the 8rst x in P is ineJective
and x = xn = yk ;
y1 : : : yl−1yl+1 : : : yku1 : : : ut otherwise (x = yl; 16l6k);
which 8nishes the proof.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 401
Example 4.7. For  from Example 4.1, we have R()= (4; R; x5 ::B) with 4= x1x2 ::A
and
R = {x1 :: A → x3x4 :: A; x2 :: B → x5 :: A; x3 :: A →  :: A; x4 :: A →  :: B}:
Recall that N = x11x
1
2 : x
1
1(x
1
3x
1
4 : x
1
1(x
2
3x
2
4 :x
1
4(x
1
2(x
1
5 :x
1
3(x
2
3(x
2
4x
1
5)))))).
In fact, the initial sequence 4 expands to Seq(M)= x1x2x3x4x3x4x5 ::B as shown
below:
x1x2 :: A⇒ x1 :: A → x3x4 :: A N = x1x2:x1P1
⇒ x1x2x3x4 :: A x1 :: A → x3x4 :: A P1 = x3x4:x1P2
⇒ x1x2x3x4x3x4 :: A x4 :: A →  :: B P2 = x3x4:x4P3
⇒ x1x2x3x4x3x4 :: B x2 :: B → x5 :: A P3 = x2P4
⇒ x1x2x3x4x3x4x5 :: A x3 :: A →  :: A P4 = x5:x3P5
⇒ x1x2x3x4x3x4x5 :: A x3 :: A →  :: A P5 = x3P6
⇒ x1x2x3x4x3x4x5 :: A x4 :: A →  :: B P6 = x4P7
⇒ x1x2x3x4x3x4x5 :: B xf = x5 P7 = x5
where the second column contains the rewriting rule expansion applied and the third
column contains its corresponding subterm, as in the proof of Theorem 4.6.
Corollary 4.8. If  is a BB′IW-inhabited type, then R() is a terminating rewriting-
system.
4.2. Termination implies BB′IW-inhabitation
In the following, we show that whenever the initial sequence 4 of R() expands
successfully to a sequence 5, then  has at least one BB′IW-inhabitant. For this, con-
sider any successful expansion from 4 to 5= z1 : : : znxf ::Cf and perform the following
annotations on z1 : : : znxf. First, associate new exponents to diJerent occurrences of the
same variable in this sequence. Second, insert in this sequence an item [xji ] before
every subsequence that has been introduced using the occurrence of xji . Third, append
the item [x1f] at the end of the sequence.
The algorithm T, that we will show to compute a BB′IW-inhabitant M5 = T(5˜) of 
from this new sequence, denoted by 5˜, is given by the following:
• T([x])= x;
• T([x]:)= x(T(:));
• T(x:)= x:T(:).
Example 4.9. An annotated version 5˜ of 5= x1x2x3x4x4x5x6 ::A from Example 3.5 is
x11x
1
2x
1
3[x
1
2]x
1
4[x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]
and M5 = T(5˜) is given by
M5 = T(x11x
1
2x
1
3[x
1
2]x
1
4[x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6])
= x11 :T(x
1
2x
1
3[x
1
2]x
1
4[x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6])
402 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
= x11x
1
2 :T(x
1
3[x
1
2]x
1
4[x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6])
= x11x
1
2x
1
3 :T([x
1
2]x
1
4[x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6])
= x11x
1
2x
1
3 :x
1
2(T(x
1
4[x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]))
= x11x
1
2x
1
3 :x
1
2(x
1
4 :T([x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(T([x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6])))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(T(x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :T([x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(T([x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6])))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(T(x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]))))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(x
1
5 :T(x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]))))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(x
1
5x
1
6 :T([x
1
5][x
2
4][x
1
1][x
1
6]))))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(x
1
5x
1
6 : x
1
5(T([x
2
4][x
1
1][x
1
6])))))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(x
1
5x
1
6 : x
1
5(x
2
4(T([x
1
1][x
1
6]))))))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(x
1
5x
1
6 : x
1
5(x
2
4(x
1
1(T([x
1
6])))))))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(x
1
5x
1
6 : x
1
5(x
2
4(x
1
1x
1
6))))))):
Theorem 4.10. Consider an arity-1 formula  with rewriting-system R()= (4; R;
xf ::Cf) and a typed sequence 5 such that 4 expands successfully to 5. Then, M5
is a BB′IW-inhabitant of .
Proof. Consider an annotated version 5˜ of 5. We begin arguing that for every such
sequence 5˜, if 5˜= :1x[x1] : : : [xn]:2, n¿0, then x∈FV (T(:2)). For this note that items
of the form [z] in 5˜ are introduced due to the use of z during the expansion of 4
to 5. Since every variable in 5, but xf, has to be used at least once in a non-8nal
position during the expansion (cf. De8nition 3.3), there has to be at least one item [x]
in [x1] : : : [xn]:2. Now, even if x= xi for some 16i6n, then this expansion with x was
performed in a 8nal position and there must be another item [x] in :2. Thus, in any
case there has to be at least one item [x] in :2 leading to a free (variables have been
renamed in 5˜, thus there is no other unbracketed x in 5˜) occurrence of x in T(:2).
Now, in order to prove that M5 is a BB′IW-term, i.e. M5 ∈HRM (cf. Proposition
2.3), we show that during the calculation of M5, for every computed subterm M = T(:)
in the scope of variables z˜= z1; : : : ; zs, s¿1, M ∈HRMz˜ as well as Indz˜ (M)= zs. We
prove this result by induction on the length of :, which is the remaining subsequence
of 5˜, which during the computation of M5 = T(5˜) is consumed from left to right.
For := [x], there is x= x1f = zs and the result is true.
For := [x]:′, one has M = T([x]:′)= x(M ′), where M ′= T(:′) with M ′ ∈HRMz˜ and
Indz˜ (M ′)= zs. On the other hand, the item [x] appears in 5˜ due to the use of x during
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 403
the expansion. So, in 5˜ there must be an unbracketed occurrence of x on the left
of this item [x]. Since every unbracketed occurrence of a variable gives origin to an
abstraction, we conclude that x is one of z1; : : : ; zs, and consequently x4 zs. Thus, it
follows from Indz˜ (x)= x≺ zs= Indz˜ (M ′) that M ∈HRMz˜ as well as Indz˜ (M)= zs.
For := x:′, there is M = T(x:′)= x:M ′, where M ′= T(:′) with M ′ ∈HRMz˜x and
Indz˜x(M ′)= x, hence x∈FV (M ′). We conclude that M = x:M ′ ∈HRMz˜. On the other
hand, since M is in the scope of variables z1; : : : ; zs, there must be unbracketed occur-
rences of variables z1; : : : ; zs (in this order, possibly separated by bracketed occurrences
of variables) in 5˜ on the left of x:′. Thus, 5˜ is of the form :?zs[x1] : : : [xn]x:′, n¿0, for
some sequence :? (containing unbracketed occurrences of z1; : : : ; zs−1). We conclude
from the remark in the beginning of the proof that zs ∈FV (M), hence Indz˜ (M)= zs.
Correct typing is guaranteed by the fact that the term M computed by T is (modulo
-conversion) in the set Terms(PT5) which has been shown (cf. Proposition 2.20) to
be a set of closed long normal inhabitants of . Here PT5 denotes the proof-tree
p0
pi1
...
pin
pf
;
where [xj1i1 ] : : : [x
jn
in ][x
1
f] is the subsequence of bracketed items in 5˜.
Note that if [xj1i1 ] : : : [x
jn
in ][x
1
f] is the subsequence of bracketed items in 5˜, then 5˜
has to be of the form xl1k1 : : : x
ls
ks [x
j1
i1 ]˜x
j1
i1 [x
j2
i2 ]˜x
j2
i2 : : : [x
jn
in ][x
1
f], where 4= xk1 : : : xks , and
where each subsequence x˜ ji is the sequence of variables introduced by the use of
variable xji in the expansion of 5 and marked by the item [x
j
i ] in 5˜. The sequence
following [xjnin ] has to empty (but for the type a→ a). Otherwise the variables in
this sequence would still have to be used leading to further bracketed items in 5˜.
Also note that if a variable with index s introduces a sequence of variables respec-
tively with indexes s1; : : : ; sm, then in the formula-tree of the formula the descendents
of the primitive part labelled with s are, respectively, labelled with s1; : : : ; sm. Thus,
M = T(5˜)= xl1k1 : : : x
ls
ks :x
j1
i1 ( x˜
j1
i1 :x
j2
i2 ( x˜
j2
i2 : : : : (x
jn
in x
1
f) : : :)).
On the other hand, when applying the algorithm Terms to PT5, then in the 8rst step
the application x0(xi1 (xi2 : : : (xinxf) : : :)) is formed. Then, before the argument of each of
x0; xi1 ; : : : ; xin an abstraction sequence  x˜0;  x˜i1 ; : : : ; ˜xin is introduced and x0 is deleted
from the top, leading to the term-scheme  x˜0:xi1 ( x˜i1 : xi2 (˜xi2 : : : : (xin(˜xin :xf)) : : :)). Also
here the abstraction sequence that is introduced before the argument of an variable with
index s is the sequence of variables indexed with the labels of the primitive parts that
in the formula-tree descend from the primitive part labelled with s. It follows from the
remark in the footnote, which guarantees that no primitive parts descend in the formula-
tree from the primitive part labelled with in, that x˜in is in fact an empty sequence and
that  x˜0 = x
l1
k1 : : : x
ls
ks . Thus, the term-scheme can in fact be obtained from M erasing
the superscripts of variables and on the other hand M will be one of the terms obtained
from this term-scheme in the third step of the algorithm Terms.
404 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
5. Decidability for arity-1 formulas
In order to prove decidability for arity-1 formulas, it remains to show decidability
of termination of rewriting-systems. We begin with a result on sequences of n-tuples
of non-negative integers.
5.1. The =niteness of non-ascending Nn-sequences
Let 5= Ta1; : : : ; Tai ; : : : be a sequence of n-tuples on non-negative integers, Tai =
〈a1i ; : : : ; ani 〉 ∈Nn, where aji ∈N represents the jth position of tuple Tai.
We de8ne a partial order on n-tuples as follows:
Ta6 Tb iJ aj6bj for 16 j 6 n:
The sequence 5 is non-ascending iJ for any i¡k we have Tai 6Tak . Note that in a
non-ascending sequence it follows that Tai = Tak for i = k.
We want to prove that any non-ascending sequence of n-tuples in Nn is 8nite. This
result is, in fact, equivalent to Kripke’s Lemma, cf. [1], and to some other known
results such as the in8nite division principle by Meyer, cf. [9], or to Dickson’s Lemma
in number theory, cf. [6], that can be obtained from Hilbert’s Finite Basis Theorem,
cf. [7]. These powerful results have been used in various areas among which in decid-
ability proofs for some fragments of relevant systems, cf. [11].
Theorem 5.1. Let 5= Ta1; : : : ; Tai ; : : : be a non-ascending sequence of tuples in Nn. Then
5 is =nite.
Proof. Suppose, for the sake of contradiction, that 5 is in8nite. There cannot be any
bounding value on the elements of the sequence, otherwise all elements of the sequence
5 would be inside an n-dimensional cube, but there are only 8nitely many distinct
elements inside an n-dimensional cube in Nn.
So at least one of the dimensions is unbounded. Without loss of generality, suppose
the 8rst dimension is unbounded (otherwise we reorder the dimensions). Let us form
a new sequence 5(1), a subsequence of 5,
5(1) = Ta(1)1 ; : : : ; Ta
(1)
i ; : : :
by deleting from 5 all the elements in which the unbound 8rst dimension is not strictly
greater than the largest value so far of the 8rst dimension. As a result, the in8nite
sequence that consists of the 8rst dimension of 5(1) is strictly ascending.
If there is another unbounded dimension in 5(1), which without loss of generality
we can suppose is the second dimension, we repeat this process above of extracting
a sequence 5(2), where the second dimension is strictly ascending. Note that in this
process the 8rst dimension remains strictly ascending.
We repeat this process as long as there is an unbounded dimension. Suppose we
have made this process m times, 16m6n, and we end up with an in8nite subsequence
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 405
5(m) of 5.
5(m) = Ta(m)1 ; : : : ; Ta
(m)
i ; : : : :
At this point, we have m dimensions of strictly ascending values and n−m bounded
dimensions in 5(m). Take a bounded dimension, say dimension m + 1. Since 5(m) is
in8nite, there is a value cm+1 in dimension m + 1 that repeats in8nitely. Now form a
new subsequence 5(m+1) of 5(m) by deleting all values for which dimension m + 1 is
diJerent from cm+1, so that dimension m+ 1 is constant in 5(m+1).
Repeat this process for all bounded dimensions. We end up with an in8nite sequence
5(n), in which m dimensions are strictly ascending and m− n dimensions are constant.
Since 5(n) is a subsequence of 5, this contradicts the fact that 5 is non-ascending.
Therefore, the initial sequence 5 cannot be in8nite, which 8nishes the proof.
The following lemma, similar to KXonig’s lemma, will be used in the proof of
Theorem 5.4, which leads to our main result.
Lemma 5.2. Let L be a set and 6 be a binary relation de=ned on L. Let T be
any =nitely branching tree whose nodes are labelled by elements of L. Consider the
following recursive procedure, where n is a node of T and S ⊆ L.
proc Visit(n,S):
let l be the label of node n
if there exists l′ ∈ S s.t. l′6l
then return
else
for each descendent n′ of n
do Visit(n′, S ∪{l})
If for any node n in T the call Visit(n,∅) does not terminate, then there exists
an in=nite sequence (li)i in L such that for all 06i¡j, one has li 6lj.
Proof. The existence of a sequence (li)i is easily established as follows: assume that
Visit(n0,∅) does not terminate for some node n0. Then, since the tree is 8nitely
branching, there is at least one descendent n1 of n0 such that Visit(n1,{l0}) also does
not terminate, where l0 is the label of n0. But then there is also a direct descendent
n2 of n1, such that Visit(n2,{l0; l1}) does not terminate, where l1 is the label of
n1 and l0 6l1. Similarly, we can conclude that there is a descendent n3 of n2, such
that Visit(n3,{l0; l1; l2}) does not terminate, where l2 is the label of n2 and such
that l0 6l1, l0 6l2 and l1 6l2. Since Visit(n,∅) does not terminate, it is possible to
repeat this procedure inde8nitely.
5.2. Deciding termination of rewriting-systems
The following Lemma will be used in order to prove decidability of termination of
rewriting-systems.
406 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
Lemma 5.3. Consider a rewriting-system R and a typed sequence 5, such that 5
expands successfully with R. Then, there is at least one successful expansion sequence
5= 51; : : : ; 5n such that for all i; j with 16i¡j6n, the typed sequences 5i and 5j do
not satisfy at least one of the following conditions:
• the type-variable in 5i and 5j is the same;
• the last term-variable in 5i and 5j is the same;
• in 5i and 5j the same term-variables occur;
• for every variable x such that kx occurrences of x in 5i have not been used in a
non-=nal position in the expansion of 5 to 5i, there are at least kx occurrences of
x in 5j that have not been used in a non-=nal position in the expansion of 5 to 5j.
Proof. Consider a successful expansion sequence 5= 51; : : : ; 5i; : : : ; 5j; : : : ; 5j+k from 5
to 5j+k of length j + k, where i; j; k¿0, j¿i and such that
• the type-variable in 5i and 5j is the same;
• the last term-variable in 5i and 5j is the same;
• in 5i and 5j the same term-variables occur;
• for every variable x such that kx occurrences of x in 5i have not been used in a
non-8nal position in the expansion of 5 to 5i, there are at least kx occurrences of x
in 5j that have not been used in a non-8nal position in the expansion of 5 to 5j.
Then, another successful expansion sequence 5= 51; : : : ; T5i = 5i; T5i+1; : : : ; T5i+k of
length i + k¡j + k can be obtained by the following. For l=0; : : : ; k − 1, suppose
that 5j+l+1 was obtained from 5j+l using rule xl ::Al → x˜l ::Bl. Then expand T5i+l with
this same rule and using the leftmost occurrence of xl in T5i+l that has not been used
in a non-8nal position in the expansion of 5 to T5i+l, if any, or otherwise any other
occurrence of xl in T5i+l.
Now repeat the whole process to this new, shorter successful expansion sequence,
as long as necessary.
Theorem 5.4. Termination of rewriting-systems over typed sequences is decidable.
Proof. Let R=(4; R; xf ::Cf) be a rewriting-system in which occur n¿0 term-
variables x1; : : : ; xn (after renaming if necessary) and m¿0 type-variables A1; : : : ; Am.
Given an expansion sequence 51; 52; : : : we associate with each typed sequence 5i in
this expansion a tuple Li =(Tai ; Vi; xi; Ai), with Tai = 〈a1i ; : : : ; ani 〉 ∈Nn, Vi⊆{x1; : : : ; xn},
xi ∈{x1; : : : ; xn} and Ai ∈{A1; : : : ; Am} by the following:
• For j=1; : : : ; n let aji be the number of occurrences of xj in 5i that have not been
used in a non-8nal position during the expansion of 51 to 5i;
• let Vi be the set of variables occurring in 5i;
• let xi be the last variable in 5i;
• and 8nally let Ai be the type-variable in 5i.
We call a typed sequence 5j in this expansion a repetition of another typed sequence
5i with i¡j if and only if Tai6Taj, Vi =Vj, xi = xj and Ai =Aj, in which case we write
that Li6Lj. We know from Lemma 5.3 that if R is terminating, then there is at least
one repetition-free successful expansion sequence starting with the initial sequence 4.
On the other hand, there are only a 8nite number of distinct Vk ’s, xk ’s as well as Ak ’s.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408 407
Thus, it follows from Theorem 5.1 that there are no in8nite, repetition-free expansion
sequences, i.e. there is no in8nite sequence of tuples (Li)i such that for any 06i¡j
one has Li 6Lj.
Consider the 8nitely branching tree T de8ned by the following: the top-node is
labelled by the tuple L0 corresponding to the initial sequence 50 = 4. Furthermore, the
descendents of a node labelled with a tuple Li are all (8nitely many) nodes labelled with
tuples Li1 ; : : : ; Lini , corresponding to all the sequences 5i1 ; : : : ; 5ini that can be obtained
in one expansion-step from 5i.
Finally, change procedure Visit to immediately stop if a successful, repetition-free
expansion sequence is reached, and apply it to T. Lemma 5.2 and the remark above
about the Li’s guarantee that this call terminates, thus making it a decision procedure.
Now we are able to conclude our main result.
Theorem 5.5. BB′IW-inhabitation is decidable for arity-1 formulas.
Proof. It follows from Theorems 4.6 and 4.10 that an arity-1 formula  is BB′IW-
inhabited if and only if the corresponding rewriting-system R() is terminating. The
decidability of the latter has been shown in Theorem 5.4.
6. Conclusions
We have shown the decidability of the arity-1 fragment of BB′IW-logic using the
termination of a special kind of rewriting-system. The decision procedure is based on
the 8niteness of non-ascending Nn-sequences. The complexity of the decision procedure
is bound to be quite costly, but yet undetermined. In fact, the results in [13] suggest
that it is primitive recursive in the Ackermann function.
The method proposed here gets considerably more complicated if applied to the
whole fragment, for then the rewriting-system will not be expanding a sequence but a
tree. The relationship between the structure of BB′IW--terms and these tree-expanding
rewriting-systems still has to be investigated.
And 8nally, we have not ruled out the possibility of the whole BB′IW-logic being
undecidable. That undecidability, if proven, will have to depend on formulas that are
not arity-1.
Acknowledgements
We would like to thank the anonymous referees for numerous comments which
contributed to enhance the presentation.
The work presented in this paper has been partially supported by funds granted to
LIACC through Programa de Financiamento Plurianual, Fundac"a˜o para a Cieˆncia e
Tecnologia and Programa POSI.
408 S. Broda et al. / Theoretical Computer Science 318 (2004) 373–408
References
[1] A.R. Anderson, N.D. Belnap, Entailment, Vol. I, Princeton University Press, USA, 1975.
[2] H. Barendregt, Lambda calculi with types, in: S. Abramsky, D.M. Gabbay, T.S.E. Maibaum (Eds.),
Background: Computational Structures, Handbook of Logic in Computer Science, Vol. 2, Oxford Science
Publications, 1992, pp. 117–309.
[3] C.-B. Ben-Yelles, Type-assignment in the lambda-calculus; syntax and semantics, Ph.D. Thesis,
Mathematics Department, University of Wales, Swansea, UK, 1979.
[4] S. Broda, L. Damas, On the structure of normal -terms having a certain type, Proc. 7th WoLLIC’2000,
2000, pp. 33–43, copy in http://www.dcc.fc.up.pt/∼sbb/wollic00.ps.
[5] M.W. Bunder, Proof 8nding algorithms for implicational logics, Theoret. Comput. Sci. 232 (2000)
165–186.
[6] L.E. Dickson, Finiteness of the odd perfect primitive abundant numbers with n distinct prime factors,
Amer. J. Math. 35 (1913) 413–422.
[7] D. Hilbert, XUber die Theorie der algebraischen Formen, Math. Ann. 36 (1890) 473–534.
[8] J.R. Hindley, Basic Simple Type Theory, in: Cambridge Tracts in Theoretical Computer Science,
Cambridge University Press, Cambridge, 1997.
[9] R.K. Meyer, H. Ono, The Finite Model Property for BCK and BCIW, Studia Logica 53 (1) (1994)
107–118.
[10] D. Prawitz, Natural Deduction, Almqvist and Wiksell, Sweden, 1965.
[11] J. Riche, R.K. Meyer, Kripke, Belnap, Urquhart and relevant decidability & complexity, in: G. Gottlob,
E. Grandjean, K. Seyr (Eds.), Computer Science Logic, CSL’98, Lecture Notes in Computer Science,
Vol. 1584, Springer, Berlin, 1998, pp. 224–240.
[12] P. Trigg, J.R. Hindley, M.W. Bunder, Combinatory abstraction using B, B′ and friends, Theoret. Comput.
Sci. 135 (1994) 405–422.
[13] A. Urquhart, The complexity of decision procedures in relevance logic, in: J.M. Dunn, A. Gupta (Eds.),
Truth or Consequences, Essays in Honor of Nuel Belnap, Kluwer Academic Publishers, Dordrecht, 1990,
pp. 61–76.
