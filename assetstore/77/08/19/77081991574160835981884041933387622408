Theoretical Computer Science 318 (2004) 373â€“408
www.elsevier.com/locate/tcs
The decidability of a fragment of BBâ€²IW-logic
Sabine Brodaa ;âˆ— , Lu)*s Damasa , Marcelo Fingerb , Paulo Silva e Silvab
aDCC-FC, Universidade do Porto, Rua do Campo Alegre 823,
4150 Porto, Portugal
bDepartamento de CieË†ncia da Computac"aËœo, Instituto de Matem&atica e Estat&(stica,
Universidade de SaËœo Paulo, Brazil
Received 11 November 2002; received in revised form 19 January 2004; accepted 5 February 2004
Communicated by D. Plotkin
Abstract
Despite its simple formulation, the decidability of the logic BBâ€²IW has remained an open
problem. We present here a decision procedure for a fragment of it, called the arity-1 formulas.
The decidability proof is based on a representation of formulas called formula-trees, which is
coupled with a proof method that computes long normal -terms that inhabit a formula.
A rewriting-system is associated with such -terms, and we show that a formula admits a
BBâ€²IW--term if and only if the associated rewriting-system terminates. The fact that termination
is decidable is proved using a result on the 8niteness of non-ascending sequences of n-tuples in
Nn, which is equivalent to Kripkeâ€™s Lemma.
cÂ© 2004 Elsevier B.V. All rights reserved.
1. Introduction
The Hilbert-style logic Tâ†’ of â€œticket entailmentâ€, introduced and motivated by
Anderson and Belnap [1], is the system of implicational propositional logic based
on the axiom schemes
B : (â†’ )â†’ (â†’ )â†’ â†’ ;
Bâ€² : (â†’ )â†’ ( â†’ )â†’ â†’ ;
I : â†’ ;
W : (â†’ â†’ )â†’ â†’ 
âˆ— Corresponding author.
E-mail address: sbb@ncc.up.pt (S. Broda).
0304-3975/$ - see front matter cÂ© 2004 Elsevier B.V. All rights reserved.
doi:10.1016/j.tcs.2004.02.002
374 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
and the rule
â†’  

(â†’ e):
Surprisingly, the problem of decidability of this logic remains unsolved, although
several studies have been carried out leading to a better insight on its nature.
Due to the fact that the axiom schemes of Tâ†’, or BBâ€²IW-logic, are the principal
types of
B : xyz:x(yz);
Bâ€² : xyz:y(xz);
I : x:x;
W : xy:xyy;
the problem is in fact equivalent to 8nding an algorithm to decide whether a given
type=formula has any inhabitants that are applicative combinations of these four terms.
Also BBâ€²IW-proofs are represented by closed BBâ€²IW-de8nable -terms. In [12], a precise
characterisation of the class of BBâ€²IW-abstractable terms was presented. That approach
was developed in terms of combinators but it can easily be transposed to -terms, as
in [5], leading to the decidable class of BBâ€²IW--terms. Consequently, a type=formula
 is a theorem of Tâ†’ iJ there is a BBâ€²IW--term to which the type  can be assigned.
Based on this characterisation, Bunder presented an algorithm in [5] that, applied to a
type , produces in 8nite time a (long) normal BBâ€²IW-inhabitant if there is one, but
that may run forever if  is not BBâ€²IW-inhabited. So, his algorithm does not, in general,
provide a decision procedure.
In this paper, we solve the problem of decidability for a restricted class of formulas,
called arity-1 formulas. In Section 2, we 8x the notation and point to some results and
methods that will be used in the remainder of the paper. We then present the class
of arity-1 formulas, a fragment of the â†’-language. In Section 3, we de8ne the no-
tion of terminating rewriting-systems over typed sequences that will be used to prove
BBâ€²IW decidability for arity-1 formulas. Our proof is based on a mapping R( ) from
arity-1 formulas to rewriting-systems. It will be shown in Section 4 that an arity-1
formula  is BBâ€²IW-inhabited if and only if the rewriting-system R() is terminating.
Decidability of termination of rewriting-systems over typed sequences is proved in Sec-
tion 5 using a result on non-ascending Nn-sequences equivalent to Kripkeâ€™s Lemma,
cf. [1].
2. Preliminaries
We assume familiarity with the basic notions in -calculus and use standard notation
from [2] and [8]. Our notation diJers from that in [2], since we denote type-variables
(atoms) by â€œA;B;C; : : :â€ and arbitrary types by lower-case Greek letters. For type
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 375
assignment, we consider the system TA of simply typed -calculus Ma la Curry (for an
introduction see [8] or [2]). A term M has a bound-variable clash iJ M contains an
abstractor x and a occurrence of x that is not in its scope. Note that for any -term M
exists a -term N = M without bound-variable clashes. In this paper we will generally,
but for the result of Algorithm 2.18, consider -terms without bound-variable clashes.
2.1. BBâ€²IW--terms
In the following, we describe the set of -terms that can be de8ned in terms of the
combinators B, Bâ€², I and W. We call these terms BBâ€²IW--terms since they represent
BBâ€²IW-proofs. Furthermore, a formula  is a BBâ€²IW-theorem if and only if there is
some BBâ€²IW--term to which the type  can be assigned.
Denition 2.1. Let xËœ= x1; : : : ; xn, where nÂ¿0, be a 8nite sequence of distinct variables
and let  represent the empty sequence. The implicit order â‰º induced by a constant âŠ¥
and xËœ is âŠ¥â‰º x1â‰º Â· Â· Â· â‰º xn. The xËœ-index of a -term P, IndËœx (P), is the â‰º-maximum
of x1; : : : ; xn in FV (P), or âŠ¥ if none of x1; : : : ; xn occurs in FV (P).
Denition 2.2. The set of hereditary right-maximal terms relative to xËœ, HRMxËœ, is
de8ned as:
â€¢ every variable is in HRMxËœ;
â€¢ if P âˆˆHRMxËœy and yâˆˆFV (P), then y:P âˆˆHRMxËœ;
â€¢ if P;QâˆˆHRMxËœ and IndËœx(P)4 IndËœx(Q), then PQâˆˆHRMxËœ.
The notion of hereditary right-maximal terms was introduced in [12], and we note
that our de8nition of HRMxËœ corresponds to HRM(1;:::; n) âˆ©Once+(1;:::; n) in that work. The
following characterisation of the set of BBâ€²IW--terms results mainly from the work
in [12].
Proposition 2.3. A closed -term P is a BBâ€²IW-term if and only if P âˆˆHRM.
A BBâ€²IW-term to which a type  can be assigned is called a BBâ€²IW-inhabitant of .
The following result, together with the subject-reduction property, reduces the existence
of BBâ€²IW-inhabitants to the case of -normal forms.
Property 2.4. Consider a BBâ€²IW-term M and a term N such that Mâ†’ N . Then, N
is a BBâ€²IW-term.
Proof. It is suPcient to show that for any sequence xËœ and redex (y:P)QâˆˆHRMxËœ
we have FV ((y:P)Q)=FV (P[Q=y]) and P[Q=y]âˆˆHRMxËœ. The former is trivial since
yâˆˆFV (P), and for the latter we will show that for every subterm M of P such that
M âˆˆHRMxËœyzËœ, for some sequence of variables zËœ, one has M [Q=y]âˆˆHRMxËœ zËœ. Then, since
P âˆˆHRMxËœy, it follows that P[Q=y]âˆˆHRMxËœ.
376 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
First note that QâˆˆHRMxËœ and no element of zËœ occurs in it. Now, we proceed
by structural induction on M . The result is trivial if M is a variable. Now, sup-
pose that M =(P1P2)âˆˆHRMxËœyzËœ, hence P1; P2 âˆˆHRMxËœyzËœ and IndËœxyzËœ (P1)4 IndËœxyzËœ (P2).
By the induction hypothesis, P1[Q=y]; P2[Q=y]âˆˆHRMxËœ zËœ. Thus, in order to prove that
(P1P2)[Q=y]âˆˆHRMxËœ zËœ it suPces to show that IndËœx zËœ (P1[Q=y])4 IndËœx zËœ (P2[Q=y]). For
that, consider the cases:
â€¢ IndËœx zËœ (P1[Q=y])=âŠ¥. The result is trivial.
â€¢ IndËœx zËœ (P1[Q=y])âˆˆ xËœ. Then no z âˆˆ zËœ occurs in P1 and from IndËœxyzËœ (P1)4 IndËœxyzËœ (P2)
we obtain the result.
â€¢ IndËœx zËœ (P1[Q=y])= zi âˆˆ zËœ. Since no z âˆˆ zËœ occurs in Q, it follows from IndËœxyzËœ (P1)4
IndËœxyzËœ (P2) that IndËœx zËœ (P2[Q=y])= zj and zi4 zj, which gives us the result.
Finally, if M = u:P1 âˆˆHRMxËœyzËœ, then P1 âˆˆHRMxËœyzËœu and uâˆˆFV (P1). Thus, by the
induction hypothesis, P1[Q=y]âˆˆHRMxËœ zËœu. Then, it follows from uâˆˆFV (P1[Q=y]) and
from De8nition 2.2 that (u:P1)[Q=y] = (u:(P1[Q=y])âˆˆHRMxËœ zËœ.
A -normal inhabitant M of a type  is called a long normal inhabitant of  iJ
every variable-occurrence z in M is followed by the longest sequence of arguments
allowed by its type, i.e. iJ each component with form (zP1 : : : Pn), (nÂ¿0), that is not in
a function position has atomic type. The 8nite set of all terms obtained by "-reducing
a -term M zero or more times is called the "-family of M and denoted by {M}".
It has been shown (cf. [3,8]) that the "-families of the long normal inhabitants of 
partition the set of normal inhabitants of  into non-overlapping 8nite subsets, each
"-family containing just one long member. Furthermore, Ben-Yelles (cf. [3,8]) showed
that every normal inhabitant of a type  can be "-expanded to one unique (up to -
conversion) long normal inhabitant of . A simple expansion-algorithm can be found
in [8]. The following result implies that when looking for -normal BBâ€²IW-inhabitants
of a type, one can just search for long normal BBâ€²IW-inhabitants from which all other
-normal inhabitants can be obtained by "-reduction.
Property 2.5. Consider two -terms M and N such that Mâ†’" N . Then, M is a
BBâ€²IW-term if and only if N is.
Proof. Let xËœ be a sequence of variables and y:Py a term such that y =âˆˆFV (P).
Then, FV (y:Py)=FV (P) and consequently IndËœx(y:Py)= IndËœx(P). On the other
hand, y:PyâˆˆHRMxËœ if and only if PyâˆˆHRMxËœy and since y =âˆˆFV (P) this holds if
and only if P âˆˆHRMxËœ.
In the following, we describe the straight relation that exists between subterms and
variables in a long normal inhabitant of a type â€™ and the subtypes of â€™. It is well
known that for every (long) normal inhabitant M of a type â€™ there is exactly one
deduction in the system TA that assigns the type â€™ to M . Thus, in the remaining we
sometimes refer to the types that are assigned to variables and subterms of a normal
inhabitant during this unique deduction as their types. We begin recalling the rather
standard de8nition of polarities of occurrences of subtypes=subformulas.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 377
Denition 2.6. An occurrence of a subtype in a type is de8ned as positive or negative
as follows:
â€¢ â€™ occurs positively in â€™;
â€¢ if an occurrence of a subtype is positive (negative) in â€™, then it is negative (resp.
positive) in â€™â†’ ;
â€¢ if an occurrence of a subtype is positive (negative) in , then it is positive (resp.
negative) in â€™â†’ .
The following properties of long normal inhabitants follow almost directly from the
de8nitions and give us some insight on the relation between the structure of a type and
the structure of their long normal inhabitants (an exhaustive analysis of this relationship
can be found in [8], cf. Section 8Eâ€”The structure of an nf-scheme).
Lemma 2.7. Consider a long normal inhabitant M of a type â€™ and let P be a subterm
of M .
(i) If P= x1 : : : xn:N , with nÂ¿1 and such that N is no abstraction, then there is
some positive occurrence of a subtype of the form = 1â†’Â· Â· Â·â†’ nâ†’A in â€™ and
P is of type . Furthermore, x1; : : : ; xn are respectively of type 1; : : : ; n, which
are negative occurrences of subtypes of â€™, while N is of atomic type A.
(ii) If P=yM1 : : : Mn, with nÂ¿0 and such that M1; : : : ; Mn are all the arguments
applied to y, then there is some negative occurrence of a subtype of the form
= 1â†’Â· Â· Â·â†’ nâ†’A in â€™, y has type  and P;M1; : : : ; Mn have respectively types
A; 1; : : : ; n.
We conclude mainly that variables in abstraction sequences correspond to negative
occurrences of subtypes and that subterms in argument position correspond to positive
occurrences of subtypes. Also, every variable x with a type 1â†’Â· Â· Â·â†’ nâ†’A occurs
always with exactly n arguments in a long normal inhabitant, i.e. in an expression
of the form xP1 : : : Pn of type A and such that P1; : : : ; Pn are, respectively, of types
1; : : : ; n. Moreover, if i = 1â†’Â· Â· Â·â†’ kâ†’B, iâˆˆ{1; : : : ; n}, then Pi is of the form
y1 : : : yk :N such that y1; : : : ; yk have types 1; : : : ; k which are negative occurrences
of subtypes, and N has type B.
2.2. The formula-tree proof method
A central element in our decidability proof is the tree-like representation of types
called formula-tree representation, 8rst introduced in [4]. 1 In this representation, every
type â€™ is split into primitive parts, and the primitive parts themselves form a tree-
like structure, which is called the formula-tree of â€™, and that de8nes some kind of
hierarchy over the primitive parts of the formula. Here, every primitive part, except the
1 A short presentation of the method together with an implementation as a Java applet can be found at
http://www.ncc.up.pt/~sbb/FTLab/ftlab.
378 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
one in the root of the formula-tree, represents together with the subtree rooted in it
a subtype of â€™ that, during the construction of a long normal inhabitant of â€™, may
be assigned to variables. 2 The formula-tree of â€™, tree(â€™), can then be used to build
proof-trees for â€™, each proof-tree being a representation of a 8nite non-empty set of
long normal inhabitants of â€™. Since â€™ may have none, a 8nite or an in8nite number
of long normal inhabitants it may consequently be possible to build none, a 8nite or
even an in8nite number of diJerent proof-trees for â€™.
Primitive parts (frequently represented inside of boxes) are items of either one of
the following forms (P1), (P2) or (P3), where A; B; B1; : : : ; Bn; C denote type-variables:
(P1) :
|
A
(P2) : (nÂ¿ 1) (P3):
C
|
Here, A; B1; : : : ; Bn are called the tail-variables of the respective primitive part, while
B and C are head-variables. The arity of a primitive part is the number of its tail-
variables. Moreover, we will always associate with each primitive part a unique label
pi which allow us to have distinct primitive parts with the same appearance.
Denition 2.8. A formula-tree is a tree-like structure with primitive parts as nodes,
but such that subtrees descend from the branches (or tail-variables) of primitive parts
rather than from the whole primitive parts as nodes. Then, such a structure is called a
formula-tree iJ
â€¢ the root of the formula-tree is the only primitive part of form (P1);
â€¢ every node of form (P2) or (P3) in the formula-tree descends from a tail-variable
in another primitive part;
â€¢ every (labeled) primitive part occurs only once in a formula-tree.
The following algorithm computes the formula-tree tree(â€™) of a type â€™. We use
dashed lines for the edges of the formula-tree in order to distinguish them from the
edges in the primitive parts (nodes) of the formula-tree. Furthermore, we will use
the expression branch only when referring to edges in primitive parts, but not when
referring to (dashed) edges of formula-trees.
Formula-tree Algorithm 2.9.
Input: A type â€™= 1â†’Â· Â· Â·â†’ nâ†’A, where A is an atom and nÂ¿0.
Output: â€™â€™s formula-tree tree(â€™).
The formula-tree tree(â€™) is given by the following.
â€¢ If n=0, i.e. â€™â‰¡A, then tree(â€™)= |
A
.
2 In [8], these subtypes are also called negative subpremises.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 379
â€¢ If nÂ¿1, then tree(â€™)=
where t(A)=
A
|
and for kÂ¿1 and m1; : : : ; mkÂ¿0 we recursively de8ne
t((11â†’Â· Â· Â·â†’1m1 â†’A1)â†’Â· Â· Â·â†’(k1â†’Â· Â· Â·â†’ kmk â†’Ak)â†’A)=
Furthermore, for 16j6k, we call the primitive parts in the top of t(j1); : : : ; t(jmj)
the descendents of primitive part
at branch j (or tail-variable Aj). Note, that in case mj =0, branch j, i.e. tail-variable
Aj, has no children=descendents.
We assume that all primitive parts introduced above are given distinct labels, thus
ensuring that each primitive part occurs only once as required in the de8nition of a
formula-tree.
In the following we exemplify the formula-tree algorithm as well as the notion of
descendents of a primitive part at a branch (tail-variable).
Example 2.10. The formula
â€™ = (((Aâ†’ A)â†’ (Aâ†’ (Aâ†’ B)â†’ A)â†’ A)â†’ A)â†’ ((Bâ†’ A)â†’ B)â†’ A
has formula-tree
tree(â€™) =
tree((((Aâ†’A)â†’ (Aâ†’ (Aâ†’B)â†’A)â†’A)â†’A)â†’ ((Bâ†’A)â†’B)â†’A) =
380 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
with primitive parts
p0 =
|
A
; p1 =
A
|
A
; p2 =
B
|
A
; p3 =
A
|
A
; p4 = ;
p5 =
B
| and p6 =
A
| :
In the formula-tree tree(â€™), p0 has descendents p1 and p2 at p0â€™s branch 1 (p0â€™s
only branch), p1 has descendents p3 and p4 at p1â€™s branch 1 (p1â€™s only branch),
p2 has descendent p5 at its only branch 1, p4 has descendent p6 at branch 2 and no
descendent at branch 1, and 8nally p3, p5 and p6 have no descendents at all.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 381
It is easy to see that for every negative occurrence of a subtype  of a type â€™ there
will be a subtree t() of tree(â€™), suggesting the following relation between subtrees
and the types of variables in long normal inhabitants (cf. Lemma 2.7): given a long
normal inhabitant M of a type â€™ and a variable x in M of type  there is exactly one
subtree t() of tree(â€™) corresponding to x. Any such subtree can be identi8ed by
the primitive part in its top position. So, from now on we call this the primitive part
corresponding to the variable x in M . Note that, while every variable in M has exactly
one corresponding primitive part in tree(â€™), given a primitive part p in tree(â€™) there
may be more than one variable in M for which p is the corresponding primitive part,
or there may even be no such variable. The result below follows from the de8nition
of corresponding primitive part and from the observations made after Lemma 2.7.
Lemma 2.11. Let M be a long normal inhabitant of a type â€™ with formula-tree
tree(â€™), consider any variable x in M and let p be the primitive part in tree(â€™)
corresponding to x. If p is of arity kÂ¿0, then x occurs always with exactly k argu-
ments in M . Furthermore, for kÂ¿1, if iâˆˆ{1; : : : ; k} and p has descendents p1; : : : ; pm
at branch=tail-variable i in tree(â€™), then the ith argument of x is of the form
y1 : : : ym:N and the primitive parts in tree(â€™) corresponding to y1; : : : ; ym are,
respectively, p1; : : : ; pm.
Furthermore, one can easily de8ne an inverse algorithm, which given a formula-tree
FT computes the unique type â€™ such that tree(â€™)= FT. In the following example, we
give some intuition on the meaning of primitive parts and the hierarchy de8ned on
them.
Example 2.12. The formula â€™=((Aâ†’B)â†’Aâ†’B)â†’(Aâ†’B)â†’Aâ†’B has formula-
tree
tree(â€™) = tree(((Aâ†’ B)â†’ Aâ†’ B)â†’ (Aâ†’ B)â†’ Aâ†’ B) =
382 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
p3 =
A
| and p4 =
A
| :
Note that part p4 connects to the branch 1 of part p1 with tail variable B.
Then we get the following information from this representation: during the construc-
tion of a long normal inhabitant of â€™ there may appear variables of type (Aâ†’B)â†’
Aâ†’B, of type Aâ†’B or of type A, which are the negative subtypes of â€™, cf.
Lemma 2.7. These are represented, respectively, by the subtrees t((Aâ†’B)â†’Aâ†’B),
t(Aâ†’B) and t(A) (the latter occurs twice). As such, using a variable x of type
(Aâ†’B)â†’Aâ†’B, corresponding to the subtree t((Aâ†’B)â†’Aâ†’B) with primitive part
at its top, allows us to construct a term of type Bâ€”the head-variable of p1. Furthermore,
in order to complete the construction of this term, two other terms of type B and of
type A, respectively,â€”the tail-variables of p1â€”have to be constructed. Also x will
appear with twoâ€”the arity of p1â€”arguments, and for the construction of the 8rst
there will appear a new variable of type A represented by t(A), i.e. corresponding to
p4â€”the descendent of the 8rst branch of p1. Actually, all this parallels the fact, cf.
Lemma 2.7, that every long normal term beginning with a variable x of type (Aâ†’B)â†’
Aâ†’B is of the form x(y:M)N of type B, where y, M and N are, respectively, of
type A, B and A, and 8nally in M there may appear a new variable y of type A.
The previous discussion illustrates that we can associate to each variable in a long
normal inhabitant M of a type â€™ a subtree t(i) of tree(â€™) with primitive part pi
at its top (the corresponding primitive part). Now, consider M â€² obtained from M by
replacing each variable in M with the name of the corresponding primitive part and by
erasing abstractions. For example, for the long normal inhabitant M = xyz:x(w:yw)z
of â€™ as above we obtain M â€²=p1(p2p4)p3, which represented as a tree gives, after
inserting a top level node p0, the following tree of primitive parts
It turns out that one can characterise precisely the trees of primitive parts that corre-
spond to long normal inhabitants of a type and which will be called valid proof-trees.
We now describe the set of rules that allows us to build proof-trees and then give two
conditions to be satis8ed by a proof-tree in order for it to be valid. In the remaining
we will often use the notation To to refer to a speci8c occurrence of an object o.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 383
Denition 2.13 (Proof-tree structure). A proof-tree for a type â€™ is a tree-like structures
whose nodes are primitive parts in pp(â€™)= {p0; : : : ; pn}, the set of (labels of the)
primitive parts in the formula-tree of â€™ and where p0 denotes the primitive part in the
root of tree(â€™) (thus the only primitive part of form (P1) in pp(â€™)). In the following,
we shall use the notation to designate a proof-tree that has in a leaf a primitive
part with a tail-variable A.
Then, the set of proof-trees for â€™ is given by the following:
â€¢ If p0 = |A âˆˆ pp(â€™), then
|
A
is a proof-tree for â€™;
â€¢ if is a proof-tree for â€™ and âˆˆ pp(â€™) where kÂ¿1,
then is a proof-tree for â€™;
â€¢ if is a proof-tree for â€™ and B| âˆˆ pp(â€™), then is a proof-tree for â€™.
Denition 2.14 (Valid proof-trees). Given a proof-tree PT for a type â€™, we call it a
valid proof-tree for â€™ iJ
â€¢ the number of subtrees rooted in any node=primitive part in PT equals the arity of
that primitive part;
â€¢ if
pâ€² =
with kÂ¿1 is a primitive part in the formula-tree tree(â€™), and p is a descendent
of pâ€² in tree(â€™) at branch i, with 16i6k, then above every occurrence Tp of p
in PT there is at least one occurrence Tpâ€² of pâ€² in PT, such that the occurrence Tp
occurs in the subtree of PT rooted in the iâ€™th branch of Tpâ€².
This last item corresponds to the hierarchy of tree(â€™) being imposed on the con-
struction of a valid proof-tree and will be illustrated by the following example. From
384 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
now on, we will usually, and for the sake of saving space, represent valid proof-trees
without drawing edges between primitive parts explicitly. As such, the tree of primitive
parts at the end of Example 2.12 will be represented by
p0
p1
p2 p3
p4
:
Due to the 8rst condition in the de8nition of a valid proof-tree (De8nition 2.14) there
will be no ambiguity regarding descendents=parents in the tree. Also, for the sake of
saving space, we will unify the head variable and tail variables of two parts that are
linked in a proof-tree.
Example 2.15. A valid proof-tree for the formula â€™ in Example 2.12 is
p0
â€–
p2
â€–
p3
i.e.
|
B
â€–
B
|
A
â€–
A
|
:
Using the compact representation this proof-tree will be represented by
p0
p2
p3
and has
appearance
|
B
|
A
|
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 385
after unifying=overlapping the linked variables. On the other hand, the tree
p0
p2
p4
is
not a valid proof-tree for â€™ (though it would have the same appearance), since it
does not respect the hierarchy given by the formula-tree of â€™, which requires that in
a valid proof-tree all occurrences of p4 occur in some subtree that is rooted in the
left branch of an occurrence of p1. Moreover, there are exactly three proof-trees with
appearance
; that are
p0
p1
p2 p3
p4
;
p0
p1
p2 p3
p3
and
p0
p1
p2 p4
p4
:
Only the 8rst two of these proof-trees are valid proof-trees, since the third does again
not satisfy the second condition of De8nition 2.14.
Another valid proof-tree is
p0
p1
p1 p3
p2 p4
p4
with appearance
:
Note that these again are, respectively, the compact representations of
386 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
:
The following example will give some intuition on the fact that, given a formula â€™,
the search for a valid proof-tree, and consequently the search for normal inhabitants,
is 8nite. A sketch of a search-algorithm is given after the example.
Example 2.16. Consider again the formula â€™ and its formula-tree tree(â€™) from
Example 2.10. We will now attempt to build a valid proof-tree for this formula, ap-
plying the rules for constructing proof-trees, in such a way that none of the conditions
in De8nition 2.14 is violated:
1. The only primitive part that can be used in the beginning is p0, leading to the
tree p0 with appearance
|
A
. This is no valid proof-tree, since p0 has arity 1 and
consequently there has to be a subtree rooted in A.
2. Now, in order to build that subtree, applying one of the other two construction-rules
for proof-trees, we have to use a primitive part with head-variable A. The primitive
parts in the formula-tree with head-variable A are p1, p3, p4 and p6. But, actually
the only primitive part that can be used without violating the second condition in
De8nition 2.14 is p1. Being a descendent of p0 at branch 1, this primitive part, as
well as p2, has been made available by the use of p0. The resulting proof-tree is
p0
p1
with appearance
|
A
|
A
;
that is still not complete.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 387
3. Again a subtree rooted in type-variable A has to be constructed, but now there are
two more primitive parts that may be used. In fact, p3 and p4 (the descendents of
p1 at branch 1) have been made available by the use of p1, and so one may now
choose between p1, p3 or p4 (p2 is available, but its head-variable does not 8t).
Using p1 again would lead to the still incomplete proof-tree
p0
p1
p1
with appearance
|
A
|
A
|
A
:
Again a subtree rooted in A has to be constructed and the use of p1 does not allow us
to use any primitive part diJerent from those available in the step before. The same
will happen if we choose to use p3 instead of p1. In fact, p3 has no descendents
and consequently there will be no further primitive parts available, but the same as
in the step before. Furthermore, p3 has also tail-variable A and consequently we will
still be attempting to construct a subtree rooted in A. Finally, we can use part p4
which leads us to the incomplete proof-tree
p0
p1
p4
with appearance
:
Now, we have to construct two subtrees. One rooted in type-variable A and another
rooted in type-variable B. Note, that p4 has no descendent at branch 1 and the
descendent p6 at branch 2. Although, p6 is now available for the construction of
the subtree rooted in B, there is no new primitive part available for the construction
of the subtree rooted in A. Consequently, again one of our tasks is the same as
before and we conclude that there is no valid proof-tree for this formula.
Based on the argument used in the previous example, one can de8ne a search al-
gorithm for a valid proof-tree as follows. Begin the construction of a valid proof-tree
388 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
with p0, the unique primitive part of form (P1) in the formula-tree. Proceed, building
a complete subtree rooted at the tail-variable of p0. During the construction of subtrees
only use primitive parts that are allowed by the second condition in De8nition 2.14.
Call these the available parts at a certain stage. During the construction, explore all
possibilities, using all available primitive part with the matching head-variable. The
search stops in one of two ways. With success, if a valid proof tree is obtained. With
failure, whenever trying to build a complete subtree rooted in the same type-variable
and with the same set of available primitive parts as in one of the steps before; this
means that there is no need to construct proof-trees with depth greater than the num-
ber of diJerent type-variables (in the type) times the number of primitive parts (in the
formula-tree). Eventually, one of the two halting conditions will be obtained, since the
number of atoms and primitive parts found in â€™ is 8nite.
In order to establish the relation between the long normal inhabitants of a type and
its valid proof-trees, we now describe an algorithm PT( ) that given a long inhabitant
M of a type â€™ computes a valid proof-tree for PT(M) for â€™. The de8nition of this
algorithm parallels the construction of a proof-tree from a long normal inhabitant in
Example 2.12. In the following algorithm, we use the notion of erasing abstractions in
a term, which consists of removing all pre8xes x in the term, obtaining as a result a
purely applicative term.
Proof-tree Algorithm 2.17.
Input: a type â€™ and M , a long normal inhabitant of â€™.
Output: a valid proof-tree PT(M) for â€™.
Let M â€² be the term obtained from M by erasing abstractions in M and replacing
each variable with the name of the corresponding primitive part in tree(â€™). Then,
PT(M) is the graphical representation of M â€² after inserting a top level node p0 (the
root-node of tree(â€™)).
We now examine an â€œinverseâ€ algorithm which computes, given a type â€™ and any
valid proof-tree PT for â€™, a 8nite non-empty set Terms(PT) of long closed normal
inhabitants of â€™. The algorithm consists of three parts.
In the 8rst two parts, the common structure of the lambda-terms that correspond
to a certain valid proof-tree is recovered by a -term, that we call a term-scheme.
These term-schemes resemble lambda-terms (possibly with bounded-variable clashes)
in the simple type-system with the total discharge convention, or Prawitz-style natural
deduction system [10], but actually they diJer from them in the following way. While
all free (distinct) variables in a subterm of a term in Prawitzâ€™ system have distinct
types, distinct (free or bounded) variables in a subterm of a term-scheme may have
the same type as long as they correspond to diJerent primitive parts (or equivalently
to diJerent negative occurrences of the type as a subtype).
In the last part, we compute the set of all terms from which a given term-scheme
may be obtained, by identifying in these terms all variables, that correspond to the
same primitive part in the formula-tree. For example, for xy:x (z :x(z:yzz)) the
term-scheme of type ((Bâ†’A)â†’A)â†’(Bâ†’Bâ†’A)â†’A, the two bounded zâ€²s are given
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 389
distinct names and all possibilities explored for the subterms in their scope, leading to
the following set of terms:
{xy:x(z:x(zâ€²:yzz)); xy:x(z:x(zâ€²:yzzâ€²)); xy:x(z:x(zâ€²:yzâ€²z));
xy:x(z:x(zâ€²:yzâ€²zâ€²))}:
Terms Algorithm 2.18.
Input: a type â€™ and a valid proof-tree PT for â€™.
Output: a 8nite non-empty set Terms(PT) of long closed normal inhabitants of â€™.
Let p0; : : : ; pn be the primitive parts in tree(â€™), where p0 is the root-part and nÂ¿0.
The set Terms(PT) is constructed in the following way.
(a) Represent PT as an application using for 06i6n the variable name xi instead of
pi. Then, for each variable-occurrence xi in this application, such that the primitive
part pi has arity kiÂ¿0, insert a (possibly empty) abstraction sequence before each
of its ki arguments. Here, the variable names in an abstraction sequence xj1 : : : xjlj
to be inserted before the jth argument, 16j6ki, correspond to the descendents
pj1 : : : pjlj at branch j of pi in tree(â€™).
(b) Now, erase the variable x0 at the top.
(c) Finally, for term-scheme T obtained in the previous step compute Terms(PT)=
T 0:::0x1 :::xn de8ned below, where x
0 = x for any variable x.
â€¢ xik1 :::0:::knx1 ::: xi :::xn = { Txi}; 3
â€¢ x
i
k1 :::ki :::kn
x1 ::: xi ::: xn
= {xi; xâ€²i ; xâ€²â€²i ; : : : ; xkiâˆ’1i }; kiÂ¿1;
â€¢ (ST )k1 :::knx1 ::: xn = {SiTj | Si âˆˆ Sk1 :::knx1 ::: xn ; Tj âˆˆTk1 :::knx1 ::: xn};
â€¢ (xi:T )k1 :::knx1 ::: xn = {xkii :Ti |Ti âˆˆTk1 :::(ki+1):::knx1 ::: xi ::: xn }.
The following example illustrates the application of the algorithm.
Example 2.19. Consider again â€™=((Aâ†’B)â†’Aâ†’B)â†’(Aâ†’B)â†’Aâ†’B from Exam-
ple 2.12 with formula-tree
3 This case corresponds to the renaming of free occurrences of variables in T .
390 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
Let PT be the last valid proof-tree for â€™ in Example 2.15, i.e.
PT = p0
p1
p1 p3
p2 p4
p4
:
In the 8rst step of the Terms algorithm, PT is represented by the application x0(x1(x1(x2
x4)x4)x3). Then, since p0 has arity 1 and descendents p1, p2 and p3 at branch 1,
the abstraction sequence x1x2x3 is inserted before the 8rst argument of x0, lead-
ing to x0(x1x2x3:x1(x1(x2x4)x4)x3). As p1 has arity 2, descendent p4 at branch 1
and no descendent at branch 2, the abstraction sequence x4 has to be inserted be-
fore the 8rst argument of (every occurrence of) x1 and no (or the empty) abstrac-
tion sequence will be inserted before the second argument of (all occurrences of)
x1, leading to x0(x1x2x3: x1(x4:x1(x4:x2x4)x4)x3). Neither p2, p3 or p4 have
descendents; thus no further abstraction sequence has to be inserted. After erasing
x0 at the top we obtain the term-scheme T = x1x2x3:x1(x4:x1(x4:x2x4)x4)x3. Finally,
Terms(PT) = T 0000x1x2x3x4 = {x1x2x3:x1(x4:x1(xâ€²4:x2x4)x4)x3; x1x2x3:x1(x4:x1(xâ€²4:x2xâ€²4)
x4)x3}.
The following result proves the correctness of Algorithms 2.17 and 2.18 and will
be used in the proof of Theorem 4.10. Note that the set of long normal inhabitants
produced by Algorithm 2.18 may contain terms with bounded-variable clashes, but is
of course equivalent (modulo -conversion) to a set of long normal inhabitants without
bounded-variable clashes.
Proposition 2.20. (i) If M is a long normal inhabitant of a type â€™, then PT(M) is a
valid proof-tree for â€™.
(ii) If PT is a valid proof-tree for a type â€™, then every member of Terms(PT) is a
closed long normal inhabitant of â€™.
Furthermore, the two algorithms are complementary in the sense that for every closed
long normal inhabitant M of â€™ there is M âˆˆ Terms(PT(M)).
Proof. We begin the proof of (i) showing that PT(M) can in fact be obtained ap-
plying the rules for constructing proof-trees in De8nition 2.13, and showing that both
conditions in De8nition 2.14 are satis8ed by PT(M). For that, consider any occurrence
Tx (not in an abstraction-sequence) of a variable x in M . Suppose that x has type
=(11â†’Â· Â· Â·â†’ 1m1 â†’A1)â†’Â· Â· Â·â†’(k1â†’Â· Â· Â·â†’ kmk â†’Ak)â†’A, let p be the primi-
tive part in tree(â€™) that corresponds to x, i.e. p is the primitive part in the top of
t(), and 8nally let Tp be the occurrence of p in PT(M) created by the replacement
of occurrence Tx of x by p during the application of algorithm PT( ).
It follows from the Formula-tree Algorithm and from the structure of , that p has
arity kÂ¿0 with head-variable A and tail-variables A1; : : : ; Ak . Furthermore, for 16j6k,
p has exactly mj descendents at branch j. Thus, by Lemma 2.11, the occurrence Tx of x
in M occurs exactly with k arguments, which for 16j6k are respectively of the form
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 391
yj1 : : : yjmj :Nj and such that Nj is of atomic type Aj. Due to their atomic type, each
Nj has to be of the form zjPj1 : : : Pjsj , sjÂ¿0. Thus, Tp will have exactly k arguments,
Tp1; : : : ; Tpk , in PT(M) which are respectively the primitive parts corresponding to z1 in
N1; : : : and to zk in Nk . This, satis8es the 8rst condition in De8nition 2.14. Furthermore,
since N1; : : : ; Nk have types A1; : : : ; Ak , respectively, we infer that the primitive parts
corresponding to z1; : : : ; zk , i.e. Tp1; : : : ; Tpk , have head-variables A1; : : : ; Ak , respectively,
so, by the formation rules in De8nition 2.13, they 8t as arguments for Tp.
Finally, we have to show that also the second condition in De8nition 2.14 is satis8ed
by PT(M). Consider Tp; we have to show that if p is a descendent at branch i of some
primitive part pâ€² in tree(â€™), then there is some occurrence of Tpâ€² in PT(M), such that
Tp occurs in the subtree of PT(M) rooted in the ith branch of Tpâ€².
Suppose p=p0, the primitive part in the root of tree(â€™), then there is no such pâ€²
and the second condition in De8nition 2.14 is trivially true.
Suppose p =p0 and let x be the variable corresponding to p. Since M is closed, Tx
occurs in the scope of some abstraction sequence xËœ containing x. If xËœ is the initial
abstraction sequence in M , then p descends from pâ€²=p0 at branch 1 in tree(â€™) and
the second condition in De8nition 2.14 is satis8ed, since p0 is the primitive part in
the root of PT(M). Otherwise, xËœ is the initial abstraction sequence of the ith argument
of a subterm of M of the form yN1 : : : Nk and iâˆˆ{1; : : : ; k}, kÂ¿1. Then, p descends
in tree(â€™) from the ith branch=tail-variable of the primitive part pâ€² that corresponds
to y. Since, Tx occurs in the ith argument of an occurrence of y, we conclude that Tp
occurs in the subtree rooted at the ith branch of an occurrence of pâ€² in PT(M).
For (ii) we begin by noting that the only occurrence of p0 in PT is in its root and
that p0 has arity 1. Therefore the expression constructed in part (a) of Algorithm 2.18
is of the form x0(T ) and that T = xi1 : : : xik :N , where pi1 ; : : : ; pik are the descendents
of p0 (at branch 1) in tree(â€™) and such that N corresponds to the subtree beneath
p0 in PT.
The term x0(T ) was constructed starting from an application of variables, by intro-
duction of abstraction-sequences before subterms in argument position, but never in
function position. So it is surely a -term in -normal form and consequently the same
is true for the term-scheme T , which is the result after step (b).
Now, consider any occurrence Txi (not in an abstraction-sequence) of a variable xi
in T , which is due to an occurrence Tpi in PT. Let pm be the primitive part of arity
lÂ¿1 such that, in tree(â€™), pi is a descendent of pm at some branch j. The second
condition in the de8nition of valid proof-trees guarantees that there is at least one
occurrence Tpm in PT such that the Tpi is in the subtree rooted in the jth branch of pm.
This is reVected in T as an occurrence of the variable xm with l arguments and such
that the occurrence Txi is in the jth argument of xm, which begins with an abstraction
sequence in which xi occurs, binding thus the occurrence Txi (if not already binded 4 ).
We conclude that T is closed.
Finally, denote by â€™i, for 16i6n, the subtype of â€™ such that the subtree t(â€™i)
in tree(â€™) has primitive part pi at its top (cf. Algorithm 2.9). Now, consider any
4 The same variable name may appear in more than one abstraction, corresponding to diJerent occurrences
of the same primitive part.
392 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
occurrence Tps of a primitive part ps of arity lÂ¿1 in PT, let PT
â€² be the subtree of
PT rooted in branch jâˆˆ{1; : : : ; l} of Tps, let A be the jth tail-variable of ps (and con-
sequently the head-variable of the primitive part in the top of PTâ€²) and 8nally let
pj1 ; : : : ; pjt , tÂ¿0, be the descendents of ps at branch j in tree(â€™). It follows from the
algorithm Terms that the jth argument of the occurrence Txs in x0(T ), created due to Tps,
is of the form T â€²= xj1 : : : xjt :P. We will show by induction on the number of occur-
rences of type-variables in PTâ€² that, for the type-context /= {x1 : â€™1; : : : ; xn : â€™n} there
is /âˆ’ xj1 : : : xjt :P : â€™j1 â†’Â· Â· Â·â†’â€™jt â†’A in TA, i.e. given / the type â€™j1 â†’Â· Â· Â·â†’â€™jt
â†’A can be assigned to xj1 : : : xjt :P, cf. [8, Chapter 2]. Then, taking for Tps the unique
occurrence of p0 in PT, one has /âˆ’ xi1 : : : xik :N : â€™i1 â†’Â· Â· Â·â†’â€™ik â†’A0, where A0 is
the tail-variable of p0, i.e. /âˆ’T : â€™. Furthermore, since T is closed, we conclude that
also âˆ’T : â€™ is true in TA. On the other hand, T is clearly long, since every variable
xi of type â€™1â†’Â· Â· Â·â†’â€™lâ†’A appears always with exactly l arguments, due to the fact
that the corresponding primitive part pi has l tail-variables.
We begin the induction proof with the case PTâ€²=pi, iâˆˆ{1; : : : ; n} and
pi =
A
| ;
hence â€™i =A. Since pi has no tail-variable, there are no primitive parts descending from
pi in tree(â€™), thus xj1 : : : xjt :P= xj1 : : : xjt : xi and /âˆ’ xj1 : : : xjt : xi : â€™j1 â†’Â· Â· Â·â†’
â€™jt â†’A is true in TA.
Now, let the primitive part in the top of PTâ€² be pi of arity lÂ¿1. Furthermore,
for 16s6l let ps1 ; : : : ; psls be the descendents (in tree(â€™)) from pi at branch s=tail-
variable As, let  xËœs be the abstraction-sequence xs1 : : : xsls and let â€™
s=â€™s1 â†’Â· Â· Â·â†’
â€™slsâ†’As. Then, â€™i =â€™1â†’Â· Â· Â·â†’â€™lâ†’A and P= xi( xËœ1:P1) : : : ( xËœl:Pl), where each
Ëœxs:Ps is constructed from subtree PTs rooted in the sth tail-variable of pi. In or-
der to show that /âˆ’ xj1 : : : xjt :P : â€™j1 â†’Â· Â· Â·â†’â€™jt â†’A is true in TA, it suPces to
show that for 16s6l, given context / the type â€™s can be assigned to  xËœs:Ps in TA.
This follows from the induction hypothesis applied to PTs, thus 8nishing the induction.
To 8nish the proof of part (ii) 8rst note that for nÂ¿1 and T resulting from (b)
of Terms Algorithm, every term M âˆˆT 0:::0x1 ::: xn is a closed term (for this it suPces to
show by structural induction on N , that for any term N with variables in {x1; : : : ; xn},
if M âˆˆNk1 :::knx1 ::: xn , then for the set FV (M) of free variables of M , one has FV (M)âŠ†{xji |
16i6n; 06j6ki âˆ’ 1}âˆª { Txi | 16i6n; xi âˆˆFV (N ); ki =0}, and consequently for
M âˆˆT 0:::0x1 ::: xn there is FV (M)= âˆ…). On the other hand, we know that there is a deduc-
tion of T : â€™ in TA. This deduction can then easily be changed into a deduction of
M : â€™, assigning identical types to variables with the same index.
The remaining claim that for every closed long normal inhabitant M of â€™ there is
M âˆˆ Terms(PT(M)), included here for the sake of completeness, is a consequence of
the symmetry of the two algorithms, and will actually not be used in this paper.
2.3. Arity-1 formulas
In this subsection, we identify the class of formulas for which decidability of BBâ€²IW-
inhabitation will be shown.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 393
Denition 2.21. A primitive part p in a formula-tree is called terminating iJ it is of
the form
A
| . It is called composed of arity nÂ¿1 iJ it is of the form
:
We call a formula an arity-1 formula iJ every composed primitive part in its formula-
tree is of arity 1.
Another simple characterisation of arity-1 formulas, that does not rely on the formula-
tree approach can be given using the notion of polarities of occurrences of subformulas,
cf. De8nition 2.6. Then, it follows that arity-1 formulas are exactly the formulas such
that all negative occurrences of subformulas are of the form â†’A or A, where  is a
type and A a type-variable.
Example 2.22. The arity-1 formula
 = (Aâ†’ B)â†’ (((Bâ†’ B)â†’ B)â†’ A)â†’ (((Bâ†’ A)â†’ Aâ†’ A)â†’ B)â†’ A
has the following formula-tree
with primitive parts p0 =
|
A
, p1 =
B
|
A
, p2 =
A
|
B
, p3 =
B
|
A
, p4 =
B
|
B
,
p5 =
A
|
B
, and p6 =
A
| . A valid proof-tree for this formula is
394 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
p0
p2
p3
p6
with appearance |
A
|
B
|
A
|
:
It is important to note that a proof-tree for an arity-1 formula is not really a tree,
but it degenerates into a sequence=chain of parts p0; : : : ; pf. This is due to the fact that
each internal primitive part in an arity-1 formula must always be of the form
X
|
Y
;
as can be seen in the two previous examples. Furthermore, note that whenever a
primitive part p descends from another primitive part pâ€², then pâ€² must have arity 1
and p descends from pâ€² at branch 1. So, in the remaining, where we deal with arity-1
formulas, we will usually just say that p descends from pâ€² and no longer specify the
branch which is necessarily branch 1.
The following properties or arity-1 formulas will be used later on. Here, we call a
term compound if there occurs at least one application in it.
Lemma 2.23. Let M be a long normal BBâ€²IW-inhabitant of an arity-1 formula â€™ and
such that M contains a compound subterm N . Then, N is of the form x1 : : : xn:yP,
with nÂ¿0. Moreover, x1; : : : ; xnâˆ’1 are all of non-atomic type. Furthermore, there are
abstractions in P if and only if xn is of non-atomic type.
Proof. First note that neither M nor any subterm of M can be of the form x:x. The
former is due to the fact that M has to contain at least one application in order to have
a compound subterm N . The latter follows from the fact that if M has a subterm of the
form x:x then there must be another subterm of M of the form zU1 : : : (x:x) : : : Ul,
lÂ¿0, covered by abstraction sequences sËœ1; : : : ; sËœt , with tÂ¿1, in which z occurs. This
subterm then violates the condition imposed on BBâ€²IW-inhabitants that there should
be IndsËœ1 ;:::; sËœt (z)4 IndsËœ1 ;:::; sËœt (x:x) which is not the case since z 4âŠ¥. Furthermore, note
that every variable x in M is of some type , where  is a negative occurrence of
a subformula of â€™, also called a negative subpremise in [8]. Since â€™ is an arity-1
formula, it follows that  is either of the form â†’A or A, where  is a type and A
a type-variable. Thus, it follows from M being a long inhabitant that every variable
occurs always with one argument if its type is of the form â†’A and always with zero
arguments if its type is of the form A. We conclude that every compound subterm of
M is of the form x1 : : : xn:yP, with nÂ¿0. Since P cannot be of the form x:x we
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 395
gain enough insight to conclude that M is necessarily of the form
sËœ1:z11(z
2
1(: : : z
k1
1 (sËœ2:z
1
2(: : : z
k2
2 (sËœ3: : : : (sËœm:z
1
m(: : : (z
km
m z) : : :)) : : :) : : :)) : : :))
with non-empty abstraction sequences sËœ1; : : : ; sËœm, mÂ¿1, k1; : : : ; kmÂ¿1, such that every
variable zji is of non-atomic type and occurs in one of sËœ1; : : : ; sËœi, with 16i6m and
16j6kj, while the only variable of atomic type is z. Finally, it follows from De8ni-
tion 2.2 that z has to be the last variable in sËœm, which concludes the proof.
Lemma 2.24. Every BBâ€²IW-inhabitated arity-1 formula has exactly one terminating
primitive part in its formula-tree.
Proof. This result follows from the analysis made in the proof of the previous lemma
together with the fact that negative occurrences of atomic subformulas in a formula
correspond to terminating primitive parts in its formula-tree.
Due to Lemma 2.24, from now on we only consider arity-1 formulas with exactly
one terminating primitive part in their formula-trees.
3. Rewriting-systems over typed sequences
In this section, we de8ne the notion of rewriting-systems over typed sequences that
will be used in order to prove decidability for arity-1 formulas. In fact, decidability
will be shown using a mapping from arity-1 formulas to rewriting-systems. The main
goal of these rewriting-systems is to describe the important steps during the search of
a long normal BBâ€²IW-inhabitant of an arity-1 formula. As such, remember that each
variable x of type  in a long normal inhabitant of a formula â€™ corresponds to a
negative occurrence of  in â€™, and is represented by the subtree t() of the formula-
tree tree(â€™). The primitive part, say px, in the top of this subtree t() describes the
consequences of using x during the construction of a subterm M : if
px =
A
|
B
and has descendents p1; : : : ; pn (at branch 1) in tree(â€™), then M is of the form
x(x1 : : : x n:N ) of atomic type A, where N of atomic type B has to be constructed.
Furthermore, all the new variables x1; : : : ; x n have to be used in N . Also all the variables
in the abstraction sequence over M that have not been used before have to appear in
N , as well as the last variable in this sequence (even if it was already used, as will be
seen in Lemma 4.5). All this will be represented as a rewriting system. Here sequences
of variables juxtaposed will be used to represent the whole abstraction sequence of
variables over the subterm that is actually being constructed, i.e. all the variables, in
order from the left, that have the subterm in their scope. A type-variable assigned to
this sequence represents the type of this subterm, and rewriting-rules will describe the
change of the current task due to the use of variables.
396 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
Denition 3.1. A typed sequence is a 8nite sequence of variables juxtaposed x1 : : : xn,
with nÂ¿0, to which a type-variable A has been assigned, and will be represented by
x1 : : : xn ::A.
The meaning of a typed sequence x1 : : : xn ::A (where x1 : : : xn represents a sequence,
in which variables may occur more than once, and not as in -calculus an application of
variables) is the following. Given a type â€™ there will be a variable name associated with
each primitive part in tree(â€™), or equivalently to each negative subformula of â€™. Then,
during the construction of a long normal BBâ€²IW-inhabitant of â€™ the typed sequence
x1 : : : xn ::A represents an intermediate step such that so far the sequence of variables
that have been introduced in abstractions have types corresponding to x1, to x2; : : :,
to xn. Also, in order to obtain a long normal BBâ€²IW-inhabitant a subterm of type A
still has to be constructed. Note that although variables may occur more than once in
a typed sequence, this does not imply a clash of bounded-variables. In fact, it rather
describes the construction of a term in which (at least) two distinct variables have the
same corresponding primitive part.
Denition 3.2. A rewriting-system over typed sequences is a tuple R=(4; R; xf ::Cf)
such that
â€¢ xf is a variable and Cf a type-variable;
â€¢ 4 is a typed sequence;
â€¢ R is a 8nite set of rules of the form x ::A â†’ x1 : : : xn ::B, where x; x1; : : : ; xn are
term-variables, A and B are type-variables and nÂ¿0.
Denition 3.3. The expansion rule â‡’R of typed sequences with a rewriting-system
R=(4; R; xf ::Cf) is de8ned as follows:
â€¢ If z1 : : : zm ::A is a typed sequence and zi ::A â†’ x1 : : : xn ::B âˆˆR, for some 16i6m,
then
z1 : : : zm :: Aâ‡’R z1 : : : zmx1 : : : xn :: B:
The corresponding occurrence of zi in z1 : : : zm is said to be used in this expansion-
step. Furthermore, if i =m, we call it to be used in a non-=nal position.
A typed sequence 5 expands to 5Ëœ iJ 5â‡’?R 5Ëœ, where â‡’?R denotes the reVexive, transitive
closure of â‡’R. A typed sequence 5 expands successfully with R=(4; R; xf ::Cf) iJ
there is some expansion from 5 to a typed sequence 5Ëœ= z1 : : : zM ::Cf such that
â€¢ zM = xf and zi = xf for any other zi âˆˆ{z1; : : : ; zMâˆ’1};
â€¢ every one of the occurrences of variables in z1; : : : ; zMâˆ’1 has been used in a non-8nal
position at least once during the expansion of 5 to 5Ëœ.
If the initial sequence 4 expands successfully with R=(4; R; xf ::Cf), then R is also
called a terminating rewriting-system.
In the following, we de8ne a function R( ) that maps formulas into rewriting-
systems. In Section 4, it will be shown that BBâ€²IW-theorems are associated
with terminating rewriting-systems, while formulas that are not BBâ€²IW-theorems are
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 397
associated with non-terminating rewriting-systems. A decision algorithm for termina-
tion of rewriting-systems will be given in Section 5.
Denition 3.4. Given an arity-1 formula , consider its formula-tree FT () with prim-
itive parts p0; : : : ; pn; pf, where p0 is the root of FT () and
pf =
Cf
|
its unique terminating primitive part. We associate with  a rewriting-system R()=
(4; R; xf ::Cf) by the following:
â€¢ 4 is the typed sequence x1 : : : xm ::A, where p1; : : : ; pm are the primitive parts de-
scending from the root
p0 =
|
A
in tree();
â€¢ for every primitive part pi of the form
B
|
C
and with descendents pi1 ; : : : ; pimi in tree(), where miÂ¿0, there is a rule
xi ::B â†’ xi1 : : : ximi ::C in R (occasionally abbreviated by xi ::B â†’ xËœi ::C).
Example 3.5. For  from Example 2.22, we have R()= (4; R; x6 ::A), where
â€¢ 4= x1x2x3 ::A
â€¢ and
R : x1 :: B â†’  :: A
x2 :: A â†’ x4 :: B
x3 :: B â†’ x5x6 :: A
x4 :: B â†’  :: B
x5 :: A â†’  :: B:
The following expansion sequence shows that R() is terminating, since 4 expands
successfully with R() to 5= x1x2x3x4x4x5x6 ::A.
x1x2x3 :: A â‡’ x1x2x3x4 :: B
â‡’ x1x2x3x4 :: A
â‡’ x1x2x3x4x4 :: B
â‡’ x1x2x3x4x4 :: B
â‡’ x1x2x3x4x4x5x6 :: A
â‡’ x1x2x3x4x4x5x6 :: B
â‡’ x1x2x3x4x4x5x6 :: B
â‡’ x1x2x3x4x4x5x6 :: A:
398 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
Note, that for sake of readability in every step of this expansion we underlined
the occurrence of the variable used to obtain the next sequence. Furthermore, we
omitted reference to R() during this expansion, writing â‡’ rather than â‡’R(). This
will be done whenever there is no ambiguity concerning the rewriting-system we
refer to.
4. BBâ€²IW-inhabitation and terminating rewriting-systems
4.1. BBâ€²IW-inhabitation implies terminating rewriting-system
In this subsection, we show that every BBâ€²IW-inhabitated arity-1 formula  gives rise
to a terminating rewriting-system R()= (4; R; xf ::Cf). For this, we prove that given
a BBâ€²IW-inhabitant M of , the initial sequence 4 expands successfully to the typed
sequence Seq(M) de8ned below, in De8nition 4.2.
First, consider the unique long inhabitant M+ of  to which M "-expands. Every
variable in M+ corresponds exactly to one primitive part, diJerent from p0, in the
formula-tree tree() with primitive parts p0; p1; : : : ; pn; pf, where nÂ¿0. Now, let N be
any term obtained by renaming variables in M+ in the following way: all occurrences
of variables corresponding to a primitive part pi, with iâˆˆ{1; : : : ; n; f}, are named xji
for some jÂ¿1. Here, occurrences of the same variable are given the same exponent j
(i.e. the same name) and diJerent variables are given diJerent exponents (i.e. receive
diJerent names). Obviously, there is N â‰¡ M+ and N is a long normal BBâ€²IW-inhabitant
of .
Example 4.1. Consider the arity-1 formula
 = (((Aâ†’ A)â†’ (Bâ†’ A)â†’ A)â†’ A)â†’ ((Bâ†’ A)â†’ B)â†’ A
with formula-tree
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 399
with primitive parts
p0 =
|
A
; p1 =
A
|
A
; p2 =
B
|
A
; p3 =
A
|
A
; p4 =
A
|
B
and p5 =
B
| :
A (long) normal BBâ€²IW-inhabitant of  is
M = xy:x(zu:x(vs:u(y(t:z(v(st))))));
where x corresponds to p1, y to p2, z and v to p3, u and s to p4, and 8nally t to p5.
After renaming we obtain the term
N = x11x
1
2 :x
1
1(x
1
3x
1
4 :x
1
1(x
2
3x
2
4 :x
1
4(x
1
2(x
1
5 :x
1
3(x
2
3(x
2
4x
1
5)))))):
Denition 4.2. Let M be a long inhabitant of an arity-1 formula  and consider a
term N â‰¡ M as above, i.e. a long normal inhabitant of  where variables are indexed
according to the primitive part in tree() they correspond to. Furthermore, let Cf
be the type-variable in the (unique) terminating primitive part in tree(). We de-
8ne Seq(M)= x1 : : : xn ::Cf, where x1 : : : xn is the sequence of variables in successive
abstractions in N after erasing superscripts=exponents.
Example 4.3. For the term from Example 4.1 we have Seq(M)= x1x2x3x4x3x4x5 ::B.
Below we will show that for every type  with normal inhabitant M the rewriting-
system R() is terminating, since its initial sequence 4 expands successfully to Seq(M).
During the proof, we will also need the notion of eJective occurrences of variables in
terms.
Denition 4.4. We call the underlined occurrence of x in a term of the form x:y1(: : :
yk(xP) : : :), with kÂ¿0, ine>ective. Every ineJective occurrence of a variable x in a
subterm of a term M is an ineJective occurrence of x in M . An occurrence of a
variable in a term (but not in an abstraction sequence) that is not ineJective is called
e>ective.
In other words, an occurrence of a variable x in a long normal BBâ€²IW-term is always
eJective, unless it is the 8rst x in a subterm of the form xP covered by an abstraction
sequence whose last variable is x. The following result shows that all variables in a
long normal BBâ€²IW-term have at least one eJective occurrence.
Lemma 4.5. If Q= x:y1(: : : yk(xP) : : :) is a subterm of a long normal BBâ€²IW-term
M , then there is at least one e>ective occurrence of x in P.
Proof. Consider the sequence of the variables xËœ= x1; : : : ; xn; x, nÂ¿0, that occur in ab-
stractions in M which have the subterm y1(: : : yk(xP) : : :) in their scope, together with
the induced implicit order âŠ¥â‰º x1â‰º Â· Â· Â·â‰º xnâ‰º x. From De8nitions 2.1 and 2.2, we con-
clude that IndËœx(P)= x, thus xâˆˆFV (P). We now prove the result by induction on the
400 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
length of P. If P= x, this occurrence of x is an eJective occurrence. If P=yPâ€², then
xâˆˆFV (Pâ€²) (for y = x as well as for y= x) and by the induction hypothesis x has an
eJective occurrence in Pâ€². Otherwise, P= y:Pâ€², where xâˆˆFV (Pâ€²). All occurrences
of x in Pâ€² are clearly eJective.
Theorem 4.6. For every BBâ€²IW-inhabitant M of an arity-1 formula , the initial se-
quence 4 expands successfully with R()= (4; R; xf ::Cf) to Seq(M).
Proof. Consider N â‰¡ M as before, i.e. obtained from the unique long normal inhabi-
tant of  to which M "-expands by renaming variables according to the primitive parts
they correspond to.
First note that for Seq(M)= s1 : : : sl ::A there is exactly one occurrence of xf
in s1 : : : sl, which is sl and that A=Cf. The latter results from the de8nition of
Seq(M) and the former from xf being the only variable of atomic type and from
Lemma 2.23.
Now let P be any long subterm of N that is not an abstraction and which is in the
scope of variables xËœP = x1; : : : ; xn and let B be the atomic type of P, for P is long.
Let yËœP =y1; : : : ; yk be the subsequence of x1; : : : ; xn obtained by deleting all variables
xj such that P occurs as a subterm of the argument of an eJective occurrence of xj.
Note that all of y1; : : : ; yk occur at least once (cf. Lemma 4.5) in P. For example, if
P=y(zu) is a subterm of xyz:z(y(x(u:y(zu))) there is xËœ= x; y; z; u and yËœP = z; u;
if we consider Pâ€²= x(u:y(zu)), then xËœ= x; y; z and yËœPâ€² = x; z.
We now prove by induction on the number of applications in P, that the typed
sequence x1 : : : xn ::B expands to Seq(M), thus Seq(M)= x1 : : : xn5 ::Cf, and during
this expansion all occurrences of variables in y1; : : : ; yk and 5, diJerent from xf, are
used in a non-8nal position.
First suppose that P= x is a variable. Since it has atomic type B, we conclude
from Lemma 2.23 that x= xn= xf, thus B=Cf, as well as Seq(M)= x1 : : : xn ::Cf. On
the other hand, we know from Lemma 4.5 that all of y1; : : : ; yk have to occur at
least once in P. Thus, y1; : : : ; yk is just xf. The result becomes trivially true. In fact,
x1 : : : xn ::B expands in zero steps to Seq(M), and there are no variables diJerent from
xf in y1; : : : ; yk .
Otherwise, by Lemma 2.23, P= x(u1 : : : ut :Q) such that Q, of type D, is not an
abstraction and tÂ¿0. Note that the 8rst occurrence of x in P is eJective if and
only if x = xn, i.e. the corresponding occurrence of x is in a non-8nal position in
x1 : : : xn. From the correspondence between variables and primitive parts we conclude
that there is the rule x ::B â†’ u1 : : : ut ::D in R. Thus, x1 : : : xn ::Bâ‡’ x1 : : : xnu1 : : : ut ::D.
Now, it is suPcient to apply the induction hypothesis to the term Q, typed sequence
xËœQ = x1 : : : xnu1 : : : ut ::D and yËœQ de8ned as before, which means that
yËœQ =
ï£±ï£´ï£´ï£²
ï£´ï£´ï£³
y1 : : : yku1 : : : ut if x =âˆˆ {y1; : : : ; yk}
or if the 8rst x in P is ineJective
and x = xn = yk ;
y1 : : : ylâˆ’1yl+1 : : : yku1 : : : ut otherwise (x = yl; 16l6k);
which 8nishes the proof.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 401
Example 4.7. For  from Example 4.1, we have R()= (4; R; x5 ::B) with 4= x1x2 ::A
and
R = {x1 :: A â†’ x3x4 :: A; x2 :: B â†’ x5 :: A; x3 :: A â†’  :: A; x4 :: A â†’  :: B}:
Recall that N = x11x
1
2 : x
1
1(x
1
3x
1
4 : x
1
1(x
2
3x
2
4 :x
1
4(x
1
2(x
1
5 :x
1
3(x
2
3(x
2
4x
1
5)))))).
In fact, the initial sequence 4 expands to Seq(M)= x1x2x3x4x3x4x5 ::B as shown
below:
x1x2 :: Aâ‡’ x1 :: A â†’ x3x4 :: A N = x1x2:x1P1
â‡’ x1x2x3x4 :: A x1 :: A â†’ x3x4 :: A P1 = x3x4:x1P2
â‡’ x1x2x3x4x3x4 :: A x4 :: A â†’  :: B P2 = x3x4:x4P3
â‡’ x1x2x3x4x3x4 :: B x2 :: B â†’ x5 :: A P3 = x2P4
â‡’ x1x2x3x4x3x4x5 :: A x3 :: A â†’  :: A P4 = x5:x3P5
â‡’ x1x2x3x4x3x4x5 :: A x3 :: A â†’  :: A P5 = x3P6
â‡’ x1x2x3x4x3x4x5 :: A x4 :: A â†’  :: B P6 = x4P7
â‡’ x1x2x3x4x3x4x5 :: B xf = x5 P7 = x5
where the second column contains the rewriting rule expansion applied and the third
column contains its corresponding subterm, as in the proof of Theorem 4.6.
Corollary 4.8. If  is a BBâ€²IW-inhabited type, then R() is a terminating rewriting-
system.
4.2. Termination implies BBâ€²IW-inhabitation
In the following, we show that whenever the initial sequence 4 of R() expands
successfully to a sequence 5, then  has at least one BBâ€²IW-inhabitant. For this, con-
sider any successful expansion from 4 to 5= z1 : : : znxf ::Cf and perform the following
annotations on z1 : : : znxf. First, associate new exponents to diJerent occurrences of the
same variable in this sequence. Second, insert in this sequence an item [xji ] before
every subsequence that has been introduced using the occurrence of xji . Third, append
the item [x1f] at the end of the sequence.
The algorithm T, that we will show to compute a BBâ€²IW-inhabitant M5 = T(5Ëœ) of 
from this new sequence, denoted by 5Ëœ, is given by the following:
â€¢ T([x])= x;
â€¢ T([x]:)= x(T(:));
â€¢ T(x:)= x:T(:).
Example 4.9. An annotated version 5Ëœ of 5= x1x2x3x4x4x5x6 ::A from Example 3.5 is
x11x
1
2x
1
3[x
1
2]x
1
4[x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]
and M5 = T(5Ëœ) is given by
M5 = T(x11x
1
2x
1
3[x
1
2]x
1
4[x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6])
= x11 :T(x
1
2x
1
3[x
1
2]x
1
4[x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6])
402 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
= x11x
1
2 :T(x
1
3[x
1
2]x
1
4[x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6])
= x11x
1
2x
1
3 :T([x
1
2]x
1
4[x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6])
= x11x
1
2x
1
3 :x
1
2(T(x
1
4[x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]))
= x11x
1
2x
1
3 :x
1
2(x
1
4 :T([x
1
1][x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(T([x
1
2]x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6])))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(T(x
2
4[x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :T([x
1
4][x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(T([x
1
3]x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6])))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(T(x
1
5x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]))))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(x
1
5 :T(x
1
6[x
1
5][x
2
4][x
1
1][x
1
6]))))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(x
1
5x
1
6 :T([x
1
5][x
2
4][x
1
1][x
1
6]))))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(x
1
5x
1
6 : x
1
5(T([x
2
4][x
1
1][x
1
6])))))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(x
1
5x
1
6 : x
1
5(x
2
4(T([x
1
1][x
1
6]))))))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(x
1
5x
1
6 : x
1
5(x
2
4(x
1
1(T([x
1
6])))))))))
= x11x
1
2x
1
3 :x
1
2(x
1
4 : x
1
1(x
1
2(x
2
4 :x
1
4(x
1
3(x
1
5x
1
6 : x
1
5(x
2
4(x
1
1x
1
6))))))):
Theorem 4.10. Consider an arity-1 formula  with rewriting-system R()= (4; R;
xf ::Cf) and a typed sequence 5 such that 4 expands successfully to 5. Then, M5
is a BBâ€²IW-inhabitant of .
Proof. Consider an annotated version 5Ëœ of 5. We begin arguing that for every such
sequence 5Ëœ, if 5Ëœ= :1x[x1] : : : [xn]:2, nÂ¿0, then xâˆˆFV (T(:2)). For this note that items
of the form [z] in 5Ëœ are introduced due to the use of z during the expansion of 4
to 5. Since every variable in 5, but xf, has to be used at least once in a non-8nal
position during the expansion (cf. De8nition 3.3), there has to be at least one item [x]
in [x1] : : : [xn]:2. Now, even if x= xi for some 16i6n, then this expansion with x was
performed in a 8nal position and there must be another item [x] in :2. Thus, in any
case there has to be at least one item [x] in :2 leading to a free (variables have been
renamed in 5Ëœ, thus there is no other unbracketed x in 5Ëœ) occurrence of x in T(:2).
Now, in order to prove that M5 is a BBâ€²IW-term, i.e. M5 âˆˆHRM (cf. Proposition
2.3), we show that during the calculation of M5, for every computed subterm M = T(:)
in the scope of variables zËœ= z1; : : : ; zs, sÂ¿1, M âˆˆHRMzËœ as well as IndzËœ (M)= zs. We
prove this result by induction on the length of :, which is the remaining subsequence
of 5Ëœ, which during the computation of M5 = T(5Ëœ) is consumed from left to right.
For := [x], there is x= x1f = zs and the result is true.
For := [x]:â€², one has M = T([x]:â€²)= x(M â€²), where M â€²= T(:â€²) with M â€² âˆˆHRMzËœ and
IndzËœ (M â€²)= zs. On the other hand, the item [x] appears in 5Ëœ due to the use of x during
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 403
the expansion. So, in 5Ëœ there must be an unbracketed occurrence of x on the left
of this item [x]. Since every unbracketed occurrence of a variable gives origin to an
abstraction, we conclude that x is one of z1; : : : ; zs, and consequently x4 zs. Thus, it
follows from IndzËœ (x)= xâ‰º zs= IndzËœ (M â€²) that M âˆˆHRMzËœ as well as IndzËœ (M)= zs.
For := x:â€², there is M = T(x:â€²)= x:M â€², where M â€²= T(:â€²) with M â€² âˆˆHRMzËœx and
IndzËœx(M â€²)= x, hence xâˆˆFV (M â€²). We conclude that M = x:M â€² âˆˆHRMzËœ. On the other
hand, since M is in the scope of variables z1; : : : ; zs, there must be unbracketed occur-
rences of variables z1; : : : ; zs (in this order, possibly separated by bracketed occurrences
of variables) in 5Ëœ on the left of x:â€². Thus, 5Ëœ is of the form :?zs[x1] : : : [xn]x:â€², nÂ¿0, for
some sequence :? (containing unbracketed occurrences of z1; : : : ; zsâˆ’1). We conclude
from the remark in the beginning of the proof that zs âˆˆFV (M), hence IndzËœ (M)= zs.
Correct typing is guaranteed by the fact that the term M computed by T is (modulo
-conversion) in the set Terms(PT5) which has been shown (cf. Proposition 2.20) to
be a set of closed long normal inhabitants of . Here PT5 denotes the proof-tree
p0
pi1
...
pin
pf
;
where [xj1i1 ] : : : [x
jn
in ][x
1
f] is the subsequence of bracketed items in 5Ëœ.
Note that if [xj1i1 ] : : : [x
jn
in ][x
1
f] is the subsequence of bracketed items in 5Ëœ, then 5Ëœ
has to be of the form xl1k1 : : : x
ls
ks [x
j1
i1 ]Ëœx
j1
i1 [x
j2
i2 ]Ëœx
j2
i2 : : : [x
jn
in ][x
1
f], where 4= xk1 : : : xks , and
where each subsequence xËœ ji is the sequence of variables introduced by the use of
variable xji in the expansion of 5 and marked by the item [x
j
i ] in 5Ëœ. The sequence
following [xjnin ] has to empty (but for the type aâ†’ a). Otherwise the variables in
this sequence would still have to be used leading to further bracketed items in 5Ëœ.
Also note that if a variable with index s introduces a sequence of variables respec-
tively with indexes s1; : : : ; sm, then in the formula-tree of the formula the descendents
of the primitive part labelled with s are, respectively, labelled with s1; : : : ; sm. Thus,
M = T(5Ëœ)= xl1k1 : : : x
ls
ks :x
j1
i1 ( xËœ
j1
i1 :x
j2
i2 ( xËœ
j2
i2 : : : : (x
jn
in x
1
f) : : :)).
On the other hand, when applying the algorithm Terms to PT5, then in the 8rst step
the application x0(xi1 (xi2 : : : (xinxf) : : :)) is formed. Then, before the argument of each of
x0; xi1 ; : : : ; xin an abstraction sequence  xËœ0;  xËœi1 ; : : : ; Ëœxin is introduced and x0 is deleted
from the top, leading to the term-scheme  xËœ0:xi1 ( xËœi1 : xi2 (Ëœxi2 : : : : (xin(Ëœxin :xf)) : : :)). Also
here the abstraction sequence that is introduced before the argument of an variable with
index s is the sequence of variables indexed with the labels of the primitive parts that
in the formula-tree descend from the primitive part labelled with s. It follows from the
remark in the footnote, which guarantees that no primitive parts descend in the formula-
tree from the primitive part labelled with in, that xËœin is in fact an empty sequence and
that  xËœ0 = x
l1
k1 : : : x
ls
ks . Thus, the term-scheme can in fact be obtained from M erasing
the superscripts of variables and on the other hand M will be one of the terms obtained
from this term-scheme in the third step of the algorithm Terms.
404 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
5. Decidability for arity-1 formulas
In order to prove decidability for arity-1 formulas, it remains to show decidability
of termination of rewriting-systems. We begin with a result on sequences of n-tuples
of non-negative integers.
5.1. The =niteness of non-ascending Nn-sequences
Let 5= Ta1; : : : ; Tai ; : : : be a sequence of n-tuples on non-negative integers, Tai =
ã€ˆa1i ; : : : ; ani ã€‰ âˆˆNn, where aji âˆˆN represents the jth position of tuple Tai.
We de8ne a partial order on n-tuples as follows:
Ta6 Tb iJ aj6bj for 16 j 6 n:
The sequence 5 is non-ascending iJ for any iÂ¡k we have Tai 6Tak . Note that in a
non-ascending sequence it follows that Tai = Tak for i = k.
We want to prove that any non-ascending sequence of n-tuples in Nn is 8nite. This
result is, in fact, equivalent to Kripkeâ€™s Lemma, cf. [1], and to some other known
results such as the in8nite division principle by Meyer, cf. [9], or to Dicksonâ€™s Lemma
in number theory, cf. [6], that can be obtained from Hilbertâ€™s Finite Basis Theorem,
cf. [7]. These powerful results have been used in various areas among which in decid-
ability proofs for some fragments of relevant systems, cf. [11].
Theorem 5.1. Let 5= Ta1; : : : ; Tai ; : : : be a non-ascending sequence of tuples in Nn. Then
5 is =nite.
Proof. Suppose, for the sake of contradiction, that 5 is in8nite. There cannot be any
bounding value on the elements of the sequence, otherwise all elements of the sequence
5 would be inside an n-dimensional cube, but there are only 8nitely many distinct
elements inside an n-dimensional cube in Nn.
So at least one of the dimensions is unbounded. Without loss of generality, suppose
the 8rst dimension is unbounded (otherwise we reorder the dimensions). Let us form
a new sequence 5(1), a subsequence of 5,
5(1) = Ta(1)1 ; : : : ; Ta
(1)
i ; : : :
by deleting from 5 all the elements in which the unbound 8rst dimension is not strictly
greater than the largest value so far of the 8rst dimension. As a result, the in8nite
sequence that consists of the 8rst dimension of 5(1) is strictly ascending.
If there is another unbounded dimension in 5(1), which without loss of generality
we can suppose is the second dimension, we repeat this process above of extracting
a sequence 5(2), where the second dimension is strictly ascending. Note that in this
process the 8rst dimension remains strictly ascending.
We repeat this process as long as there is an unbounded dimension. Suppose we
have made this process m times, 16m6n, and we end up with an in8nite subsequence
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 405
5(m) of 5.
5(m) = Ta(m)1 ; : : : ; Ta
(m)
i ; : : : :
At this point, we have m dimensions of strictly ascending values and nâˆ’m bounded
dimensions in 5(m). Take a bounded dimension, say dimension m + 1. Since 5(m) is
in8nite, there is a value cm+1 in dimension m + 1 that repeats in8nitely. Now form a
new subsequence 5(m+1) of 5(m) by deleting all values for which dimension m + 1 is
diJerent from cm+1, so that dimension m+ 1 is constant in 5(m+1).
Repeat this process for all bounded dimensions. We end up with an in8nite sequence
5(n), in which m dimensions are strictly ascending and mâˆ’ n dimensions are constant.
Since 5(n) is a subsequence of 5, this contradicts the fact that 5 is non-ascending.
Therefore, the initial sequence 5 cannot be in8nite, which 8nishes the proof.
The following lemma, similar to KXonigâ€™s lemma, will be used in the proof of
Theorem 5.4, which leads to our main result.
Lemma 5.2. Let L be a set and 6 be a binary relation de=ned on L. Let T be
any =nitely branching tree whose nodes are labelled by elements of L. Consider the
following recursive procedure, where n is a node of T and S âŠ† L.
proc Visit(n,S):
let l be the label of node n
if there exists lâ€² âˆˆ S s.t. lâ€²6l
then return
else
for each descendent nâ€² of n
do Visit(nâ€², S âˆª{l})
If for any node n in T the call Visit(n,âˆ…) does not terminate, then there exists
an in=nite sequence (li)i in L such that for all 06iÂ¡j, one has li 6lj.
Proof. The existence of a sequence (li)i is easily established as follows: assume that
Visit(n0,âˆ…) does not terminate for some node n0. Then, since the tree is 8nitely
branching, there is at least one descendent n1 of n0 such that Visit(n1,{l0}) also does
not terminate, where l0 is the label of n0. But then there is also a direct descendent
n2 of n1, such that Visit(n2,{l0; l1}) does not terminate, where l1 is the label of
n1 and l0 6l1. Similarly, we can conclude that there is a descendent n3 of n2, such
that Visit(n3,{l0; l1; l2}) does not terminate, where l2 is the label of n2 and such
that l0 6l1, l0 6l2 and l1 6l2. Since Visit(n,âˆ…) does not terminate, it is possible to
repeat this procedure inde8nitely.
5.2. Deciding termination of rewriting-systems
The following Lemma will be used in order to prove decidability of termination of
rewriting-systems.
406 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
Lemma 5.3. Consider a rewriting-system R and a typed sequence 5, such that 5
expands successfully with R. Then, there is at least one successful expansion sequence
5= 51; : : : ; 5n such that for all i; j with 16iÂ¡j6n, the typed sequences 5i and 5j do
not satisfy at least one of the following conditions:
â€¢ the type-variable in 5i and 5j is the same;
â€¢ the last term-variable in 5i and 5j is the same;
â€¢ in 5i and 5j the same term-variables occur;
â€¢ for every variable x such that kx occurrences of x in 5i have not been used in a
non-=nal position in the expansion of 5 to 5i, there are at least kx occurrences of
x in 5j that have not been used in a non-=nal position in the expansion of 5 to 5j.
Proof. Consider a successful expansion sequence 5= 51; : : : ; 5i; : : : ; 5j; : : : ; 5j+k from 5
to 5j+k of length j + k, where i; j; kÂ¿0, jÂ¿i and such that
â€¢ the type-variable in 5i and 5j is the same;
â€¢ the last term-variable in 5i and 5j is the same;
â€¢ in 5i and 5j the same term-variables occur;
â€¢ for every variable x such that kx occurrences of x in 5i have not been used in a
non-8nal position in the expansion of 5 to 5i, there are at least kx occurrences of x
in 5j that have not been used in a non-8nal position in the expansion of 5 to 5j.
Then, another successful expansion sequence 5= 51; : : : ; T5i = 5i; T5i+1; : : : ; T5i+k of
length i + kÂ¡j + k can be obtained by the following. For l=0; : : : ; k âˆ’ 1, suppose
that 5j+l+1 was obtained from 5j+l using rule xl ::Al â†’ xËœl ::Bl. Then expand T5i+l with
this same rule and using the leftmost occurrence of xl in T5i+l that has not been used
in a non-8nal position in the expansion of 5 to T5i+l, if any, or otherwise any other
occurrence of xl in T5i+l.
Now repeat the whole process to this new, shorter successful expansion sequence,
as long as necessary.
Theorem 5.4. Termination of rewriting-systems over typed sequences is decidable.
Proof. Let R=(4; R; xf ::Cf) be a rewriting-system in which occur nÂ¿0 term-
variables x1; : : : ; xn (after renaming if necessary) and mÂ¿0 type-variables A1; : : : ; Am.
Given an expansion sequence 51; 52; : : : we associate with each typed sequence 5i in
this expansion a tuple Li =(Tai ; Vi; xi; Ai), with Tai = ã€ˆa1i ; : : : ; ani ã€‰ âˆˆNn, ViâŠ†{x1; : : : ; xn},
xi âˆˆ{x1; : : : ; xn} and Ai âˆˆ{A1; : : : ; Am} by the following:
â€¢ For j=1; : : : ; n let aji be the number of occurrences of xj in 5i that have not been
used in a non-8nal position during the expansion of 51 to 5i;
â€¢ let Vi be the set of variables occurring in 5i;
â€¢ let xi be the last variable in 5i;
â€¢ and 8nally let Ai be the type-variable in 5i.
We call a typed sequence 5j in this expansion a repetition of another typed sequence
5i with iÂ¡j if and only if Tai6Taj, Vi =Vj, xi = xj and Ai =Aj, in which case we write
that Li6Lj. We know from Lemma 5.3 that if R is terminating, then there is at least
one repetition-free successful expansion sequence starting with the initial sequence 4.
On the other hand, there are only a 8nite number of distinct Vk â€™s, xk â€™s as well as Ak â€™s.
S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408 407
Thus, it follows from Theorem 5.1 that there are no in8nite, repetition-free expansion
sequences, i.e. there is no in8nite sequence of tuples (Li)i such that for any 06iÂ¡j
one has Li 6Lj.
Consider the 8nitely branching tree T de8ned by the following: the top-node is
labelled by the tuple L0 corresponding to the initial sequence 50 = 4. Furthermore, the
descendents of a node labelled with a tuple Li are all (8nitely many) nodes labelled with
tuples Li1 ; : : : ; Lini , corresponding to all the sequences 5i1 ; : : : ; 5ini that can be obtained
in one expansion-step from 5i.
Finally, change procedure Visit to immediately stop if a successful, repetition-free
expansion sequence is reached, and apply it to T. Lemma 5.2 and the remark above
about the Liâ€™s guarantee that this call terminates, thus making it a decision procedure.
Now we are able to conclude our main result.
Theorem 5.5. BBâ€²IW-inhabitation is decidable for arity-1 formulas.
Proof. It follows from Theorems 4.6 and 4.10 that an arity-1 formula  is BBâ€²IW-
inhabited if and only if the corresponding rewriting-system R() is terminating. The
decidability of the latter has been shown in Theorem 5.4.
6. Conclusions
We have shown the decidability of the arity-1 fragment of BBâ€²IW-logic using the
termination of a special kind of rewriting-system. The decision procedure is based on
the 8niteness of non-ascending Nn-sequences. The complexity of the decision procedure
is bound to be quite costly, but yet undetermined. In fact, the results in [13] suggest
that it is primitive recursive in the Ackermann function.
The method proposed here gets considerably more complicated if applied to the
whole fragment, for then the rewriting-system will not be expanding a sequence but a
tree. The relationship between the structure of BBâ€²IW--terms and these tree-expanding
rewriting-systems still has to be investigated.
And 8nally, we have not ruled out the possibility of the whole BBâ€²IW-logic being
undecidable. That undecidability, if proven, will have to depend on formulas that are
not arity-1.
Acknowledgements
We would like to thank the anonymous referees for numerous comments which
contributed to enhance the presentation.
The work presented in this paper has been partially supported by funds granted to
LIACC through Programa de Financiamento Plurianual, Fundac"aËœo para a CieË†ncia e
Tecnologia and Programa POSI.
408 S. Broda et al. / Theoretical Computer Science 318 (2004) 373â€“408
References
[1] A.R. Anderson, N.D. Belnap, Entailment, Vol. I, Princeton University Press, USA, 1975.
[2] H. Barendregt, Lambda calculi with types, in: S. Abramsky, D.M. Gabbay, T.S.E. Maibaum (Eds.),
Background: Computational Structures, Handbook of Logic in Computer Science, Vol. 2, Oxford Science
Publications, 1992, pp. 117â€“309.
[3] C.-B. Ben-Yelles, Type-assignment in the lambda-calculus; syntax and semantics, Ph.D. Thesis,
Mathematics Department, University of Wales, Swansea, UK, 1979.
[4] S. Broda, L. Damas, On the structure of normal -terms having a certain type, Proc. 7th WoLLICâ€™2000,
2000, pp. 33â€“43, copy in http://www.dcc.fc.up.pt/âˆ¼sbb/wollic00.ps.
[5] M.W. Bunder, Proof 8nding algorithms for implicational logics, Theoret. Comput. Sci. 232 (2000)
165â€“186.
[6] L.E. Dickson, Finiteness of the odd perfect primitive abundant numbers with n distinct prime factors,
Amer. J. Math. 35 (1913) 413â€“422.
[7] D. Hilbert, XUber die Theorie der algebraischen Formen, Math. Ann. 36 (1890) 473â€“534.
[8] J.R. Hindley, Basic Simple Type Theory, in: Cambridge Tracts in Theoretical Computer Science,
Cambridge University Press, Cambridge, 1997.
[9] R.K. Meyer, H. Ono, The Finite Model Property for BCK and BCIW, Studia Logica 53 (1) (1994)
107â€“118.
[10] D. Prawitz, Natural Deduction, Almqvist and Wiksell, Sweden, 1965.
[11] J. Riche, R.K. Meyer, Kripke, Belnap, Urquhart and relevant decidability & complexity, in: G. Gottlob,
E. Grandjean, K. Seyr (Eds.), Computer Science Logic, CSLâ€™98, Lecture Notes in Computer Science,
Vol. 1584, Springer, Berlin, 1998, pp. 224â€“240.
[12] P. Trigg, J.R. Hindley, M.W. Bunder, Combinatory abstraction using B, Bâ€² and friends, Theoret. Comput.
Sci. 135 (1994) 405â€“422.
[13] A. Urquhart, The complexity of decision procedures in relevance logic, in: J.M. Dunn, A. Gupta (Eds.),
Truth or Consequences, Essays in Honor of Nuel Belnap, Kluwer Academic Publishers, Dordrecht, 1990,
pp. 61â€“76.
