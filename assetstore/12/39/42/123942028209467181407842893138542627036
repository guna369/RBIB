On -conversion in the -cube and the combination with abbreviations

Fairouz Kamareddine
University of Glasgow Department of Computing Science
17 Lilybank Gardens Glasgow G12 8QQ
Scotland FAX: +44 141 330 4913 fairouz@dcs.gla.ac.uk

Roel Bloo and Rob Nederpelt
Mathematics and Computing Science Eindhoven University of Technology
P.O.Box 513 5600 MB Eindhoven
The Netherlands FAX: +31 40 2463992 fbloo, wsinrpng@win.tue.nl

Abstract
Typed -calculus uses two abstraction symbols ( and ) which are usually treated
in di erent ways: x: :x has as type the abstraction x: : , yet x: : has type 2 rather
than an abstraction; moreover, ( x:A:B)C is allowed and -reduction evaluates it, but ( x:A:B)C is rarely allowed. Furthermore, there is a general consensus that and are di erent abstraction operators. While we agree with this general consensus, we nd it nonetheless important to allow to act as an abstraction operator. Moreover, experience with AUTOMATH and the recent revivals of -reduction as in KN 95b, PM 97], illustrate the elegance of giving -redexes a status similar to -redexes. However, -reduction in the -cube faces serious problems as shown in KN 95b, PM 97]: it is not safe as regards subject reduction, it does not satisfy type correctness, it loses the property that the type of an expression is well-formed and it fails to make any expression that contains a -redex well-formed.
In this paper, we propose a solution to all those problems. The solution is to use a concept that is heavily present in most implementations of programming languages and theorem provers: abbreviations (viz. by means of a de nition) or let-expressions. We will show that the -cube extended with -conversion and abbreviations satis es all the desirable properties of the cube and does not face any of the serious problems of
-reduction. We believe that this extension of the -cube is very useful: it gives a full formal study of two concepts ( -reduction and abbreviations) that are useful for theorem proving and programming languages.
Keywords: -conversion, Abbreviations, Barendregt's cube, Subject Reduction, versus .
1 Introduction
Both -reduction and the use of names to abbreviate large expressions, are useful for automating mathematics, for theorem proving and for programming languages. Evidence of this is their presence in the various implementations of mathematics, theorem proving and programming languages. In what follows, we explicit the advantages and/or problems of these two concepts and we explain why combining them is even more useful.

1

1.1 On -reduction

Type theory has almost always been studied without -conversion (which is the analogue of

-conversion
but not ! :

on (

product type
x:A:B)C !

level). That B x := C].

is, !
The

: ( x:A:b)C ! b
exceptions to this

x := are:

C] is always assumed some AUTOMATH-

languages (see NGV 94]), the -cube extended with -reduction in KN 95b] and the in-

termediate language in compilers for source languages as in PM 97]. We claim that ! is

desirable for the following reasons:

A. is, in a sense, a kind of . In higher order type theory, arrow-types of the form

A ! B are replaced by dependent products x:A:B, where x may be free in B, and thus B

depends on x. This means that abstraction can be x:A:b. But, once we allow abstraction over types,

over types: it would be

x:A:B nice to

as well as over terms: discuss the reduction

rules which govern these types. In fact, is indeed a kind of as regards the abstraction

over a variable and hence is eligible for an application.

B. Compatibility. Here are two important rules in the -cube:

(abstraction rule)

?:hx

:

Ai

`
?

b`:

B x:A:b

:

?`
x:A:B

x:A:B

:

S

(application rule)

?

`

F

: ?

`x:FAa:B:

B

x

:=?a]`

a

:

A

The (abstraction rule) may be regarded as the compatibility property for typing with

respect to abstraction. That is: b : B implies x:A:b : x:A:B.

The compatibility property for the typing with respect to application is lost however. In

fact, from instead F
To get

:tchoemx:(Apaa:pBtpibliiimcliatptyliioefnosrFrutaylep:)i,Bnognxwe:i=dthoaer]s.esnpoetcthatvoea: pFpl:icatxi:oAn:B, oinmepnleieesdsFtao:a(ddx:!A:B)aan,dbutot

change the (application rule) to:

(new application rule)

? ` F : x:A:B ? ` Fa : (

?`a:A
x:A:B)a

C. The AUTOMATH experience. One might argue that implicit -reduction (as is the
case of the ordinary -cube with the (application rule) above) is closer to intuition in the most usual applications. However, experiences with the AUTOMATH-languages ( NGV 94]), containing explicit -reduction, demonstrated that there exists no formal or informal objection against the use of this explicit -reduction in natural applications of type systems.
D. Preference types, higher degrees, conversion. In KN 95b], -reduction was shown
to have various advantages which include the possibility of calculating the preference type (?; A) of a term A in a context ?, the ability of incorporating di erent degrees of abstraction (rather than just two, and , as in the -cube) and the fact that the following rule of the -cube is super uous:

(conversion rule) ? ` A : B ??``AB:0B: 0S

B = B0

E. Programming languages. In programming language studies, a thriving area is that
of the use of richly-typed intermediate languages in sophisticated compilers for higher-order, typed source languages ( PJ 96, SA 95, TMCSHL 96]). The recently developed language

2

PM 97] aims at reducing the number of data types and the volume of code required in the compiler, by avoiding duplications. To do this, PM 97] uses the whole -cube extended with
-reduction and gives the following motivation:

For reduction there is now only one set of rules = .

With the old application rule, matters get very complicated when one adds further expressions (such as let and case).

In a compiler, -reduction allows to separate the type nder from the evaluator since `
no longer mentions substitution. One rst extracts the type and only then evaluates it.

A : : : E above (especially B and D), can be viewed as syntactic motivations for -conversion.

There are also semantic motivations for -conversion. Of these, we mention:

A. In nite levels of abstractions One may abandon the two levels ( and ) as used in

the current type systems and reformulate all type theory using di erent levels of 's, where

stehaayce,htyl0epveiesl.wnxT:h+Aah1t:iCswwewohcuaeldlrlebCe,

1
is

is the a type

, of

etc. Then, B, and the

one will current

tbyepaebtlheetoorygiwveillevbeeryretperromducnxe:dA:aBt

rather interesting to investigate.

B. Finding and evaluating types become two separate events -reduction allows to

separate the type nder from the evaluator since ` no longer mentions substitution. This approach was presented in detail in KN 95b] where the question ? ` A : B was split into

? ` A (A is typable in ?) and (?; A) = B (B is convertible to the preference type of A).

All the above are reasons why it is interesting to study -conversion in the -cube. How-
ever, extending the -cube with -conversion is not a straightforward adding of ( x:A:B)C !
B x := C] and of the (new application rule) (see KN 95b]). Changing the (application rule) in the -cube to the (new application rule) as presented above results in the following problems:

1. Correctness of types no longer holds. With -reduction, one can have ? ` A : B

without B
( y:z:z)x 6

2 or 9S : 2 and 8S

?` : hz

B :

: S.
i:hx

For
: zi

example, hz : 6` ( y:z:z)x

:

i:hx : zi
S. The

` ( y:z:y)x : (
problem arises

y:z:z)x yet because of

the new terms that contain -redexes (which did not exist in the -cube) and because

KN 95b] showed that in the -cube extended with -reduction:

(") If ? ` A : B then neither ? nor A contain -redexes and if B contains a -redex,
then B is itself that -redex.

2. The system is no longer safe. More precisely, subject reduction (SR) fails. That is,

with -reduction and the (new application rule), ? ` A : B and A !! A0 may not imply

?toBhnue`etacA(ba"0no)v:'tieBns(h.1cooFawnobvrhoezvresex:iaommni:ahprkxuleels:e, )zthihazni`s:dixmfio::hprx(oths:syizis:zb,i:loze`n).xe(.nTeye:ozd:sysh)toxhwa:tt(h9iSsy::lzha:zzst):xfoiar:mhnxdu:l(az,iyo:`zn:ey()nxeye:!zd:zs )xtxo,

but use : S.

3. The type of an expression may not be well-formed. This is related to type

correctness above. We say that A is well-formed if A 2 or 9?; B : ? ` A : B. Now

consider hz : i:hx : zi well-formed by (").

`(

y:z:y)x : (

y:z:z)x.

The type (

y:z:z)x of (

y:z:y)x is not

3

4. -redexes are not well-formed. From (") above follows that no expression that contains a -redex is well-formed.
Despite these shortcomings of -reduction, PM 97] claims that its advantages are persuasive. In this paper we will repair the shortcomings of -reduction. It is amazing that the way to repair the problem is itself a very useful way in type theory: the use of abbreviations.

1.2 On abbreviations

In many type theories and lambda calculi, there is no formal possibility to use abbreviations, i.e., to introduce names for large expressions which can be used several times in a program or a proof. This possibility is essential for practical use, and indeed implementations of Pure Type Systems such as Coq Dow 91], Lego LP 92] and Nuprl Con 86] do provide this possibility. Moreover, most implementations of programming languages (Haskell, ML, CAML, etc.) use names for large expressions via a well-known programming language concept: let expressions.

Example 1.1 Let id : A ! A be ( x:A:x) in ( y:A!A:id)id abbreviates the complex expres-
sion ( x:A:x) as id in a more complex expression in which id occurs two times.

The intended meaning of \let x : A be a in b" is that a can be substituted for x in the expression b. In a sense, the expression let x : A be a in b is similar to ( x:A:b)a which reduces to b x := a], i.e., b with all free occurrences of x replaced by a. In the let-expression, however, it is not intended to necessarily replace all the occurrences of x in b by a. Nor is it intended that such a let-expression is a part of our term. Rather, the let-expression will live in the environment (or context) in which we evaluate or reason about the expression.
One of the advantages of the expression let x : A be a in b over the redex ( x:A:b)a is that it is convenient to have the freedom of substituting only some of the occurrences of an expression in a given formula. Another advantage is e ciency; one evaluates a in let x : A be a in b only once, even in lazy languages.1 A further advantage is that using x to be a in b can be used to type b e ciently, since the type A of a has to be calculated only once.2 Furthermore, practical experiences with type systems show that let-expressions are absolutely indispensable for any realistic application. Without let-expressions, terms soon become forbiddingly complicated. By using let-expressions one can avoid such an explosion in complexity. This is, by the way, a very natural thing to do: the apparatus of mathematics, for instance, is unimaginable without a form of let-expressions (viz. de nitions).

1Note that smart lazy languages will use explicit substitution or sharing techniques to evaluate a in b x := a]

only once. Nevertheless, our extension with abbreviations as is considered here, is a straightforward extension

of the -calculus and hence has less machinery than is involved with sharing or explicit substitution. Moreover,

it may be that this simple concept of abbreviations as we introduce it can be used to formalise the notion of

sharing. In fact, the work already done in AFMOW95, BLR96] to show that some formal systems of explicit

substitution or generalised reduction can formalise sharing, can be adapted to show that a formal system of

abb2rHeveiraet,ioinnsbcxan:=alsao],btehae

successful model for sharing. type A of a is calculated many

times.

Of course with the presence of Subject

Reduction (SR), we we do not need to calculate the type of b x := a]. Instead, we calculate the type of

( x : A:b)a (where the type of a is calculated only once) and we use subject reduction to derive the type of

b x := a]. However, many programming languages (PLs) do not have a clear notion of SR. Similarly, although

in many PLs, sharing is used in order to calculate the type A of a only once in b x := a], there can be no

escape from showing that this sharing technique of PLs is correct. Our system of de nitions can be used to

formalize this sharing technique of PLs.

4

There exist already two formal studies of let-expressions in the -cube BKN 96, SP 93] where those let-expressions are called de nitions. In this paper we di er from both accounts and use the simplest way of renaming large expressions and describe such renaming as abbreviations. We di er from SP 93] in that we do not introduce new terms (let-terms) into our syntax and do not extend -reduction to deal with those new terms. We di er from BKN 96] in that we do not use nested de nitions, which are needed for generalised reduction in BKN 96] but not for -reduction.
We write hx : Aia to describe that x of type A, abbreviates a. We include abbreviations
in contexts such that if an abbreviation occurs in a context then it can be used anywhere in the term we are reasoning about in that context.
In this paper, we will use abbreviations to repair all the problems of -reduction mentioned in Subsection 1.1. In particular, we extend the -cube with both -reduction and abbreviations and we show that this extension satis es all the desirable properties (including Subject Reduction).

1.3 On combining abbreviations and -reductions

We shall show in this paper that the -cube extended with both abbreviations and -reduction
(! and the new application rule), preserves all its original properties (including safety,
correctness of types and well-formedness of the type of an expression) and allows a nonlimited occurrence of -redexes in the well-formed terms. This means that abbreviations (being important on their own) have repaired the problems of -reduction in the -cube. Let us here explain why the shortcomings of -reduction disappear with abbreviations:
Looking at the four problems of -reduction in Subsection 1.1, one sees that one needs to be able to type -redexes. This is not possible if the -cube is simply extended with the
(new application rule) and ! as KN 95b] showed. There are several routes to follow: A. In nite levels of abstractions as discussed under the semantic motivations for -
conversion. This would be very interesting to investigate, but we feel it is a drastic change from current type theory and we are not sure what complications or contradictions will arise from di erent levels of 's. We leave it as a point for future research.
B. Abbreviations. One may introduce ( - and -) redexes as a separate (compound) term,
which can be typed using abbreviations. In the type, the abbreviation is unfolded. The idea is simple: extend contexts with abbreviations and add the following rule:

(abb rule)

?

?:hx : AiB ` ( x:A:C)B

`C:
:Dx

D :=

B]

where

2f ; g

This rule says that if C : D can be typed using the abbreviation that x of type A is B, then ( x:A:C)B : D x := B] can be typed without this abbreviation. This simple extension solves all the problems of -reduction mentioned in Subsection 1.1. Here is how:

1. Correctness of types holds. We demonstrate this with the example of problem 1 of

Subsection 1.1.
for some S, hz :

Recall
i:hx :

that
zi `

we (

have hz
y:z:z)x :

: i:hx :
S. Here

zi
is

`(
how

y:z:y)x : ( the latter

y:z:z)x and want that formula now holds:

hz : i:hx : zi ` z : hz : i:hx : zi:hy : zix ` z : hz : i:hx : zi ` ( y:z:z)x : y := x]

(start and weakening) (weakening) (abb rule)

5

2. The system is now safe. We demonstrate this with the example of problem 2 of Sub-

section and we

1.1. Recall that we need to show that

have
hz :

hz : i:hx

:

i:hx : zi `

zi
x:

`
(

( y:z:y)x y:z:z)x.

: ( y:z:z)x and ( y:z:y)x ! x
Here is how the latter formula

now holds:

a: hz : i:hx : zi ` x : z

(start and weakening)

b:

hz : hz :

i:hx i:hx

: :

zi zi

` `

( x

y:z:z)x : : ( y:z:z)x

(from 1 above) (conversion, a, b, and z =

(

y:z:z)x)

3. The type of an expression is well-formed. We demonstrate this with the example

of problem 3 of Subsection 1.1. Recall that we have hz : i:hx : zi ` (

and we want we have that

to
hz

show that
: i:hx : zi

(
`

y:z:z)x is ( y:z:z)x

typable :.

(note

that

(

y:z:z)x 6

y:2z:)y.)xB:y(1

y:z:z)x above,

4. -redexes are well-formed. -redexes can now occur in contexts, terms, and types
and all the obtained -redexes are indeed well-formed.

Remark 4.2, Lemma 4.12 and Theorem 4.13 will show that indeed all the problems of reduction are solved. Intuitively, the reason is that abbreviations keep information in the context about the de ned values of variables.
We divide the paper as follows:

1. In Section 2, we set up the machinery for both abbreviations and -reduction.

2. In Section 3, we introduce the original relation of the -cube ` and the extended relation ` as in KN 95b]. We list the properties of both ` and ` .

3.

In Section 4, we introduce `ra which is
We show that all the properties of the

`r (for
-cube

r = or ) remain valid

extended with abbreviations.
for `ra. This establishes that

extending the -cube with abbreviations or with both abbreviations and -reduction

results in a well-behaved system. Due to the uniformity of our presentation, we prove

almost all the results for `ra rather than separately prove them for ` a and ` a.

2 The Formal Machinery

The systems of the -cube (see Ba 92]), are based on a set of pseudo-expressions or terms T
de ned by the following abstract syntax:
T = j 2 j V j T T j V :T :T where 2 f ; g, V is an in nite collection of variables ( ; ; x; y; z; : : : range over V ), and 2 are sorts (S; S1; S2; : : : range over f ; 2g). We let A; B; a; b : : : range over T .
Bound and free variables and substitution are de ned as usual where the binding power of is similar to that of . We write BV (A) and F V (A) to represent the bound and free variables of A respectively. We write A x := B] to denote the term where all the free occurrences of x in A have been replaced by B. Furthermore, we take terms to be equivalent up to variable renaming and let denote syntactic equality. For example, we take x:A:x y:A:y. We assume moreover, the Barendregt variable convention which is formally stated as follows:

6

Convention 2.1 (BC: Barendregt's Convention)
Names of bound variables will always be chosen such that they di er from the free ones in a term. Moreover, di erent abstraction operators have di erent variables as subscript. Hence,
we will not have ( x:A:x)x, but ( y:A:y)x instead.

We say that a rewrite relation r between terms is compatible, if for all terms A; B; C, it

holds that A r B implies AC r BC, CA r CB, x:A:C r x:B:C and given set of rewrite rules r on terms, we de ne the reduction relation
closure of r. Furthermore, for a reduction relation !r, we de ne
re exive transitive closure and its equivalence closure respectively.

!W!!x:Cerr:Ataaasnkrdtehx=er:Crc2o:Btmof.pbaF;etoirbitlgaes

throughout and use the relations: ! and ! ( x:A:B)C ! B x := C] respectively.

generated by: ( x:A:B)C ! B x := C], and

In the following de nition, declarations are familiar from the -cube. The relation 0

enables `information-preserving' extensions of the pseudocontext. We let d; d1; d2; : : : range

over declarations and abbreviations and ?; ; ?0; ?1; ?2; : : : over pseudocontexts.

De nition 2.2 (declarations, abbreviations, pseudocontexts, 0)

1. A declaration d is of the form hx : Ai. We de ne var(d) x and type(d) A.

2. An abbreviation d is of the form hx : AiB and introduces x of type A to abbreviate B.
We de ne var(d), type(d) and ab(d) to be x, A, and B respectively.

3. A pseudocontext ? is a (possibly empty) concatenation of declarations and abbreviations
d1:d2: :dn such that if i 6= j, then var(di) 6 var(dj). 4. De ne dom(?) = fvar(d) j d 2 ?g, ?-decl = fd 2 ? j d is a declaration g and ?-abb =
fd 2 ? j d is an abbreviation g. Note that dom(?) = fvar(d) j d 2 ?-decl ?-abbg.

5. De ne 0 between pseudocontexts as the least re exive transitive relation satisfying:

?: 0 ?:d: for d a declaration or an abbreviation.
?:hx : Ai: 0 ?:hx : AiB:

In the rest of this section, we let `r be a notion of derivability. The following is familiar (cf.
Ba 92]):

De nition 2.3 Let ? be a pseudocontext.

1. A : B is called a statement. A and B are its subject and predicate respectively.

2. ? `r A : B is called a judgement, and ? `r A : B : C denotes ? `r A : B ^ ? `r B : C. 3. ? is called legal if 9A; B 2 T such that ? `r A : B.

4. A 2 T is called a ?-term if 9B 2 T ? `r A : B _ ? `r B : A].

5. A 2 T is called legal if 9? A is a ?-term].

The following is needed in the conversion rule where we replace A =r B by ? `r A =ab B.

De nition 2.4 (Abbreviational r-equality) For all pseudocontexts ? we de ne the binary relation ? `r =ab to be the equivalence relation generated by

7

if A =r B then ? `r A =ab B if d 2 ?-abb and A; B 2 T such that B arises from A by substituting one particular free occurrence of var(d) in A by ab(d), then ? `r A =ab B.

Remark 2.5 If no abbreviations are present in ? then ? `r A =ab B is the same as A =r B.

The following de nition groups some preconditions of some typing rules. For example, instead
of postulating for the start rule (in the case of a declaration) that ? ` type(d) : S and var(d) 62 ?, we say ? d. This becomes particularly useful in the case of abbreviations.

De nition 2.6 For d an abbreviation or declaration, we say ? admits d, notation ? d, i

?:d is a pseudocontext

? `r type(d) : S for some sort S. if d is an abbreviation then ? `r ab(d) : type(d) Finally, we extend the -cube notion ? ` d to deal with the case of d being either a declaration
or an abbreviation.

De
We

nition 2.7 de ne ? `r

Let ? be a
d and ? `r

pseudocontext. Let d; d1 dn as follows:

d1;

:

:

:

;

dn

be

declarations

and

abbreviations.

If d is a declaration then
abbreviation then ? `r d

? i

`r
?

d
`r

i ? `r var(d) :
var(d) : type(d)

type(d). Otherwise, if
^ ? `r ab(d) : type(d)

d
^

is ?

an
`r

var(d) =ab ab(d).

? `r d1 dn i ? `r di for all 1 i n.

3 Extending the -cube with -reduction

First we introduce the -cube as presented in Ba 92]. There the only declarations allowed
are of the form hx : Ai, hence there are no abbreviations in the contexts. Thus, ? d is of the form ? hx : Ai and means that ? ` A : S for some S and that x is fresh in ?; A. Moreover, recall that var(hx : Ai) x and type(hx : Ai) A and -reduction is not allowed.

8

De nition 3.1 ( ` ) Axioms and rules of the -cube; d is a declaration, =ab is = :

(axiom)

hi ` : 2

(start rule)

?:d ` va?r(d)d: type(d)

(weakening rule)

? d ?` D:E ?:d ` D : E

(formation rule)

? ` A : S1? `

?:hx : Ai `
x:A:B : S2

B : S2 if (S1; S2) is a rule

(abstraction rule) (application rule)

?:hx

:

Ai

`
?

`b

:

B x:A:b

:

?`
x:A:B

x:A:B : S

?`

F

: ?

`x:AF:aB:

B

x

?`
:= a]

a:A

(conversion rule) ? ` A : B

? ` B0 : S ? ` A : B0

? ` B =ab B0

Each of the eight systems of
a subset of f( ; ); ( ; 2); (2;

the -cube
); (2; 2)g.

is obtained by taking the These systems are given

(S1; S2) rules allowed from in the following table:

System
!
2
P
P2
! ! P!
P! = C

Set of speci c rules (; )
( ; ) (2; ) ( ; ) ( ; 2) ( ; ) (2; ) ( ; 2)
(; )
( ; ) (2; ) ( ; ) ( ; 2) ( ; ) (2; ) ( ; 2)

(2; 2) (2; 2) (2; 2) (2; 2)

KN 95b] extended this -cube by changing !! to !! and by changing ` to ` (note that ? ` B =ab B0 is the same as B = B0, as there are no abbreviations):

De nition 3.2 (` ) ` is ` where is replaced by throughout, and the application rule changes to:

(new application rule)

?`

F ?

:`

x:AF:Ba : (

?`
x:A:B)a

a:A

Now we list some properties of ` and ` without proofs (see KN 95b]). These properties
(except of course the loss of type correctness, of SR and the non well-formedness of some types and of -redexes) will be established for the -cube extended with either abbreviations alone, or with both abbreviations and -reduction in Section 4.

Theorem 3.3 (The Church Rosser If A !!r B and A !!r C then there

Theorem
exists D

CR, such

ftohrat!!Br,!!r r=D

or and

C

)
!!r

D

2

9

Lemma
Let ? be

3.4 (Start Lemma a `r-legal context.

Tfohren`r?f`orr

r

=
:2

or and

)
8d 2

?

?

`r

d].

2

Lemma 3.5 (Correctness of types for ` , not for ` )
For r = , but not for r = we have:
If ? `r A : B then (B 2 or ? `r B : S for some sort S).
(cf. the counterexample of Subsection 1.1, Problem 1.)

2

Lemma 3.6 (Subject Reduction SR, for ` , not for ` )
For r = , but not for r = we have:
If ? `r A : B and A !! A0 then ? `r A0 : B
(cf. Subsection 1.1, Problem 2.)

2

However, a weak form of SR holds for ` . First we need the following de nition which removes the outermost -redex of a ` -legal term:

De nition 3.7 For A ` -legal, let A^ be C x := D] if A ( x:B:C)D and A otherwise.

Lemma 3.8 (Weak Subject Reduction for ` and !! ) If ? ` A : B and A !! A0, then ? ` A0 : B^

2

Lemma 3.9 (Well-formedness of types for ` , not for ` )
For r = , but not for r = we have:
If ? `r A : B then B 2 or 9C : ? `r B : C.
(cf. Subsection 1.1, Problem 3.)

2

Lemma 3.10 (Non-well-formedness of -redexes) For no ?, A, B and C there is D such that ? ` ( x:A:B)C : D.
(cf. Subsection 1.1, Problem 4.)

2

Lemma 3.11 If ? `r A :

(Uniqueness of Types for
B1 and ? `r A : B2, then

`r
B1

and !!r
=r B2

for

r

=

or

)

2

Theorem 3.12 (Strong Normalisation If A is `r-legal then SN!r(A); i.e. A is

with respect to `r and !r
strongly normalising with

for r =
respect to

or
!r

.

)

2

In the rest of the paper, we use the -cube to denote the -cube extended with -reduction and with the new application rule. We write -cube for either the - or the -cube. Recall
that r 2 f ; g and 2 f ; g.

4 Extending the -cube with abbreviations
We shall extend the derivation rules of `r so that we can use abbreviations in the context.
The rules remain unchanged except for the following points: One rule, the (abb rule), is added. Not only declarations but also abbreviations are allowed in contexts.

10

The use of ? ` B =ab B0 in the conversion rule really has an e ect, since =ab is now a
real extension of =r and ? may contain abbreviations necessary to establish B =ab B0.

Note that the intended scope of hx : Ai
what should be expected since the scope of

in
hx

?:hx : Ai

: AiB: in ?:hx

:

A`ri:C

: D is
`r C :

; D

C is

and the

D. This same.

is

De nition 4.1 (Axioms and rules of the -cube extended with abbreviations; d ranges over
declarations and abbreviations. Recall that r is either or ; in the system where r = , we have = ; if r = , can be or .)
We extend the relation `r to `ra by adding the following abbreviation rule:

(abb rule)

?

`r?a:h(x x::AA:iCB)B`r:aDC

: x

D :=

B]

The (abb rule) says that if C : D can be deduced using an abbreviation d hx : AiB, then
( x:A:C)B will be of type D where d has been unfolded in D.

Remark
From

4.2
the

(Well-Formedness (abb rule) and the

of -redexes for (new application

` a)
rule),

if

?

`

a A : B then both A and B

may contain -redexes.

Remark 4.3 When considering an abbreviation in a term to be equivalent to a redex, the

(abb rule) is quite natural: for instance, deriving a type for ( x: :x)y via abbreviating y to

be x gives the same type as the derivation via abstraction followed by ordinary application

(let ? h : i:hy : i):

(abb rule)

?

`?ra:h(x

:
x:

:ixy)y`r:a

x: x

:=

y]

(abstr) (appl)

?:hx :

i

`??r`a`rxraa:(

x: x:

::xx):y

:?x:`x:ra:=(

x:
y]

:

):

? `ra y :

Let us now give an example which shows why abbreviations are useful:

Example 4.4 h : i:hy : i 6`r ( : :( x: :x)y) : . We need y : to be able to type
( x: :x)y. Looking carefully however, we nd that ( : :( x: :x)y) is abbreviating by . So here is how the above derivation can be obtained using abbreviations (we present a short-cut and do not mention all the steps, nor the names of the rules):

h h h h h h h

: : : : : : :

i:hy : i:hy : i:hy : i:hy : i:hy : i:hy : i:hy :

i:h : i

i:h : i

i:h : i

i:h : i

i:h : i

i i

``rraa

( (

`````rrrrraaaaa

y y (

x: :x : : =ab : x: :x)y

x:
:

: :( x: :x)y) :

: :( x: :x)y) :

:

:=

]

Remark 4.5 In BKN 96], we introduced a notion of generalised de nitions which, like abbre-
viations, bind a name to a complex expression. In BKN 96], a generalisation of -reduction was inspired by a special notation (see KN 95a]). With that generalisation of reduction (which may contract some redex r before other redexes upon which this r depends have been

11

contracted), de nitions had to be nested to mirror this generalised reduction. Such nesting

is unnecessary for the reductions we are using in the present paper.

We now study ordinary (non-nested) de nitions combined with -reduction. We note that

any abbreviation in the sense of the present paper is also a de nition in the sense of BKN 96]

when the notation is changed. Furthermore any type derivation with abbreviations in this

paper (not involving -reduction) is also a type derivation with de nitions in BKN 96]. That

iIs,tirfa?ns`lataesAte:rBmsthtoenthIe(?n)ot`aetiIo(nAo)f:

I(B) where
KN 95a].

`e

is the type derivation of

BKN 96] and

Now, we go through the usual properties of the -cube showing that they hold for `ra.

Lemma
Let ? be

4.6 (Free variable Lemma
a legal context such that ?

for
`ra

B`ra: )C.

Then

the

following

holds:

1. If d and d0 are two di erent elements of ?-decl ?-abb, then var(d) 6 var(d0).

2. F V (B); F V (C) dom(?).

3. If ? ?1:d:?2 then F V (d) dom(?1).
Proof: All by induction on the derivation of ? `ra B : C.

2

ILfe?mPimrsolaeogf4a:.l7,Ifth(?Sentaisr?tle`Lgreaaml tmh:ea2nfoafronrd`sr8oad)m2e derivation of ? `ra B : C.

?te?rm`sraBd;]C. :

?

`ra

B

:

C;

now

use

induction

on

the
2

Lemma 4.8
Let ? and

(Transitivity Lemma be legal contexts such

ftohrat`?ra`)

.

1. If `ra A =ab B then ? `ra A =ab B. 2. If `ra A : B then ? `ra A : B. Proof:

1.

For all d 2
occurrence of
proving ? `ra

, ? `ra var(d)
var(d) in A by

a=ba(bd)a, bt(hde)n.

If A0
? `ra

var(d) =ab ab(d) on the particular

results from A by replacing one free A =ab A0 by repeating the process of occurrence of var(d) in A.

2. Induction on the derivation `ra A : B, using 1 in the case of the conversion rule. 2

Note in the following lemmas how de nitions behave well in thinning and substitution.

Lemma 4.9 (Thinning Lemma for `ra)

1. If ?1:?2 `ra A =ab B, ?1: :?2 is a legal context, then ?1: :?2 `ra A =ab B.

2. If ? and are legal contexts such that ? 0 and if ? `ra A : B, then `ra A : B.

Proof: 1. is by induction on the derivation ?1:?2 `ra A =ab B. 2. is as follows:

If ?:
this by

`ra A : B, ?
induction on

`ra
the

C : S, x is fresh, then also ?:hx : derivation ?: `ra A : B using 1.

Ci: `ra A : B.
for conversion.

We

show

12

If ?:
show

`ra A : B, ? `ra C : D : S, x is
this by induction on the derivation

fresh, then also
?: `ra A : B.

?:hx

:

DiC:

`ra A : B. We

Ii?nf:dh?xu:ch:txAio:in:Aoin`: rtah`eBr1dae=rBiavba:BtCio2,nis??e:q`huxraiv:aDAlein::tAto,`t?rha:eBn `?:r:aChxB(1:fo=AraibcDoB:n2v)e.r`sriaonB,

:C
use

is 1.;

shown by note that
2

Lemma 4.10 (Substitution Let d = hx : CiD, d = x

Lemma for `ra)
:= D], Ad = A x

:=

D]

and

Bd

=

B

x

:=

D].

1. If ?:d: `ra A =ab B, A and B are ?:d: -legal, then ?: d `ra Ad =ab Bd.

2. If B is a ?:d-legal term, then ?:d `ra B =ab Bd.

3. If ?:d: `ra A : B, then ?: d `ra Ad : Bd.

4. If ?:hx : Ci: `ra A : B and ? `ra D : C, then ?: d `ra Ad : Bd.

Proof: 1. Induction on the generation
Induction on the derivation rules, using 1.,

of =ab. 2. Induction on 2. and thinning. 4. Idem.

the

structure

of

B.

3.
2

Lemma 4.11 (Generation Lemma for `ra)

1. If ? `ra S : C then S and ? `ra C =ab 2, furthermore if C 6 2 then ? `ra C :
S0 for some sort S0.

2. If ? `ra x : A then for some d 2 ?, x var(d), ? `ra A =ab type(d) and ? `ra A : S
for some sort S.

3.

If ?

`?ra`rax:Ax::AD:B=a:bCCthaennd

for if

some D
x:A:D 6

and sort
C then

S: ?:hx ? `ra C

: Ai `ra B : D, ? `ra
: S0 for some sort S0.

x:A:D : S,

4.

If ? `ra
(S1; S2) is

x:A:B :
a rule,

C then
? `ra C

for =ab

sSo2maensdoirftsSS2 16 ;

S2: ? `ra
C then ?

`Ara:CS1:,S?f:ohxr

: Ai
some

`ra B :
sort S.

S2,

5.

If ?

`?ra`rTa

Fa =ab

: C, F C and

6
if

T x6:A:CB,ththeenn?fo`rrasoCme:

D; E: S for

? `ra a
some S,

: D, ? `ra
where T

F (

: x:D:E, x:D:E)a if

r = and T E x := a] if r = .

6. If ? `ra ( x:A:D)B : C, then ?:hx : AiB `ra D : C

Proof: 1., 2., 3., 4. and 5. follow by induction on the derivations (use Thinning). As to 6.,
an easy induction on the derivation rules shows that one of the following holds:

?:hx : AiB `ra D : E; ? `ra E x := B] =ab C and E x := B] 6 C ) 9S:? `ra C : S.

? if

`ra B
r=

:

F , ? `ra
and T

x:A:D : y:F :G, ? `ra C
G y := B] if r = , then

?=a`braT

and
C:S

if T
for

6 C where T
some sort S.

( y:F :G)B

In both cases use thinning and conversion; in the second case use also 3.

2

Now, recall that correctness of types fails for ` but holds for ` . Here we show it for `ra.

13

Lemma 4.12 (Correctness

IPfr?oo`fr:a

A:
By

B then B
induction

on

(and
2 or

hence
? `ra

well-formedness) of
B : S for some sort

Types
S.

for

`ra)

the derivation rules. The interesting cases are:

Abbreviation:
C 2 or 9S; Lemma ? `ra

If ?
?:hx
Cx

:`AraiB(
:= B]

x`:Ara:DC)B: S:.

C x := If C

: S x := B] S.

B] 2

where
then C

?:hx : AiB
x := B]

`ra D : 2; else,

C,
by

then by IH, Substitution

Application: then by IH,
?:hx : Aia `

If
9S;
a

?` ?`
B:S

a F a : ( x:A:B)a where ? `

a x:A:B :
and by the

S. By Generation
(abb rule) ? ` a

(?:ahxx:FA::BA: )ia`x::AS:BaxB:a=n: dSa].?B`Sy .Tahiann:iAn2g,

From correctness of types for `ra, we can establish its subject reduction.

TheIPforr?oeo`mfr:a4WA.1e:3Bp(roSavunebdjbeAycts!!RimerduAultca0tnitoheneonufso?rin``drruaacAtai0no:ndB!o!.nrt)he derivation rules:

1.

If ? `ra A : B and ?0
abbreviations of ? by

results from contracting one of the terms
a one step r-reduction, then ?0 `ra A : B

in

the

declarations

and

2. If ? `ra A : B and A !r A0 then ? `ra A0 : B

We will only treat the case r = . If the derivation rule is (axiom): easy. If it is (start

rule): we consider the case d hx : AiB, A ! A0. The other cases are similar or easy.

We have:
? ` a A0
conversion

?:hx
: S.
?:hx

: AiB ` a x
By conversion

: ?

A
`

: A0iB ` a x : A.

where ? a B : A0.

hx : AiB, i.e. ? ` Hence ?:hx : A0iB `

a B : A : S. By IH, a x : A0 and again by

If the derivation rule is (weak), (formation), (conversion) or (abstraction): use IH (and

conversion for abstraction). Now we treat the rest:

(abbreviation): ? ` a ( x:A:D)B : C x := B] where ?:hx : AiB ` a D : C.

Now ?0 `
( x:A0:D)B C x := B0]
by Lemma

a4:an.C1d(2x,bxya::A=pI:pHDBli)ea]Bdnbdyt:otIChHteh.xe(Faj:ub=urbdtghrBeeumr]l,eme)?nowrte`e,?g:ihfexatB?(: !A`x:iAB:DaB`(0)0Bxt:haA:e:nDDC)?Bx: `C0:=:,CawBexC]

and
x := := B
get:

? B 0]. C

`a
] =ab Now
2

or by

9S;
the

?:hx : AiB ` a C :
Substitution Lemma

S. If
?`

? ` a ( x:A:D)B0 : C x := B].

C
a

C

2 then x := B]

C :

x S

:= B] x :=

B

]

C

C x := B0]. Else, S, so by conversion

For the Lemma,

last possibility,
?:hx : AiB `

(
a

x:A:D)B !
D : C leads

to

Dx
?`

:=
a

B], we D x :=

remark that
B] : C x :=

by
B].

the

Substitution

(cb?aoe0cpn`apvuleisrcesaaitboFiyonanI?):H:(`??x``:Aa :FBaaa)F0aF:aaa(0n::d(x(:?Axx:`:B:AA:):BaBa.))aFa00w,ahb:ey(reLex?m:A`m:Ba)aa4.Fb1y2:

x:A:B
IH, and
9S; ? `

and ?
?`
a(

` a a : A. Then
a F a0 : ( x:A:B)a x:A:B)a : S, so by

Now the crucial case: F

( D

xy:A:=:Ba)]a:

so ((

by Generation
x:A:B)a) y :=

?(:hyy:C:

:D),
Cia

a], but by

Fa
`
BC

! D y := a]. Then

a((Dx::A(:Bx:)Aa:)By)a:=, nao]w

by (

?Sxu:A`b:sBtit)auat(.ioyn:C?:D`)a2a:

14

The proof of strong normalisation (SN) is based on SN of the -cube extended with abbre-

viations as in
!r.

BKN 96].

SN!r(A) denotes that A

is strongly normalising with respect to

Theorem 4.14 (Strong Normalisation for the -cube with respect to `

I?``fee`Aw(PeshierAsieocaho:BfB`c:KanaB(N-aylbbe9esgR6taar]eladmftcaoetparritrnmektgdhe4tfth.ro5leoe,nm`n`gSttaNhh)aye.!idbsu(iaAte)ssr.tueabnnstdenat roodtfapt`iroeonoo)ff.

BKN 96] Now, SN (similar to

in that
for ` a
that of

a and ! ) if ? ` a A :
follows from Geu 95]) of

B then
that of SN for
2

SN of ` a is a consequence of that of ` a. First we change -redexes into -redexes.3

De nition 4.15

For all pseudo-expressions A we de ne Ae to be the term A where in all -redexes the
-symbol has been changed into a -symbol, creating a -redex instead.

For a context ? d1: :dn we de ne ?e to be df1: :dfn, where hxg: Ai hx : Aei and hx g: AiB hx : AeiBe.

Lemma 4.16 If ? ` Proof: Induction

a
on

A : B then ?e `
the derivation

a Ae :
rules

Be.
of `

rule) If

are
?`

trivial since they are also rules in
a F a : ( x:A:B)a results from ?

` `

a.
a

F

a. :

All rules except
x:A:B and ? `

the (new application a a : A. Then by IH

?e ` a Fe : As ?e `
rule) for `

axa:,AFee?e:B:e`axan:Ad(e:B?exe:,A`ew:Beae)aeaael:s:AoSe,,gesstoo

by application of
?e:hx : Aei ` a Be :
by conversion ?e

`
S
`

a, ?e ` a Feae : Be x := ae].
and hence by thinning and
a Feae : ( x:Ae:Be)ae.

the

(abb

It remains to be shown that Feae Ffa, i.e., F is not a -term. Suppose towards a contra-

diction that F is a -term, then by generation on ? ` a F : x:A:B, ? ` a x:A:B =ab S

for some sort S. This is clearly a contradiction.

2

Theorem 4.17 (Strong Normalisation for the If A is a ` a-legal term then SN! (A).

-cube with respect to `

a and !

)

Proof: If A is `
orem 4.14). Due to

a-legal then Ae is
Subject Reduction

`
of

`a-lae,ganloby

Lemma -redexes

4.16 can

and hence be created

SN! in the

(Ae) (The-
course of

! -reduction of Ae, therefore SN! (Ae) implies SN! (A).

2

See KN 95b, BKN 96] for other properties of the -cube with -reduction or abbreviations.

5 Conclusion
In type theory, abstraction is done via both and and one writes either x:A:B or x:A:B. Reduction, however, is usually restricted to -redexes. Hence, one evaluates ( x:A:B)C to B x := C], but usually one does not allow ( x:A:B)C as a term which can be evaluated to
3Note that in general this requires the level of the type system in the cube (i.e. abstractions that are allowed) to be raised.

15

B x := C]. An exception to this is the AUTOMATH notation where the distinction between

and is absent and one writes x : A]B to express either x:A:B or x:A:B. In all type

systems however (including AUTOMATH and the system of this paper), there is a distinction

between and . The various accounts di er in how large such a distinction is.

We believe that and can be treated similarly to a great extent, by the incorporation of

-reduction. As we have seen, applications of type systems use -reduction. AUTOMATH

did introduce -reduction, but its formal properties were only established for the rst time

in KN 95b] and later the problems were reconsidered in PM 97].

In this paper, we made behave more like an abstraction operator and gave a -

abstraction the right to be applied to another term. We did not however allow a -abstraction

to be typed by another abstraction. Otherwise, one will need more abstraction operators than

and and this naturally leads to an in nite level of abstraction operators as discussed in

Subsection 1.3. Our choice has been to express the type of a -term as a simple sort given by

the formation rule and to in context ? by typing C

tiynpecoante-xrted?e:xhxus:iAngiBab. bOreuvriaatdiodnitsi.onToofdaobtbhrise,vwiaetitoynpse(dw(hicxh:A:dCi

)B er

in this paper from the existing notions of de nitions in the literature), is simple and worth

studying. Furthermore, this addition enabled us to solve the problems of the -cube that

were left open in KN 95b].

There are many arguments why -reduction and abbreviations must be considered and why a system combining both, without losing any of the nice properties of the -cube, is certainly worth considering. Moreover, we nd it intriguing that so far in the literature, abbreviations have been added for reasons of e ciency of implementation and not because they solve theoretical problems. In this paper, we have shown that abbreviations solve the problems of the -cube extended with -reduction. In BKN 96], we have shown that de nitions solve the problem of subject reduction in the -cube extended with a notion of generalised reduction. The reason why abbreviations solve these problems is that they keep information in the context about the de ned values of some variables, thus preventing that this information gets lost in a reduction process.
Hence, our paper contributes to other work on de nitions not only in that it o ers a simple and attractive account of de nitions or abbreviations which keeps all the original properties of the -cube, but also because it shows that abbreviations are theoretically important and should hence be introduced in the -cube. Figure 1 on page 17 summarizes our results in this paper where we use the following notational conventions: CR, SN, SR and TC stand for Church Rosser, strong normalisation, subject reduction and type correctness respectively; WF stands for well-formedness of the type of an expression, abb-cube is the -cube extended with abbreviations for = or .

A question may now occur to the reader: \If our paper is concerned with abstractions via

and , then why have another kind of abstraction in the contexts? Why write hx : Ai and

hx : AiB to describe the binding rather than use and ?". We believe strongly that the

binding operators and should be used in the contexts as well and indeed in many of our

work we do so KN 95b, BKN 96]. In this paper however, we refrain from this option because

we do not want to give the false impression that a binding in the context using either or

has anything to do with solving the problems of -reduction that we are tackling. If the

reader however is interested x:A, for declarations and (

in using
x:A:?)B

's or

and 's in the
( x:A:?)B for

context and hence in writing x:A or abbreviations, then he/she may like

16

-cube (CR, SN, SR, TC, WF)

???? @@@@R

-cube (CR, SN)

abb-cube (CR, SN, SR, TC, WF)

@@@@R ????
abb-cube (CR, SN, SR,TC,WF)

Figure 1: Properties of the -cube with various extensions

to know that with such an account and the following new version of the (abb rule):

( -abb rule)

?

?:(
`(

x:A:?)B ` C : D
x:A:C)B : D x := B]

where

2f ; g

one can show the following lemma, the proof of which is by a simple induction on the derivation rules:

Lemma 5.1 ( -exchanging) The following holds:

1. ?: x:A: ` a C : D () ?: x:A: ` a C : D

2. ?:( x:A:?)B: ` a C : D () ?:( x:A:?)B: ` a C : D

Note that, although and can be freely interchanged in contexts, it remains desirable to

keep a distinction between them as two abstractors in our terms. This is what we do in this

article. In fact, we don't distinguish them in the context (by writing hx : Ai instead of either

x:A
from Note

or
hx

:

xi:A`).xW: e

also that `

do however distinguish them on the right hand side
using the formation rule (2; 2), we get: ` x: :x : x:
x: :x : which shows that a -abstraction has a di

of `. For example, : and ` x: : : 2.
erent type than a

-abstraction.

6 Acknowledgements
The authors are grateful to an anonymous referee for the useful comments and suggestions. Kamareddine is grateful to Assaf Kfoury and Joe Wells for their hospitality while preparing this article. Moreover, she is grateful to the Department of Mathematics and Computing Science, Eindhoven University of Technology, for their nancial support and hospitality from October 1991 to September 1992, and during various regular visits since then. She is, furthermore, grateful to the Dutch organisation of research (NWO), to the British Council and to the Action for Basic Research ESPRIT Project \Types for Proofs and Programs" for their nancial support. Bloo has been supported by the Netherlands Computer Science Research Foundation (SION) with nancial support from the Netherlands Organisation for Scienti c Research (NWO) and is grateful to the Department of Computing Science, Glasgow University, for their nancial support and hospitality during work on this subject.

17

References
AFMOW95] Z. M. Ariola, M. Felleisen, J. Maraist, M. Odersky, and P. Wadler, A call-by-need lambda calculus, In Conf. Rec. 22nd Ann. ACM Symp. Principles Programming Languages, 1995.
Ba 84] H. Barendregt, Lambda Calculus: its Syntax and Semantics, North-Holland, 1984. Ba 92] H. Barendregt, Lambda calculi with types, Handbook of Logic in Computer Science, II, eds.
S. Abramsky, D.M. Gabbay, and T.S.E. Maibaum, Oxford University Press, 118-414, 1992. BLR96] Z. Benaissa, P. Lescanne, and K. Rose, Modeling Sharing and Recursion for Weak Reduc-
tion Strategies Using Explicit Substitution, PLILP96, Lecture Notes in Computer Science 1140, Springer Verlag, 1996. BKN 96] R. Bloo, F. Kamareddine, and R.P. Nederpelt, The Barendregt Cube with De nitions and Generalised Reduction, Information and Computation 126(2), 123-143, 1996. Con 86] R. Constable et al., Implementing Mathematics with the NUPRL Development System, Prentice-Hall, 1986. Dow 91] G. Dowek, et al. The Coq proof assistant version 5.6, users guide, rapport de recherche 134, INRIA, 1991. Geu 95] H. Geuvers, A short and exible proof of strong normalization for the Calculus of Constructions, in Types for Proofs and Programs, eds. P. Dybjer, B. Nordstrom, and J. Smith, International Workshop TYPES '94, LNCS 996, 14-38, Springer, 1995. LP 92] Z. Luo, and R. Pollack,, LEGO proof development system: User's manual, Technical report ECS-LFCS-92-211, LFCS, University of Edinburgh, 1992. KN 95a] F. Kamareddine, and R.P. Nederpelt, Re ning reduction in the -calculus, Functional Programming 5 (4), 637-651, 1995. KN 95b] F. Kamareddine, and R.P. Nederpelt, Canonical Typing and -Conversion in the Barendregt Cube, Functional Programming 6 (2), 245-267, 1996. NGV 94] R.P. Nederpelt, J.H. Geuvers, and R.C. de Vrijer, eds., Selected Papers on AUTOMATH , North-Holland, 1994. PJ 96] S. Peyton Jones, Compilation by transformation: a report from the trenches, in European Symposium on programming (ESOP'96), Springer Verlag LNCS 1058, 1996. PM 97] S. Peyton Jones and E. Meijer, Henk: a typed intermediate language, Types In Compilations Workshop, 1997. SA 95] Z. Shao and A.W. Appel, A type-based compiler for standard ML, in SIGPLAN Symposium on Programming Language Design and Implementation (PLDI'95), La Jolla, ACM, 1995. SP 93] P. Severi, and E. Poll, Pure Type Systems with De nitions, Computing Science Note 93/24, Department of Mathematics and Computing Science, Eindhoven University of Technology, 1993. TMCSHL 96] D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper and P. Lee, TIL: A TypeDirected Optimizing Compiler for ML, in SIGPLAN Symposium on Programming Language Design and Implementation (PLDI'96), Philadelphia, ACM, 1996.
18

