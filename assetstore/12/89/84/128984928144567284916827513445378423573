Matching modulo superdevelopments
Application to second-order matching
Germain Faure
Ws Rho’06
1/46
Higher-order matching
I Usually defined as the following problem:
Typed λ-terms
%%LL
LLL
LLL
LLL
L
yyrrr
rrr
rrr
rrr
A B ∃σ? Aσ =β(η) B
2/46
Higher-order matching
I Usually defined as the following problem:
Typed λ-terms
%%LL
LLL
LLL
LLL
L
yyrrr
rrr
rrr
rrr
A B ∃σ? Aσ =β(η) B
2/46
Higher-order matching
I Usually defined as the following problem:
Typed λ-terms
%%LL
LLL
LLL
LLL
L
yyrrr
rrr
rrr
rrr
A B ∃σ? Aσ =β(η) B
3/46
Higher-order matching (revised) [?]
I Another approach:
Untyped λ-terms
&&MM
MMM
MMM
MMM
M
xxqqq
qqq
qqq
qqq
A B ∃σ? Aσ =⇒βf B
where =⇒βf is a one-step reduction for an appropriate parallel
reduction that always terminates
reduction that gives an approximation of β-normal form
4/46
Higher-order matching (revised) [?]
I Another approach:
Untyped λ-terms
&&MM
MMM
MMM
MMM
M
xxqqq
qqq
qqq
qqq
A B ∃σ? Aσ =⇒βf B
where =⇒βf is a one-step reduction for an appropriate parallel
reduction that always terminates
reduction that gives an approximation of β-normal form
4/46
Higher-order matching (revised) [?]
I An other approach:
Unyped λ-terms
&&MM
MMM
MMM
MMM
M
xxqqq
qqq
qqq
qqq
A B ∃σ? Aσ =⇒βf B
where =⇒βf is a one-step reduction for an appropriate parallel
reduction:
I that always terminates
I that gives an approximation of β-normal form
5/46
Higher-order matching (revised) [?]
I An other approach:
Unyped λ-terms
&&MM
MMM
MMM
MMM
M
xxqqq
qqq
qqq
qqq
A B ∃σ? Aσ =⇒βf B
where =⇒βf is a one-step reduction for an appropriate parallel
reduction:
I that always terminates
I that gives an approximation of β-normal form
5/46
Higher-order matching (revised) [?]
I An other approach:
Unyped λ-terms
&&MM
MMM
MMM
MMM
M
xxqqq
qqq
qqq
qqq
A B ∃σ? Aσ =⇒βf B
where =⇒βf is a one-step reduction for an appropriate parallel
reduction:
I that always terminates
I that gives an approximation of β-normal form
5/46
Motivations
I First introduced for automatic program transformation
I It may be difficult to find a suitable type system s.t.
equivalence on typed terms is decidable
å Example: Pattern-matching in the ρ-calculus
6/46
Motivations
I First introduced for automatic program transformation
I It may be difficult to find a suitable type system s.t.
equivalence on typed terms is decidable
å Example: Pattern-matching in the ρ-calculus
6/46
Motivations
I First introduced for automatic program transformation
I It may be difficult to find a suitable type system s.t.
equivalence on typed terms is decidable
å Example: Pattern-matching in the ρ-calculus
6/46
Higher-order matching in the ρ-calculus
1. The ρ-calculus
I was introduced [?] to make all the ingredients of rewriting such
as rule applications and results explicit
I is in fine an extension of the λ-calculus with built-in
pattern-matching and term collections
2. Higher-order matching in the ρ-calculus for
I Transformations of programs with built-in pattern-matching
(not only purely functional programs)
I Proof theory that handles rich proof-terms in the generalized
deduction modulo [?]
7/46
Higher-order matching in the ρ-calculus
1. The ρ-calculus
I was introduced [?] to make all the ingredients of rewriting such
as rule applications and results explicit
I is in fine an extension of the λ-calculus with built-in
pattern-matching and term collections
2. Higher-order matching in the ρ-calculus for
I Transformations of programs with built-in pattern-matching
(not only purely functional programs)
I Proof theory that handles rich proof-terms in the generalized
deduction modulo [?]
7/46
Higher-order matching in the ρ-calculus
1. The ρ-calculus
I was introduced [?] to make all the ingredients of rewriting such
as rule applications and results explicit
I is in fine an extension of the λ-calculus with built-in
pattern-matching and term collections
2. Higher-order matching in the ρ-calculus for
I Transformations of programs with built-in pattern-matching
(not only purely functional programs)
I Proof theory that handles rich proof-terms in the generalized
deduction modulo [?]
7/46
Higher-order matching in the ρ-calculus
1. The ρ-calculus
I was introduced [?] to make all the ingredients of rewriting such
as rule applications and results explicit
I is in fine an extension of the λ-calculus with built-in
pattern-matching and term collections
2. Higher-order matching in the ρ-calculus for
I Transformations of programs with built-in pattern-matching
(not only purely functional programs)
I Proof theory that handles rich proof-terms in the generalized
deduction modulo [?]
7/46
Higher-order matching in the ρ-calculus
1. The ρ-calculus
I was introduced [?] to make all the ingredients of rewriting such
as rule applications and results explicit
I is in fine an extension of the λ-calculus with built-in
pattern-matching and term collections
2. Higher-order matching in the ρ-calculus for
I Transformations of programs with built-in pattern-matching
(not only purely functional programs)
I Proof theory that handles rich proof-terms in the generalized
deduction modulo [?]
7/46
Higher-order matching in the ρ-calculus
1. The ρ-calculus
I was introduced [?] to make all the ingredients of rewriting such
as rule applications and results explicit
I is in fine an extension of the λ-calculus with built-in
pattern-matching and term collections
2. Higher-order matching in the ρ-calculus for
I Transformations of programs with built-in pattern-matching
(not only purely functional programs)
I Proof theory that handles rich proof-terms in the generalized
deduction modulo [?]
7/46
Some questions - Contributions
1. What is this appropriate parallel reduction?
I “It may be a little difficult to understand” [?]
I Why is it a relevant approximation of β-normal forms?
2. What is the link with other h.o. matching algorithms?
I Second-order matching
I H.o. matching of patterns a` la Miller
å
Intuition
Deeper understanding
8/46
Some questions - Contributions
1. What is this appropriate parallel reduction?
I “It may be a little difficult to understand” [?]
I Why is it a relevant approximation of β-normal forms?
2. What is the link with other h.o. matching algorithms?
I Second-order matching
I H.o. matching of patterns a` la Miller
å
Intuition
Deeper understanding
8/46
Some questions - Contributions
1. What is this appropriate parallel reduction?
I “It may be a little difficult to understand” [?]
I Why is it a relevant approximation of β-normal forms?
2. What is the link with other h.o. matching algorithms?
I Second-order matching
I H.o. matching of patterns a` la Miller
å
Intuition
Deeper understanding
8/46
Some questions - Contributions
1. What is this appropriate parallel reduction?
I “It may be a little difficult to understand” [?]
I Why is it a relevant approximation of β-normal forms?
2. What is the link with other h.o. matching algorithms?
I Second-order matching
I H.o. matching of patterns a` la Miller
å
Intuition
Deeper understanding
8/46
Some questions - Contributions
1. What is this appropriate parallel reduction?
I “It may be a little difficult to understand” [?]
I Why is it a relevant approximation of β-normal forms?
2. What is the link with other h.o. matching algorithms?
I Second-order matching
I H.o. matching of patterns a` la Miller
å
Intuition
Deeper understanding
8/46
Some questions - Contributions
1. What is this appropriate parallel reduction?
I “It may be a little difficult to understand” [?]
I Why is it a relevant approximation of β-normal forms?
2. What is the link with other h.o. matching algorithms?
I Second-order matching
I H.o. matching of patterns a` la Miller
å
Intuition
Deeper understanding
8/46
Some questions - Contributions
1. What is this appropriate parallel reduction?
I “It may be a little difficult to understand” [?]
I Why is it a relevant approximation of β-normal forms?
2. What is the link with other h.o. matching algorithms?
I Second-order matching
I H.o. matching of patterns a` la Miller
å
Intuition
Deeper understanding
8/46
Road-map
1. Superdevelopments. Strong parallel β-reduction.
2. Matching modulo SD. Links with other h.o. matching
algorithms.
3. Algorithm for matching modulo SD.
4. Second-order matching.
5. The η-equivalence.
9/46
The λ-calculus
I Syntax
A,B,C ::= x variable
| X matching variable
| c constant
| λx .A abstraction
| AB application
We note f (A1, . . . ,An) for (. . . (fA1) )An)
I Operational semantics
(λx .A)B →β A[x := B]
10/46
The λ-calculus
I Syntax
A,B,C ::= x variable
| X matching variable
| c constant
| λx .A abstraction
| AB application
We note f (A1, . . . ,An) for (. . . (fA1) )An)
I Operational semantics
(λx .A)B →β A[x := B]
10/46
The λ-calculus
I Syntax
A,B,C ::= x variable
| X matching variable
| c constant
| λx .A abstraction
| AB application
We note f (A1, . . . ,An) for (. . . (fA1) )An)
I Operational semantics
(λx .A)B →β A[x := B]
10/46
Creation of redexes in the λ-calculus (I)
@
@
   
 
??
??
?
λ
λ
→ @
λ
((λx .λy .x) a) b → (λy .a) b
11/46
Creation of redexes in the λ-calculus (I)
@
@
   
 
??
??
?
λ
λ
→ @
   
 
::
::
λ
((λx .λy .x) a) b → (λy .a) b
12/46
Creation of redexes in the λ-calculus (I)
@


::
::
@
   
 
??
??
?
λ
λ
→ @
   
 
::
::
λ
((λx .λy .x) a) b → (λy .a) b
13/46
Creation of to create redexes in the
λ-calculus (I)
@


::
::
@
   
 
??
??
?
λ
λ
→ @
   
 
::
::
λ
((λx .λy .x) a) b → (λy .a) b
14/46
Creation of redexes in the λ-calculus (II)
@


::
::
@
   
  ??
??
λ XX λ
→ @
   
 
::
::
λ
((λx .x) (λy .a)) b → (λy .a) b
15/46
Creation of redexes in the λ-calculus (III)
@
KKK
KKK
K
rrr
rrr
r
λx









77
77
77
77
77
77
77
77
77
7 λ
@
||
|| >>
>>
x
→









44
44
44
44
44
44
44
44
44
4
@
   
 
::
::
λ
(λx .xa) (λy .y) → (λy .y)a
Return
16/46
Remarks
1. What distinguishe (I) and (II) from (III)?
I The reduction of the term in functional position of the green
application creates a redex in the (I) and (II) way
I Whereas in (III) it is the substitution of a λ-abstraction in
functional position that creates a redex
2. In other words
I In (I) and (II) the creation is “upwards”
I Whereas in (III), it is “backwards”
17/46
Remarks
1. What distinguishe (I) and (II) from (III)?
I The reduction of the term in functional position of the green
application creates a redex in the (I) and (II) way
I Whereas in (III) it is the substitution of a λ-abstraction in
functional position that creates a redex
2. In other words
I In (I) and (II) the creation is “upwards”
I Whereas in (III), it is “backwards”
17/46
Remarks
1. What distinguishe (I) and (II) from (III)?
I The reduction of the term in functional position of the green
application creates a redex in the (I) and (II) way
I Whereas in (III) it is the substitution of a λ-abstraction in
functional position that creates a redex
2. In other words
I In (I) and (II) the creation is “upwards”
I Whereas in (III), it is “backwards”
17/46
Remarks
1. What distinguishe (I) and (II) from (III)?
I The reduction of the term in functional position of the green
application creates a redex in the (I) and (II) way
I Whereas in (III) it is the substitution of a λ-abstraction in
functional position that creates a redex
2. In other words
I In (I) and (II) the creation is “upwards”
I Whereas in (III), it is “backwards”
17/46
Remarks
1. What distinguishe (I) and (II) from (III)?
I The reduction of the term in functional position of the green
application creates a redex in the (I) and (II) way
I Whereas in (III) it is the substitution of a λ-abstraction in
functional position that creates a redex
2. In other words
I In (I) and (II) the creation is “upwards”
I Whereas in (III), it is “backwards”
17/46
Remarks
1. What distinguishe (I) and (II) from (III)?
I The reduction of the term in functional position of the green
application creates a redex in the (I) and (II) way
I Whereas in (III) it is the substitution of a λ-abstraction in
functional position that creates a redex
2. In other words
I In (I) and (II) the creation is “upwards”
I Whereas in (III), it is “backwards”
17/46
Defining superdevelopements
Definition [?]
A superdevelopement is a β-rewrite sequence that reduces:
1. the redexes of the term and its residuals (as in developments)
2. the redexes created in (I) or (II) not in (III)
Theorem [?]
All superdevelopments are finite
Examples of superdevelopments
Couter-examples of superdevelopments
Other characterization
18/46
Defining superdevelopements
Definition [?]
A superdevelopement is a β-rewrite sequence that reduces:
1. the redexes of the term and its residuals (as in developments)
2. the redexes created in (I) or (II) not in (III)
Theorem [?]
All superdevelopments are finite
Examples of superdevelopments
Couter-examples of superdevelopments
Other characterization
18/46
Defining superdevelopements
Definition [?]
A superdevelopement is a β-rewrite sequence that reduces:
1. the redexes of the term and its residuals (as in developments)
2. the redexes created in (I) or (II) not in (III)
Theorem [?]
All superdevelopments are finite
Examples of superdevelopments
Couter-examples of superdevelopments
Other characterization
18/46
Defining superdevelopements
Definition [?]
A superdevelopement is a β-rewrite sequence that reduces:
1. the redexes of the term and its residuals (as in developments)
2. the redexes created in (I) or (II) not in (III)
Theorem [?]
All superdevelopments are finite
Examples of superdevelopments
Couter-examples of superdevelopments
Other characterization
18/46
Defining superdevelopements
Definition [?]
A superdevelopement is a β-rewrite sequence that reduces:
1. the redexes of the term and its residuals (as in developments)
2. the redexes created in (I) or (II) not in (III)
Theorem [?]
All superdevelopments are finite
Examples of superdevelopments
Couter-examples of superdevelopments
Other characterization
18/46
Defining superdevelopements
Definition [?]
A superdevelopement is a β-rewrite sequence that reduces:
1. the redexes of the term and its residuals (as in developments)
2. the redexes created in (I) or (II) not in (III)
Theorem [?]
All superdevelopments are finite
Examples of superdevelopments
Couter-examples of superdevelopments
Other characterization
18/46
Superdevelopments
The residuals of the redexes can be reduced as in developments
Example
(λx .f (x , x)) ((λy .y) a)
→β f ((λy .y) a, (λy .y) a)
→β f (a, (λy .y) a)
→β f (a, a)
19/46
Superdevelopements
The following β-reduction is a superdevelopement:
Example
((λx .λy .f (x , y))a)b
→β (λy .f (a, y))b
→β f (a, b)
20/46
Superdevelopements
The following β-reduction is a superdevelopement:
Example
((λx .x)(λy .y))a
→β (λy .y)a
→β a
21/46
Superdevelopments
The following β-reductions are not superdeveloppements:
Example
(λx .xa)(λy .y)
→β (λy .y)a
→β a
Example
(λx .xx)(λx .xx)
→β (λx .xx)(λx .xx)
→β (λx .xx)(λx .xx)
→β . . .
22/46
Superdevelopments
The following β-reductions are not superdeveloppements:
Example
(λx .xa)(λy .y)
→β (λy .y)a
→β a
Example
(λx .xx)(λx .xx)
→β (λx .xx)(λx .xx)
→β (λx .xx)(λx .xx)
→β . . .
22/46
The parallel β-reduction [Tait Martin-Lo¨f]
(Red-β)
λx .A1 =⇒β λx .A2 B1 =⇒β B2
(λx .A1)B1 =⇒β A2[x := B2]
(Red-λ)
A1 =⇒β A2
λx .A1 =⇒β λx .A2
(Red-@)
A1 =⇒β A2 B1 =⇒β B2
A1B1 =⇒β A2B2
(Red-ℵ) ℵ =⇒β ℵ
23/46
The parallel β-reduction [Tait Martin-Lo¨f]
(Red-β)
λx .A1 =⇒β λx .A2 B1 =⇒β B2
(λx .A1)B1 =⇒β A2[x := B2]
(Red-λ)
A1 =⇒β A2
λx .A1 =⇒β λx .A2
(Red-@)
A1 =⇒β A2 B1 =⇒β B2
A1B1 =⇒β A2B2
(Red-ℵ) ℵ =⇒β ℵ
23/46
The parallel β-reduction [Tait Martin-Lo¨f]
(Red-β)
λx .A1 =⇒β λx .A2 B1 =⇒β B2
(λx .A1)B1 =⇒β A2[x := B2]
(Red-λ)
A1 =⇒β A2
λx .A1 =⇒β λx .A2
(Red-@)
A1 =⇒β A2 B1 =⇒β B2
A1B1 =⇒β A2B2
(Red-ℵ) ℵ =⇒β ℵ
23/46
The strong parallel β-reduction [?]
(Red-βf )
A1 =⇒βf λx .A2 B1 =⇒βf B2
A1B1 =⇒βf A2[x := B2]
(Red-λ)
A1 =⇒βf A2
λx .A1 =⇒βf λx .A2
(Red-@)
A1 =⇒βf A2 B1 =⇒βf B2
A1B1 =⇒βf A2B2
(Red-ℵ) ℵ =⇒βf ℵ
24/46
The strong parallel β-reduction [?]
(Red-βf )
A1 =⇒βf λx .A2 B1 =⇒βf B2
A1B1 =⇒βf A2[x := B2]
(Red-λ)
A1 =⇒βf A2
λx .A1 =⇒βf λx .A2
(Red-@)
A1 =⇒βf A2 B1 =⇒βf B2
A1B1 =⇒βf A2B2
(Red-ℵ) ℵ =⇒βf ℵ
24/46
Equivalence between superdevelopments
Theorem [?]
There exists a superdevelopment A 7→7 β B
iff
A =⇒βf B
25/46
Matching in the pure λ-calculus modulo
SD
Definition [βsd -matching equation]
a pair of (untyped) terms denoted A 6βsd B s.t.
I B is normal
I does not contain matching variables
Definition [βsd -matching system]
a multiset of matching equations
26/46
Matching in the pure λ-calculus modulo
SD
Definition [βsd -matching equation]
a pair of (untyped) terms denoted A 6βsd B s.t.
I B is normal
I does not contain matching variables
Definition [βsd -matching system]
a multiset of matching equations
26/46
Matching in the pure λ-calculus modulo
SD
Definition [βsd -matching equation]
a pair of (untyped) terms denoted A 6βsd B s.t.
I B is normal
I does not contain matching variables
Definition [βsd -matching system]
a multiset of matching equations
26/46
Matching in the pure λ-calculus modulo
SD
Definition [βsd -matching equation]
a pair of (untyped) terms denoted A 6βsd B s.t.
I B is normal
I does not contain matching variables
Definition [βsd -matching system]
a multiset of matching equations
26/46
Matching in the pure λ-calculus modulo
SD
Definition [βsd -matching equation]
a pair of (untyped) terms denoted A 6βsd B s.t.
I B is normal
I does not contain matching variables
Definition [βsd -matching system]
a multiset of matching equations
26/46
Matching in the pure λ-calculus modulo
SD
Definition [βsd -match for A 6βsd B]
A substitution φ on matching variables such that
Aφ =⇒βf B
A substitution is a match of a system if it matches each equation
27/46
Matching in the pure λ-calculus modulo
SD
Definition [βsd -match for A 6βsd B]
A substitution φ on matching variables such that
Aφ =⇒βf B
A substitution is a match of a system if it matches each equation
27/46
Matching in the pure λ-calculus modulo
SD
Definition [βsd -match for A 6βsd B]
A substitution φ on matching variables such that
Aφ =⇒βf B
A substitution is a match of a system if it matches each equation
27/46
Solved form
Definition
I For a matching equation X 6βsd A: no variables in A
I For a system: each matching variable occurs once
28/46
Matching in the simply typed λ-calculus
modulo β
Definition [β-equation]
a pair of β-normal typed λ-terms denoted Aβ B
I of the same type
I B does not contain matching variables
Definition [β-match for Aβ B]
A substitution φ, that preserves types and such that
Aφ =β B
We can associate to a β-match equation, a βsd -match equation
(erase types)
29/46
Matching in the simply typed λ-calculus
modulo β
Definition [β-equation]
a pair of β-normal typed λ-terms denoted Aβ B
I of the same type
I B does not contain matching variables
Definition [β-match for Aβ B]
A substitution φ, that preserves types and such that
Aφ =β B
We can associate to a β-match equation, a βsd -match equation
(erase types)
29/46
Matching in the simply typed λ-calculus
modulo β
Definition [β-equation]
a pair of β-normal typed λ-terms denoted Aβ B
I of the same type
I B does not contain matching variables
Definition [β-match for Aβ B]
A substitution φ, that preserves types and such that
Aφ =β B
We can associate to a β-match equation, a βsd -match equation
(erase types)
29/46
Matching in the simply typed λ-calculus
modulo β
Definition [β-equation]
a pair of β-normal typed λ-terms denoted Aβ B
I of the same type
I B does not contain matching variables
Definition [β-match for Aβ B]
A substitution φ, that preserves types and such that
Aφ =β B
We can associate to a β-match equation, a βsd -match equation
(erase types)
29/46
Matching in the simply typed λ-calculus
modulo β
Definition [β-equation]
a pair of β-normal typed λ-terms denoted Aβ B
I of the same type
I B does not contain matching variables
Definition [β-match for Aβ B]
A substitution φ, that preserves types and such that
Aφ =β B
We can associate to a β-match equation, a βsd -match equation
(erase types)
29/46
An example
The equation X (ι→ι)→ιY (ι→ι) β aκ→ι→ι(bκ, c ι)
βsd -match β-match
X ← λx .a(b, c) 3 3
X ← ab Y ← c 3 7
X ← λx .a(b, xc) Y ← λy .y 7 3
30/46
An example
The equation X (ι→ι)→ιY (ι→ι) β aκ→ι→ι(bκ, c ι)
βsd -match β-match
X ← λx .a(b, c) 3 3
X ← ab Y ← c 3 7
X ← λx .a(b, xc) Y ← λy .y 7 3
30/46
An example
The equation X (ι→ι)→ιY (ι→ι) β aκ→ι→ι(bκ, c ι)
βsd -match β-match
X ← λx .a(b, c) 3 3
X ← ab Y ← c 3 7
X ← λx .a(b, xc) Y ← λy .y 7 3
30/46
An example
The equation X (ι→ι)→ιY (ι→ι) β aκ→ι→ι(bκ, c ι)
βsd -match β-match
X ← λx .a(b, c) 3 3
X ← ab Y ← c 3 7
X ← λx .a(b, xc) Y ← λy .y 7 3
30/46
SD and second-order matching
Proposition
Let φ be a β-match a second-order β-matching equation. Then it
is also a βsd -match.
Proof In (III) there is a 3rd -order redex
31/46
SD and second-order matching
Proposition
Let φ be a β-match a second-order β-matching equation. Then it
is also a βsd -match.
Proof In (III) there is a 3rd -order redex
31/46
Remarks
I The previous result does not extend to third-order
I There are some second-order β-match equations that have no
solution but such that the corresponding βsd -match equation
do have solutions
å Np-completeness of second-order matching ?
32/46
Remarks
I The previous result does not extend to third-order
I There are some second-order β-match equations that have no
solution but such that the corresponding βsd -match equation
do have solutions
å Np-completeness of second-order matching ?
32/46
Remarks
I The previous result does not extend to third-order
I There are some second-order β-match equations that have no
solution but such that the corresponding βsd -match equation
do have solutions
å Np-completeness of second-order matching ?
32/46
Remarks
I The previous result does not extend to third-order
I There are some second-order β-match equations that have no
solution but such that the corresponding βsd -match equation
do have solutions
å Np-completeness of second-order matching ?
32/46
SD and patterns a` la Miller
The comparison is important: the algorithm of D. Miller does not
use any type information
Proposition
Let P be a pattern. If φ is a β-match of P β B then
it it also a βsd -match.
I Proof: Patterns do not need full β-conversion but only
β0-conversion:
(λx .t)x → t
and this reduction does not create redexes in (III).
33/46
SD and patterns a` la Miller
The comparison is important: the algorithm of D. Miller does not
use any type information
Proposition
Let P be a pattern.
If φ is a β-match of P β B then
it it also a βsd -match.
I Proof: Patterns do not need full β-conversion but only
β0-conversion:
(λx .t)x → t
and this reduction does not create redexes in (III).
33/46
SD and patterns a` la Miller
The comparison is important: the algorithm of D. Miller does not
use any type information
Proposition
Let P be a pattern. If φ is a β-match of P β B then
it it also a βsd -match.
I Proof: Patterns do not need full β-conversion but only
β0-conversion:
(λx .t)x → t
and this reduction does not create redexes in (III).
33/46
SD and patterns a` la Miller
The comparison is important: the algorithm of D. Miller does not
use any type information
Proposition
Let P be a pattern. If φ is a β-match of P β B then
it it also a βsd -match.
I Proof: Patterns do not need full β-conversion but only
β0-conversion:
(λx .t)x → t
and this reduction does not create redexes in (III).
33/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
Aσ =⇒βf B
34/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
Aσ =⇒βf B
34/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
aσ =⇒βf a
34/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
aσ =⇒βf a
34/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd B), S →ℵX X 6βsd B, S{A/X}
if FV(B) = ∅ and X ∈ S
Xσ =⇒βf B
35/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd B), S →ℵX X 6βsd B, S{A/X}
if FV(B) = ∅ and X ∈ S
Xσ =⇒βf B
35/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A 6βsd λx .B), S →λλ (A 6βsd B), S
(λx .A1)σ =⇒βf
λx .B1
36/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A 6βsd λx .B), S →λλ (A 6βsd B), S
(λx .A1)σ =⇒βf λx .B1
36/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A 6βsd λx .B), S →λλ (A 6βsd B), S
(λx .A1)σ =⇒βf λx .B1
36/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A1 6βsd λx .B1), S →λλ (A1 6βsd B1), S
(A1A2 6βsd B1B2), S →@@ (A1 6βsd B1), (A2 6βsd B2), S
A1σ =⇒βf B1 A2σ =⇒βf B2
(A1A2)σ =⇒βf
B1B2
37/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A1 6βsd λx .B1), S →λλ (A1 6βsd B1), S
(A1A2 6βsd B1B2), S →@@ (A1 6βsd B1), (A2 6βsd B2), S
A1σ =⇒βf B1 A2σ =⇒βf B2
(A1A2)σ =⇒βf B1B2
37/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A1 6βsd λx .B1), S →λλ (A1 6βsd B1), S
(A1A2 6βsd B1B2), S →@@ (A1 6βsd B1), (A2 6βsd B2), S
A1σ =⇒βf B1 A2σ =⇒βf B2
(A1A2)σ =⇒βf B1B2
37/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A1 6βsd λx .B1), S →λλ (A1 6βsd B1), S
(A1A2 6βsd B1B2), S →@@ (A1 6βsd B1), (A2 6βsd B2), S
A1σ =⇒βf λx .B1 A2σ =⇒βf B2
(A1A2)σ =⇒βf
B1[x := B2]
x ∈ B1 ?
38/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A1 6βsd λx .B1), S →λλ (A1 6βsd B1), S
(A1A2 6βsd B1B2), S →@@ (A1 6βsd B1), (A2 6βsd B2), S
A1σ =⇒βf λx .B1 A2σ =⇒βf B2
(A1A2)σ =⇒βf B1[x := B2]
x ∈ B1 ?
38/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A1 6βsd λx .B1), S →λλ (A1 6βsd B1), S
(A1A2 6βsd B1B2), S →@@ (A1 6βsd B1), (A2 6βsd B2), S
A1σ =⇒βf λx .B1 A2σ =⇒βf B2
(A1A2)σ =⇒βf B1[x := B2]
x ∈ B1 ?
38/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A1 6βsd λx .B1), S →λλ (A1 6βsd B1), S
(A1A2 6βsd B1B2), S →@@ (A1 6βsd B1), (A2 6βsd B2), S
(A1A2 6βsd B1), S →@pi A1 6βsd λx .B1
if x 6∈ B1
A1σ =⇒βf λx .B1 A2σB2
(A1A2)σ =⇒βf B1
x 6∈ B1
39/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A1 6βsd λx .B1), S →λλ (A1 6βsd B1), S
(A1A2 6βsd B1B2), S →@@ (A1 6βsd B1), (A2 6βsd B2), S
(A1A2 6βsd B1), S →@pi A1 6βsd λx .B1
if x 6∈ B1
A1σ =⇒βf λx .B1 A2σB2
(A1A2)σ =⇒βf B1
x 6∈ B1
39/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A1 6βsd λx .B1), S →λλ (A1 6βsd B1), S
(A1A2 6βsd B1B2), S →@@ (A1 6βsd B1), (A2 6βsd B2), S
(A1A2 6βsd B1), S →@pi A1 6βsd λx .B1 if . . .
(A1A2 6βsd B1[x := B2]), S →@β (A1 6βsd λx .B1), (A2 6βsd B2), S
where C = B1[x := B2]
and x ∈ B1
A1σ =⇒βf λx .B1 A2σ =⇒βf B2
(A1A2)σ =⇒βf
B1[x := B2]
x ∈ B1
40/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A1 6βsd λx .B1), S →λλ (A1 6βsd B1), S
(A1A2 6βsd B1B2), S →@@ (A1 6βsd B1), (A2 6βsd B2), S
(A1A2 6βsd B1), S →@pi A1 6βsd λx .B1 if . . .
(A1A2 6βsd B1[x := B2]), S →@β (A1 6βsd λx .B1), (A2 6βsd B2), S
where C = B1[x := B2]
and x ∈ B1
A1σ =⇒βf λx .B1 A2σ =⇒βf B2
(A1A2)σ =⇒βf B1[x := B2]
x ∈ B1
40/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A1 6βsd λx .B1), S →λλ (A1 6βsd B1), S
(A1A2 6βsd B1B2), S →@@ (A1 6βsd B1), (A2 6βsd B2), S
(A1A2 6βsd B1), S →@pi A1 6βsd λx .B1 if . . .
(A1A2 6βsd B1[x := B2]), S →@β (A1 6βsd λx .B1), (A2 6βsd B2), S
where C = B1[x := B2]
and x ∈ B1
A1σ =⇒βf λx .B1 A2σ =⇒βf B2
(A1A2)σ =⇒βf B1[x := B2]
x ∈ B1
40/46
Algorithm for matching modulo
superdevelopments
(a 6βsd a), S →ℵc S
(x 6βsd x), S →ℵv S
(X 6βsd A), S →ℵX X 6βsd A, S{A/X} if . . .
(λx .A1 6βsd λx .B1), S →λλ (A1 6βsd B1), S
(A1A2 6βsd B1B2), S →@@ (A1 6βsd B1), (A2 6βsd B2), S
(A1A2 6βsd B1), S →@pi A1 6βsd λx .B1 if . . .
(A1A2 6βsd C), S →@β (A1 6βsd λx .B1), (A2 6βsd B2), S
where C = B1[x := B2]
and x ∈ B1
A1σ =⇒βf λx .B1 A2σ =⇒βf B2
(A1A2)σ =⇒βf B1[x := B2]
x ∈ B1
40/46
Example: XY 6βsd ab
I Rule @@: X 6βsd a, Y 6βsd b
I Rule @pi: X 6βsd λx .ab
I Rule @β:
I
X 6βsd λx .x , Y 6βsd ab
I
X 6βsd λx .xb, Y 6βsd a
I
X 6βsd λx .ax , Y 6βsd b
41/46
Example: XY 6βsd ab
I Rule @@: X 6βsd a, Y 6βsd b
I Rule @pi: X 6βsd λx .ab
I Rule @β:
I
X 6βsd λx .x , Y 6βsd ab
I
X 6βsd λx .xb, Y 6βsd a
I
X 6βsd λx .ax , Y 6βsd b
41/46
Example: XY 6βsd ab
I Rule @@: X 6βsd a, Y 6βsd b
I Rule @pi: X 6βsd λx .ab
I Rule @β:
I
X 6βsd λx .x , Y 6βsd ab
I
X 6βsd λx .xb, Y 6βsd a
I
X 6βsd λx .ax , Y 6βsd b
41/46
Example: XY 6βsd ab
I Rule @@: X 6βsd a, Y 6βsd b
I Rule @pi: X 6βsd λx .ab
I Rule @β:
I
X 6βsd λx .x ,
Y 6βsd ab
I
X 6βsd λx .xb,
Y 6βsd a
I
X 6βsd λx .ax ,
Y 6βsd b
41/46
Example: XY 6βsd ab
I Rule @@: X 6βsd a, Y 6βsd b
I Rule @pi: X 6βsd λx .ab
I Rule @β:
I X 6βsd λx .x , Y 6βsd ab
I X 6βsd λx .xb, Y 6βsd a
I X 6βsd λx .ax , Y 6βsd b
41/46
Example: X (YX ) 6βsd a
I Rule @pi: X 6βsd λx .a
I Rule @β: X 6βsd λx .x , YX 6βsd a
I Rule @pi: X 6βsd λx .x , Y 6βsd λx .a
I Rule @β : X 6βsd λx .x , Y 6βsd λx .x , X 6βsd a.
I Rule ℵX : X 6βsd λx .x , Y 6βsd λx .x , λx .x 6βsd a
å Not a solved form
42/46
Example: X (YX ) 6βsd a
I Rule @pi: X 6βsd λx .a
I Rule @β: X 6βsd λx .x , YX 6βsd a
I Rule @pi: X 6βsd λx .x , Y 6βsd λx .a
I Rule @β : X 6βsd λx .x , Y 6βsd λx .x , X 6βsd a.
I Rule ℵX : X 6βsd λx .x , Y 6βsd λx .x , λx .x 6βsd a
å Not a solved form
42/46
Example: X (YX ) 6βsd a
I Rule @pi: X 6βsd λx .a
I Rule @β: X 6βsd λx .x , YX 6βsd a
I Rule @pi: X 6βsd λx .x , Y 6βsd λx .a
I Rule @β : X 6βsd λx .x , Y 6βsd λx .x , X 6βsd a.
I Rule ℵX : X 6βsd λx .x , Y 6βsd λx .x , λx .x 6βsd a
å Not a solved form
42/46
Example: X (YX ) 6βsd a
I Rule @pi: X 6βsd λx .a
I Rule @β: X 6βsd λx .x , YX 6βsd a
I Rule @pi: X 6βsd λx .x , Y 6βsd λx .a
I Rule @β : X 6βsd λx .x , Y 6βsd λx .x , X 6βsd a.
I Rule ℵX : X 6βsd λx .x , Y 6βsd λx .x , λx .x 6βsd a
å Not a solved form
42/46
Example: X (YX ) 6βsd a
I Rule @pi: X 6βsd λx .a
I Rule @β: X 6βsd λx .x , YX 6βsd a
I Rule @pi: X 6βsd λx .x , Y 6βsd λx .a
I Rule @β : X 6βsd λx .x , Y 6βsd λx .x , X 6βsd a.
I Rule ℵX : X 6βsd λx .x , Y 6βsd λx .x , λx .x 6βsd a
å Not a solved form
42/46
Example: X (YX ) 6βsd a
I Rule @pi: X 6βsd λx .a
I Rule @β: X 6βsd λx .x , YX 6βsd a
I Rule @pi: X 6βsd λx .x , Y 6βsd λx .a
I Rule @β : X 6βsd λx .x , Y 6βsd λx .x , X 6βsd a.
I Rule ℵX : X 6βsd λx .x , Y 6βsd λx .x , λx .x 6βsd a
å Not a solved form
42/46
Main properties
I No new matching variables
I Termination
I Soundness
I Completeness
I Finite complete match set
43/46
Main properties
I No new matching variables
I Termination
I Soundness
I Completeness
I Finite complete match set
43/46
Main properties
I No new matching variables
I Termination
I Soundness
I Completeness
I Finite complete match set
43/46
Main properties
I No new matching variables
I Termination
I Soundness
I Completeness
I Finite complete match set
43/46
Main properties
I No new matching variables
I Termination
I Soundness
I Completeness
I Finite complete match set
43/46
Back to second-order
Applying the previous algorithm in a typed context:
We get a new algorithm for second-order matching
44/46
Matching modulo sd and η
The customization is easy
I Only generate βη-normal forms for the rule @β
I Perform η-expansion on the fly
λx .A 6ηβsd B, S →λ A 6
η
βsd
Bx , S
if B is not an abstraction
and x fresh
Proposition
In the context of patterns a` la Miller, this algorithm gives the most
general match.
45/46
Matching modulo sd and η
The customization is easy
I Only generate βη-normal forms for the rule @β
I Perform η-expansion on the fly
λx .A 6ηβsd B, S →λ A 6
η
βsd
Bx , S
if B is not an abstraction
and x fresh
Proposition
In the context of patterns a` la Miller, this algorithm gives the most
general match.
45/46
Matching modulo sd and η
The customization is easy
I Only generate βη-normal forms for the rule @β
I Perform η-expansion on the fly
λx .A 6ηβsd B, S →λ A 6
η
βsd
Bx , S
if B is not an abstraction
and x fresh
Proposition
In the context of patterns a` la Miller, this algorithm gives the most
general match.
45/46
Matching modulo sd and η
The customization is easy
I Only generate βη-normal forms for the rule @β
I Perform η-expansion on the fly
λx .A 6ηβsd B, S →λ A 6
η
βsd
Bx , S
if B is not an abstraction
and x fresh
Proposition
In the context of patterns a` la Miller, this algorithm gives the most
general match.
45/46
Matching modulo sd and η
The customization is easy
I Only generate βη-normal forms for the rule @β
I Perform η-expansion on the fly
λx .A 6ηβsd B, S →λ A 6
η
βsd
Bx , S
if B is not an abstraction
and x fresh
Proposition
In the context of patterns a` la Miller, this algorithm gives the most
general match.
45/46
Conclusion
I A new approach to higher-order matching:
in the untyped
λ-calculus with a restricted notion of β-equivalence where
superdevelopments give the right intuitions
I Complete for second-order
I Complete for patterns a` la Miller
I Use of η-equivalence is optional
I The simple algorithms
I properties: termination, soudness, completeness
I intuitive and simple proofs (provides by the use of SD)
I second-order matching if applied in a typed context
I An implementation of the algorithm is available in the Tom
language
I Higher-order rewriting with the untyped λ-calculus with
superdevelopments as a meta-language
I Higher-order matching in the ρ-calculus
46/46
Conclusion
I A new approach to higher-order matching: in the untyped
λ-calculus with a restricted notion of β-equivalence
where
superdevelopments give the right intuitions
I Complete for second-order
I Complete for patterns a` la Miller
I Use of η-equivalence is optional
I The simple algorithms
I properties: termination, soudness, completeness
I intuitive and simple proofs (provides by the use of SD)
I second-order matching if applied in a typed context
I An implementation of the algorithm is available in the Tom
language
I Higher-order rewriting with the untyped λ-calculus with
superdevelopments as a meta-language
I Higher-order matching in the ρ-calculus
46/46
Conclusion
I A new approach to higher-order matching: in the untyped
λ-calculus with a restricted notion of β-equivalence where
superdevelopments give the right intuitions
I Complete for second-order
I Complete for patterns a` la Miller
I Use of η-equivalence is optional
I The simple algorithms
I properties: termination, soudness, completeness
I intuitive and simple proofs (provides by the use of SD)
I second-order matching if applied in a typed context
I An implementation of the algorithm is available in the Tom
language
I Higher-order rewriting with the untyped λ-calculus with
superdevelopments as a meta-language
I Higher-order matching in the ρ-calculus
46/46
Conclusion
I A new approach to higher-order matching: in the untyped
λ-calculus with a restricted notion of β-equivalence where
superdevelopments give the right intuitions
I Complete for second-order
I Complete for patterns a` la Miller
I Use of η-equivalence is optional
I The simple algorithms
I properties: termination, soudness, completeness
I intuitive and simple proofs (provides by the use of SD)
I second-order matching if applied in a typed context
I An implementation of the algorithm is available in the Tom
language
I Higher-order rewriting with the untyped λ-calculus with
superdevelopments as a meta-language
I Higher-order matching in the ρ-calculus
46/46
Conclusion
I A new approach to higher-order matching: in the untyped
λ-calculus with a restricted notion of β-equivalence where
superdevelopments give the right intuitions
I Complete for second-order
I Complete for patterns a` la Miller
I Use of η-equivalence is optional
I The simple algorithms
I properties: termination, soudness, completeness
I intuitive and simple proofs (provides by the use of SD)
I second-order matching if applied in a typed context
I An implementation of the algorithm is available in the Tom
language
I Higher-order rewriting with the untyped λ-calculus with
superdevelopments as a meta-language
I Higher-order matching in the ρ-calculus
46/46
Conclusion
I A new approach to higher-order matching: in the untyped
λ-calculus with a restricted notion of β-equivalence where
superdevelopments give the right intuitions
I Complete for second-order
I Complete for patterns a` la Miller
I Use of η-equivalence is optional
I The simple algorithms
I properties: termination, soudness, completeness
I intuitive and simple proofs (provides by the use of SD)
I second-order matching if applied in a typed context
I An implementation of the algorithm is available in the Tom
language
I Higher-order rewriting with the untyped λ-calculus with
superdevelopments as a meta-language
I Higher-order matching in the ρ-calculus
46/46
Conclusion
I A new approach to higher-order matching: in the untyped
λ-calculus with a restricted notion of β-equivalence where
superdevelopments give the right intuitions
I Complete for second-order
I Complete for patterns a` la Miller
I Use of η-equivalence is optional
I The simple algorithms
I properties: termination, soudness, completeness
I intuitive and simple proofs (provides by the use of SD)
I second-order matching if applied in a typed context
I An implementation of the algorithm is available in the Tom
language
I Higher-order rewriting with the untyped λ-calculus with
superdevelopments as a meta-language
I Higher-order matching in the ρ-calculus
46/46
Conclusion
I A new approach to higher-order matching: in the untyped
λ-calculus with a restricted notion of β-equivalence where
superdevelopments give the right intuitions
I Complete for second-order
I Complete for patterns a` la Miller
I Use of η-equivalence is optional
I The simple algorithms
I properties: termination, soudness, completeness
I intuitive and simple proofs (provides by the use of SD)
I second-order matching if applied in a typed context
I An implementation of the algorithm is available in the Tom
language
I Higher-order rewriting with the untyped λ-calculus with
superdevelopments as a meta-language
I Higher-order matching in the ρ-calculus
46/46
Conclusion
I A new approach to higher-order matching: in the untyped
λ-calculus with a restricted notion of β-equivalence where
superdevelopments give the right intuitions
I Complete for second-order
I Complete for patterns a` la Miller
I Use of η-equivalence is optional
I The simple algorithms
I properties: termination, soudness, completeness
I intuitive and simple proofs (provides by the use of SD)
I second-order matching if applied in a typed context
I An implementation of the algorithm is available in the Tom
language
I Higher-order rewriting with the untyped λ-calculus with
superdevelopments as a meta-language
I Higher-order matching in the ρ-calculus
46/46
Conclusion
I A new approach to higher-order matching: in the untyped
λ-calculus with a restricted notion of β-equivalence where
superdevelopments give the right intuitions
I Complete for second-order
I Complete for patterns a` la Miller
I Use of η-equivalence is optional
I The simple algorithms
I properties: termination, soudness, completeness
I intuitive and simple proofs (provides by the use of SD)
I second-order matching if applied in a typed context
I An implementation of the algorithm is available in the Tom
language
I Higher-order rewriting with the untyped λ-calculus with
superdevelopments as a meta-language
I Higher-order matching in the ρ-calculus
46/46
Conclusion
I A new approach to higher-order matching: in the untyped
λ-calculus with a restricted notion of β-equivalence where
superdevelopments give the right intuitions
I Complete for second-order
I Complete for patterns a` la Miller
I Use of η-equivalence is optional
I The simple algorithms
I properties: termination, soudness, completeness
I intuitive and simple proofs (provides by the use of SD)
I second-order matching if applied in a typed context
I An implementation of the algorithm is available in the Tom
language
I Higher-order rewriting with the untyped λ-calculus with
superdevelopments as a meta-language
I Higher-order matching in the ρ-calculus
46/46
Conclusion
I A new approach to higher-order matching: in the untyped
λ-calculus with a restricted notion of β-equivalence where
superdevelopments give the right intuitions
I Complete for second-order
I Complete for patterns a` la Miller
I Use of η-equivalence is optional
I The simple algorithms
I properties: termination, soudness, completeness
I intuitive and simple proofs (provides by the use of SD)
I second-order matching if applied in a typed context
I An implementation of the algorithm is available in the Tom
language
I Higher-order rewriting with the untyped λ-calculus with
superdevelopments as a meta-language
I Higher-order matching in the ρ-calculus
46/46
