Strong cut-elimination systems for Hudelmaier’s depth-bounded sequent calculus for implicational logic
Roy Dyckhoﬀ1, Delia Kesner2, and St´ephane Lengrand1,2
1 PPS, CNRS and Universit´e Paris 7, France 2 School of Computer Science, University of St Andrews, Scotland
Abstract. Inspired by the Curry-Howard correspondence, we study normalisation procedures in the depth-bounded intuitionistic sequent calculus of Hudelmaier (1988) for the implicational case, thus strengthening existing approaches to Cut-admissibility. We decorate proofs with proofterms and introduce various term-reduction systems representing proof transformations. In contrast to previous papers which gave diﬀerent arguments for Cut-admissibility suggesting weakly normalising procedures for Cut-elimination, our main reduction system and all its variations are strongly normalising, with the variations corresponding to diﬀerent optimisations, some of them with good properties such as conﬂuence.
1 Introduction
The sequent calculus G4ip (as it is called in [TS00]) for intuitionistic propositional logic was independently developed by Hudelmaier [Hud89,Hud92], and the ﬁrst author [Dyc92]; see also Lincoln, Scedrov & Shankar [LSS91]; it has the strong property of being depth-bounded, in that proofs are of bounded depth and thus (for root-ﬁrst proof search) no loop-checking is required. This contrasts with other calculi for this logic such as Kleene’s G3ip, where proofs can be of unbounded depth. Its essential ingredients appeared already in 1952 work of Vorob’ev, published in detail in [Vor70].
Its completeness can be shown by various means, either indirectly, using the completeness of another calculus and a permutation argument [Dyc92], or directly, such as in the work of Negri and the ﬁrst author [DN00] where cut-admissibility is proved without reference to the completeness of any other sequent calculus. This admissibility proof could be seen, via the Curry-Howard correspondence, as a weakly normalising proof-reduction system. Developing this idea, this paper presents a formulation of implicational G4ip with derivations represented by (proof-)terms; strong (instead of weak) normalisation is proved by the use of a multiset path ordering. Several variations, all of them being strongly normalising, are considered, depending on whether we want to have a system as general as possible or a system more restricted (but simpler) implementing some reduction strategy.
The merits of G4ip for proof-search and automated reasoning have been discussed in many papers (see [ORK05] for some recent pointers; note its use of an old name LJT for G4ip), because the property of being depth-bounded makes the space of derivations of a given sequent ﬁnite.
However, a question that has been less investigated, natural though it is, is the following: which proofs are produced by proof-search in G4ip and what are their properties? Our approach to cut-elimination in this paper, with a strongly normalising reduction system internal to G4ip, tackles this question in terms of the behaviour of these proofs when they are combined together with cuts. In other words, we give them an operational semantics.
A complementary approach is to give these proofs a denotational semantics and to relate them (and their reductions) to simply-typed λ-terms. We leave this approach for future work.

In contrast to previous work, this paper presents G4ip with a proof-term syntax, so sequents are of the form Γ ⇒ M : A where A is a type, M is a (proof-)term and Γ is a consistent ﬁnite set of “declarations” of the form x : B, where x is a variable and B a type. Results about such sequents translate directly to results about traditional “logical sequents”.
Our approach to cut-elimination using proof-terms diﬀers from that in [DN00], which showed (in the context of logical sequents) ﬁrst the admissibility of Contraction and then the admissibility of “context-splitting” (or “multiplicative”) Cut. Given our interest in the term calculi, it is appropriate to use rather a “context-sharing” Cut; admissibility of Contraction then follows as a special case of that of Cut.
Matthes [Mat02] tackled a similar problem, with a variety of motivations, such as that of understanding better Pitts’ algorithm [Pit92] for uniform interpolation; but his approach has not yet been brought to a successful conclusion. His work is similar to ours in using terms to represent derivations; but it diﬀers conceptually from ours by considering not the use of explicit operators to encode the Cut-rule but the closure of the syntax under (implicit) substitution, as in pure λ-calculus, where the general syntax of λ-terms may be considered as the extension of the normal lambda terms by such an implicit closure. His reduction rules are global (using implicit substitutions) rather than local (using explicit operators); strong normalisation is shown for a subset of the reductions, but not for all that are required.
Structure of the paper The paper is organised as follows. Section 2 presents the term syntax and typing rules of our calculus for G4ip and its auxiliary (admissible) rules. Section 3 studies proof transformations and reduction rules of the calculus. Section 4 shows a translation from the calculus to a ﬁrst-order syntax and Section 5 shows that every reduction step satisﬁes subject reduction and decreases ﬁrst-order terms associated to derivations with respect to a multi-set path ordering, thus proving strong normalisation. In Section 6 we give diﬀerent variants for the reduction system introduced in Section 3, some of them being conﬂuent. Finally we conclude and give some ideas for further work.

2 Syntax

2.1 Grammar
We assume we are given an inﬁnite set of base types P (known as proposition variables or atomic formulae in the logical interpretation) and an inﬁnite set of variables x. We consider the following grammars for types (also known as formulae) and terms:

Deﬁnition 1 (Grammar of Types and Terms).

A, B, C, D, E, F ::= P | A⊃B

M, N, L

::= x | λx.M | x(y, z.M ) | x(u.v.M, z.N ) |

inv(x, y.M ) | of(M, x) | dec(x, y, z.M ) | cut(M, x.N )

In this deﬁnition, the ﬁrst line deﬁnes the syntax for types, the second gives the syntax for normal or constructor terms (corresponding to primitive derivations) and the third gives the extra syntax for auxiliary terms, which may be built up using also the “auxiliary constructors” that appear in bold teletype font, such as cut. Six of the eight term constructors use variable binding: in λx.M , x binds in M ; in x(y, z.M ), z binds in M ; in x(u.v.M, z.N ), u and v bind in M and z binds in N ; in inv(x, y.M ), y binds in M ; in dec(x, y, z.M ), z binds in M ; and in cut(M, x.N ), x binds in N .

2

Standard conventions are used to avoid confusion of free and bound variables, and αconvertible terms are regarded as identical.
Certain constraints on the use of the term syntax will be evident once we present the typing rules; these constraints are captured by the following notion of well-formed term:
Deﬁnition 2. A term L is well-formed if in any sub-term of the form
– x(y, z.M ), we have x = y, with x not free in M ; – x(u.v.M, z.N ), we have u = v, with x not free in M and not free in N ; – inv(x, y.M ), we have x not free in M ; – of(M, x), we have x not free in M ; – dec(x, y, z.M ), we have x = y, with both of them not free in M .
Deﬁnition 3 (Ordering on (multi-sets of ) types). The weight w(A) of a type A is deﬁned by: w(P ) = 1 for any base type P and w(A⊃B) = 1 + w(A) + w(B). Types are compared by their weight, i.e. we say that A is smaller than B iﬀ w(A) < w(B).
We shall then compare multi-sets of types, equipped with the traditional multi-set ordering [DM79], denoted <mul, generated by the order relation on types.
The weight is chosen to ensure that, for every rule of the logical sequent calculus G4ip, the multi-set of types appearing in the conclusion is greater than that of any given premiss. Hence, we say that G4ip is depth-bounded. See [Dyc92] or [TS00] for details, and see the next section for the corresponding property in our version of G4ip with proof-terms.

2.2 Typing

A context Γ is a consistent ﬁnite set of declarations, i.e. expressions x : A (where x is a variable and A is a type) declaring x to be of type A; by consistent is meant that if x : A and x : B are in Γ , then A = B. When we write a context in the form Γ , x : A it is always implicit that there is no declaration x : B in Γ of the same variable x. By removing the variable names from a context Γ , but keeping the types, we obtain the multiset m(Γ ) of types that is associated with the context.
A sequent consists of a context Γ , a term M and a type A; it is written Γ ⇒ M : A. The next deﬁnition adds term notation to the rules for implication of G4ip; another view is that it shows how the untyped normal terms of the above grammar may be typed.
Deﬁnition 4 (Typing Rules for Normal Terms).

Γ , x : A ⇒ x : A Ax

Γ,x:A ⇒ M :B Γ ⇒ λx.M : A⊃B

R⊃

Γ , y : A, z : B ⇒ M : E Γ , x : A⊃B, y : A ⇒ x(y, z.M ) : E

L0⊃

Γ , u : C, v : D⊃B ⇒ M : D

Γ,z:B ⇒

Γ , x : (C⊃D)⊃B ⇒ x(u.v.M, z.N ) : E

N :E

L⊃⊃

As remarked before these rules only construct well-formed terms; for example the notation Γ , x : A⊃B, y : A in the conclusion of rule L0⊃ forces x to be not free in M and x = y.
Note that we use a slight variant of the L⊃⊃ rule used in [Dyc92] and [TS00], and that both in axioms Γ , x : A ⇒ x : A and in the rule L0⊃ the type A need not be atomic. In the

3

rules R⊃, L0⊃ and L⊃⊃ the types A⊃B, A⊃B and (C⊃D)⊃B respectively are principal; in L0⊃ the type A is auxiliary. (This use of “auxiliary” is not to be confused with its use in Deﬁnition 1 to describe certain kinds of term.)
Notice that in every instance of a rule in Deﬁnition 4 with conclusion Γ ⇒ M : A, each premiss Γ ⇒ N : B is such that m(Γ ) ∪ A >mul m(Γ ) ∪ B, where ∪ denotes the union of multi-sets. As a consequence, given Γ and A, there are ﬁnitely many derivations concluding Γ ⇒ M : A for some (normal) term M .

Deﬁnition 5 (Typing Rules for Auxiliary Terms).

Γ , y : C⊃D ⇒ M : E Γ , x : D ⇒ inv(x, y.M ) : E Inv

Γ ⇒ M : A⊃B Γ , x : A ⇒ of(M, x) : B

Of

Γ , z : (C⊃D)⊃B ⇒ M : A Γ , x : C, y : D⊃B ⇒ dec(x, y, z.M ) : A Dec

Γ

⇒ M : A x : A, Γ ⇒ N : B Γ ⇒ cut(M, x.N ) : B

C ut

As remarked before these rules only construct well-formed terms; for example the notation Γ , x : A in the conclusion of rule Inv forces x to be not free in M .
In the Cut-rule, we say that A is the cut-type. Derivations are the labelled trees whose leaves are axioms and whose internal nodes match rules: each label is a sequent and each internal node is also labelled by the name of the rule. A derivation is normal if it uses only the primitive rules, i.e. those of Deﬁnition 4. The height of a derivation is just its height as a tree; so a tree with one node has height 0.

Remark 1. Notice that for each proved sequent Γ ⇒ M : A there is a unique derivation tree, which can be reconstructed using the information of the term M that represents the proof (hence the notion of proof-term).

We will occasionally ﬁnd it necessary to rename free variables. The renaming by the variable y of all the free occurrences of x in M , written {y/x}M , is deﬁned whenever y and x are distinct variables, M is a well-formed term and y is not free in M .
This is an implicit operation on terms, not an explicit term constructor. In other words, renaming is a transformation of terms, and it is sound with respect to typing, as shown by the ﬁrst of the two results of admissibility of Lemma 1. Admissibility is considered in the standard sense (see for instance [TS00]):
Deﬁnition 6. A rule R is admissible in an inference system S if and only if, for each instance whose premisses are all derivable in S, the conclusion is also derivable in S.
Lemma 1. The following rules are admissible both in the system of normal derivations and in the full system with auxiliary terms, with the proviso that y = x in the (Ren) rule.

Γ,x:B ⇒ M :A (Ren)
Γ , y : B ⇒ {y/x}M : A

Γ ⇒ M :A (W )
Γ,y:B ⇒ M :A

Proof: Routine induction on the height of the derivation of the premiss. Some swapping

of bound variable names may be necessary: recall our convention about α-conversion and

identity of terms. Remember that the notation Γ , y : B forces y to be not free in M .

2

We parenthesise the names of those two rules to indicate their admissibility.

4

3 Proof Transformations and Reduction Rules

The starting point of this section is the admissibility in the (cut-free) logical sequent calculus G4ip of the following inference rules (i.e. the logical counter-part of the typing rules for auxiliary terms given in Deﬁnition 5):

Γ , C⊃D ⇒ E Γ , D ⇒ E Inv

Γ ⇒ A⊃B Γ,A ⇒ B

Of

Γ , (C⊃D)⊃B ⇒ A Γ , C, D⊃B ⇒ A Dec

Γ ⇒A

A, Γ ⇒ B

Γ ⇒B

C ut

The admissibility of Inv and Of in G4ip can be proved, independently, by induction on the height of the derivation. For the admissibility of Dec and Cut we can use a simultaneous induction, the admissibility of one rule being recursively used for the admissibility of the other. The measure is now the multi-set of types appearing in the unique premiss for Dec and in the second premiss for Cut. In other words, the induction can be done on {{Γ, (C⊃D)⊃B, A}} for Dec and on {{Γ, A, B}} for Cut.
We do not include here the detail of those proofs of admissibility, because they become a corollary (Corollary 2) of the properties that we show for our calculus with proof-terms.
With proof-terms, those admissibility properties mean that a proof-term M with auxiliary constructors inv( , . ), of( , ), dec( , , . ) or cut( , . ) can be transformed into another proof-term M with the same type in the same context that does not use these constructors.
This motivates the notion of logical admissibility in a system with proof-terms:

Deﬁnition 7. A rule R is logically admissible in system S if, given an instance with conclusion Γ ⇒ M : A and derivations in system S of its premiss(es), there exists a derivation in S of Γ ⇒ M : A for some proof-term M .
Remark that this notion corresponds to the standard notion of admissibility (Deﬁnition 6) when proof-term annotations are erased.
Indeed, the proofs of admissibility above can be seen as weakly normalising term reduction systems that specify how to eliminate the auxiliary constructors inv( , . ), of( , ), dec( , , . ) and cut( , . ).
The reduction systems, given hereafter, must satisfy the following properties:
1. A term containing an auxiliary constructor is reducible by these systems. 2. They satisfy the Subject Reduction property, i.e. preservation of typing. 3. They satisfy some termination property.
Concerning point 3, the weak normalisation property of these systems suﬃces to prove the results of admissibility, and the proofs suggested above can be expressed as a terminating innermost strategy for these reduction systems. Nevertheless, we give in this paper reduction systems that are in fact strongly normalising. While this can be inferred for the orthogonal systems that we present in Section 6 (since weak innermost normalisation is equivalent to strong normalisation for orthogonal systems [O’D77]), the result is not straightforward for the non-orthogonal ones. However, the measures for induction mentioned above can be taken as part of a Multi-Set Path Ordering [KL80,BN98] in order to conclude strong normalisation as well (see Section 4).

5

We now give in Tables 1, 2 and 3 the reduction systems that eliminate the auxiliary constructors of, inv and dec. All these rules that we call system oid will be part of the diﬀerent variants that we are going to introduce.

of(y, x)

−→o1 y(x, z.z)

of(λy.M, x)

−→o2 {x/y}M

of(y(z, w.N ), x) −→o3 y(z, w.of(N, x))

of(y(u.v.M, w.N ), x) −→o4 y(u.v.M, w.of(N, x))

Table 1. Reduction Rules for of-terms

inv(x, y.z)

−→i1 z

inv(x, y.y)

−→i2 λz.x

inv(x, y.λz.M )

−→i3 λz.inv(x, y.M )

inv(x, y.y(w, z.N ))

−→i4 {x/z}N

inv(x, y.y(u.v.M, z.N )) −→i5 {x/z}N

inv(x, y.w(y, z.N ))

−→i6 w(u.v.x, z.inv(x, y.N ))

inv(x, y.y (w, z.N )) −→i7 y (w, z.inv(x, y.N ))

inv(x, y.y (u.v.M, z.N )) −→i8 y (u.v.inv(x, y.M ), z.inv(x, y.N ))

Table 2. Reduction Rules for inv-terms

dec(x, y, z.w)

−→d1 w

dec(x, y, z.z)

−→d2 λv.v(x, w.y(w, u.u))

dec(x, y, z.λw.M )

−→d3 λw.dec(x, y, z.M )

dec(x, y, z.w(u.v.M, w .N )) −→d4 w(u.v.dec(x, y, z.M ), w .dec(x, y, z.N ))

dec(x, y, z.w(y , z .M )) −→d5 w(y , z .dec(x, y, z.M ))

dec(x, y, z.z(y , z .M ))

−→d6 y (x, z .y(z , z .inv(z , y .M )))

dec(x, y, z.x (z, z .M ))

−→d7 x(u.v.v(x, z .y(z , w.w)), z .dec(x, y, z.M ))

dec(x, y, z.z(u.v.M, z .N )) −→d8 cut({x/u}{y/v}M, y .y(y , z .N ))

Table 3. Reduction Rules for dec-terms

In order to reduce the cuts we now suggest a general system called cegs for cut-elimination in Tables 4 and 5 (variants are presented in Section 6). The whole system is called gs and contains the reduction rules in cegs (Tables 4 and 5) plus the ones in oid (Tables 1, 2 and 3).
Summing up :
6

Kind1

cut(M, x.x)

−→a M

cut(M, x.y)

−→b y

cut(M, x.λy.N )

−→c λy.cut(M, x.N )

cut(M, x.y(z, w.N ))

−→d y(z, w.cut(inv(w, y.M ), x.N ))

cut(M, x.y(u.v.N , w.N )) −→e y(u.v.cut(dec(u, v, y.M ), x.N ), w.cut(inv(w, y.M ), x.N ))

cut(λz.M, x.y(x, w.N )) −→f y(u.v.cut(u, z.dec(u, v, y.M )), w.cut(inv(w, y.λz.M ), x.N ))

cut(z, x.y(x, w.N ))

−→g y(z, w.cut(z, x.N ))

Kind2

cut(y(z, w.M ), x.N )

−→π y(z, w.cut(M, x.inv(w, y.N )))

cut(y(u.v.M , w.M ), x.N ) −→φ y(u.v.M , w.cut(M, x.inv(w, y.N )))

Table 4. Cut Elimination Rules cegs (Kind1 and Kind2)

Kind3

cut(M, x.x(z, w.N ))

−→A cut(cut(z, y.of(M, y)), w.N )

cut(M, x.x(u.v.N , w.N )) −→B cut(cut(λu.cut(λz.inv(z, y.of(M, y)), v.N ), y.of(M, y)), w.N )

Table 5. Cut Elimination Rules cegs (Kind3)

Name of the System Reduction Rules oid Tables 1, 2 and 3 cegs Tables 4, 5 gs oid ∪ cegs
As in most cut-elimination systems, the cut-reduction rules can be split into three kinds (Kind1, Kind2, Kind3), according to whether they push cuts to the right, to the left, or they break a cut into cuts on smaller types.
Here, owing to the particular inference rules of G4ip and the linearity constraints they impose on free variables, the ﬁrst two kinds must use the auxiliary constructs inv( , . ) and dec( , , . ), rather than just propagate the cuts.
For the third kind of cut-reduction rules, we usually expect both sub-proofs of the cut to introduce the cut-type (on the right and on the left, respectively). In particular, this requires the ﬁrst argument of the cut-constructor to be a value, i.e. a variable or an abstraction, with a functional type, i.e. an implication A⊃B. However, just as any λ-term can be turned into a value by an η-expansion, here any term can be turned into a value by the use of the of( , ) constructor, with the following rule, which we also call η:
M −→η λx.of(M, x) if x ∈/ F V (M )
Notice that in both cases this is only sound with respect to typing if the type of the original term is an implication.
Remark 2. All rules of system gs are such that well-formed terms reduce to well-formed terms.
7

4 A First-Order Syntax for Typed G4ip-Terms

Termination of the above rewrite systems on typed terms will be proved by the decrease of a measure associated to typing derivations. The latter are mapped to a ﬁrst-order syntax with the following inﬁnite signature:

Σ = { /0, I/1, K/2, J/1} ∪ {Dm/1, Cm/2 | m is a multiset of types}

where the notation f /n is used to say that the symbol f has arity n, and the symbols have the following precedence relation:

Cn Dn · · · · · · Cm Dm J K I

if n >mul m

Remark 3.

1. The order on types (Deﬁnition 3) is well-founded, so >mul is well-founded [DM79]. 2. The order >mul is well-founded, so is also well-founded. 3. The order is well-founded, so the Multi-Set Path Ordering mpo is also well-founded.

We now consider the Multi-set Path Ordering (mpo) [KL80,BN98] on ﬁrst-order terms induced by the above precedence relation on symbols. This is the relation deﬁned inductively as follows:

ti mpo f (t1, . . . , tn)

s mpo ti s mpo f (t1, . . . , tn)

ui mpo f (t1, . . . , tn) for all i g(u1, . . . , um) mpo f (t1, . . . , tn)

g≺f

{{t1, . . . , tn}} f (t1, . . . , tn)

mpo mul{{t1, . . . , tn}} mpo f (t1, . . . , tn)

where g and f are ﬁrst-order symbols with arities m and n, respectively, and
t1, . . . , tn, t1, . . . , tn, u1, . . . , um, s are ﬁrst-order terms. It can be shown that mpo is a well-founded order on ﬁrst-order terms satisfying the
subterm property, i.e. if s is a subterm of t then s mpo t. Derivations are mapped to this ﬁrst-order syntax. In particular, since each sequent Γ ⇒ M : A
has at most one derivation, we write Γ ⇒ M : A for such a translation, and even M when the
context and type are clear from the text, as in the right-hand sides of the following deﬁnition.

Γ,x:A ⇒ x:A

=

Γ ⇒ λx.M : A⊃B

= I(M )

Γ , x : A⊃B, y : A ⇒ x(y, z.M ) : E = I(M )

Γ , x : (C⊃D)⊃B ⇒ x(u.v.M, z.N ) : E = K(M , N )

Γ , x : D ⇒ inv(x, y.M ) : E

= J(M )

Γ , x : A ⇒ of(M, x) : B

= J(M )

Γ , x : C, y : D⊃B ⇒ dec(x, y, z.M ) : A = D{{Γ ,(C⊃D)⊃B,A}}(Γ , z : (C⊃D)⊃B ⇒ M : A)

Γ ⇒ cut(M, x.N ) : B

= C{{Γ,A,B}}(Γ ⇒ M : A, x : A, Γ ⇒ N : B)

Observe that M = {x/y}M for any renaming of M .

8

5 Subject Reduction and Strong Normalisation

In this section we show two fundamental properties of system gs. The ﬁrst one is subject reduction and it guarantees that types are preserved by the reduction system. The second one is strong normalisation and it guarantees that there is no inﬁnite reduction sequence starting from a typed term. Strong normalisation is shown by a decreasing measure given by the Multi-Set Path Ordering of Section 4.

Theorem 1. If Γ ⇒ L : E and L −→gs L , then Γ ⇒ L : E and L mpo L .
Proof: By induction on the proof Γ t : A. We consider only the cases where reduction takes place at the root.
o1 of(y, x) −→o1 y(x, z.z) The derivation

rewrites to Also, L = J( )

Γ

Γ , y : A⊃B ⇒ y : A⊃B Ax , y : A⊃B, x : A ⇒ of(y, x) : B

Of

Γ

Γ , x : A, z : B ⇒ z : B Ax , y : A⊃B, x : A ⇒ y(x, z.z) : B

L0⊃

mpo I( ) = L since J I.

o2 of(λy.M, x) −→o2 {x/y}M The derivation

rewrites to

Γ

,

Γ,y:A ⇒ M :B Γ ⇒ λy.M : A⊃B

R⊃

x : A ⇒ of(λy.M, x) : B

Of

Γ,y:A ⇒ M :B Ren
Γ , x : A ⇒ {x/y}M : B

Also, L = J(I(M )) mpo M = L by the subterm property of

mpo .

o3 of(y(z, w.N ), x) −→o3 y(z, w.of(N, x)) The derivation

Γ

,

Γ, z:C

z, y:ΓC: C,,y⊃z::DCC,⊃,xwD: :AD⇒⇒⇒yo(zNf,(wy: A(.zN⊃, w)B:.AN⊃),Bx)L: B0⊃Of

rewrites to

Γ

Γ , z : C, w : D ⇒ N : A⊃B , z : C, w : D, x : A ⇒ of(N, x) : B

Of

Γ , z : C, y : C⊃D, x : A ⇒ y(z, w.of(N, x)) : B L0⊃

Also, L = J(I(N )) mpo I(J(N )) = L since J I.

9

o4 of(y(u.v.M, w.N ), x) −→o4 y(u.v.M, w.of(N, x)) So A is of the form C⊃D. The derivation

Γ Γ, u,:yCΓ:,(,vCy:⊃D: (DC⊃)⊃B⊃DB⇒)⊃, xMB: A:⇒D⇒yo(uf.(vy.(MΓu.,v,ww.M.:NB, w) :.⇒AN⊃)N,Bx:)A: B⊃BOfL⊃⊃

rewrites to

Γ , u : C, v : D⊃B ⇒ M : D

(W )

Γ

Γ , w : B ⇒ N : A⊃B , w : B , x : A ⇒ of(N, x) : B

Of

Γ , u : C, v : D⊃B , x : A ⇒ M : D

Γ , y : (C⊃D)⊃B , x : A ⇒ y(u.v.M, w.of(N, x)) : B

L⊃⊃

Also, L = J(K(M , N )) mpo K(M , J(N )) = L since J K,.

i1 inv(x, y.z) −→i1 z The derivation

Γ , z : E, y : A⊃B ⇒ z : E Ax Γ , z : E, x : B ⇒ inv(x, y.z) : E Inv

rewrites to

Γ , z : E, x : B ⇒ z : E Ax

Also, L = J( ) mpo = L holds by the subterm property of

mpo .

i2 inv(x, y.y) −→i2 λz.x The derivation

Γ

Γ ,x

,y :B

:⇒A⊃iBnv⇒(x,yy:.yA)⊃: AB⊃ABxInv

rewrites to

Γ , x:B, z Γ ,x:B ⇒

:A ⇒ λz.x :

x:B A⊃B

Ax R⊃

Also, L = J( ) I( ) = L holds by J I.

i3 inv(x, y.λz.M ) −→i3 λz.inv(x, y.M ) with E = C⊃D The derivation Γ , y : A⊃B, z : C ⇒ M : D Γ , y : A⊃B ⇒ λz.M : C⊃D R⊃ Γ , x : B ⇒ inv(x, y.λz.M ) : C⊃D Inv

rewrites to

Γ

Γ , y : A⊃B, z : C ⇒ M : D , x : B, z : C ⇒ inv(x, y.M ) : D

I nv

Γ , x : B ⇒ λz.inv(x, y.M ) : C⊃D R⊃

Also, L = J(I(M )) mpo I(J(M )) = L by J I.

10

i4 inv(x, y.y(w, z.N )) −→i4 {x/z}N

The derivation

Γ

Γ , w : A, z : B ⇒ N : E , w : A, y : A⊃B ⇒ y(w, z.N ) : E

L0⊃

Γ , w : A, x : B ⇒ inv(x, y.y(w, z.N )) : E Inv

rewrites to

Γ , w : A, z : B ⇒ N : E Ren
Γ , w : A, x : B ⇒ {x/z}N : E

Also, M = J(I(N )) mpo N = M holds by the subterm property of

mpo .

i5 inv(x, y.y(u.v.M, z.N )) −→i5 {x/z}N with A = C⊃D The derivation

Γ

, u : C, v : D⊃B ⇒ M : D Γ , z : B ⇒ Γ , y : A⊃B ⇒ y(u.v.M, z.N ) : E

N :E

L⊃⊃

Γ , x : B ⇒ inv(x, y.y(u.v.M, z.N )) : E Inv

rewrites to

Γ ,z:B ⇒ N :E (Ren)
Γ , x : B ⇒ {x/z}N : E

Also, L = J(K(M , N )) mpo N = L holds by the subterm property of

mpo .

i6 inv(x, y.w(y, z.N )) −→i6 w(u.v.x, z.inv(x, y.N )) The derivation

Γ

Γ , y : A⊃B, z : C ⇒ N : E , w : (A⊃B)⊃C, y : A⊃B ⇒ w(y, z.N ) : E

L0⊃

Γ , w : (A⊃B)⊃C, x : B ⇒ inv(x, y.w(y, z.N )) : E Inv

rewrites to

Γ , y : A⊃B, z : C ⇒ N : E

Γ , x : B, u : A, v : B⊃C ⇒ x : B Ax Γ , x : B, z : C ⇒ inv(x, y.N ) : E Inv

Γ , w : (A⊃B)⊃C, x : B ⇒ w(u.v.x, z.inv(x, y.N )) : E

L⊃⊃

Also, L = J(I(N )) mpo K( , J(N )) = L by J K, .

i7 inv(x, y.y (w, z.N )) −→i7 y (w, z.inv(x, y.N )) The derivation

rewrites to

Γ

Γ , w : C, z : D, y : A⊃B ⇒ N : E , w : C, y : C⊃D, y : A⊃B ⇒ y (w, z.N ) : E

L0⊃

Γ , w : C, y : C⊃D, x : B ⇒ inv(x, y.y (w, z.N )) : E Inv

Γ

Γ , w : C, z : D, y : A⊃B ⇒ N : E , w : C, z : D, x : B ⇒ inv(x, y.N ) : E

I nv

Γ , w : C, y : C⊃D, x : B ⇒ y (w, z.inv(x, y.N )) : E L0⊃

11

Also, L = J(I(N )) mpo I(J(N )) = L by J I.

i8 inv(x, y.y (u.v.M, z.N )) −→i8 y (u.v.inv(x, y.M ), z.inv(x, y.N )) The derivation

Γ , y : A⊃B, u : C, v : D⊃B ⇒ M : D

Γ , y : A⊃B, z : B

Γ , y : (C⊃D)⊃B , y : A⊃B ⇒ y (u.v.M, z.N ) : E

⇒ N :E

L⊃⊃

Γ , y : (C⊃D)⊃B , x : B ⇒ inv(x, y.y (u.v.M, z.N )) : E Inv

rewrites to

Γ , y : A⊃B, u : C, v : D⊃B ⇒ M : D

Γ , y : A⊃B, z : B ⇒ N : E

Γ , x : B, u : C, v : D⊃B ⇒ inv(x, y.M ) : D Inv Γ , x : B, z : B ⇒ inv(x, y.N ) : E Inv

Γ , y : (C⊃D)⊃B , x : B ⇒ y (u.v.inv(x, y.M ), z.inv(x, y.N )) : E

L⊃⊃

Also, L = J(K(M , N )) mpo K(J(M ), J(N )) = L by J K.

d1 dec(x, y, z.w) −→d1 w, where x, y, z and w are all distinct. The derivation Γ , w : E, z : (C⊃D)⊃B ⇒ w : E Ax Γ , w : E, x : C, y : D⊃B ⇒ dec(x, y, z.w) : E Dec rewrites to Γ , w : E, x : C, y : D⊃B ⇒ w : E Ax Also, L = Dm( ) mpo = L , where m = {{Γ , E, (C⊃D)⊃B, E}}.

d2 dec(x, y, z.z) −→d2 λv.v(x, w.y(w, u.u)). The derivation

Γ , z : (C⊃D)⊃B ⇒ z : (C⊃D)⊃B Ax Γ , x : C, y : D⊃B ⇒ dec(x, y, z.z) : E Dec

rewrites to

Γ

Γ , x : C, w : D, u : B ⇒ u : B Ax , x : C, w : D, y : D⊃B ⇒ y(w, u.u) : B

L0⊃

Γ , x : C, y : D⊃B, v : C⊃D ⇒ v(x, w.y(w, u.u)) : B L0⊃

Γ , x : C, y : D⊃B ⇒ λv.v(x, w.y(w, u.u)) : (C⊃D)⊃B R⊃

Also, L = Dm( ) mpo I(I(I( ))) = L , where m = {{Γ , (C⊃D)⊃B, (C⊃D)⊃B}}, by Dm I.

d3 dec(x, y, z.λw.M ) −→d3 λw.dec(x, y, z.M ). The derivation

12

rewrites to

Γ

Γ , z : (C⊃D)⊃B, w : E1 ⇒ M : E2 Γ , z : (C⊃D)⊃B ⇒ λw.M : E1⊃E2

R⊃

, x : C, y : D⊃B ⇒ dec(x, y, z.λw.M ) : E1⊃E2

Dec

Γ Γ,

,x x:

Γ :C C,

, z : (C⊃D)⊃B, w : E1 ⇒ M : E2 , y : D⊃B, w : E1 ⇒ dec(x, y, z.M ) : E2 y : D⊃B ⇒ λw.dec(x, y, z.M ) : E1⊃E2

Dec R⊃

Let m = {{Γ , (C⊃D)⊃B, E1⊃E2}} and n = {{Γ , (C⊃D)⊃B, E1, E2}}. We have

since Dm

L = Dm(I(M )) I, Dn because m >mul n.

mpo I(Dn(M )) = L

d4 dec(x, y, z.w(u.v.M, w .N )) −→d4 w(u.v.dec(x, y, z.M ), w .dec(x, y, z.N )). The derivation

Γ , v : F , u : G⊃H, z : (C⊃D)⊃B ⇒ M : G Γ , w : H, z : (C⊃D)⊃B ⇒ N : E

Γ , w : (F ⊃G)⊃H, z : (C⊃D)⊃B ⇒ w(u.v.M, w .N ) : E

L⊃⊃

Γ , w : (F ⊃G)⊃H, x : C, y : D⊃B ⇒ dec(x, y, z.w(u.v.M, w .N )) : E Dec

rewrites to

Γ , v : F , u : G⊃H, x : (C⊃D)⊃B ⇒ M : G

Γ , w : H, z : (C⊃D)⊃B ⇒ N : E

Γ

, v : F , u : G⊃H, x : C, y : D⊃B ⇒ M : G Dec Γ , w : (F ⊃G)⊃H, x : C, y : D⊃B ⇒

Γ , w : H, x : C, y : D⊃B w(u.v.M , w .N ) : G

⇒

N

:E

Dec L⊃⊃

with M = dec(x, y, z.M ) and N = dec(x, y, z.N ). Let k = {{Γ , (F ⊃G)⊃H, (C⊃D)⊃B, E}} and m = {{Γ , F, G⊃H, (C⊃D)⊃B, G}} and n = {{Γ , H, (C⊃D)⊃B, E}}. We have

since Dk

L = Dk(K(M , N )) mpo K(Dm(M , Dn(N )) = L K, Dm, Dn because k >mul m, n.

d5 dec(x, y, z.w(y , z .M )) −→d5 w(y , z .dec(x, y, z.M )). The derivation

Γ , y : F , z : G, z : (C⊃D)⊃B ⇒ M : E Γ , y : F , w : F ⊃G, z : (C⊃D)⊃B ⇒ w(y , z .M ) : E L0⊃ Γ , y : F , w : F ⊃G, x : C, y : D⊃B ⇒ dec(x, y, z.w(y , z .M )) : E Dec rewrites to

13

Γ , y : F , z : G, z : (C⊃D)⊃B ⇒ M : E Γ , y : F , z : G, x : C, y : D⊃B ⇒ dec(x, y, z.M ) : E Dec Γ , y : F , w : F ⊃G, x : C, y : D⊃B ⇒ w(y , z .dec(x, y, z.M )) : E L0⊃ Let k = {{Γ , F, F ⊃G, (C⊃D)⊃B, E}} and m = {{Γ , F, G, (C⊃D)⊃B, E}}. We have
L = Dk(I(M )) mpo I(Dm(M )) = L since Dk I, Dm because k >mul m.

d6 dec(x, y, z.z(y , z .M )) −→d6 y (x, z .y(z , z .inv(z , y .M ))). The derivation

Γ

Γ , y : C⊃D, z : B ⇒ M : E , z : (C⊃D)⊃B, y : C⊃D ⇒ z(y , z .M ) : E

L0⊃

Γ , x : C, y : D⊃B, y : C⊃D ⇒ dec(x, y, z.z(y , z .M )) : E Dec

rewrites to

Γ

Γ , y : C⊃D, z : B ⇒ M : E , z : D, z : B ⇒ inv(z , y .M ) : E

I nv

Γ , z : D, y : D⊃B ⇒ y(z , z .inv(z , y .M )) : E L0⊃

(W )

Γ , x : C, z : D, y : D⊃B ⇒ y(z , z .inv(z , y .M )) : E Γ , y : C⊃D, x : C, y : D⊃B ⇒ y (x, z .y(z , z .inv(z , y .M ))) : E L0⊃

Also, L = Dk(I(M )) mpo I(I(J(M ))) = L since Dk I, J, where k = {{Γ , (C⊃D)⊃B, C⊃D, E}}.

d7 dec(x, y, z.x (z, z .M )) −→d7 x(u.v.v(x, z .y(z , w.w)), z .dec(x, y, z.M )). The derivation Γ , z : (C⊃D)⊃B, z : A ⇒ M : E Γ , x : ((C⊃D)⊃B)⊃A, z : (C⊃D)⊃B ⇒ x (z, z .M ) : E L0⊃ Γ , x : ((C⊃D)⊃B)⊃A, x : C, y : D⊃B ⇒ dec(x, y, z.x (z, z .M )) : E Dec

rewrites to

... Γ , . . . ⇒ v(x, z .y(z , w.w)) : B

Γ , z : (C⊃D)⊃B, z : A ⇒ M : E Γ , x : C, y : D⊃B, z : A ⇒ dec(x, y, z.M ) : E Dec

Γ , x : ((C⊃D)⊃B)⊃A, y : C, z : D⊃B ⇒ x(u.v.v(x, z .y(z , w.w)), z .dec(x, y, z.M )) : E L⊃⊃

with ﬁrst premiss is constructed as follows

Γ

Γ , x : C, w : B, u : B⊃A, z : D ⇒ w : B Ax , x : C, y : D⊃B, u : B⊃A, z : D ⇒ y(z , w.w) : B

L0⊃

Γ , x : C, y : D⊃B, u : B⊃A, v : C⊃D ⇒ v(x, z .y(z , w.w)) : B L0⊃

14

Let k = {{Γ , (C⊃D)⊃B, ((C⊃D)⊃B)⊃A, E}} and m = {{Γ , (C⊃D)⊃B, A, E}}. We have L = Dk(I(M )) mpo K(I(I( )), Dm(M )) = L
since Dk K, I, , Dm because k >mul m.

d8 dec(x, y, z.z(u.v.M, z .N )) −→d8 cut({y/u}{x/v}M, y .y(y , z .N )). The derivation

rewrites to

Γ

, v : C, u : D⊃B ⇒ M : D

Γ ,z :B ⇒

Γ , z : (C⊃D)⊃B ⇒ z(u.v.M, z .N ) : E

N :E

L⊃⊃

Γ , x : C, y : D⊃B ⇒ dec(x, y, z.z(u.v.M, z .N )) : E Dec

Γ ,z :B ⇒ N :E

(W )

y :D, Γ , x:C, z :B ⇒ N :E

Γ , v : C, u : D⊃B ⇒ M : D

(Ren) y : D, Γ , x : C, y : D⊃B ⇒ y(y , z .N ) : E L0⊃

Γ , x : C, y : D⊃B ⇒ {y/u}{x/v}M : D

Γ , x : C, y : D⊃B ⇒ cut({y/u}{x/v}M, y .y(y , z .N )) : E

C ut

Let k = {{Γ , (C⊃D)⊃B, E}} and j = {{Γ , D, C, D⊃B, E}}. We have

since Dk

L = Dk(K(M , N )) Cj, I because k >mul j.

mpo Cj(M , I(N )) = L

a cut(M, x.x) −→a M . The derivation

rewrites to

Γ

⇒ M :A Γ,x:A ⇒ x:A Γ ⇒ cut(M, x.x) : A

Ax C ut

Γ ⇒ M :A Also, L = Cm(M , ) mpo M = L , where m = {{Γ, A, A}}.

b cut(M, x.y) −→b y. The derivation

rewrites to

Γ

, y:E ⇒ M :A Γ , y:E, x:A ⇒ y:E Γ , y : E ⇒ cut(M, x.y) : E

Ax C ut

Γ ,y:E ⇒ y:E Also, L = Cm(M , ) mpo = L , where m = {{Γ , E, A, E}}.

15

c cut(M, x.λy.N ) −→c λy.cut(M, x.N ). The derivation

Γ

x : A, Γ , y : C ⇒ N : D ⇒ M : A x : A, Γ ⇒ λy.N : C⊃D
Γ ⇒ cut(M, x.λy.N ) : C⊃D

R⊃ C ut

rewrites to

Γ ⇒ M :A Γ,y:C ⇒ M :A
Γ,y:C

(W ) x : A, Γ , y : C ⇒ cut(M, x.N ) : D

⇒

N :D

C ut

Γ ⇒ λy.cut(M, x.N ) : C⊃D R⊃

Let k = {{A, Γ , C⊃D}} and j = {{A, Γ , C, D}}. We have

L = Ck(M , I(N )) mpo I(Cj(M , N )) = L

since Ck I, Cj because k >mul j.

d cut(M, x.z(y, w.N )) −→d z(y, w.cut(inv(w, z.M ), x.N )). The derivation

Γ , y : C, z : C⊃B ⇒ M : A

x : A, Γ , y : C, w : B ⇒ N : E x : A, Γ , y : C, z : C⊃B ⇒ z(y, w.N ) : E

L0⊃

Γ , y : C, z : C⊃B ⇒ cut(M, x.z(y, w.N )) : E

C ut

rewrites to

Γ

Γ , y : C, z : C⊃B ⇒ M : A , y : C, w : B ⇒ inv(w, z.M ) : A

I nv

x : A, Γ , y : C, w : B ⇒ N : E

Γ , y : C, w : B ⇒ cut(inv(w, z.M ), x.N ) : E

C ut

Γ , y : C, z : C⊃B ⇒ z(y, w.cut(inv(w, z.M ), x.N )) : E L0⊃

Let k = {{A, Γ , C, C⊃B, E}} and j = {{A, Γ , C, B, E}}. We have

L = Ck(M , I(N )) mpo I(Cj(J(M ), N ) = L

since Ck I, Cj, J because k >mul j.

e cut(M, x.y(u.v.N, z.N )) −→e y(u.v.cut(dec(v, u, y.M ), x.N ), z.cut(inv(z, y.M ), x.N )). The derivation

Γ , y : (C⊃D)⊃B ⇒ M : A

x : A, Γ , v : C, u : D⊃B ⇒ N : D x : A, Γ , y : (C⊃D)⊃B ⇒

x : A, Γ , z : B ⇒ N y(u.v.N, z.N ) : E

:E

L⊃⊃

Γ , y : (C⊃D)⊃B ⇒ cut(M, x.y(u.v.N, z.N )) : E

C ut

rewrites to

DD

Γ , v : C, u : D⊃B ⇒ cut(dec(v, u, y.M ), x.N ) : D Γ , z : B ⇒ cut(inv(z, y.M ), x.N ) : E

Γ , y : (C⊃D)⊃B ⇒ y(u.v.cut(dec(v, u, y.M ), x.N ), z.cut(inv(z, y.M ), x.N )) : E

L⊃⊃

16

where D is the following derivation:

Γ , y : (C⊃D)⊃B ⇒ M : A

Γ , v : C, u : D⊃B ⇒ dec(v, u, y.M ) : A Dec x : A, Γ , v : C, u : D⊃B ⇒ N : D

Γ , v : C, u : D⊃B ⇒ cut(dec(v, u, y.M ), x.N ) : D

C ut

and D is the following derivation:

Γ , y : (C⊃D)⊃B ⇒ M : A

Γ , z : B ⇒ inv(z, y.M ) : A Inv x : A, Γ , z : B ⇒ N : E

Γ , z : B ⇒ cut(inv(z, y.M ), x.N ) : E

C ut

Let k = {{A, Γ , (C⊃D)⊃B, E}} and j = {{A, Γ , C, D⊃B, D}} and i = {{A, Γ , B, E}} and h = {{Γ , (C⊃D)⊃B, A}}. We have

since Ck

L = Ck(M , K(N , N )) mpo K(Cj(Dh(M ), N ), Ci(J(M ), N ) = L K, J, Cj, Ci, Dh because k >mul j, h, i.

f cut(λz.M, x.y(x, w.N )) −→f y(u.v.cut(u, w.dec(w, v, y.M )), w.cut(inv(w, y.λz.M ), x.N )). The derivation

z : C, Γ , y : (C⊃D)⊃B ⇒ M : D Γ , y : (C⊃D)⊃B ⇒ λz.M : C⊃D R⊃

x : C⊃D, Γ , w : B ⇒ N : E x : C⊃D, Γ , y : (C⊃D)⊃B ⇒ y(x, w.N ) : E

L0⊃

Γ , y : (C⊃D)⊃B ⇒ cut(λz.M, x.y(x, w.N )) : E

C ut

rewrites to

DD

Γ

, u : C, v : D⊃B ⇒ M : D Γ , w : B ⇒ N Γ , y : (C⊃D)⊃B ⇒ y(u.v.M , w.N ) : E

:E

L⊃⊃

where M = cut(u, w.dec(w, v, y.M )), N = cut(inv(w, y.λz.M ), x.N ), D is the following derivation:

u : C, Γ , y : (C⊃D)⊃B ⇒ M : D

Γ , u : C, v : D⊃B ⇒ u : C Ax Γ , u : C, w : C, v : D⊃B ⇒ dec(w, v, y.M ) : D Dec

Γ , u : C, v : D⊃B ⇒ cut(u, w.dec(w, v, y.M )) : D

C ut

and D is the following derivation:

Γ

Γ , y : A⊃B ⇒ λz.M : C⊃D , w : B ⇒ inv(w, y.λz.M ) : C⊃D

I nv

x : C⊃D, Γ , w : B ⇒ N : E

Γ , w : B ⇒ cut(inv(w, y.λz.M ), x.N ) : E

C ut

Let k = {{C⊃D, Γ , (C⊃D)⊃B, E}} and j = {{Γ , C, C, D⊃B, D}} and h = {{C, Γ , (C⊃D)⊃B, D}} and i = {{C⊃D, Γ , B, E}}.

17

We have since Ck

L = Ck(I(M ), I(N )) mpo K(Cj( , Dh(M )), Ci(J(I(M )), N )) = L K, , J, I, Cj, Ci, Dh because k >mul j, i, h.

g cut(x, y.z(y, w.M )) −→g z(y, w.cut(x, y.M )). The derivation

Γ , x : A, z : A⊃B ⇒ x : A Ax

x : A, y : A, w : B, Γ ⇒ M : E x : A, y : A, z : A⊃B, Γ ⇒ z(y, w.M ) : E

L0⊃

Γ , x : A, z : A⊃B ⇒ cut(x, y.z(y, w.M )) : E

C ut

rewrites to

Γ , x : A, w : B ⇒ x : A Ax x : A, y : A, w : B, Γ ⇒ M : E

Γ , x : A, w : B ⇒ cut(x, y.M ) : E

C ut

Γ , x : A, z : A⊃B ⇒ z(y, w.cut(x, y.M )) : E L0⊃

Let k = {{A, A, A⊃B, Γ , E}} and j = {{A, A, B, Γ , E}}.

We have

L = Ck( , I(M )) mpo I(Cj( , M )) = L

since Ck I, Cj because k >mul j.

π cut(z(y, w.M ), x.N ) −→π z(y, w.cut(M, x.inv(w, z.N ))). The derivation

Γ

Γ ,y:C,w:B ⇒ M :A , y : C, z : C⊃B ⇒ z(y, w.M ) : A

L0⊃

x : A, Γ , y : C, z : C⊃B ⇒ N : E

Γ , y : C, z : C⊃B ⇒ cut(z(y, w.M ), x.N ) : E

C ut

rewrites to

x : A, Γ , y : C, z : C⊃B ⇒ N : E

Γ , y : C, w : B ⇒ M : A x : A, Γ , y : C, w : B ⇒ inv(w, z.N ) : E Inv

Γ , y : C, w : B ⇒ cut(M, x.inv(w, z.N )) : E

C ut

Γ , y : C, z : C⊃B ⇒ z(y, w.cut(M, x.inv(w, z.N ))) : E L0⊃

Let k = {{A, Γ , C, C⊃B, E}} and j = {{A, Γ , C, B, E}}.

We have

L = Ck(I(M ), N ) mpo I(Cj(M , J(N )) = L

since Ck I, Cj, J because k >mul j.

φ cut(y(u.v.M, z.M ), x.N ) −→φ y(u.v.M, z.cut(M , x.inv(z, y.N ))). The derivation

Γ

, v : C, u : D⊃B ⇒ M : D Γ , z : B ⇒ M Γ , y : (C⊃D)⊃B ⇒ y(u.v.M, z.M ) : A

:A

L⊃⊃

x : A, Γ , y : (C⊃D)⊃B ⇒ N : E

Γ , y : (C⊃D)⊃B ⇒ cut(y(u.v.M, z.M ), x.N ) : E

C ut

18

rewrites to

Γ ,z:B ⇒ M :A

x : A, Γ , y : (C⊃D)⊃B ⇒ N : E x : A, Γ , z : B ⇒ inv(z, y.N ) : E

Of

Γ , v : C, u : D⊃B ⇒ M : D

Γ , z : B ⇒ cut(M , x.inv(z, y.N )) : E

C ut

Γ , y : (C⊃D)⊃B ⇒ y(u.v.M, z.cut(M , x.inv(z, y.N ))) : E

L⊃⊃

Let k = {{A, Γ , (C⊃D)⊃B, E}} and j = {{A, Γ , B, E}}. We have
L = Ck(K(M , M ), N ) mpo K(M , Cj(M , J(N ))) = L
since Ck K, Cj, J because k >mul j.
A cut(M, x.x(z, w.N )) −→A cut(cut(z, y.of(M, y)), w.N ). The derivation

Γ , z : C ⇒ M : C⊃B

Γ

Γ ,z:C,w:B ⇒ N :E , z : C, x : C⊃B ⇒ x(z, w.N ) : E

L0⊃

Γ , z : C ⇒ cut(M, x.x(z, w.N )) : E

C ut

rewrites to

Γ , z : C ⇒ z : C Ax

Γ

Γ , z : C ⇒ M : C⊃B , z : C, y : C ⇒ of(M, y) : B

Of

Γ , z : C ⇒ cut(z, y.of(M, y)) : B

Cut Γ , z : C, w : B ⇒ N : E

Γ , z : C ⇒ cut(cut(z, y.of(M, y)), w.N ) : E

C ut

Let k = {{Γ , C, C⊃B, E}} and j = {{Γ , C, B, E}} and i = {{Γ , C, C, B}}. We have

L = Ck(M , I(N )) mpo Cj(Ci( , J(M )), N ) = L since k >mul j, i and Ck , J, Cj, Ci.

B cut(M, x.x(u.v.N, z.N )) −→B cut(cut(λu.cut(λy .inv(y , y.of(M, y)), v.N ), y.of(M, y)), z.N ). The derivation

Γ ⇒ M : (C⊃D)⊃B

u : C, v : D⊃B, Γ ⇒ x : (C⊃D)⊃B, Γ

N :D z :B, Γ ⇒ N :E ⇒ x(u.v.N, z.N ) : E

L⊃⊃

Γ ⇒ cut(M, x.x(u.v.N, z.N )) : E

C ut

rewrites to

D Γ ⇒ M : C⊃D

Γ ⇒ M : (C⊃D)⊃B Γ , y : C⊃D ⇒ of(M, y) : B

Of

Γ ⇒ cut(M , y.of(M, y)) : B

Cut z : B, Γ ⇒ N : E

Γ ⇒ cut(cut(M , y.of(M, y)), z.N ) : E

C ut

19

where M = λu.cut(λy .inv(y , y.of(M, y)), v.N ) and D is the following derivation:

Γ ⇒ M : (C⊃D)⊃B Γ , y : C⊃D ⇒ of(M, y) : B

Of

(W )

Γ , u : C, y : C⊃D ⇒ of(M, y) : B

Γ , u : C, y : D ⇒ inv(y , y.of(M, y)) : B Inv

Γ , u : C ⇒ λy .inv(y , y.of(M, y)) : D⊃B R⊃ u : C, v : D⊃B, Γ ⇒ N : D

Γ , u : C ⇒ cut(λy .inv(y , y.of(M, y)), v.N ) : D

C ut

Γ ⇒ λu.cut(λy .inv(y , y.of(M, y)), v.N ) : C⊃D R⊃

Let k = {{(C⊃D)⊃B, Γ , E}} and j = {{B, Γ, E}} and i = {{Γ , C⊃D, B}} and h = {{C, D⊃B, Γ , D}}. We have

L= Ck(M , K(N , N ))

mpo Cj(Ci(I(Ch(I(J(J(M ))), N )), J(M )), N ) =L

since Ck I, J, Cj, Ci, Ch because k >mul j, i, h.

2

Corollary 1 (Strong Normalisation). System gs is strongly normalising on typed terms.

Proof: This is a consequence of Theorem 1 and Remark 3.

2

Corollary 2. Rules Inv, Of, Dec, and Cut are logically admissible in the system of Deﬁnition 4.

Proof: Every term with an auxiliary constructor is reducible by system gs.

2

6 Variants of reduction systems
We investigate in this section some variants of the cut-elimination system presented in Section 3.
We discuss in Section 6.1 the rules of Kind3, noticing that the of( , )-constructor is only introduced by the reductions of gs in order to include η-conversion in the system. We present two variations without η-conversion, called system rs and system ars, that no longer use the of( , )-constructor.
Without η-conversion, the only critical pairs of those variations are between the rules of Kind1 and those of Kind2, so in Section 6.2, which only concerns rules of Kind1 and Kind2, we present two ways of removing those critical pairs, i.e. of making systems rs and ars orthogonal.
All the systems presented in this paper can be summarised in the following table:
20

of, inv and dec cut = (Kind1 + Kind2) +

Kind3

Whole system

oid

cegs = Table 4 +

Table 5

gs

oid

cers = Table 4 +

Table 6

rs

oid

cears = Table 4 +

Table 7

ars

oid

cecbn = Table 8 + (Table 6 or Table 7)

cbn

oid

cecbv = Table 9 + (Table 6 or Table 7)

cbv

6.1 Avoiding the of-constructor

In this section we remove η-expansion from the reduction system so that the of( , )-constructor is no more used by the cut elimination rules. We obtain two variants, depending on whether we want variables to behave like their η-expansions or we want the elimination of a cut with a variable to be simpler and closer to renaming.
The rules A and B of system gs introduce the of( , )-constructor to model η-expansion, turning the ﬁrst argument of the cut into an abstraction.
Theorem 2. Rule A (resp. B) can be factorised into an η-expansion followed by rule C (resp. D) below:

cut(λy.M, x.x(z, w.N ))

−→C cut(cut(z, y.M ), w.N )

cut(λy.M, x.x(u.v.N , w.N )) −→D cut(cut(λu.cut(λz.inv(z, y.M ), v.N ), y.M ), w.N )

Proof:

(Rule A)

cut(M, x.x(z, w.N ))

−→η cut(λy.of(M, y), x.x(z, w.N ))

−→C cut(cut(z, y.of(M, y)), w.N )

(Rule B)

cut(M, x.x(u.v.N , w.N ))

−→η cut(λy.of(M, y), x.x(u.v.N , w.N ))

−→D cut(cut(λu.cut(λz.inv(z, y.of(M, y)), v.N ), y.of(M, y)), w.N )

2

Note that the η-expansion of an abstraction reduces, by direct elimination of the of( , ), to the abstraction itself:

λy.M −→η λx.of(λy.M, x) −→o2 λx.{x/y}M =α λy.M with x ∈/ F V (M )

This justiﬁes the following theorem:

Theorem 3. Rules C and D can be respectively derived from rules A and B using system oid.

Proof:

(Rule C)

cut(λy.M, x.x(z, w.N ))

−→A cut(cut(z, w .of(λy.M, w )), w.N )

−→o2 cut(cut(z, w .{w /y}M ), w.N )

=α cut(cut(z, y.M ), w.N )

(Rule D)

cut(λy.M, x.x(u.v.N , w.N ))

−→B cut(cut(λu.cut(λz.inv(z, w .of(λy.M, w )), v.N ), z .of(λy.M, z )), w.N ) −→∗o2 cut(cut(λu.cut(λz.inv(z, w .{w /y}M ), v.N ), z .{z /y}M ), w.N )

=α cut(cut(λu.cut(λz.inv(z, y.M ), v.N ), y.M ), w.N )

21

2 Similarly, direct elimination of the of( , )-constructor is allowed by rule o1 in the case of a
variable (y −→η λx.of(y, x) −→o1 y(x, z.z) with x ∈/ F V (M )), so this suggests that two rules E and F , treating the case of a variable, can also be derived from rules A and B:
Theorem 4. The following rules E and F can be respectively derived from A and B using system gs:

cut(y, x.x(z, w.N ))

−→E y(z, w .cut(w , w.inv(w , y.N )))

cut(y, x.x(u.v.N , w.N )) −→F y(u .v .cut(u , u.P ), w .cut(w , w.inv(w , y.N )))

where P = dec(u , v , y.cut(λy .y(u.v.y , z.z), v.N ))

Proof:

(Rule E)

cut(y, x.x(z, w.N ))

−→A cut(cut(z, y .of(y, y )), w.N )

−→o1 cut(cut(z, y .y(y , w .w )), w.N )

−→g cut(y(z, w .cut(z, y .w )), w.N )

−→b cut(y(z, w .w ), w.N )

−→π y(z, w .cut(w , w.inv(w , y.N )))

(Rule F )

cut(y, x.x(u.v.N , w.N ))

−→B cut(cut(λu.cut(L, v.N ), y .of(y, y )), w.N ) −→∗ cut(cut(λu.cut(L , v.N ), y .of(y, y )), w.N )

−→o1 cut(cut(λu.cut(L , v.N ), y .y(y , w .w )), w.N ) −→∗ cut(y(u .v .cut(u , u.P ), w .w ), w.N )

−→φ y(u .v .cut(u , u.P ), w .cut(w , w.inv(w , y.N )))

where the ﬁrst −→∗ is justiﬁed by

L = λy .inv(y , w .of(y, w ))

−→o1 λy .inv(y , w .y(w , z.z))

−→i6 λy .y(y1.y2.y , z.inv(y , w .z))

−→i1 λy .y(y1.y2.y , z.z)

=L

and the last −→∗ is justiﬁed by

cut(λu.cut(L , v.N ), y .y(y , w .w ))

−→f y(u .v .cut(u , u.dec(u , v , y.cut(L , v.N ))), w .cut(inv(w , y.λu.cut(L , v.N )), y .w ))

−→b y(u .v .cut(u , u.dec(u , v , y.cut(L , v.N ))), w .w )

= y(u .v .cut(u , u.P ), w .w )

2

Now, by construction, rules E and F make variables have the same functional behaviour as their η-expansion.
Notice also that the new rules C, D, E and F (together with rules π and φ) can now replace any use of rules A and B, thus forming a system, called cers, that is still complete for cut-elimination and makes no use of the of( , )-constructor. We show in Table 6 only the cut reduction rules of Kind3, in which cegs and cers diﬀer, the rules of Kind1 and Kind2 being the same. System cegs can thus be seen as system cers to which η-expansion has been integrated by the use of the auxiliary constructor of( , ).
The behaviour of functionals is interesting in G4ip, because it is a depth-bounded calculus. For instance, among all Church’s numerals, only 0 and 1 can be represented in G4ip, so

22

Kind3

cut(λy.M, x.x(z, w.N ))

−→C cut(cut(z, y.M ), w.N )

cut(λy.M, x.x(u.v.N , w.N )) −→D cut(cut(λu.cut(λz.inv(z, y.M ), v.N ), y.M ), w.N )

cut(y, x.x(z, w.N ))

−→E y(z, w .cut(w , w.inv(w , y.N )))

cut(y, x.x(u.v.N , w.N )) −→F y(u .v .cut(u , u.P ), w .cut(w , w.inv(w , y.N )))

where P = dec(u , v , y.cut(λy .y(u.v.y , z.z), v.N ))

Table 6. Cut Elimination Rules in System cers (Kind3)

when reducing the term that represents (using cuts) “1 + 1”, we should expect some semantical anomaly in the reductions (which is quite similar to the one reported by Vestergaard in [Ves99]). Such an anomaly is to be found in rules B and D, and for abstractions we have no alternative choice. However in system rs we have made the choice of making variables have the same functional behaviour as their η-expansions, hence rule F inherits the anomaly. But instead we might rather follow the intuition that cutting a variable with a another variable is almost renaming, and replace rule F with a new rule G, thus forming system cears presented in Table 7 (again we only show rules of Kind3, but rules of Kind1 and Kind2 are the same as in cegs or cers). This new rule is simpler and more natural than rule F ; however the reducts are semantically diﬀerent and thus the choice of rule G breaks the property that a variable and its η-expansion have the same behaviour.

Kind3

cut(λy.M, x.x(z, w.N ))

−→C cut(cut(z, y.M ), w.N )

cut(λy.M, x.x(u.v.N , w.N )) −→D cut(cut(λu.cut(λz.inv(z, y.M ), v.N ), y.M ), w.N )

cut(y, x.x(z, w.N ))

−→E y(z, w .cut(w , w.inv(w , y.N )))

cut(y, x.x(u.v.N , w.N )) −→G y(u .v .cut(u , u.P ), w .cut(w , w.inv(w , y.N )))

where P = cut(v , v.dec(u , v , y.N ))

Table 7. Cut Elimination Rules in System cears (Kind3)

Since all the rules of system rs are derived from system gs, it is clear that the former inherits from the latter the Subject Reduction property as well as the Strong Normalisation of typed terms. However, for system ars, those properties are not inherited, so we have to check that rule G satisﬁes the Subject Reduction property and decreases the multi-set path ordering from Section 4.

cut(y, x.x(u.v.N , w.N )) −→G y(u .v .cut(u , u.P ), w .cut(w , w.inv(w , y.N )))

Let Γ = Γ , y : (C⊃D)⊃B. The derivation

23

Γ ⇒ y : (C⊃D)⊃B

Γ, u : C, v : D⊃B ⇒ Γ, x : (C⊃D)⊃B

N :D Γ, w :B ⇒ N :E ⇒ x(u.v.N , w.N ) : E

L⊃⊃

Γ ⇒ cut(y, x.x(u.v.N , w.N )) : E

C ut

rewrites to

Γ

,u

:C, v

: D⊃B ⇒ u : C Ax Γ , u : C, v : D⊃B

L Γ , u : C, u : C, v : D⊃B
⇒ cut(u , u.P ) : D

⇒

P

:D

C ut

L Γ ,w :B ⇒ M :E

Γ , y : (C⊃D)⊃B ⇒ y(u .v .cut(u , u.P ), w .L ) : E

L⊃⊃

where M = cut(w , w.inv(w , y.N )), the premiss L is constructed as follows:

Γ , y : (C⊃D)⊃B, u : C, v : D⊃B ⇒ N : D

Γ , u : C, u : C, v : D⊃B ⇒ v : D⊃B Γ , u : C, v : D⊃B, u : C, v : D⊃B ⇒ dec(u , v , y.N ) : D Dec

Γ , u : C, u : C, v : D⊃B ⇒ cut(v , v.dec(u , v , y.N )) : D

C ut

and the second premiss L is constructed as follows:

Γ , y : (C⊃D)⊃B, w : B ⇒ N : E

Γ , w : B ⇒ w : B Γ , w : B, w : B ⇒ inv(w , y.N ) : E Inv

Γ , w : B ⇒ cut(w , w.inv(w , y.N )) : E

C ut

Let k = {{Γ , (C⊃D)⊃B, (C⊃D)⊃B, E}} and i = {{Γ , B, B, E}} and j = {{Γ , C, C, D⊃B, D}} and h = {{Γ , C, D⊃B, C, D⊃B, D}} and l = {{Γ , (C⊃D)⊃B, C, D⊃B, E}} and
We have

cut(y, x.x(u.v.N , w.N ))
= Ck( , K(N , N ))

mpo K(Cj( , Ch( , Dl(N ))), Ci( , J(N ))) =
y(u .v .cut(u , u.P ), w .cut(w , w.inv(w , y.N )))

since Ck K, Cj, Ch, Dl, Ci because k >mul i, j, h, l.

6.2 Orthogonal systems
In this section we suggest two ways of restricting the rules of Kind1 and Kind2 to make systems rs and ars orthogonal, and hence conﬂuent.
In the restricted systems gs and ars there is an overlap between the right and left propagation sub-systems, i.e. there is a critical pair between any rule in {a, b, c, d, e} and any rule any in {π, φ}. This is shown in the following table, where column headers represent the diﬀerent cases concerning the ﬁrst premiss of the cut, while row headers represent the diﬀerent cases for the second one (marking inside parentheses the status of the cut-type).

24

Axiom R⊃ L0⊃ L⊃⊃

Axiom (Principal)

a a aπ aφ

Axiom (Non-Principal)

b b bπ bφ

R⊃ c c cπ cφ

L0⊃ (Non-Principal, Non-Auxiliary) d

d

dπ

dφ

L⊃⊃ (Non-Principal)

e e eπ eφ

L0⊃ (Non-Principal, Auxiliary)

gf

π

φ

L0⊃ (Principal)

EC

π

φ

L⊃⊃ (Principal)

F or G D

π

φ

This overlap is well-known in sequent calculus, and corresponds to the choice of whether to push a cut into the proof of its left premiss or into the proof of its right premiss. The former corresponds to a call-by-value strategy and the latter corresponds to a call-by-name strategy.
Since the overlap only concerns cut reduction rules of Kind1 and Kind2, we shall only study those kinds of rules and leave the rules of Kind3 as they are in system cers or in system cears since both are possible.
Call-by-name One way to make the system orthogonal is to give preference to rules a-b-cd-e over rules π-φ, thus restricted to the case when N is an x-covalue Q, i.e. is of the form x(y, w.N ) or x(u.v.M, w.N ). We show the resulting reduction rules of Kind1 and Kind2 in Table 8.

Kind1

cut(M, x.x)

−→a M

cut(M, x.y)

−→b y

cut(M, x.λy.N )

−→c λy.cut(M, x.N )

cut(M, x.y(z, w.N ))

−→d y(z, w.cut(inv(w, y.M ), x.N ))

cut(M, x.y(u.v.N , w.N )) −→e y(u.v.cut(dec(u, v, y.M ), x.N ), w.cut(inv(w, y.M ), x.N ))

cut(λz.M, x.y(x, w.N )) −→f y(u.v.cut(u, z.dec(u, v, y.M )), w.cut(inv(w, y.λz.M ), x.N ))

cut(z, x.y(x, w.N ))

−→g y(z, w.cut(z, x.N ))

Kind2

cut(y(z, w.M ), x.Q)

−→π y(z, w.cut(M, x.inv(w, y.Q)))

cut(y(u.v.M , w.M ), x.Q) −→φ y(u.v.M , w.cut(M, x.inv(w, y.Q)))

Table 8. Cut Elimination Rules in system cecbn (Kind1 and Kind2)

Notice that in order to reduce a term like cut(M, x.y(x, w.N )), there is no choice other than left-propagation (rules π and φ) until a similar redex is found in which M is a value, and then only rules f or g can be applied.
25

Axiom

Axiom (Principal)

a

Axiom (Non-Principal)

b

R⊃ c

L0⊃ (Non-Principal, Non-Auxiliary) d

L⊃⊃ (Non-Principal)

e

L0⊃ (Non-Principal, Auxiliary)

g

L0⊃ (Principal)

E

L⊃⊃ (Principal)

F (G)

R⊃ a b c d e f C D

L0⊃ a b c d e π π π

L⊃⊃ a b c d e φ φ φ

Call-by-value Alternatively, preference might be given to rules π and φ, which we can formalise as restricting rules a-b-c-d-e to the case when M is a value V (variable or abstraction). We show the resulting reduction rules of Kind1 and Kind2 in Table 9.

Kind1

cut(V, x.x) cut(V, x.y) cut(V, x.λy.N ) cut(V, x.y(z, w.N )) cut(V, x.y(u.v.N , w.N ))

−→a V −→b y −→c λy.cut(V, x.N ) −→d y(z, w.cut(inv(w, y.V ), x.N )) −→e y(u.v.cut(dec(u, v, y.V ), x.N ), w.cut(inv(w, y.V ), x.N ))

cut(λz.M, x.y(x, w.N )) −→f y(u.v.cut(u, z.dec(u, v, y.M )), w.cut(inv(w, y.λz.M ), x.N ))

cut(z, x.y(x, w.N ))

−→g y(z, w.cut(z, x.N ))

Kind2

cut(y(z, w.M ), x.N )

−→π y(z, w.cut(M, x.inv(w, y.N )))

cut(y(u.v.M , w.M ), x.N ) −→φ y(u.v.M , w.cut(M, x.inv(w, y.N )))

Table 9. Cut Elimination Rules in system cecbv (Kind1 and Kind2)

This choice is particularly coherent because the two rules of right-propagation f and g only

apply to cuts whose ﬁrst argument is a value. This suggests that G4ip has an inherent call-by-

value ﬂavour, echoing the idea that it is somehow based on the call-by-value sequent calculus

LJQ. Indeed, completeness of LJQ gives a short proof of the completeness of G4ip [DL06].

Axiom R⊃ L0⊃ L⊃⊃

Axiom (Principal)

aa

π

φ

Axiom (Non-Principal)

bb

π

φ

R⊃

cc

π

φ

L0⊃ (Non-Principal, Non-Auxiliary) d

d

π

φ

L⊃⊃ (Non-Principal)

ee

π

φ

L0⊃ (Non-Principal, Auxiliary)

gf

π

φ

L0⊃ (Principal)

EC

π

φ

L⊃⊃ (Principal)

F (G) D

π

φ

We ﬁnish this section by stating the following property of the orthogonal systems presented

here.

26

Theorem 5. Reduction systems cbn and cbv are conﬂuent, hence normal forms are unique.

Proof: Systems cbn and cbv can be seen as particular orthogonal CRS, so they enjoy con-

ﬂuence (see [vOvR94] for details).

2

7 Another proof of strong normalization
We present here a second proof of strong normalization.
Lemma 2. If N ∈ SNgs, then inv(x, y.N ) ∈ SNgs. Proof. By induction on N, |N | w.r.t the lexicographic order →, > .
Lemma 3. If N ∈ SNgs, then of(N, x) ∈ SNgs. Proof. By induction on N, |N | w.r.t the lexicographic order →, > .
Lemma 4. Suppose Γ , z : A N : E and N ∈ SNgs. Then 1. If A = (C⊃D)⊃B, and x, y are fresh, then dec(x, y, z.N ) ∈ SNgs; 2. Let Γ M : A with M ∈ SNgs; then cut(M, z.N ) ∈ SNgs. Proof. By simultaneous induction on tuples ({{Γ , A, E}}, N, M w.r.t. the lexicographic order >multiset, →, → . Theorem 6. If Γ M : A, then M ∈ SNgs. Proof. By induction on the structure of M using Lemmas 2, 3 and 4.
Theorem 7. If Γ M : A, then M ∈ SNrs. Proof. This is evident since every rs-reduction step can be simulated by a non-empty sequence in gs.
Theorem 8. If Γ M : A, then M ∈ SNars. Proof. One can do the same proof as in Theorem 6 by remarking that rule G also decreases the measure of sequents.

27

8 Conclusion
This paper deﬁnes various proof-term calculi for the depth-bounded intuitionistic sequent calculus of Hudelmaier. Using standard techniques of rewriting, we prove subject-reduction and strong normalisation for all of them, so Cut-admissibility turns out to be a corollary. The cbn and cbv systems presented in this paper are also orthogonal, which guarantees conﬂuence (and uniqueness of normal forms).
Some relations between G4ip and other calculi for intuitionistic logic are studied in [DL06]. Our approach also suggests how to obtain a term calculus for G4ip but (as in λ-calculus) with implicit, rather than explicit, operators to model cut-elimination. This would bring our calculus closer to that of Matthes [Mat02], and with a strong normalising cut-elimination procedure. As mentioned in the introduction, deﬁning a denotational semantics for our calculi as well as investigating the connexions with the simply-typed λ-calculus would reveal more properties of the proofs in G4ip. This is left for further investigations.
References
[BN98] F. Baader and T. Nipkow. Term Rewriting and All That. Cambridge University Press, 1998. [DL06] R. Dyckhoﬀ and S. Lengrand. LJQ, a strongly focused calculus for intuitionistic logic, 2006. Sub-
mitted. Available at http://www.pps.jussieu.fr/~lengrand/Work/Papers.html. [DM79] N. Dershowitz and Z. Manna. Proving termination with multiset orderings. Communications of the
ACM, 22(8):465–476, 1979. [DN00] R. Dyckhoﬀ and S. Negri. Admissibility of structural rules for contraction-free systems of intuition-
istic logic. The Journal of Symbolic Logic, 65(4):1499–1518, 2000. [Dyc92] R. Dyckhoﬀ. Contraction-free sequent calculi for intuitionistic logic. The Journal of Symbolic Logic,
57(3):795–807, 1992. [Hud89] J. Hudelmaier. Bounds for Cut Elimination in Intuitionistic Logic. PhD thesis, Universita¨t Tu¨bingen,
1989. [Hud92] J. Hudelmaier. Bounds on cut-elimination in intuitionistic propositional logic. Archive for Mathe-
matical Logic, 31:331–354, 1992. [KL80] S. Kamin and J.-J. L´evy. Attempts for generalizing the recursive path orderings. Handwritten paper,
University of Illinois, 1980. [LSS91] P. Lincoln, A. Scedrov, and N. Shankar. Linearizing intuitionistic implication. In Proc. of the Sixth
Annual IEEE Symposium on Logic in Computer Science, pages 51–62, Amsterdam, The Netherlands, 1991. [Mat02] R. Matthes. Contraction-aware lambda-calculus, 2002. Seminar at Oberwolfach. [O’D77] M. J. O’Donnell. Computing in Systems Described by Equations, volume 58 of Lecture Notes in Computer Science. Springer-Verlag, 1977. [ORK05] J. Otten, T. Raths, and C. Kreitz. The ILTP Library: Benchmarking automated theorem provers for intuitionistic logic. In B. Beckert, editor, International Conference TABLEAUX-2005, volume 3702 of Lecture Notes in Artiﬁcial Intelligence, pages 333–337. Springer Verlag, 2005. [Pit92] A. M. Pitts. On an interpretation of second order quantiﬁcation in ﬁrst-order intuitionistic propositional logic. Journal of Symbolic Logic, 57:33–52, 1992. [TS00] A. S. Troelstra and H. Schwichtenberg. Basic Proof Theory. Cambridge University Press, 2000. [Ves99] R. Vestergaard. Revisiting Kreisel: A computational anomaly in the Troelstra-Schwichtenberg G3i system, March 1999. Available at http://www.cee.hw.ac.uk/~jrvest/. [Vor70] N. N. Vorob’ev. A new algorithm for derivability in the constructive propositional calculus. American Mathematical Society Translations, 94(2):37–71, 1970. [vOvR94] V. van Oostrom and F. van Raamsdonk. Weak orthogonality implies conﬂuence: the higher-order case. In A. Nerode and Y. Matiyasevich, editors, Proceedings of the 3rd International Symposium on Logical Foundations of Computer Science, volume 813 of Lecture Notes in Computer Science, pages 379–392. Springer-Verlag, July 1994.
28

