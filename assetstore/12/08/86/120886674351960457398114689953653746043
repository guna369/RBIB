Polymorphic Bytecode: Compositional Compilation for Java-like Languages

Davide Ancona
DISI - Universita` di Genova
davide@disi.unige.it
Sophia Drossopoulou
Dep. of Computing - Imperial College
sd@doc.ic.ac.uk

Ferruccio Damiani
Dip. di Informatica - Universita` di Torino
damiani@di.unito.it
Elena Zucca
DISI - Universita` di Genova
zucca@disi.unige.it

ABSTRACT
We deﬁne compositional compilation as the ability to typecheck source code fragments in isolation, generate corresponding binaries, and link together fragments whose mutual assumptions are satisﬁed, without reinspecting the code. Even though compositional compilation is a highly desirable feature, in Java-like languages it can hardly be achieved. This is due to the fact that the bytecode generated for a fragment (say, a class) is not uniquely determined by its source code, but also depends on the compilation context.
We propose a way to obtain compositional compilation for Java, by introducing a polymorphic form of bytecode containing type variables (ranging over class names) and equipped with a set of constraints involving type variables. Thus, polymorphic bytecode provides a representation for all the (standard) bytecode that can be obtained by replacing type variables with classes satisfying the associated constraints.
We illustrate our proposal by developing a typing and a linking algorithm. The typing algorithm compiles a class in isolation generating the corresponding polymorphic bytecode fragment and constraints on the classes it depends on. The linking algorithm takes a collection of polymorphic bytecode fragments, checks their mutual consistency, and possibly simpliﬁes and specializes them. In particular, linking a self-contained collection of fragments either fails, or produces standard bytecode (the same as what would have been produced by standard compilation of all fragments).
Categories and Subject Descriptors: D.3.3[Programming languages]: Language constructs and features—classes and objects; D.3.1[Programming languages]: Formal deﬁnitions and theory—syntax, semantics; D.3.4[Programming languages]: Processors—incremental compilers
General Terms: languages, theory, design
Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for proﬁt or commercial advantage and that copies bear this notice and the full citation on the ﬁrst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a fee. POPL’05, January 12–14, 2005, Long Beach, California, USA. Copyright 2005 ACM 1-58113-830-X/05/0001 ...$5.00.

Keywords: type systems, compositional analysis
1. INTRODUCTION
Compilers have two main tasks: To check that the source code adheres to the language rules (which usually means that it typechecks), and to produce target code.
Originally, compilers would process the complete source of an application; thus they would apply global compilation. In strongly typed languages execution of a globally compiled application is guaranteed to be type safe.
In the 70s, inspired by Parnas’s ideas about abstract data types, languages like Mesa, LIS, Modula-2, and Ada introduced separate compilation, whereby an application would consist of fragments (e.g., modules, packages, or classes).1 A fragment would be compiled separately in the context of other, used fragments. The produced target code fragment would reﬂect these used fragments, that is, it would reﬂect the compilation environment in which it was created.
An application would be put together through safe linking of target fragments; linking of target fragments was legal only with target fragments which corresponded to the compilation environment in which the former was created. Thus, linking preserved a correspondence between the compilation and the execution environment, and the ensuing application would correspond to a globally compiled one, and have the same type safety guarantees.
In recent years, Java and C have adopted the separate compilation approach, however combined with dynamic linking, whereby fragments (in this case, classes in binary form) are loaded lazily at run-time. Thus, dynamic linking does not attempt to preserve a correspondence between the compilation and the execution environment, nor does the ensuing application correspond to a globally compiled one; type safety can only be achieved through runtime veriﬁcation checks.
Thus, we argue that in Java (and C too) there is a clash of philosophy between compilation and execution. Namely, the adoption of separate compilation means that the target fragments reﬂect the compilation environment in which they
1Separate compilation should not be confused with independent compilation, introduced by FORTRAN II, which does not use type information from the used fragments, and thus does not guarantee type-safety [15].

were created, while the adoption of dynamic linking means that there is no correspondence between compilation and execution environment.
For example, compilation of the source method declaration mds:
E m(B x){ return x.f1.f2; }
in an environment ∆1 containing class B with ﬁeld f1 of type C, and class C with ﬁeld f2 of type E, generates bytecode mdb1 with annotations which reﬂect the classes where ﬁelds were found and their types, that is:
E m(B x){ return x[B.f1 C][C.f2 E]; }
On the other hand, compilation of mds in an environment ∆2 containing a class B with a ﬁeld f1 of type D, and a class D with a ﬁeld f2 of type F, for some F subclass of E, generates a diﬀerent bytecode mdb2:
E m(B x){ return x[B.f1 D][D.f2 F] }
More importantly, execution of mdb1 in the environment ∆2 will throw a FieldNotFoundException, even though compilation and subsequent execution of mds in the environment ∆2 would be successful.2
Thus, given the lazy nature of Java dynamic linking, separate compilation is, in some sense, too eager, and too context dependent.
In this paper, we consider, instead, compositional compilation, whereby target fragments do not reﬂect the compilation environment in which they were created, while linking produces an application which corresponds to a globally compiled one, and which, therefore, has all its type safety guarantees.
We deﬁne compositional compilation to be the ability to typecheck source code fragments in isolation, to generate corresponding binaries, and to link together fragments whose mutual assumptions are satisﬁed, without reinspecting the code.
We illustrate a new approach to compilation and linking for Java-like languages, which will support compositional compilation. We propose a polymorphic form of bytecode containing type variables (ranging over class names) and equipped with a set of constraints involving type variables. Thus, polymorphic bytecode provides a representation for all the (standard Java) bytecode that can be obtained by replacing type variables with class names satisfying the associated constraints.
In terms of our example, mds can be compiled in isolation; the set of polymorphic constraints associated with mds is { φ(B, f1, α), φ(α, f2, β), β ≤ E }, where α, β are type variables, and a constraint of the shape φ(t, f, t ) expresses that type t is expected to declare or inherit a ﬁeld f of type t . Furthermore, the following polymorphic bytecode mdb would be generated:
E m(B x){ return x[B.f1 α][α.f2 β]; }
Our approach also supports linking, which checks whether the polymorphic bytecode of the various fragments satisﬁes
2This example shows, in a sense, the most simple case of dependency of generated bytecode on the context; Java features such as method overloading and ﬁeld hiding complicate matters even further, but the essence of the problem remains the same.

each other’s requirements, without inspecting the code itself. The process involves the replacement of some type variables by concrete class names. In our example, linking mdb in the environment ∆1 leads to mdb1, linking mdb in the environment ∆2 leads to mdb2.
The rest of the paper is organized as follows. In Section 2 we deﬁne a schema formalizing global and compositional compilation, introduce the notions of soundness and completeness of compositional compilation w.r.t. global compilation, and give suﬃcient conditions for guaranteeing them. These conditions place requirements on the linking process, and on the relation between global and compositional compilation of one class. In Sections 3 and 4 we instantiate the schema to model global compilation and compositional compilation for a small Java-like language [9]. In Section 5 we give an algorithm for linking which satisﬁes the properties required by the theorems in Section 2. Finally, in Section 6 we discuss related work and in the Conclusion applicability of our approach and further work.
A preliminary version of the material from this paper appeared in [1]. Proofs of the main results can be found in an extended version of this work [2].
2. FORMALIZING COMPILATION
In this section we deﬁne a schema formalizing both global and compositional compilation.
We start by listing the basic syntactic categories and judgments such a type system should deﬁne. We use a Javaoriented terminology, since a signiﬁcant class of languages on which the schema could be instantiated are Java-like (in particular, in the next sections we present an instance which deﬁnes global and compositional compilation for Featherweight Java [9]). However, the schema is much more general, and is appropriate for any language where, roughly speaking, generated binary code is context-dependent. Hence, “class” below can be thought of, in general terms, as “language entity”.
• Source and binary class declarations (s and b).
• Source fragments (S), which are sequences of source class declarations; and binary fragments (B), which are sequences of binary class declarations.
• Class type environments (∆), which are sequences of class type assignments (δ). A class type assignment can be thought of as the type information which can be extracted from a class declaration (hence the metavariables ∆ and δ); thus a class type environment corresponds to a sequence of source class declarations deprived of bodies.
• Global compilation (of a class), ∆ g s : δ | b, to be read: The source class declaration s has type δ and compiles to b in the class type environment ∆.
• Type constraint environments (Γ), which are sequences of type constraints (γ). A type constraint expresses expectations from used classes, e.g., that a given class has a ﬁeld of a given type.
• Compositional compilation (of a class), c s : δ | Γ | b, to be read: The source class declaration s has type δ and compiles to b under the type constraints in Γ.

• Linking, ∆ Γ | B Γ | B , to be read: In the class type environment ∆ the type constraints Γ are simpliﬁed into Γ , and the binary fragment B becomes B.
Empty class type environments and empty type constraint environments will be denoted by Λ.
The ingredients from above model two diﬀerent approaches to compilation.
In the ﬁrst approach, code fragments are compiled in the context of full type information on other fragments (formalized by the class type environment ∆), as shown by the rules in Fig.1. The global compilation (of a fragment) judgment ∆ G S : ∆ | B means that in ∆ the fragment S has type ∆ and compiles to B. Here ∆ represents (full) type information related to classes which are not being compiled, such as libraries. In particular, Λ G S : ∆ | B models the compilation of a self-contained fragment.

∆δ g s : δ | b (g-frag1) ∆ G s : δ | b

∆ ∆1 ... ∆i−1 ∆i+1 ... ∆n G Si :

(g-frag2)

∆ G S1 ... Sn : ∆1 ... ∆n

∆i | Bi ∀i ∈ 1..n | B1 ... Bn

n≥2

Figure 1: Global compilation of a fragment

In the second approach, code fragments can be compiled in isolation producing binary code equipped with type constraints (both the binary code and the type constraints might contain type variables denoting yet unknown classes). Then, it is possible to link together a successfully compiled collection of fragments, obtaining, if their mutual requirements are compatible, a new binary fragment with simpliﬁed type constraints. Notice that this check does not depend on the source code. This is shown by the rules in Fig.2. The compositional compilation (of a fragment) judgment C S : ∆ | Γ | B means that the source fragment S has type ∆ and compiles to B under the type constraints in Γ.

cs : δ|Γ |b δ Γ |b Γ|b (c-frag1) C s : δ | Γ | b

C Si : ∆i | Γi | Bi ∀i ∈ 1..n ∆1 ... ∆n Γ | B Γ | B (c-frag2) C S1 ... Sn : ∆1 ... ∆n | Γ | B

n≥2
i∈1..n
(Γ ,B )= ⊕ (Γi, Bi)

Figure 2: Compositional compilation of a fragment

In rule (c-frag2), we assume an operator ⊕ which, given a sequence of (at least two) pairs consisting of a type constraint environment and a binary fragment, gives a new pair, intuitively obtained by combining them avoiding interferences (typically, this operator will eliminate clashes in type variables, through α-renaming.)
Iterating this process, we will eventually obtain a fragment for which no type constraints are left, that is, a judgment

C S : ∆ | Λ | B. This means that we have obtained a selfcontained fragment. In this case, we expect to have obtained the same result as global compilation, that is, compositional compilation to be sound w.r.t. global compilation, and conversely, that is, compositional compilation to be complete w.r.t. global compilation. As a ﬁrst approximation, soundness and completeness could be expressed as follows:
C S : ∆ | Λ | B if and only if Λ G S : ∆ | B.
However, since compositional compilation is obviously expected to be incremental, and since global compilation allows for the import of some library classes, whose binary may be available, but whose source may not be available, the claim above should be generalized in order to deal with open source fragments, that is, fragments where some needed class is missing.
We say that a class type environment ∆ is consistent (w.r.t. global compilation) if Λ G S : ∆ | B for some S, B.3
Deﬁnition 1. We say that compositional compilation is sound w.r.t. global compilation iﬀ for consistent ∆ ∆:
C S : ∆ | Γ | B, and ∆ ∆ Γ | B Λ | B imply ∆ G S : ∆ | B .
We now state suﬃcient conditions for soundness. These conditions (and analogously those which guarantee completeness later on) provide a general schema for proving that compositional compilation is sound (resp. complete). Indeed, they allow to split the proof in two parts: First, checking that compositional compilation of a single class is sound and complete — conditions (1) in Theorems 4 and 6. Second, checking that linking satisﬁes some requirements of well-behaviour — conditions (2) and (3) in Theorems 4 and 6. In particular, conditions (2) are related to vertical (sequential) composition and conditions (3) to horizontal composition of linking steps. Conditions (2) require that, whenever two linking steps in sequence allow to eliminate all type constraints, and the latter requires more type information on classes, then starting with this richer type information the two steps can be combined in just one step; conversely, given a linking step which allows to eliminate all type constraints under some type information on classes, if we start with only partial type information it is always possible to perform a partial simpliﬁcation of type constraints. Conditions (3) require that, whenever a linking step allows to eliminate a combination of type constraint environments, it is always possible to eliminate each component, and conversely. Finally, condition (4) in Theorem 4 is just a trivial requirement needed to express soundness for closed fragments as a particular case of soundness.
Note that, in order to prove soundness and completeness, it is not necessary that linking is well-behaved for all type constraint environments, but only for those which can be obtained through the compilation and linking process. This is formalized by the following deﬁnition:
Deﬁnition 2. Relevant type constraint environments are inductively deﬁned by the following clauses:
• if c s : δ | Γ | b holds for some s, δ, b, then Γ is relevant;
3This deﬁnition assumes the fact that libraries used in global compilation have been obtained by correctly compiling some code.

• if Γ is relevant and ∆ Γ | B Γ | B holds for some ∆, B, B , then Γ is relevant;
i∈1..n
• if Γ1, ..., Γn are relevant and (Γ,B) = ⊕ (Γi, Bi) for some B, B1, ..., Bn, then Γ is relevant.
Fact 3. If C S : ∆ | Γ | B holds for some S, ∆, B, then Γ is relevant.
Theorem 4 (Sufficient conditions for soundness). Compositional compilation is sound w.r.t. global compilation if the following conditions hold:

S ::= s1 . . . sn s ::= class c extends c { fds mdss } (c = Object) fds ::= c1 f1; ... cn fn; mdss ::= mds1 ... mdsn mds ::= mh {return es;} mh ::= c0 m(c1 x1 ... cn xn) es ::= x | es.f | es0.m(es1 ... esn) |
new c(es1 ... esn) | (c)es
where ﬁeld, method and parameter names in fds, mdss and mh are distinct

1. c s : δ | Γ | b , and ∆ δ Γ | b Λ | b, and ∆ δ consistent imply ∆ δ g s : δ | b.

Figure 3: Source language

2. Γ relevant, ∆2 Γ | B

Γ | B , and ∆1∆2

Γ | B Λ | B imply ∆1 ∆2 Γ | B Λ | B.

for the minor diﬀerence that here class constructors are implicitly declared. Every class can contain instance ﬁeld and

i∈1..n
3. ∆ Γ | B Λ | B , and (Γ,B) = ⊕ (Γi, Bi) for some B1, ..., Bn and Γ1, ..., Γn relevant, implies ∆ Γi | Bi

method declarations and has only one constructor whose parameters correspond to all class ﬁelds (both inherited and declared) in the order of declaration. In class declarations

Λ | Bi, for some Bi, for all i ∈ 1..n, and B = B1 ... Bn.

we assume that the name of the class c cannot be Object.

4. Λ Λ | B Λ | B for all B.

Method overloading and ﬁeld hiding are not supported. Expressions are variables, ﬁeld access, method invocation, in-

Deﬁnition 5. We say that compositional compilation is
complete w.r.t. global compilation iﬀ ∆ G S : ∆ | B implies ∃ B, Γ s.t. C S : ∆ | Γ | B and ∆ ∆ Γ | B Λ | B .

stance creation and casting; the keyword this is considered a special variable. Finally, in order to simplify the presentation, we assume ﬁeld names in fds, method names in mdss, parameter names in mh to be distinct.
In Fig.4 we give the syntax of bytecode generated by

Theorem 6 (Sufficient conditions for completeness).global compilation — that is (an abstraction of) standard

Compositional compilation is complete w.r.t. global compi-

Java bytecode.

lation if the following conditions hold:

1. ∆ δ g s : δ | b implies ∃ b , Γ s.t.
c s : δ | Γ | b and ∆ δ Γ | b Λ | b.
2. Γ relevant and ∆1 ∆2 Γ | B Λ | B imply ∃ Γ , B s.t. ∆2 Γ | B Γ | B and ∆1 ∆2 Γ | B Λ | B.
3. Γi relevant and ∆ Γi | Bi Λ | Bi, for i ∈ 1..n, with
i∈1..n
⊕ (Γi, Bi) = (Γ, B), imply ∆ Γ | B Λ | B1 ... Bn.
Note that theorems 4 and 6 imply soundness and completeness for closed fragments. Namely, if we take ∆ = Λ = Γ, applying (4) from theorem 4 we get soundness for closed fragments:
C S : ∆ | Λ | B implies Λ G S : ∆ | B.
On the other hand, for ∆ = Λ, if there exist B, Γ s.t. C S : ∆ | Γ | B and ∆ Γ | B Λ | B , we get C S : ∆ | Λ | B by applying rule (c-frag2), and hence we
obtain completeness for closed fragments:
Λ G S : ∆ | B implies C S : ∆ | Λ | B.
3. FJ GLOBAL COMPILATION
In this section, we formalize global compilation of a small Java-like language. This models both standard type checking for Java-like languages (see, e.g., [9, 16]), as well as bytecode generation (as already in, e.g., [4, 8]).
The syntax of the (source) language is deﬁned in Fig.3. It is basically Featherweight Java [9] (FJ in the sequel) hence a functional subset of Java with no primitive types, except

B ::= b1 ... bn b ::= class c extends c { fds mdsb } mdsb ::= mdb1 ... mdbn mdb ::= mh {return eb;} eb ::= x | eb[c.f c ] | eb0[c.m(c¯)c ](eb1 ... ebn)
| new [c c¯](eb1 ... ebn) | (c)eb c¯ ::= c1 ... cn
where fds and mh are deﬁned in Fig.3 and method names in mdsb are distinct
Figure 4: (Abstract) standard bytecode
Our notion of bytecode is abstract, since the only diﬀerences between source code and bytecode of interest here are the annotations needed by the JVM veriﬁer — recall that in Java bytecode a ﬁeld access is annotated with the static type of the receiver and the type of the ﬁeld, a method invocation with the static type of the receiver, the type of the parameters and the return type, and an instance creation with the type of the parameters.
In Fig.5 we deﬁne class type assignments. A class type assignment collects the type information needed for compiling other classes which can be extracted from a class declaration; it is a 4-tuple consisting of the name of the class, the name of the parent class, the set of ﬁeld signatures (type and name of declared ﬁelds) and the set of method signatures (return type, name and parameter types of declared methods).
We assume the existence of a function type extracting type

δ ::= (c, c , fss, mss) fss ::= {fs1, . . . , fsn} fs ::= c f mss ::= {ms1, . . . , msn} ms ::= c m(c¯)
Figure 5: Class type assignments
information from a source class declaration. So we will write type(fds) and type(mdss) to denote the set of ﬁeld signatures and the set of method signatures extracted from the ﬁeld declarations fds and from the method declarations mdss, respectively. The straightforward deﬁnition of type has been omitted.
The typing rules deﬁning global compilation of a class are given in Fig.6. They are standard rules analogous to those given in other type systems for Java-like languages [9, 8, 4]. We use the following auxiliary judgments:
• ∆; c g mdss : mdsb, meaning that method declaration(s) mdss in class type environment ∆ and current class c (needed for assigning the right type to this) compile(s) to mdsb.
• ∆; Π g es : c | eb, meaning that expression es in class type environment ∆ and local type environment Π (which maps this and method parameters to class names) has type c and compiles to eb.
In rule (g-class), for compiling a class c in a class type environment ∆ we check that ∆ is well-formed (judgment
g ∆ ), and compile each method body in ∆ and current class c. A class type environment is well-formed if there are no multiple type assignments for the same class name, the inheritance relation is acyclic, each extended class is available, there is no ﬁeld hiding, the Java rule on overriding is respected and there is no overloading (the last two conditions correspond to the requirement that a class may not declare a method with the same name and diﬀerent return or parameter types as an inherited method). Note, however, that a class which is only used as a type may not have an assignment in ∆. This deﬁnition of well-formedness exactly models the checks which Java compilers perform on the needed compilation context.The formal deﬁnition of g ∆ can be found in [2].
It is easy to see that the notion of well-formed class type environment is the concrete version in the FJ case of the general notion of consistent class type environment introduced in Section 2 (see [2] for the details).
In rules for compiling expressions, we use an auxiliary judgment of the form ∆ γ, meaning that in the class type environment ∆ the type constraint γ holds. Type constraints are listed in Fig.7. They have the following informal meaning:
• c ≤ c means “c is a subtype of c ”.
• ∃ c means “c is deﬁned”.
• φ(c, f, c ) means “c provides ﬁeld f with type c ”.

γ ::= c ≤ c | ∃ c | φ(c, f, c ) | µ(c, m, c¯, (c , c¯ )) | κ(c, c¯, c¯ )
Figure 7: Type constraints
• µ(c, m, c¯, (c , c¯ )) means “c provides method m applicable to arguments of type c¯, with return type c and parameters of type c¯ .
• κ(c, c¯, c¯ ) means “c provides constructor applicable to arguments of type c¯, with parameters of type c¯ ”.
Note that both the constraints µ(c, m, c¯, (c , c¯ )) and κ(c, c¯, c¯ ) implicitly include the constraint c¯ ≤ c¯ .
The rules deﬁning the judgment ∆ γ (in Fig.8) are intuitive and almost self-explanatory. In rule (φ-2), the side condition f ∈ fss means that f is not declared in fss; analogously, in rule (µ-2), m ∈ mss means that m is not declared in mss. The type constraints in Fig.7 and the rules in Fig.8 are essentially a subset of those deﬁned in [5] (where type constraints were called local type assumptions).
The rules for the compilation of a class in Fig.6, together with the general rules for the global compilation of a fragment, given in Fig.1, provide an instantiation to FJ of the global compilation schema introduced in Section 2.
4. FJ COMPOSITIONAL COMPILATION
In this section we formalize compositional compilation for the small Java-like language introduced in Section 3. Classes are compiled in isolation into polymorphic bytecode. That is, bytecode where the annotations may contain type variables denoting names of yet unknown classes. The syntax of polymorphic bytecode is described by the ﬁrst four productions in Fig.4 (deﬁning binary fragments, class declarations, method sequences, and methods, respectively) and by the productions in Fig.9 (deﬁning binary expressions).
eb ::= x | eb[t.f t ] | eb0[t.m(¯t)t ](eb1 ... ebn) | new [c t¯](eb1 ... ebn) | (c)eb | c, t eb
t ::= c | α t¯ ::= t1 ... tn
Figure 9: Polymorphic bytecode (expressions)
Besides the presence of type variables, the only diﬀerence between polymorphic and standard bytecode is the presence of the “polymorphic casting” annotated expression; if the type variable α is substituted with c , then c, α eb can be specialized either into eb, if c ≤ c holds (casting-up), or into (c)eb, if c ≤ c holds (casting-down), or into c, c eb if nothing can be said about c ≤ c and c ≤ c . For the “polymorphic casting” annotation we use a diﬀerent notation (double angle brackets rather than parentheses) since this annotation is only allowed in polymorphic bytecode.
Polymorphic bytecode comes with a sequence of polymorphic type constraints, which involve type variables and class names. These are listed in Fig.10. As for polymorphic bytecode, the meta-variable t denotes either a type variable or a class name. Besides the presence of type variables, the only

g∆

∆; c g mdss : mdsb

type(mdss) = mss

(g-class) ∆ g class c extends c {fds mdss} : (c, c , fss, mss) | class c extends c {fds mdsb} type(fds) = fss

∆; c
(g-methods)
∆; c g

g mdsi : mdbi mds1 ... mdsn

:

∀i ∈ 1..n mdb1 ... mdbn

n=1

∆; x1:c1 ... xn:cn, this:c g es : c | eb

∆ c ≤ c0

(g-method) ∆; c g c0 m(c1 x1 ... cn xn) {return es;} : c0 m(c1 x1 ... cn xn) {return eb;} ∆ ∃ ci ∀i ∈ 0..n

Π x:c (g-parameter) ∆; Π g x : c | x

∆; Π g es : c | eb (g-ﬁeld access) ∆; Π g es.f : c | eb[c.f c ]

∆

φ(c, f, c )

(g-meth call) ∆; Π

∆; Π g es0 : c0 | eb0

g

∆; Π g esi : es0.m(es1, . . . , esn)

ci :

| ebi ∀i ∈ 1..n c | eb0[c0.m(c¯)c](eb0, . . . , ebn)

∆

µ(c0, m, (c1, . . . , cn), (c, c¯))

(g-new) ∆; Π

∆; Π g esi : ci | ebi ∀i ∈ 1..n g new c(es1 ... esn) : c | new [c c¯](eb1 ... ebn)

∆

κ(c, c1 ... cn, c¯)

∆; Π (g-downcast) ∆; Π g

g es (c)es

: :

c | eb c | (c)eb

∆

c≤c

∆; Π (g-upcast) ∆; Π

g es : g (c)es

c | eb : c | eb

∆

c ≤c

Figure 6: Global compilation

γ ::= t ≤ t | ∃ c | φ(t, f, t ) | µ(t, m, ¯t, (t , ¯t )) | κ(c, ¯t, t¯ ) | c ∼ t
Figure 10: Polymorphic type constraints
diﬀerence between the polymorphic type constraints and the type constrains listed in Fig.7 is the presence of the last constraint in Fig.10, whose informal meaning is the following:
• c ∼ t means “c and t are comparable” (this constraint will be generated when compiling a cast).
Polymorphic type constraints not containing type variables will be called monomorphic type constraints.
The rules deﬁning the judgement for compositional compilation of classes are given in Fig.11. We use the following auxiliary judgments:
• c c mdss : Γ | mdsb, meaning that method declaration(s) mdss in current class c (needed for assigning the right type to this) compile to mdsb under the polymorphic type constraints in Γ.
• Π c es : t | Γ | eb, meaning that expression es in local type environment Π (which maps this and method parameters to class names) has type t and compiles to eb under the polymorphic type constraints in Γ.
The intuition behind the compositional compilation rules is that they extract the polymorphic type constraints Γ necessary to compile a given source fragment into a certain polymorphic binary fragment.

However, note that the rules do not check whether the inferred collection of constraints Γ is actually satisﬁable; indeed, for any fragment it is possible to derive a judgment, even for those that are not statically correct. Consistency checks are performed by the rule for the linking judgment (see below). This approach has the advantage that the typing rules for separate compilation are very simple and can be implemented in a straightforward way.
Note also that in the type system a unique judgment can be derived for any class declaration (the proof is immediate); therefore, we can easily deﬁne a type inference algorithm, that is, an eﬀective way for deducing just from the single declaration of a class c the type and the (polymorphic) bytecode of c, and the required type constraints. This is not possible for the systems in [4, 5, 3], where one needs to know the environment where c is compiled.
We now deﬁne the linking judgment ∆ Γ | B Γ | B . Linking a fragment of polymorphic bytecode B, equipped with polymorphic type constraints Γ, in a given class type environment ∆, amounts to ﬁnding a suitable substitution σ mapping the type variables into class names. The substitution σ instantiates some polymorphic type constraints in Γ into monomorphic type constraints that hold in ∆, and instantiates variables in B correspondingly; these constraints can be eliminated, leaving only the constraints in Γ . In particular, when all constraints are eliminated, we obtain a fragment of standard bytecode (like the one produced by global compilation).
Instantiation of Γ w.r.t. substitution σ is denoted by σ(Γ); we have omitted the trivial inductive deﬁnition which coincides with conventional variable substitution. Instantiation of B w.r.t. ∆ and σ is denoted by Iσ∆(B); ∆ is needed for

∆ γ ∀γ ∈ Γ (Γ) ∆ Γ

(∃) ∆, (c, c , fss, mss) ∃ c

(∃-Obj) ∆ ∃ Object

(≤-reﬂ) ∆ c ≤ c

∆, (c1, c2, fss, mss) c2 ≤ c3

(≤-trans)

∆ c1 ≤ c3

(≤-Obj) ∆ c ≤ Object

(φ-1) ∆, (c, c , fss, mss) φ(c, f, c ) c f ∈ fss

∆, (c, c , fss, mss) (φ-2) ∆, (c, c , fss, mss)

φ(c , f, c φ(c, f, c

) )

f

∈

fss

(µ-1)

∆,

(c,

∆, c,

(c, fss,

c , fss, mss)

mss) µ(c,

ci ≤ ci ∀ m, c1 ... cn,

i∈ (c

1..n , c1 ...

cn

))

c

m(c1 ... cn) ∈ mss

∆, (c, c , fss, mss) (µ-2) ∆, (c, c , fss, mss)

µ(c , m, c¯, (c µ(c, m, c¯, (c

, c¯ , c¯

)) ))

m

∈

mss

(κ-1) ∆ κ(Object, , )

∆, (c, c , fss, mss) ∆, (c, c , fss, mss) (κ-2) ∆, (c, c , fss, mss)

κ(c , c1 ... ck, c1 ... ck) ci ≤ ci ∀ i ∈ k + 1..n
κ(c, c1 ... cn, c1 ... cn)

fss = {ck+1 fk+1, . . . , cn fn}

Figure 8: Entailment judgement ∆ γ (rules for the type constraints in Fig.7)

∆ c≤c (∼-1) ∆ c ∼ c

∆ c∼c (∼-2) ∆ c ∼ c

Figure 12: Entailment judgement ∆ γ (rules for the type constraint c1 ∼ c2)

dealing with the case c, t eb:

Iσ∆( c, t eb) =

8 <

Iσ∆ (eb )

(c)Iσ∆ (eb )

: c, σ(t) Iσ∆(eb)

if σ(t) = c and ∆ if σ(t) = c and ∆ otherwise.

c ≤c c≤c

In all other cases instantiation of polymorphic bytecode corresponds to variable substitution.

Remark. Note that the ability of instantiating polymorphic
bytecode into diﬀerent kinds of standard bytecode instructions is a key feature for dealing with important issues, such as resolution of Java syntax ambiguities (see the Conclusion for an example of such ambiguities) and, in a wider context, code optimization.
The fact that the monomorphic type constraint γ holds in the class type environment ∆ is expressed by the judgement ∆ γ, which is deﬁned by the rules in Fig.8 and in Fig.12.

c∆ ∆ Γ →ls σ | Γ (c-linking) ∆ Γ | B Γ | Iσ∆(B)
Figure 13: Linking

The linking judgement is deﬁned by rule (c-linking) in

Fig.13, which is parameterized w.r.t. a linking-simpliﬁcation relation →ls . A linking-simpliﬁcation relation models a particular way of ﬁnding suitable substitutions for simplifying type constraints w.r.t. class type environments.
The formal deﬁnition of c ∆ (well-formed type environments for compositional compilation) can be found in [2]. The judgment c ∆ is more liberal than g ∆ , since it allows extended classes to be undeﬁned in ∆. Indeed, the check g ∆ in global compilation (rule (g-class)) models the behaviour of standard Java compilers. On the other hand, the premise c ∆ in rule (c-linking) corresponds to an intrinsic notion of consistency, and expresses that some additional constraints on each compiled class c are satisﬁed in ∆, that is, that there is no other declaration for c, that the parent class does not have conﬂicting ﬁeld/method declarations, and that the parent class is not a subtype of c. These constraints could be equivalently generated during compositional compilation of class c, as done in [4, 5, 3]; here we preferred a more compact and eﬃcient formulation. Note that for FJ the check of ∃ c constraints could also be moved to be part of well-formedness of class type environment, since used classes are always mentioned in ﬁeld or method declarations; but this is not true in general, for instance if we have local variables.
The rules for the compilation of a class in Fig.11 and the rule for linking in Fig.13, together with the general rules for the compositional compilation of a fragment, given in Fig.2, provide an instantiation to FJ of the compositional compilation schema introduced in Section 2. In this case the operator ⊕ used in rule (c-frag2) in Fig.2 in Section 2 just corresponds to pairwise concatenation of sequences (of constraints and binary fragments, respectively) with proper α-renaming in order to avoid conﬂicts of type variables.
Note that all the type variables occurring in a compositional compilation judgement are (implicitly) universally quantiﬁed. In fact, in a class compilation judgement c s : δ | Γ | b, the triple δ | Γ | b represents all the standard binary class declarations of the form Iσ∆ ∆(b), for some class

c c mdss : Γ | mdsb

type(mdss) = mss

(c-class) c class c extends c {fds mdss} : (c, c , fss, mss) | Γ, ∃ c | class c extends c {fds mdsb} type(fds) = fss

(c-methods)
c

c c mdsi : Γi | mdbi c mds1 ... mdsn : Γ1 ... Γn

∀i ∈ 1..n | mdb1 ... mdbn

n=1

x1:c1 ... xn:cn, this:c c es : t | Γ | eb (c-method) c c c0 m(c1 x1 ... cn xn) {return es;} : Γ, t ≤ c0, ∃ cii∈0..n | c0 m(c1 x1 ... cn xn) {return eb;}

Π x:c (c-parameter) Π c x : c | Λ | x

(c-ﬁeld access) Π

Π c es.f :

c es : t | Γ | eb α | Γ, φ(t, f, α) |

eb [t.f

α]

α

fresh

Π c es0 : t0 | Γ0 | eb0

(c-meth call) Π

c es0.m(es1 ... esn)

:

β

|

Π c esi : ti | Γi | ebi ∀i ∈ 1..n Γ0Γ1 . . . Γn, µ(t0, m, t1 ... tn, (β, α¯))

|

eb0[t0.m(α¯)β](eb1, . . . , ebn)

β,α¯

fresh

(c-new) Π

Π c new c(es1 ... esn) :

c esi : ti | Γi | ebi ∀i ∈ 1..n c | Γ1 . . . Γn, κ(c, t1 ... tn, α¯) | new [c α¯](eb1 ... ebn)

α¯ fresh

Π c es : t | Γ | eb (c-cast) Π c (c)es : c | Γ, c ∼ t | c, t eb

Figure 11: Compositional compilation

type environment ∆ and substitution σ such that c ∆ ∆ and ∆ ∆ σ(Γ).
We prove now that, under suitable hypothesis on the linkingsimpliﬁcation relation, the compositional compilation which we deﬁned for FJ can be safely used in place of global compilation, that is, is sound and complete w.r.t. global compilation in the sense of Def.1 and Def.5 in Section 2.
We start by stating some properties of entailment which will be needed in the proof and hold independently of the linking-simpliﬁcation relation we choose. Let σ and σ be two substitutions, that is, ﬁnite mappings from type variables to class names. Then σ σ denotes the unique substitution s.t. (σ σ )(Γ) = σ(σ (Γ)) for all Γ; the empty substitution is denoted by . Finally, Γ \ Γ denotes the sequence of constraints obtained by removing from Γ all constraints in Γ , while Vars(Γ) (resp. Vars(b)) denotes the set of type variables appearing in Γ (resp. in b).
Proposition 7. If g ∆ δ , ∆ δ σ(Γ), then for all s, b :
c s : δ | Γ | b implies ∆ δ g s : δ | Iσ∆ δ(b).
Proposition 8. If ∆ δ g s : δ | b, then there exist σ, Γ, b s.t. dom(σ) ⊆ Vars(Γ), and
c s : δ | Γ | b , ∆ δ σ(Γ), b = Iσ∆ δ(b ).
Proposition 9 (Weakening of entailment). ∆ Γ implies ∆ ∆ Γ.
Proposition 10. c ∆1∆2 implies c ∆1 .
Note that Prop.10 does not hold for the judgment g ∆ deﬁning well-formed type environments for global compilation; indeed, g ∆ holds only if the class hierarchy in ∆ is (upward) complete.

In order to establish assumptions in Theorem 4 and Theorem 6, we require the simpliﬁcation relation to satisfy the properties listed in Theorem 11 below, which have the following informal meaning.
→ls -sound guarantees that the simpliﬁcation step is sound, in the sense that, after applying the given substitution, it actually eliminates only type constraints which hold in the current class type environment.
→ls -complete-1 guarantees that, if ∆ contains enough type information to satisfy all type constraints in Γ, then this simpliﬁcation step must be possible in →ls .
→ls -complete-2 handles the case in which there is not enough type information in a class type environment, say ∆2, to guarantee that all constraints in Γ hold. However, if it is possible to eliminate these type constraints in a larger class type environment ∆1 ∆2, then it must be possible to partially simplify Γ in ∆2, obtaining Γ .
Note that the last requirement allows many diﬀerent “strategies” for →ls — including the strategy where simpliﬁcation just does nothing (Γ = Γ in the above) until the class type environment contains suﬃcient information to simplify all type constraints, in which case it applies all the substitutions. However, algorithms implementing →ls should attempt to ﬁnd as many simpliﬁcations as possible at any step. We will present such an algorithm in the next section.
Theorem 11. If the linking-simpliﬁcation relation →ls satisﬁes the following properties:
→ls -sound Γ relevant and c ∆ and ∆ Γ →ls σ | Γ imply dom(σ) ⊆ Vars(Γ) and Γ ⊆ σ(Γ) and ∆ σ(Γ) \ Γ .

→ls -complete-1 Γ relevant and c ∆ and ∆ σ(Γ) and dom(σ) ⊆ Vars(Γ) imply ∆ Γ →ls σ | Λ.
→ls -complete-2 Γ relevant and c ∆1 ∆2 and ∆1 ∆2 Γ → ls σ | Λ imply ∃ Γ , σ , σ s.t. (1) ∆2 Γ → ls σ | Γ , (2) ∆1 ∆2 Γ →ls σ | Λ, and (3) σ = σ σ .
Then, compositional compilation of FJ is sound and complete w.r.t. global compilation.
5. A LINKING ALGORITHM
In this section we describe a particular linking algorithm, thus making rule c-linking eﬀective, and we sketch a proof that this algorithm is a correct implementation of the →ls relation. We start with some basic deﬁnitions which specify the problem we are aiming to solve.
5.1 Basic deﬁnitions
Unless speciﬁed, in this section we will only consider type environments ∆ s.t. c ∆ , that is, possibly open environments with no multiple type assignments for the same class name, no inheritance cycles, no ﬁeld hiding and no bad method overriding. Furthermore, when more convenient, we will treat ∆ and Γ as the sets of their elements (regardless possible repetitions in Γ), and use the standard set theory notations.
As a ﬁrst, rather imprecise attempt, the problem could be informally stated as follows: given a type environment ∆ and a sequence of constraints Γ, ﬁnd the possibly maximal Γ ⊆ Γ s.t. ∆ satisﬁes Γ ; note that, since we are interested in incremental linking, ∆ might not satisfy the whole environment Γ.
A ﬁrst problem with the above statement is that satisfaction of type constraints is under-speciﬁed; e.g., for ∆ = (c, Object, ∅, ∅) and Γ = φ(c1, f, α), α ≤ c (with c = c1), one might be tempted to assert that α ≤ c is satisﬁed by ∆ with α = c. Nevertheless, even though α = c originally seems like the only possible solution, it cannot be considered valid because it is sensitive to extensions to ∆. For instance, if we take ∆ = ∆, (c1, c, {c1 f}, ∅) then we discover that α = c is no longer a valid solution, and that the whole Γ is satisﬁed by ∆ with α = c1. In terms of the linking process, this means that we would need to backtrack from α = c when adding a class c1 as speciﬁed by ∆ .
We now formalize the above reasoning. First, a solution is a substitution σ for type variables s.t. ∆ satisﬁes σ(Γ), that is, ∆ σ(Γ) is valid. Second, in order to avoid backtracking, σ must be the unique possible choice (up to inclusion of maps) for all extensions of ∆.
Deﬁnition 12. For substitutions σ, σ , we say σ ⊆ σ iﬀ dom(σ) ⊆ dom(σ ) and for all α ∈ dom(σ), σ(α) = σ (α).
Deﬁnition 13. A sequence of constraints Γ has solution σ w.r.t. a given ∆ iﬀ
1. ∆ σ(Γ);
2. ∀σ , ∆ : if ∆ ⊆ ∆ and ∆ σ (Γ), then σ ⊆ σ .
Fact 14. A Γ has at most one solution w.r.t. a given ∆.

Now that we have formalized the notion of solution, we can consider in more detail the situation where Γ has no solution w.r.t. a given ∆; as already said, this situation occurs quite naturally when considering incremental linking, because ∆ is likely to be incomplete, and thus may contain insuﬃcient information to compute a solution for Γ. Nevertheless, the algorithm should be able to identify a subsequence Γ ⊆ Γ s.t. Γ has a solution σ w.r.t. ∆, and perform a simpliﬁcation step: the constraints Γ are removed in order to avoid unnecessary checks in further linking steps, whereas σ is applied to the remaining constraints Γ \ Γ , thus returning a sequence Γ . Note that if the algorithm was smart enough, then Γ would be maximal, that is, there would not exist a Γ s.t. Γ ⊂ Γ ⊆ Γ and Γ has solution w.r.t. ∆.
We distinguish two possible situations w.r.t. remaining constraints Γ : If there exists no extension of ∆ which gives a solution for Γ , then the algorithm should detect a linking error. In this case, we say that Γ is inconsistent w.r.t. ∆.
Otherwise, linking succeeds, but the constraints Γ still need to be satisﬁed, therefore the obtained fragment needs to be linked further before execution. In this case, we say that Γ is undetermined w.r.t. ∆.
Deﬁnition 15. A sequence of constraints Γ is inconsistent w.r.t. a given ∆ iﬀ for all ∆ if ∆ ⊆ ∆ , there is no σ s.t. ∆ σ(Γ); it is consistent (w.r.t. ∆) otherwise.
A sequence of constraints Γ which is inconsistent w.r.t. Λ (that is, for all ∆) is called inconsistent. Conversely, a sequence of constraints Γ which is consistent w.r.t. some ∆ (hence, w.r.t. Λ as well) is called consistent.
Deﬁnition 16. A sequence of constraints Γ is determined w.r.t. ∆ iﬀ Γ either has a solution or is inconsistent w.r.t. ∆; it is undetermined (w.r.t. ∆) otherwise.
Deﬁnition 17. A sequence of constraints Γ is determined iﬀ for all ∆, there exists ∆ s.t. ∆ ⊆ ∆ and Γ is determined w.r.t. ∆ ; and is undetermined otherwise.
Proposition 18. The constraint γ is determined iﬀ it matches one of the following patterns: ∃ c, c ≤ c , φ(c, f, t), µ(c, m, c¯, (t, t¯)), κ(c, c¯, ¯t), c ∼ c .
Finally, in order to prove that our algorithm implements a →ls relation satisfying properties →ls -sound, →ls -complete1, and →ls -complete-2 of Theorem 11 — hence, soundness and completeness of compositional compilation w.r.t. global compilation is guaranteed — we show that each relevant set of constraints satisﬁes a quite intuitive syntactic property, and that for constraint sets which satisfy this syntactic property we can deﬁne an algorithm which satisﬁes the conditions of Theorem 11.
This syntactic property is based on a topological relation ≺ between constraints, with the following intuitive meaning: if γ ≺ γ , then γ has to be processed prior to γ . For this we deﬁne the predicates I(α, γ), expressing that α appears in an “in-position” in γ that is, needs to have been substituted before γ can be processed, and O(α, γ) expressing that α appears in an “out-position” in γ, that is, processing γ will provide a substitution for this variable. I(γ), I(Γ), O(γ), O(Γ) have the obvious meaning, that is, the set of I variables in γ, or Γ, and the set of O variables in γ, or Γ.

Input: this: a well-formed Γ argument: a well-formed ∆ Output: if it fails then Γ is inconsistent w.r.t. ∆ else returns σ and transforms Γ into Γ s.t. – Γ = σ(Γ \ Γ ) –Γ ⊆Γ – σ is the solution of Γ w.r.t. ∆ – for all γ ∈ Γ , γ has no solution w.r.t. ∆ Pseudo-code:
Subs solve(Env ∆) throws fail{ σ= this.topsort () // Γ must be topologically sorted for each γ ∈ this { // according to the order try{ γ .apply (σ) σ = γ.entailedBy (∆) this.remove (γ ) σ.update (σ ) } catch(undetermined ){} } return σ
}
Figure 14: Constraint solving algorithm solve
Deﬁnition 19. For any Γ, α, and γ we deﬁne:
1. I(α, γ) iﬀ γ = α ≤ t, or γ = t ≤ α, or γ = c ∼ α, or γ = φ(α, f, t), or γ = µ(t, m, t¯, (t , t¯ )) with α = t or α ∈ t¯, or γ = κ(c, ¯t, ¯t ) with α ∈ ¯t.
2. O(α, γ) iﬀ γ = φ(t, f, α), or γ = µ(t, m, t¯, (t , t¯ )) with α ∈ t¯ or α = t , or γ = κ(c, ¯t, ¯t ) with α ∈ ¯t .
3. I(γ) = { α | I(α, γ) }, I(Γ) = ∪γ∈ΓI(γ), O(γ) = { α | O(α, γ) }, O(Γ) = ∪γ∈ΓO(γ).
Deﬁnition 20. The following topological relation is deﬁned on type constraints: γ ≺ γ iﬀ O(γ) ∩ I(γ ) = ∅.
Deﬁnition 21. Let ≺+ denote the transitive closure of ≺. Then a set of constraints Γ is well-formed iﬀ
1. ∀γ ∈ Γ : I(α, γ) =⇒ ∃γ ∈ Γ : O(α, γ ),
2. ∃γ ∈ Γ : γ ≺+ γ,
3. ∀γ, γ ∈ Γ : O(α, γ) and O(α, γ ) =⇒ γ = γ
5.2 Description of the algorithm
The Java pseudo-code of the main algorithm is deﬁned in Figure 14. The method solve takes a class type environment ∆ and returns a substitution; it is declared in the class implementing sequences of constraints, therefore this denotes a certain Γ. When invoked, method solve either throws fail or returns a substitution σ and simplify Γ into Γ .
The invocation γ.entailedBy (∆), will throw the exception fail if a γ ∈ Γ is found to be inconsistent w.r.t. ∆ (and hence the whole Γ is inconsistent as well).
The method solve returns a σ, if it has found a subsequence Γ ⊂ Γ which has solution σ w.r.t. ∆, and has

modiﬁed Γ to Γ by removing Γ and applying σ. We can see that Γ is maximal, by proving that for all γ ∈ Γ , γ has no solution w.r.t. ∆. However, while all possible simpliﬁcations are always performed, some inconsistencies may be discovered later on, when some new fragment is linked, mainly because each constraint γ ∈ Γ is checked separately.
For instance, given ∆ = (c, Object, ∅, ∅) and Γ = c1 ≤ c2, c2 ≤ c1 (with all class names distinct), Γ.solve(∆) returns the empty substitution and does not modify Γ, even though Γ is clearly inconsistent; however, such inconsistency can be captured when performing further linking steps. For instance, if we take ∆ = ∆, (c1, Object, ∅, ∅) then Γ.solve(∆ ) throws fail since c1 ≤ c2 is clearly inconsistent w.r.t. ∆ .
The constraints are processed respecting the topological order given in Deﬁnition 20, so that it is possible to scan Γ only once without failing to simplify some constraints. To see that the topological sorting is needed, consider for instance Γ = α ≤ c, φ(c, f, α), which is not topologically sorted, and ∆ = (c, Object, {c f}, ∅). The constraint α ≤ c is processed ﬁrst and kept, since is undetermined w.r.t. ∆. Then the constraint φ(c, f, α) is removed (since it has solution α = c); however, the already examined constraint α ≤ c cannot be further instantiated into c ≤ c, and, therefore, is not removed. Therefore solve fails to perform a simpliﬁcation step. Finally, note that since Γ is assumed to be well-formed, it can always be topologically sorted.
Before being processed, each γ is instantiated w.r.t. the current substituion σ. Then, the method entailedBy checks whether γ has solution w.r.t. ∆; if so, it returns the corresponding substitution σ , otherwise it throws either fail, if γ is inconsistent w.r.t. ∆, or undetermined if γ is undetermined w.r.t. ∆. As already explained, fail is propagated by solve, whereas undetermined is captured; in this way, the constraint is not removed, the current substitution is not updated, and solve continues with the next constraint.
Figure 15 contains pseudo-code for entailedBy in the class representing constraints of the form t ≤ t (the other cases can be found in [2]).
If either the left or right hand side of the constraint is a variable, then the constraint is undetermined, therefore the corresponding exception is thrown. Otherwise the constraint is ground and we can check whether it is satisﬁed by ∆. If the trivial cases do not apply (reﬂection and top type), then we perform an inheritance graph traversal from c1 up to Object which can terminate in three diﬀerent ways: if c2 is found, then the constraint is satisﬁed and we return the empty substitution; if Object is reached without ﬁnding c2 then the constraint is inconsistent and fail is thrown; otherwise the traversal stops because method superclass throws undetermined since some superclass of c1 (c1 included) could not be found in ∆. In the last case, the exception must be caught since the constraint still could be inconsistent if there exists c s.t. c2 ≤ c and c ≤ c1. For this reason a new traversal is started from c2 looking for a superclass of c2 (c2 included) contained in the set S of all superclasses of c1 (c1 included) collected during the ﬁrst traversal. If such a class is found, then fail is thrown, otherwise (if either superclass throws undetermined , or Object is reached) undetermined is thrown.
5.3 Correctness of the algorithm
In the sequel, let →ls denote the relation implemented by solve, that is, the relation deﬁned as follows:

Subs entailedBy (Env ∆) throws undetermined , fail{ // ∆ assumed to be well-formed
if this.lhs().var () ∨ this.rhs ().var () throw undetermined c1 = this.lhs() c2 = this.rhs() if c1.equals (c2) ∨ c2.equals (Object) return c = c1 S = {c1} // will contain all c s.t. c1 ≤ c try {
while c = Object{ c = ∆.superclass (c) S.add (c) if c.equals (c2) return
} throw fail // chain complete up to Object } catch(undetermined ){} c = c2 // still could fail while c = Object{ c = ∆.superclass (c) if S.contains (c) throw fail } throw undetermined }
Figure 15: Deﬁnition of entailedBy for t ≤ t
∆ Γ →ls σ | Γ iﬀ Γ.solve(∆) returns σ and transforms Γ into Γ .
The following propositions ensure that → ls leads to a sound and complete compositional compilation of FJ w.r.t. global compilation.
Proposition 22. Any relevant Γ is well-formed.
Proposition 23. The relation → ls satisﬁes properties →ls -sound, →ls -complete-1, and →ls -complete-2 of Theorem 11 for any well-formed Γ.
Finally, note that Prop. 22 ensures also that solve is only invoked for sequences of constraints which can be sorted w.r.t. the topological order ≺ deﬁned in Deﬁnition 20.
6. RELATED WORK
No formal model for separate compilation and linking had been developed until Cardelli’s seminal work in 1997 [7], which can be considered a milestone in the area. It develops a simple formal framework for separate compilation (which, for the sake of simpliﬁcation, is considered to consist only of typechecking), and linking. This framework can be considered to embody the notion of compositional compilation formalized in the present paper. The main diﬀerences are that we are also interested in code generation, and that the general framework in Section 2 abstracts from a particular programming language, and is parametric in the deﬁnition of separate compilation and linking judgments. Instead, [7] illustrates the concepts on a simple lambda-calculus, and linking just amounts in checking that each used entity has the required type and replacing its name by its deﬁnition.
Moreover, [7] did not consider the issue of which properties compositional compilation should satisfy in order to produce the same ﬁnal result as global compilation. These

properties correspond to some form of soundness and completeness as described in the present paper. They have been ﬁrstly introduced and formalized in [5], within a general framework for separate compilation and linking especially suited for Java-like languages similar to that introduced here. However, the framework in [5] did not take into account possible specialization of bytecode during linking, hence linking was reduced to inter-checking, that is, checking that mutual assumptions on fragments are satisﬁed. As a consequence, in the instantation of the framework presented in [5] (again on Featherweight Java) the code generated by separate compilation was standard Java bytecode, rather than the polymorphic bytecode introduced here; hence, since generated bytecode is context-dependent, separate compilation of a class was only possible under some given type constraints (or, equivalently, for each possible resulting bytecode).
The result in [5] was nevertheless important, since a type system for a Java-like language was ﬁrstly formally proved to guarantee sound and complete inter-checking (or, from another point of view, to support principal typings, see below). On the practical side, type systems as that in [5] (see also [4, 3]) constitute a good basis for selective recompilation, as exploited for full Java in [11, 12, 14], since it is possible to check whether a change in a source fragment aﬀects other fragments by simply checking that their requirements still hold, but not for type inference, since type constraints needed for compiling a class cannot be inferred by just inspecting its source code.
In other words, compositional compilation as meant in this paper (compilation of a fragment in isolation) is not possible; type constraints can only be inferred for a given resulting bytecode.
The diﬀerence between the present paper and [5] becomes clearer by discussing the relation of our approach with the notion of principal typing. According to Wells [17]:
• a typing for a term T is the collection of all the information other than T which appears in the ﬁnal judgement of a proof derivation showing that T is typable, and
• (roughly speaking) a typing for a term T is principal if it somehow represents all the typings for T .
The paper [17] (see also [10]) pointed out that the principal typing property (that is, every typable term has a principal typing) plays a key role in compositional type inference.
In this paper, as in [5], we have formalized compilation (including code generation) by means of a type system. Therefore, in our framework, performing compilation amounts to performing type inference.
In the type system in [5], the principal typing property holds by taking as terms pairs consisting of a source and a binary fragment (in other words, bytecode is considered part of the term). Instead, in the type system for compositional compilation proposed in this paper, C , the principal typing property holds by taking as terms source fragments S: a typing is a triple ∆ | B | Γ (note that bytecode is considered part of the typing) and the system has the principal typing property since, for any source fragment S, at most one typing (modulo renaming of type variables) can be derived.

7. CONCLUSION
In this paper we addressed the problem of supporting compositional compilation for languages (like Java and C ) where the binary code depends on the compilation context. For this, we deﬁned a schema formalizing global and compositional compilation for such languages, and instantiated it by providing algorithms supporting compositional compilation for Featherweight Java. To the best of our knowledge, this is the ﬁrst compositional compilation procedure for a Java-like language.
We believe that the results in this paper can be exploited at least in two diﬀerent ways.
Firstly, they can be directly applied to the development of a new generation of compilers/interpreters/linkers (supporting compositional compilation) for real languages like Java and C . In this approach, polymorphic bytecode would be instantiated eagerly, in a step corresponding to staticlinking. Such compilers would naturally support selective recompilation mechanisms, in the same spirit of [11, 12, 14]. In this respect, note that the application of our approach to, e.g., full Java, does not pose substantially new problems, though obviously more and more involved forms of type constraints, as we brieﬂy discuss below. Type constraints modeling ﬁeld hiding and method overloading were already presented (in the non polymorphic approach) in [4, 5, 3], and are omitted in this paper for simplicity. Roughly speaking, allowing method overloading simply leads to a diﬀerent interpretation of the type constraint µ(c, m, c¯, (c , c¯ )), which becomes: “for a call of method m with receiver of type c and arguments of type c¯ the most speciﬁc method has return type c and parameters of type c¯ ” (and analogously for ﬁeld hiding). Hence, rule (c-meth-call) in Fig.11 is not aﬀected, whereas rules deﬁning the entailment judgment for this type constraint, that is, (µ-1) and (µ-2) in Fig.8, must change in order to reﬂect that the type constraint holds when c and c¯ are the return and parameter types of the most speciﬁc method for the call in the given class type environment. The linking simpliﬁcation algorithm must change accordingly. Type constraints modeling most other relevant Java features, such as checked exceptions, accessibility levels, unreachable code, compile-time constants, are presented in [11, 12, 14]. Finally, in [13] it is shown how to deal with another Java peculiar feature, that is, the ambiguity in an expression such as A.B.C.4
Secondly, the results in this paper could lead to the development of a more ﬂexible run-time support for Java-like languages, allowing execution of bytecode containing type variables. In this approach, polymorphic bytecode would be instantiated lazily, during dynamic linking and loading — some initial exploration appears in [6].
Further work includes extensions of our polymorphic model to other Java features, adapting to the polymorphic case the results mentioned above, and, more interestingly, to Ffounded polymorphic methods and classes as introduced by GJ and Java 1.5. We also plan to investigate the extension of the source language so that it may contain type variables as well.

Acknowledgements. We are grateful to the anonymous ref-
erees for detailed and insightful comments and suggestions, and to to Alex Buckley for feedback. This work has been partially supported by Dynamic Assembly, Reconﬁguration and Type-checking - EC project IST-2001-33477, and by APPSEM II - Thematic network IST-2001-38957.
8. REFERENCES
[1] D. Ancona, F. Damiani, S. Drossopoulou, and E. Zucca. Even more principal typings for Java-like languages. In 6th Intl. Workshop on Formal Techniques for Java Programs 2004, June 2004.
[2] D. Ancona, F. Damiani, S. Drossopoulou, and E. Zucca. Polymorphic bytecode: Compositional compilation for Java-like languages. Technical report, Dipartimento di Informatica e Scienze dell’Informazione, Universita` di Genova, November 2004. Extended verson with proofs, available at ftp://ftp.disi.unige.it/pub/person/AnconaD/PBCCJL.pdf.
[3] D. Ancona and G. Lagorio. Stronger Typings for Smarter Recompilation of Java-like Languages. Journal of Object Technology, 3(6):5–25, June 2004. Special issue: ECOOP 2003 workshop on Formal Techniques for Java-like Programs.
[4] D. Ancona, G. Lagorio, and E. Zucca. True separate compilation of Java classes. In ACM SIGPLAN Conference on Principles and Practice of Declarative Programming (PPDP’02), pages 189–200. ACM Press, 2002.
[5] D. Ancona and E. Zucca. Principal typings for Java-like languages. In ACM Symp. on Principles of Programming Languages 2004, pages 306–317. ACM Press, January 2004.
[6] Alex Buckley and Sophia Drossopoulou. Flexible Dynamic Linking. In 6th Intl. Workshop on Formal Techniques for Java Programs 2004, June 2004.
[7] L. Cardelli. Program fragments, linking, and modularization. In ACM Symp. on Principles of Programming Languages 1997, pages 266–277. ACM Press, 1997.
[8] Sophia Drossopoulou and Susan Eisenbach. Is the Java Type System Sound? In 11th European Conference on Object Oriented Programming (ECOOP’97), volume 1241 of LNCS, pages 389–418. Springer-Verlag, June 1997.
[9] A. Igarashi, B. Pierce, and P. Wadler. Featherweight Java: A minimal core calculus for Java and GJ. In ACM Symp. on Object-Oriented Programming: Systems, Languages and Applications 1999, pages 132–146, November 1999.
[10] T. Jim. What are principal typings and what are they good for? In Proceedings of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 42–53. ACM Press, 1996.
[11] G. Lagorio. Towards a smart compilation manager for Java. In Blundo and Laneve, editors, Italian Conf. on Theoretical Computer Science 2003, number 2841 in Lecture Notes in Computer Science, pages 302–315. Springer, October 2003.
[12] G. Lagorio. Another step towards a smart compilation manager for Java. In Hisham Haddad, Andrea Omicini, Roger L. Wainwright, and Lorie M. Liebrock, editors, ACM Symp. on Applied Computing (SAC 2004), Special Track on Object-Oriented Programming Languages and Systems, pages 1275–1280. ACM Press, March 2004.
[13] G. Lagorio. Capturing ghost dependencies in Java sources. Journal of Object Technology, 2004. To appear.
[14] G. Lagorio. Type systems for Java separate compilation and selective recompilation. PhD thesis, Dipartimento di Informatica e Scienze dell’Informazione, Universita` di Genova, May 2004.
[15] Robert Sebesta. Concepts of Programming Languages. Addison-Wesley, 2004. Seventh edition.
[16] D. von Oheimb and T. Nipkow. Java is Type Safe - Deﬁnitely. In ACM Symp. on Principles of Programming Languages 1998, ACM Press, 1998.
[17] J.B. Wells. The essence of principal typings. In International Colloquium on Automata, Languages and Programming 2002, number 2380 in Lecture Notes in Computer Science, pages 913–925. Springer, 2002.

4For instance, A could be a class, B a static ﬁeld, C a ﬁeld, or A could be a class, B a nested class, C a static ﬁed, or A could be a package, B a class, and C a ﬁeld.

