Tlce IafeeeaVe with ExcTafiba ITeiTblef Tad IateefeVtiba Tlcef ia
Slftem E Tad Ta ExTVt CbeeefcbadeaVe with -EedhVtiba
Se´bastien Carlier
Heriot-Watt University
httc-//jjj.mTcf.hj.Tc.hk/~febc/
J. B. Wells
Heriot-Watt University
httc-//jjj.mTcf.hj.Tc.hk/~jbj/
ABSTRACT
System E is a recently designed type system for the -
calculus with intersection types and yfipunsion vuriuvlys. Dur-
ing automatic type inference, expansion variables allow post-
poning decisions about which non-syntax-driven typing rules
to use until the right information is available and allow im-
plementing the choices via substitution.
This paper uses expansion variables in a unification-based
automatic type inference algorithm for System E that suc-
ceeds for every -normalizable -term. We have imple-
mented and tested our algorithm and released our implemen-
tation publicly. Each step of our unification algorithm corre-
sponds to exactly one -reduction step, and viwy vyrsu. This
formally verifies and makes precise a step-for-step correspon-
dence between type inference and -reduction. This also
shows that type inference with intersection types and expan-
sion variables can, in effect, carry out an arbitrary amount
of partial evaluation of the program being analyzed.
Categories and Subject Descriptors
D.3.1 [drogrumming Lunguugys]: Formal Definitions and
Theory; F.4.1 [hhyory oz Computution]: Mathematical
Logic—Lumvxu wulwulus unx rylutyx systyms; F.3.2 [Logics
unx ayunings oz drogrums]: Semantics of Programming
Languages—drogrum unulysis.
General Terms
Algorithms, languages, theory.
Keywords
Lambda-calculus, type inference, intersection types, expan-
sion variables.
∗Partially supported by EC FP5/IST/FET grant IST-2001-
33477 “DART”, NSF grant 0113193 (ITR), and Sun Mi-
crosystems equipment grant EDUD-7826-990410-US.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee.
PPDP ’04, 2004-08-24/---26, Verona, Italy.
Copyright 2004 ACM 1-58113-819-9/04/0008 ...$5.00.
1. DISCUSSION
1.1 Background and Motivation
1.1.1 Types for Programs and Type Inference
Types have been used extensively to analyze computer
program properties without executing the programs, for pur-
poses such as detecting programming errors, enforcing ab-
stract inter-module interfaces, justifying compiler optimiza-
tions, and enforcing security properties.
In the typy ussignmynt style, a type system associates each
untyped (i.e., free of type annotations) term (e.g., computer
program fragment) with 0 or more typings, where each typ-
ing is a pair of a result type and a type environment for free
term variables. hypy infyrynwy is finding a typing to assign
to an untyped term, if possible. Type inference provides the
benefits of types while relieving programmers from having
to manually supply the types.
Type inference algorithms generally solve constraints, of-
ten by uniwution, the process of computing a solution (if
one exists) that assigns values to variables so that con-
straints become solved. Unification-based type inference is
usually understandable and often efficiently implementable.
The most widely used type inference algorithm is Milner’s
W for the well known Hindley/Milner (HM) system [27],
used in languages such as SML, OCaml, and Haskell.
The amount of polymorphism provided by HM is equiva-
lent to unfolding all let-expressions (a form of partial eval-
uation) and then doing type inference with simple types.
HM-style polymorphism is not implemented by unfolding
let-expressions because (1) this is difficult to combine with
separate compilation and (2) it is very inefficient as it re-
analyzes let-expressions every time they are used. HM has
simple and efficient (for typical cases) type inference and
supports separate compilation provided module interfaces
are given. However, HM is somewhat inflexible and does
not support wompositionul unulysis, i.e., analyzing modules
without knowledge about other modules.
1.1.2 Intersection Types
Intersection types were introduced for the -calculus by
Coppo and Dezani [8] and independently by Pottinger [29].
In both cases, a major motivation was the connection be-
tween -reduction and intersection types, which makes in-
tersection types well suited for program analysis.
Intersection type systems have been developed for many
kinds of program analysis (e.g., flow [1], strictness [18], dead-
code [13, 10], and totality [7]) usable for justifying compiler
optimizations to produce better machine code. Intersection
types seem to have the potential to be a general, flexible
framework for many program analyses.
In most intersection type systems, every typable term has
a prinwipul typing [37], one that is stronger than all other
typings assignable to that term. Principal typings improve
the possibilities of analyzing programs incrementally and
minimizing reanalysis cost after program modifications.
1.1.3 Type Inference for Full Intersection Types
The first type inference algorithms for intersection type
systems were by Coppo, Dezani and Venneri [9], and Ronchi
della Rocca and Venneri [32]. These algorithms give princi-
pal typings for -normal forms, and it is separately proven
that a principal typing for a term’s -normal form is also
principal for the term. One disadvantage of this approach is
that terms must be reduced to -normal form before types
are found for them. Another disadvantage is that getting
other typings from principal typings in this approach uses
operations such as suvstitution, yfipunsion, and lifting, and
the older expansion definitions are hard to understand.
Ronchi della Rocca [31] devised the first unification-based
type inference algorithm for a non-rank-restricted intersec-
tion type system. This algorithm yields principal typings
when it succeeds. Because typability for the full system
is undecidable, the algorithm is of course sometimes non-
terminating; to ensure termination, one can restrict type
height. This algorithm uses the older, complicated defini-
tion of expansion, which has several disadvantages: (1) the
unification procedure requires global knowledge in addition
to the two types to unify, which makes the technique delicate
to extend; (2) expansion is only defined on types and typ-
ings, but not on typing derivations (needed for use in com-
piler optimizations), which are thus not straightforward to
obtain via type inference; (3) the older notion of expansion
only allows intersection introduction in argument position,
and is thus unsuitable for accurate resource tracking under
call-by-need and call-by-value evaluation.
Regnier [30] presented an inference algorithm for an in-
tersection type system called Dy. System Dy is similar to
that of [31], with the essential addition of luvyls in types
to carry out expansion. Using nyts, an untyped version of
proof nets from Linear Logic [14], Regnier showed an ex-
act correspondence between net reduction in Linear Logic
and type inference in System Dy. Boudol and Zimmer [4]
gave an inference algorithm that implements expansion by
attaching a set of type variables to each typing constraint;
this appears to be hard to generalize beyond pure -calculus.
Both the approach of Regnier and that of Boudol and Zim-
mer are stated to be unification-based, but neither approach
produces uniyrs (substitutions that solve unification con-
straints); this makes them less practical.
1.1.4 Rank-2 Intersection Types
Leivant [23] introduced a rank-2 intersection type system
and remarked that it is similar in typing power to Hind-
ley/Milner. In fact, rank-2 intersection type systems type
strictly more terms than Hindley/Milner, although the ad-
ditional terms are not very significant.
Van Bakel [35] gave the first unification-based type infer-
ence algorithm for a rank-2 intersection type system. Jim [19]
studied extensions of rank-2 intersection type systems with
practical programming features and discussed the impor-
tance of principal typings. Damiani [11] has extended sup-
port for conditionals and letrec (mutually recursive bind-
ings) as well as support for a let-binding mechanism that
effectively adds some of the power of one more rank to ob-
tain some of the expressiveness of rank-3 intersection types.
Damiani [12] has also worked on rank-2 intersection types
for symmetric linking of modules.
Restricting intersection types to rank-2 does not use their
full potential to analyze programs as precisely as needed, so
we do not pursue this idea.
1.1.5 Expansion Variables
Kfoury and Wells [20, 22] gave a type inference algo-
rithm for System I, a full, non-rank-restricted intersection
type system. System I introduced yfipunsion vuriuvlys and
a single operation integrating expansion and substitution;
together, these features vastly simplified expansion.
Unfortunately, System I has several technical limitations.
The substitution operation (which contains expansion) has
a built-in renaming (needed for complete type inference)
of type and expansion variables that prevents substitutions
from being composable. An awkward workaround for this
problem called sufy womposition was developed, but safe
composition is hard to understand and people have been
error-prone when working with it. System I has other techni-
cal limitations such as non-associative and non-commutative
intersections and no weakening; together, these limitations
prevent it from having subject reduction.
The recently developed System E [6] improves in many
ways on System I. The full System E (only a fraction of
its power is needed for this paper) is more flexible than the
extremely flexible intersection type system of Barendregt,
Coppo, and Dezani [2]. Contrary to Van Bakel’s advice to
make intersection type systems as lean as possible [36], Sys-
tem E does not restrict where intersection type constructors
(and thus also expansion variables) can be used. Flexible
expansion variable placement allows expansion variables to
establish namespaces. In turn, this allows a substantially
simpler way of integrating expansion and substitution. In
particular, System E does not need the automatic built-in
fresh-renaming done during expansion in System I. As a
result, substitution and expansion in System E are more ro-
bust than they are in System I and composition works for
substitutions and expansions. These improvements make it
much simpler to design type inference methods for System E,
leading to the new results in this paper.
1.2 Summary of Contributions
1. We present a clear and precise unification-based inter-
section type inference algorithm in System E and prove
that it types any -normalizing -term. We believe our
presentation is easier to understand and implement than
other presentations of intersection type inference. It is a
strength of our algorithm that it needs only the !-free frag-
ment of System E restricted to trivial subtyping. (Our
algorithm works unchanged with these features present.)
2. Our intersection type inference approach provides a sim-
ple and clean styp-for-styp -reduction/unification corre-
spondence. In the main algorithm phase, each step of
our unify- rule on constraints corresponds to exactly
one -reduction step on -terms, and viwy vyrsu. Any
-reduction strategy can be simulated by a strategy of
using unify-, and viwy vyrsu. Our proof that our algo-
rithm succeeds for all -normalizing -terms takes ad-
vantage of this correspondence and uses the well known
-normalizing leftmost/outermost strategy. This corre-
spondence is impossible for systems without the flexibility
of intersection types, because they can not type even all
strongly -normalizing terms [34]. Our correspondence
improves over that of Regnier [30] both by being more
formal and also by being direct instead of being the com-
position of two correspondences with untyped nyts as an
intermediate notion.
The clear presentation of this correspondence helps to
share the understanding that any intersection type in-
ference approach will be equivalent to purtiul yvuluution
followed by a monovariant analysis. In effect, intersection
type inference can do an arbitrary amount of partial eval-
uation via type unification, i.e., it can do the equivalent
of any amount of -reduction of the analyzed term.
3. Our intersection type inference approach is the only one
to provide a notion of ryuxvuwk that allows extracting -
reduced -terms from partially solved constraints xuring
type inference. This makes it easy to prove the step-for-
step -reduction/unification correspondence and makes
the correspondence easier to understand. The use of read-
back makes our approach clearer than the approaches of
Boudol and Zimmer [4] and also Regnier [30].
4. Unlike early algorithms from before 1990, our inference
algorithm can build and use expansions based solely on
local matching of constraint solving rules without needing
global knowledge of the typing inferred so far, because
expansion in System E is guided by E-variables.
5. The statements and proofs of properties of our inference
algorithm are made clearer and more precise by the use
of skylytons, compact syntactic representations of typing
derivations. Unlike System E, nearly all other intersection
type systems do not have skeletons.
6. Our inference algorithm builds a solution that solves the
input constraints, i.e., a substitution of types for type
variables and expansions for E-variables that when ap-
plied to the input constraints yields satisfied constraints.
This is only possible because the composition of expan-
sions and substitutions is straightforward in System E,
which is not true for other systems.
7. Our algorithm can easily be used to get different forms
of output such as a full typing derivation or just a typing
(result type and type environment) because expansion is
defined on all of the mathematical entities in System E,
including skeletons. Constructing typing derivations is
vital for use in compilers with typed intermediate repre-
sentations. In contrast, many presentations of other algo-
rithms do not clearly document how to construct typing
derivations; this knowledge is either buried deep inside
proofs or simply omitted.
8. Our inference algorithm manages analysis polyvariance
by a scheme of properly arranging the nesting of a finite
number of E-variables. This is simpler than renaming
schemes used in other approaches and greatly eases imple-
mentation. This is only possible because, unlike previous
intersection type systems, System E has no restrictions
on where expansion can occur. Expansion in System E
can splice intersection constructors into type positions
that are to the right of arrows and into typing derivation
positions that are not function application arguments.
9. As explained below in sec. 1.3, our algorithm is more
suitable to be extended to have flexible analysis precision
and to analyze call-by-need and call-by-value behavior.
10. We have implemented all of the algorithms described in
this paper and made them available via a web interface [5]
and for downloading (httc-//jjj.mTcf.hj.Tc.hk/DART/
fbftjTee/flftem-e/). Our implementation generated
the example output found in appendix A.
11. A technical report with full proofs will be made available
on the web pages of the authors by 2004-08.
1.3 Ongoing Future Work
The full System E (only part is presented in this pa-
per) has the ! type constructor which allows non-exact anal-
ysis. The step-for-step -reduction/unification correspon-
dence means that type inference can obtain polyvariance
by doing the equivalent of any amount of partial evaluation
of the analyzed program followed by a cruder, more tradi-
tional monovariant analysis that uses ! and subtyping to col-
lapse the analysis. Because of the careful way ! is integrated
into the full System E, the analysis results precisely indicate
where the information is exact and where it is approximate.
This ability for type inference to partially evaluate leads
to the potential of analysis that simultaneously is compo-
sitional and has easily adjustable cost and precision. (The
algorithm presented in this paper always has exact precision
and the same cost as normalization.) In contrast, the widely
used algorithm W for Hindley/Milner is non-compositional
and does the equivalent of a fixed amount of partial evalua-
tion (unfolding all let-expressions) followed by the standard
(monovariant) first-order unification of simple type infer-
ence [25]; all information in the results must be assumed to
be approximate. Although we have left the full exploration
of this promising possibility to future work, this motivation
helps justify the significance of this work. Investigating this
is ongoing work with our colleague Makholm.
Because in System E expansion can occur in non-function-
argument positions, type inference will be able to do resource-
aware analysis of call-by-need and call-by-value evaluation,
rather than being applicable only to call-by-name evaluation
(which is unused in practice).
We believe the algorithm Infyr (definition 4.22) finds so-
lutions that yield prinwipul typings [37]. Proving this is on-
going work with our colleagues Kfoury and Bakewell.
1.4 Other Future Work
Because types are often exposed to programmers, a major
design goal for many type systems has been making types
suitable for human comprehension. Unfortunately, this con-
flicts with making types suitable for accurate and flexible
program analysis. Intersection types are good for accurate
analysis. However, inferred intersection types may be ex-
tremely detailed and thus are likely to be unsuitable for pre-
senting to humans. Alternative type error reporting meth-
ods such as typy yrror sliwing [15, 16] can avoid presenting
these types directly to programmers. Investigation is needed
to combine type error slicing with System E.
Module boundary interfaces are generally intended to ab-
stract away from the actual software on either side of the
interface, so that implementations can be switched. Also,
module boundary interfaces must be compact and easily un-
derstandable by humans. For these reasons, ∀ and ∃ quan-
tifiers are appropriate for use in module boundary types.
An open problem is how to use very flexible and accurate
types such as intersection types for analysis and then check
whether they imply types using ∀ and ∃ quantifiers.
We (Carlier, Kfoury, and Wells) and also independently
Mairson and Neergaard [28] have noticed a correspondence
between solving of typy infyrynwy wonstruints in System I and
ryxuwtion of nyts. Intersection types correspond to contrac-
tion nodes, ! (introduced in I! by Carlier) to 0-ary contrac-
tion nodes (weakening), E-variables to boxes, T-variables to
axiom links, and constraints to cut links. Each type infer-
ence constraint solving step in System I (using the precise
version of the rules of [20]) corresponds to a net reduction
step. Expansion describes net transformations, and our uni-
fication algorithm does the equivalent of cut-elimination on
nets via substitution for E-variables. In System E (but not
in System I), the equalities imposed on types and constraints
in sec. 3.2 correspond to the flexibility of nets.
This connection with nets has several possible implica-
tions. First, the expansion variables of System E offer a
syntactic alternative to nets that may be easier for pre-
cise reasoning. Second, System E could lead to a Linear
Logic extension with intersection as a proof-functional con-
nective [24] (unlike the usual truth-functional connectives).
In this new system, Regnier’s nets could be annotated with
formulas. (Although Mairson [26] earlier suggested that
net edges can be annotated with Linear Logic formulas, a
counter-example, due to Urzyczyn, is the net for FFK, with
F = f:x:f(fx) and K = y:z:y.)
1.5 Other Related Work
Sayag and Mauny [33] characterize principal typings in
intersection type systems and show they are isomorphic to
-normal forms. The correspondence is limited to normal
forms and does not directly show the step-for-step corre-
spondence between -reduction and type inference.
1.6 Acknowledgements
This paper benefited from detailed comments by Adam
Bakewell, Assaf Kfoury, Henning Makholm, and Jeff Po-
lakow and from helpful discussions with Harry Mairson and
Peter Neergaard on correspondences between proof nets and
type inference with expansion variables.
2. PRELIMINARY DEFINITIONS
This section defines generic mathematical notions. Let
i, j, m, n, p, and q range over {0P 1P 2P : : :} (the natural
numbers). Let .)(〈vP b〉) = v and .2(〈vP b〉) = b. Given a
function f , let f [v 7→ b] = (f \{ (vP x) (vP x) ∈ f })∪{(vP b)}.
Let r range over binary relations. Let −r→ be alternate infix
notation for r. Let −r be the transitive and reflexive (w.r.t.
the intended carrier set) closure of r. Let r; r′ be the compo-
sition of r and r′, i.e., r; r′ = { (vP x) ∃b:r(vP b) ∧ r′(bP x) }.
Given a context X, let X[j ] stand for X with the single
occurrence of 2 replaced by j , e.g., (x:2)[x] = x:x.
If S names a set and < is defined as a metavariable ranging
over S, let S∗ be the set of syquynwys over S as per the
following grammar, quotiented by the subsequent equalities,
and let ~< be a metavariable ranging over S∗:
~< ∈ S∗ ::=  | < | ~<) · ~<2
 · ~< = ~<P ~< ·  = ~<P (~<) · ~<2) · ~<+ = ~<) · (~<2 · ~<+)
For example, ~n ranges over {0P 1P 2P : : :}∗ (sequences of nat-
ural numbers). Length 1 sequences are equal to their sole
member; this requires taking some care.
Given an order Q on a set m, let the lyfiiwogruphiw-yfitynsion
orxyr Qlyx of Q be the least relation s.t. for any ~xP ~z ∈ m
∗ and
yP y′ ∈ m where y Q y′ both ~x Qlyx ~x · y · ~z and ~x · y · ~y Qlyx
~x · y′ · ~z hold.
Diagrams illustrate formal statements. A diagram means
that for all entities linked to solid lines satisfying the re-
lations attached to the solid lines, the additional entities
linked to dashed lines exist satisfying the relations attached
to the dashed lines. For example, the following diagram
means ∀mP nP q: (m Q n)∧ (n ≤ q) ⇒ ∃p: (m ≤ p)∧ (p Q q):
m n
p q
Q
≤≤
Q
3. SYSTEM E
This section presents System E. See [6] for full details.
3.1 Syntax
Fig. 1 defines the syntactic entities used in this paper.
Note the distinction between the metavariables x, , and z
and concrete variables like fi(, u), and y2. The main differ-
ence from the original System E definition [6] is that the !
operator is omitted in this paper.
We use @ for application in terms and skeletons; this is
non-standard, but we do so to have some syntactic marker
for application nodes when terms and skeletons are pretty-
printed or drawn as tree.
We define operator precedence, including for ordinary func-
tion application (f(v)) and modification (f [v 7→ b]), and for
later-defined operations like expansion application ([E]m)
and term-variable substitution (b)[x:=b2]). The prece-
dence groups follow, from highest to lowest:
group 1: f2 , f(v), f [v 7→ b], b)[x := b2],
v := Φ, X[b ], D[f], ~<) · ~<2
group 2: z m, [E] m, (P S)
group 3: m) :∩m2, z=S
group 4: ) → 2, b @ c , f) @ f2, S); S2
group 5: ) l 2, x:b , x:f,
As examples of binding conventions, z) :∩ 2 → + =
((z)) :∩ 2) → +, and (z) l 2) = ((z)) l 2), and
x: x21 @ y22 = x: (x21 @ y22). As is usual, application
is left-associative so that b) @ b2 @ b+ = (b) @ b2) @
b+ (similarly for skeletons) and function types are right-
associative so that ) → 2 → + = ) → (2 → +). Let the
expression ) :∩ · · · :∩ n denote ) :∩ (2 :∩ (· · · :∩ n)) when
n ≥ 1 and ! when n = 0. Extending E-variable application
to sequences, let  m = m and (~z · z)m = ~z (z m).
3.2 Equalities
Terms and skeletons are quotiented by -conversion as
usual [3], where x:b and x: f bind the variable x.
For types and constraints, the definitions of fig. 1 are mod-
ified by imposing equalities for E-variable application, the :∩
operator, and the ! constant. The :∩ operator is associative
and commutative with ! as its unit. E-variable application
distributes over :∩ and !. (The constant ! is a 0-ary version
of :∩.) Formally, these rules hold:
i) :∩ (i2 :∩ i+) = (i) :∩ i2) :∩ i+
i) :∩ i2 = i2 :∩ i) ! :∩ i = i
z (i) :∩ i2) = zi) :∩ zi2 z! = !
:he sorts aTd their abstract syTtax Mrammars aTd metavariables:
x ∈ TyrmAVuriuvly ::= fii
 ∈ TAVuriuvly ::= ui
e ∈ EAVuriuvly ::= yi
 ∈ ETAAssignmynt ::=  :=  | e := E
S ∈ ETAguvstitution ::=  | P S
MPN ∈ Tyrm ::= x | x:M | M) @ M2
X ∈ TyrmAContyfit ::= 2 | x:X | X @ M | M @ X
 ∈ Typy ::= ) :∩ 2 | e  | ! |  | ) → 2
E ∈ Efipunsion ::= E) :∩E2 | eE | ! | S
∆ ∈ Construint ::= ∆) :∩∆2 | e∆ | ! | ) l 2
Q ∈ gkylyton ::= Q) :∩ Q2 | eQ | !M | x2 | x: Q | Q) @ Q2 | Q2
Y ∈ gkylAContyfit ::= 2 | Y :∩Q | Q :∩Y | e Y | x: Y | Y @ Q | Q @ Y | Y2
Metavariables raTMiTM over subsets or multiple sorts:
v ::= e |  Φ ::= E |  T ::=  | ∆ X ::=  | E | ∆ | Q Y ::=  | E | ∆ ∆˙ ::= e ∆˙ | ∆¯ ∆¯ ::= ) l 2
Figury E: gyntufi grummurs unx mytuvuriuvly convyntions.
[E) :∩ E2] X = [E)]X :∩ [E2]X [] =  [S] eX = [[S] e] X
[e E] X = e [E]X [] e = e
[!] Y = ! [v := ΦP S] v′ = [S] v′ if v 6= v′ [S] = S
[!] Q = !tyrm(Q) [v := ΦP S] v = Φ [S] (v := ΦP S′) = (v := [S] ΦP [S]S′)
[S] (X) :∩ X2) = [S]X) :∩ [S]X2 [S]! = ! [S]x2 = x2[S] 
[S] () l 2) = [S] ) l [S] 2 [S]!M = !M [S]x:Q = x: [S]Q
[S] () → 2) = [S] ) → [S] 2 [S]Q2 = ([S]Q)
2[S]  [S] (Q) @ Q2) = [S]Q) @ [S]Q2
Figury F: Efipunsion upplicution.
Both -conversion and the additional rules for types and
constraints are imposed as yquulitiys, where “=” is mathe-
matical equality (as it should be). For example, ! :∩  = .
After this modification, the syntactic sorts no longer form
an initial algebra, so care must be taken.
3.3 Operations on Syntax
Let i v i ′ iff i ′ = i :∩ i ′′ and let i w i ′ iff i ′ v i .
Let b [x :=c ] and respectively b −→ c denote the usual
notions [3] for untyped -terms of term-variable substitution
and respectively -reduction.
Let tyrm be the least-defined function such that:
tyrm(x2 ) = x
tyrm(x: f) = x:tyrm(f)
tyrm(f) @ f2) = tyrm(f)) @ tyrm(f2)
tyrm(f2 ) = tyrm(zf) = tyrm(f)
tyrm(!M ) = b
tyrm(f) :∩f2) = tyrm(f)) if tyrm(f)) = tyrm(f2)
A skeleton f is wyll formyx iff tyrm(f) is defined. E.g., f =
x21 :∩ y22 is ill-formed if x 6= y since tyrm(f) is undefined.
Convyntion 3.E. Henceforth, only well formed skeletons
are considered.
Dynition 3.F. E-path If ∆˙ = ~z∆¯, then E-puth(∆˙) = ~z
is the E-puth of ∆˙. If D is a skeleton context, we define
E-puth(D), the E-path of the context hole in D, by induc-
tion, as follows:
E-puth(2) = 
E-puth(zD) = z · E-puth(D)
E-puth(x:D) = E-puth(D2 ) = E-puth(D @ f)
= E-puth(f @ D) = E-puth(D :∩f)
= E-puth(f :∩D) = E-puth(D)
3.4 Expansion Application
The essential new notion of System E is the way it uses
yfipunsion vuriuvlys (E-variables) to implement expansion.
Expansion is an operation that calculates for a typing judge-
ment the changed judgement that would result from insert-
ing additional typing rule uses at nested positions in the
judgement’s derivation. E-variables are a new technology
that makes expansion simpler and easier to implement and
reason about. E-variables are pluwyholxyrs for unknown uses
of other typing rules like :∩-introduction. E-variables are
propagated into the types and the type constraints used
by type inference algorithms. In System E, expansion op-
erations are described by syntactic terms. The use of E-
variables and expansion terms allows defining expansion ap-
plication in a precise, uniform, and syntax-directed way.
Dynition 3.3 (Efipunsion upplicution). Fig. 2 defines
the application of substitutions to E-variables, and of expan-
sions to types, expansions, constraints, and skeletons.
Epaepde 3.4. E-variables effectively establish namespaces
and substituting an expansion for an E-variable can merge
namespaces. Define the following:
) = y) u( → u( S) = (y) := P ) S2 = (u( := 2P )
Then these facts hold:
[S2] ) = y) u( → 2
[S)] ) = u( → u(
[S2] [S)] ) = 2 → 2
In [S2] ), the T-variable u( inside the E-variable y) is ef-
fectively distinct from the T-variable u( outside y), so the
substitution only replaces the outer u(. The operation [S)] )
replaces y) by the empty expansion (which is actually the
identity substitution), and this effectively lifts the inner u(
into the root namespace, so that [S2] [S)] ) replaces both
occurrences of u(.
Lymmu 3.5 (Efipunsion upplicution composition).
Givyn uny E)P E2P m, [[E)] E2] m = [E)] [E2] m.
Let E); E2 = [E2] E) (composition of expansions). By
lem. 3.5, the “;” operator is associative. Although E); E2 is
not much shorter than [E2] E), it is easier to follow.
(uvstruction)
(M C Q) : 〈A ` 〉 = ∆
(x:M C x:Q) : 〈A[x 7→ !] ` A(x) → 〉 = ∆
(vuriuvly)
(x C x2 ) : 〈(x : ) ` 〉 = !
(upplicution)
(M) C Q)) : 〈A) ` 2 → )〉 = ∆); (M2 C Q2) : 〈A2 ` 2〉 = ∆2
(M) @ M2 C Q) @ Q2) : 〈A) :∩ A2 ` )〉 = ∆) :∩ ∆2
(omygu)
(M C !M ) : 〈ynv! ` !〉 = !
(intyrsyction)
(M C Q)) : 〈A) ` )〉 = ∆); (M C Q2) : 〈A2 ` 2〉 = ∆2
(M C Q) :∩ Q2) : 〈A) :∩A2 ` ) :∩ 2〉 = ∆) :∩∆2
(EAvuriuvly)
(M C Q) : 〈A ` 〉 = ∆
(M C eQ) : 〈e A ` e 〉 = e∆
(rysult
suvtyping)
(M C Q) : 〈A ` )〉 = ∆
(M C Q22 ) : 〈A ` 2〉 = ∆ :∩ () l 2)
Note: When these rules derive judgements of the form (M C Q) : 〈A ` 〉 = ∆ such that solvyx(∆) holds, then these rules
act as typing rules in the traditional sense. (See also remark 3.10.)
Figury 3: hyping rulys.
An assignment  may stand for a substitution (P ) and
is to be interpreted that way if necessary. The higher prece-
dence of (v := Φ) over (P S) also applies here. For exam-
ple, as a substitution (z) := z2 := S2P z+ := S+) stands for
((z) := (z2 := S2))P z+ := S+) which can be written in full as
((z) := ((z2 := S2)P ))P (z+ := S+)P ).
Let z=S stand for (z := z S). Thus, when necessary, z=S
stands for ((z := zS)P ). The “=” notation builds a substi-
tution that affects variables underneath an E-variable, be-
cause [z=S] zm = z [S] m. E.g., S = (y(=(u) := ))P u( := ()
stands for S = (y( := y( (u) := )P )P u( := (P ) and in
this case it holds that [S] (y( u) → u() = y( ) → (.
We extend this notation to E-variable sequences so that
~z · z=S stands for ~z=z=S and =S stands for S.
3.5 Type Environments and Typing Rules
hypy ynvironmynts, ranged over by A and B, are total
functions from hyrm-Vuriuvly to hflpy that map only a finite
number of variables to non-! types.
Dynition 3.6 (cpyrutions on typy ynvironmynts).
[E]A = { (xP [E] A(x)) x ∈ hyrm-Vuriuvly }
A :∩B = { (xPA(x) :∩B(x)) x ∈ hyrm-Vuriuvly }
zA = { (xP z A(x)) x ∈ hyrm-Vuriuvly }
ynv! = { (xP!) x ∈ hyrm-Vuriuvly }
Let (x) : )P : : : P xn : n) be ynv![x) 7→ )] · · ·[xn 7→ n]. Ob-
serve, for every z, E), E2, A, and x, that (1) [E) :∩ E2] A =
[E)] A :∩[E2] A, (2) [E] (A :∩B) = [E]A :∩[E] B, (3) [z] A =
z A, (4) (zA)(x) = zA(x), (5) [!]A = ynv!, and finally (6)
[E] A[x 7→  ] = ([E] A)[x 7→ [E]  ].
Dynition 3.7 (hyping juxgymynts unx typing rulys).
Fig. 3 gives the typing rules of System E used in this paper.
The rules derive juxgymynts of the following form with the
indicated components:
typing
(b C f) : 〈A ` 〉 = ∆
untypyx tyrm wonstruint
skylyton rysult typy
typy ynvironmynt
A pair 〈A `  〉 of a type environment A and a rysult typy 
is a typing.
A skeleton f is just a proof tyrm, a compact notation
representing an entire typing derivation. A skeleton f syn-
tacticly represents a tree of typing rule uses that derives
a judgement for the untyped term tyrm(f). Using skele-
tons avoids needing gigantic judgement trees in formal state-
ments. Many type systems use type-annotated -terms for
this role, but this fails for typing rules like our intersection
( :∩-introduction) rule. (See [38, 39] for a discussion.)
The intended meaning of (b C f) : 〈A `  〉 = ∆ is that f
is a proof that the untyped term b has the typing 〈A `  〉,
provided the constraint ∆ is solvyx w.r.t. some subtyping
relation. The typing rules do not check whether a constraint
∆ is solved to allow (1) using different subtyping relations
and (2) using the same rules to generate constraints to be
solved by type inference. For a subtyping relation, this paper
needs and will use only the weakest, namely equality on
types, but other papers on System E use other relations
(e.g., ≤nlin and ≤yfi from [6]). The results in this paper
extend to all subtyping relations that include equality.
Dynition 3.L (julix skylyton). A skeleton f is vulix iff
there exist b , A,  , and ∆ s.t. (b C f) : 〈A `  〉 = ∆.
Convyntion 3.M. Only valid skeletons are considered.
A skeleton f uniquely determines all components in its
judgement. Let tflping, construint, tynv, and rtflpy be func-
tions s.t. (b C f) : 〈A `  〉 = ∆ implies tflping(f) = 〈A `  〉,
construint(f) = ∆, tynv(f) = A, and rtflpy(f) =  .
A constraint ∆ is solvyx, written solvyx(∆), iff ∆ is of the
form ~z) () l )) :∩ · · · :∩ ~zn (n l n). Given a judgement
(b C f) : 〈A`  〉 = ∆, the entire judgement and its skeleton
f are solvyx iff ∆ is solved. The unsolvyx purt of a constraint
∆, written unsolvyx(∆), is the smallest constraint ∆) such
that ∆ = ∆) :∩∆2 and solvyx(∆2) for some ∆2.
Reearc 3.10 (Redalagn lg lradalagnad lypang rmdek).
Solved judgements and skeletons correspond respectively to
traditional typing judgements and derivations. Traditional
typing rules are merely the special case of the typing rules
in fig. 3 where all constraints are solved. When constraints
are solved, our use of “typing” for a pair 〈A` 〉 matches the
definition in [37]. The rules in fig. 3 can also be used to gen-
erate unsolved constraints to be solved by a type inference
algorithm, as is done in sec. 4. Our presentation not only
saves space by combining the two roles of the rules, but also
guarantees in a simple way (stated formally in lem. 3.11)
that type inference yields valid typing derivations.
Lymmu 3.EE (Uxmissivility oz yfipunsion). If (b Cf) :
〈A `  〉 = ∆, thyn (b C [E] f) : 〈[E] A ` [E]  〉 = [E] ∆.
4. TYPE INFERENCE
This section presents a type inference algorithm for Sys-
tem E. We show how to infer a typing for any normalizing
untyped -term b , where each constraint-solving step ex-
actly corresponds to one -reduction step, starting from b .
We also give an algorithm that reconstructs the -reduced
term from each intermediate stage of type inference.
The approach to type inference is as follows. Given an
untyped term b as input, (1) pick an initial skeleton f such
that tyrm(f) = b , (2) do unification to find a substitution
S solving construint(f), and (3) use f and S to calculate a
solved skeleton (typing derivation) or a typing for b .
If run on -terms which have no normal form, our in-
ference algorithm is non-terminating. This also makes it
in some sense incomplete because any term, even if it is
non-normalizable, can be typed using the ! typing rule in
System E.
4.1 Initial Skeletons
We pick an initial skeleton initiul(b) using three distinct
E-variables y(, y), and y2, and one T-variable u(, as follows:
initiul(x) = x2u0
initiul(x:b) =

let f = y( initiul(b)
in x: f

initiul(b @ c) =
0
@let f) = y) initiul(b)f2 = y2 initiul(c)
in f)
2rtflpy(Q2)→u0 @ f2
1
A
We extend this definition to contexts, taking initiul(2) = 2.
Epaepde 4.1 (Inalaad kcedelgn). Let b = (x:x @ x)@y,
f = initiul(b):
f = ( y) (x: y( ((y) (x
2u0) : y2 u( → u() @ y2 (x
2u0)))
: y2 u( → u()
@ y2 (y
2u0)
We have (b C f) : 〈A `  〉 = ∆ where A = (y : y2 u(),  =
u( and ∆ = (y) (y( y) u( :∩ y( y2 u( → y( u() l y2 u( → u() :∩
(y) y( (y) u( l y2 u( → u()).
We now define plyusunt skeletons, which syntacticly char-
acterize skeletons produced by initiul.
Dynition 4.F (dlyusunt skylyton). A skeleton f is plyus-
unt iff f = e for some e defined as follows:
e ::= x2u0 | x: y( e | (y) e))
2y2 →u0 @ y2 e2
Note that by convention 3.9, if e = (y) e))
2y2 →u0 @ y2 e2,
then  = rtflpy(e2). Note that this definition uses 4 specific,
fixed concrete E- and T-variables (y(, y), y2, and u().
All constraints of a pleasant skeleton are unsolved, and
for all x, tynv(e )(x) = ~z) u( :∩ · · · :∩ ~zn u( for some n ≥ 0.
Lymmu 4.3 (dropyrtiys oz initiul).
E. initiul(b) is u plyusunt skylyton.
2. If e = initiul(b) thyn tyrm(e ) = b .
G. If b = tyrm(e ) thyn initiul(b) = e .
4.2 Readback
To show an exact correspondence with -reduction, we
define a ryuxvuwk function to reconstruct a pleasant skeleton
from a typing and a constraint.
Dynition 4.4 (fyuxvuck). Let ryuxvuck be the least-
defined function where ryuxvuck(AP P ∆) is given by case
analysis on  and subsequently on ∆ if  = u(, such that:
ryuxvuck((x : u()P u(P !) = x
2u0
ryuxvuck(y( AP y( ) → y( 2P y( ∆) = x: y( f
if A(x) = !
and f = ryuxvuck(A[x 7→ )]P 2P ∆)
ryuxvuck(y) A) :∩ y2 A2P u(P
y) ∆) :∩ y2 ∆2 :∩ (y) ) l y2 2 → u()
= (y) f))
2y2 2→u0 @ y2 f2
if f) = ryuxvuck(A)P )P ∆))
and f2 = ryuxvuck(A2P 2P ∆2)
For convenience, we let ryuxvuck(f) = ryuxvuck(tynv(f)P
rtflpy(f)P unsolvyx(construint(f))).
Epaepde 4.5 (Readbacc). Let A = (z : y2 u(),  = u( and:
∆ = (y) (y( u( → y( u() l y2 u( → u()
:∩ (y) ( (y( u( → y( u()→ y( u( → y( u(
l (y( u( → y( u()→ y( u( → y( u())
We have:
ryuxvuck(AP P ∆) = (y) (x: y( (x
2u
0)) : y2 u( → u()
@ y2 (z
2u
0)
Lymmu 4.6 (fyuxvuck vuilxs plyusunt skylytons). If
ryuxvuck(AP P ∆) = f, thyn f = e for somy e .
Lymmu 4.7 (fyuxvuck is ixyntity on plyusunt skylyA
tons). If ryuxvuck(e ) = e ′, thyn e ′ = e .
Combining lemmas 4.3 and 4.7, we obtain this diagram:
b e
initiul
tyrm
ryuxvuck
Lymmu 4.L (fyuxvuck prysyrvys typings). gupposy
thut ryuxvuck(AP P ∆) = e unx tyrm(e ) = b . hhyn it
holxs thut (b C e ) : 〈A `  〉 = unsolvyx(∆).
4.3 Unification Rules
From fig. 1, the metavariable ∆˙ ranges over singulur con-
straints, those that contain exactly one type inequality, and
∆¯ ranges over singular constraints that have an empty E-
path. Each unification step solves one singular constraint.
Fig. 4 introduces rules uniffl- and uniffl-@, which are
used to produce substitutions that solve singular constraints.
Observe that these rules mention 4 specific, fixed concrete
E- and T-variables (y(, y), y2, u(), rather than arbitrary
metavariables z and . (Originally, we made the rules match
arbitrary E-variables, but this generality was not actually
used and the proof is simpler this way.) We now study each
of these two rules in detail.
4.3.1 Rule uniffl-
This section shows that rule uniffl- solves constraints in a
way that corresponds exactly with -reduction on -terms.
Rule uniffl- matches on singular constraints of the form
∆¯ = ~z (y) (y( ( → y( )) l y2 2 → u() corresponding to a -
redex (x:b) @ c in the untyped -term. Informally, each
portion of ∆¯ corresponds to a portion of the redex: ( to the
type of x in b , ) to the result type of b , 2 to the result
type of c , and u( to the result type of the whole redex.
~e (y) (y( ( → y( )) l y2 2 → u() −
unify-−−−−→ ~e=((y2 := y) y( EP y)=y(=S); (u( := [S] )P y) := y( := ))
if ( −
yxtruct−−−→ E and ( −
252−−→ S
~e (y) u( l y2 ) → u() −
unify-@−−−−−→ ~e=(y) := (u( := y2 2 → u(P y) := y) y) P y2 := y) y2 ))
 −yxtruct−−−→ 
) :∩ 2 −
yxtruct−−−→ E) :∩E2 if ) −
yxtruct−−−→ E) and 2 −
yxtruct−−−→ E2
e  −yxtruct−−−→ eE if  −yxtruct−−−→ E
! −yxtruct−−−→ !
 −252−−→ ( := 2)
) :∩ 2 −
252−−→ S);S2 if ) −
252−−→ S) and 2 −
252−−→ S2
e  −252−−→ e=S if  −252−−→ S
! −252−−→ 
Figury 4: fulys zor solving construints.
Epaepde 4.9 (Rmde uniffl-). Consider the following sin-
gular constraint ∆¯ which is part of ∆ from example 4.1 (for
memory, b = (x:x @ x) @ y):
∆¯ = (y) (y( y) u( :∩ y( y2 u( → y( u() l y2 u( → u()
This constraint corresponds to the -redex in b . We have
∆¯ −unify-−−−−→ S, where S is the following substitution:
y2 := y) y( (y)  :∩ y2 )
P y) := y) ( y( := y( ( y) := y) (u( := u( P ) P 
; y2 := y2 (u( := u( P ) P )
P )
P 
; u( := u( P y) := y( :=  P  P 
The first part of S (line 1, y2 := y) y( (y)  :∩ y2 )) makes
as many copies of argument y of the -redex as there are
occurrences of the bound variable x. Each copy is put un-
derneath a distinct sequence of E-variables (here y) and y2);
each sequence of E-variables corresponds to one occurrence
of x. The second part of the substitution S (lines 2-4) re-
places the type variable associated with each occurrence of
the bound variable x with the result type of the correspond-
ing copy of the argument y (this has no effect in this case,
because y also has type u(). The last part of S (line 6) si-
multaneously replaces the type variable that holds the result
type of the application with the result type of the body of
the -abstraction (having no effect in this case), and then
erases E-variables y) and y(. Only the E-variable y) needs
to be erased for the constraint to become solved; erasing y(
is needed to preserve definedness of ryuxvuck.
Lymmu 4.ED. If construint(e ) = ∆¯ :∩∆′ unx ∆¯ −unify-−−−−→ S,
thyn solvyx([S] ∆¯).
S
〈SP ∆¯〉 !
∆¯
uniffl-
.)
.2
[·] ·; unsolvyx
The previous lemmas show that uniffl-, when it applies to
some constraint ∆¯ of a pleasant skeleton, produces a substi-
tution S that solves ∆¯. ∆¯ −unify-−−−−→ S implies the following:
∆¯ = y) (y( ( → y( )) l y2 2 → u(
( = ~z) u( :∩ · · · :∩ ~zn u(
S = (y2 := y) y( E P y)=y(=S
′)
; (u( := [S
′] ) P y) := y( := )
( −
yxtruct−−→ E and ( −
252−−→ S′P for some E and S′:
Let E′ = ~z)  :∩ · · · :∩ ~zn  and
S′′ = ~z)=(u( := 2); · · ·;~zn=(u( := 2):
With these particular E′ and S′′, it is easy to see that
[E′] 2 = ~z) 2 :∩ · · · :∩ ~zn 2 = [S
′′] ( holds, provided that
no ~zi is a proper prefix of ~zj , with iP j ∈ {1P : : : P n}. This is
guaranteed by the hypothesis construint(e ) = ∆¯ :∩∆′, since
for every i, ~zi is the E-path of some skeleton variable in
e . Equalities of sec. 3.2 are imposed on types, but not on
expansions and substitutions, so E = E′ and S′ = S′′ do
not necessarily hold. However, all possible E and S′ have
the same effect when they are applied to types. By defi-
nition 3.3, [S] ∆¯ = [S′] ( → [S] ) l [E] 2 → [S] ). Since
[E] 2 = [E
′] 2 = [S
′′] ( = [S
′] (, solvyx([S] ∆¯) holds.
The next lemma shows that, given a pleasant skeleton
e whose term is a -redex, any substitution generated by
uniffl- applied to the constraint ∆¯ of e generates a substi-
tution S that, when applied to e , (1) solves ∆¯ and only ∆¯,
(2) preserves definedness of ryuxvuck, and (3) changes the
term of the readback by contracting the -redex considered.
Lymmu 4.EE. Lyt b = (x:b)) @ b2, lyt e = initiul(b),
lyt construint(e ) = ∆¯ :∩ ∆′, unx lyt ∆¯ −unify-−−−−→ S. hhyn
ryuxvuck([S] e ) = e ′ whyry construint(e ′) = [S] ∆′ unx
tyrm(e ′) = b)[x := b2].
The next two lemmas show the step-by-step equivalence
between uniffl- and -reduction.
Lymmu 4.EF (cny styp oz unifflA corrysponxs to ony
styp oz Aryxuction). If ryuxvuck(f) = e = initiul(b),
b = tyrm(e ), construint(f) w ∆˙ −unify-−−−−→ S, unx f′ =
[S] f, thyn thyry yfiist b ′ unx e ′ s.t. ryuxvuck(f′) = e ′ =
initiul(b ′), unx b −−→ b ′ = tyrm(e ′).
∆˙ S
f 〈SP f〉 f′
e e ′
b b ′
construint;w .)
.2 [·] ·
uniffl-
ryuxvuck
initiul tyrm
ryuxvuck
tyrminitiul
Lymmu 4.E3 (cny styp oz Aryxuction corrysponxs
to ony styp oz unifflA). If ryuxvuck(f) = e = initiul(b),
tyrm(e ) = b −−→ b ′, initiul(b ′) = e ′, unx tyrm(e ′) =
b ′, thyn thyry yfiist ∆˙, S unx f′ s.t. construint(f) w ∆˙
−unify-−−−−→ S, [S] f = f′, unx ryuxvuck(f′) = e ′.
∆˙ S
f 〈SP f〉 f′
e e ′
b b ′
ryuxvuck
initiul tyrm  initiul tyrm
ryuxvuck
construint;w
uniffl-
.)
.2 [·] ·
4.3.2 Rule uniffl-@
Rule uniffl-@ is designed to be used after rule uniffl-
has been used as much as possible and can not be used
anymore. Because uniffl- effectively simulates -reduction,
this means when uniffl- is done, the term resulting from
ryuxvuck is a -normal form. Because a -normal form may
have applications in it, there may still be unsolved con-
straints. Rule uniffl-@ applies to singular constraints of the
form ∆¯ = y) u( l y2 2 → u(. Such constraints are generated
by terms that are chains of applications whose head is a
variable, i.e., terms of the form xb) · · ·bn. For [S] ∆¯ to be
solved, S must replace y) u( by an arrow type.
The substitution S produced by uniffl-@ is simple, but
has been carefully designed. Part of the substitution pro-
duced by uniffl-@ is S′ = y) := (u( := y2 2 → u() which has
the property that [S′] ∆¯ is solved. However, S′ erases y),
which effectively merges the namespace inside y) with the
parent namespace. Without care, this has the danger that it
could cause formerly distinct variables which should remain
distinct to become the same.
There are three variables that we have to be careful about
that might live at the top level in the namespace of y) just
before rule uniffl-@ is applied. The strategy we use for apply-
ing rules uniffl- and uniffl-@, discussed in the next section,
guarantees that y( does not occur at the top-level of the
namespace inside y). We do not need to worry about the
single T-variable u(, because it is completely replaced by S.
The rest of the substitution produced by uniffl-@ avoids con-
fusing y) and y2 (and also their nested namespaces) in the
namespace of the outer y) with the same names in the par-
ent namespace by replacing them by y)y) and respectively
y)y2. This is done at the same time as the outer y) is erased,
thereby effectively preserving the original namespaces.
Note that if a constraint ∆˙ = y) (y) u( l y2 2 → u() ex-
ists in the namespace of the outer y) as it is erased, this
constraint becomes [S] ∆˙ = y) y) u( l y) y2 2 → y2 2 → u(,
to which uniffl-@ would not apply, and constraint solving
would get stuck at some point. This issue is easily solved
by applying uniffl-@ with a strategy that always selects the
singular constraints that have the longer E-path first. Such
a strategy is given in the next section.
4.4 Inference Algorithm
This section presents an inference algorithm producing a
valid, solved skeleton for any -normalizable term.
Let b be an arbitrarily chosen -term. If b has a -
normal form, then the procedure described below will ter-
minate, otherwise it will go forever. The results of previ-
ous sections are used to design a strategy for applying rules
uniffl- and uniffl-@ that exactly follows leftmost/outermost
-reduction. This reduction strategy is known to terminate
for arbitrary normalizing terms, so by following it we are
able to infer typings for any term that has a -normal form.
Dynition 4.E4 (LyztmostCoutyrmost ryxyfi oz un unA
typyx tyrm). Define metavariables and sets as follows:
bnf ∈ bF-hyrm ::= x:b nf | bnf1
bnf1 ∈ bFE-hyrm ::= x | b nf1 @ b nf
X lo ∈ Lc-Contyfit ::= x:X lo | X lo1
X lo1 ∈ LcE-Contyfit ::= 2 | X lo1 @ b | b nf1 @ X lo
For every term b , exactly one of the following conditions
holds. (1) b = b nf , meaning b is a -normal form. (2)
b = X lo[(x:b)) @ b2], in which case the occurrence of
the subterm (x:b)) @ b2 in the hole of X
lo is the lyft-
most/outyrmost ryxyfi of b .
In order to precisely define the complete strategy for type
inference, we now define the notions of lyftmost/outyrmost
wonstruint, which we use for uniffl-, and rightmost/innyrmost
wonstruint, which we use for uniffl-@.
Dynition 4.E5 (crxyr on syquyncys oz yfipunsion
vuriuvlys). Let yi Q yj iff i Q j. Thus, Q is a strict total
order on expansion variables, and so is its lexicographic-
extension order Qlyx on sequences of finite length.
Dynition 4.E6 (LyztmostCoutyrmost construint). If
∆ = ~z) ∆¯) :∩ · · · :∩ ~zn ∆¯n, then the lyftmost/outyrmost won-
struint of ∆, written Lc(∆), if it exists, is the singular con-
straint that has the least E-path, i.e., Lc(∆) = ~zi ∆¯i iff
1 ≤ i ≤ n and ~zi Qlyx ~zj for any j ∈ ({1P : : : P n} \ {i}).
Dynition 4.E7 (fightCinnyrmost construint). If ∆ =
~z) ∆¯) :∩· · · :∩ ~zn ∆¯n, then the rightmost/innyrmost wonstruint
of ∆, written fI(∆), if it exists, is the singular constraint
that has the greatest E-path, i.e., fI(∆) = ~zi ∆¯i iff 1 ≤ i ≤ n
and ~zj Qlyx ~zi for any j ∈ ({1P : : : P n} \ {i}).
Epaepde 4.18. Consider the following skeleton:
(z) x: z2 x
21 )22 @ z+ (z4 y
25 23 @ z5 z
24)
The leftmost/outermost constraint is z) (z2 ) → z2 )) l 2,
with E-path , and the rightmost/innermost constraint is
z+ (z4 5 l +), with E-path z+.
By design, the leftmost/outermost constraint of a pleasant
skeleton e , namely Lc(construint(e )), corresponds exactly
to the leftmost/outermost application in tyrm(e ). The left-
most/outermost constraint in construint(e ) that also matches
rule uniffl- corresponds exactly to the leftmost/outermost
-redex in tyrm(e ). Thus, the constraint solving strategy
that always uses rule uniffl- on the leftmost/outermost con-
straint matching uniffl- corresponds exactly to leftmost/
outermost -reduction.
Let ltyr-(∆) contain all the singular constraints of ∆ to
which rule uniffl- applies. That is, given ∆ = ∆˙) :∩· · · :∩ ∆˙n,
let ltyr-(∆) = ∆˙i1 :∩ · · · :∩ ∆˙ip where j ∈ {i)P : : : P ip} ⊆
{1P : : : P n} iff there exists S s.t. ∆˙j −
unify-−−−−→ S.
Lymmu 4.EM. If ryuxvuck(f) = e = initiul(b) unx b =
X lo[(x:b)) @ b2], thyn ∆˙ = Lc(ltyr-(construint(f))) is
xynyx unx E-puth(∆˙) = E-puth(initiul(X lo)).
b X lo
e
f ∆˙ ~z
·[(x:b)) @ b2]
initiultyrm
ryuxvuck
initiul; E-puth
construint; ltyr-; Lc E-puth
Similarly, in construint(e ), the rightmost/innermost con-
straint corresponds to the rightmost/innermost application
in tyrm(ryuxvuck(f)). This precise correspondence breaks
down once we start using rule uniffl-@, because ryuxvuck is
no longer defined after using uniffl-@. However, the intuition
still explains how our strategy of using uniffl-@ works, be-
cause uniffl-@ does not rearrange namespaces. Appendix B
presents a modified ryuxvuck which is still defined after uses
of uniffl-@. We do not use it here because its correspon-
dence with pleasant skeletons is not very tight, and this
would complicate the proofs.
Dynition 4.FD (inicution ulgorithm). Given a term
b , the strategy (which succeeds iff b has a -normal form)
for solving the constraint ∆ = construint(initiul(b)) is:
(0) Initial call: iniffl(∆) −→ iniffl(∆P )
(1) iniffl(∆P S) −→ iniffl([S′] ∆P S; S′)
if Lc(ltyr-(∆)) −unify-−−−−→ S′
(2) iniffl(∆P S) −→ iniffl([S′] ∆P S; S′)
if fI(unsolvyx(∆)) −unify-@−−−−→ S′
and case (1) does not apply
(3) Final call: iniffl(∆P S) −→ S
if solvyx(∆)
Lymmu 4.FE (iniffl succyyxs zor Anormulizing tyrms).
If ryuxvuck(f) = e , tyrm(e ) = b , b −− b nf unx ∆ =
construint(f), thyn iniffl(∆) −− S unx solvyx([S] ∆).
b bnf
e S 〈SP∆〉
f ∆ !

initiultyrm
ryuxvuck
construint
iniffl
.)
.2
[·] ·; unsolvyx
Dynition 4.FF (hypy inzyryncy ulgorithm). The over-
all algorithm is:
Infyr(b) −→ 〈eP S〉
if e = initiul(b)
and iniffl(construint(e )) −− S
If Infyr(b) −→ 〈eP S〉, a solved skeleton (traditional typing
derivation) for b is obtained by computing [S] e . If only
a typing (type environment, result type) is desired, it is
obtained by computing 〈[S] tynv(e ) ` [S] rtflpy(e )〉.
hhyorym 4.F3 (Infyr succyyxs zor Anormulizing tyrms).
If b −− b nf , thyn Infyr(b) −→ 〈eP S〉 whyry f = [S] e
is solvyx unx tyrm(f) = b .
5. REFERENCES
oE] UB VunyrjyyB U moxulur, polflvuriunt, unx tflpyAvusyx wlosury
unulflsisB ]n Prop. 1FFD Int'y Pons. Sunptvonny ProtrnmmvntB UWa
dryss, EMMKB
oF] HB Vurynxrygt, aB Woppo, aB Xy–uniAWiunwugliniB U ltyr
lumvxu moxyl unx thy womplytynyss oz tflpy ussignmyntB
W. Symooyvp Lotvp, HL(H), EMLGB
oG] HB dB VurynxrygtB aur Lnmodn Pnypuyus: Its Syntnx nnd
SrmnntvpsB borthAHollunx, ryvisyx yxition, EMLHB
oH] [B Vouxol, dB nimmyrB cn tflpy inzyrynwy in thy intyrsywtion
tflpy xiswiplinyB Xruzt uvuiluvly zrom Est uuthor's wyv pugy, FDDHB
oI] gB Wurliyr, JB dolukowB gflstym Y yfipyrimyntution toolB
httc-//www.macs.hw.ac.hk/hltea/comcositioaal-aaallsis/slstem-EB
oJ] gB Wurliyr, JB dolukow, JB VB kylls, UB JB KzourflB gflstym YN
Yfipunsion vuriuvlys zor yfiivly tflping with linyur unx nonAlinyur
tflpys unx intyrsywtion tflpysB ]n Protrnmmvnt Lnntuntrs 3
Systrms9 13tu Ruroprnn Symp. Protrnmmvnt, volB FMLJ oz LNPSB
gpringyrAjyrlug, FDDHB
oK] aB Woppo, ZB Xumiuni, dB [iunniniB gtriwtnyss, totulitfl, unx
nonAstunxurx tflpy inzyrynwyB aurorrt. Pomput. Spv., FKF(EAF), FDDFB
oL] aB Woppo, aB Xy–uniAWiunwugliniB Un yfitynsion oz thy vusiw
zunwtionulitfl thyorfl zor thy AwulwulusB Notrr Dnmr W. Sormny
Lotvp, FE(H), EMLDB
oM] aB Woppo, aB Xy–uniAWiunwuglini, VB jynnyriB drinwipul tflpy
swhymys unx Awulwulus symuntiwsB ]n Hinxlyfl unx gylxin oEK]B
oED] ZB XumiuniB U wonjunwtivy tflpy sflstym zor usylyssAwoxy
yliminutionB Mntu. Strupturrs Pomput. Spv., EG, FDDGB
oEE] ZB XumiuniB funk F intyrsywtion tflpys zor lowul xynitions unx
wonxitionul yfipryssionsB NPM arnns. on Prot. Lnnts. 3 Systs.,
FI(H), FDDGB
oEF] ZB XumiuniB funk F intyrsywtion tflpys zor moxulysB ]n Prop. Btu
Int'y Pons. Prvnpvpyrs 3 Prnptvpr Drpynrntvvr Protrnmmvnt, FDDGB
oEG] ZB Xumiuni, dB [iunniniB Uutomutiw usylyssAwoxy xytywtion unx
yliminution zor Hch zunwtionul progrumsB W. Sunpt. Protrnmmvnt,
FDDDB
oEH] JBAmB [irurxB Linyur logiwN its sflntufi unx symuntiwsB ]n JBAmB
[irurx, mB Luzont, LB fygniyr, yxsB, Ndvnnprs vn Lvnrnr Lotvp9
Proprrdvnts os tur 1FF3 dorxsuop on Lvnrnr Lotvp, Lonxon
authymutiwul gowiytfl Lywtury boty gyriysB Wumvrixgy inivyrsitfl
dryss, EMMIB
oEI] WB Huuwk, JB VB kyllsB hflpy yrror sliwing in impliwitlfl tflpyx,
highyrAorxyr lunguugysB ]n Protrnmmvnt Lnntuntrs 3 Systrms9
12tu Ruroprnn Symp. Protrnmmvnt, volB FJEL oz LNPSB
gpringyrAjyrlug, FDDGB gupyrsyxyx vfl oEJ]B
oEJ] WB Huuwk, JB VB kyllsB hflpy yrror sliwing in impliwitlfl tflpyx,
highyrAorxyr lunguugysB Spv. Pomput. Protrnmmvnt, ID, FDDHB
gupyrsyxys oEI]B
oEK] JB fB Hinxlyfl, JB dB gylxin, yxsB ao H. O. Purry: Rssnys on
Pomovnntory Lotvp9 Lnmodn Pnypuyus9 nnd SormnyvsmB Uwuxymiw
dryss, EMLDB
oEL] hB JynsynB ]nzyrynwy oz polflmorphiw unx wonxitionul striwtnyss
propyrtiysB ]n Pons. Rrp. POPL 'FE: 2Btu NPM Symp. Prvnp. os
Prot. Lnnts., EMMLB
oEM] hB JimB khut ury prinwipul tflpings unx whut ury thyfl goox
zorS ]n Pons. Rrp. POPL 'FC: 23rd NPM Symp. Prvnp. os Prot.
Lnnts., EMMJB
oFD] UB JB Kzourfl, JB VB kyllsB drinwipulitfl unx xywixuvly tflpy
inzyrynwy zor nityArunk intyrsywtion tflpysB ]n Pons. Rrp. POPL 'FF:
2Ctu NPM Symp. Prvnp. os Prot. Lnnts., EMMMB gupyrsyxyx vfl oFF]B
oFE] UB JB Kzourfl, JB VB kyllsB drinwipulitfl unx tflpy inzyrynwy zor
intyrsywtion tflpys using yfipunsion vuriuvlysB gupyrsyxys oFD], FDDGB
oFF] UB JB Kzourfl, JB VB kyllsB drinwipulitfl unx tflpy inzyrynwy zor
intyrsywtion tflpys using yfipunsion vuriuvlysB aurorrt. Pomput. Spv.,
GEE(E{G), FDDHB gupyrsyxys oFD]B Zor omittyx proozs, syy thy longyr
ryport oFE]B
oFG] XB LyivuntB dolflmorphiw tflpy inzyrynwyB ]n Pons. Rrp. 10tu
Nnn. NPM Symp. Prvnp. os Prot. Lnnts., EMLGB
oFH] YB KB [B Lopy–AYswovurB droozAzunwtionul wonnywtivysB ]n
WB Xi driswo, yxB, Mrtuods os Mnturmntvpny Lotvp9 Proprrdvnts os
tur Ctu Lntvn:Nmrrvpnn Symposvum on Mnturmntvpny Lotvp9
Pnrnpns 1FE3, volB EEGD oz Lrpturr Notrs vn MnturmntvpsB
gpringyrAjyrlug, EMLIB
oFI] HB [B auirsonB Xywixing aL tflpuvilitfl is womplyty zor
xytyrministiw yfiponyntiul timyB ]n Pons. Rrp. 1Dtu Nnn. NPM
Symp. Prvnp. os Prot. Lnnts., EMMDB
oFJ] HB [B auirsonB Zrom Hilvyrt spuwys to Xilvyrt spuwysN Wontyfit
symuntiws muxy simplyB ]n 22nd Ponsrrrnpr on Soundntvons os
Sostwnrr arpunoyoty nnd aurorrtvpny Pomputrr Spvrnpr, FDDFB
oFK] fB ailnyrB U thyorfl oz tflpy polflmorphism in progrummingB W.
Pomput. Systrm Spv., EK, EMKLB
oFL] dB a0llyr byyrguurx, HB [B auirsonB hflpys, potynwfl, unx
impotynwflN khfl nonlinyuritfl unx umnysiu muky u tflpy sflstym
workB ]n Prop. Ftu Int'y Pons. Sunptvonny ProtrnmmvntB UWa
dryss, FDDHB
oFM] [B dottingyrB U tflpy ussignmynt zor thy stronglfl normuli–uvly
AtyrmsB ]n Hinxlyfl unx gylxin oEK]B
oGD] LB fygniyrB Lnmodn pnypuy rt rrsrnuxB dhX thysis, inivyrsitfl
duris K, EMMFB
oGE] gB fonwhi Xyllu fowwuB drinwipul tflpy swhymys unx uniwution
zor intyrsywtion tflpy xiswiplinyB aurorrt. Pomput. Spv., IM(E{F),
EMLLB
oGF] gB fonwhi Xyllu fowwu, VB jynnyriB drinwipul tflpy swhymys zor
un yfitynxyx tflpy thyorflB aurorrt. Pomput. Spv., FL(E{F), EMLHB
oGG] ’YB guflug, aB auunflB U nyw prysyntution oz thy intyrsywtion
tflpy xiswipliny through prinwipul tflpings oz normul zormsB hywhniwul
fyport ffAFMML, ]bf]U, EMMJB
oGH] dB ir–flw–flnB hflpy rywonstruwtion in F! B Mntu. Strupturrs
Pomput. Spv., K(H), EMMKB
oGI] gB JB vun VukylB Intrrsrptvon aypr Dvspvpyvnrs vn Lnmodn
Pnypuyus nnd Nppyvpntvvr arrm Rrwrvtvnt SystrmsB dhX thysis,
Wutholiw inivyrsitfl oz bijmygyn, EMMGB
oGJ] gB JB vun VukylB ]ntyrsywtion tflpy ussignmynt sflstymsB aurorrt.
Pomput. Spv., EIE(F), EMMIB
oGK] JB VB kyllsB hhy yssynwy oz prinwipul tflpingsB ]n Prop. 2Ftu
Int'y Poyy. Nutomntn9 Lnntuntrs9 nnd Protrnmmvnt, volB FGLD oz
LNPSB gpringyrAjyrlug, FDDFB
oGL] JB VB kylls, WB HuuwkB Vrunwhing tflpysB ]n Protrnmmvnt
Lnntuntrs 3 Systrms9 11tu Ruroprnn Symp. Protrnmmvnt, volB
FGDI oz LNPSB gpringyrAjyrlug, FDDFB
oGM] JB VB kylls, WB HuuwkB Vrunwhing tflpysB Insorm. 3 Pomput.,
FDDlB gupyrsyxys oGL]B Uwwyptyx suvjywt to ryvisionsB
APPENDIX
A. FULL EXAMPLE OF TYPE INFERENCE
This appendix shows an example of type inference, present-
ing output produced by our implementation, which has the
option of writing bits of LATEX code suitable for inclusion in
LATEX documents. We analyze the term b :
b = (x:x @ x) @ (z:z @ y)
For compactness, uses of result type subtyping which add
a singular constraint that is solved have been omitted from
skeletons in the rest of this section. However, these solved
constraints are included in judgements.
A.1 Initial Skeleton
The inference process starts by picking an initial skeleton
e( = initiul(b):
e( = ( y) (x: y( ((y) (x
2u0) : y2 u( → u() @ y2 (x
2u0)))
: y2 (y( y) u( → y( u()→ u()
@ y2 (z: y( ((y) (z
2u0) : y2 u( → u() @ y2 (y
2u0)))
The judgement e( derives is:
(b C e() : 〈A( ` (〉 = ∆(P where
A((y) = y2 y( y2 u(
( = u(
∆( = y) (y( y) u( :∩ y( y2 u( → y( u()
l y2 (y( y) u( → y( u()→ u(
:∩ y) y( (y) u( l y2 u( → u()
:∩ y2 y( (y) u( l y2 u( → u()
The readback of the judgement derived by e( is:
ryuxvuck(A(P (P ∆() =
( y) (x: y( ((y) (x
2u0) : y2 u( → u() @ y2 (x
2u0)))
: y2 (y( y) u( → y( u()→ u()
@ y2 (x: y( ((y) (x
2u0) : y2 u( → u() @ y2 (y
2u0)))
Note that, since we have quotiented skeletons and terms by
-equivalence (renaming of bound variables), this skeleton
is actually equal to e(. Of course, tyrm(e() = b .
A.2 Step 1 (use of uniffl-)
The leftmost-outermost unsolved constraint of f( to which
uniffl- applies is:
∆˙( = y) (y( y) u( :∩ y( y2 u( → y( u()ly2 (y( y) u( → y( u()→ u(
We have ∆˙( −
unify-−−−−→ S( where:
S( = y2 := y) y( (y)  :∩ y2 )
P y)=y(= y)=u( := y( y) u( → y( u(
; y2=u( := y( y) u( → y( u(
; u( := u( P y) := y( := 
The skeleton f) = [S(] f( is:
f) = (x: ( y) (x
2y0 y1 u0→y0 u0 )
: y2 (y( y) u( → y( u()→ u()
@ y2 (x
2y0 y1 u0→y0 u0 ))
@ y) (z: y( ((y) (z
2u0 ) : y2 u( → u() @ y2 (y
2u0)))
:∩ y2 (z: y( ((y) (z
2u0 ) : y2 u( → u() @ y2 (y
2u0)))
The judgement f) derives is:
(b C f)) : 〈A) ` )〉 = ∆)P where
A)(y) = y) y( y2 u( :∩ y2 y( y2 u(
) = u(
∆) = y) (y( y) u( → y( u() l y2 (y( y) u( → y( u()→ u(
:∩ y) (y( y) u( → y( u() :∩ y2 (y( y) u( → y( u()→ u(
l y) (y( y) u( → y( u() :∩ y2 (y( y) u( → y( u()→ u(
:∩ y) y( (y) u( l y2 u( → u()
:∩ y2 y( (y) u( l y2 u( → u()
The readback e) of the judgement derived by f) is:
ryuxvuck(A)P )P ∆)) = e) =
( y) (x: y( ((y) (x
2u0) : y2 u( → u() @ y2 (y
2u0)))
: y2 (y( y) u( → y( u()→ u()
@ y2 (x: y( ((y) (x
2u0) : y2 u( → u() @ y2 (y
2u0)))
The untyped term associated with e) is:
tyrm(e)) = (x:x @ y) @ (x:x @ y)
Note that tyrm(e() −
-Lc−−−→ tyrm(e)).
A.3 Step 2 (use of uniffl-)
The leftmost-outermost unsolved constraint of f) to which
uniffl- applies is:
∆˙) = y) (y( y) u( → y( u() l y2 (y( y) u( → y( u()→ u(
We have ∆˙) −
unify-−−−−→ S) where:
S) = y2 := y) y( y)  P y)=y(=y)=u( := y( y) u( → y( u(
; u( := u( P y) := y( := 
The skeleton f2 = [S)] f) is:
f2 = (x: (x
2y1 (y0 y1 u0→y0 u0)→u0)
@ y) (x
2y0 y1 u0→y0 u0 ))
@ (z: (y) (z
2y0 y1 u0→y0 u0 ) : y2 u( → u()
@ y2 (y
2u0))
:∩ y) (z: y( ((y) (z
2u0) : y2 u( → u() @ y2 (y
2u0)))
The judgement f2 derives is:
(b C f2) : 〈A2 ` 2〉 = ∆2P where
A2(y) = y2 u( :∩ y) y( y2 u(
2 = u(
∆2 = y) (y( y) u( → y( u()→ u(
l y) (y( y) u( → y( u()→ u(
:∩ (y) (y( y) u( → y( u()→ u()
:∩ y) (y( y) u( → y( u()
→ u(
l (y) (y( y) u( → y( u()→ u()
:∩ y) (y( y) u( → y( u()
→ u(
:∩ y) (y( y) u( → y( u() l y2 u( → u(
:∩ y) y( (y) u( l y2 u( → u()
The readback e2 of the judgement derived by f2 is:
ryuxvuck(A2P 2P ∆2) = e2 =
( y) (x: y( ((y) (x
2u0) : y2 u( → u() @ y2 (y
2u0)))
: y2 u( → u()
@ y2 (y
2u0)
The untyped term associated with e2 is:
tyrm(e2) = (x:x @ y) @ y
Note that tyrm(e)) −
-Lc−−−→ tyrm(e2).
The following diagram sums up the relations between the entities presented in appendix A. The path followed by type inference
is drawn in solid lines, and the -reduction sequence it implies is drawn in dashed lines. The relation -Lc is the least such that
X lo[(x:M)) @ M2] −
-Lc−−−→ X lo[M)[x := M2]], ryuxvuck
′ is given in appendix B, and X −
[S] ·
−−→ X′ means X′ = [S]X.
initiul
input
M M) M2 Mnf
e) e2 e+ e4
e( Q) Q2 Q+ Q4
∆( ∆) ∆2 ∆+ ∆4 !
∆˙( S( ∆˙) S) ∆˙2 S2 ∆˙+ S+
〈S(P S)〉 S
′
) 〈S
′
)P S2〉 S
′
2 〈S
′
2P S+〉 S
nul
result
initiul
initiul initiul initiul
tyrm
tyrm tyrm tyrm tyrm
-Lc -Lc -Lc
ryuxvuck
ryuxvuck ryuxvuck ryuxvuck ryuxvuck′
construint construint construint construint construint
ltyrA; Lc ltyrA; Lc ltyrA; Lc unsolvyx; fI
unify- unify- unify- unify-@
[S(] · [S)] · [S2] · [S+] ·
unsolvyx
[S(] · [S)] · [S2] · [S+] ·
.)
.2 .2 .2
· ; · .) · ; · .) · ; ·
Figury 5: cutliny oz yfiumply oz typy inzyryncy.
A.4 Step 3 (use of uniffl-)
The leftmost-outermost unsolved constraint of f2 to which
uniffl- applies is:
∆˙2 = y) (y( y) u( → y( u() l y2 u( → u(
We have ∆˙2 −
unify-−−−−→ S2 where:
S2 = y2 := y) y( y)  P y)=y(=y)=u( := u(
; u( := u( P y) := y( := 
The skeleton f+ = [S2] f2 is:
f+ = (x: (x
2(y1 u0→u0)→u0 ) @ (x2y1 u0→u0 ))
@ (z: (z2y1 u0→u0 ) @ y) (y
2u0))
:∩ (z: (y) (z
2u0) : y2 u( → u() @ y2 (y
2u0))
The judgement f+ derives is:
(b C f+) : 〈A+ ` +〉 = ∆+P where
A+(y) = y) u( :∩ y2 u(
+ = u(
∆+ = (y) u( → u()→ u( l (y) u( → u()→ u(
:∩ ((y) u( → u()→ u() :∩ (y) u( → u()→ u(
l ((y) u( → u()→ u() :∩ (y) u( → u()→ u(
:∩ y) u( → u( l y) u( → u(
:∩ y) u( l y2 u( → u(
The readback e+ of the judgement derived by f+ is:
ryuxvuck(A+P +P ∆+) = e+ = (y) (y
2u0) : y2 u( → u() @ y2 (y
2u0)
The untyped term associated with e+ is:
tyrm(e+) = y @ y
Note that tyrm(e2) −
-Lc−−−→ tyrm(e+), and tyrm(e+) is a -
normal form.
A.5 Step 4 (use of uniffl-@)
At this step, f+ has no singular constraint to which uniffl-@
applies, so we switch to using uniffl-@ in order to solve the
remaining constraints. The rightmost-innermost unsolved
constraint of f+ is:
∆˙+ = y) u( l y2 u( → u(
We have ∆˙+ −
unify-@−−−−→ S+ where:
S+ = y) := u( := y2 u( → u( P y) := y) y)  P y2 := y) y2 
The skeleton f4 = [S+] f+ is:
f4 = (x: (x
2((y2 u0→u0)→u0)→u0 ) @ (x2(y2 u0→u0)→u0 ))
@ (z: (z2(y2 u0→u0)→u0 ) @ (y2y2 u0→u0 ))
:∩ (z: (z2y2 u0→u0 ) @ y2 (y
2u0))
The judgement f4 derives is:
(b C f4) : 〈A4 ` 4〉 = ∆4P where
A4(y) = (y2 u( → u() :∩ y2 u(
4 = u(
∆4 = ((y2 u( → u()→ u()→ u(
l ((y2 u( → u()→ u()→ u(
:∩ (((y2 u( → u()→ u()→ u()
:∩ ((y2 u( → u()→ u()
→ u(
l (((y2 u( → u()→ u()→ u()
:∩ ((y2 u( → u()→ u()
→ u(
:∩ (y2 u( → u()→ u( l (y2 u( → u()→ u(
:∩ y2 u( → u( l y2 u( → u(
Note that f4 is solved. By lem. 3.5, the substitution S =
S(; S); S2; S+ solves the initial skeleton e(.
B. IMPROVED READBACK
A slight modification to ryuxvuck, which we have imple-
mented, allows it to operate after uniffl-@ has been used. We
present this variation because it may be of interest, and also
because it is mentioned by the full example (appendix A).
The first case of the definition of ryuxvuck is modified thus:
ryuxvuck(AP u(P !)
= x2 @ f) @ · · ·@ fn
if A = ~z) y2 A) :∩ · · · :∩ ~zn y2 An :∩ (x : )
and  = ~z) y2 ) → · · · → ~zn y2 n → u(
and f) = ~z) y2 ryuxvuck(A)P )P !)
· · ·
fn = ~zn y2 ryuxvuck(AnP nP !)
where ~zn =  and if 1 ≤ i Q n then ~zi = y) · ~zi+).
