Programming J.J. Homing 
Languages Editor 
Proving Termination 
with Multiset 
Orderings 
Nachum Dershowitz and Zohar Manna 
Stanford University and 
The Weizmann Institute of Science 
A common tool for proving the termination of 
programs is the well-founded set, a set ordered in such a 
way as to admit no infmite descending sequences. The 
basic approach is to find a termination function that 
maps the values of the program variables into some 
well-founded set, such that the value of the termination 
function is repeatedly reduced throughout the 
computation. All too often, the termination functions 
required are difficult to find and are of a complexity out 
of proportion to the program under consideration. 
Multisets (bags) over a given well-founded set S are 
sets that admit multiple occurrences of elements taken 
from S. The given ordering on S induces an ordering on 
the f'mite multisets over S. This multiset ordering is 
shown to be well-founded. The multiset ordering 
enables the use of relatively simple and intuitive 
termination functions in otherwise difficult termination 
proofs. In particular, the multiset ordering is used to 
prove the termination of production systems, programs 
defined in terms of sets of rewriting rules. 
Key Words and Phrases: program correctness, 
program termination, program verification, well-founded 
orderings, well-founded sets, multisets, bags, production 
systems, term rewriting systems, tree replacement 
systems, reduction rules 
CR Categories: 5.24, 5.7 
Permission to copy without fee all or part of this material is 
granted provided that the copies are not made or distributed for direct 
commercial dvantage, the ACM copyright notice and the title of the 
publication and its date appear, and notice is given that copying is by 
permission of the Association for Computing Machinery. To copy 
otherwise, or to republish, requires a fee and/or specific permission. 
This research was supported inpart by the United States Air Force 
Office of Scientific Research under Grant AFOSR-76-2909 (sponsored 
by the Rome Air Development Center, Griffiss Air Force Base, NY), 
by the National Science Foundation under Grant MCS 76-83655, and 
by the Advanced Research Projects Agency of the Department of 
Defense under Contract MDA 903-76-C-0206. 
Authors' present addresses: N. Dershowitz, Department of Com- 
puter Science, University of Illinois at Urbana-Champaign, Urbana, 
IL 61801; Z. Manna, Computer Science Department, Stanford Uni- 
versity, Stanford, CA 94305. 
© 1979 ACM 0001-0782/79/0800--0465 $00.75. 
465 
1. Introduction 
The use of well-founded sets for proving that pro- 
grams terminate has been suggested by Floyd [2]. A well- 
founded set (S, >) consists of a set of elements S and an 
ordering > defined on the elements, such that there can 
be no infinite descending sequences of elements. The 
idea is to find a well-founded set and a termination 
function that maps the values of the program variables 
into that set, such that the value of the termination 
function is repeatedly decreased throughout the compu- 
tation. Since, by the nature of the set, that value cannot 
decrease indefinitely, the program must terminate. The 
well-founded sets most frequently used for this purpose 
are the natural numbers under the "greater-than" order- 
ing and n-tuples of natural numbers under the lexico- 
graphic ordering. 
In this paper, we define and illustrate a class of 
orderings on multisets. Multisets, sometimes called bags, 
are like sets, but allow multiple occurrences of identical 
elements. For example, (3, 3, 3, 4, 0, 0} is a multiset of 
natural numbers; it is identical to the multiset (0, 3, 3, 0, 
4, 3} but distinct from {3, 4, 0). 
The ordering > on any given well-founded set S can 
be extended to form a well-founded ordering >~ on the 
finite multisets over S. In this ordering, M >>- M', for 
two finite multisets M and M' over S, if M' can be 
obtained from M by replacing one or more elements in 
M by any finite number of elements taken from S, each 
of which is smaller than one of the replaced elements. In 
particular, a multiset is reduced by replacing an element 
with zero elements, i.e. by deleting it. Thus if S is the set 
of natural numbers 0, 1, 2 .... with the > ordering, then 
under the corresponding multiset ordering >> over S, the 
multiset (3, 3, 4, 0} is greater than each of the three 
multisets {3, 4}, {3, 2, 2, 1, 1, 1, 4, 0}, and {3, 3, 3, 3, 2, 
2}. In the first case, two elements have been removed; in 
the second case, an occurrence of 3 has been replaced 
by two occurrences of 2 and three occurrences of 1; and 
in the third case, the element 4 has been replaced by two 
occurrences each of 3 and 2, and in addition the element 
0 has been removed. The empty multiset ( ) is clearly 
smaller than any other multiset. 
As an example of the use of a multiset ordering for 
a proof of termination, consider the following trivial 
program to empty a shunting yard of all trains: 
loop until the shunting yard is empty 
select a train 
if the train consists of  only a single car 
then remove it f rom the yard 
else split it into two shorter trains 
fi 
repeat 
This program is nondeterministic, as it does not indicate 
which train is to be selected nor how the train is to be 
split. 
Communications August 1979 
of Volume 22 
the ACM Number 8 
Let trains(yard) be the number of trains in the yard, 
and cars(yard) be the total number of cars in the yard. 
For any train E yard, let cars(train) be the number of 
cars it contains. We present wo proofs of termination. 
I f  we take the set of natural numbers as our well- 
founded set, then we are led to the selection of the 
termination function 
y( yard) = 2. cars(yard) - trains(yard). 
(See Ill.) This solution uses the fact that "splitting" 
conserves the number of cars in the yard. Splitting a 
train into two increases trains(yard) by 1, thereby de- 
creasing the current value of the termination function 
•(yard) by 1. Removing a one-car train from the yard 
decreases 2. cars(yard) by 2 and increases -trains(yard) 
by l, thereby decreasing ~(yard) by 1. 
If  we use multisets of natural numbers as our well- 
founded set, then the function 
T(yard) = { cars(train): train E yard } 
demonstrates the termination of the shunting program. 
That is, for any configuration of the yard, T(yard) de- 
notes the multiset containing the length of each of the 
trains in the yard. Each iteration of the program loop 
dearly decreases the value of ~(yard) under the multiset 
ordering: removing a train from the yard reduces the 
multiset by removing one element; splitting a train re- 
places one element with two smaller ones, corresponding 
to the two shorter trains. 
Programs are sometimes written in the form of a 
production system. The following system of three rewrite 
rules is an example: 
white, red--~ red, white 
blue, red ~ red, blue 
blue, white --~ white, blue. 
This program solves the "Dutch national flag" problem: 
Assuming that we have a series of marbles, colored red, 
white, or blue and placed side by side in no particular 
order, then the above program will rearrange the marbles 
so that all the red marbles are on the left, all blue marbles 
are on the right, and all white marbles are in the middle. 
The first rule, for example, states that if anywhere in the 
series there is an adjacent pair of marbles, the left one 
white and the right one red, then they should be ex- 
changed so that the red marble is on the left and the 
white one is on the right. 
The three rules may be applied in any order and to 
any pair of marbles matching a left-hand side of a rule. 
The program terminates when no rule can be applied. 
Clearly, if no rule can be applied, the marbles are in the 
desired order, since nowhere does a red marble have 
anything but a red marble to its immediate left (or else 
one of the first two rules could be applied), and nowhere 
does a blue marble have anything but a blue marble to 
its right (or else one of the last two rules could be 
applied). The only thing we need to ascertain is that the 
466 
program will not run indefinitely, never reaching a situ- 
ation when no rule can be applied; in other words, we 
must prove that the above production system terminates. 
There are several ways of proving the termination of 
the program. The three given here all use the following 
ordering on colors: 
blue is greater than white and white is greater than red. 
It follows from the transitivity of orderings that blue is 
also greater than red. 
The first method counts the total number of "inver- 
sions" of marbles, i.e. the number of pairs of marbles a 
and b (not necessarily adjacent), such that a appears to 
the left of b and the color of a is greater than the color 
of b. For example, if five marbles are arranged blue, red, 
white, red, blue, then there are four inversions: blue-red, 
blue-white, blue-red, and white-red. Thus, the well- 
founded set is the set of natural numbers under their 
standard > ordering, and the termination function counts 
the number of inversions by summing, for each marble, 
the number of marbles with a greater color to its left. 
Each of the rules, when applied, eliminates one inversion 
by exchanging the positions of one inverted pair, without 
generating any additional inversions, thereby decreasing 
the value of the termination function by one. 
For the second method, suppose that there are n 
marbles. The well-founded set we use is the set of n- 
tuples of colors. Such tuples are ordered lexicographi- 
cally: They are reduced if some component is reduced 
without changing any component to its left. The termi- 
nation function simply yields the tuple containing the 
colors of the marbles in order, from left to right. To 
prove termination, we note that whenever one of the 
rules is applied to two marbles, only the values of the 
two corresponding components of the tuple change. By 
the nature of the lexicographic ordering, we need only 
consider the change in the left component, and indeed it 
is reduced in its color: If  it was white, then now it is red, 
and if it was blue, then now it is either red or white. 
The third solution illustrates the use of multiset or- 
derings. Each of the n positions in the series is assigned 
a number, beginning with n - 1 at the left and going 
down to 0 for the rightmost position. We take the mul- 
tisets of pairs of the form (position, color) as the well- 
founded set. The position-color pairs are ordered lexi- 
cographically: We say that a pair is greater than another 
if it has a higher position number than the Other or if it 
has the same position number but a greater color. For 
each marble, the termination function yields one pair, 
giving its position and color. When a rule is applied to 
the marbles at positions i and i - 1, it decreases the value 
of the multiset by decreasing the color of the marble at 
position i. The fact that the color at position i - 1 is 
increased oes not matter, since any pair with position i
is lexicographically greater than any pair with position 
i - l, regardless of the colors. 
These two examples have demonstrated how multiset 
orderings may be used in termination proofs. These 
Communications August 1979 
of Volume 22 
the ACM Number 8 
proofs, however, did not have a clear advantage over the 
alternative proofs using the more common "greater- 
than" relation on the natural numbers and lexicographic 
ordering on n-tuples. In practice, the use of these con- 
ventional orderings may lead to complex termination 
functions that are difficult to discover. For example, the 
termination proofs of programs involving stacks and 
production systems are often quite complicated and re- 
quire much more subtle orderings and termination func- 
tions. Finding an appropriate ordering and termination 
' function for such programs is a well-known challenge 
among researchers in the field of program verification. 
In the remainder of this paper, we shall demonstrate 
how the multiset ordering can sometimes permit he use 
of relatively simple and intuitive termination functions 
in otherwise difficult termination proofs. 
In Section 2 we rigorously define the multiset order- 
ing and prove that it is well-founded. In Section 3 we 
apply the multiset ordering to a number of termination 
proofs of programs. Then in Section 4 we use the multiset 
ordering to prove the termination of production systems. 
2. The Multiset Ordering 
A partially-ordered set (S, >-) consists of a set S and 
a transitive and irreflexive binary relation >- on elements 
of S. For example, both the set Z of all integers and the 
set N of nonnegative integers are ordered by the "greater- 
than" relation >. In general the ordering may be partial: 
For two distinct elements a and b of the set, we may have 
neither a >- b nor b >- a. 
A partially-ordered set (S, >-) is said to be well- 
founded if there can be no infinite descending sequences 
of elements ~ >~ sz >- ... from the set S. Thus, the set 
(N, >) is well-founded, since any descending sequence 
of natural numbers cannot go beyond 0. On the other 
hand, the set (Z, >) is not well-founded. 
For a given partially-ordered set (S, >), we consider 
multisets over S, i.e. unordered collections of elements 
that may have multiple occurrences ofidentical elements. 
We denote by J/(S) the set of all f'mite multisets with 
elements taken from the set S and associate an ordering 
>>- on J /(S) that is induced by the given ordering >- on 
S. 
In the following definition, as well as in the rest of 
this paper, set operators will denote their multiset ana- 
logs: The equality A --- B of two multisets, for example, 
means that any element occurring exactly n times in A, 
also occurs exactly n times in B, and vice versa. The 
union of two multisets A U B is a multiset containing m 
+ n occurrences of any element occurring m times in A 
and n times in B. For example, the union of the multisets 
{2, 2, 4} and (2, 0, 0) is {2, 2, 4, 2, 0, 0). 
For a partially-ordered set (S, >), the multiset order- 
ing >>- on ..~'(S) is defined as follows: 
M >>- M' 
467 
if for some multisets X, Y E J//(S), where { ) ~ X _ M, 
M '=(M-X)  U Y 
and 
(vy e Y)(3x ~ x )  x > y. 
In words, a multiset is reduced by the removal of at least 
one element (those in X) and their replacement with any 
finite number--possibly zero--  of elements (those in Y), 
each of which is smaller than one of the elements that 
have been removed. 
We must first show that >>- is in fact a partial 
ordering, i.e. if >- is irreflexive and transitive, then >>- is 
also: 
(1) To show irreflexivity, we must show that there 
can be no multiset M such that M >>~ M. Suppose that 
M >>- M; then there would be some nonempty finite 
multiset X ___ M such that (Vy E X)(3x ~ X)x • y. In 
other words, for every element of X there would be a 
distinct element of X greater than it, which is impossible 
for a finite X. 
(2) To show transitivity of >>-, consider the following 
irreflexive relation >>-' on multisets in ~/(S): M >>-' 
(M - {x}) U Yif  (Vy E Y)x >y. In other words, a finite 
multiset is reduced in the relation >>-' by replacing a 
single element with zero or more smaller elements. Note 
that the multiset ordering >>- is the (irreflexive) transitive 
closure of the relation >>-', i.e. M >>- M' if and only if M' 
can be obtained from M by replacing elements in M one 
by one. It follows that >>- is transitive. 
We have the following theorem. 
Tt-IEOREM. The multiset ordering (~(S), >>-) over 
(S, >-) is well-founded if and only if(S, >-) is well-founded. 
PROOF. 
(1) "Only i f" part. If(S, >) is not well-founded, then 
there exists an infinite descending sequence Sa > s2 ~- 
sa ~ ... of  elements in S. The corresponding sequence 
of singletons {sl} >>- {s2) >>- {s3} >>- ..- forms an infi- 
nite descending sequence of elements in J/(S), and 
(J/(S), >>-) is therefore not well-founded. 
(2) " I f"  part. Assume that (S, >-) is well-founded. 
Let S' = S U {1) be S extended with a least element 
_1_; i.e. for every element s ~ S, s >- Z in the ordering on 
S'. Clearly S' is well-founded if S is. Now suppose that 
(~(S), >>-) is not well-founded; therefore there exists an 
intinite descending sequence M1 >>" Me >>" Ms >>- --- of 
multisets from J/(S). We derive a contradiction by con- 
structing the following tree. Each node in the tree is 
labeled with some element' of S'; at each stage of the 
construction, the set of all leaf nodes in the tree forms a 
multiset in ~(S' ) .  
Begin with a root node with children corresponding 
to each element of M1. Since M1 >>- Ms, there must exist 
multisets X and Y, such that { } # X _ Ma, M2 = 
(Mx - X) U Y, and (Vy E Y)(3x E X)x >~ y. Then for 
each y E Y, add a child labeled y to the corresponding 
x. In addition, grow a child ± from each of the elements 
of X. (Since X is nonempty, growing ± ensures that even 
Communications August 1979 
of Volume 22 
the ACM Number 8 
if Y is empty, at least one node is added to the tree. Since 
Y is fmite, the nodes corresponding to X each have a 
rmite number of children.) Repeat the process for 
M2 >>- ]143, M3 >>- )1'/4, and so on. 
Since at least one node is added to the tree for each 
multiset M~ in the sequence, were the sequence infinite, 
the tree corresponding to the sequence would also be 
infinite. But by Konig's Infinity Lemma, an infinite tree 
(with a finite number of children for each node) must 
have an infinite path. On the other hand, by our con- 
struction, all paths in the tree are descending in the well- 
founded ordering ~ on S', and must be finite. Thus we 
have derived a contradiction, implying that the sequence 
M~, M2, M3, ...  cannot be infinite. [] 
Remark. If (S, ~-) is totally ordered, then for any 
two multisets M, M' E Jt/(S), one may decide whether 
M >>- M' by first sorting the elements of both M and M' 
in descending order (with respect o the relation ~) and 
then comparing the two sorted sequences lexicographi- 
cally. For example, to compare the multisets {3, 3, 4, 0) 
and {3, 2, 1, 2, 0, 4), one may compare the sorted 
sequences (4, 3, 3, 0) and (4, 3, 2, 2, 1, 0). Since (4, 3, 3, 
0) is lexicographically greater than (4, 3, 2, 2, 1, 0), it 
follows that (3, 3, 4, 0) >> {3, 2, 1, 2, 0, 4). 
Remark. l f  (S, ~-) is of order type a, then the multiset 
ordering (~/(S), >~) over (S, >) is of order type ~o ~. This 
follows from the fact that there exists a mapping ~p from 
J/(S) onto o~" that is one-to-one and order-preserving, 
i.e. if M >>- M' for M, M' E J/(S), then the ordinal ~k(M) 
is greater than ~M') .  That mapping is 
~M) = y, ,0~ ~m), 
mEM 
where Y, denotes the natural (i.e. commutative) sum of 
ordinals and ¢p is the one-to-one order-preserving map- 
ping from S onto a. 
Remark. Consider the case where there is a bound 
k on the number of replacement elements, i.e. restrict he 
ordering >>- by taking the (irreflexive) transitive closure 
of the relation M >>-' M' which holds if I Y] < k when 
M' = (M - X)  U Y. Any termination proof using this 
bounded multiset ordering over IV may be translated into 
a proof using (IV, >). This may be done, for example, 
using the order-preserving function 
~b(M) = Y, k n 
ruEM 
which maps multisets over the natural numbers into the 
natural numbers by summing the number k n for every 
natural number n in a multiset M. 
We turn now to consider nested multisets, by which 
we mean that the elements of the multisets may belong 
to some base set S, or may be multisets of elements of S, 
or may be multisets containing both elements of S and 
multisets of elements of S, and so on. For example, 
{{1, l}, ({0}, 1, 2), 0} 
468 
is a nested multiset. More formally, given a partially- 
ordered set (S, ~-), a nested multiset over S is either an 
element of S, or else it is a fmite multiset of nested 
multisets over S. We denote by J/*(S) the set of nested 
multisets over S. 
We det'me now a nested multiset ordering >>-* on 
J/*(S); it is a recursive version of the standard multiset 
ordering. For two elements M, M' E J/*(S), we say that 
M>>-* M' 
if 
(i) M, M' E S and M • M' (two elements of the 
base set are compared using ~); or else 
(ii) M ~ S and M' E S (any multiset is greater 
than any element of the base set), or else 
(iii) M, M' ~ S, and for some X, Y E ./#*(S), where 
( )~XC_M,  
M'=(M-X)  U Y and ( rye  Y) (3xEX)x>>-*y .  
For example, the nested multiset 
((1, 1}, ((0}, 1, 2), 0} 
is greater than 
{ (1, 0, 0}, 5, { {0}, l, 2}, 0}, 
since { 1, 1} is greater than both {1, 0, 0} and 5. The 
same nested multiset 
({1, 1}, ({0), 1, 2}, O} 
is also greater than 
{{{ ), l, 2}, {5, 5, 2}, 5}, 
since { {0), 1, 2} is greater than each of the three elements 
{{ }, 1, 2}, (5, 5, 2}, and 5. 
Let .~/i(S) denote the set of all nested multisets of 
depth i. In other words, ..//°(S) = S and JZi+I(S) contains 
the multisets whose elements are taken from ~/°(S), 
./#1(S) ..... J//~(S), with at least one element aken from 
./t/i(S). Thus the set .//f*(S) is the infinite union of the 
disjoint sets J[°(S), .//1(S), Jt/2(S) . . . . .  The following 
property holds: 
PROPERTY. For two nested multisets, M and M', if 
the depth of M is greater than the depth of M', then 
M>>-* M'. 
In other words, the nested multisets in ./#~(S) are all 
greater than those in JZ2(S) under the ordering >>-*, for 
any i >f  By the antisymmetry of >>-*, it follows that if 
M >>-* M', then the depth of M' cannot be greater than 
the depth of M. 
PROOF. This property may be proved by induction 
on the depth of M. It holds vacuously for M of depth 0. 
For the inductive step, assume that nested multisets of 
depth i are greater than nested multisets of depth less 
than i; we must show that a nested multiset M of depth 
i + 1 is greater than any nested multiset M' of lesser 
depth. If the depth of M' is 0, then M' E S while M ~ S, 
and therefore M >>-* M', as desired. If the depth of M' 
is less than i + 1 but greater than 0, then each of the 
Communications August 1979 
of Volume 22 
the ACM Number 8 
elements in M' is of depth less than i. The nested multiset 
M, on the other hand, is of depth i + 1 and must 
therefore contain some element of depth i. By the induc- 
tive hypothesis, that element is greater than each of the 
elements in M'. Again it follows that M >~* M'. [] 
The relation >>-* is a partial ordering; it can be shown 
to be both irreflexive and transitive. The following theo- 
rem gives the condition under which it is well-founded: 
THEOREM. The nested multiset ordering (J~r*(S), 
>>-*) over (S, >) is well-founded if and only if (S, >) is 
well-founded. 
PROOF. 
(1) "Only if" part. If(S, >) is not well-founded, then 
there exists an infinite descending sequence sl > s2 > 
sa > .-- of elements in S. This sequence isalso an infinite 
descending sequence of elements in d/*(S) under >>-*, 
and (.riP'(S), >>-*) is therefore not well-founded. 
(2) " I f"  part. In order to show that (J/*(S), >>-*) is 
well-founded, it suffices to show that each ~i(s )  is itself 
well-founded under >>-*. For if it were assumed that 
~/*(S) were not well-founded, then there would exist an 
infinite descending sequence of nested multisets M~ >>-* 
Ms >~* .... By the above property (and the antisymmetry 
of >>-*), the depth of any nested multiset Mk+l in the 
sequence cannot be greater than the depth of its prede- 
cessor Mk. Since that sequence is infinite, it must have 
an infinite subsequence of nested multisets all of the 
same depth i, which contradicts the well-foundedness of 
~i(s). 
We prove that each (Jgi(s), >~*) is well-founded by 
induction on i: The ordering >>-* on sg°(S) -- S is simply 
the ordering > on S, and it follows that (Jg°(S), >>-*) is 
well-founded. For the inductive step, assume that each 
(J#(S), >>-*), j < i, is well-founded, and note that each 
of the elements of ~/i(s) is a member of the union of 
Jg°(S), .Atl(S) ..... ./gi-l(s). By the induction hypothesis, 
each of these .A#(S) is well-founded under >>-*; therefore 
their union is also well-founded under >>-*. Since the 
ordering >>-* on two nested multisets from ~'Z(S) is 
exactly the standard multiset ordering over that well- 
founded union, and since a multiset ordering is well- 
founded if the ordering on the elements i , it follows that 
~/~(S) is also well-founded under >>-*. [] 
Remark. If (S, >) is totally ordered, then two nested 
multisets over S may be compared by first recursively 
sorting them at all levels and then comparing them 
lexicographically. 
Remark. We have seen above that for (S, >) of 
order type a, the multiset ordering (J//(S), >>-) is of order 
type w ~. In a similar manner, it can be shown that the 
order type of (Jgi(s), >>-*) is 
~o~o'" *°i i times, 
the limit of which is the ordinal co--provided that a is 
469 
an ordinal ess than Eo. Thus i f(S, >) is of order type less 
than co, then (sg*(S), >>-*) is of order type co. (Gentzen 
[3] used an eo ordering to prove the termination of his 
normalization procedure for proofs in arithmetic.) 
In the following two sections we apply the multiset 
ordering to problems of termination, first proving the 
termination of conventional programs, and then proving 
the termination of production systems. 
3. Termination of Programs 
The following basic theorem is commonly used to 
prove the termination of programs: 
THEOREM (Floyd). A program P with variables £ 
ranging over a domain D terminates if and only if there 
exist 
(i) a set of labels ~Sf cutting all the loops in P, 
(ii) a well-founded set (W, >), and 
(iii) a termination function T mapping ~× b into W, 
such that whenever control traverses apath from one label 
to another, the value of the termination function ZL(X ) 
decreases for the current label L and value of £. 
The justification is straightforward: 
If the program does not terminate, then there exists 
an infmite sequence of label-value pairs (L1, dl), (L2, dz), 
.... corresponding tothe sequence of labels through which 
control passes during a nonterminating computation and 
the values of the variables at those points. Since the 
function ~- decreases with each traversal of a path, it 
follows that 'I'Ll(d1) > TL2(d2) ~" . . -  forms an infinite 
descending sequence in the set W, contradicting its well- 
foundedness. 
On the other hand, if the program does terminate, 
then the set (ZP x /3, >p) is well-founded, where the 
relation >-p is defined so that (L, d) >p (L', d')  if the 
program can reach the label L with the value d before it 
reaches L' with the value d'. Thus, if zL(£) returns the 
pair (L, £), then with each traversal of a path, the current 
value of ~'L(x) decreases. 
In the following examples, we prove the termination 
of programs using multiset orderings as the well-founded 
set. 
Example 1. Counting tips of binary trees. Consider 
a simple program to count the number of tips--leaf 
nodes (without descendents)--in a binary tree. Each tree 
y that is not a tip has two subtrees, left(y) and right(y). 
The program is 
S := (t) 
c :=0 
loop until S = ( ) 
y := head(S) 
if tip(y) then S := tail(S) 
e:=c+ 1 
else S := left(y) o right(y) o tail(S) 
fi 
repeat 
It employs a stack S and terminates when S is empty. At 
Communicat ions.  August 1979 
of Volume 22 
the ACM Number  8 
that point, the variable c is to contain the total number 
of tip nodes in the given tree t. 
Initially the given tree is placed in the stack. With 
each iteration the subtree at the top of the stack is tested 
to determine whether it is a tip: if it is, then it is removed 
from the stack and the count is incremented by 1; if it is 
not a tip, then it is replaced in the stack by its two 
subtrees, so that the number of tips in each subtree may 
be counted. 
The termination of this program may be proved using 
the well-founded set (N, >). The appropriate t rmination 
function is 
• (S) = ~ nodes(s), 
sES 
where nodes(s) is the total number, of nodes in the subtree 
s - -not  just the tip nodes. To show that the value of 
decreases with each loop iteration, we must consider two 
cases: I f  y = head(S) is a tip node, then that node is 
removed from the stack, and the sum is decreased by 1. 
I f  y is not a tip, then it is replaced by its two subtrees, 
left(y) and right(y). Buty contains one node-- the root - -  
more than left(y) and right(y) combined, and again the 
sum is decreased. 
Using the multiset ordering over trees, we can prove 
termination with the simple termination function 
• (S) = (s :s  ~ s} ,  
giving the multiset of trees appearing in the stack. The 
trees themselves are ordered by the natural well-found 
subtree ordering, i.e. any tree is greater than its subtrees. 
Thus removal of a tree from the stack decreases r in the 
multiset ordering by removing an element, and the re- 
placement of a tree with two smaller subtrees decreases 
r by replacing one element in the multiset with two 
smaller elements. 
This example is similar to the shunting yard example. 
In general, any program in which elements are repeat- 
edly removed from a stack, queue, bag, etc., and replaced 
with any number of smaller elements (in some well- 
founded ordering) can be shown to terminate with the 
corresponding multiset ordering. 
Example 2. McCarthy's 91-function. The following 
is a contrived program to compute the simple function 
f (x )=/ fx>100 thenx-  10 else 91, 
over the set of integers Z, in a round-about manner. 
Though this program is short, the proof of its correctness 
and termination are nontrivial, and for this reason it is 
often used to illustrate proof methods. 
The program is: 
n := 1 
g:=x 
loop L: asser t f (x )  = i f ( z ) ,  n ~ l 
if z> 100thenn:=n-  1 
z :=z- lO  
else n:=n+ 1 
z :=z+l l  
fi 
unti l  n = 0 
repeat 
assert z =f (x ) .  
470 
The predicates f (x)  = fn(z) and n ___ l, in the asser t  
clause at the head of the loop, are loop invariants; they 
hold whenever control is at label L. When the program 
terminates, the variable z contains the value off(x), since 
the loop is exited if control reaches the until clause with 
n = 0; at that point, f (x) =f° (z )  = z. 
Using the conventional well-founded s t (N, >), Katz 
and Manna [6] prove the termination of this program 
with the termination function 
~,(n, z) = -2 .z  + 21.n + 2.max(Il l, x) 
at L. 
For an alternative proof of termination, we consider 
the following well-founded partial-ordering > on the 
integers: 
a>b if and only if a<b_< I I I .  
(This is the same ordering on integers as in the familiar 
structural-induction proof, due to Rod Burstall, of  the 
recursive version of this program.) As the well-founded 
set, we use the set (Jg(Z), >>-) of all multisets of integers, 
under the corresponding multiset ordering. The appro- 
priate termination function ~" at L yields a multiset in 
.//g(Z), and is defined as 
"r(n, z) = (z,f(z) . . . . .  fn - l ( z ) ) .  
We must sl~ow that for each loop iteration this func- 
tion decreases. There are three cases to consider: 
(1) z > 100 at L. In this case, the then branch of the 
conditional is executed and both n and z are decre- 
mented. When control returns to L (assuming that the 
loop has not been exited), we have, in terms of the old 
values of n and z, 
~-(n- 1, z -  10)= (z -  lO, f ( z -  10) . . . . .  f " -2 (z -  10)). 
Since z > lO0, we havef(z)  = z - lO, and therefore 
1"(n- 1, z -  10)= (f(z),f2(z) ..... fn-l(z)}. 
Thus, the value of the termination function ~" has been 
decreased by removing the element z from the original 
multiset (z, f(z) . . . . .  fn-l(z)). 
(2) 90 ~ z ~ 100 at L. In this case, the else branch 
is taken and both n and z are incremented, yielding 
• (n+ 1, z+ 11) 
= {z + l l , f (z  + l l),f2(z + 11) . . . . .  f"(z + 11)). 
Since z + 11 > I00, we havef (z  + 11) = z + 1 and 
f2(z + 11) =f(z + 1). Furthermore, either z + 1 = 101 
or else z + 1 _ 100, and in both casesf(z + 1) = 91 = 
f(z) and consequentlyf2(z + 11) =f(z) .  Thus we get 
~'(n + 1, z + 11) = (z + 11, z + 1,f(z) . . . . .  fn - l ( z ) ) .  
S incez<z+l<z+l l _< l l l ,  wehavez>z+l land  
z > z + 1. Accordingly, the multiset has been reduced by 
replacing the element z with the two smaller elements, 
z+ l landz+ 1. 
(3) z < 90 at L. The else branch is taken and we 
have 
Communicat ions  August  1979 
of  Vo lume 22 
the ACM Number  8 
r (n+ 1, z+ 11) 
= {z + l l , f (z  + 1 l),f2(z + 11) . . . . .  fn (z  + 11)}. 
Since z + 11 _< 100, we havef (z  + 11) = 91 and 
f2 (z  + I1) =f(91)  = 91 =f(z) ,  and thus 
~'(n + 1, z + 11) ---- (z + 11, 91,f(z) . . . . .  fn - l (z )} .  
Again z has been replaced by two smaller elements 
(under the > relation), z + 11 and 91. 
Example 3. Ackermann's function. Ackermann's 
function a(m, n) over pairs of natural numbers is defined 
recursively as 
a(m, n) ~ if m --- 0 then n + 1 
else ifn = 0 then a(m - 1, 1) 
else a(m - 1, a(m, n - 1)) 
tiff. 
The following iterative program computes this function: 
s := (m) 
Z :=71 
loop L: assert a(m, n) = a(sk, a(sk-1 ..... a(s2, a(sl, z))...)) 
y := head(S) 
S := tail(S) 
i f y= 0thenz  :=z+ 1
else 
i fz = 0 then S := (y  - l )oS 
z := l  
else S:=yo(y -  I )oS 
z :=z- I  
tiff 
until s = ( ) 
repeat 
assert  z = a(m, n), 
where the stack S is of the form (s~, s2 . . . . .  Sk) for some 
k >_ O, head(S) = s~, tail(S) = (s2 . . . . .  Sk), and yoS = 
(y, sl . . . . .  Sk). This is achieved by keeping the relation 
a(m, n) = a(Sk, a(sk-1 . . . . .  a(s2, a(sl ,  z ) )  ...)) 
invariantly true whenever control is at the head of the 
loop. Thus when the stack S is empty, the loop terminates 
with a(m, n) = z. 
The underlying idea is to apply the recursive defmi- 
tion for a(m, n) to the rightmost wo elements of the 
sequence 
Sk, ... , $2, S1, Z. 
The three branches of the conditional statement in the 
loop correspond to the three cases in the recursive deft- 
nition, e.g. if y = s~ # 0 and z # 0, then the sequence 
becomes Sk . . . . .  S2, Sl -- 1, Sl, Z -- 1, since a(sl, z) = 
a(sl -- 1, a(sa, z -- 1)). 
The termination of this program was proved by 
Manna and Waldinger [11] using the intermittent-asser- 
tion technique. We give here a proof using multisets. 
Consider the set N x N of lexicographically-ordered 
pairs of natural numbers and the corresponding multiset 
ordering over N x N. Let y = head(S) = sa. The 
termination function at L is 
471 
T(s, z) 
= {(sk + 1, 0), (Sk-1 + l, O) . . . . .  (S2 + l, 0), (y, Z)}. 
Thus ~'(S, z) yields a multiset containing one pair per 
element in the stack S. Note that at L, the stack S is 
nonempty, and all the elements in S as well as z are 
nonnegative integers. 
The proof considers three cases, corresponding to the 
three branches of the conditional in the loop: 
(1) y = 0. I f  the loop is not exited, then the new value 
of ~" at L is 
• ((s2 . . . . .  sk), z + 1) 
= ((Sk + 1, 0) . . . . .  (S3 + 1, 0), (Sz, Z + 1)}. 
This represents a decrease in r under the multiset order- 
ing, since the element (y, z) has been removed and the 
element (s2 + 1, 0) has been replaced by the smaller (s2, 
z+ 1). 
(2) y # 0 and z ffi 0. In this case we obtain 
~((y - 1, s2 . . . . .  Sk), 1) 
= {(sk + 1, 0) . . . . .  ($2 + 1, 0), (y  -- 1, 1)}. 
Thus the element (y, z) has been replaced by the smaller 
element (y -  1, 1). 
(3) y # 0 and z # 0. Here we have 
~-((y, y - 1, s2 .. . . .  sk), z - 1) 
= {(Sk + 1, O) . . . . .  (S2 + 1, 0), (y ,  0), (y ,  Z -- 1)}. 
The element (y, z) has been replaced by the two smaller 
elements (y, 0) and (y, z - 1). 
Remark. The previous examples uggest the follow- 
ing heuristic for proving termination: Given a program 
over a domain (D, >-) that computes ome functionf(x), 
if the program has a loop invariant of the form 
f (x )  = h(f(gx(y)) ,  f (g2(y) )  . . . . .  f (g , (y) ) ) ,  
then try the multiset ordering (J#(D), >>-), and use the 
termination function 
• (y)  = { gl(y),  g2(y) . . . . .  g,(y)}. 
The idea underlying this heuristic is that ~" represents he 
set of unevaluated arguments of some recursive xpan- 
sion of the funct ionf  
4. Terminat ion  o f  P roduct ion  Systems 
A production system 1I (also called a term-rewriting 
system) over a set of expressions E is a (f'mite or infinite) 
set of rewriting rules, called productions. Each production 
is of the form 
~(,~,/~ .... )---' ~'(~, • .... ), 
where ~r and ~r' are expression schemata containing 
variables a, fl .... ranging over E. (The variables appear- 
ing in ,r' must be a subset of those in ,r.) Instantiating 
the variables a, fl . . . .  with expressions a, b . . . .  in E, 
respectively, the rule indicates that an expression 
,r(a, b . . . .  ) E E may be replaced by the corresponding 
expression ~r'(a, b .... ) E E. 
A rule is applied in the following manner: Given an 
Communicat ions  August  1979 
of  Vo lume 22 
the ACM Number  8 
expression e E E that contains a subexpression ~r(a, b, 
...), 7r'(a, b .... ). We write e =* e' if the expression e' can 
be derived from e by a single application of some rule in 
H to one of the subexpressions of e. 
For example, the following is a production system 
that differentiates an expression, containing + and. ,  
with respect o x: 
Dx--* 1 ] 
Dy~O 
D(a + fl) ----) (Da + Dfl) [ 
D(a.fl) ~ ((fl. Da) + (a. Dfl)), [ 
where y can be any constant or any variable other than 
x. Consider the expression 
e = D(D(x.x) + y). 
We could apply either the third production to the outer 
D or the fourth production to the inner D. In the latter 
case, we obtain 
e' = D(((x. Dx) + (x. Dx)) + y), 
which now contains three occurrences ofD. At this point, 
we can still apply the third production to the outer D, or 
we could apply the first production to either one of the 
inner D's. Applying the third production yields 
(D((x. Dx) + (x. Dx)) + Dy). 
Thus 
e" = O(O(x.x) + y) ~ a(( (x .Ox)  + (x .ax) )  + y) 
(D((x. Dx) + (x. Dx)) + Dy). 
In general, at each stage inihe computation there are 
many ways to proceed, and the choice is made nonde- 
terministically. In our case, all choices eventually lead to 
the expression 
((((1. l) + (x .0) )  + ((1.1)  + (x .0)) )  + 0), 
for which no further application of a production is 
possible. 
A production system II terminates over E if there 
exist no infinite sequences of expressions el, ez, e3 .... such 
that el ~ e2 ~ e3 ~ - . .  and ei E E. In other words, 
given any initial expression, execution always reaches a
state for which there is no way to continue applying 
productions. The difficulty in proving the termination of 
a production system, such as the one for differentiation 
above, stems from the fact that while some productions 
(the first two) may decrease the size of an expression, 
other productions (the last two) may increase its size. 
Also, a production (the fourth) may actually duplicate 
occurrences of subexpressions. Furthermore, applying a 
production to a subexpression not only affects the struc- 
ture of that subexpression but also affects the structure 
and size of higher level superexpressions, including the 
top-level expression. A proof of termination must hold 
for the many different possible sequences generated by 
the nondeterministic choice of productions and sub- 
expressions. 
472 
The following theorem has provided the basis for 
most of the techniques used for proving the termination 
of production systems: 
THEOREM (Manna and Ness). A production system 
over E terminates if and only if there exists a well-founded 
set (W, >) and a termination function r:E----~ IV, such that 
for any e, e' ~ E, 
e ~ e' implies z(e) > T(e'). 
To see why this theorem is true, suppose that the 
system does not always terminate although e~ e' implies 
r(e) > T(e') in some well-founded set (W, >). By defini- 
tion, there must be an infinite sequence of expressions 
ei E E such that ea ~ e2 ~ e3 ~ • • .. In that case, there 
exists an infinite descending sequence z(el) > z(e2) >- 
z(e3) >- • • • in IV, which contradicts the assumption that 
> is a well-founded ordering. It follows that the system 
must terminate. 
On the other hand, if the system does always termi- 
nate, then the set E is well-founded under the ~ order- 
ing, where ~ is the (irreflexive) transitive closure of the 
relation =*. Letting (W, >) be (E, ~)  and • be 
the identity function we clearly have e =* e' implies 
~'(e) = e +=, e' = r(e'). 
Several researchers have considered the problem of 
proving the termination of production systems. Among 
them: Gorn [4], Knuth and Bendix [7], and Plaisted [12, 
13] define special well-founded orderings for this pur- 
pose; Manna and Ness [10] and Lankford [8] suggest the 
use of "monotonic" termination functions; Itturiaga [5] 
and Lipton and Snyder [9] give sufficient conditions 
under which certain classes of production systems ter- 
minate. 
In the following examples, we illustrate the use of 
multisets in proving termination. We begin with a very 
simple example. 
Example 1. Associativity. Consider the set of arith- 
metic expressions E constructed from some set of atoms 
(symbols) and the single operator +. The production 
system 
over E contains just one production which reparenthe- 
sizes a sum by associating to the right. For example, the 
expression (a + b) + ((c + d) + g) becomes either 
a + (b + ((c + d) + g)) or (a + b) + (c + (d + g)), both 
of which become a + (b + (c + (d + g))). Since the 
length of the expression remains constant when the 
production is applied, some other measure is needed to 
prove termination. 
Solution 1 (arithmetic). Let the well-founded set be 
(N, >). The termination function ~': E ~ N maps expres- 
sions into the well-founded set, and is defined recursively 
as follows: 
r(a + fl) = 2. r(a) + r(fl) 
Communications August 1979 
of Volume 22 
the ACM Number 8 
for expressions of the form a +/3, and 
r (u )  = 1 
for any atom u. For example, the value of r for the 
expression (a + b) + ((c + d) + g) is 13. 
The key point in the proof is that this function pos- 
sesses the following two important properties (see [10]): 
(1) The value of the termination function r decreases 
for the subexpression that the production is applied to; 
i.e. for any possible values of a,/3, and 3', 
• :((~. +/3)  + 3') > r(~ + (/3 + 3')). 
This is so since 
• :( (a +/3)  + 3') = 2. r(a +/3) + ,:(7) 
= 4. , : (a)  + 2.  r08) + r(3'), 
while 
• : (a + 08 + 3')) = 2. r(a) + ,:08 + 3") 
= 2. , : (a )  + 2.,:(/3) + ,:(y), 
and ,:(a) is at least 1. 
(2) The function r is monotonic in each operand in 
the sense that if 
• :(e,) > ,:(e2), 
for some expressions el and e2, then for any expression 
e3, 
• :(el + ea) > ,:(ez + ea) 
and 
• :(Ca + e,) > ,:(ca + e2). 
Thus if e ~ e', then some subexpression (a +/3) + 3' 
of e has been replaced by a + 08 + 3') to obtain e'. We 
have ,:((a + /3) + 3') > ,:(a + 08 + 3')), by the first 
property. Therefore, by the monotonicity property, we 
obtain 
e ~ e' implies r(e) > r(e'), 
and, by the preceding theorem, it follows that the pro- 
duction system must terminate. 
Solution 2 (multisets). For this solution, we use the 
multiset ordering over the natural numbers, (J/(N), >>), 
and let the termination function r: E -+ J//(PO return the 
multiset of the lengths lal of all the subexpressions of
the form a +/3 in e, i.e. 
,:(e) = {1 a l: a +/3 in e}. 
For example, 
• :((a + b) + ((c + d) + g)) = (I, 3, l, 3), 
since the left operands of the operator + are a, a + b, c, 
and c + d. 
Again there are two crucial properties: 
(l) The value of the termination function ,: decreases 
with each application of a production, i.e. 
• :((,~ +/~)  + 3') >> ,:(,, + 08 + 3')) 
473 
Before an application of the production, the multiset 
• :((a +/3) + 3') includes one occurrence of [a  +/31 and 
one of  l a I, along with elements corresponding to the 
subexpressions of a,/3, and 3'. After application of the 
production, the new multiset ,:(a + 08 + "t)) includes one 
occurrence of [ a I and one of 1/31, leaving the subexpres- 
sions of a, /3, and 3' unchanged. Thus, the element 
]a + /31 has been replaced by the smaller element 1/31, 
and the multiset has accordingly been decreased. 
(2) Since the production does not change the length 
of the expression it is applied to, i.e. 
I~1 = I¢1,  
the length of superexpressions containing (a +/3) + Y is 
also unchanged. 
The only elements in ,:(e) that are changed by the 
production are those in ,:((a +/3) + 3'), and they have 
been decreased by the production. Thus, e ~ e' implies 
that r(e) >> r(e'). 
Example  2. Differentiation. The following system 
symbolically differentiates an expression with respect o 
x: 
Dx---~ 1 
Dy --, O 
D(a + 13) --'-) (Da + Dfl) 
D(a . f l )  ---) ( ( f l .Da)  + (a .Df l ) )  
D( -a )  --'-) ( -Da)  
D(a - fl) ~ (Da - Dfl) 
D(a/fl) ----) ((Dalfl) - ((a. Dfl)l(fl t 2))) 
D(ln a) ---* (Da/a)  . 
D(a  t f l)  ~ ( (Da . ( f l . (a  t ([t - 1)))) + 
(((In a). Dfl). (a t fl)))" 
Solution 1 (arithmetic). Take (N, >) as the well- 
founded set. Let the termination function ,::E ~ N be 
defined by 
• : (~ ®/3)  = ,:(~) + %e),  
where ® is any of the binary operators +, . ,  - ,  and 1', 
,:(Da) = ,:(a) 2, 
• : ( -a )  = r (a)  + 1, 
r0n a) = r(a) + 1, 
and 
• : (u)  = 4, 
for any atom u. 
(1) For each of the nine productions rr ~ rr', the 
value of ,: decreases, i.e. ,:(rr) > ,:(~r'). For example, 
• :(D(alfl)) -- (,:(a) + ":(/3)) 2 
= ,:(a) 2 + r08) = + 2. ,:(a).,:08), 
while 
• : ( ( (Oa l f l )  - ((a. Dfl)108 t 2)))) 
= ,:(a) = + ,:08) = + r (a )  + 2 . , : (8 )  + 4. 
This is a decrease, since ,:(a), ,:08) --> 4 and therefore 
Communications August 1979 
of Volume 22 
the ACM Number 8 
2. ~(a). 0-(fl) _> 4.0"(a) + 4. r(fl) > ~'(a) + 2. ~'(fl) + 4. 
(2) z is monotonic in each operand, for each of the 
operators, e.g. if z(e~) is greater than z(ez), then r(e~. e3) 
= r(el) + ~'(e3) is greater than ~'(e2. e3) = z(e2) + ~'(e3), for 
any e3. 
It follows that e ==* e' implies r(e) > "r(e'). 
Solution 2 (rnultisets). To prove termination, we use 
the multiset ordering over sequences of natural numbers. 
The sequences are compared under the well-founded 
stepped lexicographic ordering ~, i.e. longer sequences 
are greater than shorter ones (regardless of the values of 
the individual elements), and equal ength sequences are 
compared lexicographically. The termination function is 
T(e) = ((dl(u), d2(u) .... ): 
u is an occurrence of an atom in e}, 
where d,-(u) is the distance (number of operators) between 
u and the ith D enclosing it. 
For example, consider the expression 
e = DD(Dy. (y + DDx)), 
or in tree form (with the D's enumerated for expository 
purposes), 
D 1 
/ 
D~ 
! , / \o,  
D~ 
7( 
There are three atoms: y, y, and x. The left atom 2 
contributes the element (0, 2, 3) to the multiset, since 
there are no operators between Da and y, there are two 
operators (. and D3) between Dz and y, and there are 
three operators (D2, •, and D3) between D, and y.' Sim- 
ilarly the other two atoms contribute (2, 3) and (0, 1, 4, 
5). Thus 
~'(e) = {(0, 2, 3), (2, 3), (0, 1, 4, 5)}. 
Applying the production 
D(a.fl) --> ((/8. Da) + (a. Dfl)) 
to e yields 
e' = D(((y + nDx) .  DDy) + (Dy. D(y  + DDx))). 
In tree form (with the labeling of the D's retained), we 
have 
474 
Dl 
/ 
/+\o, 
x D5 
X 
and accordingly. 
z(e') = ((3), (0, 1, 5), (0, 1, 4), (0, 3), (1, 4), (0, 1, 3, 6)}. 
Thus r(e) >>- z(e'), since the element (0, 1, 4, 5) has been 
replaced by five shorter sequences and by the lexico- 
graphically smaller (0, 1, 3, 6). 
In general, the following two properties hold: 
(1) Applying any of the productions decreases z. 
Consider, for example, what happens to the multiset r(e) 
when the production 
D(a. fl) ~ ((/8. Da) + (a. Dfl)) 
is applied to some subexpression of e. Let u be an atom 
occurring in a. Applying the production results in re- 
placing the sequence s = (dl(u), d2(u) .... ) corresponding 
to u, with two sequences, ' and s", corresponding to the 
occurrences of u in Da and a, respectively. But s is 
greater than both s' and s" in the stepped-lexicographic 
ordering: the sequence s" is shorter than s, since there is 
one less D above u; the sequence s' is of the same length 
as s, but is lexicographically ess, since a D has been 
pushed closer to u, while the distance from u to nearer 
D's remains unchanged. Similarly, the sequences corre- 
sponding to the atoms in fl are replaced by two smaller 
sequences. 
(2) The productions only affect he sequences in T(e) 
corresponding to the atoms of the subexpression that 
they are applied to. 
Therefore, for any application of a production, 
e ~ e' implies z(e) >)- ~(e'). 
Solution 3 (nested multisets). Note that he argu- 
ments to D are reduced in length by each production. 
One would therefore like to prove termination using the 
well-founded set (~¢/(N), >>) and a termination function 
that yields the multiset containing the lengths of the 
arguments of each occurrence of D, i.e. z(e) = (l~l:O~ 
in e}. The value of this function is decreased by the 
application of a production, i.e. z(~r) >> r(~r') foreach of 
the productions ~r ~ 7r'. The problem is that the length 
of superexpressions i creases, since I~'1 > I~1; applying 
a production to a subexpression of e may therefore 
increase ~'(e). 
To overcome this problem, we need a termination 
function that takes the nested structure of the expression 
Communications August 1979 
of Volume 22 
the ACM Number 8 
into consideration and gives more significance to more 
deeply nested subexpressions. Fortunately, this is exactly 
what nested multisets can do for us. 
Let the well-founded set be the nested multisets over 
the natural numbers, (J#*(N), >>*), and let the termi- 
nation function T:E---) J//*(N) yield l al for each occur- 
rence of Dc~, while preserving the nested structure of the 
expression) 
~'(,~ ® #) = ~'(,~) u T(#) 
z(Da) = {{I,~1) u ~(a)}, 
r ( -a )  = T(ln a) = T(a), 
and 
~'(u) = { ), 
for any atom u. For example, the arguments of the six 
occurrences of D in the expression D(D(Dx.Dy) + 
Dy)/Dx are D(Dx.Dy) + Dy, Dx.Dy, x, y, y, and x. 
They are of lengths 9, 5, 1, 1, 1, and 1, respectively. 
Considering the nested depths of the D's, the structure 
of the expression is
D(D(Dx. Dy)+Dy)/ Dx 
Thus for 
we have 
e = D(D(Dx.Dv) + Dy)/Dx, 
} t \ \ ~ \ 
I ~l \\ \ \ \ 
~-(e) = { (9, {5, { l ) ,  ( l ) ) ,  {1)) ,  {'1) ). 
(1) For each production ~r ---) ~r', we have 0-(~r) >>* 
T(Tr') under the nested multiset ordering. Consider, for 
example, the production 
D(ot.fl) --) ((fl. Da) + (ot. Dfl)), 
and let ~'(a) and z(fl) stand for the list of elements of the 
multisets ~'(a) and ~'(fl), respectively. Applying ~ to the 
two sides of the production yields 
T(D(a.fl)) = ({la'/~l, ~('~), ~Ge))) 
and 
r((fl. DcO + (c~. Dfl)) 
= {~'~), {I'~I, ~'(~)), ~'(~), {I/¢I, ~(#))) 
This clearly is a decrease in J/g*(N) regardless of the 
exact form of a and fl, since {{ a. fl {, l"(a), r(fl) } is greater 
than (1~1, ~(c0) or (1#1, ~'q~)) and is also greater than 
each of the elements in T(a) and r(fl). 
Consider, for example, 
D(x. Dy) =~ ((x. DD.v) + (Dy. Dx)). 
~An alternative solution would be to let ~(Da) = {0-(d)} and 
• (~) = {z} .  
475 
We have 
z(D(x.Dy)) = {{4, {1)}), 
while 
• (((x.DDy) + (Dy.Dx))) = ((2, ( l ) ) ,  {l), ( l ) ) .  
This is a decrease in the nested multiset ordering, since 
{4, {1)} is greater than both {2, (1}} and {1}. A similar 
argument applies to all of the other productions. 
(2) It remains to ascertain what happens to the value 
of z for superexpressions. The crucial point here is that 
the termination function gives greater weight o the more 
deeply nested D's by placing their lengths at a greater 
depth in the nested multiset. The decrease in r for the 
subexpression to which the production is applied over- 
shadows any increase in the length of a superexpression. 
Consider, for example, 
D(D(x.x) + y) ~ D(((x. Dx) + (x. Dx)) + y), 
The value of T for the expression on the left is 
((6, {3})), while for the right-hand side expression it is 
(( 11, (1 }, ( 1 } } }. Note that this represents a decrease in 
the nested multiset ordering over N, despite the fact that 
the element 6, corresponding to the length of the top- 
level expression, has been increased to 11. This is the 
case since the production has replaced the element (3} 
in the multiset (6, (3} } by two occurrences ofthe smaller 
{ 1}, and {3} is also greater than 11--or any number for 
that matter--on account of its greater depth. 
Thus, e ~ e' implies r(e) >>* r(e'). 
In this section, we have illustrated the use of multiset 
and nested multiset orderings in proofs of termination of 
production systems. Along similar lines, using these or- 
derings, one can give general theorems which express 
sufficient conditions for the termination of broad classes 
of production systems. 
Acknowledgments. We thank R.S. Boyer, J. Doner, 
C. Goad, J. McCarthy, S. Ness, A. Pnueli, A. Pridor, W. 
Sherlis, and R. Weyhrauch for stimulating discussions 
and the referees for their helpful comments. 
Received June 1978; revised November 1978 
References 
1. Dijkstra, E.W. A small note on the additive composition of 
variant functions. Note EWD592, Burroughs Corp., Neunen, The 
Netherlands, 1976. 
2. Floyd, R.W. Assigning meanings to programs. Proc. Symp. in 
Applied Math., Vol. 19, Amer. Math. Soc., Providence, R.I., pp. 19- 
32. 
3. Gentzen, G. New version of the consistency proof for elementary 
number theory (1938). In The Collected Papers of Gerhart Gentzen, 
M.E. Szabo, Ed., North-Holland, Amsterdam, 1969, pp. 252-286. 
4. Gorn, S. Explicit definitions and linguistic dominoes. Proc. Conf. 
on Syst. and Comptr. Sci., London, Ontario, Sept. 1965, pp. 77-115. 
5. Iturriaga, R. Contributions tomechanical mathematics. Ph.D. 
Th., Carnegie-Mellon U., Pittsburgh, Pa., May 1967. 
6. Katz, S.M. and Manna, Z. A closer look at termination. Acta 
Inform. 5, 4 (1975), 333-352. 
Communications August 1979 
of Volume 22 
the ACM Number 8 
7. Knuth, D.E. and Bendix, P.B. Simple word problems in universal 
algebras. In Computational Problems in Universal Algebras, J. Leech, 
Ed., Pergamon Press, Oxford, 1969, pp. 263-297, 
8. Lankford, D.S. Canonical algebraic simplification i  
computational logic. Memo ATP-25, Automatic Theorem Proving 
Project, U. of Texas, Austin, Texas, May 1975. 
9. Lipton, R.J. and Snyder, L. On the halting of tree replacement 
systems. Proc. Conf. on Theoret. Comptr. Sci., Waterloo, Ontario, 
Aug. 1977, pp. 43~16. 
10. Manna, Z. and Ness, S. On the termination of Markov 
algorithms. Proc. Third Hawaii Int. Conf. on Syst. Sci., Honolulu, 
Hawaii, Jan. 1970, pp. 789-792. 
!1. Manna, Z. and Waldinger, R.J. Is SOMETIME sometimes better 
than ALWAYS? Intermittent assertions in proving program 
correctness. Comm. ACM 21, 2 (Feb. 1978), 159-172. 
12. Plaisted, D. Well-founded orderings for proving the termination 
of rewrite rules. Memo R-78-932, Dept. of Comptr. Sci., U. of 
Illinois, Urbana, IlL, July 1978. 
13. ~laisted, D. A recursively defined ordering for proving 
termination of term rewriting systems. Memo R-78-943, Dept. of 
Comptr. Sci., U. of Illinois, Urbana, I11., Oct. 1978. 
Operating R. Stockton Gaines 
Systems Editor 
Secure Personal 
Computing in an 
Insecure Network 
Dorothy E. Denning 
Purdue University 
A method for implementing secure p rsonal 
computing in a network with one or more central 
facilities is proposed. The method employs a public-key 
encryption device and hardware keys. Each user is 
responsible for his own security and need not rely on 
the security of the central facility or the communication 
links. A user can safely store confidential files in the 
central facility or transmit confidential data to other 
users on the network. 
Key Words and Phrases: personal computing, 
security, privacy, networks, public-key encryption 
CR Categories: 2.12, 6.20 
476 
I. Introduction 
Within the next ten years many of us will have 
personal computers linked to a central facility. The 
central facility (CF) will offer many attractive features: 
long-term storage, text editors, language processors, pe- 
Permission to copy without fee all or part of this material is 
granted provided that the copies are not made or distributed for direct 
commercial dvantage, the ACM copyright notice and the title of the 
publication and its date appear, and notice is given that copying is by 
permission of the Association for Computing Machinery. To copy 
otherwise, or to republish, requires a fee and/or specific permission. 
This work was supported in part by National Science Foundation 
Grant MCS77-04835. 
Author's address: D.E. Denning, Computer Science Department, 
Purdue University, West Lafayette, IN 47907. 
© 1979 ACM 0001-0782/79/0800-0476 $00.75 
Communications August 1979 
of Volume 22 
the ACM Number 8 
