Theoretical Computer Science 50 (1987) 137--181 North-Holland

137

J.A. BERGST
Department of Computer Science, University of Amsterdam, 2098 SJ Amsterdam, The Netherlands, and Department of Philosophy, University of Utrecht, 3584 CS Utreeht, The Netherlands
J.V. TUCKER
Department of Computer Science, University of Leeds, Leeds LS2 9JT United Kingdom
Communicated by J.W. de Bakker Received December 1979 Revised April 1986
Abstract. An extensive survey is given of the properties of various specification mechanisms based on initial algebra semantics.

Conteds
Introduction ...................................................................... 1. Algebraic specification methods ..................................................... 2. Specifications with hidden functions and hidden sorts .................................. 3. Computable and semicomputable algr bras ............................................ 4. Limitations of specifications without hidden mechanisms ............................... 5. Adequacy and completeness theorems for specifications with hidden mechanisms .......... 6. Completing the classification. ....................................................... 7. Concluding remarks ...............................................................
Acknowledgment .................................................................. References .......................................................................

137
140
149 153
159
168 172 178 179 179

Background Axiomatic methods for data type specification arise from the idea that a data
type D in a programming language L, or program P, should be formally characterized in L, or P, as a collect-‘q,1 C of operators which have properties defined by a set E of axioms. The axiomatk specification (2, E) is meant to be a contract in w
* Partially supported by ESPRIT Project No. 432 METEOR.
0304-3975/87/$3.50 @ 1987, Elsevier Science Publishers B.V. (North-Holland)

138 J.A. Bergstra, J. K Tucker
settles the syntactic structure of 0, and E guarantees a set of features common to all implementations of D. Algebraic specification methods are the simplest of the axiomatic methods in so far as they use the simplest axioms which are algebraic formulae such as equational laws.
Axiomatic data type specifications were first seen in Van Wijngaarden’s study of computer real arithmetic [57], but the full extent of their role for general user-defined types emerged later, through the work of Hoare on program specification and correctness [25,26,27], and Parnas on modularization [43,44]. The algebraic specification methods originate in Liskov and Zilles [34], Zilles [59], Guttag [21] and ADJ [l7]. Simple, elegant, and ideally matched to art algebraic view of the semantics of data types, the algebraic specification methods have proved to be a versatile tool for thinking about problems to do with data in the design and implementation of programming languages: see Wulf [SS] and the bibliography by Kutzler and Lichtenberger [29].
But these investigations, with their diverse programming objectives, have not easily grown into a theor), of algebraic data type specification. The subject has been made with widely varying standards of conceptual precision and mathematical rigor, and has been troubled by technical problems of an algebraic nature. One thinks of the literature generated by Majster’s transversable stack [37] which fails to have the much favoured, finite equational specification. This important observation signalled a growth to profusion of algebraic specification techniques, many informal and defective, some ad hoc, designed for particular examples.
Classijication programme The purpose of this paper is to review concisely the mathematical basis of the
algebraic approach to data type specification, and organize a proper mathematical analysis and classification of the algebraic specification methods that gives technical insight into the methods, and a theoretical assessment of their scope and limits. We will concentrate on equational and conditional equational specifications, with and without hidden operators, using initial algebra semantics, as developed by the ADJ
ata types with total operators; see ADJ [ 17, 18, 51, 521. However, the tools and techniques can be used to extend the classification programme 0to include other specification methods.
In Sections 1 and 2 we shall carefully describe the syntactic and semantic structure of an algebraic specification technique. This leads us to a taxonomy of 27 specification methods: 9 not involving hidden machinery, 9 allowing hidden operators, and 9 allowing hidden types and operators. For these methods we shall formulate comparison qdestions of the form: Given two algebraic specijkation methods M and M’, is M more generally applicable or more powerful than M’, are
uivaient, or are they disparate in their powers of definition? 1~:the course of er, we shall compietely answer such questions for all the methods not allowing hidden machi ery, and we will almost complete the classification of the other techniques. The situation is summarized in Figs. 1 and 2 in Sections 1 and 2.

Algebraic specificaths of (semi jcomputable data types

139

In making the classification, where possible, we shall surve:’ relevant information and results existing in the data types literature and in the mathematical literature, but usually we shall prove or reprove what we need here. For example, in Section 4, we shall prove in detail that the simple numerical structure
((0, 1, . . .}; 0, x+ 1, X2)
cannot be specified using finitely many equations and initial algebra semantics, unless auxiliary or hidden operators are permitted. Also, in Section 4, we shall prove in detail that the simple structure
w, 1,l l -1,it rue, false]; 0, x + 1, p, me, false),
wherep:{O, 1,. . .) + {true, false} is the characteristic function of the prime numbers, cannot be specified using finitely many conditional equations and initial algebra semantics, but it can be given a specification by using finitely many equations and auxiliary functions. These results are related to work on the role of hidden operations by ADJ [52] and Majster [37,38]. Other counterexamples cam be found in Section 6.
In Section 3 we shall carefully define the nature of an effectively calculable data type in terms of computable and semicomputable many-sorted algebras. This leads to the concepts of soundness, adequacy, and completeness for algebraic specification methods and, in particular, to adequacy and completeness questions of the form: Can the specification method M define all, and only, the data types one wants, at least in principle ?
In Section 5, we shall prove the following adequacy theorem. Any computable data
type A can be algebraically specified by a finite set E ofequations, involving a finite
set C of operators, some external to A, using initial algebra semantics for (2, E) (Theorem 5.1). Such specifications can derine semicomputable but noncomputable types, however. Using the adequacy result, we will be able to prove the following completeness theorem (Theorem 5.3).

Theorem. A data type A is semicomputable ifand only ifit can be algebraically specijed by a Jinite set E of equations, involving a finite set C of operators and data domains external to A, using initial algebra semantics for (2, E ).

The question as to whether or not hidden sorts are necessary for the finite specification of the semicomputable data types is an important open problem (Open Problem 3.15).
The need for a systematic and rigorous survey seems to have been first recognized by Kamin whose admirable notes [3O] summarized specification techniques, associated with initial algebra semantics, and posed a number of questions about the differences between them. Answers to those questions can be found commentary which settles some other technical matters raised in [30] (hidden function mechanisms; unitrersality).

140 J.A. Bergstru, J. V. Tucker
An objective of this paper is to serve a variety of readers as an essentially self-contained and reliable compendium of theoretical facts about specifications. Part of our material may seem familiar to some readers, but it is a fact that no theorem is given here which has an adequate statement and/or proof elsewhere. For example, our account of the adequacy and completeness theorems and problems stated above contradicts a popular and mistaken idea, originating in Guttag [21], that the adequacy of the algebraic specification method is evident from the equational definition of the partial recursive functions.
Further work and prerequisites This paper is a cornerstone for a series of articles [3-l l] which further develops
the classification project according to the principles seen here; in particular, it is a second edition of [4]. Among the subjects considered are: implementing equational specifications as rewrite systems and the completeness of the method for computable data types [S]; the size of algebraic specifications and adequacy theorems for computable data types [6,7]; proving specified programs using data type specifications [9]; completeness of methods based on final algebra semantics for the cosemicomputable data types [8, lo]; completeness of methods based on initial find final algebra semantics for computable data types [ll]. See Section 7 (Concluding remarks) for further comments.
We presume the reader is familiar with the informal issues and basic mathematical ideas about algebraic specifications, for which we follow and recommend ADJ [lS, 51,523. The papers Kamin [30] and Majster [37,38] are also useful to have at hand. In addition we use some basic results from recursive function theory for which we recommend Mal’cev [39] or Rogers [47]. The reader will also find the paper by Meseguer and Goguen [42] of value in seeing our work in a broad context.
ecification methods
In this section and the next we shall survey the mathematical foundations of the algebraic specification methods for data types in order to establish notation and terminology, and, in particular, to explain in detail the classification scheme for the methods. A number of subjects require commentaries: axiomatic specifications; algebraic specifications and their algebraic semantics; the use of hidden or auxiliary operators and sorts in specifications; but we begin with a discussion of the concept of an abstract data type.

seven interpretations be found supporting

any informal usages an few precise definitions in the mmg languages and methodology. For instance, Cries lists in his editorial notes in [20, pp. 263-2681 and all of them can r6les to play in the subject of abstract data types and their

Algebraic specifca tions of ( semi )computable data types

141

specification. There is, however, an exact meaning for the term abstract data type which is invariably used (often implicitly) in work on algebraic specification methods. The mathematical definition is essentially due to the ADJ Group and appears in [l’?] although its essential features are more carefully explained in [ 181. We shall quickly reconstruct the definition, noting any correspondences between our technical vocabulary and the usages in Gries’ list.
First, consider a data type D whose syntactic structure is determined by a list of names for different kinds of data (for use in variable declarations) and lists of notations for distinguished data and basic operations (for use in assignments and in tests for control constructs). These items we call sort, constant, and operator symbols, respectively, and the union C of the lists we refer to as the signature of D. (In Gries’ notes, the first interpretation of type is restricted to signatures.)
What makes such a data type D an ‘abstract’ data type is a property of its semantics namely, the semantics of D is de$ned quite independently of how data and operations are to be represented in implementations. This criterion is made precise via the semantical concept of a data structure which formalizes the third, and most popular, informal description in Gries’ list (and subsumes the second). Throughout this pa we assume that every signature permits at least one closed term for each sort.
A data structure is a finitary many-sorted algebra which is minimal in a sense to be defined below. Thus, a data structure A consists of a finite family A,, . . . , A,, of sets, called co.mponent data domains, together with a finite list of elements of these sets, and a finite family of (total) functions of the form

where A=(& ,..., hk) and Al,..., Ak, pE{l,..., n} and k~w-{O}. The distinguished elements are called the initial data of the structure and the maps are called the primitive operations of the structure.
A many-sorted algebra is minimal, or prime, if it is generated by its distinguished elementc, or eqrlivalently, if it has no proper subalgebras. This minimality condition in the definition cf a data structure ensures that every element of a data structure can be constructed from its initial data by means of its primitive operators.
A data structure A exactly describes how the syntax of a data type n is ~~t~~~~et~~ in a concrete implementation or partit ular representation of the se antics of D. The representation-free picture of the semantics of a data type, required in she CQ~~X$ of an abstract data type, can be achieved by adopting the foll wing Ips’iflc:;>I2.
ition (Abstraction Principle). A property P of a data stsructure as an abstract semantical property of the data type D which if P is an invariant of algebraic isomorphism; i.e., if
g or representing D, and A and are iso

For example, finiteness is an abstract property and, moreover, any property of a data structure which is jirst-order de$nable is an abstract property. In a later section

142 J.A. Bergsrra, J. V. Tucker
we shall define the eflective computability of a data structure in such a way as to make it an abstract property of a data type. With this kind of analysis of the abstract nature of a data type semantics, the AD.I Group gave the following semantical definition of an abstract data type in [ 181.
efinition (Abstract data type). An abstract data type is the isomorphism class of a data structure.

For information on the invariance of semantical properties of programs based on abstract data types, see Tucker and Zucker [53].
Mathematically, the theory of abstract data types is the theory of finitely generated minimal algebras. We assume the reader is familiar with the basic algebra of congruences, homomorphisms and so on, and can establish, when needed, facts such as the following lemma.

1.3. Lemma. Let A and B be ,minimalalgebras of signature 2. Ifthere are homomorph-

isms+:A+Band$:B+A,

thenA=Bvia&and&

Nowhere in this paper do we allow partial operations in our types.
Axiomatic specifications A first-order axiomatic specification (2, T) describes a data type as a signature C
whose constants and operator symbols satisfy a set T of first-order axioms. In Hoare’s seminal paper [25], a specification is a formal documentation for a data type D which guarantees properties of implementations of D for use in proving the correctness of programs using D. The idea of axiomatizing implementations is suited to an abstract (read: ‘representation-free’) view of data type, but alone, without special algebraic devices, it does not support a method which uniquely defines abstract data types. For consider the semantics of a first-order specification (2, T).
From the logical point of view, the natural semantics of (2; T) is the class ALG(Z, T) of all C-structures satisfying the axioms in T. This is because of Gijdel’s Completeness Theorem.
(Completeness Theorem). A first-order statement p is provable from T if and only if it is true in all models of T; in the usual notation,
T+p if and only if Tl=p.

tit’ data structures

e Lowenheim-Skolem Theor ything to do with data types.

few of the members of therefore define the class

ALG,(& T) = {A E ALG(Z, E) : A is minimal}.

Algebraic specijcations of (semi)computable data types

143

The class ALG,(Z, T) consists of all implementations consistent with the conditions in T. As the class is closed under isomorphism, and contains nonisomorphic data structures, ALG,(Z; T) serves as the semantics of specification (2, T) when the
latter is thought of as a contract open to interpretation by a numbt:r of different
abstract data types-an interpretation appropriate to program verification [9,12,13].
However, to be able to define an abstract data type by means of an axiomatic specification (Z, T) some semantic mechanism Ju is necessary which chooses, uniquely up to isomorphism, an algebra Ju(Z, T) E ALG,(Z, T) as the meaning of the specification (Lc,T). Given any such mechanism .&, we say that an abstract data type D (read: ‘isomorphism type of a minimal algebra’) is correctly specijied by an axiomatic vpecijkation (2, T) under semantics Ju if the algebra JR@, T) is in D.
This assignment by .& cannot be accomplished by logical means for first-order
specifications in general; it can be made by algebraic techniques for algebraic
specifications.

Algebraic specijications According to usage, a first-order specification (X, T) is called an algebraic
specijcation when the axioms in T ‘look algebraic’. In this paper, we shall consider specifications made with three simple kinds of algebraic axioms only: simple equations, or identities; equations; and conditional equations.
Let T(Z) denote the algebra of (closed) terms over C and let T,(X,, . . . , X,,) = Tr (X) be the algebra of all terms of polynomials over C in the indeterminates X=(X ,,..., X,).
A simple equation, also called a simple identijication, is an axiom of the form t = t’ where t, t’~ T(C). An equation is an axiom of the form t(X) = t’(X’) where t(X) E T,(X) and t’(x)) E T,(X’). A conditional equation is an axiom of the form
el /\ l ’ ’ /\ ek - ek+, ,
where each ei, 1 c i < k, snd ek+l is an equation. In the obvious notations, the sets of such axioms are *rested thus:

LSEQV)

AEQ(Z)

CEQ(Z).

Here then, an algebraic specification (2, E) will be a simple equational specijication if E c SEQ(2); an equational speci$cation if E c EQ(Z); or a conditional equation specijication if E c CEQ(Z). In particular, axioms involving negation, exljlicitly or implicitly, are not allowed in specifications: for example, no inequalities t f t’ or definition-by-cases t = ii
Shortly, we shall need to discuss computations on syntax in the arguments that
follow, so we assume that the various sets

Y(z), CEQ(V,

etc.

have been godel-nurnb~~ed by means of the set w = (0, I,. . .}. On being given the giidel number of a term, polynomial, axiom, etc. we can primitive-recursively

144 LA. Bergstra, J. V. Tucker
calculate godel numbers for its subterms, and the complexity of its syntax. Furthermore, in saying that E c CEQ(z) is a recursive or recursively enumerable set (for example), we actually mean that, with respect to the gijdel numbering S: O+ CEQ( C ), the set S-‘(E) = (i : 6(i) E E} is recursive or recursively enumerable. And in saying that E = {ei : i E o} is recursively enumerated by $: o + CEQ(z), where f(i) = ei, we actually mean that f: o + cr)is a recursive function such that 6j: w + E is surjective.
Semantics of algebraic specifications The choice of an algebra Ju (2, E) in AL&,( 2, E) as the meaning of the algebraic
specification (2, E) is most simply made by using initial algebra semantics. When E contains conditional equations, the category ALG( X, E) of all E-algebras
and all homomorphisms between them possesses an initial object I(& E), unique up to isomorphism. Furthermore, I(& E) E ALG,( 2, E) and we can define Ju( 2, E) to be I(& E) (cf. ADJ [17,18-J).
Let A be a minimal algebra or data structure, representing the abstract data type D. Then the specification (2, E) correctly defines the type D under initial algebra semantics if
Z(2, E)=A.
The practical effect of this method is to declare two operator terms of T(z) to be semantically equivalent if and only if they can be proved equal by using the axioms of E and the rules of first-order logic, as expressed in the following theorem.
(Provability Criterion). For any l, t’ E T( 25)
fit-t=t’ ifandonlyif Z(Z;E)l=t=t’.
Compare this with the Completeness Theorem 1.4. We must assume that the reader is familiar with the basic algebra and logic involved in constructing and using initial algebra semantics. For example, we shall make great use of the construction of I(& E) as a factor algebra T(z, E) of T( 2). Recall that, for E c CEQ(C), a congruence = on a z-algebra A is an E-congruence if, for each conditional equation e of the form
I, = t; /\ l ’ * A tk = t;+ fk+, = t;+,
where tiy t: E Tz( ), lci<k+l, we have that
t,(a) = t’;(a), . . . , tk(a) = t;(a) implies tk+,(a)= t;+,(a)
for all a E A,, x l l xl A,,,. Equivalent, = is an E-congruence if A/= is in ALG(Z; E). The intersection of all E-congruences on A is an E-congruence called the least E-congruence on A, and is denoted = E (when A is understood).

Algebraic specijications of (semi)computable data types

145

Now, consider the least E-congruence on T(Z), and define
T(2, E) = T(Z)/=..
It can be shown that I(& E) = T(2, E). In working with T(2, E) we shall make use of transversals for = E: Let = be a
congruence on A. A transversal T for = is a complete family of unique representations of = in the sense that (i): for each a E A there is t E T such that a = t, and (ii): for each t, t’ E T, t = t’ implies t = t’. (We have adopted here the name ‘transversal’ from the algebra of groups.)

I.6 Lemma. T(Z, E)= T(&(~ESEQ: EI-e}).

1.7. Lemma. If E is a set of equations, then
T(Z, E) = T(X, (e E SEQ: e is a substitution instance of some e’e E)).
Initial algebra semantics is the denotational device used to assign 2 meaning to a specification in the early works of the ADJ Group [17] and in Liskov and Zilles [34,59], and it is the only semantics considered in this paper. However, initial algebra semantics is not the semantics desired by Guttag [21] (see [22] for an explicit statement to this effect). The semantical status of an algebraic specification is far from clear in Guttag’s early work; perhaps his requirements are best met by the jinal algebra semantics of Wand [55] and the Munich Group [14,56]. Final or terminal algebra semantics is a category-theoretic dual to initial algebra semantics in which provability is replaced by logical consistency. We have considered the technique in [8,10,11].

ClassiJication of spec$ca tion methods An alget_laic specification method is characterized by the nature of its axicms
and the nature of its semantical mechanisms. We consider methods based on initial algebra semantics and three types of axioms. Yet, in a specification (2, E) the set E of axioms may be a Jinite, recursive, or recursively enumerable set of simple identities, equations or conditional equations. This amounts to 9 possibilities; later we shall discuss two further refinements of specification methods, involving auxiliary operations and sorts, that lead to a classification of 27 methods. For the moment, let us make a notation for the 9; let
FPN.
denote finite, recursive, and recursively enumerable and let
SEQ, EQ, and CEQ
denote simple equations, equations, and conditional equations.

146 J.A. Bergstra, .LV. Tucker

Let ar E {FIN, REC, RE} and p E {SEQ, EQ, CEQ}. A specification (Z, E) is of type (cy,p) if E is a set of type LYcontaining axioms of type p.

. An abstract data type represented by many-sorted algebraic structure ) spec$cation under initial algebra semantics if there is an (a, p)
specification (2, E) such that T(Z, E) s A.

les. Consider the following four important

(0,1,2, . . .} of natural numbers:

A1 = (w; 0, x + l),

A,=((o;O,x+l,x+y),

structures

on the set o =

A3=(~;0,x+1,x+y,x-y),

A,=(w;O,x+l,x+y,x-y,x2).

These structures have the following (FIN, EQ) specification:

2, = (NAT; 0, succ),

E, =0,

E2 = {ADD( X, 0) = X, ADD( X, succ( Y)) = SUCC( ADD( X, Y))},

&=(NAT;O,SUCC,ADD,MULT),
E3 = E2 u { MULT( X, 0) = 0, MULT( X, succ( Y)) = ADD( MULT( X, Y), X)},

&=(NAT;O,SUCC,ADD,MULT,SQ),

E4= E,v{SQ(X)=

MULT(X, x)}.

We leave the task of verifying that, for i = 1, . . . ,4, I(Z’i, Ei) s T(Zi, Ei) s Ai
as an easy, yet essential, exercise.

These 9 types of specification are completely classified in Fig. 1, where in a single arrow (cy,p) + ((Y’,/3’) indicates that any data type that can be given an (cu,p) specification can be given ar (cy’,p’) specification, but not conversely; and a double arrow (cy,p) e ((Y’,/3’) indicates that the two kinds of specification define the same data types. Figure 1 also registers the adequacy of the methods with respect to the finite, computable, and semicomputable data types; this will be taken up later in Section 3. Figure 1 conveniently records many theorems, of varying difficulty, distributed throughout the paper. Some results are easy and can be proved here, for an illustration. However, most results are best established with the semantical concepts of computable and semicomputable data type at hand; we shall comment on Fig. 1 then.

be a many-sorted algebra of signature C. Then the following

C EQ) specification.

Algebraic specijcations of (semi)computable data types

complete for semicomputable data types
(RE, SEQ)
(REC. CEQ)

WE,CEQ)
(1.10) (3.15)
I

147

I (ref. PI)

I I.WC. EQ)

adequate for computable data types
adequate for finite data types
Fig. 1. Classification of the 9 algebraic methods (without hidden machinery). Arrows point from a class to a strictly larger class; the label indicates where the strictness result is shown.
Proof. By virtue of the definitions, it is sufficient to prove that statement (iii) implies statement (i). Suppose A = T(Z, E), where E is an r.e. set of conditional equations. Then define

By Lemma 1.6, T(Z’, E) = T(Z, E’). Clearly, E’ is r.e. and hence, A has an (RE, SEQ) specification. 0

Let A tve a many-sorted algebra of signature 2. Then (REC, EQ) specification if and onldv if A has a (REC, SEQ) specifkation.

has a

Clearly, every (REC, SEQ) specification is a (REC, EQ) specification. To the converse, suppose that A has REC, EQ) specification V, El, i.e., E is a recursive set of equa;ions over C and = T(Zi, E).
Define E’ to be the set of all simple equations obtained by substituting all close
terms over C into the equations of E. Thus,

E’={t=t’:forsome

e,=e,EE and t,,...,t,cT(Z)

t = e&. . . 5t,) and t’= ez(t,, . . . , r,)).

148 J.A. Bergstra, J. V. Tucker
By Lemma 1.7, we have T(Z; E) = T(2, E’). We claim that E’ is recursive. Now, given t = t’ with t, t’ E T(Z), there are finitely many equations e, = e2E
EQ(Z), the set of all equations over 2, such that there could exist tl, . . . , tnE T(2) with
t=e,(t,,.. . , tn) and t’= e2( tl, . . . , t,,).
e lengths of the equations are constrained by the lengths of the terms t, t’; in fact:
Thus we can search through all equations and find those e, = e2 for which t = t’ is a substitution instance, and decide whether or not e, = e2E E since E is recursive. Thus, E’ is recursive. Cl
reposition. Let A be a jinite many-sorted minimal structure. 7’hen A has a (FIN, SEQ) specijication.
roof. For each element b of A, let tb E T(X) be a term that evaluates to b in A (Using minhality). Let us axiomatize each operation CA of A
& = 14 fb,,..., fb,)=fb:gA(b ,,..., b,)=b}
and set

Then it may be proved that T(2, E) s A. Cl
Constructing specifications We shall state a series of theorems about constructing algebras and their
specifications which are of general interest and which will be employed in many of the proofs of this paper.
Let A and B be algebras with signatures C and C’ respectively; and suppose that Z f7 2’ - 8. The join [A, B] of A and B is the algebra of signature C u 2’ obtained by taking all the domains, constants, and operations of A and B together to form one algebra. The effect of this operation on algebraic specifications is this:
emma). Suppose = T(X, E) and = T(27, E’). Then [A, B] =

algebra with signatu

’ be a set of conditional equations

= E’ denote the least ‘-congruence on A.

Algebraic specijica tions of ( semi ) computable data types

149

(Factor Lemma). Suppose A = T(2, E). Then, /E~Z T(& Eu E’).

5. (Refinement Lemma). SupposeA= T(& E). IfE%EmdAt= A= T(Z, E’).

E’, then

Let A be an algebra with signature C and let let f: A,, x l - l x A*” + AP be a function on A. On adding f as an operation we obtain an algebra Ar with signature Zf=2u{F}.

Suppose A = T(Z, E ). We can algebraically specify Af by a straightforward representation of the graph of jI Let T be a set of canonical term representatives,

or a transversal, of = E. The map f on A uniquely induces maps 1 and IT on T(.Z, E) and T in the obvious way:

f

A,,x.-•xA~,,-A
44

YTTx7-i(-i,&TTWwEV)),,,T(X,E),,x

ll l

I-L

TA,x l l xl TA, -

TP

Here u: T(Z)+ T(Z)/= E is the canonical factor map v(t) = [t] which is a bijection on T. We define

Efu)={w

,,..., t,)= t:j;(t ,,...,

which represents the graph off on T.

t,)= t}.

1.16. Lemma (Function Lemma). Suppose A = T(2, E) and f is a map on A. For
any transversal T, Af = T(Zf, E u Ef ( T)).

The specification methods classified by Definition 1.8 have the property that only the sorts and operations of the data type signature are allowed in specifications of the data type: if A is of signature 2, then A must be axiomatized by a set E using the operations in C only. These methods can be augmented usefully by allowing extra, auxiliary sorts and functions in specifications ( ‘, E’) that are not re in A, so CCC’.
. Consider the algebra
A5 = (0; 0, x+ 1, x2).

150 LA. Bergstra, J. V. Tucker
The natural way to specify A5 is to specify the algebra

by means of the (FIN, EQ) specification (&, &) in Example 1.9 and then to forget or to Me the operations of addition and multiplication. Later we shall prove that it is not possible to specify A5 without recourse to hidden operations.

To put such techniques on a proper foundation, we must define the mechanisms of hiding the auxiliary operations. Let B be an algebra of signature C and let &c C. We define two algebras:
(1) BI,, is the algebra consisting of the domains, constants, and operations of B named in &; and
(2) (B)& is the subalgebra of BI, generated by elements named in &.

2.2. (9 (9
(iiij

TIaefollowing statements are equivalenr : &,, is minimal; BIh = U9h;
Bl,,=(B&,.

.3. mma. Let B be of signature C and let &c 2, c 2. Then,
(9 m,&) =BI,;

2.4. mma. Let B and B’ be Z-algebras. Let 4 : B + B’ be a E-homomorphism. Then the restrictions
4 : BI,+ B’I, and +:(B)p(B’),,
are &-homomorphisms.
These two contraction methods lead to three kinds of specifications allowing hidden functions and three kinds of specifications allowing hidden sorts and functions. For in either case, in the specification of A of signature &, an algebra B of signature & with ZAc 2, is constructed and specified, and we may choose one of the following (writing C = &):
(ii) (B), = A; =A. EC, RE} and /3 E {SEQ, EQ, CEQ}. Let A be a many-sorted algebra
of signature 2 representing an abstract data type.
S. n (a, p) hidden function specification of type I, or III for A consists of an algebrizlic specification (.X0, Eo) of type (CYp,) such that C c & and

Algebraic specifications cf (semi)computable data types

151

& contains exactly the sorts of -C,and which defines A by means of initial algebra semantics in one of the following three ways respectively:
type I: type II: ( T(&, Eo))= = A; type III: T(&, E& =(T(&, E,)), =A.

2.6. Definitions. An (cy,p) hidden sorts specijkation of type I, II or III for A consists of a specification (&, EO) of type (cy,p) such that C = & and which defines A by means of initial algebra semantics in one of the following three ways respectively:
type I: T(&,, &,)I, =A;
type II: (T( Eo, E,))= = A;
type III: T(& E& = (T(&, E& = A.

In Kamin [30], type I specifications are said to be the usual interpretation of hidden functions and sorts and type II specifications are said to be the subalgebra interpretation. In the standard case that A is a C-minimal algebra, a type I specification is also a type II specification and a type III specification (Lemma 3 2).
In this paper we shall consider only specifications of type III, and introduce the following terminology [4].

2.7. Definitions. An (cy,p) hidden enrichment specijcation for A is an (cy,p) hidden functions specification of type III for A. An (QI,p) hidden enrichment with sorts specification for A is an (cy,p) hidden sorts specification of type III for A.

For example, (&, EJ is a (FIN, EQ) hidden enrichment specification of the

algebra A5 of Example 2.1.

In addition to the 9 types of specification methods defined in the last section, we

can consider a further 9 types of specification method that allow hidden functions

and 9 types of specification method that allow hidden sorts and functions. This

makes 27 methods in total, all based on initial algebra semantics.

Thus, let cyE {FIN, REC, RE} and p E {SEQ, EQ, CEQ} and let y E (

where WE and HES stand for hidden enrichment and hidden enrichmen

respectively. The first 9 types of specification are abbreviated (cy,p) as before; the

18 new types of specification are abbreviated (

Once again we shall summarize what is kno

classification in

majority of eqluivalences will easily follow fro

CQ

(see the next section).

We conclude with two lemmas.

152 J. A. Bergstra, J. V. Tucker

complete for semicomputable types (RE, SEQ)

(RE. SEQ. HES)

W, EQ,HES) W, EQ,HEI

(RE, CEQ, HES)
(RE,CEQ.HE)

(REC. SEQ. HES) (REC. SEQ. HE)

(REC. EQ, .,(ES) (REC. EQ. HE)

(REC. CEQ, HES) (REC. CEQ, HE)

adequate for computable types
Fig. 2. Classification of the 18 algebraic methods (using hidden machinery). All qcestkt; masks refer to the problem of showing that the dotted arrow does not exist (i.e., the other arrow &i&es a proper inclusion). Now, ?(l) and ?(3) can presumably be easily settled in a way similar to Lemma 4.5 or Theorem 6.10. However, ?(2) and ?(4) seem to be difficult open questions.
Let (2, E) and (27, E’) be specijications with CCC’ and EC E’. C and 2’ contain the same sorts. Suppose there exists a transversal Tc T(2) for =E such that (i) for distinct tl , t2 E T, t, $ E’ tZ; (ii) for each constant c E 2’ - 2, there is a t E T such that c = E’t; (iii) for each k-ary operation u E C’- C and any t,, . . . , tk E T, there is a t E T such that o(t ,,..., tk) =En t. Th,sn T(Z’, E’)I, = T(2, E).
Since E C E’ and T is a transversal, it is easy to se? that 4( [ f]E) = [ &, (for t E T) well defines a Z-homomorphism
4: T(2, E)+ T(Z’, E’&.
Condition (i) implies 4 is injective because if t,, tzE T and [t& f [t&, then [ t&‘# [ &‘. Conditions (ii) and (iii) imply that d) is surjcctive as follows: we show
at for each t’c (2’) there is a t E T such that t = El t’. Now, if t’E T(Z), then t =E t’ for some t E T and so t = El t’ as GE is contained in E E’- Assume t’E T(Y) - T(Z). We argue by induction on the complexity of t’. The basis case has t’ a constant in 2’ -4, and is immediate from condition (ii).

Algebraic specijications of (semi) computable data types

153

Let t’= a(&. . . , tl) for some u E C’ and assume that there exist tl, . . . , tk E T suchthattiEE’f:for1didkThen,t’~Ef~(fl,...,fk).IfCTE~,thena(t,,...,tk)E
T(&) and obviously, t = ESt’ for some tE T. If oEZ’-Z, then a(?,, . . . , tJ =E’t for some t E T by condition (iii). Thus, t = E’ t’. q

2.9. Lemma. Let (2, E) and (Z, E’) be speci$cations with C c 27, E c E’. Suppose that C and 2’ contain the same sorts and that T(Z”, E’)l, = T(2, E). Let A and A’ be C- and Z-algebras such that A’l= = A. If A= T(IC,E) and A’ is an Et-algebra, then A’= T(Z’, E’).

Proof. The hypotheses imply that there is a Z-isomorphism
4 : T(Y, E’& + A’I,.
By the initiality of T(Z’, E’)l, for E-algebras-inherited from T(X, E)-the map 4 is unique as a homomorphism. Since A’ is an E’-algebra, there exists a z”homomorphism # : T(Z’, E ‘)+ A’ which restricts to a C-homomorphism #: T(Z’, E’)l= + A’I,. Thus, rC=, 4 and rl, must be bijective and hence a C’isomorphism. Cl

3. Computable and semicomputable alge
In this section we shall define the computable and semicomputable data types and explain their rale in the theory. A number of basic properties of these notions are described and we are then able to review Figs. 1 and 2 of Sections 1 and 2 in order to set the scene for the rest of the paper.

Adequacy and completeness 0ur semantic measures of adequacy for the specification methods are the classes
of computable and semicomputable data types.

3.1. nitions. A many-sorted algebra A is said to be eflectively presented when

it is given an ecffectivecoordinatization (a, 0) consisting of recursive sets 01, . l - , an, tif2i c o for 1s i < n, corresponding with the domains A,, . . . , A, of A; surjections

~I,*-*,%,

ai : Oi + Ai for 1d i c n; and, fOFeach operation U,

a:Ah,x=. lXAhk+AW

a recursive function 6

154 J.A. Bergstra, J. Vi Tucker
that tracks o in the sense that the ff llowing diagram commutes:

wherein (cy+ x l l l x aA,)(xI, . . . . , xk) = (a&q), . . . , aA, (Q). We sometimes write Q : L? + A or, simply, Q!for an effective coordinatization (cy,0).
The algebra A is said to be computable, semicomputable, or cosemicomputable if there exists an effective presentation ar : 0 + A for which the relations = i defined on Oi by
x E=,J if and only if ai( a,(y) in Ai,
for 1s i S n, are recursive, r.e., or co-r.e. respectively.

These three notions are the standard formal definitions of constructive algebraic structures currently in use in mathematical logic, and they derive from the work of Rabin 1461 and, in particular, Mal’cev [39]; they possess the following essential property.
3.2. Lemma. Computability, semicomputability and cosemicomputability are isomorphism invariants.

Thus, the three notions qualify as abstract semantical properties for data types, according to the Abstraction Principle 1.1.
efinition. A data type D is computable, semicomputable, or cosemicomputable if there exists an algebra A representing D that is computable, semicomputable, or cosemicomputable.
By Lemma 3.2, if one algebra r&presents D and is effectively computable, then all representing algebras of D are effectively computable.
Shortly, in Lemmas 3.12 and 3.14, we shall see that, under initial algebra semantics, all the algebraic specijication methods define semicomputable data types. Thus, given the independent interest of the notion, it is natural to seek to determine which specification methods are capable of defining all semicomputable data types. More general Iy, let be a data type specification method and let K be a class of data types; we then have the following definition.

s. The method is sound for

is adequate fo

s complete for

is sound and ade

can be defined

Algebraic specijications of ( semi )computable data types

155

Notice that two methods that are complete for the same class are equivalen+. In this paper we shall often be concerned with methods that are complete for the semicomputable data types and adequate (but not sound) for the computable data types. For information on methods that are complete for computable a cosemicomputable data types, see the Section 7.

Basic technical ideas Combining the components of an effective c~~~dinatisatlon (CY0,)
make a recursive algebra fl of numbers from a,, . . . , 0, and the recursive trac operations of signature 2. With respect to this algebra, the maps cyl, e. . , a,, constitute a 25epimorphism ar : f2 + 4. Thug, A is the homomorphic image of a recursive algebra 0 of numbers and A = O/c,.

3.5. Lemma (Representation Lemma). /‘, computable algebra A is isomorphic to a recursive algebra W of numbers, each of whose domains Ri is the set w of natural numbers or the set o, of the first m natural numbers according to the corresponding domain Ai of A being infinite orjinite of cardinality m.

Proof. Let A be computable under o : fl-, A. For each 16 i 6 n, define the recursive set l-‘ic J2i by

SOthat ai : ri + Ai is bijective. Let A : o + ri be a recursive bijection if ri is infinite;
and let A : a~,,,+ ri be a bijection if Ti is finite. Define Ri = dam(J) and pi : Ri + Ai by
PI. = aifi: Ri + ri + Ai.
Now, for each recursive tracking function

of operation u of A, we define a recursive function

It is easy to see that ak tracks u with respect to /3. It follows that combining the domains Ri and operations (;TRforms the required algebra that is isomorphic to
A under p. 0

Obviously, such an isomorphic algebra of numbers can be provided for a semicom-

putable or cosemicomputable algebra A if and only if A is computable.

e shall now discuss the invariance of co

ility in te soft

ess

of the coordinatizations.

156 J.A. Bergsrra, J. V. Tucker

nitions. Let a! and p be effective presentations of an algebra A. Then cy

recursively reduces to p (in symbols: a s /!I) if there exist recursive functions

fI,-l-9Ycn9 whereJ:O~+@,

that, for 1 G i 6 n, commute the following diagrams:

4

Further, QIis recursively equivalent to /3 if both Q!s p and p s cy.
Now recursive equivalence is the basic identity relation between coordinatizations and establishes the uniqueness of computability concepts in the algebraic setting.
Let R c A,, x l l - x AAkbe a relation on A and let A be effectively presented by cy.Then R is said to be o-computable if its pre-image:
o-‘(R) ={(XI,. . .v xd: b&A.. . , ~&k))E RI
is recursive. The definitions of a-semicomputable and a-cosemicomputable relations follow mutato nomine. The following fact is easy to check.
3.7. Lemma. Let R be an o-computable (a-semicomputable or a-cosemicomputable)
relation on A. Ifp is another effective presentation for A and p recursively reduces to
a, then R is P-computable (P-semicomputable or P-cosemicomputable).
To what extent is the computability of an algebra, and its various relations, dependent upon the choice of a coordinatization? We shall show that as far as the theory of data types is concerned, the computability theory is independent of coordinatizations.
Henceforth, we shall consider minimal algebras only: let A be a minimal algebra of signature C. Clearly, the term algebra T(C) is computable under any natural godel numbering of terms. By Lemma 3.5, we can choose a computable coordinatization y* : R + T(Z), with the domains of R each being o. Let v: T(2) + A be the unique term-evaluation homomorphism. We define the standard effectivepresentation of A derived from y*, to be the composition
yA=vy.+_:R+ T(E)+A.
( Reduction Lemma). The standard effective presentation yA of minimal algebra A recursively reduces to every effective presentation a of A.
A proof of this fact can be found in Mal’cev [39]; coupled with Lemma 3.6 it leads to several important results.
(Invariance Theorem). 7%eminimal algebra is computable, semicomosemicomputable v and only if it is so under the standard effective presentation yA.

Al&k~

ofspe~i$c~tions

( semi )cornpu table data types

157

3. (Uniqueness Theorem). Any two semicomputable coordinatizations of ihe minimal algebra A are recursively equivalent.

ma (Representation Lemma). Let A be a minimal algebra. If A is semicomputable or cosemicomputable, then it can be represented as the image of a recursive algebra R of numbers, all of whose domains are w, and such that epimorphism o : R + A has congruence = a, dejned by
X -=ay ifand only if a(x: -2a(y) in A
and which is r.e. or co-r.e. respectively.

Classijcation of methods: no hidden machinery Let us begin to apply these concepts to the classification
and comment on Fig. 1. Let A be minimal and define

of specification

methods,

&-{t=t’ESEQ:Al=t=t’}={t=t’~SEQ:v(t)=v(t’)inA}
= {Y*(X)= Y*(Y): (X, y9E==y&
where ?A = vy* : R + A is the standard effective presentation for A constructed above. Clearly, by the definitions, T(& SA) = A.
Suppose that A has an (RI?, CEQ) specification (2, E) so that A = T(X, E). By the Provability Criterion 1S,
Et-t== e AI=t=t’ p, t=tkS,.+
Since E is an r.e. set of axioms, & is r.e. Thus we may deduce that A has an (RE, SEQ) and hence an (RE, EQ) specif&tion. Furthermore, since S, is r.e., we know that =,,A is r.e. and, in particular, that A is semicomputable.
Conversely, suppose A is semicomputable. Then, by the Invariance Theorem 3.9, A is semicomputable under yAand SAis r.e. Thus we know that A has an (RE, SEQ) specification and so an (RE, EQ) and an (RE, CEQ) specification.

3.12. Lemma (Completeness Lemma). Let A be a minimal many-sorted algebra. Then the following statements are equivalent :
(i) A is semicomputable;
(ii) SA is r-e.; (iii) A has an (RE, SEQ) specification; (iv) A has an (RE, EQ) specification; (v) A has an (RE, CEQ) specification.

Suppose that A is computable; then, by a similar argument, we can conclude that

SA is recursive. Conversely, if S, is recursive, then A

utable under ?A.

Let A be a minimal many-sorte are equivalent:
(i) A is computable;

158 J. A. Bergstra, J. V. Tucker
(ii) SA is recursive.
IfA is computable, then A has a (REC, SEQ) specification.
Later we shall show th;lt the converse of this adequacy fact is false (Corollary 6.3), i.e., that (REC, SEQ) specifications are not sound for computable types. In addition, we shall show that the (REC, SEQ) and (REC, EQ) specifications, shown to be equivalent in Theorem 1.11, are not adequate for the semicomputable types (Theorem 6.5). However, we shall show that the (REC, CEQ) specifications are complete for the semicomputable types (Theorem 6.1). This concludes the case of infinite specifications (without hidden operators or sorts). To complete our commentary on Fig. 1, we note that the (FIN, SEQ), (FIN, EQ), and (FIN,CEQ) specifications are lather weak and are not adequate even for the computable data types; a full discussion of these finite methods can be found in the next section.
Classification of methods : hidden machinery Given the Completeness Lemma 3.12, it is a routine matter to extend it to the
following lemma.
mma (Completness Lemma). Let A be a minimal many-sorted algebra. Then the following statements are equivalent:
(i) A is semicomputable; (ii) A has an (RE, p, y) specijication for any p E {SEQ, EQ, CEQi and y E {HE, HES}.
Later, we shall show that the (REC, SEQ, HE) specifications and hence, all the (REC, cy,p) specifications are complete for the semicomputable types (Theorem 6.2). Thus, on allowing hidden sorts or operators and infinitely many axioms, completeness for a method duly follows, and all methods are equivalent.
We are left with two basic questions: Are any finite algebraic specifications either complete for the semicomputable data types, or adequate for the computable data types?
In Theorem 5.3, we shall prove (FIN, EQ, HES), and hence (FIN, CEQ, HES), specifications to be complete for the semicomputable data types. In Theorem 5.1 we shall prove (FIN, EQ, HE), and hence (FIN, CEQ, HE), specifications to be adequate (but not sound) for the computable data types. As illustrated in Fig. 2, ye have no information on the (FIN, SEQ, HE) and (FIN, SEQ, HES) specifications and, more importantly, must record that the following problem from [4] is still open.
Are the (FIN, EQ, E) specifications cori,plete for the semi-
Some work on thi ; problem can be found in [lo]. For a review of our adequacy results, we refer to Table 1.

Algebraic speciJications of ( semi) computable data types

159

Table 1. The adequacy of finite algebraic axiomatisations

method class

(FIN, EQ) WWEQ) WIN,EQ, HEr (FIN,CEQ, HE) (FIN, EQ, HES)

finite data types

J

J

J

J

J

computable data types X

X

J

J

J

semicomputable data X

X

?

?

J

wes

Word problems The mathematical tools of computability we employ are used in studying algorith-
mic questions in algebra, mainly in combinatorial aspects of group theory [36] and universal algebra [4Q]; and also in ring and field theory [46,50]. The equivalence of (i) and (ii) in Lemmas 3.12 and 3.14 establishes their connection with the decidability of word problems.
With reference to the literature [ 16,19,40] we note the following lemma.
3.16. Lemma. Let V be a variety of algebraic structures of signature C deJined by a jinite set L of laws. l%en A E V is finitely presented with respect to V by (X, R) if and oniy if the pair (2 v X, L v R) is a ();I[N, EQj specijkation Jbr A Oil adjoining tk generators of A as constants.
Thus, the existence of finitely presented semigroups and groups with unsolvable word problems [33,48] implies that (FIN, EQ) specifications define noncomputable algebras and are not sound for computable semigroups and groups. Not all finitely generated semigroups and groups are finitely presented, and indeed there exist semicomputable semigroups and groups that are not finitely presented: thus, (FIN, EQ) specifications are not complete.
On the other hand, every finitely generated abelian group is finitely presented with respect to the variety of abelian groups, and indeed is computable. By the Hilbert Basis Theorem, the same is true of the finitely generated commutative rings.

. en s

The main tasks of this section are to construct two simple algebras and prove in

detail that they fail to possess (FIN, EQ) and ( FIN, C EQ) specifications respectively.

algebras are computable, so from these theorems we can deduce a nu

nonequivalence results with methods t

ate for co

idden operations can be used to give simple specifications, as

2.1. In [37], there appeared the first example of a type which cannot be specified

by a (FIN, EQ) specification. The type is an interesting stack, but its complexity

160 J.A. Bergstra, J. V. Tucker

precluded a full proof of its nondefinability. Attempts and suggestions aimed at giving a specification of Majster’s stack [37], using extra machinery, are found in [24,28,31,49,51]; see also [38] which includes another example that we shall take up shortly.
In [52], there is a criticism of this situation. In yarticular, a simpler toy-stack, based on Majster’s stack, is constructed and carefully proved not to have a (FIN, EQ) specification and yet to have a (FIN, EQ, HE) specification. Thus it is known that there are data types that one desires to specify that require the use of hidden machinery.
Independently of [52], the present authors presented in [4] the algebra A5 in Example 2.1 as an example of a data type that one wishes to define, but which needs hidden machinery. Here is the proof.
4.1. Theorem. 7%e o!gebrc: ,4 = (a; 0, ,Y-!-I, x2) does ml possess a (FIN, EQ) specification.

Proof. Suppose, for a contradiction, that (2, E) is a (FIN, EQ) specification of A. We assume that E contains no trivial equations of the form t=t.Let E=E,uE,v E3, where
E, contains the simple equations of E; E2 contains the equations of E of the forms

rlw = f2,

f2 = tlw,

tl(W

= h( n,

where t2 is simple and X, Y are free in t,, t3; E, contains the equations of E of the form t,(X) = t2(X), where X is free in t, , t2. First we show that E2= (b.For instance, tl(X) = t2 cannot hold in A because t*(X) is interpreted in A by an injective function (because the operations of A are injective) while t2 is interpreted as a fixed number. The case of t2= t,(X) is identical. Finally, t,(X) = t3( Y) cannot hold in A because, on substituting Y = 0, we obtain an equation of the previous form t,(X) = t2 which does not hold in A. Now we show that E3= 0. Actually, we shall show that if A I=tl( X) = t2(X), zhen t,(X) = t2(X) and the equation is trivial; since we suppose E to be free of trivial equations, we may conclude that E3= 0.
If AI= t,(X) = t*(X), then if FE C names f(x) =x’,

Ak tJ(X) = t,F(X).

We shall create a special representation of these terms of form tF(X) in order to prove t, f t2. Let S name s(x) =x+ 1.
Let C’= C - (0). The terms of interest are those in T’&(F(X)). Let B be the following structure of infinite signature r

= b :h,.rl A J,l l
wherein A(x) = x’+ i; note that J;,(x) = x7. This B is tailored to the semantics of T,*(F(X)) (see Lemma 4.2). Let r be the signature of B with J named by 4. We

Algebraic specifications of (semi) computable data types

169

construct a syntactic transformation H : WWW + T,.(X):

WV))

= F,W),

WW) = F,+*(F,, 9F,,(X)) ll

H(F(t)) = F,(H(t))=

if H( t) = F,F,, =l l Fh,(X),

4.2. Lemma. H is injective and t and H(t) have identical interpretations as functions on 0. In particular,
A+ t,F(X)= t,F(X) implies Bl= H(t,F(X))= H(t,F(X)).

Proof. We leave this as an exercise involving induction. Cl

Proof of Theorem 4.1 (continued). Suppose H(t,F(X))= H( t,F(X)) = Fb, . l l F,$X). We prove that

F,, l l l FaP(X)

Bl= F,, l . l F,&X) = Fb, l l l Fb$X) @ p=qandai=bifori=l,...,p.

and

That is, the semigroup G of functions on o generated by the J’s under composition is a free semigroup. This done, we deduce that

Bi= H(t,F(X))= H(t,F(X)) implies H(t,F(X))= H(t,F(X)).

By the injectivity of H we know that t, F(X) = t2F(X). This obviously implies that t, --_ tz.
Suppose B + F,, l 9 l FaP(X) = Fb, . l l Fb, (X). If p # q, then, on their interpretation
as polynomials on w, the terms on each side have different degrees, namelv 2P and
29 respectively. Consequently, the terms cannot represent identical functions and the equation fails on B. Thus, p = q.
We now need some special notation.

ui = E&l,+, l l - E$, 6’ = J + g,

ri = Fb,Fb,+, l l l F/,, pi = J - g_

Now we consider 6’ and pi as polynomials over the ring Z of integers. Note that

deg(ui)=deg(6i)=deg(ri)=2P-i+’

for isp.

In this notation, our equation is B t= c’ = 71 or equivalently 21I=p’ = 0. Suppose that U’ + 71. Let j be the largest index such that aj # bj* SO i > j implies
ai = bi and gi E #. By induction on k, we show that, for 0 s k s j - 1, it is the case

that Z I# pjmk =O. Thus, Wp’ = 0 which contradicts our assumption

In the basis k = 0, there are two cases j = p and j <p. If j = p, then p’ = d - 7’ =

(X2+ap)-(X2+bp)=ap

- bp and, by the assumption on j = p, Z&t pp = 0. If j < p,

then

P’ = ai - Tj = F,,++’ - F$j+l = ( uj+‘)2-(,-j+‘)2+~j-bj=aj-bj

= ((g-j+‘)*+

aj) -((rJ+‘)*+

bj)

because #’ = rj+’ by choice of j. Thus, Z t# p’ = 0.

162 J. A. Bergstra, J. VI Tucker

In the induction step, let B I# p’ =Owhere I=j-!c.

P ‘-1 =(7 I-1 _ g-1 = Fa,_p’

- F&T’

We considerj-(k+l)=j-I.

= ((a’)2+ a,_,) - ((r’)2+ b,_,) = Sip’+ a,_, - b,_, .

Now, Z l# pj = 0 implies

deg( 6$‘) 3 deg( 6’) > 2p-‘+’ 3 2.

I-Ience, deg(p’-‘) 3 2 and Z I# p’-’ = 0. This concludes the proof that E3 = 0. Suppose T(Z, E,) = A. Let

& = {F(S”(0)) = Sf12(0): n E o, n < k}.

Notice that if i <j, then ii c Ej and that A is an &-algebra for all k. We claim that,
for sufficiently large kO, &F E,. This can be easily proved: First define A : T( 2) + o
such that Ai= t = S”“‘(O). By induction, we define

h(0) =o, h(S(t’)) = A(?‘)+ 1, A(F( t’)) = A( tr)2.

It is easy to check that this A is uniquely determined.

&(,)t- t = SA”‘(0).

roof. This is clone by induction on t. The basis case t =.O is trivial. The induction step has two cases.
Case 1: Let t = S( t’). Then, by the induction hypothesis,

&( ,‘)I- t’ = S”““(O),

&J-t’=

P”)(O),

&,Jk S( t) = S(S”““(O)),

&(‘)t- t = P”)+‘(O),

&,g- t = S”“‘(0).

Case 2: Let t = F( t’). Then, by the induction hypothesis,

&(,‘)t t’ = S*(“)(O),

&(,)I- t’= S”““(O),

I$(,+- F( t’) = F(S*““(O)),

&J-t = SAqO),

&(,jk t = S”“‘(0).

0

roof 0 eote any e ‘?=t’EE,,

.1 (continued). Choose k, > max{A (t) : t occurs in E,}. Then, for

&,t- t = S*(‘)(O) and E,i- t’ = Z?““(O).

Since Ab t = t’, we know that A(t) = A( t’) and hence that E& t = t’. Since Ek,+ El,

s an E,-algebra. Since A = 7”(2; E,) is an &,-algebra, we

(Z, E,) = T(X, .&J.

atement that A is initial in ALG(Z, Eh,) giving an &,-

may not be homomor ically mapped. he structure is

h,=(o:O,x+I,g),

where g:w+w is defined

X2 if x< ko, g(x) =
k; otherwise.

Algebraic specijicarions of (semi)computable data types

163

Any homomorphism 4 :A + A, must satisfy 4(n) = n; note that the homomorphism property fails as follows:
H(k,+ I) = !Mk,+ I), H(k,+ I)*) = g(k,+ I), (kO+l)*= k,t.
Thus we have shown that T(Z, E,) %A and we conclude that A does not possess a (FIN, EQ) specification. •J

On adequacy grounds, to be discussed in the next section, we have the following corollary.

4.4. Corollary. (FIN, EQ) and hence (FIN, SEQ) specifications are not equivalent to the injinite specijication methods.
The above proof that (0, 0, x i- 1, x2) has no (FIN, SEQ) specification is easily adapted to work for (0, 0, x + 1,2 l x), an algebra with (FIN, EQ) specification. Consequently, we have the following lem.ma.

4.5. Lemma. (FIN, EQ) specifications are not equivalent to (FIN, SEQ) specijications.

Next, let us turn to (FIN, CEQ) specifications. We shall now give a simple computable algebra tlhat cannot be defined by these specifications. The problem is alluded to in [52], but not solved. The algebra was mentioned in [38] as an example of a structure without a (FIN, EQ) specification, but a proof was not provided.
Consider the following two-sorted structure C’ based on the characteristic function

f : w + {true, false}

of a set Sj-c w where

x+ @ f(x)=true. The structure cf has domains w and {tr

Ise} linked by f:

cf=(0;{trufaelse,} :0, x + 1, tr

se,f ).

The structure &;- is uniquely determined up to isomorphism by f as expressed in the following lemma.

The following conditions are equivalent:
(ii) T,.= $; (iii) c,, = Cg; (iv) cr = CR; (v) there is a homomorphism 4 : cl-+ CR.

164 J. A. Bergsrra, J. V. Tucker

roof. The cycle of implications from (i) to (v) is obvious. Suppose 4 : Cr + Cg is a homomorphism. Then 4(n) = n for all n E o because 4 presert es 0 and successor. Thus, for all n,
f(n) = &f(n)) = g(W)) = g(n)
and (v) implies (i). 0

Consider the following sparsity property on f:
for any k E o there exists an x E o such k), . . . ,f(x-1), f(x+l) ,..., f(x+k)=false.

that f(x)

= true

and f (x --

Equivalently, for the set S,

for any k E o there exists an x E Sf such that the interval [x - k, x + k] n Sf = (x).

For example, the set {n”: n E o} of squares satisfies this sparsity property. Less obviously, we also have the following set.

4.7. Lemma. The set P of prime numbers satis$es the sparsity property.

roof. A significant theorem about the increasing enumeration po, p, , p2, . . . of the primes is that, for any n, there exist (infinitely many) i’s such that
Jpi-pi-J> n and )pi+l-pi+zl> n,
see Theorem 6.1 in [45]. Cl

We note that if f has the sparsity property, then: for any kE o there exists x E o such that f(x), f(x+ I), . . . , f(x+ k) = false.
Or, equivalently,
for any k E o there exists x E o such that the interval [x, x + k] n S’ = 0.

Letf:w+{tr

se} satisfy the sparsity property. Then the structure

Cr fails to possess a (FIN, C EQ) specifIcation.

. Suppose, for a contradiction, that there exists a finite conditional equation specification (E, E) for Cr so that T( 2, E) = CP Let K be the class of all characteristic function structures

e claim that CJ is the only structure in that satisfies all the equations in E. For pose that CRI= E; then since C, is initial in ALG(Z; E), there must exist a
homomorphism $ : C, + CR. By Lemma 4.6, C’ = CR.

Algebraic specijications of ( semi )computable data types

165

Now, define 4 = AeEE e. We know that Cr is the only structure in K that satisfies 4. This property we shall seek to contradict.
The open formula 4 can be built up using 1 and v from equations over the two sorts of numbers and booleans. An equation t, = t2 over booleans is equivalent to

(t,=FALSEh tz=FALSE) V(t,= TRUEA t,=TRUE)

and hence, we may assume that the atomic formulae of 4 are either equations over w or equations over booleans having one of the forms t = FALSE or t = TRUE, and that there are no variables of type boolean. The atomic formulae are therefore of the form:

S”(0) = S”(O),

Fs"(O)=TRUE,

S”(0) = S”(X),

!?$"(O)=FALSE,

S"(X)=S"'(X),

FS"(X)=TRUE,

s"(x)=s"(Y),

FS"(X)=FALSE.

Let 4 contain the numerical variables XI, . . . , X,, and have length 1. We shall now construct a g : o + {true, false} such that CRt= 4 and 4i_f Cg. Since f satisfies the sparsity assumption, we can choose z E w such that f(z) = true; but for all x E [z - 4111z, +41&J, if x f z, then f(x) = false.
Now we define

1*f(x) if x # z,

g(x) = false

if x = z.

Thus f, g differ only at z. The implications which this has f~J,r valuations

P:W,,--9

XI1}+ to of 4 are expressed in the following lemma.

4.9. Lemma. Iffor each i= 1,. . . , n (p(X,)-zl> cj+pb4 if and only if Cg,pt=4.

I, then

roof. We prove this by induction on 4. The eight cases of atomic formulae follow a similar pattern: we consider 4 = FS”( Xi) = TRUE and show that
C,.,p I=4 implies CR,p ‘--4: ,

cl, p I# 4 implies Cx, p 5” 4.

NOW, c,-, p l= 4 entails thatf(s”(p(Xi))) --rRuE,wheres(x)=x+l.AsIp(Xi)-zl>/ and a < lYs”(p(Xi)) # z. Hence,

gs”(p(Xi)) =fs”(p(Xi))
= TRUE

(by definition of g) by C,,Pk4)

and CK,pk= 4. The second argument is similar. itie induction steps for v and 1 are easy. Cl

166 _!.A. Bergstra, .I.V. Tucker

Fig. 3.

(continued). Since .f# g, we have that C,. # CR and C,# 4 (remember the assumptions on 4). Thus, there exists a valuation v : {Xi, . . . , X,} + o such that CR, ol= 14. In view of the difference between f and g, we may expect the elements of V = { o( X,), . . . , 0(X,,)} to be ‘near’ z. We shall construct another valuation T that mainly coincides with CTbut which changes values in a ‘small’ interval around z to larger values in a ‘small’ interval higher up such that

CR, al= i& implies CR, rl= -14

and Lemma 4.9 can be applied to 7 to yield

CR, rt=i& implies Cr, +-$A

This done, we blote that C$+ 4, which is a contradiction. To construct 7 we first find two numbers L, R such that (cf. Fig. 3) (i) LE[z-4ln,z], R~[z,z+41n]; (ii) z-4ln< L-l, L+l-Kz; (iii) z< R-1+1, R+l<z+41n; (iv) [L-l, L+l-l]n V=fl, [R-1+1, R+l]n V=fl.
Suppose no such L at the centre of an interval of length 1 existed; then condition (iv) implies that there must be 41n/21= 2n elements of V within [z -4ln, z].
By sparsity, there is a number K,> max( V) + 41n + z such that the interval [KU41n, K,+ 41n] does not contain elements x with f(x) = true nor elements of Y Set d=K,,-z (cf. Fig. 4). Then define valuation

7( Xi) = u(Xi)+d
c(xiJ

ifo(Xi)E[L, R], if a(X&[L, R].

a. For any open formula cc/of length G 1 and with variable among X,, l . l 9 X,, we have
A,, &= + if and onl_vif A,, 7-k +.

This is shown by induction on the structure of q?.The basis case diviks ;iiato subcases determint-d by the atomic formulae.

Fig. 4.

Algebraic specijcations of (semi)computable data types

167

Consider 9(X;) = Sh(Xi). If a(Xi) and u(X~) are outside [L, R], then u and T agree on Xi and Xj and we are done:
A,, ak S”(Xi)= S’(X,) and A,, Tb S”(Xi) = Sh(Xj).
In the case a(Xi) E [L, R] and a( Xj) e [L, R] it is the case that
Ag, aI+ S”(Xi) = S”(Xj) and A,, TCfSa(Xi)=Sh(Xj)*
TO see this, note that g(Xj) $ [L- I, R + 11 and SO Ia - a( > 1. But A.f, aI= S”(Xi) = Sb(Xj) implies
Ia(U(Xj)lsa-_<a++.
Since a + 6 < I, this equation cannot hold. Concerning A,, ~t# S”(Xi) = Sh(Xj) we note that lT(Xi) - r(Xj)l> I because
T(Xi) = a( Xi) and

By the same reasoning we can deduce that the equation does not hold. The other cases of atomic formulae follow similarly and the induction steps are
obvious. Cl
Proof of Theorem 4.8 (conclusion). We have shown that for the constructed 7

Since IT(Xi) - zI > I for each i, we can apply the Lemma 4.9 to conclude
CR, ~i=i+ implies c,., ~I=14 which is the desired G- aU*I+DraEd_i.ction, as explained earlier. Cl
Again, on adequacy grounds, we can deduce the following improvement to Corollary 4.4.
4.11. Corollary. (FIN, CEQ) specifications are not equivalent to the in$nite r.e. specification methods.
The nonequivalence ~Gt8athe infinite recursive specification methods follows in Section 6.
The fact that (FIN, CEQj and (FIN, EQ) specifications are not equivalent was established in [52] using a rather simple, if artificial, type. In [2], a natural exa of a data type of .iets-ofii+t;rge~*s is shown to have a (FIN, CEQ) specification but not to have a (FIN, EQ) ~~pecification.

168 J. A. Bergsrra, J. V. Tucker

. equacy and completeness theore

ecificationwsit id

S

In this section we shall prove that the (FIN, EQ, HE) specifications are adequate for the computable data types and that the (FIN, EQ, HES) specifications are complete for the semicomputable data types. We shall use some fairly elementary results from the theory of recursive functions, and present proofs in some detail in order to establish properly the translation of ideas of computability to ideas of algebra.
As with the cituation concerning hidden functions outlined in the previous section, there have been some observations concerning effective caloulability and the power of methods already. In [21,22], the definition of partial recursive functions by Herbrand-Giidel- Kleene equations is claimed to establish adequacy for their methods. However, a considerable amount of work, particularly on the technical foundations of their specification methods, is necessary to establish this fact. A puzzle arises in their claim, however: the semantics of Herbrand-Giidel-Kleene equations is that of an operational rewrite rule system and hence, ought naturally to lead to an initial algebra semantics for equations; but Guttag and Horning deny such a semantics is intended for their methods.
In 2381, a similar sentiment concerning Herbrand-GSdei -Kleene computability and finite equations and hidden functions is expressed. Again, considerable work is requited to develop the initial algebra semantics of specifications for partia! types, which Majster’s interpretation [38] clearly involves, and to develop the necessary computability theory for data types as we have here, in the case of types with total operations. In [l], we considered computable data types with partial functions.
For simplicity, the theorems will be proved in the case of single-sorted data types only. The mtiny-sorted generalizations are indeed true, but we prefer to follow the as-C: al pracliice of our series of leaving the generalization to the reader. However, in @] it wa s expedient to give an account of an interesting relationship between the sing!+sorted and many-sorted cases of computable data types which can be of help here.

4 be a single-sorted minimal algebra of signature 2. !fA is
computable, then A has a (FIN, EQ, HE) specijkation.

e case that A is finite is accounted for by Proposition 1.12. Suppose A is y the Representation Lemma 3.5, A is isomorphic to a recursive algebra R of numbers, say
=(w CI,..4,,,fi4 . . . ..f,,,
e J’s are recursive functions on w. is minimal, of course. as a (FIN, EQ, HE) specification by constructing an algebra specification and such that R’12 = (R’), = R.

Algebraic specifications of (semi)computable data types

169

First we shall prove the following technical fact

5.2. Lemma. Let f, , . . . , fm be primitive recursive functions and let A,, . . . , A, be the functions appearing in their explicit dejnitims. Then the algebra

x+B = (w 0, 1,A, bf,,9 l l l ,
has a (FIN, EQ) speci$cation.

l l - rfm)

. Without loss of generality, we can assume that the ope,*ations of B are ordered in a list 0,x+1, 8,,. .., &+,,, so that any function is to the right of all those functions appearing in its explicit definition.
Define a sequence of algebras

&= (0; 0, x+ I), R+, = (B,, %+,)
for n=O,..., I+ m. We shall prove that each B, has a (FIN, EQ) specification and so, in particular, A = B,,, has such a specification.
The base of the sequence is obvious: let -C,= (0, S} and E0 = fl, so B0 = T(&). Assume that B, has a (FIN, EQ) specification (Z,, E,) so that B, = T(&, E,,), and consider B,,+, . By the construction of the list, the new function en+, is either
a projection function, or is defined by composition or primitive recursion from earlier 6i, 6’jwith i,j < n + 1. These three cases are treated in a like manner so we
shall write out the case of primitive recursion only. Suppose

fl,+,(O, xl,. . . , xd = 6(x,, . . . , xd,

%+AY+ 1,XI,

xd =- - . ,

ej(V, XI,

. . . , xk,

e,+,(y, XI,.

. . , %H-

Then, set Z,+, = Z, u 0%+,1 and E,+, to be E, with &ese equations adjoined:

x,,e,+,(O, l l l 9 xc) = WG, l l l , x,),

e,+,(S( Y), x,, l l l ,x,) = (Y,X,,*..,x,,~*+,(3:X,,...,X~)2.

Clearly, G,+, , E,,, ,) is a (FIN, EQ) specification, so
T(&+, , En+,) s B,,+, l We use Lemma 2.9. We know that B,, s T( E,, E, ), so we musk verify that

e must show that ,,+,I\.,,= B, and that

T(&+, 9 cl+,)Il,, = wi, En)
to apply Lemma 2.9. For this we can use Lemma 2.8. Consider T = {S’(O) : r E w}. Now, T is a transversal for T( ,,, 5,) because

K&l, En&,: = &IL,, =

Condition (i) of Lemma 2.8 is

E,,+, because B,,+, is an &+,-algebra.

Since condition (ii) is automatic, we are left with condition (iii). This condition is

checked by considering

(fl+I

)9 - * * 9

and showing that it is E,,+,- equivalent to an element of T, going by the equations for ,,+, to elements of T( Z,) in which T is an E, c E,,,-transversal. 0

170 J.A. Bergstra, J. Vi Tucker

heorem 5.1 (continued). We shall now construct R’ from R. Let f: wk + o be a recursive function. Then the graph off

graph(f)={(x,,...,xk,f(x,,=..,xk)):x,,...,xkEw}
is recursively enumerable. Since every r.e. set has a primitive recursive enumeration, let h l,*=-, hk, g :o + o be primitive recursive functions enumerating graph(f). Thus,
graph(f) = {(h,(z), l l l 9 h&(Z), g(d) : z (5 d
and, in particular, for all ZE of(h,(z), . . . , h&(z)) = g(z). Now, for each &-ary recursive operation jj of R, choose primitive recursive
functions h{, . . . . , hi, and g’ that enumerate graph(J) as above. Let {A,} and {pj} be the lists of functions making up the explicit definitions of the hj and g’ respectively. Define

R’=(o;O,x+I,(h,},{~j},

hj, l --, Gc,, gj,h,

~1, l *-v cra)l<j~m,~<i</c,*

Clearly, R’IZ = (R’): = R. We have to show that R’ has a (FIN, EQ) specification. First set

Rk=

(w; 0, X+ 1, (ho}, {p,},

h(, l l l 3 hi,, g’)lsj<m,l-=i-=k \I

and let its signature be Zj. Then, RI,, = (R),;, = RL and, by Lemma 5.2, Rb has a (FIN, EQ) specification (Z&, Eb).
We now define a specification for R’. Let C’ be the signature of R’ so that C’ = Zbu C. Let E’ be E& with the following equations added:
- for each constant cj E Z,q = S’(O); - for each operation & E Z,&(#(X), . . . , hi(X)) = g’(X). The pair (Z’, E’) is a (FIN, EQ) specification, so we must verify that T(Z’, E’) Z+RZ’. This is done by Lemma 2.9.
Clearly, R’ is an P-algebra, so all that remains is the hypothesis T(Y, E’&,z T(& Eb). For this, we look to Lemma 2.8. Consider T = {S’(O) : r~ o}. That T is a transversal for T(Z& EL) follows from the fact that

T(Z, G)l{.0 .S)= Rbl{09S)s T(&).
Conditions (i) and (ii) of Lemma 2.8 are true of T by inspection of E, which leaves condition (iii). So consider the term f( 53(O), . . . , P(O)). The isomorphism between T(Z& Eb) and RI, implies that there is an S’(0) such that S’(O) =E;, for 1 G is k. Thus,

s’l(o), . . . , srk(o)) =E'f(

&SZ(0)) = E’ gs’(o).

Since gS’( 0) E T( 2;) and T is an Eb-transversal,

gS’(O) =& Si(0)

for some i, whence the condition follows as = Ei,c = E’. 0

Next we turn to the only completeness theorem we know for the semicomputable he use of hidden sorts we saw first

Algebraic specijka tions of ( semi )computable data types

171

.3. eorem. Let A be a single-sorted minimal algebra of signature 2. If A is semicomputable, then A has a (FIN, EQ, ES) speciJication.

roof. We consider the case when A is infinite. Since A is semicomputable, we can choose a recursive algebra
,fm)R = (a; Cl, l *l 5 Cmfi,l l l
of numbers and a canonical codification YA: R + A with = ,,Ar.e. (by the Representation Lemma 3.11). Recall from Section 3 that ?A is factored thus:

T(Z)U-A

Y* T1 / R

yA

andthat SA={y*(i)= y.Jj):(i,j)E=yA } is the set of all simple equations true in A. Since syA is r.e., we can choose primitive recursive functions g, h to enumerate
it so that =yA = {(g(z), h(z)) : z E to} and hence,

SA = b’&(Z)) = r,(W) :z E:0).

Adjoin the functions to R to make (R, g, h), denoted RO, with signature &. Consider next the new two-sorted structure of signature l?

Clearly, BIH = A with nat the sort name for o and nat g 2. We shall prove the theorem by showing that B has a (FIN, EQ, HE) specification.
Since RO is computable, it has a (FIN, EQ, HE) specification by Theorem 5.1. More precisely, from the argument of Theorem 5.1, there is a new recursive number algebra RA and a (FIN, EQ) specification (2& EA) such that
T(Z;, E;) = R& R&,, = (R&, = Ro, R&s1 = (w; 0, x + 1).
Define B’ to be B with all the new operations added to RO to make Rh; let B’ have signature r’. Clearly, B’II-= B.
NOW, C c F’, 2&c 25;~ r’ and (0, S} c r’. We show that B’ has a (FIN, EQ) specification (r’, F). Define F to be Eb together with the following equations over l-‘:

Clearly, (r’, F) is a (FIN, EQ) specification.

e that TV’, F) =

two steps. irst we clai that

)

T( r’, F v SA). Secondly, we clai

‘= T(r’, Fu sA)*

172 J.A. Bergsrra, J. V. Tucker

Consider the second claim first. B’ is an (F u S&algebra so, by initiality and the fact that B’ is minimal, there is a unique epimorphism 4 : T( r’, F u SA) + B’. To check that 4 is injective, we split 4 into &,, &:
4, = 4 r T(P, Fu $,)I, and qb2= t,b1 T(l--‘, F u &)I.,;.
Now, T(f’, F u S,)l, is an &-algebra and 4, : T(T’, F u S,)l, --,B’I\-.
NOW, B’lr = A = T(Z, SJ. Hence, T( r’, F u S,)), is initial for &-algebras and
T( I-, F u S,)l, z B’(,

by 4,. The injectivity of & follows the same lines. Finally, consider the first claim. Observe {S’(O) : r E o}
T(Z& Eh) so that

is a transversal

for

g( S’(0)) f El,P”(O),

Ir(S’(0)) = E;,S”“‘(0)

since T(&, E&,, = Ro. Moreover, one may now use the equations given J’or F to show that y(Y(0)) = F y.J r) by induction on the complexity of terms. From these observations,

Y*&(Z)) = Fr(SYO)) = Fy(gS’(0)) =&hS(O)) =Fy(P-)(O)) =FY*(h(Z)),
whence T(T’, F) is an &-algebra. 0

With these results we have almost completed our work on Fig. 2 in Section 2.

leting the classification

Some four results ar”enecessary to complete the analysis of specification methods without hidden machinery, represented in Fig. 1; and one result is outstanding for Fig. 2. We begin with completeness issues.
GE. Let A be a semicomputable minimal algebra of signature 2. Then A C, CEQ) specification.

roof. By the Completeness Lemma 3.12, A has a (RE, SEQ) specification (2, E).
Let E be enumerated by f so that f(i) = e;. Let c be a constant symbol for 2 and define EC to the set of all conditional equations of the form

C =civ-~

c=c+ei

I times

for i E w. Clearly, T( 2, E,.) = T( 2, E) = A. But E,. is a recursive set of axioms for,

any conditional equation e = eI Al l 9A e, + e',one first decides whether or not the e,‘s are c = c: if not, then e c Et.. If the e, are c = c, then one computes f(n) = e,,

and checks whether or not e,, is et. 0

Algebraic specifications of (semi)computable data types

173

osition. Let A be a semicomputable minimal algebra of signature 2. Then A has a (REC, SEQ, E ) specification.

roof. By the Completeness Lemma 3.12, A has an (RE, SEQ) specification (2, E). Let E = UF E,, where E, is the set of equations of sort s E 2. Letf, and g, be recursive functions that enumerate E, so that

E,={f,(i)=g.Ji):i~o}.

Now, for each sort s, we adjoin to Z a new function symbol I, to make a new signature C’. We define Et ),g consist of the following simple equations:

I.$(t) = t

for each t E T(E),

I, l l l I,(f,(i)) =gc(i)
i tiiiies

for each ie o.

Now E’ = Us E’, is a recursive set of simple equations analogous to that in the previous result. Clearly,

over 2“, oy reasoning

T(Z’, E’)I, = T(2, E) = A. 0

From this result we can obtain a simple counter-example to the converse of Lemma 3.13.

6.3. Corollary. There are (REC, SEQ) speciJications that dejne noncomputable algebras.

Proof. Choose A to be semicomputable, but not computable, and apply the above constructions to it. The algebra T(Y, E’) is not computable. cl

Next we shall prove that the (REC, EQ) specifications are not complete. Let Lz1 be Ae following signature:

sorts :
constants: _functions:

nat, s; 0 : nat; S:nat+nat,

F:nat+s,

G:nat+s.

Let W c w and define Ew = { F(S”(0)) = G(S”(0)): n E W}. Set AuP= T(2, E,). We have axiomatized the equality of functions on a given set of numbers as stated in the following lemma.

a. The congruence = k-:‘Mis .the set (( FS”(O), GS”(0)) : fi E ) u (( GS”(O), FS”(0)) : n E
u{(t, 1): tc T(2)).

174 J.A. Bergstra, J. V. Tucker

Thus, for n E 0, n E W ifand only if FS”(Q) sEw GS”(0).
In consequence, for W, L c 0, &V =A= ifand only if W=Z.

roof. Let = denote the set defined above. It is easy to show that = is a congruence. Since T(Z)/ = satisfies Ew, we note that = is an E+zongruence and that = &, c = since = Eu,is the least E+zongzence. Conversely, it is easy to check that = c = &,. The other properties are immediate. U

Note that the equivalence classes of = &, are all finite and contain either one or two elements.

Let W be an r.e. nonrecursive set. Then the algebra Aw is semicomputable but it fails to possess a (REC, EQ) specification.

Proof. The algebra is clearly semicomputable on account of Lemma 3.12: the congruence = Ew is a r.e. set of simple equations that specifies Aw.
Suppose, for a contradiction, that there was a specification (Z; E) with E a recursive set of nontrivial equations such that T(Z; E) = A,; i.e., = E is = &+,.Let E = E, u E2 where E, is the subset of all simple equations in E. We first show that E2=0.
Let t, = t2 be a nontrivial element of Et. Depending upon the occurrences of free variables in the equation, there are three possibilities: an equation of one of the following forms is valid in A,,+,(with X, Y ranging over 0):
t1= t*(X), t*(X) = tzw, h(X) = f2(Y)

(remember the operations in C are unary). If t,(X) = t2( Y) is valid, then setting Y = I) gives that {t,( S”(0)) : n E w} is a subset
of [ fZ(O)]E,which contradicts the finiteness of the equivalence classes. Thus no such equations are in E.
For nontrivial equations of the form t,(X) = t2( Y) it is obvious by inspection of all cases that these cannot be valid in Aw.
Finally, if t, = tz(X) is valid, then again the set [t& must contain the infinite set {t2( r) : r E T(Z)}, which is not possible.
Thus, T(T;, E,) = Aw and the simple equations in E, must have the forms

FS”(O) = GS”(0) or GS”(0) = FS”(0)

with nE Without loss of generality, we may take

E, = { FS”(O) = GS”(0) : n E Z c W}.

tion of T(Z, E,) =

z (by definition). Since Z is recursive and and, by Lemma 6.4, that AZ 74Aw. This contradicw completes the proof. Cl

Algebraic specijicotions of (semi )computable data types

175

We shall now prove that the (FIN, CEQ) specifications are not comparable with the (REC, EQ) specifications (recall Theorem 4.8).

6.6. Theorem. There is a semicomputable algebra A that possesses a (FIN, CEQ) specification but fails to possess a (REC, EQ) specijication.

roof. The construction of the algebra A is complicated and involves certain constructions made earlier. First, let W be an r.e. nonrecursive set and let Aw be the two-sorted algebra constructed for Theorem 6.5: Aw = T(Z, E,).
Let h : o + w be a recursive function that enumerates W and define the singlesorted structure Bw = (w ; 0, x + 1, h) with signature 2, .I By Theorem 5.1, since Bw is computable, there exists a (FIN, EQ, HE) specification (2,) E2) such that

Let Cw= T(&, E2). Thus C, is a computable algebra with a (FIN, EQ) specification.
We shall join the independent structures Aw and Cw by means of a map 4 : Aw + C, that identifies their independent copies of o. This results in the structure D,,,, which is the algebra required in the theorem. In constructing Dw we shall work with specifications.
First we assume that C n Z2 = 0. Let N and % denote the copies of the natural numbers in Aw and Cw respectively.
Let Di be the join [A,, C,] of the two structures; by the Join Lemma 1.13,
&.= T(Zu&, E,u E,).

To identify N and fi, we take transversals {S”(O): n E w} and {S’$): n E w)

for N and fi, and define map 4: N+ fi by 4([S”(O)]) = [S”(&]. The map 4 is added to Di as a new operation to make D&+ By the Function Lemma 1.16, this algebra is axiomatized by adding a new function symbol @ to 2 u &, and by adding equations
E4 = {@(S”(O)) = 2?(i) : n E w}

to EwuEZ. For &=~u&u{@}

and E3= Ewu E,uE, we have Di,,=

T(&, Ed* We take Dw = T(& , E3). We claim that Dw is a structure satisfying the properties

of the theorem.

Dw possesses a ( FIN, CEQ) specijication.

. The infinite set E3 of specifying equations for Dw is made up of infinitely many axioms Ew for A*, finitely many axioms E2 for Cw, and infinitely many

176 J.A. Bergstra, J. V. Tucker

axioms E& for the linking of IV, I?. Leaving E2 alone, we make new sets

EO, = {G(O) = 6,

@(S(X)) = M(X))13

EO,= {@(X)=H(Y)+F(X)=G(X)}

and define E! = EL v E2 v Ez. We claim that l& = T(&, Ey). We shall prove this by means of the Refinement Lemma 1.15. This requires us to
verify the following three conditions:
(a) E$- E3; (b) Dw = T(&, G); (c) D,!== E;. Of course, (b) holds by definition. We consider (c). Now, Dw I=Ez because of (b) and Dw I=Ei by inspection. Consider Dw I=Eow. Let a be any valuation of the free variables of the equation in 2cow,l say o(X) = [S”(O)], a( Y) = [Sm(6)]. And suppose Dw, d= @(X) = H( Y). Then,

Dwl= @(S”(O)) = @“(6))

by inspection;

Dw I=in@) = H(SI”(6))

by D\d= E+

By the construction of (the component algebra Bw in) Dw, it may be checked that

Dw I= H(P(0)) = ih(m)(6)

and hence, n = h(m) and n E W. We must now verify that D,y, d= F(X) = G(X), i.e., Dwt= F(S”(0)) = G@“(O)).

This is true by virtue of Ew in the specification of D w. This concludes our check of (c).
Consider (a). Since E+ Ey, we have that Eyt- E2. To show that E$-- E, is a matter of showing that E$-- E4 by induction. Thus it remains to show EPt- Ew. Let F(S”(0)) = G(S”(O))E Ew. Then, n E W and there is an m E w such that h(m) = n. We have
B,k i?‘(6)= k@“(6)), c,t= P(6) = H(P@))
and since Cw = T(&, E2), by initiality (Provability Criterion l.S),

E&‘(6) = k@“(b)). Now, Ed t--@(S”(O)) = S’@) and since E$ E,,

E$- @(S”(O)) = H(g”(0)).
Applying the axiom of E”w we obtain Ey t- ES” (0) = GS” (0) on substitution of S” (0) for
This concludes the proof of (a) and, by the efinement Lemma 1.15, the proof that u’= T(&, E:‘). C!

Algebraic specijcations of (semi)computable data types

177

a. DW does not possess a (REC, EQ) specification.

. Consider the relationship between DW and AW. Clearly, D& = AW and each function symbol of Z3 -2 has codomain sort in & -2
6.9. Lemma. Let A and B 6e arbitrary algebras of signatures C and 2’. Suppose that C c 2’ and Blr = A. Suppose that each function symbol of C’- C has codomain sort in C’- 2. Then, for any equational specification (2’, E’), we have
B = T(T:‘, E’) implies A = T(Z, E ),
where E = Et n L(X) and L(Z) is the jirst-order language over C. Thus, if B has a (*, EQ) specijication, then A has a (*, EQ) specijkation.
Now, if we assume that D, has a (REC, EQ) specification then, by Lemma 6.9, AW has a (REC, EQ) specification: this is not the case because of Theorem 6.5. Cl (Lemma 6.8)

Proof of Lemma 6.9. Let B s T(Y, E’). Construct B*, a homomorphic image of B, that is made by collapsing all domains in B named in C’- C to a singleton set: we take B* = Bl= E*, where
E*={X,= Y,:ssort in 2’-Z}.
By the fact that the operators of C’-- C have codomains in C’- 2, we have that B*lx = A, and that B* = T( Z, E’ u E*) follows from the Factor Lemma 1.14.
Now, take E = E’rl L(2); i.e., E is the set of equations involving operators from C only. Notice that E u E * I- E’u E* because E * i- E’ - E. By the Refinement Lemma 1.15, T(Y, E v E*)= B*.
We shall now show that T(Z, E) = A. Clearly, Al= E because Bl= E’ and Blx = A. Thus we must show that A is initial in ALG(2, E). Suppose CE ALG(IC, E); we must construct a homomorphism A + C. First we enrich C to a Z-structure C’ by
adding singleton domains for the new sorts and the uniquely determined operators having codomains among the new sorts. Note that C’l= E u E*. By the initiality of B* for ALG(Y, E u E*) there is a homomorphism 4 : B* + C’. On restricting our interest to C we find that 4 induces a homomorphism A = Blz + C. This concludes
the proof of Lemma 6.9 and that of Theorem 6.6. Cl

Finally, in Fig. 1, we must separate the simple equations for the equations:

There is an algebra A that possesses a ( FI N, EQ) specification but fails to possess a (FIN, SEQ) specijication.

roof. Let C be the following signature:

sorts :

nat;

constants:

0 : nat;

functions:

S:nat+nat, P:nnac+nat.

178 J.A. Bergstra, J. V. Tucker

and let E Ibe the set containing the equations P(0) = 0, PS( X) = X. Clearly, T( 2, E) is the structure
A=({O, l,... };C,x+l,x-1)

and A has a (FIN, EQ) specification. Suppose, for a contradiction, that A has a (FIN, SZQ) specification
Define, for k E o,

(2, EO).

Ek = {P(O) = 0)u {ES"+'(O)= S"(O) :n s k}.

6.1!. Lemma. Let e be a simple equation OLW_X _‘f 1el < k and A I=e, then Ek t- e.

roof. By induction on the structure of e. Cl

Proof of Theorem 6.10 (continued ). Let k, = max{ le] : e e E,}; remember E0 is finite. Then, by Lemma 6.11, E,& EO. Since At= Eb, we have that A = T( 2, Eb) by the

Refinement Lemma 1.15. To this statement we obtain a contradiction as follows:

Let B=(o;O,x+l,p),

where p:o+o is defined by

if n = 0, -1 ifO<nsk,,
if n> k,,.

Now, B k Ek, and so, by the initiality of A = T(2, Ek,), there exists a homomorphism # : A + B. But we can calculate @(1) in two ways:

(a) 4( 1) = &(s(O)) = s&(O) = s(O) = 1;

(b) 4(l) = &( p%%)(1j) = p4$(skf)( 1)) = p$b(k,+ 1) = 0.

This is a contradiction. U

The classification programme can be extended to other specification methods: closely related are algebraic specifications equipped with final algebra semantics; specifications that allow forms of negation under both initial and final algebra semantics; soecifications possessing stronger properties such as associated rewrite rule systems that are confluent and noetherian, or properties such as w-completeness; specifications that allow partial operations under initial and final algebra semantics.
of these cases there is much work to be done for the mathematics of the methods k not as simple as that of the cases considered here (see, for example, [ 15,231). Pn addition, the classification programme could include techniques such as those in [32,35].

Algebraic specijicalions of ( semi) eomputable data types

179

We have taken some steps in these directions in our series [3-II], particularly focusing on the subject of adequacy and completeness theorems for (FIN, EQ, HE) and (FIN, CEQ, HE) specifications under initial and final algebra semantics. Those of our resuits that are improvements of Theorem 5.1 are proved using substantially harder arguments (involving the Diophantine Theorem for r.e. sets); thus, the virtue of Theorem 5.1 is its use of basic facts about computability theory. In the case of semicomputable algebras, Theorem 5.3 is both simple and the only completeness theorem for the finite specifications under initial algebra semantics that is known. We feel that the solution of Open Problem 3.15 will be an important step forward.

Acknowledgment
We are particularly indebted to S. Kamin, J. W. Thatcher, P. Rodenburg, and an anonymous referee for useful criticism on earlier versions of this paper. We thank Ms. Judith Thursby for typing the manuscript.

References

Ill J.A. Bergstra, M. Broy, M. Wirsing, J.V. Tucker, On the power of algebraic specifications, in: J.
Gruska and M. Chytil, eds., Proc. Mathematical Foundations of Computer Science 1981, Strbske

Pleso, Czechoslovakia, Springer Lecture Notes in Computer Science 118 (Springer, Berlin, 1981)

193-204.
[2] J.A. Bergstra and J.-J. Ch Meyer, On specifying Kyberner. 20 (1984) 531-541.

sets of integers,

Eleklron. Znformarionsverarb.

[3] J.A. Bergstra and J.V. Tucker, On the adequacy of finite equational methods for data type specifications, ACM-Sigplan Nolices 14( 11) ( 1979) 13- 18.

[4] J.A. Bergstra and J.V. Tucker, Algebraic specifications of computable and semicomputable data

structures, Department of Computer Science Research Rept. I W 115, Mathematical Centre, Amster-

dam, 1979.

[51J J.A. Bergstra and J.V. Tucker, A characterisation of computable data types by means of a finite, equational specification method, in: J.W. de Bakker and J. van Leeuwen, eds., Proc. 7th ICALP,

Noordwijkerhout, 1980 (Springer, Berlin, 1980) 76-90.

[6] J.A. Bergstra and J.V. Tucker, Equational specifications for computable data types: six hidden

functions suffice and other sufficiency bounds, Department Computer Science Research Rept. IW

l-28, Mathematical Centre, Amsterdam, 1980.

[7] J.A. Bergstra and J.V. Tucker, On bounds for the specification of finite data types by means of

equations and conditional equations, Department Computer Science Research Rept. IW 131,

Mathematical Centre, Amsterdam, 1980.

[8] J.A. Bergstra and J.V. Tucker, A natural data type with a finite equational final s,mantics specification
but no effective equational initial semantics specification, Bulletin EATCS II ( 1980) 23-33. [9] J.A. Bergstra and J.V. Tucker, Algebraically specified programming systems and Hoare‘s logic, in:
S. Even and 0. Kariv, eds., Pror. o“+..~L KELP, Acre, 1981, Springer Lecture Notes in Computer

Science 115 (Springer, Berlin, 1981) 348-362.

[lo] J.A. Bergstra and J.V. Tucker, Initial and final algebra semantics for data type specifications: two characterisation theorems, SIAM J. Cornput. 12 ( 1983) 366-387.

[ 111 J.A. Bergstra and J.V. Tucker, The wupleteness types, Inform. and Conrrol 54 ( 1982) 186-200.

of the algebraic specification methods for data

180 J.A. Bergstra, J. V. Tucker

[12] J.A. Bergstra and J.V. Tucker, Expressiveness and the completeness r:f Hoare’; Jcgic, 3 COrnpUt.

System Sci. 25 (1982) 267-284. [ 131 J.A. Bergstra and J.V. Tucker, The axiomatic semantics of programs based on Hodre’s logic, Acfa

Inform. 21 (1984) 293-320. [14] M. Broy, W. Dosch, H. Parsch, P. Pepper and M. Wirsing, Existential quantifiers in abstract data

types, in: H. Maurer, ed., P)oc. 6ih !Cd4!P5 C~r?z, 1980 (Springer, Berlin, 1979) 72-87.

[ 151 M. Broy and M. Wirsing, Partial abstract types9 Actu iirjbrm. 18 (1982) 47-64.

[ 161 P.M. Cohn, Universal Algebra (Harper and Row, New York, 1965).

[ 171 J.A. &gum, J.W. Thatcher, E.G. Wagner and J.B. Wright, Abstract data types as initial algebras and correctness of data representations, in: Proc. ACM Conference on Computer Graphics, Pattern

Recognition and Data Structure, New York (1975) 89-93.

[ 173 J.A. Goguen, J.W. Thatcher, E.G. Wagner and J.B. Wright, Abstract data types as initial algebras

and correctness of data representations, in: ptoc. ACM Conference on Computer Graphics, Pattern

Recognition and Data Structure, New York (1975) 89-93.

[18] J.A. Goguen, J.W. Thatcher and E.G. Wagner, An initial algebra approach to the specification,

correctness and implementation of abstract data types, in: R.T. Yeh, ed., Current Trends in Program-

ming Methodology; IV, Data Structuring (Prentice-Hall, Englewood Cliffs, NJ, 1978) 80-149.

[ 193 G. Grgtzer, Universal Algebra (Van Nostrand, Princeton, 1968).

[20] D. Gries, ed., Programming Methodology (Springer, Berlin, 1978). [21] J.V. Gutt2g, The specification and application to programming of abstract data types, Ph.D. Thesis,

Department Computer Science, University of Toronto, Toronto, 1975. 1221 J.V. Guttag and J.J. Horning, The algebraic specification of abstract data types, Acta Inform. 10

(1978) 27-52.

1231 J. Heering, Partial evaluation and o-completeness of algebraic specifications, Theoret. Compu!‘. Sci.

43 (1986) 149-167.

[24] P.N. Hilfinger, Correspondence from members, ACM-Sigplan Notices 13 (1978) 11-12. [25] C.A.R. Hoare, An axiomatic basis for computer programming, Comm. ACM 12 (1969) 576-583.

[26] C.A.R. Hoare, Pro of of correctness of data representations, Acta Inform. 1 ( 1972) 27 l-28 1. [27] C.A.R. Hoare, Notes on data structuring, in: O.J. Dahl, E.W. Dijkstra and C.A.R. Hoare, eds.,

Structured Programming (Academic Press, London, lQ?2). [28] D.W. Jones, A note on some limits of the algebraic ,jpecification methods, ACM-Sigplan Notices

13 (1978) 64-67. [29] B. Kutzler and F. Lichtenberger, Bibfiography on Abstract Data Types (Springer, Berlin, 1983). [30] S. Kamin, Some definitions for algebraic data type specifications, ACM-Sigplan Notices 14 (1979)
28-37.

[3 1] D. Kapur, Specifications of Majster’s traversable stack and Veloso’s traversable stack, ACM-Sigplan Notices 14 (1979) 46-53.

1321 H. Klaeren, A constructive method for abstract algebraic software specification, Theoret. Comput. Sci. 30 (1984) 139-204.

1331 G. Lallement, Semigroups and Combinatorial Applications (Wiley, New York, 1978). [34] B. Liskov and S. Zilles, Specification techniques for data abstractions, IEEE Trans. Sofrware Engrg.
SE-1 (1975) 7-19.

1351 9. Loeckx, Algorithmic specifications of data types, in: S. Even and 0. Ksriv, eds., hoc. 8th ICALP,

Acre, 1981, Springer Lecture Notes in Computer Science 115 (Springer, Berlin, 1981) 129-147. 1361 R Lyndon and P. Schupp, Combinatorial Group Theory (Springer, Berlin, 1977).

[37] M.E. Majster, Limits of the “algebraic” specification of abstract data types, ACM-Sigplan Notices 12 (1977) 37-42.

1381 ME- Majster, Data types, abstract data types and their specification problem, Theoret. Comput. Sci. ( 1979) 89- 127.

.I. Mal’cev, Constructive algebras I, Russian Math. Surv

[40] A.I. Mal’cev, Algorithms and

1411 A.I. Mal’cev, Algebraic Syste
WI J- MesewerandJ. Goguen, I
eds., Akebraic Methods in Semantics (Cambridge

University

Press, 1985).

1431 D-L. Parnas, On the criteria to be used in decomposing systems into modules, Comm. ACM 15 ( 1972) 1053- 1058.

Algebraic specijka tions of ( semi) computable data types

181

[44] D.L. Parnas, A technique for software module specification with examples, Comm. ACM 15 (1972)
330-336. [45] K. Prachar, Primzahluerteilurrg (Springer, Berlin, 1957). [46] M.O. Rabin, Computable algebra, general theory and the theory of computuble fields, Trans. Amer.
Math. Sot. 98 (1960) 341-360. [47] H. Rogers, Theory of Recursive Functions and E$ective Computability (McGraw-Hill, New York,
1967).
[48] J.J. Rotman, Theory ofGroups (Allyn and Bacon, Boston, 1973).
1491 P.A. Subrahmanyam, On a finite axiomatisation of the data type L, ACM-Sigplan Notices 13 (1978) 80-84.
[SO] V. Stoltenberg-Hansen and J.V. Tucker, Computable algebra. An introduction to computable rings and fields, in preparation.
[Sl] J.W. Thatcher, E.G. Wagner and J.B. Wright, Specification of abstract data types using conditional axioms, IBM Research Rept. RC 6214, Yorktown Heights, NY, 1979.
[52] J.W. Thatcher, E.G. Wagner and J.B. Wright, Data type specifications: parametrization and the power of specification techniques, IBM Research Rept. RC 7757, Yorktown Heights, NY, 1979.
1531 J.V. Tucker and J.I. Zucker, Program correctness over abstract data types, with error-state sema&cs, Research Monograph, in preparation.
[54] P.A.S. Veloso, Traversable stack with fewer errors, ACM-Sigplan Notices 14 (1979) 55-59. [55] M. Wand, Final algebra semantics and data type extensions, .I. Comput. System Sci. 19 (1979) 27-44. [56] M. Wirsing and M. Broy, Abstract data types as lattices of finitely generated models, hoc. 8th
Symp. on Mathematical Foundations of Computer Science, Rydzyna 1980 (Springer, Berlin, 1980). [571 A. van Wijngaarden, Numerical analysis as an independent science, BIT 6 (1966) 66-81. [58] S. Zilles, An introduction to data algebras, Working Paper, IBM Research Laboratory, San Jose,
CA 1975.

