Transforming Cabbage into Turnip
(polynomial algorithm for sorting signed permutations by reversals)

Sridhar Hannenhalli

Pavel Pevznery

March 2, 1995

Abstract
Analysis of genome rearrangements in molecular biology started in the late 1930's, when Dobzhansky and Sturtevant published a milestone paper presenting a rearrangement scenario with 17 inversions for the species of Drosophila. Analysis of genomes evolving by inversions leads to a combinatorial problem of sorting by reversals studied in detail recently. Kececioglu and Sanko conjectured that sorting by reversals is NP-hard, but despite many attempts their conjecture remains open. We study sorting of signed permutations by reversals, a problem which adequately models rearrangements in small genomes like chloroplast or mitochondrial DNA. The previously suggested performance guarantee algorithms for sorting signed permutations by reversals approximate the reversal distance between permutations with an astonishing accuracy for both simulated and biological data. We prove a duality theorem explaining this intriguing performance and show that there exists a \hidden" parameter which allows one to e ciently compute the reversal distance between signed permutations.
1 Introduction
In the late 1980's Je rey Palmer and colleagues discovered a remarkable and novel pattern of evolutionary change in plant organelles. They mapped the mitochondrial genomes of Brassica oleracea (cabbage) and Brassica campestris (turnip), which are very closely related (many genes are 99% - 99.9% identical). To their surprise, these molecules, which are almost identical in gene sequence, di er dramatically in gene order (Fig. 1). This discovery and many other studies in the last decade convincingly proved that genome rear-
supported by NSF Young Investigator Award, NSF grant CCR-9308567, NIH grant 1R01 HG00987 and DOE grant DEFG02-94ER61919
yDepartment of Computer Science and Engineering, The Pennsylvania State University, University Park, PA 16802; email: hannenha,pevzner@cse.psu.edu. . . . . . . . . . . . . . . . ....................................... ....................................... ....................................... ....................................... ....................................... .....

rangements is a common mode of molecular evolution in mitochondrial, chloroplast, viral and bacterial DNA (see Bafna and Pevzner, 1995a).
Every study of genome rearrangements in mitochondrial DNA involves solving a combinatorial \puzzle" to nd a shortest series of reversals to transform one genome into another. (Three such reversals \transforming" cabbage into turnip are shown in Fig. 1.) For genomes consisting of small number of \blocks", Palmer and co-authors were able to nd the most parsimonious scenarios for rearrangements. However, for genomes consisting of more than 10 blocks, exhaustive search over all potential solutions is far beyond the possibilities of \pen-and-pencil" methods. As a result, Palmer and Herbon, 1988 and Makaro and Palmer, 1988 overlooked the most parsimonious scenarios of rearrangements in more complicated cases like turnip vs. black mustard or turnip vs. radish (see Bafna and Pevzner, 1995a for correct solutions).
Analysis of genome rearrangements provides a multitude of challenges; see Pevzner and Waterman, 1995 for a review of open combinatorial problems motivated by genome rearrangements. A computational approach based on comparison of gene orders versus traditional comparison of DNA sequences was pioneered by Sanko (see Sanko et al., 1990, 1992 and Sanko , 1992). Kececioglu and Sanko , 1993 suggested the rst performance guarantee algorithm to analyze genome rearrangements and conjectured that sorting by reversals in NP-hard. The problem was further studied by Bafna and Pevzner, 1993 who introduced the notion of breakpoint graph of a permutation and revealed important links between the maximum cycle decomposition of this graph and reversal distance. See also Kececioglu and Sanko , 1994, Kececioglu and Gus eld, 1994, Kececioglu and Ravi, 1995, Hannenhalli, 1994 and Bafna and Pevzner, 1995b for recent progress on the computational aspects of genome rearrangements, as well as Gates and Papadimitriou, 1979, Even and Goldreich, 1981, Jerrum, 1985, Aigner and West, 1987, Cohen and Blum, 1993 and Heydari and Sudborough, 1993 for studies of related combinatorial problems.
In the problem we consider, the order of genes

1

2

is represented by a permutation. A reversal (i; j) transforms a permutation

= ( 1 : : : i?1 i i+1 : : : j?1 j j+1 : : : n)

into a permutation

(i; j) = ( 1 : : : i?1 j j?1 : : : i+1 i j+1 : : : n)

and has the e ect of reversing the order of elements

reivei+rs1a:l:d:isjta?n1cej.prGobilveemn

permutations is to nd a series

and , the of reversals

m1i;ni2m; u: :m:; (Ft isgu.c2ha)t.haWt e

cal1l

t

t2he

retve=rsal

and t is distance

between and . Sorting by reversals is the problem

of nding the reversal distance, d( ), between and

the identity permutation (12 : : :n).

What makes it hard to sort a permutation? In

the very rst computational studies of rearrangements

Watterson et al., 1982 and Nadeau and Taylor, 1984

introduced the notion of breakpoint and noticed some

correlations between the reversal distance and the

number of breakpoints. (In fact, Sturtevant and

Dobzhansky, 1936 implicitly discussed these correla-

tions 60 years ago!) Breakpoints are de ned as fol-

lows. Let i j if ji ? jj = 1. Extend a permutation

Wpofoi=ei6 nctsaa1,linl+s21oaa.:rdt:jApi:anascgienrtnhbboceyyfyidreiaefledevnmdetiriienstnyagtlsps e0c(rio+m=ri1r,u,e0tsaapaitn+noidond1n)da,shn0bat+rsoe1ane=kolpiimbonirine+natakn1ti-f.-,

ing breakpoints. An observation that every rever-

sal d( in

)c.anHbeo(l2iwm)e,viwnearh,teertehaetb(mes)otsiimts 2athteberonefaukmrpebvoeeinrrstoasflibmdriepsatliakenpscoteihnaitnst

terms of breakpoints is very inaccurate. Bafna and

Pevzner, 1993 found another parameter which esti-

mates reversal distance with much greater accuracy.

The breakpoint graph of a permutation =

(vbFerjiireg1tb6a.iyk2c2peb:aso:.j)i:fbnalAatnn0cd);ikcniyies1cd;lae:g?n:ei1:jne;i)df(aig(a.nneen;-.iedc,donlgb+ojeiy1r)-gecaid.oslWggoarrrjaeabeydprjaoehnegainddrkGagpv(pieoehri6)intfGitwc(ejiiiinst);sh.jc)ina((ialS+siln.eeedda2e.

alternating if the colors of every two consecutive edges

of this cycle are distinct. In the following by cycles we

mean alternating cycles. The length of a cycle C, de-

noted by l(C), is the number of black (or equivalently,

gray) edges in it. A cycle C is short if l(C) = 2 and

long if l(C) > 2. A permutation is simple if it has

no long cycles.

Consider a cycle decomposition of G( ) into a

maximum number c( ) of edge-disjoint alternating

cycles (Fig. 2b). Bafna and Pevzner, 1993 showed that

the maximum cycle decomposition provides a better

bound for the reversal distance:

(1.1) d( ) b( ) ? c( )

Hannenhalli and Pevzner

However, nding a maximum cycle decomposition is

a di cult problem. Fortunately in biologically more

relevant case of signed permutations this problem is

trivial. Genes are directed fragments of DNA and se-

quence of n genes signed permutation

in on

af1g;e:n: o: nmge wisithre+preosren?tesdignbyasa-

sociated with every element of . For example, a gene

order by a

for B. signed

poelerrmaucetaatpiornese(n+t1ed?in5

Fig. +4

?1

is modeled 3 + 2). In

the signed case, every reversal (i; j) changes both the

order and the signs of the elements within the frag-

ment in the

mi iin+i1m:u: :mjn?u1mjbe(rFiogf.

1). We reversals

are d(

interested ) required

to transform a signed permutation into the iden-

tity signed permutation (+1 + 2 : : : + n). Bafna and

Pevzner, 1993 noted that the concept of breakpoint

graph extends naturally to signed permutations and

devised an approximation algorithm for sorting signed

permutations with performance ratio 1.5. For signed

permutations the bound (1.1) approximates the rever-

sal distance extremely well for both simulated (Kece-

cioglu and Sanko , 1994) and biological data (Bafna

and Pevzner, 1995a, Hannenhalli et al., 1994). This

intriguing performance raises a question whether the

bound (1.1) overlooked a third parameter (in addi-

tion to the number of breakpoints and the size of a

maximum cycle decomposition) that would allow clos-

ing the gap between d( ) and b( ) ? c( ). Below we

answer this question by revealing the third \hidden"

parameter (number of hurdles in ). We show that

b( ) ? c( ) + h( ) d( ) b( ) ? c( ) + h( ) + 1,

where h( ) is the number of hurdles in . Based on

this result we devise a polynomial algorithm for sort-

ing signed permutations by reversals. This is the rst

polynomial algorithm for a realistic model of genome

rearrangements.

The paper is organized as follows. In section 2 we

introduce the notion of a hurdle and prove the bound

d( ) b( ) ? c( ) + h( ). Previous studies revealed

that a complicated interleaving structure of long cy-

cles in the breakpoint graph poses major di culties in

analyzing genome rearrangements. To get around this

problem we develop a new technique called equivalent

transformations of permutations (section 3). The tech-

nique allows one to mimic sorting permutations with

long cycles by sorting simple permutations. In sec-

tion 4 we study combinatorics of simple permutations

and make the rst step towards proving the bound

d( ) b( )?c( )+h( )+1 . In section 5 we associate

a partial order with every permutation. The proper-

ties of this partial order allow us to introduce safe re-

versals (hurdle cutting and hurdles merging) which are

the key operations for clearing the hurdles in our algo-

rithm. In section 6 we further develop a characteriza-

twiohnichofc\ahnarndo-ttob-seorsto"rtpeedrminutba(ti)on?s

(called c( ) +

fortresses) h( ) steps

Transforming Cabbage into Turnip

and prove the duality theorem

d( ) =

b( b(

) )

? ?

c( c(

) )

+ h( + h(

) + 1; );

if is a fortress otherwise

Finally in section 7 we present a polynomial algorithm for sorting by reversals based on equivalent transformations, duality theorem and clearing the hurdles. The applications of these results are given in Hannenhalli and Pevzner, 1994 where the duality theorem was used to settle two conjectures by Kececioglu and Sanko (reversals do not cut long strips and reversals do not increase the number of breakpoints) while the algorithm for sorting signed permutations was used to analyze evolution of extensively rearranged plant and animal organelles.

2 Interleaving graph and hurdles

De of

ne a order

tnratnosfoarnmuantisoingnferdompearmsiguntaedtiopnerm0uotaf tioornder

2n as follows. To model the signs of elements in

replace the positive elements +x by 2x ? 1; 2x and

tnheegautnivseigenleedmpenetrsm?utxatbioyn2x;0

2x ? 1 (Fig. 2c) We call the image of the signed

permutation . Observe that in the breakpoint graph

of the image of a signed permutation, every vertex has

degree at most 2. Therefore the cycle decomposition

is unique, thus making signed permutations easier

to analyze. We observe that the identity signed

permutation of order n maps to the identity (unsigned)

pdim((e02.cr=amai)gTn+(euhtbe11ae;t0ed2i2moj(=:en)i:cm0ot:w)(f.ihocnokf1i0r)cedIahdn20werr:\bee:tc2yvh:umneetar,e"20saanrafonnoe)lvlndlseoolo(ytrfw2hsratiaieanilf+netgosegi1rnegb;ocnye2ftevj0does)tnfo0horapbuntpeiyrosrnesmvgiri0meteuivrcooptsaefanalrnytslstiiaoobhnilnnneesg

mPtbheeiatvmwtzinedceek(nre,d)1=b209iy9?d31a().arne0I)vdneifrtsht20ahiel)eraec(rsiuett+sfoof1ar;btfjthie)derdopoenandpd(esrtpeheoauslsBlituaiimofnnnspasilgy(aniine.neddg.

permutations we consider are images of some signed

permutations. For convenience we extend the term

\signed permutation" for unsigned permutations =

n( u1mb2e:r:s:

fo2rn)1

such i

that n.

2i?1 and

2i are consecutive

If edges

( in

i?G1(;

)i)),

and we

s(ayj; thja+t1)raevreerbsarelak(pio; jin)tsac(tbslaocnk

edges ( (acting)

io?n1;a

ic)ycalne,d

( a

rje; vejr+s1a)l

belong to , denote

itf(htebjh;esabjm+ree1a)b.k(cypc;oli(en)i;tisj=n)(Gbis(i(?a1);).re?iGv)ebiarv(sneand)l

(ci(ncr)ea?sec(in)

breakpoints), and (increase in the size

c of the

c( cycle

;)= decom-

position). Bafna and Pevzner, 1993 proved that ev-

ery (b

?revce)rsal

bre(du; ce)s?b(

) c(

? ;

c( )

)?b1y.

at most 1, i.e. We call a rever-

sal proper if (b ? c) = ?1. A gray edge g is oriented

3

if a reversal acting on two black edges incident to g is

proper and unoriented otherwise. A cycle in G( ) is

oriented if it has an oriented gray edge and unoriented

otherwise. It can be veri ed that there is no proper

reversal acting on an unoriented cycle.

Gray terleaving

edges if the

(init;ervj)alasndi;

( j]

ka;ndt)

in G( ) are k; t] overlap

inbut

neither in G( )

oafrethienmtercloeanvtianingsiftthheeoretheexri.stCiynctelersleCav1inagndgrCay2

edgeLsegt1C2

Cbe1

tahnedsegt2

2 of

cCy2c.leSseienFthige.

2c for examples. breakpoint graph

of a permutation . De ne an interleaving graph

H (C ; I ) of with the edge set I

CT1heanvderCte2xarseetintoefrlHeavinisg

cycles in G( partitioned

=)gf((CFi1g;.C22d)).: into oriented

and unoriented vertices (cycles in C ). A connected

component of H is oriented if it has at least one

oriented vertex and unoriented otherwise. For a

connected component U de ne leftmost and rightmost

pUUgbUruomastisaynietxUpieFoa=dm0nir0ggaismen.te;3(aasUasxmic0Cs;0oUea2mpxmUj]a)pimr6nioanantex=ieU;snjitts]2smh.uCecUFihnioc0.C;ortWUhm2eUax0pe0tamosimnanUiypenm0nlteitihn,i2saf;tCUthUthiae0m0eccaaroonxeamm]dnedppxUoois0nni0ta.;eesnjnnd]att,

Let be a partial order on a set P. An element

x 2 P is called a minimal element in if there is no

element y 2 P with y x. An element x 2 P is

the greatest in if y x for every y 2 P . Consider

the set of unoriented components U in H and de ne

the containment partial order on this set, i.e. U W

ihurdUlemiisn;dUemnaexd]

as

aWn munino;rWienmtaexd]

for U; W 2 U . A component U which

is either a minimal hurdle or the greatest hurdle where

a minimal hurdle is a minimal element in and the

greatest hurdle satis es the following two conditions

(i) U is the greatest element in and (ii) U does

not separate any two hurdles. Let h( ) be the overall

number of hurdles in (see Fig. 3). The following

tPh,redoo(Troefhm):eofGurbrie(vtmhe)ner?1a.icmr(Fepvo)reror+vsaaerhslb(itth,r)ea.drebynoo(utsneidgn(eh1d.)1)perhm(ut;at)io=n

h( ) ? h( ). Since acts on black edges of at most

two hurdles, it may \destroy" at most two minimal

hurdles. Note that if destroys two minimal hurdles

in U then can not destroy the greatest hurdle in

U (see condition (ii) in the de nition of the greatest

hurdle). Therefore h ?2.

Bafna and Pevzner, 1993 proved that (b ? c) 2

f?1; 0; 1g. If (b?c) = ?1, then acts on an oriented

cycle (Bafna and Pevzner, 1993) and hence it does

not a ect any unoriented components in . Therefore

h 0 and (b ? c + h) b ? c + h ?1.

If (b ? c) = 0, then acts on a cycle and a ects

at most one hurdle (see condition (ii)). It implies

h ?1 and (b?c+h) ?1. If (b?c) = 1, then

(b?c+h) ?1 since h ?2 for every reversal .

4

Therefore, for an arbitrary reversal , (b?c+h) ?1

thus implying d( ) b( ) ? c( ) + h( ).

2

3 Equivalent transformations of permutations

Previous studies revealed that complicated interleav-

ing structure of long cycles in the breakpoint graphs

poses serious di culties in analyzing sorting by rever-

sals (Bafna and Pevzner, 1993) and by transpositions

(Bafna and Pevzner, 1995b). To get around this prob-

lem we introduce equivalent transformations of per-

mutations based on the following idea. If a permu-

tation (0) has a long cycle, transform it into

a new permutation (1) by \breaking" this long cy-

cle into two smaller cycles. Continue with (1) in

the same manner and form a sequence of permuta-

tions (0); (1); : : :; (k) ending with a sim-

ple (i.e. having no long cycles) permutation. In this

section we show that these transformations can be ar-

ranged in such a way that every sorting of mimics

a sorting of with the same number of reversals. In

the following sections we show how to optimally sort

simple permutations. Optimal sorting of the simple

permutation mimics optimal sorting of the arbitrary

permutation leading to a polynomial algorithm for

sorting by reversals.

Let b (G(w: (:g:;;)vvgbo);fwbabe;

= a

g(rvaby; webd)gebebealonbgliancgk

edge and to a cycle

:p:e:r;mwugt;avtgi;o:n:

:)

in .

the breakpoint A (g; b)-split of

g= C= graph G( )

is a new graph G^( ) obtained from G( ) by (i)

removing edges g and b, (ii) adding two new vertices

vaoanfnddaan((dswvi;g;wvnwg,eb)d)(,(ipFi(ie)iivgrm.)adua5ddt)aid.ntiginoIgfntwGtwo(otnh)neeeiwnswaebgvlrbeaarrcyyekaek(edgpdg;ogebies)ns-ts(pw(gvlgribta;;wpvoh))f

G( ) corresponds to the breakpoint graph of a signed generalized permutation ^ such that G^( ) = G(^).

Below we de ne a permutation ^ corresponding to a

(g; b)-split of G( ).

A generalized permutation permutation of arbitrary distinct

=( reals

(1ve2rs:u: :s

pne)rmisua-

tations of integers f1; 2; : : :; ng we considered before).

In this section by permutations we mean generalized

permutations and by identity generalized permutation

wwaeeETlmdleiehetdmeehmminnebteegnrsnatietnas<0kjalp=oaigsinueanmidn+cntheid1nrgairktfalhoiipo+zraiheft1?d1oo1pffjaeaarr<nemiad(crgueoetlnnanas<ent+deir1joca?anul=citkez1ienvm.fdet=o)arfEixof(pi1xrett10hreimen+2rduel:ti1:ai.:stiEbnonnnlyno)-..

cfen=0t; e(l1e;1m: :e2:n;:t:s:nt;hna)nt+ias1rgdeewniontthedcbolnaasscektchueetdigvgeersaapbnhedtowgnreaevynereatddigcjeeass-

between consecutive elements that are not adjacent.

(

Let j; k)

b= be a

g(rai+y1;edig)e

be a black edge and belonging to a cycle

g C

= =

Hannenhalli and Pevzner

eawG(:le(p:=m:e;)re.mnikt+usD?t1a;oetb3iiotn;.ane:iA:n^:e;d=(g=jf;(r;bo)1m-kpk;a2:?d::d::b)i:ynijgniivnaowtsnfhedreit+ilb=ne1rtg:e(:avv:k1pa=non2)id:no:twnj: g+narnaf+)tp3eih2rs,

the i-th element of . Note that v and w are both

consecutive and adjacent in ^ thus implying that if

i(sth(ethime iamgeagoef)oaf)siagnseigdnpeedrmpeurtmatuitoant.io1n

then The

^ is also following

lemma establishes the correspondence between (g; b)

paddings and (g; b)-splits.
Lemma 1. G^( ) = G(^).
A (g; b)-padding transforming into ^ = is

safe if it acts on non-incident edges of a long cycle and

h( ) = h(^). Clearly, every safe padding breaks a long

cycle into two smaller cycles. Therefore safe paddings

may be used to transform an arbitrary permutation

parinatmoetaersbim( p)l?e cp(er)m+uht(at)io(nnowteitthhoauttb(c^h)an=gibn(g)t+h1e

and c(^) = c( ) + 1). Below we prove that for

every permutation with a long cycle there exists a safe

paddLinegm. mFiars2t.wLeenteaed(ga;

series of lemmas. b)-padding break

a

cycle

C

in G( ) oriented

iintoeitchyecrleCs 1Co1r

and C2

isCo2riinenGte(d^. ).

Then

C

is

Lemma 3. Let a (g; b)-padding breaks a cycle C

in G( ) cycle D

iinntteorlceyacvliensgCw1itahnCd

Cin2

in G(

G(^). Then every ) interleaves with

either C1 or C2 in G(^).

Lemma 4. For every gray edge g there exists a
gray edge f interleaving with g in G( ) . If C is a cycle in G( ) and g 62 C then g interleaves with an

even number of gray edges in C.

Theorem 2. If C is a long cycle in G( ), then
there exists a safe (g; b)-padding acting on C.

Proof ign1t;og2tw2o

If C has a pair of interleaving gray edges C then removing these edges transforms C paths. Since C is a long cycle at least one

of these paths contains a gray edge g. Pick a black

edge b from another path and consider the (g; b)-

padding transforming into ^ (clearly g and b are

non-incident edges). This (g; b)-padding breaks C into

iactnoyrteceldreiilsnetaeCevrre1ilnneaagtnv. cidAnygclCsloe2tshtihunCiss1G(img(a^;npb)dl)y-wpiCniat2gdh.dtgihn1CagtlaednaCodre1lysg,an2nogbdt1e\laCbonnr2degaiakngr"ge2

the component K in H containing the cycle C since

by lemma 3 all cycles from K belong to the component

loefmHm^ac2ontthaeinoirniegnCta1tiaonndofCt2h. isMcoormeopvoenre, natccinorHdingantdo

1Of course, a (g; b)-padding of a permutation = ( 1 2 : : : n) on f1; 2; : : : ; ng can be modeled as a permutattv^ihio=en=fo^ljlio=+owt(i1hn^;eg1wr^w\2=mis:ei:m.:kW^ici+kveiwn1pg,^re"i^+fmei1r=o:gr:ee:n^iiennr+t)aul2oiitznieivfdfe.p1i;e2r>m; :um: :ti;anntfio+njs;2tgokwgmhaaenkrdee

Transforming Cabbage into Turnip

pHr^eseisrvtehsetshaemseet.

Therefore of hurdles

the and

chosen hence,

(g; h(

b)-padding ) = h(^).

If all gray edges of C are mutually non-interleaving

then C is an there exists

aungorraiyenetdedgecyecl2e.CL0eminmtearlsea4viimngplwieisththaatt

gcley2acstltreaatnwtsfoloeragmsrtasyoCneedingotefostthgwe1so;egp2paat2thhsCsac.nodnRtsaeinmincsoevaCinggirsagya1

and long edge

g. Pick a black edge b from another path and consider

the (g; b)-padding of . This padding breaks C into

idcnyitcelererlseenaCtv1ecaywncidltehsCCC2 01inianGn^d(.^C)T2wh. ietCrhelfegoa1rrealynt,hdbisgo2t(hgb;eCbl)o1-npaganidnddgiCntog2

ttCdahhno2eidesascCrchneo0oomu.stneMpbnoorronie(regeaenn;kotbtve)tedi-hnrpe,tahHacducodcsmioianmrpngdodpipnnlHryegenisn^tteogriKsvtlehetmisahntemttHhshaeae2msoceberot.ioneotTtnhfathiahCneturii1nerodfganolnreoCdesf

and hence, h( ) = h(^).

2

A permutations is equivalent to a permuta-

tion if there exists a series of permutations

(0); (1); : : :; (k) such that (i+1) = (i) (i)

for De C

a safe (g; b)-padding (i) ne the complexity( ) = is the set of cycles in G(

Po)naCn2d(Ci)l((C(l(0C) )is?ith2e)klwe?nhge1tr)he.

of a cycle C. The complexity of a simple permutation

is 0. Note that every padding on non-incident edges

p(olfa(dCad)lio?nng2gs)cr=yedc(luelc(CCe 1tbh)?reeca2ok)m+s Cp(ll(eiCxni2tto)y?coy2fc)pl+eesr1mC. uT1thaaentridoefnCosr2.eTwsahitfihes

observation and theorem 2 imply that every permuta-

tion with long cycles can be transformed into a simple

permutation by a series of safe paddings preserving

b( ) ? c( ) + h( ).

Let ^ be a (g; b)-padding of and be a reversal

acting on two black edges of ^. Then can be

mimicked on by ignoring the padded elements. We

need a generalization of this observation. A sequence

of permutations

(0); (1); : : :; (k) is

called a generalized sorting of if is the identity

(generalized) permutation and (i + 1) is obtained

from (i) either by a reversal or by a padding. Note

that reversals and paddings in generalized sorting of

maLyemintmeralea5v.eE. very generalized sorting of mimics

a (genuine) sorting of with the same number of

reversals.

In the following we show how to nd a generalized

sorting of a permutation by a series of paddings

and reversals containing d( ) reversals. Lemma 5

implies that this generalized sorting mimics an optimal

(genuine) sorting of .

4 Safe reversals in oriented components

Recall that for an arbitrary reversal, (b?c+h) ?1

(see (b

?prcoo+f

of h)

=the?or1e.mIn1)t.he

A reversal following we

is safe if prove the

5

existence of a safe reversal in a simple permutation

with an oriented cycle. In this section, by cycles

we mean short cycles and by permutations we mean

simple permutations.

Denote the set of cycles interleaving with a cycle

C in G( ) as V (C) (i.e. V (C) is the set of vertices adVejad(cgCeens)taitnnodtChCei1nsiunHbtgerr)la.epaLhveetosfEwH(itCh)iCn=2dufin(cCed1g;bCby2e)Vt:(hCCe1);.sCetD2 oe2-f

Cno1t;eCAt2hr2eevVceor(msCapl)leamnadcetnCint1godfoonEes(aCnn)ootraisiennEttee(rdCle)(asv=heowrft(i)Cthc1y;CcCl2e2g)C. :

\destroys" C (i.e. removes the edges of C from G( ))

and transforms every other cycle in G( ) into a cor-

responding cycle on the same vertices in G( result transforms the interleaving graph H

()C.

A; Is

a )

of into the interleaving graph H (C nC; I ) of .

This transformation results in complementing the sub-

graph induced by V (C) as described by the following

lemmLae.mWmead6en. oLteetI
ented (short) cycle C

.

= I n f(C; D) : D bTehaenre(vie)rIsal a=cti(nIg

2 V (C)g. onnEa(nC)o)ri-

E(C), i.e. removes edges E(C) and adds edges E(C)

to transform H tion of a cycle D

i2ntCo

H i

;D(i2i)V

changes (C).

the

orienta-

Lemma 7. Let be a reversal acting on a cycle
C and A, B be non-adjacent vertices in H . Then (A; B) is an edge in H i A; B 2 V (C).

Let K be an oriented component of H and let R(K) be a set of reversals acting on oriented cycles from K. Assume that a reversal 2 R(K)

\breaks" K into a number of connected components

Kpo1n(en);tsKa2r(e

); : : : in H unoriented.

and the If m > 0

rst m of these comthen may be unsafe

since form

some of the new hurdles

cinompotnheunstsinKcr1e(as)i;n:g:

:h;(Km)(as);cmomay-

pared to h( exibility in

). In the choosing

following we show that a reversal from the set

Rth(eKre)isala-

lowing one to substitute a safe reversal for an unsafe

reversal .

Lemma 8. Let and
orensptewcotiivnetlyer.leIaf vCin0 gbeolroinegnstetdo

be the cycles C

arenvderCsa0 lisn

acting G( ),

an unoriented component

wKh1i(ch)

in H then (i) every are adjacent in H

two are

avlesroticaedsjaocuetnstidienKH1(

) ;

(ii) orientation of vertices outside change in H as compared to H .

K1(

)

does

not

Proof
nected

Let D; E by an edge

be in

Htwo.vIefrtoinceesofouthtseisdeevKer1ti(ce)s,csoany-

D, does plies (i)

(nCo0t;

belong to V (C) in H D) is not an edge in H

then and

lemma 7 im(ii) (D; E) is

an edge in H . Therefore, by lemma 6 reversal pre-

serves the edge (D; E) in H . If both vertices D and

E belong to not an edge

V (C) in H

then lemma 6 . Since vertex

iCm0palineds tvheartti(cDes;

E) D;

is E

tahreatin(Cd0i;

Der)enatndco(mCp0;oEne)natrseoefdHges

, lemma 7 implies in H . Therefore,

6

by lemma 6, (D; E) is an edge in H . In both cases

preserves the edge (D; E) in H and the rst part

of the lemma holds.

Kan1d(

L)e,mDma27Vim(Cp)lieis lemma 6 imply

tDhat2foVr

(eCve0)r.y

vertex D outside This observation

that the orientation of vertices

outside K1( ) in H and H is the same. 2

H

Theorem 3.
there exists a

(Fsoarfee)vereryveorrsiaelnte2d

cRom(Kpo)nseuncthKthiant

all components K1( ); K2( ); : : : are oriented in H .

Proof Assume that a reversal 2 R(K)

\breaks" K into a number of connected components

Kar1e( u)n;oKri2e(nt)e;d:.: :

in H Denote

and the the overall

rst m of them number of ver-

tmaiPnincidmienK=s1bi2i(jrnRKe)(atKi.k(h)seL)isnjKee,tdwueixnhno(etbroreie)e.anajKtTneriehud(vimsec)rbojrsmeeairsvlpetorsohsfuneaceclhnnoatumtscmhtpasabostneorneiinnnoatddfsee.vcxxye((rcItlf))eicae==Clsl

these components are oriented (i.e. index( ) = 0)

the theorem holds. Otherwise index( ) > 0 and let

iKn1H( );

: .

:

:B; Kelomw(

) (m we

nd

1) be unoriented another reversal

com2poRne(Knt)s

with index( ) < index( ), a contradiction.

uKcfcfKrroynoo11ncomm((lsreLiid))eVecinentoicrtsamoVeVtrndh1aeptneoaoabinn(irneunniedensontnhontltae(er-eKltitedeesmmne1liett(pnmaebtods)yeatf)aacvt6sodonhee)nmjrd.teaetVicparLceveloeenlv=ensttcreetyroVCntescfotx1al0Ke\lisCbfnVa1ref(cor(itmoaCni)mnn.),HgVo(NVaofo(1lor.Cvlnniteeec)VrCnSytttiaic0nheaclndcaeeridneess)t

G( ). Lemma 8 implies that for i 2 all edges of the

tchoemporoinenentattiKoni(

) of

in H vertices

in H as compared to H

are preserved in H and i.nTKhie(re)fodreoeasllnuontorciheanntegde

components and

Km+1(

); Km+2(

); : : :

of

\survive" in

index( ) index( )

Below we prove that there exists a reversal acting

on a cycle from V such that index( ) < index( ), a

caCon0n0a(t2cIortfariVindVe1gin1cntto6=eViodnn)iVn.Cc(yG0Cc(i)lnet)Ch. e0Lno2ermtiVhemnertaaesn6detxhimaiesntpcsl(yiuaecnsnleotrheCidaegtn00etaeibndree)tvGwcey(resceal)nel.

This observation and lemma 8 imply that reduces

index( ) by at least 1 as compared to index( ), a

contradiction. interleave with

If C.

VS1in=ce

V (C) every

uthneonrieanltledcyschleosrtocfyKcle1

in G( ) has an interleaving cycle (4), there exist at

n(leooartsietinnttteewrdol)eavcvyeircntlgiecsiensC0i;n(CoVt00h(e2Crw)V.i1ses,Mulceohmremtohvaaet6r,w(Ctoh0u;elrCde0i0m)exapirslyet

tchoantneKct1i(vi)tyisoaf

graph with K1( )). De

no edges, ne as a

a contradiction to reversal acting on

Hannenhalli and Pevzner

oCf0C. L00etmhums are6duimcinpglieisndtheaxt(

preserves the orientation ) by at least 1 as compared

to index( ), a contradiction.

The oriented
c( ; )

found reversal =com?p1oannednts. h(

does not create new Therefore b( ; ) = ; ) = 0 implying that

?un2-, is

safe. 2

5 Clearing the hurdles

If has an oriented component then theorem 3 implies

that there exists a safe reversal in . In this section we

search for a safe reversal in the absence of any oriented

component.

Let be a partial order on a set P. We say x

is z

2coPverfeodr

by y in P which x

if x z

y and there is no element y. The cover graph of

is an (undirected) graph with vertex set P and edge

sUet

f(x; y) be the

: set

x; y 2 P and of unoriented

x is covered by components in

yg. H

Let and

Ualent2d UUrimgih(nts;meUeomsseatcxpt]ioobsneit2ito)h.nesDinientenarevnaUlumnbioenrtiw=eenetmnedinthUcoe2mUlepfUtomnmeoinnstt,

Umax = maxU2U Umax and let U be an (arti cial)

component associated with De ne U as the set U

theUinctoenrsviasltinUgmoifn;jUU

mj a+x]1.

elements. Let be the containment partial order

on U de ned eWstmuinno;rWiemntaexd]

by the rule U

fcoormUp;oWne2ntUU

. If in

Wi there (i.e.

Umin; Umax] exists the greatUmin; Umax] =

mUemnitns;

U(\mreaaxl]")

we assume component

that there exist two eleU and \arti cial" compo-

nent U) corresponding to the greatest interval and

that U cover graph

U. of

Let be the the partial order

tree

orenpUresen(Ftiingg.

the 4a).

Every vertex in but U is associated with an unoriented component in U . In the case has the greatest

hurdle we assume that the leaf U is associated with

this greatest hurdle (i.e. in this case there are two

vertices in leaf U and its

corresponding to the neighbor, the greatest

greatest hurdle U

hurdle, 2 U ).

In the case U is a leaf in it is not necessarily a hurdle (for example, U is a leaf in but not a hurdle for a permutation shown in Fig. 3a). Therefore, the number of leaves in coincides with the number of hurdles h( ) except for the cases when (i) there exists only one unoriented component in (in this case

has the

two leaves while greatest element

ihn(U)

= 1) and (ii) there exists which is not a hurdle, i.e.

nthuims Lbeleeermmomefnleatasv9ee.psa(erHqauutearsdlsloeht(chue)trt+ihn1ug)r).dlE2evseL(rieynmrtmehviaesr4csaaimlseptloihenes
a cycle in a hurdle K cuts o the leaf K from the cover

2Although an addition of an \arti cial" component U might look a bit strange and unnecessary we will nd below that such an addition greatly facilitates the analysis of technical details.

Transforming Cabbage into Turnip

graph of , i.e. = n K. A hurdle K 2 U protects a non-hurdle U 2 U if
deleting K from U transforms U from a non-hurdle into a hurdle (i.e. U is a hurdle in U nK). A hurdle in
is a superhurdle if it protects a non-hurdle U 2 U , and a simple hurdle otherwise (see Fig. 4 and 6 for examLpelmesm). aCl1e0a.rlyA reversal acting on a cycle of a
simple hurdle is safe. Unfortunately, a reversal acting on cycle of a superhurdle is unsafe since it transforms a non-hurdle into
a hurdle implying (b ? c + h) = 0. Below we dene a new operation (hurdles merging) allowing one

to search for safe reversals even in the absence of simple hurdles.

If L and M are two hurdles in de ne PATH(L; M) as the set of (unoriented) components

on the (unique) path from the leaf L to the leaf M in the cover graph . If both L and M are minimal elements in de ne LCA(L; M) as an (unoriented) component which is the least common ancestor of L

and M and de ne LCA(L; M) as the least common ancestor of L and M which does not separate L and

M. are

If L corresponds to the two elements U and U in

UgreactoersrteshpuornddleinUg

there to the

same (greatest) interval Umin; Umax] = Umin; Umax].

In this case Let G(V; E)

de be

ne a

gLrCapAh(,Lw; M2)

= V

LCA(L; M) = and W V .

U. A

contraction of W into gfr(app(xh);wp(iyth)) v: er(txe;xy)s2et

EwVg,innw(hGWereisnpd(wve))

ned and =w

as a new

iefdvge2

set W

and p(v) duces the

= v otherwise. Note number of vertices in

that G by

ajWcojn?t1raicftwion2

reW

and by jWj if w 62 W. Let L and M be two hur-

dles in . We de ne (L; M) as the graph obtained

from by the contraction of PATH(L; M) into

LCA(L; M) (loops in (L; M) are ignored). Note that (L; M) corresponds to deleting the elements of the set PATH(L; M) n LCA(L; M) from the partial order .

Lemma 11. (Hurdles merging) Let be a permu-
tation with cover graph and let be a reversal acting on black edges of (di erent) hurdles L and M in . Then acts on as the contraction of P AT H(L; M)

into LCA(L; M), i.e. = (L; M).

PCaItn1rdios2oCefa2LsTyinhattenoodrevaveCneri2rfosyar2iltehnMataetcdteisvncoeyrnGcylbe(clayC)ccklaeinnedidnGgtete(rsraloenfa)stvfho(inFremgicgysw.ci4Clte)h1s.

Cim1poliresCt2haitn

G( ) interleaves with transforms hurdles L

C in G( and M in

). It into

parts of an oriented component in and, therefore, L and M \disappear" from . Moreover, every

component from PATH(L; M) n LCA(L; M) has at least one cycle interleaving with C in G( ). It implies that every such component in becomes a part of an oriented component in and therefore \disappears"

7

from . Every component from U n PATH(L; M) remains unoriented in . Component LCA(L; M)

remains unoriented i LCA(L; M) = LCA(L; M).

Every component which is covered by a vertex from

PATH(L; M) in will be covered by LCA(L; M)

in .

2

We write U < W for hurdles U and W if the

rightmost position of U is smaller then the right-

most position of hurdles of in

W, the

iin.ec.reUasminagx

<ordWermoaxf .

Order the their right-

most positions U(1) < : : : < U(l) L < : : : <

U(m) M < : : : < U(h( )) and de ne the sets

of hurdles BETWEEN(L; M) = fU(i) : l < i <

mg and OUTSIDE(L; M) = fU(i) : i 62 l; m]g.

Lemma 12. Let be a reversal merging hurdles
L and M in . If both sets BET W EEN(L; M) and OUT SIDE(L; M) are non-empty then is safe.

Proof Let U0 2 BETWEEN(L; M) and U00 2

OUTSIDE(L; M). Lemma 11 implies that deletes

L and M from . There is also a \danger" that

adds a new hurdle K in by transforming K from

a non-hurdle in into a hurdle in . If it is the

case, K does not separate L and M in (otherwise,

absysulemmemthaa1t1LK<wUo0u<ldMbe. deleted from ). W.l.o.g.

If K is a minimal hurdle in then either L K

or M K (otherwise K would be a hurdle in ).

Since K does not separate L

that L K and M K.

bUe0tweenKL,

and M it implies a contradiction to

SatnihndacteMUU00inis minimality

, it implies sandwiched
K. Thus of K in .

If K is the greatest hurdle in then either L; M 6 K

or L; M K (if, otherwise, L 6 K and M K

oitshuets)nsa.i,ndIadefcwLcKio;crhMdienidn6 gbteaotKnwldeemtehUnme0n0La61La1n,<dKKUMw0,o.auTlcdohKbneerte<rdafoedMlrieectt,eUidio.0ne0f.r.loiKmeIsf

L; M K then, since K is a non-hurdle in , K

issneeppaarraaittteessimULp;0lMfierosfmtrhoNamt.aKSnionstechpeearbroahttuhersdNlNe aNannd.dTUUh0 e0\rsienuforvreiv,eK"a

contradiction.

Therefore h( ) = h( ) ? 2. Since b( ) = b( )

and c( ) = c( ) ? 1, the reversal is safe.

2

Lemma 13. If h( ) > 3 then there exists a safe

rPervoerosfal

merging two Order h( )

hurdles hurdles

in of

.

in

the

increasing

order of be the Since h(

rts)hte>iarnr3di,g(hb1tom+thoshst(2etp)s)o-sBtihtEiohTnusWrdaElnedEs Nilnet(LtLh;iMsano)drdaneMrd.

OUTSIDE(L; M) are non-empty and by lemma 12

the reversal merging L and M is safe.

2

LLeemmmmaa91a4n.dI1f 1hi(m)pl=y 2 then there exists a safe

reversal merging two hurdles in . If h( ) = 1 then

there exists a safe reversal cutting the only hurdle in

.

8

Lemmas 13 shows that hurdles merging guarantees a safe reversals even in the absence of simple hurdles. On the negative note, hurdles merging never transforms a superhurdle into a simple hurdle.
Lemma 15. Let be a reversal in merging
two hurdles L and M. Then every superhurdle in (di erent from L and M) remains a superhurdle in
.

6 Fortresses
Lemmas 13 and 14 imply that unless is a homeomorph of the 3-star (a graph with 3 edges incident on the same vertex) there exists a safe reversal in . On the other hand, if has a simple hurdle then lemma 10 implies that there exists a safe reversal in . Therefore, unless is a homeomorph of 3-star with 3 superhurdles, called a 3-fortress, there exists a safe reversal in (Fig. 6a).
Lemma 16. If is a reversal destroying a 3-
fortress (i.e. is not a 3-fortress) then is unsafe.

Proof Every reversal on a permutation can reduce

h( ) by at most 2 and the only operation which can

reduce h( ) by 2 is hurdles merging. On the other

hand, lemma 11 implies that hurdles merging in a

3-fortress can reduce h( ) by at most 1. Therefore,

h ?1. Note that for every reversal which does

not act on edges of the same cycle, (b ? c) = 1 and

therefore every such reversal in a 3-fortress is unsafe.

If acts on a cycle in an unoriented component of a 3-

fortress then it does not reduce the number of hurdles.

Since (b ? c) = 0 for a reversal on an unoriented

cycle, is unsafe. If acts on a cycle in an oriented

component of a 3-fortress then it does not destroy any

unoriented components in and, does not reduce h( ).

If h( ) > h( ) then (b ? c + h) 0 and is unsafe.

If h( ) = h( ) then the number of superhurdles in

and is the same thus implying that is a 3-fortress,

a contradiction.

2

b(

)L?emc( m)a+1h7(.

If )+

1.

is

a

3-fortress

then

d(

)

=

Proof Lemma 16 implies that every sorting of 3-

fortress contains at least one unsafe reversal. There-

fore d( ) b( ) ? c( ) + h( ) + 1.

If has oriented cycles, all oriented components

in can be destroyed by safe paddings (theorem 2)

and safe reversals in oriented components (theorem 3)

without a ecting unoriented components. Therefore

we can assume that is a 3-fortress without oriented

components. If is a 3-fortress without oriented cycles

then an (unsafe) reversal merging arbitrary hurdles

in leads to a permutation with two hurdles

(lemma 11). Once again, oriented cycles appearing

in after such merging can be destroyed by safe

paddings and safe reversals in oriented components

(theorems 2 and 3) leading to a permutation with

h( ) = 2. Theorems 2, 3 and lemma 14 imply that

Hannenhalli and Pevzner

can be sorted by safe paddings and safe reversals.

Hence, there exists a generalized sorting of such that

all paddings and all reversals but one in this sorting

are safe. Therefore this generalized sorting contains

b( ) ? c( ) + h( ) + 1 reversals. Lemma 5 implies

that the generalized sorting of mimics an optimal

(genuine) sorting of by d( ) = b( )?c( )+h( )+1

reversals.

2

In the following we try to avoid creating 3-

fortresses in the course of sorting by reversals. If

we are successful in this task can be sorted in

b( ) ? c( ) + h( ) reversals. Otherwise we show how

to sort in b( ) ? c( ) + h( ) + 1 reversals and prove

that such permutations can not be sorted with fewer

number of reversals. Permutation is called a fortress

if it has an odd number of hurdles and all these hurdles

are superhurdles.

Lemma 18. If is a reversal destroying a

fortress with h( )-superhurdles (i.e. is not a

fortress with h( ) superhurdles) then either is un-

safe or is a fortress with h( ) ? 2 superhurdles.

Proof Arguments similar to the proof of lemma 16

demonstrate that if does not merge hurdles then is

unsafe. If a safe reversal does merge (super)hurdles

L and M in then lemma 11 implies that every such

reversal reduces the number of hurdles by 2, and in

the case h( ) > 3, does not create new hurdles. Thus

lemma 15 implies that is a fortress with h( ) ? 2

superhurdles.

2

Lemma 19. If is a fortress then d( ) b( ) ?

cP(ro)o+f

h( ) + 1. Lemma

18

implies

that

every

sorting

of

either contains an unsafe reversal or gradually de-

creases the number of superhurdles in by transform-

ing a fortress with h (super)hurdles into a fortress with

h ? 2 (super)hurdles. Therefore, if sorting of uses

only safe reversals then it will eventually lead to a 3-

fortress. Therefore, by lemma 16 every sorting of a

fortress contains at least one unsafe reversal and hence

d( ) b( ) ? c( ) + h( ) + 1.

2

Theorem 4. For every permutation ,

d( ) =

b( ) ? c( ) + h( ) + 1; b( ) ? c( ) + h( );

if is a fortress otherwise

Proof If has an even number of hurdles then

safe paddings (theorems 2), safe reversals in oriented

components (theorem 3) and safe hurdles mergings

(lemmas by b(

)13?acn(d)1+4)hl(ea)d

to a generalized sorting of reversals. If has an odd

number of hurdles at least one of which is simple then

there exists a safe hurdle cutting (lemma 10) leading

to a permutation with an even number of hurdles.

Therefore, similar to the previous case, there exists a

bg(en)er?alciz(ed)

sorting + h( )

of safe

using only safe paddings and reversals. Thus, if is not a

fortress, there exists a generalized sorting of using

Transforming Cabbage into Turnip

only safe paddings and b( ) ? c( ) + h( ) reversals.

Theorem 1 and lemma 5 imply that this generalized

sorting mimics optimal (genuine) sorting of . If

is a fortress there exists a sequence of safe paddings

(theorems 2), safe reversals in oriented components

(theorem 3) and safe hurdles mergings (lemma 13)

leading to a 3-fortress. This 3-fortress can be sorted by

a series of reversals having at most one unsafe reversal.

Tb(he)r?efco(re)+thhe(re

exists a generalized sorting of )+1 reversals. Lemmas 5 and 19

using imply

tshorattinthgisofgenberyabli(ze)d?socr(tin)g+mhi(mi)c+s o1ptriemvearls(aglse.nuin2e)

7 Polynomial algorithm

Theorem 4 motivates the algorithm Reversal Sort
nowfhiRnicehOv(eonrps4t)aimltiSamloleyr.t.sWoNretosstkeaettschihgantaenedvOepr(yenrm4it)euirtmaattpiioloennmooefnfwtoahrtdiioleenr
loop reduces the function complexity( ) + 3d( ) by at least 1 thus implying that the number of iterations of Reversal Sort is bounded by 4n. The most \expensive" iteration is a search for a safe reversal in an soeraiernchtedcacnobmepiomnpelnetm. eFnotredainsimOp(nle3)pteirmmeu,ttahtuiosni,mspulcyhiOn(gnt4h).at the overall running time of Reversal Sort is

Algorithm Reversal Sort( )

12..

whiilfe

is not sorted has a long cycle

43..

elseseiflecthaassaafne

(g; b)-padding of oriented component

(theorem

2)

5. select a safe reversal in this component

(theorem 3)

6. else if has an even number of hurdles

7. select a safe reversal merging two hurdles in

98..

else(leifmmhaa1s3aatnleda1st4)one simple hurdle
select a safe reversal cutting this hurdle in

(lemmas 10 and 14)

1101..

else if is a fortress with more than 3 superhurdles
select a safe reversal merging two

12. else(sup=er)hurisdlaes3i-nfortr(elesms m=a 13)

13. select an (un)safe reversal merging two

arbitrary (super)hurdles in

14.

15. endwhile

16. mimic (genuine) sorting of using the computed

generalized sorting of (lemma 5)

We omit an amortized analysis of Reversal Sort

leading to further reduction of running time. Instead,

we describe a simpler does not use paddings

vaenrdsiorunnosfiRn eOv(enrs5)altiSmoer.t

which De ne

f( ) =

1; 0;

if is a fortress otherwise

.

A reversal

is

valid, if (b ? c + h + f) = ?1. Proofs of theorem 1

and lemma 19 imply that (b ? c + h + f) ?1.

This inequality and theorem 4 imply that (i) for every

permutation there exists a valid reversal in and (ii)

9

every sequence of valid reversals sorting is optimal. These observations motivate Reversal Sort Simple which is very fast in practice.

4312....

AlgoritwhmhilReeveirssnalotSsoorrttSedimple( )
select a valid reversal
endwhile

in

Reversal Sort Simple was implemented and tested on biological data. The results of these tests are described in Hannenhalli and Pevzner, 1994, in particular, we found optimal evolutionary scenarios for extensively rearranged genomes which were considered as \too-hard-to-analyze" in the previous studies. Experiments with Reversal Sort Simple on simulated data explained the mystery of astonishing performance of previously suggested approximation algorithms for sorting signed permutations by reversals. A simple explanation for this performance is that the bound (2) is extremely tight since h( ) is small for \random" permutations and zero for most of the biological data.

8 Acknowledgments
We are indebted to Vineet Bafna, Piotr Berman, Webb Miller and Anatoly Rubinov for many helpful discussions and suggestions. We are also grateful to Eric Boudreau and Monique Turmel for sending us unpublished experimental data on gene orders of Chlamydomonas gelatinosa and Chlamydomonas reinhardtii for testing Reversal Sort Simple.

References

1] M. Aigner and D. B. West. Sorting by insertion of

2]

4le5a:d3i0n6g{3e0le9m, 1e9n8t7. . V. Bafna and P.

Journal Pevzner.

of Combinatorial Theory, Genome rearrangements

Fanodunsdoarttiionngs boyf rCevoemrspaultse.r ISnci3en4tche,IEpaEgEesS1y4m8p{.15o7n,

1993. (to appear in SIAM J. Computing).

3] V. Bafna and P. Pevzner. Sorting by reversals:

GlEuvetoinolo.n,ma1re2y:r2eh3ai9srt{roa2rn4yg6e,om1f9eX9n5tsc.hirnomploasnotmoer.gaMneollle.sBainodl. eavnod-

4] 5]

DVDIn..isCBPcroraeohftncee.anAoaaflnngd6dotrMhPit.h.APmBneslnvu,uzmpnaa.elgrIAe.msCSp6Mor1ro4-tvS{ine6IdgA23bMb,oy1uSt9nry9dam5snbpsf.poorosissuiotmriotinonsng.

pancakes under a conjecture. 1993 (manuscript).

6] S. Even and O. Goldreich. The minimum-length

Agelngoerraitthomr ss,e2q:u3e1n1c{e31p3r,ob1l9e8m1. is NP-hard. Journal of

7] W. H. Gates and C. H. Papadimitriou. Bounds for

8]

s2o7r:t4i7n{g57b,y19p7r9e. S. Hannenhalli.

x reversals. Discrete Mathematics, Polynomial algorithm for computing

6trtahnAslnonca.tSioynmpd.isotnanCceombbetinwaeteonrigaelnPoamtteesr.nInMPatrcohci.nogf,

1995. (to appear).

9] S. Hannenhalli, C. Chappey, E. Koonin, and

3PHr.edrPpIenevstzvl.nirCeuros.nefSevrcoeelnunctaeiroionons aBfsoiroaigntefenosortmmcaeatsirece.sararnIandngCPeormomcep.nlteosx:f

Genome Analysis, 1994 (to appear).

10

10] S. Hannenhalli and P. Pevzner. Reversals do not

cTDuhetpealProtenmngnesnsyttlrvioapfns.iCaoSmTtpaetcuehtenUricnaSilvceieRrnseictpeyo,ra1tn9:d94EC. nSgEin-9e4e-r0in7g4,,

11] M. Heydari and I. H. Sudborough. On sorting

bnyetwporreksx. 1r9e9v3er(smalsanuanscdriptth)e. diameter of pancake

12] M. Jerrum. The complexity of nding minimum-

Slecnigetnhceg, e3n6e:2ra6t5o{r28s9e,q1u9e8n5c.es. Theoretical Computer

13] pAJto.anrgKyneuesocaf4elr7ceAi1oc{Cog4mlMu8b0-a,iSnn1IadA9t9iMDo4n..sSGyfurmospme.lado.nseRtDeoicfsocsnreesqttuereunAcctleignsog.riIatnhhm5itssh-,

14] 15]

ttoJJiin..ooKnnKD.aeeircIcsyenceccrdPieioiotrsgegotllacuuA.nalcoganefonsdr6dibtRthheD.tmAw.RsneSa,nevapnuina.akgglOoeeAsnf .Com6mM0iE4ce-e{xsS6aaIu1cAnn3tdMd, ae1mnr9Sde9ytn5rma:a.ppnEopsvlsrooioculxuami---

tCCmwooaommtiopbpnieunrtaameltrguootrSraiciattiliehonmPncsaes.tft6oe8Irrn4nt,hPMperaoaignctev.csehori8fsn7igo4{,nt1h0Ld5eAi.sctntSaunpnr.rceieSnNygbmeoerttpwe.Vseeoeirnnn-

lag, 1993. (Extended version has appeared in Algo-

rithmica, 13: 180-210, 1995.).

16] J. Kececioglu and D. Sanko . E cient bounds for

5oL3r2tehi5ce.tnAutSnrepednr.iNncShgoyretmoermspV.ionesoronlCamgoCe,mo1impn9uv9bet4ienr.sraiotSoncriiedanilscPteaan8tc0tee7r.,nIpnMagPaetrscoh3ci.0n7og{f,

17] C. A. Makaro and J. D. Palmer. Mitochondrial

DiunlNatrhAeCrmeelalaurlrelaasrntgeBeriimoleleocngytyst,oa8pn:l1ad4s7mt4ra{on1f4sOc8r0gi,putr1ia9o8nr8aa.dl iashlt.erMatoiolencs-

18] 19]

1JJsao9n..m8dDH4a..m.lPNosauaeldsgmeme.eareuPnartanosndcd.cLoNBn.a.sAteAl.r.v.HAeTedcraabydsoli.onnrSc..ecPiL.dleaUinvnSegtrtAgmh,esin8toco1fec:8hc1oho4fnr{odm8mr1iaao8nl-,

20]

D1Pse9.NqA8u8A.e.Pnecevev.ozlnvJeeorsuarrnnaadpliMdofly.SM.ionWlecasutterlaurmrctEaunvr.eo,luOtbipuoentn,

s2l7o:w8l7y{9i7n, combina-

aPItnonrredi3saSsrl,dyps1rtI9eos9mrb5al.see,mlpsSaygimnespc1oo5sm8iu{pm1u6t3ao.tniIoEnTEahEleomCroyolmeocpfuulCaterormbSipoouclotieigntyyg.

21] D. Sanko . Edit distance for genome comparison

bAL13aen5scne.td.uSrpSeoryniNmngopnet.eorsnoV-inlneorclCCaagloo,mmo1pbp9uie9ntr2aea.rttoioSrnicaisel.nPceaItn6t4e4rPn,rpoMca.gaetoscfh1i23n1rgd{,

22] D. Sanko , R. Cedergren, and Y. Abel. Genomic di-

EvPAevrcreoigdslesuSn,tcei1oqe9nu9t:e0hnC.rcooeumsg,phcuhgtaeeprnteeArnr2ea6al,yrrspaiasngogefesmP4r2eon8tt{e.4in3I8na.nAMdcoNaleducecumlelaiiccr

23] D. Sanko , G. Leduc, N. Antoine, B. Paquin, B. F.

d6Lp5rhai7yna9lglo,,gg1aee9nnn9deo2tm.Rice..CinPefedrroeecrn.gcrNee:na.tlE.GvAeoncluaetdoi.orndSecroi.fcUotmhSeApa,mr8iist9oo:6nc5hs7of5no{r-

24] Atp4hh5si.see0tuH,otdr1.hoy9iSo3robtd6fus.crtcuthherevraoas,mpnateoncsaidoensmd.thePTerio.roDfco.uwbsNiezladhtian.nrAastkccheyaes.d.osIStfnucvidde.yr,ros2is2ooo:fnp4sh4tih8iln{ea

25] G. A. Watterson, W. J. Ewens, T. E. Hall, and

AJo.urMnoarlgoafnT. heTorheeticcahlrBomioolosgoym,e99i:n1v{e7r,s1io9n82p. roblem.

Hannenhalli and Pevzner

Transforming Cabbage into Turnip

B. oleracea (cabbage)

1 -5 4 -3 2 1 -5 4 -3 -2

1 -5 -4 -3 -2

B. campestris (turnip)

12345

Figure 1: \Transformation" of cabbage into turnip

3 5 8 6 4 7 9 2 1 10 11
3 5 4 6 8 7 9 2 1 10 11
3 4 5 6 8 7 9 2 1 10 11
(a)
3 4 5 6 7 8 9 2 1 10 11
9 8 7 6 5 4 3 2 1 10 11
1 2 3 4 5 6 7 8 9 10 11
black edge gray edge

11

(b)
0 3 5 8 6 4 7 9 2 1 10 11 12
A

(c)
0

B

56
+3

10 9
-5

15 16 12 11
+8 -6

C
78
+4

D
14 13 17 18
-7 +9

34
+2

EF

12
+1

19 20 22 21 23
+10 -11

B
(d)

F D AE
C
non-oriented cycle oriented cycle

Figure 2: (a) Optimal sorting of a permutation = (3 5 8 6 4 7 9 2 1 10 11) by 5 reversals (b) Breakpoint

graph G( ) can be decomposed into three short cycles ( (8; 9; 7; 6; 8), (8; 5; 4; 7; 8) and (3; 5; 6; 4; 3)) and one long

cycle (0; 1; 10; 9; 2; 3;0) thus implying that c( ) = 4. (c) Transformation of a signed permutation into an unsigned

permutation and the breakpoint graph G( ). Gray edges (8; 9) and (22; 23) are oriented while gray edges (4; 5)

and ii

?(1k8;=19j)

?arle).unCoyrcielensteCd

(note that and F are

a gray edge ( oriented while

ic;ycjl)esinAc;idBe;nDt taonbdlaEckaerdeguenso(riekn; teid).aGndra(y

je;dgle)sis(6o;r7ie)natnedd

(12; 13) are interleaving while gray edges (6; 7) and (4; 5) are non-interleaving. (d) Interleaving graph H with

two oriented and one unoriented component.

12 Hannenhalli and Pevzner

U

(a)
0

U

9 10 +5

13 14 +7

11 12 +6

15 16 +8

12 +1

U

56 +3

34 +2

78 +4

17

U

(b)
0

34 2

U

78 +4

56 +3

U

9 10 +5

13 14 +7

11 12 +6

15 16 +8

12 +1

17

Figure 3: Permutation component U separates

hinur(dal)eshUas0

a2nmd iUni00m. aPlearmndutnaotiognreiante(sbt)

hhuarsd2lem(ihn(im)a=l (U20)

since and U

0t0h) eangdre1atgersetatuensotrhieunrtdelde

U (h( ) = 3).

U "artificial" greatest element U "real" greatest element

(a) K
L

P N

M

0 45 46 43 44 1 2 7 8 13 14 11 12 9 10 15 16 5 6 3 4 17 18 23 24 29 30 27 28 25 26 31 32 37 38 35 36 33 34 39 40 21 22 19 20 41 42 47
merging hurdles L and M
U "artificial" greatest element U "real" greatest element

(b)

N

0 45 46 43 44 1 2 7 8 13 14 11 12 9 10 32 31 26 25 28 27 30 29 24 23 18 17 4 3 6 5 16 15 37 38 35 36 33 34 39 40 21 22 19 20 41 42 47
Figure 4: (a) A cover graph of a permutation with \real" unoriented components K; L; M; N; P; U and an \arti cial" component U; (b) A reversal merging hurdles L and M in transforms unoriented components L; K; P and M into an oriented component which \disappears from . This reversal transforms unoriented cycles (32; 33; 36; 37; 32) and (10; 11; 14; 15; 10) in into an oriented cycle (15; 14; 11; 10; 32; 33; 36; 37; 15) in . LCA(L; M) = LCA(L; M) = U and PATH(A; F) = fL; K; U; P; Mg. Components M, N and U are simple hurdles while component L is a superhurdle (deleting L transforms a non-hurdle K into a hurdle).

g

C C1 C2

b (g,b)-split

wg wb vb vg

wg

wb w v

vb vg

Figure 5: A (g; b)-split transforming a cycle C in G( ) into cycles C1 and C2 in G^( ).

Transforming Cabbage into Turnip

13

U "artificial" greatest element U superhurdle
(a)

L
superhurdle

M
superhurdle U "artificial" greatest element U simple hurdle

(b)

LM

superhurdle

superhurdle

Figure 6: Permutation in (a) is a 3-fortress while permutation in (b) with the same cover graph is not a fortress.

