Principal Typings for Java-like Languages∗

Davide Ancona
DISI - Universita` di Genova Via Dodecaneso, 35 16146 Genova, Italy
davide@disi.unige.it

Elena Zucca
DISI - Universita` di Genova Via Dodecaneso, 35 16146 Genova, Italy
zucca@disi.unige.it

Abstract
The contribution of the paper is twofold. First, we deﬁne a general notion of type system equipped with an entailment relation between type environments; this generalisation serves as a pattern for instantiating type systems able to support separate compilation and interchecking of Java-like languages, and allows a formal deﬁnition of soundess and completeness of inter-checking w.r.t. global compilation. These properties are important in practice since they allow selective recompilation. In particular, we show that they are guaranteed when the type system has principal typings and provides sound and complete entailment relation between type environments.
The second contribution is more speciﬁc, and is an instantiation of the notion of type system previously deﬁned for Featherweight Java with method overloading and ﬁeld hiding. The aim is to show that it is possible to deﬁne type systems for Java-like languages, which, in contrast to those used by standard compilers, have principal typings, hence can be used as a basis for selective recompilation.
Categories and Subject Descriptors: D.3.3[Programming languages]: Language constructs and features–classes and objects; D.3.1[Programming languages]: Formal deﬁnitions and theory–syntax, semantics; D.3.4[Programming languages]: Processors–incremental compilers
General Terms: languages, theory, design
Keywords: principal typings, selective recompilation, Java-like languages
∗Partially supported by Dynamic Assembly, Reconﬁguration and Type-checking - EC project IST-2001-33477, APPSEM II - Thematic network IST-2001-38957, and Murst NAPOLI - Network Aware Programming: Oggetti, Linguaggi, Implementazioni.
Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for proﬁt or commercial advantage and that copies bear this notice and the full citation on the ﬁrst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a fee. POPL’04, January 14–16, 2004, Venice, Italy. Copyright 2004 ACM 1-58113-729-X/04/0001 ...$5.00

1 Introduction
The fact that separate compilation is a highly desirable property is a generally accepted principle. However, as pointed out in the seminal Cardelli’s paper [4], even though module mechanisms have received considerable theoretical attention, the notion of separate compilation and the associated notion of linking have not been emphasized, and there is little work on formal models for them; as a consequence, despite of the popularity of the word, it is often difﬁcult to establish in a precise way whether a programming environment actually supports separate compilation or not.
The mentioned paper [4] can be considered a milestone in this direction and is based on the deﬁnition of a simple formal framework where separate compilation, which is there simpliﬁed to typechecking, is modeled by a judgment Γ ⊢ s : τ. The intended meaning is that s is a source fragment assumed to be open, that is, to contain references to names deﬁned in other fragments, τ is the resulting type, and Γ is a type environment intuitively containing all the assumptions on other fragments needed to typecheck s. In this paper we are also interested in code generation, since, as we will show later, in Java-like languages different bytecode is produced under different assumptions in Γ; hence, we model separate compilation by a judgment Γ ⊢s:τ b where b is the binary fragment generated by the compilation of s.
A source fragment is a compilation unit, and exports one or more names to other fragments. For instance, in the case of Java-like languages, the most elementary (non-empty) compilation unit corresponds just to a class declaration, but several class declarations can be part of the same compilation unit as well, as happens for all Java systems. Hence, in general, s will be a sequence of declarations (e.g., class declarations in Java) and τ a sequence of types for the declared class names.
At this point, given a collection of successfully compiled fragments, it is possible to test whether they successfully inter-check, that is, the mutual assumptions between fragments are satisﬁed. Formally, we have a linkset Γi ⊢si:τi bii∈1..n and we have to check that, for each i ∈ 1..n, assumptions Γi required by si are matched by other fragments1, in a sense to be made precise depending on the nature of the type assumptions.
For instance, in the simple case in which a type environment is just
1Here we simplify the presentation by considering only selfcontained linksets; in the following, linksets will be possibly open, that is, they will also include a type environment containing assumptions on the external fragments.

a sequence of pairs c : τ meaning that the entity (e.g., class) named c should have type τ, inter-checking just amounts to check that, for each i, j ∈ 1..n, if c : τ appears in Γ j, then τ must be the same type c has in τi (as it is in [4]). However, a type environment could in general contain other kinds of type assumptions, such as subtyping assumptions c1 ≤ c2 or others depending on the language we are considering. Hence, we need a deﬁnition of inter-checking which abstracts from the particular form of type assumptions.
In this paper we provide such a deﬁnition (Deﬁnition 8), based on the idea that an effective inter-checking procedure can be modeled by an entailment relation ⊢ on type environments, so that interchecking succeeds if c1 : τ1, . . . cm : τm ⊢ Γi holds for all i ∈ 1..n, where c1, . . . , cm are all the classes declared in the linkset and, for all j ∈ 1..m, τ j is the type derived for c j in the linkset. Intuitively, this means that it is possible to prove all the required type assumptions whenever fragment types are those in the linkset.
The advantages of separate compilation plus inter-checking w.r.t. global compilation of s1, . . . , sn altogether are clear. Each fragment can be compiled without inspecting the fragments it depends on; then, a collection of fragments can be put together to form an executable application by just considering the type information (type environment and type) of fragments, without any need of reinspecting code. However, in order to really offer these advantages, inter-checking should satisfy some properties which ensure that it can actually replace global compilation. This issue was not considered in [4] and its formalization in the abstract framework for inter-checking described above is the ﬁrst main contribution of this paper.
Of course, inter-checking should at least be sound w.r.t. global compilation, in the sense that, if for some linkset Γi ⊢si:τi bii∈1..n inter-checking succeeds, then we can be sure that compiling altogether s1, . . . , sn we successfully get the same binary fragments. This is a minimal property which we expect to be always satisﬁed by separate compilation (Deﬁnition 10), and which is guaranteed under the hypothesis that the entailment relation is sound (Theorem 11).
Consider now the situation in which inter-checking fails. This means that there is some type assumption in some Γi which is not satisﬁed by the types of other fragments. However, this does not necessarily mean that the fragments cannot be safely linked. Indeed, in general for each pair (s, b), many judgments Γ ⊢s:τ b can be derived, and for some fragment we could have taken a too restrictive type environment (that is, containing unnecessary type assumptions).
We can be sure that this is not the case only if the typing (Γ, τ) gives all the type information about (s, b), that is, represents all possible typings of (s, b); in other words, Γ contains only the type assumptions that are strictly needed for compiling s generating b. This property can be expressed by saying that (Γ, τ) is a principal typing of (s, b), and has been recently formalized in a general setting (that is, independent of the particular type system we are considering) in [14]. If (Γ1, τ1), . . . , (Γn, τn) are principal typings for (s1, b1), . . . , (sn, bn), respectively, then we can be sure that no further type information about fragments can be obtained by re-inspecting the code, hence failure of inter-checking was not due to our particular choice of typings. Hence, we can conclude that global compilation would either fail as well, or would produce different binary fragments.
We will call completeness of inter-checking w.r.t. global compila-

tion the fact that, with a suitable choice of typings in linksets, failure of inter-checking guarantees that we could not generate the binary fragments in the linkset by global compilation (Deﬁnition 12). We show that a sufﬁcient condition for this is that the type system supports principal typings and complete environment entailment relation (Theorem 14).
The second contribution of this paper is more speciﬁc, and is an instantiation of the notion of type system previously deﬁned for Featherweight Java [8] enriched by overloading and hiding. The aim is to show that it is possible to deﬁne type systems for Java-like languages, which, in contrast to those used by standard compilers, have principal typings, hence can be used as a basis for selective recompilation.
We brieﬂy explain the essence of the problem of ﬁnding principal typings for Java-like languages on a simple example (more extended discussions and other examples can be found in [3, 2]).
Consider the following class:
class C extends Parent { ...
Type1 m (Type2 x) { return new Used().g(x);} }
Let us wonder which is the minimal type information on other classes needed for typechecking the class and generating the corresponding bytecode.
For classes Type1 and Type2, since they are just used as pure types, it is enough to assume that they exist (we will model this in our type system by type assumptions ∃ Type1, ∃ Type2).
Looking at the method call, we can say that the class C can be typechecked in any type environment where a class Used is available which provides, besides the default constructor, a method (either directly declared or inherited) with name g and one parameter of a supertype of Type2; moreover we have the constraint that its return type must be a subtype of Type1. For instance, class C can be typechecked in the following context (1):
class Parent{} class Type1{} class Type2 extends Type1{} class Type3 extends Type2{} class UsedParent { Type3 g(Type1 x) { ...}} class Used extends UsedParent {}
and also in this context (2):
class Parent{} class Type1{} class Type2 extends Type1{} class Used {
Type2 g(Type2 x) {...} int f() {...} }
Hence, we would be tempted to express this by a type assumption expressing that class Used must have a method g with one parameter of a supertype of Type2 and return type subtype of Type1. However, in order to produce the corresponding bytecode, a Java compiler must know exactly which are the parameter and return type of the method which will be selected, since they appear as annotations in bytecode (see Section 3 for more details). In the example, C can be typechecked, e.g., in a type environment Γ1 where the method g

selected for method invocations with receiver type Used and argument type Type2 has return type Type3, and parameter type Type1, as in environment (1); this constraint is formalized by the judgment Γ1 ⊢ Used.g(Type2) m-→res (Type1, Type3).
As well, C can be typechecked in a type environment Γ2 where the selected method has return and parameter type Type2, as in environment (2); this constraint is formalized by the judgment Γ2 ⊢ Used.g(Type2) m-→res (Type2, Type2).
The example clearly shows that, in order to get a principal typing property (in particular, a “minimal” type environment), we must type pairs consisting of a source and a binary fragment.
The rest of the paper is organized as follows: in Section 2 we deﬁne the formal notions of type system for separate compilation and inter-checking and soundness and completeness of inter-checking. In Section 3 we deﬁne an instantiation of the notion of type system deﬁned in the previous section for Featherweight Java [8] with method overloading and ﬁeld hiding. In Section 4 we prove that this type system satisﬁes the hypotheses which guarantee soundness and completeness of inter-checking. We also prove that it has principal typings and that the environment entailment is complete. Finally in the Conclusion we summarize the contribution of the paper and draw some direction for further work.
2 Type systems for separate compilation
In this section we deﬁne a general notion of type system for separate compilation.
The main motivation is reuse: this general notion of type system serves as a pattern to be instantiated by a “real” type system where all deﬁnitions and details which have been intentionally omitted here are provided (including, e.g., the syntax of terms and types, and the typing rules for judgments). However, each correct instantiation (as we will see, there are some basic properties expected to hold) is guaranteed to support well selective recompilation [1]. We will denote by T a generic instantiation of our general notion of type system.
Even though in this paper we deﬁne just one instantiation (for Featherweight Java [8] enriched by overloading and hiding, see Section 3), we expect our general notion of type system to be useful for a number of other possible instantiations including both more signiﬁcant subsets of Java and C# and toy languages deﬁned for studying the interaction of Java or C# with advanced features like, for instance, generic types that will be soon included in Java and have been formally studied with GJ [8].
2.1 Basic notions
We start by listing the basic syntax categories and typing judgments that are expected to be deﬁned by every instantiation.
Basic syntax categories
Each instantiation should at least deﬁne the following sets (metavariables used for the elements of such sets are shown in parentheses):
• Class names (c).
• (Sequences of) source class declarations (s).

• (Sequences of) binary class declarations (b). • (Sequences of) class types (τ). • Type assumptions (γ). They always include the type assump-
tions of the form c:τ which are called standard. • Type environments (Γ). An environment is just a possibly
empty sequence of type assumptions γ1, . . . , γn.
We assume that each (source/binary) class declaration introduces a class name c that can be extracted by a function name mapping a sequence of source or binary class declarations to the sequence of their corresponding names. As already explained in the Introduction, binaries are needed for modeling the situation where some source class modiﬁcation can change the binary generated from other source classes.
Notation for sequences
We denote by |σ| the length of a sequence σ, by σ1, σ2 the concatenation of the two sequences σ1 and σ2. A sequence is written either e1, . . . , en or eii∈1..n; however, the ﬁrst notation is only used when there is no ambiguity with concatenation.
Basic judgments
Each instantiation should at least deﬁne the following two judgments:
• Γ ⊢s:τ b: source class declarations s compile to b and have type τ in Γ. We assume that if Γ ⊢s:τ b is valid, then |s| = |τ| = |b| = n, name(s) = name(b) = c1, . . . , cn, with ci = c j for all i, j ∈ 1..n, i = j. Note that for Java-like languages the information about the inferred type τ is, in a sense, redundant, since it does not depend on Γ, but it is a function of just the source s; nevertheless, we have preferred to leave this information in the judgment for readability.
• Γ1 ⊢ Γ2: Γ1 entails Γ2, that is, Γ1 enforces stronger type requirements than those of Γ2.
Intuitively, the notion of entailment should correspond to a computable relation (at least) sound w.r.t. the notion of stronger environment (see Deﬁnition 4 in Section 2.2).
A basic expected property of the compilation judgment is compositionality.
Let the expression env(s:τ) denote the type environment: c1:τ1, . . . , cn:τn if name(s) = cii∈1..n, τ = τii∈1..n and s does not contain class name conﬂicts (that is, ci = c j implies i = j, for all i, j ∈ 1..n) otherwise, it is undeﬁned2.
Def. 1 (COMPOSITIONALITY). We say that T is compositional iff for all Γ, s = s1, . . . , sn, τ = τ1, . . . , τn, b = b1, . . . , bn: Γ ⊢s:τ b ⇔ Γ, env(s:τ) ⊢si:τi bi, for all i ∈ 1..n.
2.2 Principal typings
The system independent deﬁnition of principal typing given by Wells [14] ﬁts well our general notion of type system. We recall
2Hence a judgment of the form Γ, env(s:τ) ⊢ . . . is valid if and only if env(s:τ) is deﬁned and denotes a type environment Γ′ s.t. Γ, Γ′ ⊢ . . . is valid.

here the basic notions and notations on principal typings inspired by Wells and adapted to our purposes.
Def. 2 (TYPING). If Γ ⊢s:τ b holds, then we say that the pair (Γ, τ) is a typing of (s, b). We say that (s, b) is typable iff it has a typing.
Note that we could have adopted Well’s deﬁnition of typing by considering binary sequences as part of the type so that (Γ, (τ, b)) is a typing of s if Γ ⊢s:τ b holds. However, this deﬁnition would lead to a rather strong deﬁnition of principal typing for Java-like languages that, in fact, would not be satisﬁed by any system adopting the usual notion of bytecode (see the Conclusion).
Def. 3 (CONSISTENT ENVIRONMENT). An environment is consistent iff there exist s, τ, and b s.t. Γ ⊢s:τ b.
Def. 4 (STRONGER ENVIRONMENT). An environment Γ1 is stronger than Γ2 (written Γ1 ≤ Γ2) iff Γ2 is consistent and for all s, τ, and b, if Γ2 ⊢s:τ b holds, then Γ1 ⊢s:τ b holds as well.
Note that the relation of Deﬁnition 4 is a pre-order, but, in general, is not a partial order.
Def. 5 (STRONGER TYPING). A typing (Γ1, τ1) is stronger than (Γ2, τ2) (written (Γ1, τ1) ≤ (Γ2, τ2)) iff Γ2 ≤ Γ1 and τ1 = τ2.
The deﬁnition of stronger typing given here differs from Well’s definition in two respects:
• Well’s deﬁnition does not require that if (Γ1, τ1) is stronger than (Γ2, τ2), then Γ2 is stronger than Γ1 and τ1 equals τ2. However, this stronger property clearly holds in the setting of Java-like languages where the type of a class is uniquely determined by the annotations contained in its body. Under this property, the notion of stronger typing can be simply captured by the notion of entailment between environments (see Theorem 14).
• In Well’s deﬁnition there is no notion of consistent type/environment. However, if non-consistent types and environments were not ruled out from Deﬁnition 4, then some expected completeness property would not hold, like, for instance, Γ1 ≤ Γ2 ⇒ Γ1 ⊢ Γ2; indeed, we may not want a system where Γ1 ⊢ Γ2 is provable for any Γ2, just because Γ1 is not consistent. On the other hand, we would like to consider concatenation of environments as a total function, therefore non-consistent environments cannot simply ruled out from all deﬁnitions.
Def. 6 (PRINCIPAL TYPING). A principal typing of (s, τ) is a typing of (s, τ) which is stronger than all typings of (s, τ). We say that T has principal typings iff all typable (s, b) have a principal typing.
Finally, the deﬁnition of principal typing given here is strictly stronger than Well’s deﬁnition; indeed, our deﬁnition could be regarded as a reﬁnement of Well’s principality suitable for type systems in the Church style (that is, with explicitly typed terms).
2.3 Linksets
Selective recompilation tries to minimize compilation steps after changes to a certain software conﬁguration. Software conﬁgurations can be modeled by the notion of linkset, which was ﬁrstly introduced by Cardelli [4].

Def. 7 (LINKSET). A linkset is a pair, written
Γ| Γi ⊢si:τi bii∈1..n
consisting of a type environment and a (possibly empty) sequence of valid compilation judgments s.t. s = s1, . . . , sn does not contain class name conﬂicts.
Intuitively, the environment Γ contains the type assumptions on the external classes (that is, not deﬁned in the linkset), whereas for all i ∈ 1..n the judgment Γi ⊢si:τi bi corresponds to the successful compilation of a single compilation unit si to bi in the type environment Γi.
Since here the emphasis is on inter-checking, the deﬁnition of linksets assumes that the compilation judgments are valid, hence our linksets correspond to intra-checked Cardelli’s linksets [4]. Moreover, in [4] type environments are just sequences of standard type assumptions c : τ, and class names in Γ need to be different from those in each Γi. Indeed, typechecking of a single fragment si is performed in the type environment Γ, Γi containing type assumptions on external classes and classes in the linkset, respectively. In our notion of linkset, instead, type environments contain arbitrary type assumptions, each one possibly involving more than one class, and typechecking of si is performed in the type environment Γi which contains type assumptions on both external classes and classes in the linkset. Thus, Γ, Γi can contain redundant assumptions, even though intuitively the best situation occurs when Γi contains exactly the minimal type assumptions on other classes needed to compile si and Γ contains exactly the minimal type assumptions on external classes needed to compile all si.
Finally, judgments are not named as in Cardelli’s linksets, since the type environment exported by any compilation unit Γ ⊢s:τ b is simply obtained via the name function.
The deﬁnition of inter-checking is a generalization of that given by Cardelli.
Def. 8 (LINKSET INTER-CHECKING). Let
L = Γ| Γi ⊢si:τi bii∈1..n
be a linkset and set s = s1, . . . , sn, τ = τ1, . . . , τn. We say that L inter-checks (written ⊢ L⋄) iff Γ, env(s:τ)⊢Γi holds for all i ∈ 1..n.
2.4 Sound and complete inter-checking
As already explained, the inter-checking procedure allows separate compilation of the units which need to be assembled in the linkset, and prevents code inspection and recompilation, since the overall consistency of the linkset is checked via the entailment relation on environments which completely relies on unit interfaces. On the other hand, one could always adopt a “brute force” algorithm by (re)compiling all units as a whole. We model global (re)-compilation by a judgment Γ⊢s1, . . . , sn G b1, . . . , bn, expressing that source fragments s1, . . . , sn are compiled altogether, generating binary fragments b1, . . . , bn in the type environment Γ (see Def. 9).
Def. 9 (GLOBAL COMPILATION). For all Γ, s, b, the judgment Γ⊢s G b is valid iff Γ ⊢s:τ b can be proved for some τ.
Of course we expect separate compilation plus inter-checking to produce the same binaries as we would have got from global com-

pilation; if so, we say that inter-checking is sound w.r.t. global compilation.
Def. 10 (SOUND INTER-CHECKING). Inter-checking is sound w.r.t. global compilation iff for all linksets L = Γ| Γi ⊢si:τi bii∈1..n if ⊢ L⋄ then Γ⊢s1, . . . , sn G b1, . . . , bn.
Soundness of inter-checking is guaranteed under some reasonable conditions: the type system should be compositional, and the entailment judgment should be sound with respect to the relation of stronger environment.
Theorem 11 (SOUNDNESS OF INTER-CHECKING). Let T be a compositional type system satisfying the following additional property :
(∗) Γ1 ⊢ Γ2 ⇒ Γ1 ≤ Γ2 for all Γ1, Γ2 (entailment is sound).
Then, inter-checking is sound w.r.t. global compilation.
PROOF. Let L be Γ| Γi ⊢si:τi bii∈1..n be a linkset s.t. ⊢ L⋄ holds and set s = s1, . . . , sn, τ = τ1, . . . , τn. Then, by Deﬁnition 8, Γ, env(s:τ) ⊢ Γi holds for all i ∈ 1..n. By hypothesis (∗), Γ, env(s:τ) ≤ Γi, therefore Γ, env(s:τ) ⊢si:τi bi for all i ∈ 1..n. Finally, by compositionality, Γ⊢s1, . . . , sn G b1, . . . , bn.
From the point of view of selective recompilation, soundness of inter-checking ensures that recompilation steps are really unnecessary in case of successful inter-checking since they would lead to the same result. On the other hand, we would like to be sure that if inter-checking fails, then some recompilation step is really needed, so that it never happens that a recompilation step turns out to be useless. This happens if inter-checking is complete w.r.t. global compilation.
Def. 12 (COMPLETE INTER-CHECKING). Inter-checking is complete w.r.t. global compilation iff, for all typable (s, b), we can select a typing (Γ(s,b), τ(s,b)) of (s, b) s.t.
for all linksets L = Γ| Γi ⊢si:τi bii∈1..n, with (Γi, τi) = (Γ(si,bi), τ(si,bi)), i ∈ 1..n, if Γ⊢s1, . . . , sn G b1, . . . , bn holds, then ⊢ L⋄ holds.
Note that the property above is weaker than the opposite implication of Def. 10, which does not hold; indeed, for an arbitrary linkset, inter-checking could fail since for some fragment we have taken a too restrictive type environment. However, completeness as stated above requires that for each fragment we can select a priori a typing s.t., for any possible future context, failure of linking will ensure that we could not get the same binary fragments by global compilation.
Prop. 13 (COMPLETENESS OF INTER-CHECKING). Let T be a compositional type system satisfying the following additional property:
for all typable (s, b), there exists a provably principal typing of (s, b), that is a typing (Γ, τ) of (s, b) s.t. for all typings (Γ′, τ′) of (s, b), Γ′ ⊢ Γ and τ = τ′.
Then, inter-checking is complete w.r.t. global compilation.
PROOF. Let us take, for all (s, b), (Γ(s,b), τ(s,b)) a provably principal typing of (s, b).

Let L be Γ| Γi ⊢si:τi bii∈1..n with (Γi, τi) provably principal for (si, bi), i ∈ 1..n, and s.t. Γ⊢s G b holds.

By compositionality:

for for

all i ∈ 1..n, some τ′1, . . . ,

Γ, τ′n.

env(s1

,

.

.

.

,

sn:τ′1,

.

.

.

,

τ′n

)

⊢si:τ′i

bi,

Therefore, since (Γi, τi) is provably principal for (si, bi), τi = τ′i and Γ, env(s1, . . . , sn:τ1, . . . , τn)⊢Γi hold for all i ∈ 1..n, hence ⊢ L⋄ by Deﬁnition 8.

The following is just a corollary of Theorem 13 stating that completeness of inter-checking holds whenever T is compositional, has principal typings and the entailment relation is complete.
Theorem 14. Let T be a compositional type system with principal typings, satisfying the following additional property:
(∗∗) Γ1 ≤ Γ2 ⇒ Γ1 ⊢ Γ2 for all Γ1, Γ2 (entailment is complete).
Then, inter-checking is complete w.r.t. global compilation.

PROOF. Let (s, b) be typable; then by hypothesis (s, b) has a principal typing (Γ, τ). By deﬁnition of principal typing, for all (Γ′, τ′) of (s, b), τ = τ′ and Γ′ ≤ Γ, hence by hypothesis (∗∗), Γ′ ⊢ Γ. Finally, theorem 13 can be applied.

2.5 Selective recompilation
In this section we illustrate more in detail the role of soundness and completeness of inter-checking for selective recompilation. Assume that in a compositional system T some of a successfully interchecked linkset has been modiﬁed and recompiled, obtaining the new linkset Γ| Γi ⊢si:τi bii∈1..n. Of course, this change could have affected compatibility with some other fragment, therefore further recompilation steps could be required in principle. However, to avoid a pointless recompilation, we can use Deﬁnition 8; if all checks are passed, then by soundness we are sure that the modiﬁcation did not affect any other fragment, hence any further recompilation step would be useless.
On the other hand, if inter-checking is not passed, and typings in the linkset are those selected according to Deﬁnition 12, then, by completeness, we know that for s = s1, . . . , sn, b = b1, . . . , bn, Γ⊢s G b does not hold, hence, by completeness,
• either we simply introduced some name conﬂict, hence we obtain an ill-formed linkset;
• or ∃ i ∈ 1..n s.t. Γ, env(s:τ) ⊢si:τi bi is not valid.
In this latter case we recompile the i-th unit, since we are sure we will obtain either a different binary or a compilation error, but not the same result as before.
Note that it would be even better to be able to infer, in case of failure of inter-checking, whether recompilation would generate a different binary or a compilation error; indeed in this way we could avoid recompilation in the latter case and get an optimal procedure of selective recompilation. In languages where, differently from what happens in Java, changes to a fragment cannot affect other binary fragments, this is always the case since the former possibility does not hold. For Java-like languages, the same result could be achieved by introducing two different judgments, one for type-checking (not taking into account code generation) and one for compilation (that

s CDs

::= ::=

CDs1 . . . class

CDsn c extends

c′

{

FDS

MDSs

}

FDS ::= FD1 . . . FDn

FD ::= c f;

MDSs MDs

::= ::=

MDs1 . . . MDsn MH {return

Es;}

MH ::= c0 m(c1 x1, . . . , cn xn)

Es

::=

x | Es | new

.cf(|EEs1,s0..m. .(,EEs1sn,).

.|.(,cE)snE)s

b CDb

::= ::=

CDb1 . . . class

CDbn c extends

c′

{

FDS

MDSb

}

MDSb ::= MDb1 . . . MDbn MDb ::= MH {return Eb;}

Eb ::= x | Eb ≪c.f c′≫

Eb0 ≪ c.m(c¯)c′ ≫ (Eb1, . . . , Ebn) | new ≪c c¯≫ (Eb1, . . . , Ebn) | (c)Eb c¯ ::= c1, . . . , cn

Implicit assumptions:

• ﬁeld names in FDS are distinct • parameter types of methods with the same name are dis-
tinct in MDSs and MDSb • parameter names in MH are distinct
Figure 1. Syntax

introduced in next section). See the Conclusion for more on this point.
3 Separate compilation for FJ
3.1 Syntax
The language we consider at the source level is an extended version of Featherweight Java [8], shortly FJ in the following. More precisely, we keep the same syntax, but take a more liberal type system allowing ﬁeld hiding (a heir class can declare a ﬁeld already present in the parent; the new ﬁeld hides the inherited ﬁeld, which can only be recovered by an up cast3) and method overloading (a class can have many methods, either directly declared or inherited, with the same name and different parameter types; they are considered as different methods and the right method associated to an invocation, if any, is determined by the rules for overloading resolution, see in the sequel).
We include these features from full Java since they are signiﬁcant for the problem we are studying. Indeed, in both cases, the type which can be assigned to an expression in a fragment and the corresponding generated bytecode cannot be determined by simply inspecting the fragment, but depend on the context, as explained at the end of the Introduction.
The syntax of the language is deﬁned in Figure 1; metavariables c, f, m and x range over sets of class, ﬁeld, method and parameter names, respectively.
A source fragment s is a sequence of class declarations, each one consisting of the name of the class, the name of the superclass, a sequence of ﬁeld declarations FDS and a sequence of method dec-
3Or, in full Java, by super.

larations MDSs. If c′ is the superclass of c, then we also say that c (directly) extends c′, and extends any class c′′ which c′ (directly) extends. We assume a distinguished class name Object, denoting the root of the inheritance hierarchy, which cannot be declared.
A ﬁeld declaration FD consists of the type and the name of the declared ﬁeld. A method declaration MDs consists of a method header and a method body (an expression). A method header MH consists of a (return) type, a method name and a sequence of parameter types and names. There are ﬁve kinds of expression: parameter name, ﬁeld access, method invocation, instance creation and cast. Types of expressions are class names, and c is a subtype of c′ iff either c extends c′ or c = c′.
In FJ, any class c is assumed to have exactly one constructor Kc, which takes a canonical form explained below.
Let us deﬁne the sequence of the ﬁelds of c as follows: the sequence of the ﬁelds of Object is empty; if c directly extends c′, then the sequence of the ﬁelds of c is obtained appending to the sequence of the inherited ﬁelds (that is, the ﬁelds of c′) the sequence of the ﬁelds directly declared in c, in the given order.
Then
Kc ::= c(c1 f1, . . . , cn+m fn+m){ KEc; } KEc ::= super(f1, . . . , fn);
this.fn+1 = fn+1; . . . this.fn+m = fn+m;
where c1f1, . . . , cn+mfn+m, for n, m ≥ 0, are the ﬁelds of c and, in particular, cn+1fn+1, . . . , cn+mfn+m are the directly declared ﬁelds (hence c1f1, . . . , cnfn are the inherited ﬁelds).
Note that, if the whole FJ program is available, then the canonical constructor for a class c is completely determined by the inheritance hierarchy of c, hence it is immaterial to either explicitly write its declaration in the class or not. However, this consideration does not apply to separate compilation; indeed, if constructors are explicit, then compilation of a class requires the existence of all its ancestors, since we must check that the constructor matches inherited and declared ﬁelds. On the other hand, if constructors are implicit, then the availability of all ancestors is not required for compiling a class.
Here, we have chosen the second alternative, which allows a more modular type-checking. Another alternative would consist in allowing arbitrary constructors as in full Java. Here we preferred to keep the simpler FJ choice, since the problem of constructor overloading is basically an easier version of method overloading [10].
As already mentioned, the bytecode language we deﬁne for FJ differs from the source code only for ﬁeld accesses, which contain a symbolic reference ≪c.f c′ ≫ to the ﬁeld to be selected, method invocations, which contain a symbolic reference ≪c.m(c¯)c′ ≫ to the method to be invoked, and instance creation expressions, which contain a symbolic reference ≪c c¯≫ to the canonical constructor.
Type assumptions are deﬁned in Figure 2.
A standard type assumption has form c:(c′, FS, MSS) with the meaning “c extends c′ and declares exactly all ﬁelds speciﬁed by FS and all methods speciﬁed by MSS”, where FS is a set of ﬁelds (ﬁeld type and ﬁeld name) and MSS is a set of method signatures (return type, method name and parameter types).

γ ::= c : τ | ∃ c | c ≤ c′ | c.f f-→res c′ | c.m(c¯) m-→res (c¯′, c) | c k-→res c¯ | c MS | c ≤ c′
τ ::= (c, FS, MSS) FS ::= {F1, . . . , Fn}
F ::= c f MSS ::= {MS1, . . . , MSn} (where parameter types of methods with the same name are distinct)
MS ::= c m(c¯)
Figure 2. Type environments

Other forms of type assumptions are listed below:
• ∃ c with the meaning “c is declared”; • c ≤ c′ with the meaning “c is a subtype of c′”;
• c.f f-→res c′ with the meaning “the access to ﬁeld f of an object of type c is successfully resolved to a ﬁeld (obviously named f) with type c′”.
• c.m(c¯) m-→res (c¯′, c′) with the meaning “the invocation of method m of an object of type c and with arguments of types c¯ is successfully resolved to a method (obviously named m) with parameters of types c¯ ′ and return type c′”.
• c k-→res c¯ with the meaning “the canonical constructor of c has parameter types c¯ ”;
• c c′ m(c¯) with the meaning “c can be extended by a subclass with a method c′ m(c¯) without breaking the Java rule on method overriding”;
• c ≤ c′ with the meaning “c is not a subtype of c′”;
Typing rules for separate compilation are given in Figure 3.
The top-level rule (fragment) deﬁnes the compilation of a sequence of source class declarations s1, . . . , sn, whose type is τ1, . . . , τn, into a sequence of binary class declarations b1, . . . , bn. The provided environment, Γ, is enriched with the standard type assumptions assigning to classes their declared types to deal with mutual recursion. The resulting environment must be well-formed; the deﬁnition of well-formed type environments (typing rules for the judgment ⊢ Γ⋄ are given in Figure 4) relies on that for well-formed standard type environments (that is, those which only contain standard type assumptions, ranged over by Γs). That is, Γ is well-formed iff there exists a well-formed standard type environment Γs which entails Γ. A standard type environment is well-formed if the inheritance relation is acyclic, for each class all its ancestor classes are available and the Java rules on overriding are respected (that is, a class cannot declare a method with the same name and parameter types of an inherited method and different return type).This is modeled by means of a judgment Γs ⊢ c:MSS⋄ which holds if we can calculate in Γs the set of all method signatures of class c (empty for Object).
Rule (class), which deﬁnes the compilation of a single source class declaration for class c, checks that the superclass c′ can be safely extended with the methods declared in c and that there are no cycles involving c and c′ (existence of the superclass is guaranteed by this last check). Note that there is no constraint on the ﬁelds declared in c since we allow ﬁeld hiding.
Compilation of a sequence of method declarations consists in compilation of each method declaration.
Rule (method) for compiling a single method declaration checks the

existences of the return type and of the types of the parameters and, moreover that, under the type assumptions for parameters in the method header, the body is a well-formed expression of a subtype of the method return type.
The judgment for separate compilation of expressions takes an additional Π which is a mapping from variables to class names.
Rule (ﬁeld access) for compiling a ﬁeld access Es.f checks that Es is a well-formed expression of some type c, and an access to ﬁeld f of an object of type c is successfully resolved to a ﬁeld of some type c′, which is the resulting type of the ﬁeld access. Moreover, the corresponding binary ﬁeld access is annotated with the static type of Es and the type of the selected ﬁeld.
Rule (meth call) for compiling a method invocation Es0.m(Es1, . . . , Esn) checks that Es0 is a well-formed expression of some type c, all arguments are well-formed expressions of some types c¯ , and an invocation of method m of an object of type c and with arguments of types c¯ is successfully resolved to a method, whose return type is the resulting type of the method invocation. Moreover, the corresponding binary method invocation is annotated with the static type of the receiver and the parameter types and return type of the selected method.
Rule (new) for compiling an instance creation new c(Es1, . . . , Esn) checks that all arguments are well-formed expressions, an invocation of the canonical constructor of c is successfully resolved and the argument types are subtypes of the corresponding parameter types of the canonical constructor. Moreover, the corresponding binary instance creation is annotated with the parameter types of the canonical constructor.
There are two typing rules for compiling a cast expression (c)Es, which both check that Es is a well-formed expression of some type c′; then, the cast expression is well-formed and has type c if either c is a subtype of c′ (down cast) or conversely (up cast). Note that up casts are removed from the binaries. In [8], also casts between classes which are not in the subtyping relation (stupid casts) are allowed, in order to get the subject reduction property4, but no userdeﬁned expression can be typed by using the corresponding rule. Here we do not deal with the reduction semantics of FJ, hence we do not include stupid casts.
The typing rules for entailment of type environments are given in Figure 5. The ﬁrst three rules for environment entailment simply say that Γ1 ⊢ Γ2 is valid if each type assumption γ contained in Γ2 is entailed by Γ1; the remaining rules cover the cases when Γ2 is a single atomic type assumption γ.
There are two rules which deal with resolution of ﬁelds. Rule
4Since, e.g., (B)(Object)new A() reduces to (B)new A() for A, B heirs of Object.

⊢ Γ, env(s:τ)⋄

Γ, env(s:τ) ⊢si:τi bi ∀i ∈ 1..n

(fragment)

Γ ⊢s:τ b

s = s1, . . . , sn, τ = τ1, . . . , τn, b = b1, . . . , bn ∀i ∈ 1..n.τi = type(si)

(class) Γ ⊢

Γ ⊢MDSs MDSb Γ ⊢ c′ MSi ∀ i ∈ 1..n Γ ⊢ c′ ≤ c class c extends c′ {FDS MDSs} : (c′, FS, {MS1, . . . , MSn}) class c extends c′ {FDS MDSb}

type(MDSs) = {MS1, . . . , MSn} type(FDS) = FS

(methods)

Γ

Γ ⊢MDsi ⊢MDs1 . .

.

MDbi MDsn

∀i ∈ 1..n MDb1 . . . MDbn

Γ; x1:c1, . . . , xn:cn ⊢Es:c Eb Γ ⊢ c ≤ c0 Γ ⊢ ∃ ci ∀ i ∈ 0..n (method) Γ ⊢ c0 m(c1 x1, . . . , cn xn) {return Es;} c0 m(c1 x1, . . . , cn xn) {return Eb;}

⊢ Γ⋄ Π⊢x:c (parameter) Γ; Π ⊢x:c x

Γ; Π ⊢Es:c Eb Γ ⊢ c.f f-→res c′ (ﬁeld access) Γ; Π ⊢Es.f:c′ Eb ≪c.f c′≫

Γ; Π ⊢Es0:c Eb0

Γ; Π ⊢Esi :ci Γ ⊢ c.m(c1,

.

.

Ebi ∀i . , cn)

∈ 1..n m-→res (c¯′,

c′)

(meth call) Γ; Π ⊢Es0.m(Es1, . . . , Esn):c′ Eb0 ≪ c.m(c¯′)c′ ≫ (Eb1, . . . , Ebn)

Γ; Π ⊢Esi :c′i Ebi ∀i ∈ 1..n

Γ ⊢ c k-→res c1, . . . , cn

(new)

Γ;

Π

⊢new

c(Es1,

.

Γ ⊢ c′i ≤ . . , Esn):c

ci ∀i ∈ 1..n new ≪c c1,

.

.

.

,

cn

≫

(Eb1,

.

.

.

,

Ebn

)

Γ; Π ⊢Es:c′ Γ ⊢ c ≤ c′ (down cast) Γ; Π ⊢(c)Es:c

Eb (c)Eb

Γ; Π ⊢Es:c′ Eb Γ⊢ c′ ≤ c Γ⊢∃c (up cast) Γ; Π ⊢(c)Es:c Eb

type(CDs1 . . . type(class

cCDexsn)te=ndtyspec(′C{DFs1)D,S.

.M.D, tSysp}e()C=Dsn()c′

,

type(FDS),

type(MDSs))

type(FD1 . . . FDn) = {type(FD1), . . . , type(FDn)}

type(c f;) = c f

type(MDs1 . type(MH {

.r.eMtDusnr)n=Es{;ty}p)e(=MDtys1p)e, .(.M.H,)type(MDsn

)}

type(c0 m(c1 x1, . . . , cn xn)) = c0 m(c1..cn)

name(CDs1 . . . name(class

cCDexsn)te=ndnsamce′ ({CFDDs1)S,

. . . , name(CDsn) MDSs }) = c

Figure 3. Separate compilation

Γs ⊢ Γ ⊢ Γs⋄

(non standard)

⊢ Γ⋄

(standard)

c1

:τ1

,

.

.

.

,

cn:τn ⊢ ⊢ c1:τ1

ci:MSSi ⋄ ∀i , . . . , cn:τn⋄

∈

1,

.

.

.

,

n

n≥0 ci = c j =⇒ τi = τ j ∀i, j ∈ 1, . . . , n

Γs ⊢ c′:MSS′⋄ Γs(c) = (c′, −, MSS) (msigs obj) Γs ⊢ Object:0/ ⋄ (msigs down) Γs ⊢ c:MSS ∪ MSS′⋄ c1 m(c¯) ∈ MSS, c2 m(c¯) ∈ MSS′ =⇒ c1 = c2
Figure 4. Well-formed type environments

⊢ Γ⋄ (empty) Γ ⊢ Λ

(conc)

Γ

⊢ Γ1 Γ⊢

Γ Γ1, γ

⊢

γ

(singleton)

⊢ Γ1, Γ1, γ,

γ, Γ2⋄ Γ2 ⊢ γ

Γ⊢c:τ (def class) Γ ⊢ ∃ c

⊢ Γ⋄ (def obj) Γ ⊢ ∃ Object

⊢ Γ⋄ (reﬂ) Γ ⊢ c ≤ c

Γ ⊢ c1 ≤ c2 Γ ⊢ c2 : (c3, −, −)

(trans)

Γ ⊢ c1 ≤ c3

(≤vector)

Γ

Γ⊢ ci ⊢ c1, . .

≤ c′i . , cn

∀i ≤

∈ 1..n c′1, . . . ,

c′n

⊢ Γ⋄ (≤obj) Γ ⊢ c ≤ Object

(direct ﬁeld

Γ ⊢ c : (−, FS, −)
res)

c′

f

∈ FS

Γ ⊢ c.f f-→res c′

Γ ⊢ c1 : (c2, FS, −) Γ ⊢ c2.f f-→res c
(inh ﬁeld res)
Γ ⊢ c1.f f-→res c

∃c′.c′ f ∈ FS

Γ ⊢ c2 : (−, −, MSS) Γ ⊢ c1

(exact meth res)

Γ ⊢ c1.m(c¯) m-→res (c¯, c)

≤ c2

c

m(c¯) ∈ MSS

applAll(Γ, c, m, c¯) = µs Γ ⊢ c¯⇑ mostSpec(Γ, µs) = (c¯′, c′) (complete meth res) Γ ⊢ c.m(c¯) m-→res (c¯ ′, c′)

applAll(Γ, c, m, c¯) = µs matchAll(Γ, c, m, n) = µs mostSpec(Γ, µs) = (c¯′, c′) (match meth res) Γ ⊢ c.m(c¯) m-→res (c¯′, c′)

⊢ Γ⋄
(K obj)
Γ ⊢ Object k-→res Λ
⊢ Γ⋄ ( obj) Γ ⊢ Object c m(c¯ )
notSub(Γ, c, c′) (≤) Γ ⊢ c ≤ c′

(K

Γ ⊢ c : (c′, FS, −) Γ ⊢ c′ k-→res c¯
up)
Γ ⊢ c k-→res c¯ , c1, . . . , cn

FS

= c1

f1 . . . cn

fn

Γ ⊢ c1 : (c2, −, MSS)

Γ ⊢ c2 c m(c¯) ( down) Γ ⊢ c1 c m(c¯)

(c′ m(c¯) ∈ MSS) =⇒ c′ = c

Figure 5. Type environments entailment

Γ ⊢ c1, . . . , cn⇑= Γ ⊢ c1⇑ ∧ . . . ∧ Γ ⊢ cn⇑

 true

if c = Object

 Γ ⊢ c⇑=

Γ ⊢ c′⇑

if Γ ⊢ c : (c′, −, −)

 false otherwise

notSub(Γ, c, c′) = Γ ⊢ c⇑ ∧c′ ∈ supertypes(Γ, c)


 supertypes(Γ, c) =

{Object} {c} ∪ supertypes(Γ, c′)

if c = Object if Γ ⊢ c : (c′, −, −)

⊥

otherwise

appl(Γ, c, m, c¯) =

{<c, c¯′, c′> | c′ m(c¯′) ∈ MSS, Γ ⊢ c¯ ≤ c¯′ } if Γ ⊢ c : (−, −, MSS) ⊥ otherwise

 

0/

applAll(Γ, c, m, c¯) = µs1 ∪ µs2

if c = Object if appl(Γ, c, m, c¯) = µs1, Γ ⊢ c : (c′, −, −), applAll(Γ, c′, m, c¯) = µs2

⊥

otherwise

match(Γ, c, m, n) =

{<c, c′1, . . . , c′n, c′> | c′ m(c′1, . . . , c′n) ∈ MSS if Γ ⊢ c : (−, −, MSS) ⊥ otherwise

 

0/

matchAll(Γ, c, m, n) = µs1 ∪ µs2

if c = Object if match(Γ, c, m, n) = µs1, Γ ⊢ c : (c′, −, −), matchAll(Γ, c′, m, n) = µs2

⊥

otherwise

mostSpec(Γ, µs) =

<c0, c¯0, c′0> if <c0, c¯0, c′0> ∈ µs and Γ ⊢ c0, c¯0 ≤ c, c¯, for all <c, c¯, c′> ∈ µs ⊥ otherwise

Figure 6. Auxiliary functions

(direct ﬁeld res) states that an access to ﬁeld f for an object of type c can be successfully resolved if class c directly declares a ﬁeld named f. Rule (inh ﬁeld res) states that an access to ﬁeld f for an object of type c1 can be successfully resolved if it can be resolved for an object of the parent type c2 and c1 declares no ﬁelds named f (which would hide the inherited ﬁeld).
There are three rules which deal with resolution of methods.
Rule (exact meth res) covers the simple case where there exists an applicable method which perfectly matches the invocation, hence can be directly selected.
Otherwise, all applicable methods must be collected, and then the most speciﬁc method (if any) is selected [7].
The set applAll(Γ, c, m, c¯), formally deﬁned in Figure 6, contains all methods of c (either directly declared or inherited) named m whose parameter types are supertypes of c¯ in Γ (note that for calculating this set all ancestors of c are needed).
However, in general we cannot be sure that this set actually contains all the applicable methods, since there could exist some m in c for which we do not have in Γ the type assumptions stating that the parameter types are supertypes of c¯ . We can conclude that we have collected all applicable methods (hence the most speciﬁc, if any, can be selected) only in two cases: if we have all ancestors of the argument types (Γ ⊢ c¯ ⇑ in rule complete meth res), or if the set applAll(Γ, c, m, c¯) coincides with the set matchAll(Γ, c, m, n) of all methods m of class c whose number of parameters matches the number of arguments in the invocation (rule match meth res), hence the set of all applicable methods cannot be larger.
Rules (K obj) and (K up) deal with resolution of constructors. The former states that the canonical constructor of class c is Object has no parameters (Λ denotes the empty sequence). The latter states that the canonical constructor of a class c which extends c′ has as sequence of parameter types the sequence of the parameter types of the canonical constructor of c′, followed by the types of the ﬁelds directly declared in c.
Rule ( obj) states that Object can be extended by any method.
Rule ( down) states that if we know that a certain class c2 can be extended by a method c m(c¯), then a heir class c1 which does not deﬁne the method with a different return type can be extended with the same method as well.
Finally, the last rule states that we can conclude that c is not a subtype of c′ if all ancestors of c are available and c′ is not among them (see the deﬁnition of notSub in Figure 6).
4 Results
In this section we prove that the type system TFJ for FJ extended with overloading and hiding deﬁned in the previous section satisﬁes the hypotheses of Theorem 11 and 13, hence supports sound and complete inter-checking. We also prove that it has principal typings and that the environment entailment is complete.
In order to prove these results, we need the following lemmas, stating that entailment is a pre-order on well-formed type environments and that well-formedness actually coincides with consistency.

Lemma 15.
1. If Γ1 ⊢ Γ2 holds, then ⊢ Γ1⋄ holds.
2. If ⊢ Γ1, Γ2⋄ holds, then Γ1, Γ2 ⊢ Γ1 holds.
3. If Γ1 ⊢ Γ2 and Γ2 ⊢ Γ3 hold, then Γ1 ⊢ Γ3 holds.
4. If Γ1 ⊢ Γ2 holds, then ⊢ Γ2⋄ holds.
Lemma 16. Γ is consistent iff ⊢ Γ⋄.
Fact 17 (COMPOSITIONALITY OF TFJ ). The type system TFJ is compositional, that is, for all Γ, s = s1, . . . , sn, τ = τ1, . . . , τn, b = b1, . . . , bn: Γ ⊢s:τ b ⇔ Γ, env(s:τ) ⊢si:τi bi, for all i ∈ 1..n.
Theorem 18. The environment entailment is sound, that is, for all Γ1, Γ2, Γ1 ⊢ Γ2 ⇒ Γ1 ≤ Γ2.
Theorem 19. In the type system TFJ inter-checking is sound w.r.t. global compilation.
Theorem 20. For all typable (s, b), there exists a typing
(Γ(s,b), τ(s,b))
of (s, b) s.t. for all typings (Γ, τ) of (s, b), Γ ⊢ Γ(s,b) and τ(s,b) = τ.
Theorem 21. In the type system TFJ inter-checking is complete w.r.t. global compilation.
Theorem 22. The type system TFJ has principal typings.
Theorem 23. The environment entailment is complete, that is, for all Γ, Γ′, Γ ≤ Γ′ ⇒ Γ ⊢ Γ′.
5 Conclusion
We have deﬁned an abstract framework for modeling separate compilation and inter-checking, provided a formal deﬁnition of soundness and completeness of inter-checking, and proved that these properties can be guaranteed when the type system has principal typings and provides sound and complete entailment relation between type environments.
The fact that a type system has principal typings is often claimed to be a highly desirable feature since they allow compositional type analysis in the sense that the procedure of ﬁnding types for a term uses only the analysis results for its immediate subterms, which can be analyzed independently in any order [14] and never need to be inspected again (see also [9, 5]). Perhaps the most important result of this paper on the foundational side is that we are able to formally express this property in the context of separate compilation and linking and to prove that it is actually guaranteed by principal typings.
On the side of application to Java-like languages, this paper is part of a stream of work [3, 2, 10, 11] on alternative type systems for Java.
In [3] we ﬁrstly realized that, despite the fact that Java is considered a paradigmatic example of language supporting separate compilation, compilation as performed by standard Java compilers and

modeled in current Java formal deﬁnitions is not truly separate in the sense made precise in [4] and in this paper. Indeed, each class is typechecked against the same “global” type environment, that is, that extracted from a particular program context. Hence, a different type system for a subset of Java has been designed, introducing type assumptions expressing minimal requirements needed for typechecking a class in isolation, similar to those shown in this paper.
In [2] it is shown that this type system actually allows stronger typings w.r.t. to standard type systems for Java and that it can be the basis for selective recompilation of Java applications.
Concerning the applicability of these results to the whole Java language, [10] and [11] outline the extension of this type system to a large Java subset (including, e.g., constructors, access modiﬁers, static members, throws clauses and unreachable code) and the development of a corresponding smart compiler. The reader interested into aspects related to Java and selective recompilation can refer to these papers.
Here, our aim was to formally prove a result of existence of principal typings for a Java-like language (the ﬁrst to our knowledge), hence we have preferred to consider a simple and clean language as Featherweight Java, enriched with the features which pose the main problems in the Java type system. We believe a nice sidecontribution of this paper is that we have “exported” the notion of principal typing, more familiar in the community of functional languages, to a completely different context, and show that, whereas in classical type systems with principal typings they are usually obtained by making the type more general (typically by introducing polymorphism or intersection types), in Java-like languages the opposite happens, that is, principal typings can be obtained by making type environments less restrictive.
In the notion of type system introduced in this paper, we have considered fragments as pairs (s, b). As already mentioned, an interesting alternative would be to consider the binary as part of the type. In this case, in order to get the principal typings property, we should introduce polymorphic types.
For instance, consider again the example in the Introduction:
class C extends Parent { ... Type1 m(Type2 x){ return new Used().g(x);}
}
If we do not care about which bytecode will be generated, then class C can be correctly linked with any class Used having a method α g(β), for any types α, β s.t. α ≤ Type1 and Type2 ≤ β. Clearly, all these classes cannot be captured by a unique type environment Γ in our current type system. In order to do that, we should introduce type variables in the type environments, analogously to the approach followed in [13]; so we could model the requirements above as follows:
α ≤ Type1, Type2 ≤ β, Used.g(Type2) m-→res (α, β)
However, in this way the compiler cannot generate bytecode for C, since method descriptors cannot contain type variables; as a consequence, either JVM should be modiﬁed, or we should introduce a sort of pre-bytecode that may contain type variables that must be instantiated during static inter-checking in order to produce valid bytecode (similar solutions can be found in literature [13, 12]).

Finally, another interesting topic for further investigation is the relation between the notions of binary compatibility [6] and interchecking.
6 Acknowledgements
We would like to thank Eugenio Moggi for his helpful suggestions on the relation between Well’s and our notion of principality.
7 References
[1] Rolf Adams, Walter Tichy, and Annette Weinert. The cost of selective recompilation and environment processing. ACM Transactions on Software Engineering and Methodology, 3(1):3–28, January 1994.
[2] D. Ancona and G. Lagorio. Stronger typings for separate compilation of Java-like languages (Extended Abstract). In 5th Intl. Workshop on Formal Techniques for Java Programs 2003, July 2003.
[3] D. Ancona, G. Lagorio, and E. Zucca. True separate compilation of Java classes. In ACM SIGPLAN Conference on Principles and Practice of Declarative Programming (PPDP’02), pages 189–200. ACM Press, 2002.
[4] L. Cardelli. Program fragments, linking, and modularization. In ACM Symp. on Principles of Programming Languages 1997, pages 266–277. ACM Press, 1997.
[5] F. Damiani. Rank 2 intersection types for local deﬁnitions and conditional expressions. ACM Transactions On Programming Languages and Systems, 25(4):401–451, 2003.
[6] S. Drossopoulou, D. Wragg, and S. Eisenbach. What is Java binary compatibility? In ACM Symp. on Object-Oriented Programming: Systems, Languages and Applications 1998, volume 33(10) of SIGPLAN Notices, pages 341–358, October 1998.
[7] J. Gosling, B. Joy, G. Steele, and G. Bracha. The JavaTM Language Speciﬁcation, Second Edition. Addison-Wesley, 2000.
[8] A. Igarashi, B. Pierce, and P. Wadler. Featherweight Java: A minimal core calculus for Java and GJ. In ACM Symp. on Object-Oriented Programming: Systems, Languages and Applications 1999, pages 132–146, November 1999.
[9] T. Jim. What are principal typings and what are they good for? In Proceedings of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 42–53. ACM Press, 1996.
[10] G. Lagorio. Towards a smart compilation manager for Java. In Blundo and Laneve, editors, Italian Conf. on Theoretical Computer Science 2003, number 2841 in Lecture Notes in Computer Science, pages 302–315. Springer, October 2003.
[11] G. Lagorio. Another step towards a smart compilation manager for Java. In ACM Symp. on Applied Computing (SAC 2004), Special Track on Object-Oriented Programming Languages and Systems, 2004. To appear.
[12] S. McDirmid, M.Flatt, and W. Hsieh. Jiazzi: New age components for old fashioned Java. In ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA 2001). ACM Press, October 2001.
[13] Z. Shao and A.W. Appel. Smartest recompilation. In ACM Symp. on Principles of Programming Languages 1993, pages 439–450. ACM Press, 1993.

[14] J.B. Wells. The essence of principal typings. In International Colloquium on Automata, Languages and Programming 2002, number 2380 in Lecture Notes in Computer Science, pages 913–925. Springer, 2002.
A Proofs
Lemma 15 1. By induction on the derivation of Γ1 ⊢ Γ2. 2. By rules (conc) and (singleton). 3. By induction on the derivation of Γ2 ⊢ Γ3. 4. By rule (non standard) and (3).
Lemma 16 ⇒ If Γ is consistent, then we have applied rule (fragment), hence
⊢ Γ, env(s : τ)⋄ holds for some s, τ. Then by lemma 15 (2) and (4) we get that ⊢ Γ⋄ holds. ⇐ If ⊢ Γ⋄ holds, then we can apply rule (fragment) with n = 0.
Theorem 18 (Sketch) The fact that Γ2 is consistent follows from lemma 15 (4) and lemma 16. Then, we have to prove that, for all s, τ, b, if Γ2 ⊢s:τ b holds, then Γ1 ⊢s:τ b holds as well. This can be shown by induction on the derivation of Γ2 ⊢s:τ b, by extending the claim to all other kinds of compilation judgments and by using the transitivity of entailment.
Theorem 19 From Theorem 11 and Theorem 18.

We just outline the proof for the rule (ﬁeld access). Then we know that
H1 Γ; Π ⊢Es:c Eb holds; H2 Γ ⊢ c.f f-→res c′ holds; H3 (from (H1) by inductive hypothesis) there exists Γ(Es,Eb) s.t.
property (2) holds.

Let us take Γ(Es.f,Eb≪c.f c′≫) = Γ(Es,Eb), c.f f-→res c′. We have to prove that

T1 Γ(Es,Eb), c.f f-→res c′; Π ⊢Es.f:c′ Eb ≪c.f c′≫ holds; T2 Γ′ ⊢ Γ(Es,Eb), c.f f-→res c′ holds for all Γ′
Γ; Π ⊢Es.f:c Eb ≪c.f c′≫ holds.

s.t.

First of all we prove that Γ(Es,Eb), c.f f-→res c′ is consistent. Since Γ is consistent by hypothesis, Γ ⊢ Γ(Es,Eb) holds by (H3), Γ ⊢ c.f f-→res c′ holds by (H2), by rule (conc) we can conclude that Γ ⊢ Γ(Es,Eb), c.f f-→res c′ holds, and this implies that Γ(Es,Eb), c.f f-→res c′
is consistent by lemma 15 and lemma 16.

We prove now (T1). We can instantiate rule (ﬁeld access) by premises:

• Γ(Es,Eb), c.f f-→res c′; Π ⊢Es:c Eb (this follows from the facts that Γ(Es,Eb), c.f f-→res c′ is consistent, hence Γ(Es,Eb), c.f f-→res c′ ⊢Γ(Es,Eb) holds by lemma 15 (2) and by soundness of environment entailment (Theorem 18)).
• Γ(Es,Eb), c.f f-→res c′ ⊢ c.f f-→res c′ (this follows from the fact that Γ(Es,Eb), c.f f-→res c′ is consistent by rule (singleton).
Finally, (T2) follows from the fact that, if Γ′; Π ⊢Es:c Eb holds, then we must have instantiated rule (ﬁeld access), hence we can apply to Γ′ the previous reasoning and get that Γ′ ⊢Γ(Es,Eb), c.f f-→res c′ holds.

Theorem 20 (Sketch) We have to prove that,
(1) for all typable (s, b), there exists Γ(s,b), τ(s,b) s.t. Γ(s,b) ⊢s:τ(s,b) b holds and Γ ⊢ Γ(s,b), τ = τ(s,b) for all Γ s.t. Γ ⊢s:τ b holds.
Since (s, b) is typable, at least one compilation judgment Γ ⊢s:τ b holds. The proof is by induction on the derivation of this judgment, by extending the claim to all other kinds of compilation judgments.
Typings for expressions are the most interesting case. Then, property (1) becomes,
(2) for all Π, and typable (Es, Eb) w.r.t. Π, there exists Γ(Es,Eb), c(Es,Eb) s.t. Γ(Es,Eb); Π ⊢Es:c(Es,Eb) Eb holds and Γ ⊢ Γ(Es,Eb), c = c(Es,Eb) for all Γ s.t. Γ; Π ⊢Es:c Eb holds,
where (Es, Eb) is typable w.r.t. Π if there exist Γ, c s.t. Γ; Π ⊢Es:c Eb holds.

Theorem 21 From Theorem 13 and Theorem 20.
Theorem 22 From Theorem 18 and Theorem 20.
Theorem 23 (Sketch) First of all note that Γ ≤ Γ′ implies that Γ′ and Γ′ are consistent (hence ⊢ Γ′⋄ holds). The proof is by induction on the length of Γ′. The case Γ′ = Λ is trivial by rule (empty). Assume Γ ≤ Γ′, γ. Then Γ ≤ Γ′ and Γ ≤ γ by transitivity, since Γ′, γ ≤ Γ′ and Γ′, γ ≤ γ hold since Γ′, γ is consistent from lemma 15 (2) and soundness of environment entailment. Then, by inductive hypothesis Γ ⊢ Γ′ holds and we can instantiate rule (conc) provided that we prove that Γ ≤ γ implies Γ ⊢ γ for each type assumption γ. This can be proved by case analysis.

