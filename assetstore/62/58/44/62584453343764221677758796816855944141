Theoretical Computer Science 318 (2004) 373 – 408

www.elsevier.com/locate/tcs

The decidability of a fragment of BB IW-logic
Sabine Brodaa;∗ , LuÃs Damasa , Marcelo Fingerb , Paulo Silva e Silvab
aDCC-FC, Universidade do Porto, Rua do Campo Alegre 823, 4150 Porto, Portugal
bDepartamento de Cieˆncia da Computaca˜o, Instituto de MatemaÃtica e EstatÃstica, Universidade de Sa˜o Paulo, Brazil
Received 11 November 2002; received in revised form 19 January 2004; accepted 5 February 2004 Communicated by D. Plotkin
Abstract
Despite its simple formulation, the decidability of the logic BB IW has remained an open problem. We present here a decision procedure for a fragment of it, called the arity-1 formulas.
The decidability proof is based on a representation of formulas called formula-trees, which is coupled with a proof method that computes long normal -terms that inhabit a formula.
A rewriting-system is associated with such -terms, and we show that a formula admits a BB IW- -term if and only if the associated rewriting-system terminates. The fact that termination is decidable is proved using a result on the ÿniteness of non-ascending sequences of n-tuples in Nn, which is equivalent to Kripke’s Lemma. c 2004 Elsevier B.V. All rights reserved.
1. Introduction
The Hilbert-style logic T→ of “ticket entailment”, introduced and motivated by Anderson and Belnap [1], is the system of implicational propositional logic based on the axiom schemes
B : ( → ÿ) → ( → ) → → ÿ; B : ( → ÿ) → (ÿ → ) → → ; I : →; W : ( → → ÿ) → → ÿ
∗ Corresponding author. E-mail address: sbb@ncc.up.pt (S. Broda).
0304-3975/$ - see front matter c 2004 Elsevier B.V. All rights reserved. doi:10.1016/j.tcs.2004.02.002

374 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

and the rule
→ÿ ÿ

(→ e):

Surprisingly, the problem of decidability of this logic remains unsolved, although several studies have been carried out leading to a better insight on its nature.
Due to the fact that the axiom schemes of T→, or BB IW-logic, are the principal types of

B : xyz: x(yz);

B : xyz:y(xz);

I : x: x;

W : xy: xyy;
the problem is in fact equivalent to ÿnding an algorithm to decide whether a given type=formula has any inhabitants that are applicative combinations of these four terms. Also BB IW-proofs are represented by closed BB IW-deÿnable -terms. In [12], a precise characterisation of the class of BB IW-abstractable terms was presented. That approach was developed in terms of combinators but it can easily be transposed to -terms, as in [5], leading to the decidable class of BB IW- -terms. Consequently, a type=formula
is a theorem of T→ i there is a BB IW- -term to which the type can be assigned. Based on this characterisation, Bunder presented an algorithm in [5] that, applied to a type , produces in ÿnite time a (long) normal BB IW-inhabitant if there is one, but that may run forever if is not BB IW-inhabited. So, his algorithm does not, in general, provide a decision procedure.
In this paper, we solve the problem of decidability for a restricted class of formulas, called arity-1 formulas. In Section 2, we ÿx the notation and point to some results and methods that will be used in the remainder of the paper. We then present the class of arity-1 formulas, a fragment of the →-language. In Section 3, we deÿne the notion of terminating rewriting-systems over typed sequences that will be used to prove BB IW decidability for arity-1 formulas. Our proof is based on a mapping R( ) from arity-1 formulas to rewriting-systems. It will be shown in Section 4 that an arity-1 formula is BB IW-inhabited if and only if the rewriting-system R( ) is terminating. Decidability of termination of rewriting-systems over typed sequences is proved in Section 5 using a result on non-ascending N n-sequences equivalent to Kripke’s Lemma, cf. [1].

2. Preliminaries
We assume familiarity with the basic notions in -calculus and use standard notation from [2] and [8]. Our notation di ers from that in [2], since we denote type-variables (atoms) by “A; B; C; : : :” and arbitrary types by lower-case Greek letters. For type

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

375

assignment, we consider the system TA of simply typed -calculus aÂ la Curry (for an introduction see [8] or [2]). A term M has a bound-variable clash i M contains an abstractor x and a occurrence of x that is not in its scope. Note that for any -term M exists a -term N = M without bound-variable clashes. In this paper we will generally, but for the result of Algorithm 2.18, consider -terms without bound-variable clashes.

2.1. BB IW- -terms
In the following, we describe the set of -terms that can be deÿned in terms of the combinators B, B , I and W. We call these terms BB IW- -terms since they represent BB IW-proofs. Furthermore, a formula is a BB IW-theorem if and only if there is some BB IW- -term to which the type can be assigned.
Deÿnition 2.1. Let ˜x = x1; : : : ; xn, where n¿0, be a ÿnite sequence of distinct variables and let represent the empty sequence. The implicit order ≺ induced by a constant ⊥ and ˜x is ⊥≺ x1 ≺ · · · ≺ xn. The ˜x-index of a -term P, Ind˜x (P), is the ≺-maximum of x1; : : : ; xn in FV (P), or ⊥ if none of x1; : : : ; xn occurs in FV (P).
Deÿnition 2.2. The set of hereditary right-maximal terms relative to ˜x, HRM˜x, is deÿned as: • every variable is in HRM˜x; • if P ∈ HRM˜xy and y ∈ FV (P), then y: P ∈ HRM˜x; • if P; Q ∈ HRM˜x and Ind˜x(P) 4 Ind˜x(Q), then PQ ∈ HRM˜x.
The notion of hereditary right-maximal terms was introduced in [12], and we note that our deÿnition of HRM˜x corresponds to HRM(1;:::; n) ∩ Once(+1;:::; n) in that work. The following characterisation of the set of BB IW- -terms results mainly from the work in [12].
Proposition 2.3. A closed -term P is a BB IW-term if and only if P ∈ HRM .
A BB IW-term to which a type can be assigned is called a BB IW-inhabitant of . The following result, together with the subject-reduction property, reduces the existence of BB IW-inhabitants to the case of ÿ-normal forms.
Property 2.4. Consider a BB IW-term M and a term N such that M →ÿ N . Then, N is a BB IW-term.
Proof. It is su cient to show that for any sequence ˜x and redex ( y:P)Q ∈ HRM˜x we have FV (( y:P)Q) = FV (P[Q=y]) and P[Q=y] ∈ HRM˜x. The former is trivial since y ∈ FV (P), and for the latter we will show that for every subterm M of P such that M ∈ HRM˜xy˜z, for some sequence of variables ˜z, one has M [Q=y] ∈ HRM˜x ˜z. Then, since P ∈ HRM˜xy, it follows that P[Q=y] ∈ HRM˜x.

376 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408
First note that Q ∈ HRM˜x and no element of ˜z occurs in it. Now, we proceed by structural induction on M . The result is trivial if M is a variable. Now, suppose that M = (P1P2) ∈ HRM˜xy˜z, hence P1; P2 ∈ HRM˜xy˜z and Ind˜xy˜z (P1) 4 Ind˜xy˜z (P2). By the induction hypothesis, P1[Q=y]; P2[Q=y] ∈ HRM˜x ˜z. Thus, in order to prove that (P1P2)[Q=y] ∈ HRM˜x ˜z it su ces to show that Ind˜x ˜z (P1[Q=y]) 4 Ind˜x ˜z (P2[Q=y]). For that, consider the cases: • Ind˜x ˜z (P1[Q=y]) = ⊥. The result is trivial. • Ind˜x ˜z (P1[Q=y]) ∈˜x. Then no z ∈ ˜z occurs in P1 and from Ind˜xy˜z (P1) 4 Ind˜xy˜z (P2)
we obtain the result. • Ind˜x ˜z (P1[Q=y]) = zi ∈ ˜z. Since no z ∈ ˜z occurs in Q, it follows from Ind˜xy˜z (P1) 4
Ind˜xy˜z (P2) that Ind˜x ˜z (P2[Q=y]) = zj and zi 4 zj, which gives us the result. Finally, if M = u:P1 ∈ HRM˜xy˜z, then P1 ∈ HRM˜xy˜zu and u ∈ FV (P1). Thus, by the induction hypothesis, P1[Q=y] ∈ HRM˜x ˜zu. Then, it follows from u ∈ FV (P1[Q=y]) and from Deÿnition 2.2 that ( u:P1)[Q=y] = ( u:(P1[Q=y]) ∈ HRM˜x ˜z.
A ÿ-normal inhabitant M of a type is called a long normal inhabitant of i every variable-occurrence z in M is followed by the longest sequence of arguments allowed by its type, i.e. i each component with form (zP1 : : : Pn), (n¿0), that is not in a function position has atomic type. The ÿnite set of all terms obtained by Á-reducing a -term M zero or more times is called the Á-family of M and denoted by {M }Á. It has been shown (cf. [3,8]) that the Á-families of the long normal inhabitants of partition the set of normal inhabitants of into non-overlapping ÿnite subsets, each Á-family containing just one long member. Furthermore, Ben-Yelles (cf. [3,8]) showed that every normal inhabitant of a type can be Á-expanded to one unique (up to conversion) long normal inhabitant of . A simple expansion-algorithm can be found in [8]. The following result implies that when looking for ÿ-normal BB IW-inhabitants of a type, one can just search for long normal BB IW-inhabitants from which all other ÿ-normal inhabitants can be obtained by Á-reduction.
Property 2.5. Consider two -terms M and N such that M →Á N . Then, M is a BB IW-term if and only if N is.
Proof. Let ˜x be a sequence of variables and y:Py a term such that y ∈= FV (P). Then, FV ( y:Py) = FV (P) and consequently Ind˜x( y:Py) = Ind˜x(P). On the other hand, y:Py ∈ HRM˜x if and only if Py ∈ HRM˜xy and since y ∈= FV (P) this holds if and only if P ∈ HRM˜x.
In the following, we describe the straight relation that exists between subterms and variables in a long normal inhabitant of a type ’ and the subtypes of ’. It is well known that for every (long) normal inhabitant M of a type ’ there is exactly one deduction in the system TA that assigns the type ’ to M . Thus, in the remaining we sometimes refer to the types that are assigned to variables and subterms of a normal inhabitant during this unique deduction as their types. We begin recalling the rather standard deÿnition of polarities of occurrences of subtypes=subformulas.

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

377

Deÿnition 2.6. An occurrence of a subtype in a type is deÿned as positive or negative as follows: • ’ occurs positively in ’; • if an occurrence of a subtype is positive (negative) in ’, then it is negative (resp.
positive) in ’ → ; • if an occurrence of a subtype is positive (negative) in , then it is positive (resp.
negative) in ’ → .

The following properties of long normal inhabitants follow almost directly from the deÿnitions and give us some insight on the relation between the structure of a type and the structure of their long normal inhabitants (an exhaustive analysis of this relationship can be found in [8], cf. Section 8E—The structure of an nf-scheme).

Lemma 2.7. Consider a long normal inhabitant M of a type ’ and let P be a subterm
of M .
(i) If P = x1 : : : xn: N , with n¿1 and such that N is no abstraction, then there is some positive occurrence of a subtype of the form = 1 → · · · → n→ A in ’ and P is of type . Furthermore, x1; : : : ; xn are respectively of type 1; : : : ; n, which are negative occurrences of subtypes of ’, while N is of atomic type A.
(ii) If P = yM1 : : : Mn, with n¿0 and such that M1; : : : ; Mn are all the arguments applied to y, then there is some negative occurrence of a subtype of the form
= 1 → · · · → n → A in ’, y has type and P; M1; : : : ; Mn have respectively types A; 1; : : : ; n.

We conclude mainly that variables in abstraction sequences correspond to negative
occurrences of subtypes and that subterms in argument position correspond to positive
occurrences of subtypes. Also, every variable x with a type 1 → · · · → n → A occurs always with exactly n arguments in a long normal inhabitant, i.e. in an expression
of the form xP1 : : : Pn of type A and such that P1; : : : ; Pn are, respectively, of types 1; : : : ; n. Moreover, if i = ÿ1→ · · · → ÿk → B, i ∈ {1; : : : ; n}, then Pi is of the form y1 : : : yk : N such that y1; : : : ; yk have types ÿ1; : : : ; ÿk which are negative occurrences of subtypes, and N has type B.

2.2. The formula-tree proof method
A central element in our decidability proof is the tree-like representation of types called formula-tree representation, ÿrst introduced in [4]. 1 In this representation, every type ’ is split into primitive parts, and the primitive parts themselves form a treelike structure, which is called the formula-tree of ’, and that deÿnes some kind of hierarchy over the primitive parts of the formula. Here, every primitive part, except the

1 A short presentation of the method together with an implementation as a Java applet can be found at http://www.ncc.up.pt/~sbb/FTLab/ftlab.

378 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408
one in the root of the formula-tree, represents together with the subtree rooted in it a subtype of ’ that, during the construction of a long normal inhabitant of ’, may be assigned to variables. 2 The formula-tree of ’, tree(’), can then be used to build proof-trees for ’, each proof-tree being a representation of a ÿnite non-empty set of long normal inhabitants of ’. Since ’ may have none, a ÿnite or an inÿnite number of long normal inhabitants it may consequently be possible to build none, a ÿnite or even an inÿnite number of di erent proof-trees for ’.
Primitive parts (frequently represented inside of boxes) are items of either one of the following forms (P1), (P2) or (P3), where A; B; B1; : : : ; Bn; C denote type-variables:

(P1) :

| A

(P2) :

(n ¿ 1) (P3):

C |

Here, A; B1; : : : ; Bn are called the tail-variables of the respective primitive part, while B and C are head-variables. The arity of a primitive part is the number of its tailvariables. Moreover, we will always associate with each primitive part a unique label pi which allow us to have distinct primitive parts with the same appearance.

Deÿnition 2.8. A formula-tree is a tree-like structure with primitive parts as nodes, but such that subtrees descend from the branches (or tail-variables) of primitive parts rather than from the whole primitive parts as nodes. Then, such a structure is called a formula-tree i • the root of the formula-tree is the only primitive part of form (P1); • every node of form (P2) or (P3) in the formula-tree descends from a tail-variable
in another primitive part; • every (labeled) primitive part occurs only once in a formula-tree.

The following algorithm computes the formula-tree tree(’) of a type ’. We use dashed lines for the edges of the formula-tree in order to distinguish them from the edges in the primitive parts (nodes) of the formula-tree. Furthermore, we will use the expression branch only when referring to edges in primitive parts, but not when referring to (dashed) edges of formula-trees.

Formula-tree Algorithm 2.9. Input: A type ’ = 1 → · · · → n → A, where A is an atom and n¿0. Output: ’’s formula-tree tree(’). The formula-tree tree(’) is given by the following.

• If n = 0, i.e. ’ ≡ A, then tree(’) =

| A

.

2 In [8], these subtypes are also called negative subpremises.

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

• If n¿1, then tree(’) =

where t(A) =

A |

and for k¿1 and m1; : : : ; mk ¿0 we recursively deÿne t(( 11 → · · · → 1m1 → A1) → · · · →( k1→ · · · → kmk → Ak ) → A) =

379

Furthermore, for 16j6k, we call the primitive parts in the top of t( j1); : : : ; t( jmj ) the descendents of primitive part
at branch j (or tail-variable Aj). Note, that in case mj = 0, branch j, i.e. tail-variable Aj, has no children=descendents. We assume that all primitive parts introduced above are given distinct labels, thus ensuring that each primitive part occurs only once as required in the deÿnition of a formula-tree. In the following we exemplify the formula-tree algorithm as well as the notion of descendents of a primitive part at a branch (tail-variable). Example 2.10. The formula
’ = (((A → A) → (A → (A → B) → A) → A) → A) → ((B → A) → B) → A has formula-tree
tree(’) = tree((((A → A) → (A → (A → B) → A) → A) → A) → ((B → A) → B) → A) =

380 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

with primitive parts

p0 =

| A

; p1 =

A | A

; p2 =

B | A

; p3 =

A | A

; p4 =

;

p5 =

B |

and

p6 =

A |

:

In the formula-tree tree(’), p0 has descendents p1 and p2 at p0’s branch 1 (p0’s only branch), p1 has descendents p3 and p4 at p1’s branch 1 (p1’s only branch), p2 has descendent p5 at its only branch 1, p4 has descendent p6 at branch 2 and no descendent at branch 1, and ÿnally p3, p5 and p6 have no descendents at all.

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

381

It is easy to see that for every negative occurrence of a subtype of a type ’ there will be a subtree t( ) of tree(’), suggesting the following relation between subtrees and the types of variables in long normal inhabitants (cf. Lemma 2.7): given a long normal inhabitant M of a type ’ and a variable x in M of type there is exactly one subtree t( ) of tree(’) corresponding to x. Any such subtree can be identiÿed by the primitive part in its top position. So, from now on we call this the primitive part corresponding to the variable x in M . Note that, while every variable in M has exactly one corresponding primitive part in tree(’), given a primitive part p in tree(’) there may be more than one variable in M for which p is the corresponding primitive part, or there may even be no such variable. The result below follows from the deÿnition of corresponding primitive part and from the observations made after Lemma 2.7.

Lemma 2.11. Let M be a long normal inhabitant of a type ’ with formula-tree tree(’), consider any variable x in M and let p be the primitive part in tree(’) corresponding to x. If p is of arity k¿0, then x occurs always with exactly k arguments in M . Furthermore, for k¿1, if i ∈ {1; : : : ; k} and p has descendents p1; : : : ; pm at branch=tail-variable i in tree(’), then the ith argument of x is of the form
y1 : : : ym: N and the primitive parts in tree(’) corresponding to y1; : : : ; ym are, respectively, p1; : : : ; pm.

Furthermore, one can easily deÿne an inverse algorithm, which given a formula-tree FT computes the unique type ’ such that tree(’) = FT. In the following example, we give some intuition on the meaning of primitive parts and the hierarchy deÿned on them.

Example 2.12. The formula ’ = ((A → B) → A →B) →(A → B)→ A→ B has formulatree

tree(’) = tree(((A → B) → A → B) → (A → B) → A → B) =

382 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

A p3 = |

A and p4 = | :

Note that part p4 connects to the branch 1 of part p1 with tail variable B. Then we get the following information from this representation: during the construction of a long normal inhabitant of ’ there may appear variables of type (A → B)→ A → B, of type A → B or of type A, which are the negative subtypes of ’, cf. Lemma 2.7. These are represented, respectively, by the subtrees t((A → B)→ A→ B), t(A → B) and t(A) (the latter occurs twice). As such, using a variable x of type (A → B) → A → B, corresponding to the subtree t((A → B)→ A → B) with primitive part

at its top, allows us to construct a term of type B—the head-variable of p1. Furthermore, in order to complete the construction of this term, two other terms of type B and of type A, respectively,—the tail-variables of p1—have to be constructed. Also x will appear with two—the arity of p1—arguments, and for the construction of the ÿrst there will appear a new variable of type A represented by t(A), i.e. corresponding to p4—the descendent of the ÿrst branch of p1. Actually, all this parallels the fact, cf. Lemma 2.7, that every long normal term beginning with a variable x of type (A → B) → A → B is of the form x( y: M )N of type B, where y, M and N are, respectively, of type A, B and A, and ÿnally in M there may appear a new variable y of type A.
The previous discussion illustrates that we can associate to each variable in a long normal inhabitant M of a type ’ a subtree t( i) of tree(’) with primitive part pi at its top (the corresponding primitive part). Now, consider M obtained from M by replacing each variable in M with the name of the corresponding primitive part and by erasing abstractions. For example, for the long normal inhabitant M = xyz: x( w:yw)z of ’ as above we obtain M = p1(p2p4)p3, which represented as a tree gives, after inserting a top level node p0, the following tree of primitive parts

It turns out that one can characterise precisely the trees of primitive parts that correspond to long normal inhabitants of a type and which will be called valid proof-trees. We now describe the set of rules that allows us to build proof-trees and then give two conditions to be satisÿed by a proof-tree in order for it to be valid. In the remaining we will often use the notation o to refer to a speciÿc occurrence of an object o.

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

383

Deÿnition 2.13 (Proof-tree structure). A proof-tree for a type ’ is a tree-like structures
whose nodes are primitive parts in pp(’) = {p0; : : : ; pn}, the set of (labels of the) primitive parts in the formula-tree of ’ and where p0 denotes the primitive part in the root of tree(’) (thus the only primitive part of form (P1) in pp(’)). In the following,

we shall use the notation

to designate a proof-tree that has in a leaf a primitive

part with a tail-variable A. Then, the set of proof-trees for ’ is given by the following:

• If p0 =

| A

∈ pp(’), then

| A

is a proof-tree for ’;

• if is a proof-tree for ’ and

∈ pp(’) where k¿1,

then is a proof-tree for ’;

• if

is a proof-tree for ’ and

B |

∈ pp(’), then

is a proof-tree for ’.

Deÿnition 2.14 (Valid proof-trees). Given a proof-tree PT for a type ’, we call it a valid proof-tree for ’ i • the number of subtrees rooted in any node=primitive part in PT equals the arity of
that primitive part; • if
p=
with k¿1 is a primitive part in the formula-tree tree(’), and p is a descendent of p in tree(’) at branch i, with 16i6k, then above every occurrence p of p in PT there is at least one occurrence p of p in PT, such that the occurrence p occurs in the subtree of PT rooted in the i’th branch of p .
This last item corresponds to the hierarchy of tree(’) being imposed on the construction of a valid proof-tree and will be illustrated by the following example. From

384 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

now on, we will usually, and for the sake of saving space, represent valid proof-trees without drawing edges between primitive parts explicitly. As such, the tree of primitive parts at the end of Example 2.12 will be represented by

p0

p1 p2 p3

:

p4

Due to the ÿrst condition in the deÿnition of a valid proof-tree (Deÿnition 2.14) there will be no ambiguity regarding descendents=parents in the tree. Also, for the sake of saving space, we will unify the head variable and tail variables of two parts that are linked in a proof-tree.

Example 2.15. A valid proof-tree for the formula ’ in Example 2.12 is

p0

p2

p3 i.e.

| B

B |: A

A |

p0

Using the compact representation this proof-tree will be represented by p2 and has

appearance

p3

| B | A |

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

385

p0 after unifying=overlapping the linked variables. On the other hand, the tree p2 is
p4 not a valid proof-tree for ’ (though it would have the same appearance), since it
does not respect the hierarchy given by the formula-tree of ’, which requires that in
a valid proof-tree all occurrences of p4 occur in some subtree that is rooted in the left branch of an occurrence of p1. Moreover, there are exactly three proof-trees with appearance

p0 p0

p0

;

that

are

p1 p2 p3

;

p1 p2 p3

and

p1 p2 p4

:

p4 p3

p4

Only the ÿrst two of these proof-trees are valid proof-trees, since the third does again not satisfy the second condition of Deÿnition 2.14. Another valid proof-tree is
p0 p1 p1 p3 p2 p4 p4
with appearance

:

Note that these again are, respectively, the compact representations of

386 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

:

The following example will give some intuition on the fact that, given a formula ’, the search for a valid proof-tree, and consequently the search for normal inhabitants, is ÿnite. A sketch of a search-algorithm is given after the example.

Example 2.16. Consider again the formula ’ and its formula-tree tree(’) from

Example 2.10. We will now attempt to build a valid proof-tree for this formula, ap-

plying the rules for constructing proof-trees, in such a way that none of the conditions

in Deÿnition 2.14 is violated:

1. The only primitive part that can be used in the beginning is p0, leading to the

tree

p0

with

appearance

| A

.

This

is no valid proof-tree, since p0

has arity 1 and

consequently there has to be a subtree rooted in A.

2. Now, in order to build that subtree, applying one of the other two construction-rules

for proof-trees, we have to use a primitive part with head-variable A. The primitive

parts in the formula-tree with head-variable A are p1, p3, p4 and p6. But, actually

the only primitive part that can be used without violating the second condition in

Deÿnition 2.14 is p1. Being a descendent of p0 at branch 1, this primitive part, as

well as p2, has been made available by the use of p0. The resulting proof-tree is

p0 p1

with appearance

|

A |

;

A

that is still not complete.

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

387

3. Again a subtree rooted in type-variable A has to be constructed, but now there are
two more primitive parts that may be used. In fact, p3 and p4 (the descendents of p1 at branch 1) have been made available by the use of p1, and so one may now choose between p1, p3 or p4 (p2 is available, but its head-variable does not ÿt). Using p1 again would lead to the still incomplete proof-tree

p0 p1 p1

with appearance

|

A

| A

:

|

A

Again a subtree rooted in A has to be constructed and the use of p1 does not allow us to use any primitive part di erent from those available in the step before. The same
will happen if we choose to use p3 instead of p1. In fact, p3 has no descendents and consequently there will be no further primitive parts available, but the same as
in the step before. Furthermore, p3 has also tail-variable A and consequently we will still be attempting to construct a subtree rooted in A. Finally, we can use part p4 which leads us to the incomplete proof-tree

p0 p1 p4
with appearance

:

Now, we have to construct two subtrees. One rooted in type-variable A and another rooted in type-variable B. Note, that p4 has no descendent at branch 1 and the descendent p6 at branch 2. Although, p6 is now available for the construction of the subtree rooted in B, there is no new primitive part available for the construction of the subtree rooted in A. Consequently, again one of our tasks is the same as before and we conclude that there is no valid proof-tree for this formula.
Based on the argument used in the previous example, one can deÿne a search algorithm for a valid proof-tree as follows. Begin the construction of a valid proof-tree

388 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408
with p0, the unique primitive part of form (P1) in the formula-tree. Proceed, building a complete subtree rooted at the tail-variable of p0. During the construction of subtrees only use primitive parts that are allowed by the second condition in Deÿnition 2.14. Call these the available parts at a certain stage. During the construction, explore all possibilities, using all available primitive part with the matching head-variable. The search stops in one of two ways. With success, if a valid proof tree is obtained. With failure, whenever trying to build a complete subtree rooted in the same type-variable and with the same set of available primitive parts as in one of the steps before; this means that there is no need to construct proof-trees with depth greater than the number of di erent type-variables (in the type) times the number of primitive parts (in the formula-tree). Eventually, one of the two halting conditions will be obtained, since the number of atoms and primitive parts found in ’ is ÿnite.
In order to establish the relation between the long normal inhabitants of a type and its valid proof-trees, we now describe an algorithm PT( ) that given a long inhabitant M of a type ’ computes a valid proof-tree for PT(M ) for ’. The deÿnition of this algorithm parallels the construction of a proof-tree from a long normal inhabitant in Example 2.12. In the following algorithm, we use the notion of erasing abstractions in a term, which consists of removing all preÿxes x in the term, obtaining as a result a purely applicative term.
Proof-tree Algorithm 2.17. Input: a type ’ and M , a long normal inhabitant of ’. Output: a valid proof-tree PT(M ) for ’. Let M be the term obtained from M by erasing abstractions in M and replacing
each variable with the name of the corresponding primitive part in tree(’). Then, PT(M ) is the graphical representation of M after inserting a top level node p0 (the root-node of tree(’)).
We now examine an “inverse” algorithm which computes, given a type ’ and any valid proof-tree PT for ’, a ÿnite non-empty set Terms(PT) of long closed normal inhabitants of ’. The algorithm consists of three parts.
In the ÿrst two parts, the common structure of the lambda-terms that correspond to a certain valid proof-tree is recovered by a -term, that we call a term-scheme. These term-schemes resemble lambda-terms (possibly with bounded-variable clashes) in the simple type-system with the total discharge convention, or Prawitz-style natural deduction system [10], but actually they di er from them in the following way. While all free (distinct) variables in a subterm of a term in Prawitz’ system have distinct types, distinct (free or bounded) variables in a subterm of a term-scheme may have the same type as long as they correspond to di erent primitive parts (or equivalently to di erent negative occurrences of the type as a subtype).
In the last part, we compute the set of all terms from which a given term-scheme may be obtained, by identifying in these terms all variables, that correspond to the same primitive part in the formula-tree. For example, for xy: x ( z : x( z:yzz)) the term-scheme of type ((B → A) → A)→(B → B → A) → A, the two bounded z s are given

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

389

distinct names and all possibilities explored for the subterms in their scope, leading to the following set of terms:

{ xy:x( z:x( z :yzz)); xy:x( z:x( z :yzz )); xy:x( z:x( z :yz z)); xy:x( z:x( z :yz z ))}:

Terms Algorithm 2.18.

Input: a type ’ and a valid proof-tree PT for ’.

Output: a ÿnite non-empty set Terms(PT) of long closed normal inhabitants of ’.

Let p0; : : : ; pn be the primitive parts in tree(’), where p0 is the root-part and n¿0.

The set Terms(PT) is constructed in the following way.

(a) Represent PT as an application using for 06i6n the variable name xi instead of

pi. Then, for each variable-occurrence xi in this application, such that the primitive

part pi has arity ki¿0, insert a (possibly empty) abstraction sequence before each

of its ki arguments. Here, the variable names in an abstraction sequence xj1 : : : xjlj to be inserted before the jth argument, 16j6ki, correspond to the descendents

pj1 : : : pjlj at branch j of pi in tree(’). (b) Now, erase the variable x0 at the top.

(c) Finally, for term-scheme T obtained in the previous step compute Terms(PT) =

Tx01::::::0xn deÿned below, where x0 = x for any variable x.

• xikx11::::::0x:i::::k:xnn = {xi}; 3

•

xixk11

:::ki :::kn ::: xi ::: xn

= {xi; xi ; xi

; : : : ; xiki−1};

ki ¿1;

• (ST )kx11::::::kxnn = {SiTj | Si ∈ Sxk11::::::kxnn ; Tj ∈ Txk11::::::xknn };

•

(

xi :T

)k1 :::kn
x1::: xn

=

{

xiki :Ti | Ti ∈ Txk11::::::x(ik:i::+xn1):::kn }.

The following example illustrates the application of the algorithm.

Example 2.19. Consider again ’ = ((A → B)→ A → B)→(A → B) → A → B from Example 2.12 with formula-tree

3 This case corresponds to the renaming of free occurrences of variables in T .

390 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

Let PT be the last valid proof-tree for ’ in Example 2.15, i.e.

PT =

p0

p1

p1 p3

p2 p4

p4

:

In the ÿrst step of the Terms algorithm, PT is represented by the application x0(x1(x1(x2 x4)x4)x3). Then, since p0 has arity 1 and descendents p1, p2 and p3 at branch 1, the abstraction sequence x1x2x3 is inserted before the ÿrst argument of x0, leading to x0( x1x2x3:x1(x1(x2x4)x4)x3). As p1 has arity 2, descendent p4 at branch 1 and no descendent at branch 2, the abstraction sequence x4 has to be inserted before the ÿrst argument of (every occurrence of) x1 and no (or the empty) abstraction sequence will be inserted before the second argument of (all occurrences of)

x1, leading to x0( x1x2x3: x1( x4:x1( x4:x2x4)x4)x3). Neither p2, p3 or p4 have descendents; thus no further abstraction sequence has to be inserted. After erasing

x0 at the top we obtain the term-scheme T = x1x2x3:x1( x4:x1( x4:x2x4)x4)x3. Finally,

Terms(PT)

=

T 0000
x1 x2 x3 x4

= { x1x2x3:x1( x4:x1( x4:x2x4)x4)x3;

x1x2x3:x1( x4:x1( x4:x2x4)

x4)x3}.

The following result proves the correctness of Algorithms 2.17 and 2.18 and will be used in the proof of Theorem 4.10. Note that the set of long normal inhabitants produced by Algorithm 2.18 may contain terms with bounded-variable clashes, but is of course equivalent (modulo -conversion) to a set of long normal inhabitants without bounded-variable clashes.

Proposition 2.20. (i) If M is a long normal inhabitant of a type ’, then PT(M ) is a valid proof-tree for ’.
(ii) If PT is a valid proof-tree for a type ’, then every member of Terms(PT) is a closed long normal inhabitant of ’. Furthermore, the two algorithms are complementary in the sense that for every closed long normal inhabitant M of ’ there is M ∈ Terms(PT(M )).

Proof. We begin the proof of (i) showing that PT(M ) can in fact be obtained applying the rules for constructing proof-trees in Deÿnition 2.13, and showing that both conditions in Deÿnition 2.14 are satisÿed by PT(M ). For that, consider any occurrence x (not in an abstraction-sequence) of a variable x in M . Suppose that x has type
= ( 11 → · · · → 1m1 → A1) → · · · →( k1→ · · · → kmk → Ak ) → A, let p be the primitive part in tree(’) that corresponds to x, i.e. p is the primitive part in the top of t( ), and ÿnally let p be the occurrence of p in PT(M ) created by the replacement of occurrence x of x by p during the application of algorithm PT( ).
It follows from the Formula-tree Algorithm and from the structure of , that p has arity k¿0 with head-variable A and tail-variables A1; : : : ; Ak . Furthermore, for 16j6k, p has exactly mj descendents at branch j. Thus, by Lemma 2.11, the occurrence x of x in M occurs exactly with k arguments, which for 16j6k are respectively of the form

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

391

yj1 : : : yjmj : Nj and such that Nj is of atomic type Aj. Due to their atomic type, each Nj has to be of the form zjPj1 : : : Pjsj , sj¿0. Thus, p will have exactly k arguments, p1; : : : ; pk , in PT(M ) which are respectively the primitive parts corresponding to z1 in N1; : : : and to zk in Nk . This, satisÿes the ÿrst condition in Deÿnition 2.14. Furthermore, since N1; : : : ; Nk have types A1; : : : ; Ak , respectively, we infer that the primitive parts corresponding to z1; : : : ; zk , i.e. p1; : : : ; pk , have head-variables A1; : : : ; Ak , respectively, so, by the formation rules in Deÿnition 2.13, they ÿt as arguments for p.
Finally, we have to show that also the second condition in Deÿnition 2.14 is satisÿed
by PT(M ). Consider p; we have to show that if p is a descendent at branch i of some
primitive part p in tree(’), then there is some occurrence of p in PT(M ), such that
p occurs in the subtree of PT(M ) rooted in the ith branch of p .
Suppose p = p0, the primitive part in the root of tree(’), then there is no such p and the second condition in Deÿnition 2.14 is trivially true.
Suppose p = p0 and let x be the variable corresponding to p. Since M is closed, x occurs in the scope of some abstraction sequence ˜x containing x. If ˜x is the initial
abstraction sequence in M , then p descends from p = p0 at branch 1 in tree(’) and the second condition in Deÿnition 2.14 is satisÿed, since p0 is the primitive part in the root of PT(M ). Otherwise, ˜x is the initial abstraction sequence of the ith argument
of a subterm of M of the form yN1 : : : Nk and i ∈ {1; : : : ; k}, k¿1. Then, p descends in tree(’) from the ith branch=tail-variable of the primitive part p that corresponds
to y. Since, x occurs in the ith argument of an occurrence of y, we conclude that p
occurs in the subtree rooted at the ith branch of an occurrence of p in PT(M ).
For (ii) we begin by noting that the only occurrence of p0 in PT is in its root and that p0 has arity 1. Therefore the expression constructed in part (a) of Algorithm 2.18 is of the form x0(T ) and that T = xi1 : : : xik : N , where pi1 ; : : : ; pik are the descendents of p0 (at branch 1) in tree(’) and such that N corresponds to the subtree beneath p0 in PT.
The term x0(T ) was constructed starting from an application of variables, by introduction of abstraction-sequences before subterms in argument position, but never in
function position. So it is surely a -term in ÿ-normal form and consequently the same
is true for the term-scheme T , which is the result after step (b).
Now, consider any occurrence xi (not in an abstraction-sequence) of a variable xi in T , which is due to an occurrence pi in PT. Let pm be the primitive part of arity l¿1 such that, in tree(’), pi is a descendent of pm at some branch j. The second condition in the deÿnition of valid proof-trees guarantees that there is at least one
occurrence pm in PT such that the pi is in the subtree rooted in the jth branch of pm. This is re ected in T as an occurrence of the variable xm with l arguments and such that the occurrence xi is in the jth argument of xm, which begins with an abstraction sequence in which xi occurs, binding thus the occurrence xi (if not already binded 4 ). We conclude that T is closed.
Finally, denote by ’i, for 16i6n, the subtype of ’ such that the subtree t(’i) in tree(’) has primitive part pi at its top (cf. Algorithm 2.9). Now, consider any

4 The same variable name may appear in more than one abstraction, corresponding to di erent occurrences of the same primitive part.

392 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

occurrence ps of a primitive part ps of arity l¿1 in PT, let PT be the subtree of PT rooted in branch j ∈ {1; : : : ; l} of ps, let A be the jth tail-variable of ps (and consequently the head-variable of the primitive part in the top of PT ) and ÿnally let
pj1 ; : : : ; pjt , t¿0, be the descendents of ps at branch j in tree(’). It follows from the algorithm Terms that the jth argument of the occurrence xs in x0(T ), created due to ps, is of the form T = xj1 : : : xjt :P. We will show by induction on the number of occurrences of type-variables in PT that, for the type-context = {x1 : ’1; : : : ; xn : ’n} there
is − xj1 : : : xjt :P : ’j1 → · · · → ’jt → A in TA , i.e. given the type ’j1 → · · · → ’jt → A can be assigned to xj1 : : : xjt :P, cf. [8, Chapter 2]. Then, taking for ps the unique occurrence of p0 in PT, one has − xi1 : : : xik : N : ’i1 → · · · → ’ik → A0, where A0 is the tail-variable of p0, i.e. − T : ’. Furthermore, since T is closed, we conclude that
also − T : ’ is true in TA . On the other hand, T is clearly long, since every variable xi of type ’1 → · · · → ’l → A appears always with exactly l arguments, due to the fact
that the corresponding primitive part pi has l tail-variables.
We begin the induction proof with the case PT = pi, i ∈ {1; : : : ; n} and

pi

=

A |

;

hence ’i = A. Since pi has no tail-variable, there are no primitive parts descending from

pi in tree(’), thus xj1 : : : xjt :P = xj1 : : : xjt : xi and − xj1 : : : xjt : xi : ’j1 → · · · → ’jt → A is true in TA .
Now, let the primitive part in the top of PT be pi of arity l¿1. Furthermore,

for 16s6l variable As,

let let

ps1 ; : : : ; ˜xs be

psls the

be the descendents (in abstraction-sequence

tree(’)) xs1 : : : xsls

from pi at branch s=tailand let ’s = ’s1 → · · · →

’sls → As. Then, ’i = ’1 → · · · → ’l → A and P = xi( ˜x1:P1) : : : ( ˜xl:Pl), where each

˜xs:Ps is constructed from subtree PTs rooted in the sth tail-variable of pi. In or-

der to show that − xj1 : : : xjt :P : ’j1 → · · · → ’jt → A is true in TA , it su ces to show that for 16s6l, given context the type ’s can be assigned to ˜xs:Ps in TA .

This follows from the induction hypothesis applied to PTs, thus ÿnishing the induction.

To ÿnish the proof of part (ii) ÿrst note that for n¿1 and T resulting from (b)

of Terms Algorithm, every term M ∈ Tx01::::::0xn is a closed term (for this it su ces to show by structural induction on N , that for any term N with variables in {x1; : : : ; xn}, if M ∈ Nxk11::::::xknn , then for the set FV (M ) of free variables of M , one has FV (M ) ⊆ {xij | 16i6n; 06j6ki − 1} ∪ {xi | 16i6n; xi ∈ FV (N ); ki = 0}, and consequently for M ∈ Tx01::::::0xn there is FV (M ) = ∅). On the other hand, we know that there is a deduction of T : ’ in TA . This deduction can then easily be changed into a deduction of

M : ’, assigning identical types to variables with the same index.

The remaining claim that for every closed long normal inhabitant M of ’ there is

M ∈ Terms(PT(M )), included here for the sake of completeness, is a consequence of

the symmetry of the two algorithms, and will actually not be used in this paper.

2.3. Arity-1 formulas

In this subsection, we identify the class of formulas for which decidability of BB IWinhabitation will be shown.

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

393

Deÿnition 2.21. A primitive part p in a formula-tree is called terminating i it is of

the

form

A |

.

It

is

called

composed

of

arity

n¿1

i

it is of the form

:

We call a formula an arity-1 formula i every composed primitive part in its formulatree is of arity 1.
Another simple characterisation of arity-1 formulas, that does not rely on the formulatree approach can be given using the notion of polarities of occurrences of subformulas, cf. Deÿnition 2.6. Then, it follows that arity-1 formulas are exactly the formulas such that all negative occurrences of subformulas are of the form → A or A, where is a type and A a type-variable.
Example 2.22. The arity-1 formula
= (A → B) → (((B → B) → B) → A) → (((B → A) → A → A) → B) → A
has the following formula-tree

with primitive parts p0 =

| A

, p1 =

B | A

, p2 =

A | B

, p3 =

B | A

, p4 =

B |, B

p5 =

A
| , and p6 = B

A |

. A valid proof-tree for this formula is

394 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408
p0 with appearance | p2 A p3 | p6 B :
| A |
It is important to note that a proof-tree for an arity-1 formula is not really a tree, but it degenerates into a sequence=chain of parts p0; : : : ; pf. This is due to the fact that each internal primitive part in an arity-1 formula must always be of the form
X |; Y
as can be seen in the two previous examples. Furthermore, note that whenever a primitive part p descends from another primitive part p , then p must have arity 1 and p descends from p at branch 1. So, in the remaining, where we deal with arity-1 formulas, we will usually just say that p descends from p and no longer specify the branch which is necessarily branch 1.
The following properties or arity-1 formulas will be used later on. Here, we call a term compound if there occurs at least one application in it.
Lemma 2.23. Let M be a long normal BB IW-inhabitant of an arity-1 formula ’ and such that M contains a compound subterm N . Then, N is of the form x1 : : : xn:yP, with n¿0. Moreover, x1; : : : ; xn−1 are all of non-atomic type. Furthermore, there are abstractions in P if and only if xn is of non-atomic type.
Proof. First note that neither M nor any subterm of M can be of the form x:x. The former is due to the fact that M has to contain at least one application in order to have a compound subterm N . The latter follows from the fact that if M has a subterm of the form x: x then there must be another subterm of M of the form zU1 : : : ( x: x) : : : Ul, l¿0, covered by abstraction sequences s˜1; : : : ; s˜t, with t¿1, in which z occurs. This subterm then violates the condition imposed on BB IW-inhabitants that there should be Inds˜1;:::; s˜t (z) 4 Inds˜1;:::; s˜t ( x: x) which is not the case since z 4 ⊥. Furthermore, note that every variable x in M is of some type , where is a negative occurrence of a subformula of ’, also called a negative subpremise in [8]. Since ’ is an arity-1 formula, it follows that is either of the form → A or A, where is a type and A a type-variable. Thus, it follows from M being a long inhabitant that every variable occurs always with one argument if its type is of the form → A and always with zero arguments if its type is of the form A. We conclude that every compound subterm of M is of the form x1 : : : xn:yP, with n¿0. Since P cannot be of the form x: x we

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

395

gain enough insight to conclude that M is necessarily of the form
˜s1:z11(z12(: : : z1k1 ( ˜s2:z21(: : : z2k2 ( ˜s3: : : : ( ˜sm:zm1 (: : : (zmkm z) : : :)) : : :) : : :)) : : :))
with non-empty abstraction sequences ˜s1; : : : ; ˜sm, m¿1, k1; : : : ; km¿1, such that every variable zij is of non-atomic type and occurs in one of ˜s1; : : : ; ˜si, with 16i6m and 16j6kj, while the only variable of atomic type is z. Finally, it follows from Deÿnition 2.2 that z has to be the last variable in ˜sm, which concludes the proof.
Lemma 2.24. Every BB IW-inhabitated arity-1 formula has exactly one terminating primitive part in its formula-tree.

Proof. This result follows from the analysis made in the proof of the previous lemma together with the fact that negative occurrences of atomic subformulas in a formula correspond to terminating primitive parts in its formula-tree.

Due to Lemma 2.24, from now on we only consider arity-1 formulas with exactly one terminating primitive part in their formula-trees.

3. Rewriting-systems over typed sequences

In this section, we deÿne the notion of rewriting-systems over typed sequences that will be used in order to prove decidability for arity-1 formulas. In fact, decidability will be shown using a mapping from arity-1 formulas to rewriting-systems. The main goal of these rewriting-systems is to describe the important steps during the search of a long normal BB IW-inhabitant of an arity-1 formula. As such, remember that each variable x of type in a long normal inhabitant of a formula ’ corresponds to a negative occurrence of in ’, and is represented by the subtree t( ) of the formulatree tree(’). The primitive part, say px, in the top of this subtree t( ) describes the consequences of using x during the construction of a subterm M : if

px =

A | B

and has descendents p1; : : : ; p n (at branch 1) in tree(’), then M is of the form x( x1 : : : x n: N ) of atomic type A, where N of atomic type B has to be constructed. Furthermore, all the new variables x1; : : : ; x n have to be used in N . Also all the variables in the abstraction sequence over M that have not been used before have to appear in N , as well as the last variable in this sequence (even if it was already used, as will be seen in Lemma 4.5). All this will be represented as a rewriting system. Here sequences of variables juxtaposed will be used to represent the whole abstraction sequence of variables over the subterm that is actually being constructed, i.e. all the variables, in order from the left, that have the subterm in their scope. A type-variable assigned to this sequence represents the type of this subterm, and rewriting-rules will describe the change of the current task due to the use of variables.

396 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408
Deÿnition 3.1. A typed sequence is a ÿnite sequence of variables juxtaposed x1 : : : xn, with n¿0, to which a type-variable A has been assigned, and will be represented by x1 : : : xn :: A.
The meaning of a typed sequence x1 : : : xn :: A (where x1 : : : xn represents a sequence, in which variables may occur more than once, and not as in -calculus an application of variables) is the following. Given a type ’ there will be a variable name associated with each primitive part in tree(’), or equivalently to each negative subformula of ’. Then, during the construction of a long normal BB IW-inhabitant of ’ the typed sequence x1 : : : xn :: A represents an intermediate step such that so far the sequence of variables that have been introduced in abstractions have types corresponding to x1, to x2; : : :, to xn. Also, in order to obtain a long normal BB IW-inhabitant a subterm of type A still has to be constructed. Note that although variables may occur more than once in a typed sequence, this does not imply a clash of bounded-variables. In fact, it rather describes the construction of a term in which (at least) two distinct variables have the same corresponding primitive part.
Deÿnition 3.2. A rewriting-system over typed sequences is a tuple R = (Â; R; xf :: Cf) such that • xf is a variable and Cf a type-variable; • Â is a typed sequence; • R is a ÿnite set of rules of the form x :: A → x1 : : : xn :: B, where x; x1; : : : ; xn are
term-variables, A and B are type-variables and n¿0.
Deÿnition 3.3. The expansion rule ⇒R of typed sequences with a rewriting-system R = (Â; R; xf :: Cf) is deÿned as follows: • If z1 : : : zm :: A is a typed sequence and zi :: A → x1 : : : xn :: B ∈ R, for some 16i6m,
then
z1 : : : zm :: A ⇒R z1 : : : zmx1 : : : xn :: B:
The corresponding occurrence of zi in z1 : : : zm is said to be used in this expansionstep. Furthermore, if i = m, we call it to be used in a non-ÿnal position. A typed sequence expands to ˜ i ⇒?R ˜, where ⇒?R denotes the re exive, transitive closure of ⇒R. A typed sequence expands successfully with R = (Â; R; xf :: Cf) i there is some expansion from to a typed sequence ˜ = z1 : : : zM :: Cf such that • zM = xf and zi = xf for any other zi ∈ {z1; : : : ; zM−1}; • every one of the occurrences of variables in z1; : : : ; zM−1 has been used in a non-ÿnal position at least once during the expansion of to ˜. If the initial sequence Â expands successfully with R = (Â; R; xf :: Cf), then R is also called a terminating rewriting-system.
In the following, we deÿne a function R( ) that maps formulas into rewritingsystems. In Section 4, it will be shown that BB IW-theorems are associated with terminating rewriting-systems, while formulas that are not BB IW-theorems are

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

397

associated with non-terminating rewriting-systems. A decision algorithm for termination of rewriting-systems will be given in Section 5.

Deÿnition 3.4. Given an arity-1 formula , consider its formula-tree FT ( ) with primitive parts p0; : : : ; pn; pf, where p0 is the root of FT ( ) and

pf =

Cf |

its unique terminating primitive part. We associate with a rewriting-system R( ) =
(Â; R; xf :: Cf) by the following: • Â is the typed sequence x1 : : : xm :: A, where p1; : : : ; pm are the primitive parts de-
scending from the root

p0 =

| A

in tree( ); • for every primitive part pi of the form
B | C

and with descendents pi1 ; : : : ; pimi in tree( ), where mi¿0, there is a rule xi :: B → xi1 : : : ximi :: C in R (occasionally abbreviated by xi :: B →˜xi :: C).

Example 3.5. For from Example 2.22, we have R( ) = (Â; R; x6 :: A), where • Â = x1x2x3 :: A • and
R : x1 :: B → :: A x2 :: A → x4 :: B x3 :: B → x5x6 :: A x4 :: B → :: B x5 :: A → :: B:
The following expansion sequence shows that R( ) is terminating, since Â expands successfully with R( ) to = x1x2x3x4x4x5x6 :: A.
x1x2x3 :: A ⇒ x1x2x3x4 :: B ⇒ x1x2x3x4 :: A ⇒ x1x2x3x4x4 :: B ⇒ x1x2x3x4x4 :: B ⇒ x1x2x3x4x4x5x6 :: A ⇒ x1x2x3x4x4x5x6 :: B ⇒ x1x2x3x4x4x5x6 :: B ⇒ x1x2x3x4x4x5x6 :: A:

398 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408
Note, that for sake of readability in every step of this expansion we underlined the occurrence of the variable used to obtain the next sequence. Furthermore, we omitted reference to R( ) during this expansion, writing ⇒ rather than ⇒R( ). This will be done whenever there is no ambiguity concerning the rewriting-system we refer to.
4. BB IW-inhabitation and terminating rewriting-systems
4.1. BB IW-inhabitation implies terminating rewriting-system
In this subsection, we show that every BB IW-inhabitated arity-1 formula gives rise to a terminating rewriting-system R( ) = (Â; R; xf :: Cf). For this, we prove that given a BB IW-inhabitant M of , the initial sequence Â expands successfully to the typed sequence Seq(M ) deÿned below, in Deÿnition 4.2.
First, consider the unique long inhabitant M + of to which M Á-expands. Every variable in M + corresponds exactly to one primitive part, di erent from p0, in the formula-tree tree( ) with primitive parts p0; p1; : : : ; pn; pf, where n¿0. Now, let N be any term obtained by renaming variables in M + in the following way: all occurrences of variables corresponding to a primitive part pi, with i ∈ {1; : : : ; n; f}, are named xij for some j¿1. Here, occurrences of the same variable are given the same exponent j (i.e. the same name) and di erent variables are given di erent exponents (i.e. receive di erent names). Obviously, there is N ≡ M + and N is a long normal BB IW-inhabitant of .
Example 4.1. Consider the arity-1 formula
= (((A → A) → (B → A) → A) → A) → ((B → A) → B) → A
with formula-tree

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408
with primitive parts

399

p0 =

| A

; p1 =

A | A

; p2 =

B | A

; p3 =

A | A

; p4 =

A | B

and p5 =

B |

:

A (long) normal BB IW-inhabitant of is
M = xy:x( zu:x( vs:u(y( t:z(v(st))))));
where x corresponds to p1, y to p2, z and v to p3, u and s to p4, and ÿnally t to p5. After renaming we obtain the term
N = x11x21:x11( x31x41:x11( x32x42:x41(x21( x51:x31(x32(x42x51)))))):
Deÿnition 4.2. Let M be a long inhabitant of an arity-1 formula and consider a term N ≡ M as above, i.e. a long normal inhabitant of where variables are indexed according to the primitive part in tree( ) they correspond to. Furthermore, let Cf be the type-variable in the (unique) terminating primitive part in tree( ). We deÿne Seq(M ) = x1 : : : xn :: Cf, where x1 : : : xn is the sequence of variables in successive abstractions in N after erasing superscripts=exponents.
Example 4.3. For the term from Example 4.1 we have Seq(M ) = x1x2x3x4x3x4x5 :: B.
Below we will show that for every type with normal inhabitant M the rewritingsystem R( ) is terminating, since its initial sequence Â expands successfully to Seq(M ). During the proof, we will also need the notion of e ective occurrences of variables in terms.
Deÿnition 4.4. We call the underlined occurrence of x in a term of the form x:y1(: : : yk (xP) : : :), with k¿0, ine ective. Every ine ective occurrence of a variable x in a subterm of a term M is an ine ective occurrence of x in M . An occurrence of a variable in a term (but not in an abstraction sequence) that is not ine ective is called e ective.
In other words, an occurrence of a variable x in a long normal BB IW-term is always e ective, unless it is the ÿrst x in a subterm of the form xP covered by an abstraction sequence whose last variable is x. The following result shows that all variables in a long normal BB IW-term have at least one e ective occurrence.
Lemma 4.5. If Q = x:y1(: : : yk (xP) : : :) is a subterm of a long normal BB IW-term M , then there is at least one e ective occurrence of x in P.
Proof. Consider the sequence of the variables ˜x = x1; : : : ; xn; x, n¿0, that occur in abstractions in M which have the subterm y1(: : : yk (xP) : : :) in their scope, together with the induced implicit order ⊥≺ x1 ≺ · · · ≺ xn ≺ x. From Deÿnitions 2.1 and 2.2, we conclude that Ind˜x(P) = x, thus x ∈ FV (P). We now prove the result by induction on the

400 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

length of P. If P = x, this occurrence of x is an e ective occurrence. If P = yP , then x ∈ FV (P ) (for y = x as well as for y = x) and by the induction hypothesis x has an e ective occurrence in P . Otherwise, P = y:P , where x ∈ FV (P ). All occurrences of x in P are clearly e ective.

Theorem 4.6. For every BB IW-inhabitant M of an arity-1 formula , the initial sequence Â expands successfully with R( ) = (Â; R; xf :: Cf) to Seq(M ).

Proof. Consider N ≡ M as before, i.e. obtained from the unique long normal inhabi-

tant of to which M Á-expands by renaming variables according to the primitive parts

they correspond to.

First note that for Seq(M ) = s1 : : : sl :: A there is exactly one occurrence of xf

in s1 : : : sl, which is sl and that A = Cf. The latter results from the deÿnition of

Seq(M ) and the former from xf being the only variable of atomic type and from Lemma 2.23.

Now let P be any long subterm of N that is not an abstraction and which is in the

scope of variables ˜xP = x1; : : : ; xn and let B be the atomic type of P, for P is long.

Let y˜P = y1; : : : ; yk be the subsequence of x1; : : : ; xn obtained by deleting all variables xj such that P occurs as a subterm of the argument of an e ective occurrence of xj.

Note that all of y1; : : : ; yk occur at least once (cf. Lemma 4.5) in P. For example, if

P = y(zu) is a subterm of x y z: z(y(x( u:y(zu))) there is ˜x = x; y; z; u and y˜P = z; u; if we consider P = x( u:y(zu)), then ˜x = x; y; z and y˜P = x; z.
We now prove by induction on the number of applications in P, that the typed

sequence x1 : : : xn :: B expands to Seq(M ), thus Seq(M ) = x1 : : : xn :: Cf, and during

this expansion all occurrences of variables in y1; : : : ; yk and , di erent from xf, are used in a non-ÿnal position.

First suppose that P = x is a variable. Since it has atomic type B, we conclude

from Lemma 2.23 that x = xn = xf, thus B = Cf, as well as Seq(M ) = x1 : : : xn :: Cf. On the other hand, we know from Lemma 4.5 that all of y1; : : : ; yk have to occur at least once in P. Thus, y1; : : : ; yk is just xf. The result becomes trivially true. In fact,

x1 : : : xn :: B expands in zero steps to Seq(M ), and there are no variables di erent from

xf in y1; : : : ; yk . Otherwise, by Lemma 2.23, P = x( u1 : : : ut:Q) such that Q, of type D, is not an

abstraction and t¿0. Note that the ÿrst occurrence of x in P is e ective if and

only if x = xn, i.e. the corresponding occurrence of x is in a non-ÿnal position in x1 : : : xn. From the correspondence between variables and primitive parts we conclude that there is the rule x :: B → u1 : : : ut :: D in R. Thus, x1 : : : xn :: B ⇒ x1 : : : xnu1 : : : ut :: D.

Now, it is su cient to apply the induction hypothesis to the term Q, typed sequence

˜xQ = x1 : : : xnu1 : : : ut :: D and y˜Q deÿned as before, which means that

  y1 : : : yk u1 : : : ut y˜Q =  y1 : : : yl−1yl+1 : : : yk u1 : : : ut

if x ∈= {y1; : : : ; yk } or if the ÿrst x in P is ine ective
and x = xn = yk ; otherwise (x = yl; 16l6k);

which ÿnishes the proof.

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

401

Example 4.7. For from Example 4.1, we have R( ) = (Â; R; x5 :: B) with Â = x1x2 :: A and

R = {x1 :: A → x3x4 :: A; x2 :: B → x5 :: A; x3 :: A → :: A; x4 :: A → :: B}:

Recall that N = x11x21: x11( x31x41: x11( x32x42:x41(x21( x51:x31(x32(x42x51)))))). In fact, the initial sequence Â expands to Seq(M ) = x1x2x3x4x3x4x5 :: B as shown
below:

x1x2 :: A ⇒

x1 :: A → x3x4 :: A N = x1x2:x1P1

⇒ x1x2x3x4 :: A

x1 :: A → x3x4 :: A P1 = x3x4:x1P2

⇒ x1x2x3x4x3x4 :: A x4 :: A → :: B P2 = x3x4:x4P3

⇒ x1x2x3x4x3x4 :: B x2 :: B → x5 :: A P3 = x2P4

⇒ x1x2x3x4x3x4x5 :: A x3 :: A → :: A P4 = x5:x3P5

⇒ x1x2x3x4x3x4x5 :: A x3 :: A → :: A P5 = x3P6

⇒ x1x2x3x4x3x4x5 :: A x4 :: A → :: B P6 = x4P7

⇒ x1x2x3x4x3x4x5 :: B xf = x5

P7 = x5

where the second column contains the rewriting rule expansion applied and the third column contains its corresponding subterm, as in the proof of Theorem 4.6.

Corollary 4.8. If is a BB IW-inhabited type, then R( ) is a terminating rewritingsystem.

4.2. Termination implies BB IW-inhabitation

In the following, we show that whenever the initial sequence Â of R( ) expands successfully to a sequence , then has at least one BB IW-inhabitant. For this, consider any successful expansion from Â to = z1 : : : znxf :: Cf and perform the following annotations on z1 : : : znxf. First, associate new exponents to di erent occurrences of the same variable in this sequence. Second, insert in this sequence an item [xij] before every subsequence that has been introduced using the occurrence of xij. Third, append the item [xf1] at the end of the sequence.
The algorithm T, that we will show to compute a BB IW-inhabitant M = T( ˜) of from this new sequence, denoted by ˜, is given by the following: • T([x]) = x; • T([x] ) = x(T( )); • T(x ) = x:T( ).

Example 4.9. An annotated version ˜ of = x1x2x3x4x4x5x6 :: A from Example 3.5 is x11x21x31[x21]x41[x11][x21]x42[x41][x31]x51x61[x51][x42][x11][x61]
and M = T( ˜) is given by
M = T(x11x21x31[x21]x41[x11][x21]x42[x41][x31]x51x61[x51][x42][x11][x61]) = x11:T(x21x31[x21]x41[x11][x21]x42[x41][x31]x51x61[x51][x42][x11][x61])

402 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408
= x11x21:T(x31[x21]x41[x11][x21]x42[x41][x31]x51x61[x51][x42][x11][x61]) = x11x21x31:T([x21]x41[x11][x21]x42[x41][x31]x51x61[x51][x42][x11][x61]) = x11x21x31:x21(T(x41[x11][x21]x42[x41][x31]x51x61[x51][x42][x11][x61]))
= x11x21x31:x21( x41:T([x11][x21]x42[x41][x31]x51x61[x51][x42][x11][x61]))
= x11x21x31:x21( x41: x11(T([x21]x42[x41][x31]x51x61[x51][x42][x11][x61])))
= x11x21x31:x21( x41: x11(x21(T(x42[x41][x31]x51x61[x51][x42][x11][x61]))))
= x11x21x31:x21( x41: x11(x21( x42:T([x41][x31]x51x61[x51][x42][x11][x61]))))
= x11x21x31:x21( x41: x11(x21( x42:x41(T([x31]x51x61[x51][x42][x11][x61])))))
= x11x21x31:x21( x41: x11(x21( x42:x41(x31(T(x51x61[x51][x42][x11][x61]))))))
= x11x21x31:x21( x41: x11(x21( x42:x41(x31( x51:T(x61[x51][x42][x11][x61]))))))
= x11x21x31:x21( x41: x11(x21( x42:x41(x31( x51x61:T([x51][x42][x11][x61]))))))
= x11x21x31:x21( x41: x11(x21( x42:x41(x31( x51x61: x51(T([x42][x11][x61])))))))
= x11x21x31:x21( x41: x11(x21( x42:x41(x31( x51x61: x51(x42(T([x11][x61]))))))))
= x11x21x31:x21( x41: x11(x21( x42:x41(x31( x51x61: x51(x42(x11(T([x61])))))))))
= x11x21x31:x21( x41: x11(x21( x42:x41(x31( x51x61: x51(x42(x11x61))))))):
Theorem 4.10. Consider an arity-1 formula with rewriting-system R( ) = (Â; R; xf :: Cf) and a typed sequence such that Â expands successfully to . Then, M is a BB IW-inhabitant of .
Proof. Consider an annotated version ˜ of . We begin arguing that for every such sequence ˜, if ˜ = 1x[x1] : : : [xn] 2, n¿0, then x ∈ FV (T( 2)). For this note that items of the form [z] in ˜ are introduced due to the use of z during the expansion of Â to . Since every variable in , but xf, has to be used at least once in a non-ÿnal position during the expansion (cf. Deÿnition 3.3), there has to be at least one item [x] in [x1] : : : [xn] 2. Now, even if x = xi for some 16i6n, then this expansion with x was performed in a ÿnal position and there must be another item [x] in 2. Thus, in any case there has to be at least one item [x] in 2 leading to a free (variables have been renamed in ˜, thus there is no other unbracketed x in ˜) occurrence of x in T( 2).
Now, in order to prove that M is a BB IW-term, i.e. M ∈ HRM (cf. Proposition 2.3), we show that during the calculation of M , for every computed subterm M = T( ) in the scope of variables ˜z = z1; : : : ; zs, s¿1, M ∈ HRM˜z as well as Ind˜z (M ) = zs. We prove this result by induction on the length of , which is the remaining subsequence of ˜, which during the computation of M = T( ˜) is consumed from left to right.
For = [x], there is x = xf1 = zs and the result is true. For = [x] , one has M = T([x] ) = x(M ), where M = T( ) with M ∈ HRM˜z and Ind˜z (M ) = zs. On the other hand, the item [x] appears in ˜ due to the use of x during

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

403

the expansion. So, in ˜ there must be an unbracketed occurrence of x on the left
of this item [x]. Since every unbracketed occurrence of a variable gives origin to an
abstraction, we conclude that x is one of z1; : : : ; zs, and consequently x 4 zs. Thus, it follows from Ind˜z (x) = x ≺ zs = Ind˜z (M ) that M ∈ HRM˜z as well as Ind˜z (M ) = zs.
For = x , there is M = T(x ) = x: M , where M = T( ) with M ∈ HRM˜zx and Ind˜zx(M ) = x, hence x ∈ FV (M ). We conclude that M = x: M ∈ HRM˜z. On the other hand, since M is in the scope of variables z1; : : : ; zs, there must be unbracketed occurrences of variables z1; : : : ; zs (in this order, possibly separated by bracketed occurrences of variables) in ˜ on the left of x . Thus, ˜ is of the form ?zs[x1] : : : [xn]x , n¿0, for some sequence ? (containing unbracketed occurrences of z1; : : : ; zs−1). We conclude from the remark in the beginning of the proof that zs ∈ FV (M ), hence Ind˜z (M ) = zs.
Correct typing is guaranteed by the fact that the term M computed by T is (modulo
-conversion) in the set Terms(PT ) which has been shown (cf. Proposition 2.20) to
be a set of closed long normal inhabitants of . Here PT denotes the proof-tree

p0 pi1 ... ;
pin pf

where [xij11 ] : : : [xijnn ][xf1] is the subsequence of bracketed items in ˜. Note that if [xij11 ] : : : [xijnn ][xf1] is the subsequence of bracketed items in ˜, then ˜
has to be of the form xkl11 : : : xklss [xij11 ]˜xij11 [xij22 ]˜xij22 : : : [xijnn ][xf1], where Â = xk1 : : : xks , and where each subsequence ˜xij is the sequence of variables introduced by the use of variable xij in the expansion of and marked by the item [xij] in ˜. The sequence following [xijnn ] has to empty (but for the type a → a). Otherwise the variables in this sequence would still have to be used leading to further bracketed items in ˜.

Also note that if a variable with index s introduces a sequence of variables respec-

tively with indexes s1; : : : ; sm, then in the formula-tree of the formula the descendents

of the primitive part labelled with s are, respectively, labelled with s1; : : : ; sm. Thus, M = T( ˜) = xkl11 : : : xklss :xij11 ( ˜xij11 :xij22 ( ˜xij22 : : : : (xijnn xf1) : : :)).
On the other hand, when applying the algorithm Terms to PT , then in the ÿrst step

the application x0(xi1 (xi2 : : : (xin xf) : : :)) is formed. Then, before the argument of each of x0; xi1 ; : : : ; xin an abstraction sequence ˜x0; ˜xi1 ; : : : ; ˜xin is introduced and x0 is deleted from the top, leading to the term-scheme ˜x0:xi1 ( ˜xi1 : xi2 ( ˜xi2 : : : : (xin ( ˜xin : xf)) : : :)). Also here the abstraction sequence that is introduced before the argument of an variable with

index s is the sequence of variables indexed with the labels of the primitive parts that

in the formula-tree descend from the primitive part labelled with s. It follows from the

remark in the footnote, which guarantees that no primitive parts descend in the formula-

tree that

from the primitive part ˜x0 = xkl11 : : : xklss . Thus,

labelled with in, that ˜xin the term-scheme can in

is in fact an empty sequence and fact be obtained from M erasing

the superscripts of variables and on the other hand M will be one of the terms obtained

from this term-scheme in the third step of the algorithm Terms.

404 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408
5. Decidability for arity-1 formulas
In order to prove decidability for arity-1 formulas, it remains to show decidability of termination of rewriting-systems. We begin with a result on sequences of n-tuples of non-negative integers.
5.1. The ÿniteness of non-ascending N n-sequences
Let = a1; : : : ; ai; : : : be a sequence of n-tuples on non-negative integers, ai = a1i ; : : : ; ain ∈ N n, where aij ∈ N represents the jth position of tuple ai.
We deÿne a partial order on n-tuples as follows:
a6b i aj6bj for 1 6 j 6 n:
The sequence is non-ascending i for any i¡k we have ai6ak . Note that in a non-ascending sequence it follows that ai = ak for i = k.
We want to prove that any non-ascending sequence of n-tuples in N n is ÿnite. This result is, in fact, equivalent to Kripke’s Lemma, cf. [1], and to some other known results such as the inÿnite division principle by Meyer, cf. [9], or to Dickson’s Lemma in number theory, cf. [6], that can be obtained from Hilbert’s Finite Basis Theorem, cf. [7]. These powerful results have been used in various areas among which in decidability proofs for some fragments of relevant systems, cf. [11].
Theorem 5.1. Let = a1; : : : ; ai; : : : be a non-ascending sequence of tuples in N n. Then is ÿnite.
Proof. Suppose, for the sake of contradiction, that is inÿnite. There cannot be any bounding value on the elements of the sequence, otherwise all elements of the sequence
would be inside an n-dimensional cube, but there are only ÿnitely many distinct elements inside an n-dimensional cube in N n.
So at least one of the dimensions is unbounded. Without loss of generality, suppose the ÿrst dimension is unbounded (otherwise we reorder the dimensions). Let us form a new sequence (1), a subsequence of ,
(1) = a(11); : : : ; a(i1); : : :
by deleting from all the elements in which the unbound ÿrst dimension is not strictly greater than the largest value so far of the ÿrst dimension. As a result, the inÿnite sequence that consists of the ÿrst dimension of (1) is strictly ascending.
If there is another unbounded dimension in (1), which without loss of generality we can suppose is the second dimension, we repeat this process above of extracting a sequence (2), where the second dimension is strictly ascending. Note that in this process the ÿrst dimension remains strictly ascending.
We repeat this process as long as there is an unbounded dimension. Suppose we have made this process m times, 16m6n, and we end up with an inÿnite subsequence

(m) of .

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

405

(m) = a(1m); : : : ; a(im); : : : :

At this point, we have m dimensions of strictly ascending values and n − m bounded dimensions in (m). Take a bounded dimension, say dimension m + 1. Since (m) is
inÿnite, there is a value cm+1 in dimension m + 1 that repeats inÿnitely. Now form a new subsequence (m+1) of (m) by deleting all values for which dimension m + 1 is di erent from cm+1, so that dimension m + 1 is constant in (m+1).
Repeat this process for all bounded dimensions. We end up with an inÿnite sequence (n), in which m dimensions are strictly ascending and m − n dimensions are constant. Since (n) is a subsequence of , this contradicts the fact that is non-ascending.
Therefore, the initial sequence cannot be inÿnite, which ÿnishes the proof.

The following lemma, similar to Konig’s lemma, will be used in the proof of Theorem 5.4, which leads to our main result.

Lemma 5.2. Let L be a set and 6 be a binary relation deÿned on L. Let T be any ÿnitely branching tree whose nodes are labelled by elements of L. Consider the following recursive procedure, where n is a node of T and S ⊆ L.
proc Visit(n,S): let l be the label of node n if there exists l ∈ S s.t. l 6l then return else for each descendent n of n do Visit(n , S ∪ {l})
If for any node n in T the call Visit(n,∅) does not terminate, then there exists an inÿnite sequence (li)i in L such that for all 06i¡j, one has li6lj.
Proof. The existence of a sequence (li)i is easily established as follows: assume that Visit(n0,∅) does not terminate for some node n0. Then, since the tree is ÿnitely branching, there is at least one descendent n1 of n0 such that Visit(n1,{l0}) also does not terminate, where l0 is the label of n0. But then there is also a direct descendent n2 of n1, such that Visit(n2,{l0; l1}) does not terminate, where l1 is the label of n1 and l06l1. Similarly, we can conclude that there is a descendent n3 of n2, such that Visit(n3,{l0; l1; l2}) does not terminate, where l2 is the label of n2 and such that l06l1, l06l2 and l16l2. Since Visit(n,∅) does not terminate, it is possible to repeat this procedure indeÿnitely.

5.2. Deciding termination of rewriting-systems

The following Lemma will be used in order to prove decidability of termination of rewriting-systems.

406 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408
Lemma 5.3. Consider a rewriting-system R and a typed sequence , such that expands successfully with R. Then, there is at least one successful expansion sequence
= 1; : : : ; n such that for all i; j with 16i¡j6n, the typed sequences i and j do not satisfy at least one of the following conditions: • the type-variable in i and j is the same; • the last term-variable in i and j is the same; • in i and j the same term-variables occur; • for every variable x such that kx occurrences of x in i have not been used in a
non-ÿnal position in the expansion of to i, there are at least kx occurrences of x in j that have not been used in a non-ÿnal position in the expansion of to j.
Proof. Consider a successful expansion sequence = 1; : : : ; i; : : : ; j; : : : ; j+k from to j+k of length j + k, where i; j; k¿0, j¿i and such that • the type-variable in i and j is the same; • the last term-variable in i and j is the same; • in i and j the same term-variables occur; • for every variable x such that kx occurrences of x in i have not been used in a
non-ÿnal position in the expansion of to i, there are at least kx occurrences of x in j that have not been used in a non-ÿnal position in the expansion of to j. Then, another successful expansion sequence = 1; : : : ; i = i; i+1; : : : ; i+k of length i + k¡j + k can be obtained by the following. For l = 0; : : : ; k − 1, suppose that j+l+1 was obtained from j+l using rule xl :: Al →˜xl :: Bl. Then expand i+l with this same rule and using the leftmost occurrence of xl in i+l that has not been used in a non-ÿnal position in the expansion of to i+l, if any, or otherwise any other occurrence of xl in i+l. Now repeat the whole process to this new, shorter successful expansion sequence, as long as necessary.
Theorem 5.4. Termination of rewriting-systems over typed sequences is decidable.
Proof. Let R = (Â; R; xf :: Cf) be a rewriting-system in which occur n¿0 termvariables x1; : : : ; xn (after renaming if necessary) and m¿0 type-variables A1; : : : ; Am. Given an expansion sequence 1; 2; : : : we associate with each typed sequence i in this expansion a tuple Li = (ai; Vi; xi; Ai), with ai = a1i ; : : : ; ain ∈ N n, Vi ⊆ {x1; : : : ; xn}, xi ∈ {x1; : : : ; xn} and Ai ∈ {A1; : : : ; Am} by the following: • For j = 1; : : : ; n let aij be the number of occurrences of xj in i that have not been
used in a non-ÿnal position during the expansion of 1 to i; • let Vi be the set of variables occurring in i; • let xi be the last variable in i; • and ÿnally let Ai be the type-variable in i. We call a typed sequence j in this expansion a repetition of another typed sequence
i with i¡j if and only if ai6aj, Vi = Vj, xi = xj and Ai = Aj, in which case we write that Li6Lj. We know from Lemma 5.3 that if R is terminating, then there is at least one repetition-free successful expansion sequence starting with the initial sequence Â. On the other hand, there are only a ÿnite number of distinct Vk ’s, xk ’s as well as Ak ’s.

S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408

407

Thus, it follows from Theorem 5.1 that there are no inÿnite, repetition-free expansion
sequences, i.e. there is no inÿnite sequence of tuples (Li)i such that for any 06i¡j one has Li6Lj.
Consider the ÿnitely branching tree T deÿned by the following: the top-node is
labelled by the tuple L0 corresponding to the initial sequence 0 = Â. Furthermore, the descendents of a node labelled with a tuple Li are all (ÿnitely many) nodes labelled with tuples Li1 ; : : : ; Lini , corresponding to all the sequences i1 ; : : : ; ini that can be obtained in one expansion-step from i.
Finally, change procedure Visit to immediately stop if a successful, repetition-free
expansion sequence is reached, and apply it to T. Lemma 5.2 and the remark above
about the Li’s guarantee that this call terminates, thus making it a decision procedure.

Now we are able to conclude our main result.
Theorem 5.5. BB IW-inhabitation is decidable for arity-1 formulas.
Proof. It follows from Theorems 4.6 and 4.10 that an arity-1 formula is BB IWinhabited if and only if the corresponding rewriting-system R( ) is terminating. The decidability of the latter has been shown in Theorem 5.4.

6. Conclusions
We have shown the decidability of the arity-1 fragment of BB IW-logic using the termination of a special kind of rewriting-system. The decision procedure is based on the ÿniteness of non-ascending N n-sequences. The complexity of the decision procedure is bound to be quite costly, but yet undetermined. In fact, the results in [13] suggest that it is primitive recursive in the Ackermann function.
The method proposed here gets considerably more complicated if applied to the whole fragment, for then the rewriting-system will not be expanding a sequence but a tree. The relationship between the structure of BB IW- -terms and these tree-expanding rewriting-systems still has to be investigated.
And ÿnally, we have not ruled out the possibility of the whole BB IW-logic being undecidable. That undecidability, if proven, will have to depend on formulas that are not arity-1.

Acknowledgements
We would like to thank the anonymous referees for numerous comments which contributed to enhance the presentation.
The work presented in this paper has been partially supported by funds granted to LIACC through Programa de Financiamento Plurianual, Fundaca˜o para a Cieˆncia e Tecnologia and Programa POSI.

408 S. Broda et al. / Theoretical Computer Science 318 (2004) 373 – 408
References
[1] A.R. Anderson, N.D. Belnap, Entailment, Vol. I, Princeton University Press, USA, 1975. [2] H. Barendregt, Lambda calculi with types, in: S. Abramsky, D.M. Gabbay, T.S.E. Maibaum (Eds.),
Background: Computational Structures, Handbook of Logic in Computer Science, Vol. 2, Oxford Science Publications, 1992, pp. 117–309. [3] C.-B. Ben-Yelles, Type-assignment in the lambda-calculus; syntax and semantics, Ph.D. Thesis, Mathematics Department, University of Wales, Swansea, UK, 1979. [4] S. Broda, L. Damas, On the structure of normal -terms having a certain type, Proc. 7th WoLLIC’2000, 2000, pp. 33–43, copy in http://www.dcc.fc.up.pt/∼sbb/wollic00.ps. [5] M.W. Bunder, Proof ÿnding algorithms for implicational logics, Theoret. Comput. Sci. 232 (2000) 165–186. [6] L.E. Dickson, Finiteness of the odd perfect primitive abundant numbers with n distinct prime factors, Amer. J. Math. 35 (1913) 413–422. [7] D. Hilbert, Uber die Theorie der algebraischen Formen, Math. Ann. 36 (1890) 473–534. [8] J.R. Hindley, Basic Simple Type Theory, in: Cambridge Tracts in Theoretical Computer Science, Cambridge University Press, Cambridge, 1997. [9] R.K. Meyer, H. Ono, The Finite Model Property for BCK and BCIW, Studia Logica 53 (1) (1994) 107–118. [10] D. Prawitz, Natural Deduction, Almqvist and Wiksell, Sweden, 1965. [11] J. Riche, R.K. Meyer, Kripke, Belnap, Urquhart and relevant decidability & complexity, in: G. Gottlob, E. Grandjean, K. Seyr (Eds.), Computer Science Logic, CSL’98, Lecture Notes in Computer Science, Vol. 1584, Springer, Berlin, 1998, pp. 224–240. [12] P. Trigg, J.R. Hindley, M.W. Bunder, Combinatory abstraction using B, B and friends, Theoret. Comput. Sci. 135 (1994) 405–422. [13] A. Urquhart, The complexity of decision procedures in relevance logic, in: J.M. Dunn, A. Gupta (Eds.), Truth or Consequences, Essays in Honor of Nuel Belnap, Kluwer Academic Publishers, Dordrecht, 1990, pp. 61–76.

