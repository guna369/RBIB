Fully Homomorphic Encryption Using Ideal Lattices
Craig Gentry
Stanford University and IBM Watson
cgentry@cs.stanford.edu
ABSTRACT
We propose a fully homomorphic encryption scheme â€“ i.e.,
a scheme that allows one to evaluate circuits over encrypted
data without being able to decrypt. Our solution comes
in three steps. First, we provide a general result â€“ that,
to construct an encryption scheme that permits evaluation
of arbitrary circuits, it suffices to construct an encryption
scheme that can evaluate (slightly augmented versions of)
its own decryption circuit; we call a scheme that can evaluate
its (augmented) decryption circuit bootstrappable.
Next, we describe a public key encryption scheme using
ideal lattices that is almost bootstrappable. Lattice-based
cryptosystems typically have decryption algorithms with low
circuit complexity, often dominated by an inner product
computation that is in NC1. Also, ideal lattices provide
both additive and multiplicative homomorphisms (modulo a
public-key ideal in a polynomial ring that is represented as
a lattice), as needed to evaluate general circuits.
Unfortunately, our initial scheme is not quite bootstrap-
pable â€“ i.e., the depth that the scheme can correctly evalu-
ate can be logarithmic in the lattice dimension, just like the
depth of the decryption circuit, but the latter is greater than
the former. In the final step, we show how to modify the
scheme to reduce the depth of the decryption circuit, and
thereby obtain a bootstrappable encryption scheme, with-
out reducing the depth that the scheme can evaluate. Ab-
stractly, we accomplish this by enabling the encrypter to
start the decryption process, leaving less work for the de-
crypter, much like the server leaves less work for the de-
crypter in a server-aided cryptosystem.
Categories and Subject Descriptors: E.3 [Data En-
cryption]: Public key cryptosystems
General Terms: Algorithms, Design, Security, Theory
1. INTRODUCTION
We propose a solution to the old open problem of con-
structing a fully homomorphic encryption scheme. This no-
tion, originally called a privacy homomorphism, was intro-
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee.
STOCâ€™09, May 31â€“June 2, 2009, Bethesda, Maryland, USA.
Copyright 2009 ACM 978-1-60558-506-2/09/05 ...$5.00.
duced by Rivest, Adleman and Dertouzos [54] shortly af-
ter the invention of RSA by Rivest, Adleman and Shamir
[55]. Basic RSA is a multiplicatively homomorphic encryp-
tion scheme â€“ i.e., given RSA public key pk = (N, e) and
ciphertexts {Ïˆi â† piei mod N}, one can efficiently computeâˆ
i Ïˆi = (
âˆ
i pii)
e mod N , a ciphertext that encrypts the
product of the original plaintexts. Rivest et al. [54] asked
a natural question: What can one do with an encryption
scheme that is fully homomorphic: a scheme E with an effi-
cient algorithm EvaluateE that, for any valid public key pk,
any circuit C (not just a circuit consisting of multiplication
gates), and any ciphertexts Ïˆi â† EncryptE(pk, pii), outputs
Ïˆ â† EvaluateE(pk, C, Ïˆ1, . . . , Ïˆt) ,
a valid encryption of C(pi1, . . . , pit) under pk? Their answer:
one can arbitrarily compute on encrypted data â€“ i.e., one can
process encrypted data (query it, write into it, do anything
to it that can be efficiently expressed as a circuit) without
the decryption key. As an application, they suggested pri-
vate data banks: a user can store its data on an untrusted
server in encrypted form, yet still allow the server to pro-
cess, and respond to, the userâ€™s data queries (with responses
more concise than the trivial solution: the server just sends
all of the encrypted data back to the user to process). Since
then, cryptographers have accumulated a list of â€œkillerâ€ ap-
plications for fully homomorphic encryption. However, prior
to this proposal, we did not have a viable construction.
1.1 Homomorphic Encryption
A homomorphic public key encryption scheme E has four
algorithms KeyGenE , EncryptE , DecryptE , and an additional
algorithm EvaluateE that takes as input the public key pk, a
circuit C from a permitted set CE of circuits, and a tuple of
ciphertexts Î¨ = ã€ˆÏˆ1, . . . , Ïˆtã€‰; it outputs a ciphertext Ïˆ. The
computational complexity of all of these algorithms must
be polynomial in security parameter Î» and (in the case of
EvaluateE) the size of C. E is correct for circuits in CE if,
for any key-pair (sk,pk) output by KeyGenE(Î»), any circuit
C âˆˆ CE , any plaintexts pi1, . . . , pit, and any ciphertexts Î¨ =
ã€ˆÏˆ1, . . . , Ïˆtã€‰ with Ïˆi â† EncryptE(pk, pii), it is the case that:
Ïˆ â† EvaluateE(pk, C,Î¨) â‡’ C(pi1, . . . , pit) = DecryptE(sk, Ïˆ)
By itself, mere correctness does not exclude trivial schemes.1
So, we require ciphertext size and decryption time to be up-
1In particular, we could define EvaluateE(pk, C,Î¨) to just
output (C,Î¨) withoutâ€œprocessingâ€ the circuit or ciphertexts
at all, and DecryptE to decrypt the component ciphertexts
and apply C to results.
169
per bounded by a function of the security parameter Î», in-
dependently of C (or perhaps, as a relaxation, dependent on
the depth of C, but not the size).
Definition 1 (Homomorphic Encryption). E is ho-
momorphic for circuits in CE if E is correct for CE and
DecryptE can be expressed as a circuit DE of size poly(Î»).
Definition 2 (Fully Homomorphic Encryption).
E is fully homomorphic if it is homomorphic for all circuits.
Definition 3 (Leveled Fully Hom. Encryption).
A family of schemes {E (d) : d âˆˆ Z+} is leveled fully homo-
morphic if they all use the same decryption circuit, E (d) is
homomorphic for all circuits of depth at most d (that use
some specified set of gates Î“), and the computational com-
plexity of E (d)â€™s algorithms is polynomial in Î», d, and (in
the case of EvaluateE(d) ) the size of C.
Remark 1. One may desire â€“ e.g., for the two-party com-
putation setting â€“ the additional property that EncryptE and
EvaluateE have the same output distribution, or that there
is at least some post-hoc randomization procedure that in-
duces the same output distribution. We discuss such circuit
privacy in Section 7.
Here, we focus on constructing a scheme that is semanti-
cally secure against chosen plaintext attacks (or justâ€œseman-
tically secureâ€). Unfortunately a scheme that has nontriv-
ial homomorphisms cannot be semantically secure against
adaptive chosen ciphertext attacks (CCA2), since it is mal-
leable. There are relaxed notions of CCA2 security [3, 16,
52], but they do not apply to a fully homomorphic scheme.
However, constructing a CCA1-secure fully homomorphic
encryption scheme is an interesting open problem.
1.2 Our Results
We construct a fully homomorphic encryption scheme us-
ing ideal lattices. The result can roughly be broken down
into three steps: a general â€œbootstrappingâ€ result, an â€œinitial
constructionâ€using ideal lattices, and a technique toâ€œsquash
the decryption circuitâ€ to permit bootstrapping.
Our research began with the second step: a PKE scheme
E1 described in Section 3 that uses ideal lattices and is homo-
morphic for shallow circuits. A ciphertext Ïˆ has the form
v + x where v is in the ideal lattice and x is an â€œerrorâ€
or â€œoffsetâ€ vector that encodes the plaintext pi. Interpret-
ing ciphertext vectors as coefficient vectors of elements in a
polynomial ring Z[x]/f(x), we add and multiply ciphertexts
using ring operations â€“ Ïˆ â† Ïˆ1 + Ïˆ2 or Ïˆ â† Ïˆ1 Ã— Ïˆ2 â€“ and
induce addition and multiplication of the underlying plain-
texts. By itself, this scheme improves upon prior work. It
compares favorably to Boneh-Goh-Nissim [11]; it is homo-
morphic for circuits with greater multiplicative depth while
allowing essentially unlimited additions. The security of E1
is based on a natural decisional version of the closest vector
problem for ideal lattices for ideals in a fixed ring.
E1 is homomorphic only for shallow circuits because the
â€œerrorâ€ vector grows with addition and (especially) multi-
plication operations; eventually, it becomes so long that it
causes a decryption error. It is natural to ask: can we â€œre-
freshâ€ a ciphertext whose error vector is almost too long to
obtain a new ciphertext whose error vector is shorter? Ob-
viously, we could refresh a ciphertext if we could completely
decrypt it! This is the idea behind bootstrapping: we do
decrypt the ciphertext, but homomorphically!
Specifically, suppose E is bootstrappable with plaintext
space P is {0, 1}, and that circuits are boolean. Suppose we
have a ciphertext Ïˆ1 that encrypts pi under pk1, which we
want to refresh. So that we can decrypt it homomorphically,
suppose we also have sk1, the secret key for pk1, encrypted
under a second public key pk2: let sk1j be the encrypted
secret key bits. Consider the following algorithm.
RecryptE(pk2, DE , ã€ˆsk1jã€‰, Ïˆ1).
Set Ïˆ1j
Râ† EncryptE(pk2, Ïˆ1j)
Output Ïˆ2 â† EvaluateE(pk2, DE , ã€ˆã€ˆsk1jã€‰, ã€ˆÏˆ1jã€‰ã€‰)
Above, Evaluate takes in the bits of sk1 and Ïˆ1, each en-
crypted under pk2. Then, E is used to evaluate the de-
cryption circuit homomorphically. The output Ïˆ2 is thus an
encryption under pk2 of DecryptE(sk1, Ïˆ1) = pi.
2 Applying
the decryption circuit DE removes the error vector associ-
ated to the first ciphertext, but EvaluateE simultaneously
introduces a new error vector. Intuitively, we have made
progress as long as the second error vector is shorter.
Suppose CE contains not just DE but also the augmen-
tation of DE by NAND (i.e., a NAND gate connecting two
copies of DE). Then, we say E is bootstrappable.
Theorem 1 (Informal). One can construct a (seman-
tically secure) family {E (d)} of leveled fully homomorphic en-
cryption schemes from any (semantically secure) bootstrap-
pable encryption scheme E .
E (d)â€™s public key contains d+ 1 E public keys, basically one
for each level of the circuit, and an acyclic chain of encrypted
secret keys. It evaluates a d-depth NAND-circuit as follows:
given ciphertexts encrypted under pki associated to wires
at the ith level of the circuit, it Recrypts them so that they
become encrypted under pkiâˆ’1, applies the NAND gates at
that level, and recurses for i âˆ’ 1. If E securely encrypts
key-dependent messages (is KDM-secure) [9, 24, 12] â€“ i.e.,
roughly, if providing a ciphertext that encrypts a function
of the secret key does not hurt security â€“ then the E public
keys need not be distinct; we can have a â€œloop,â€ even a â€œself-
loop,â€ of encrypted secret keys, and the derived scheme is
fully homomorphic. See Section 2 for formal details.
In Section 4, we describe a scheme E2 that â€œtweaksâ€ E1,
analyze the complexity of its decryption circuit, and explain
why we are unable to prove that it is bootstrappable. In
Section 5, we describe a transformation of E2, labeled E3,
where the E3 public key contains a set of vectors with a secret
sparse subset whose sum is related to E2 secret key. This
allows us to re-express decryption as a sparse subset vector
sum rather than a full matrix-vector product, which requires
a circuit of lower depth, permitting bootstrapping. It also
entails an additional assumption: roughly, that it is hard to
distinguish a set that has a sparse subset with a known sum
from a set that is uniform. Similar assumptions have been
analyzed in connection with server-aided decryption.
Theorem 2 (Informal). E3 is bootstrappable and is
semantically secure (under two assumptions).
2Recrypt implies a one-way proxy re-encryption scheme [10].
170
1.3 Other Related Work
Homomorphic encryption schemes that are not semanti-
cally secure, like basic RSA, may also have stronger attacks
on their one-wayness. Boneh and Lipton [13] proved that
any algebraic privacy homomorphism over a ring Zn can be
broken in sub-exponential time under a (reasonable) num-
ber theoretic assumption, if the scheme is deterministic or
otherwise offers an equality oracle. See also [35] and [18].
Goldwasser and Micali [23] proposed the first semanti-
cally secure homomorphic encryption scheme (and also in-
troduced the notion of semantic security). Their scheme
is â€œadditively homomorphicâ€ over Z2; in our terminology,
its set CE of permitted circuits contains circuits with XOR
gates. Other additively homomorphic encryption schemes
with proofs of semantic security are Benaloh [8], Naccache-
Stern [42], Okamoto-Uchiyama [46], Paillier [47], and Damgard-
Jurik [19]. Some additively homomorphic encryption schemes
use lattices or linear codes [22, 50, 27, 36, 37, 4]. ElGamal
[20] is multiplicatively homomorphic.
Semantically secure schemes that allow both addition and
multiplication include Boneh-Goh-Nissim [11] (quadratic for-
mulas) and â€œPolly Crackerâ€ by Fellows and Koblitz [21, 29,
30, 31] (arbitrary circuits but with exponential ciphertext-
size blow-up). Sanders, Young and Yung [56, 7] (SYY) use
circuit-private additively homomorphic encryption to con-
struct a circuit-private scheme that can handle NC1 circuits.
Ishai and Paskin [26] do this for branching programs, which
covers NC1 circuits (by Barrington [6]), and ciphertexts in
their scheme are much shorter â€“ proportional to the length
of the branching program rather than its size, though the
computation is proportional to the size.
2. BOOTSTRAPPABLE ENCRYPTION
To be bootstrappable, E needs to be able to evaluate not
only its decryption circuit, which merely allows recryptions
of the same plaintext, but also slightly augmented versions of
it, so that we can perform nontrivial operations on plaintexts
and make progress through a circuit.
Definition 4 (Augmented Decryption Circuit).
Let Î“ be a set of gates with inputs and output in plaintext
space P including the identity gate (input and output are the
same). For gate g âˆˆ Î“, the g-augmented decryption circuit
consists of a g-gate connecting multiple copies of DE (the
number of copies equals the number of inputs to g), where
DE takes a secret key and ciphertext as input formatted as
elements of P`(Î»). We denote the set of g-augmented de-
cryption circuits, g âˆˆ Î“, by DE(Î“).
Definition 5 (Bootstrappable Encryption). Let CE
be a set of circuits with respect to which E is homomorphic.
We say that E is bootstrappable with respect to Î“ if
DE(Î“) âŠ† CE .
For a family of schemes {E (d)} derived from E that we will
define momentarily, we have the following theorems.
Theorem 3. Let E be bootstrappable with respect to a set
of gates Î“. Then the family {E (d)} is leveled fully homomor-
phic (for circuits with gates in Î“).
Theorem 4. Let A be an algorithm that breaks the se-
mantic security of E (d) with advantage . Then, there is an
algorithm B that breaks the semantic security of E with prob-
ability at least /`(d+ 1), for ` as in Definition 4, and time
poly(`, d) times that of A.
Note that Î“ is arbitrary in Theorem 3. For example, each
gate in Î“ could be a circuit of (ANDs, ORs, NOTs) of depth
m and fan-in 2; for this value of Î“, Theorem 3 implies the
scheme correctly evaluates â€œnormalâ€ circuits of depth d Â·m.
Now we specify the leveled fully homomorphic scheme.
Let E be bootstrappable with respect to a set of gates Î“. For
any integer d â‰¥ 1, we use E to construct a scheme E (d) =
(KeyGenE(d) , EncryptE(d) , EvaluateE(d) , DecryptE(d)) that can
handle all circuits of depth d with gates in Î“. When we refer
to the level of a wire in C, we mean the level of the gate for
which the wire is an input. We use the notation DE(Î“, Î´) to
refer to the set of circuits that equal a Î´-depth circuit with
gates in Î“ augmented by DE (copies of DE become inputs
to the Î´-depth circuit).
KeyGenE(d) (Î», d). Takes as input a security parameter Î» and
a positive integer d. For ` = `(Î») as in Definition 4, it sets
(ski,pki)
Râ† KeyGenE(Î») for i âˆˆ [0, d]
skij
Râ† EncryptE(pkiâˆ’1, skij) for i âˆˆ [1, d], j âˆˆ [1, `]
where ski1, . . . , ski` is the representation of ski as elements
of P . It outputs the secret key sk(d) â† sk0 and the pub-
lic key pk(d) â† (ã€ˆpkiã€‰, ã€ˆskijã€‰). For Î´ â‰¤ d, let E (Î´) refer to the
scheme using sk(Î´) â† sk0 and pk(Î´) â† (ã€ˆpkiã€‰iâˆˆ[0,Î´], ã€ˆskijã€‰iâˆˆ[1,Î´]).
EncryptE(d) (pk
(d), pi). Takes as input a public key pk(d) and a
plaintext pi âˆˆ P . It outputs a ciphertext Ïˆ Râ† EncryptE(pkd, pi).
DecryptE(d)(sk
(d), Ïˆ). Takes as input a secret key sk(d) and
a ciphertext Ïˆ (which should be an encryption under pk0).
It outputs DecryptE(sk0, Ïˆ).
EvaluateE(Î´) (pk
(Î´), CÎ´,Î¨Î´). Takes as input a public key pk
(Î´),
a circuit CÎ´ of depth at most Î´ with gates in Î“, and a tuple
of input ciphertexts Î¨Î´ (where each input ciphertext should
be under pkÎ´). We assume that each wire in CÎ´ connects
gates at consecutive levels; if not, add identity gates to make
it so. If Î´ = 0, it outputs Î¨0 and terminates. Otherwise, it
does the following:
â—¦ Sets (Câ€ Î´âˆ’1,Î¨â€ Î´âˆ’1)â† AugmentE(Î´) (pk(Î´), CÎ´,Î¨Î´).
â—¦ Sets (CÎ´âˆ’1,Î¨Î´âˆ’1)â† ReduceE(Î´âˆ’1) (pk(Î´âˆ’1), Câ€ Î´âˆ’1,Î¨â€ Î´âˆ’1).
â—¦ Runs EvaluateE(Î´âˆ’1) (pk(Î´âˆ’1), CÎ´âˆ’1,Î¨Î´âˆ’1).
AugmentE(Î´) (pk
(Î´), CÎ´,Î¨Î´). Takes as input a public key
pk(Î´), a circuit CÎ´ of depth at most Î´ with gates in Î“, and a
tuple of input ciphertexts Î¨Î´ (where each input ciphertext
should be under pkÎ´). It augments CÎ´ with DE ; call the
resulting circuit Câ€ Î´âˆ’1. Let Î¨
â€ 
Î´âˆ’1 be the tuple of ciphertexts
formed by replacing each input ciphertext Ïˆ âˆˆ Î¨Î´ by the
tuple ã€ˆã€ˆskÎ´jã€‰, ã€ˆÏˆjã€‰ã€‰, where Ïˆj â† EncryptE(Î´âˆ’1) (pk(Î´âˆ’1), Ïˆj)
and the Ïˆj â€™s form the properly-formatted representation of
Ïˆ as elements of P . It outputs (Câ€ Î´âˆ’1,Î¨â€ Î´âˆ’1).
ReduceE(Î´) (pk
(Î´), Câ€ Î´ ,Î¨
â€ 
Î´). Takes as input a public key pk
(Î´),
a tuple of input ciphertexts Î¨â€ Î´ (where each input ciphertext
should be an output of EncryptE(Î´) ), and a circuit C
â€ 
Î´ âˆˆ
DE(Î“, Î´+1). It sets CÎ´ to be the sub-circuit of C
â€ 
Î´ consisting
of the first Î´ levels. It sets Î¨Î´ to be the induced input
171
ciphertexts of CÎ´, where the ciphertext Ïˆ
(w)
Î´ associated to
wire w at level Î´ is set to EvaluateE(pkÎ´, C
(w)
Î´ ,Î¨
(w)
Î´ ), where
C
(w)
Î´ is the sub-circuit of C
â€ 
Î´ with output wire w, and Î¨
(w)
Î´
are the input ciphertexts for C
(w)
Î´ . It outputs (CÎ´,Î¨Î´).
Regarding the computational complexity of EvaluateE(d) :
Theorem 5. For a circuit C of depth at most d and size
s (defined here as the number of wires), the computational
complexity of applying EvaluateE(d) to C is dominated by at
most s Â· ` Â· d applications of EncryptE and at most s Â· d ap-
plications of EvaluateE to circuits in DE(Î“), where ` is as in
Definition 4.
As mentioned above, if E is KDM-secure, we can shorten
the public key to include pk and and an encryption of sk
under pk, a â€œself-loopâ€ rather than an acyclic chain of en-
crypted secret keys.3 This scheme is fully homomorphic,
with security following from KDM-security, and correctness
following from correctness of the above scheme.
3. AN INITIAL CONSTRUCTION
Our goal now is to construct an encryption scheme that
is bootstrappable with respect to a universal set of gates Î“
â€“ e.g., where Î“ includes NAND and the trivial gate. Here,
we describe an initial attempt. In Section 4, we describe
some tweaks to this construction and find that the decryp-
tion complexity is still too large to permit bootstrappability.
We finally achieve bootstrappability in Section 5.
3.1 The Initial Construction, Abstractly
We start by describing our initial attempt simply in terms
of rings and ideals; we bring in ideal lattices later. In our ini-
tial scheme E , we use a fixed ring R that is set appropriately
according to a security parameter Î». We also use a fixed
basis BI of a ideal I âŠ‚ R, and an algorithm IdealGen(R,BI)
that outputs public and secret bases BpkJ and B
sk
J of some
(variable) ideal J , such that I + J = R â€“ i.e., I and J are
relatively prime. (Actually, BskJ can be a basis of a (frac-
tional) ideal that contains J , rather than of J .) We assume
that if t âˆˆ R and BM is a basis for ideal M âŠ‚ R, then the
value t mod BM is unique and can be computed efficiently
â€“ i.e., the coset t+M has a unique, efficiently-computable
â€œdistinguished representativeâ€with respect to the basis BM .
We use the notation R mod BM to denote the set of distin-
guished representatives of r +M over r âˆˆ R, with respect
to the particular basis BM of M . We also use an algorithm
Samp(x,BI , R,BJ ) that samples from the coset x+ I .
In the scheme, Evaluate takes as input a circuit C whose
gates perform operations moduloBI . For example, an AddBI
gate in C takes two terms in R mod BI , and outputs a third
term in R mod BI , which equals the sum of the first two
terms modulo I .
KeyGen(R,BI). Takes as input a ring R and basis BI of I .
It sets (BskJ ,B
pk
J )
Râ† IdealGen(R,BI). The plaintext space
P is (a subset of) R mod BI . The public key pk includes R,
BI , B
pk
J , and Samp. The secret key sk also includes B
sk
J .
3Initially, we used Eâˆ— (with the self-loop) and tried to prove
KDM-security. Canetti [15] proposed the acyclic, leveled
approach to make this unnecessary.
Encrypt(pk, pi). Takes as input the public key pk and plain-
text pi âˆˆ P . It sets Ïˆâ€² â† Samp(pi,BI , R,BpkJ ) and outputs
Ïˆ â† Ïˆâ€² mod BpkJ .
Decrypt(sk, Ïˆ). Takes as input the secret key sk and a ci-
phertext Ïˆ. It outputs
pi â† (Ïˆ mod BskJ ) mod BI
Evaluate(pk, C,Î¨). Takes as input the public key pk, a cir-
cuit C in some permitted set CE of circuits composed of
AddBI and MultBI gates and a set of input ciphertexts Î¨.
It invokes Add and Mult, given below, in the proper sequence
to compute the output ciphertext Ïˆ. (We will describe CE
when we consider correctness below. If desired, one could
use different arithmetic gates.)
Add(pk, Ïˆ1, Ïˆ2). Outputs Ïˆ1 + Ïˆ2 mod B
pk
J .
Mult(pk, Ïˆ1, Ïˆ2). Outputs Ïˆ1 Ã— Ïˆ2 mod BpkJ .
Now, let us consider correctness, which is a highly non-
trivial issue in this paper. The following definitions provide
structure for our analysis.
To begin, we observe that the scheme is actually using two
different circuits. First, Evaluate takes a mod-BI circuit C
as input. This circuit is implicitly applied to plaintexts.
Second, Evaluate applies a circuit related to C, which we
call the generalized circuit, to the ciphertexts; this circuit
uses the ring operations (not modulo I).
Definition 6 (Generalized Circuit). Let C be a mod-
BI circuit. We say generalized circuit g(C) of C is the cir-
cuit formed by replacing Câ€™s AddBI and MultBI operations
with addition â€˜+â€™ and multiplication â€˜Ã—â€™ in the ring R.
Here are a few more definitions relevant to Theorem 6
below, which concerns correctness.
Definition 7 (XEnc and XDec). Let XEnc be the image
of Samp. Notice that all ciphertexts output by Encrypt are
in XEnc + J. Let XDec equal R mod B
sk
J , the distinguished
representatives of cosets of J wrt the secret basis BskJ .
Definition 8 (Permitted Circuits). Let
CEâ€² = {C : âˆ€(x1, . . . , xt) âˆˆ XEnct, g(C)(x1, . . . , xt) âˆˆ XDec}
In other words, CEâ€² is the set of mod-BI circuits that, when
generalized, the output is always in XDec if the inputs are in
XEnc. (The value t will of course depend on C.) If CE âŠ† CEâ€²,
we say that CE is a set of permitted circuits.
Definition 9. Ïˆ is a valid ciphertext wrt E public key pk
and permitted circuits CE if it equals Evaluate(pk, C,Î¨) for
some C âˆˆ CE , where each Ïˆ âˆˆ Î¨ is in the image of Encrypt.
Theorem 6. Assume CE is a set of permitted circuits
containing the identity circuit. E is correct for CE â€“ i.e.,
Decrypt correctly decrypts valid ciphertexts.
Proof. For Î¨ = {Ïˆ1, . . . , Ïˆt}, Ïˆk = pik + ik + jk, where
pik âˆˆ P , ik âˆˆ I , jk âˆˆ J , and pik + ik âˆˆ XEnc, we have
Evaluate(pk, C,Î¨) = g(C)(Î¨) mod BpkJ
âˆˆ g(C)(pi1 + i1, . . . , pit + it) + J
172
If C âˆˆ CE , we have g(C)(XEnc, . . . ,XEnc) âˆˆ XDec; so,
Decrypt(sk,Evaluate(pk, C,Î¨))
= g(C)(pi1 + i1, . . . , pit + it) mod BI
= g(C)(pi1, . . . , pit) mod BI
= C(pi1, . . . , pit)
as required.
The bottom line is that we have proven that E is correct
for permitted circuits, and our goal now is to maximize this
set. The permitted circuits are defined somewhat indirectly;
they are the circuits for which the â€œerrorâ€ g(C)(x1, . . . , xt)
of the output ciphertext is small (i.e., lies inside XDec) when
the input ciphertexts are in the image of EncryptE . When
we begin to instantiate the abstract scheme with lattices and
give geometric interpretations of XEnc and XDec, the problem
of maximizing CE will have a geometric flavor.
3.2 Security of the Abstract Construction
For an abstract â€œinstantiationâ€ of Samp that we describe
momentarily, we provide a simple proof of semantic security
based on the following abstract problem.
Definition 10 (Ideal Coset Problem (ICP)). Fix R,
BI , algorithm IdealGen, and an algorithm Samp1 that ef-
ficiently samples R. The challenger sets b
Râ† {0, 1} and
(BskJ ,B
pk
J )
Râ† IdealGen(R,BI). If b = 0, it sets r Râ† Samp1(R)
and t â† r mod BpkJ . If b = 1, it samples t uniformly from
R mod BpkJ . The problem: guess b given (t,B
pk
J ).
Basically the ICP asks one to decide whether t is uniform
modulo J , or whether it was chosen according to a known
â€œclumpierâ€ distribution induced by Samp1.
To get a proof based on the ICP, define Samp as follows.
Let s âˆˆ I be such that the ideal (s) is relatively prime to J .
(Assume for now that such an s can be efficiently generated.)
Samp(x,BI , R,B
pk
J ). Run r
Râ† Samp1(R). Output x+rÃ—s.
Obviously, the output is in x + I since s âˆˆ I . The value s
could be a fixed parameter wired into the algorithm Samp,
or generated dynamically from BI and B
pk
J according to a
prescribed distribution.
Theorem 7. Suppose that there is an algorithm A that
breaks the semantic security of E with advantage  when it
uses Samp. Then, there is an algorithm B, running in about
the same time as A, that solves the ICP with advantage /2.
Proof. The challenger sends B a ICP instance (t,BpkJ ).
B sets s, and sets the other components of pk in the obvious
way using the ICP instance. When A requests a challenge
ciphertext on one of pi0, pi1 âˆˆ P , B sets a bit Î² Râ† {0, 1} and
sends back Ïˆ â† piÎ² + tÃ— s mod BpkJ . A sends back a guess
Î²â€², and B guesses bâ€² â† Î² âŠ• Î²â€².
If b = 0, we claim that Bâ€™s simulation is perfect; in partic-
ular, the challenge ciphertext has the correct distribution.
When b = 0, we have that t = r + j, where r was chosen
according to Samp1 and j âˆˆ J . So, Ïˆ â† piÎ² + t Ã— s =
piÎ² + r Ã— s mod BpkJ ; the ciphertext is thus well-formed. In
this case A should have advantage , which translates into
an advantage of  for B.
If b = 1, then t is uniformly random modulo J . Since the
ideal (s) is relatively prime to J , tÃ— s is uniformly random
modulo J , and consequently Ïˆ is a uniformly random ele-
ment of R mod BpkJ that is independent of Î². In this case
Aâ€™s advantage is 0. Overall, Bâ€™s advantage is /2.
3.3 Background on Ideal Lattices
Let R = Z[x]/f(x), where f(x) âˆˆ Z[x] is monic and of
degree n. We view an element v âˆˆ R both as a ring element
and as a vector â€“ specifically, the coefficient vector v âˆˆ Zn.
The ideal (v) generated by v directly corresponds to the
lattice generated by the column vectors {v Ã— xi mod f(x) :
i âˆˆ [0, n âˆ’ 1]}; we call this the rotation basis of the ideal
lattice (v). Generally speaking, an ideal I âŠ‚ R need not be
principal â€“ i.e., have a single generator â€“ and a basis BI of I
need not be a rotation basis. R corresponds to the ideal (1)
or (e1), and to Z
n. The Hermite normal form (HNF) of a
lattice I is an upper triangular basis that can be efficiently
computable from any other basis of I , making it well-suited
to be a public key [39]. The index [R : I ] equals |det(BI)|;
since this is invariant, we refer to det(I).
As required by our abstract scheme, for any basis BI of
an ideal I âŠ† R, the term t mod BI is uniquely defined as
the vector tâ€² âˆˆ P(BI) such that t âˆ’ tâ€² âˆˆ I , where P(BI)
is the half-open parallelepiped P(B) â† {âˆ‘ni=1 xibi : xi âˆˆ
[âˆ’1/2, 1/2)}. The vector t mod BI is efficiently computable
as t âˆ’ B Â· bBâˆ’1 Â· te, where bÂ·e rounds the coefficients of a
vector to the nearest integer. We define the length â€–BIâ€– of
a basis to be max{â€–biâ€– : bi âˆˆ BI}.
Cryptographic work on ideal lattices includes NTRU [25]
and more recent work [41, 32, 33, 48, 49].
3.4 The Initial Construction, Concretely
When we implement the abstract construction using a
polynomial ring and ideal lattices as described in Section
3.3, the sets XEnc and XDec become subsets of Z
n. We re-
characterize these sets geometrically as follows.
Definition 11 (rEnc and rDec). Let rEnc be the smallest
value such that XEnc âŠ† B(rEnc), where B(r) is the ball of
radius r. Let rDec be the largest such that XDec âŠ‡ B(rDec).
Now, let us define a set of permitted circuits CE as follows:
CE = {C : âˆ€(x1, . . . , xt) âˆˆ B(rEnc)t, g(C)(x1, . . . , xt) âˆˆ B(rDec)}
CE is defined like the maximal set CE â€² of permitted circuits
in Definition 8, but we have replaced XEnc and XDec with
B(rEnc) and B(rDec). Clearly, CE âŠ† CE â€². (At several points
later in the paper, we narrow our set of permitted circuits
again so as to enable a less complex decryption algorithm.)
For fixed values of rEnc and rDec, what is CE? This is a
geometric problem, and we can bound the Euclidean length
â€–g(C)(x1, . . . ,xt)â€– by bounding the lengths of â€–u + vâ€– and
â€–uÃ— vâ€– in terms of â€–uâ€– and â€–vâ€–. For addition, this is easy:
using the triangle inequality, we have â€–u+ vâ€– â‰¤ â€–uâ€–+ â€–vâ€–
for u,v âˆˆ R. For multiplication, we can prove that â€–u Ã—
vâ€– â‰¤ Î³Mult(R) Â· â€–uâ€– Â· â€–vâ€–, where Î³Mult(R) is some factor that
is dependent only on the ring R. (See [32] for a different
definition of the expansion factor for multiplication.)
The following theorem characterizes the â€œerror expansionâ€
that a circuit can cause based on the circuitâ€™s depth.
Theorem 8. Suppose rE â‰¥ 1 and that circuit Câ€™s additive
fan-in is Î³Mult(R), multiplicative is 2, and depth is at most
log log rD âˆ’ log log(Î³Mult(R) Â· rE)
Then, C(x1, . . . ,xt) âˆˆ B(rD) for all x1, . . . ,xt âˆˆ B(rE).
173
Proof. For a d-depth circuit, let ri be an upper-bound on
the Euclidean norm of the values at level i, given that rd =
rE. By the triangle inequality, an addition (or subtraction)
gate at level i outputs some v âˆˆ R such that â€–vâ€– â‰¤ Î³Mult(R)Â·
ri. A multiplication gate at level i outputs some v âˆˆ R such
that â€–vâ€– â‰¤ Î³Mult(R) Â· r2i . In either case, riâˆ’1 â‰¤ Î³Mult(R) Â· r2i ,
and thus r0 â‰¤ (Î³Mult(R) Â· rE)2d . The result follows.
An (oversimplified) bottom line from Theorem 8 is that, to
maximize the depth of circuits that E can correctly evaluate
(see Theorem 6), we should minimize Î³Mult(R) and rEnc, and
maximize rDec. Most of the remainder of this subsection
consists of proposals toward this goal.
First, though, we observe that semantic security places a
limit on how large we can take rDec/rEnc. In concrete terms,
the ICP becomes (roughly): decide whether t is within a
small distance (less than rEnc) of the lattice J (according to
a distribution determined by Samp1), or is uniformly ran-
dom modulo J . This is a fairly natural decisional version
of the closest vector problem, though we are unaware of
an equivalent problem mentioned in the literature. Cer-
tainly rDec < Î»1(J), the latter being the length of the short-
est nonzero vector in J . On other hand, we cannot let
Î»1(J)/rEnc be too large (e.g., 2
n); otherwise, lattice reduc-
tion techniques, such as LLL [28, 5, 57], make it feasible
to recover the J-vector closest to t, which breaks the ICP.
However, given known attacks, this problem is infeasible for
a 2n
c
approximation factor when c < 1. Overall, the ratio
rDec/rEnc can also be sub-exponential. When rDec = 2
nc1 and
Î³Mult(R) Â·rEnc = 2nc2 , then Theorems 6 and 8 imply that the
scheme can correctly evaluate circuits of depth (c1âˆ’c2) log n.
Regarding Î³Mult(R), there are many f for which Î³Mult(R)
is only polynomial in n:
Theorem 9. Let R = Z[x]/f(x) and suppose f(x) =
xn âˆ’ h(x) where h(x) has degree at most nâˆ’ (n âˆ’ 1)/k for
k â‰¥ 2. Then, Î³Mult(R) â‰¤
âˆš
2n Â· (1 + 2n Â· (
âˆš
(k âˆ’ 1)nâ€–fâ€–)k).
As an example, f(x) = xnÂ±1 achieves Î³Mult(R) = âˆšn. Aside
from Theorem 9, we do not specify how to choose R; let us
assume it is chosen so that Î³Mult(R) is polynomial in n.
Regarding rEnc, recall that XEnc âŠ† B(rEnc) is the image
of Samp, where our security proof (Theorem 7) holds when
Samp(x,BI , R,B
pk
J ) runs r â† Samp1(R) and outputs x +
rÃ— s, where s âˆˆ I and the ideal (s) is relatively prime to J .
For simplicity, suppose that I is the principal ideal (s). Let
` be an upper bound on the length of r, drawn according to
Samp1. We have
rEnc = max{â€–x + rÃ— sâ€–} â‰¤ n Â· â€–BIâ€–+
âˆš
n Â· ` Â· â€–BIâ€–
Toward minimizing rEnc, we can choose s to be short â€“ e.g.,
use s = 2 Â· e1. The size of ` is a security issue. We need
it to be large enough so that the min-entropy of t mod BpkJ
in the ICP is large; taking ` to be polynomial in n suffices.
Overall, we can take rEnc to be polynomial in n. We note
that, even in this case, the plaintext space may be as large
as [R : I ] = det(I), which can be exponential in n.
Now, rDec, as the radius of the largest sphere centered at
0 that is circumscribed by BskJ , obviously depends crucially
on the secret basis. The important property of BskJ is its
shape â€“ i.e., we want the parallelepiped P(BskJ ) to be â€œfatâ€
enough to contain a large sphere. This property is easier
to formalize in terms of the inverse matrix (BskJ )
âˆ’1, whose
transpose is a basis (or independent set) of the fractional
ideal Jâˆ’1. (The fractional ideal Jâˆ’1 contains the elements
in Q[x]/f(x) that, when multiplied by any element in J , the
product is in R.)
Lemma 1. Let B be a lattice basis and Bâˆ— = (Bâˆ’1)T .
Let r be the radius of the largest sphere, centered at 0, cir-
cumscribed by P(B) (permitting tangential overlap). Then,
r = 1/(2 Â· â€–Bâˆ—â€–). In particular,
rDec = 1/(2 Â· â€–((BskJ )âˆ’1)T â€–)
Suppose â€–tâ€– < r; then each coefficient of Bâˆ’1 Â· t has magni-
tude at most 1/2.
Proof. Each coefficient of Bâˆ’1 Â· t is an inner product of
t with a column vector of Bâˆ—, and therefore has magnitude
at most â€–tâ€– Â· â€–Bâˆ—â€– < 1/2. This implies bBâˆ’1 Â· te = 0,
and thus t = (t mod B), and thus t âˆˆ P(B). Let v be
the longest vector in Bâˆ—, and let x be parallel to v. Then,
bBâˆ’1 Â· xe 6= 0 â€“ i.e., x 6= P(B) â€“ when |ã€ˆv,xã€‰| > 1/2 â‡”
â€–xâ€– > 1/(2 Â· â€–Bâˆ—â€–).
It is easy to imagine ad hoc ways of instantiating IdealGen
â€“ e.g., one could generate a random vector v and simply set
BskJ to be the rotation basis of v, and set B
pk
J to be the
HNF of (v). Very roughly speaking, if v is generated as a
vector that is very â€œnearly parallelâ€ to e1 (i.e., the vector
(1, 0, . . . , 0)), then the rotational basis will have rDec within
a small factor of â€–vâ€–/2. This method can be made to ensure
that rDec is within a polynomial factor of Î»1(J).
On the other hand, one may prefer to generate J according
to a â€œniceâ€ average-case distribution that permits a worst-
case / average-case reduction [1, 2, 53]. This is a technical
issue that we tackle in a separate work. We stress that our
analysis below regarding the decryption circuit does not rely
on any of the concrete proposals in this subsection â€“ e.g., the
analysis does not require I to be a principal ideal.
4. BOOTSTRAPPABLE YET?
Here, we describe two â€œtweaksâ€ to the scheme to lower the
decryption complexity in preparation for bootstrapping; we
label the tweaked scheme E2. Next, we analyze the decryp-
tion complexity (and find that it is too large). However,
some of the analysis applies to the final scheme.
We separate E2 from E1 because the former already im-
proves upon previous work, irrespective of bootstrapping.
The Boneh-Goh-Nissim (BGN) pairing-based cryptosystem
[11] was the first to permit efficient evaluation of quadratic
formulas that may have an arbitrary number of monomials.
However, BGN has a small plaintext space â€“ log Î» bits for
security parameter Î». E1 allows both greater multiplicative
depth in the circuit (while allowing essentially an arbitrary
number of additions) and also a larger plaintext space.
4.1 Some Tweaks to the Initial Construction
In each of the following tweaks, we slightly narrow our set
of permitted circuits CE . Recall from Section 3.4 that E1â€™s
definition of CE used B(rEnc) and B(rDec).
Tweak 1: Redefine the set of permitted circuits CE , replac-
ing B(rDec) with B(rDec/2).
Purpose: To ensure that ciphertext vectors are closer to
the lattice J than they strictly need to be, so that we will
need less â€œprecisionâ€ to ensure the correctness of decryption.
174
Recall that Decrypt computes (Ïˆ mod BskJ ) mod BI , where
Ïˆ mod BskJ = Ïˆ âˆ’ BskJ Â· b(BskJ )âˆ’1 Â· Ïˆe. If we permitted the
coefficients of (BskJ )
âˆ’1 Â· Ïˆ to be very close to half-integers,
we would need high precision to ensure correct rounding.
However, after Tweak 1, we have the following lemma:
Lemma 2. If Ïˆ is a valid ciphertext after Tweak 1, then
each coefficient of (BskJ )
âˆ’1 Â· Ïˆ is within 1/4 of an integer.
Proof. Observe that Ïˆ âˆˆ B(rDec/2)+J . Let Ïˆ = x+j for
x âˆˆ B(rDec/2) and j âˆˆ J . We have (BskJ )âˆ’1 Â· Ïˆ = (BskJ )âˆ’1 Â·
x + (BskJ )
âˆ’1 Â· j, where the former term has coefficients of
magnitude at most 1/4 by Lemma 1 and the latter is an
integer vector.
Per Theorem 8, the new maximum evaluation depth of the
scheme after Tweak 1 is log log(rDec/2) âˆ’ log log(Î³Mult(R) Â·
rEnc), which is less than the original amount by only a sub-
constant additive factor.
Tweak 2 is more technical and less â€œessentialâ€ than the
first tweak. It replaces matrix-vector multiplications with
ring multiplications. This is nice, but the two computations
are essentially equally parallelizable, and their circuits have
essentially the same depth. So, really, this tweak is primar-
ily useful for reducing the public key size and the per-gate
computation during bootstrapping in our ultimate scheme.
Tweak 2: From BI and B
sk
J , compute a short vector v
sk
J âˆˆ
Jâˆ’1 such that there exists u âˆˆ 1+I with uÃ—(vskJ )âˆ’1 âˆˆ 1+I .
Also, redefine CE again, now using B(2 Â·rDec/(n1.5 Â·Î³Mult(R)2 Â·
â€–BIâ€–)).
Purpose: To modify Decrypt from Ïˆ âˆ’ BskJ Â· b(BskJ )âˆ’1 Â·
Ïˆe mod BI to the simpler expression Ïˆâˆ’bvskJ Ã—Ïˆe mod BI ,
where vskJ âˆˆ Q[x]/f(x).
To use both tweaks, we need to reduce the radius of the
sphere in Tweak 2 by an additional factor of 2.
Tweak 2 requires us to reduce the permitted distance of
ciphertexts from the J-lattice much more than Tweak 1.
Still, it does not affect our maximum evaluation depth very
much when Î³Mult(R) and â€–BIâ€– are polynomial in n, and
rDec/rEnc is super-polynomial.
The following two lemmas say that we can perform Tweak
2 efficiently and that it has the expected effect â€“ i.e., the new
Decrypt equation works correctly.
Lemma 3. From BI and B
sk
J , we can compute in polyno-
mial time a vector vskJ âˆˆ Jâˆ’1 and a vector u âˆˆ 1 + I such
that uÃ—(vskJ )âˆ’1 âˆˆ 1+I. Moreover, â€–vskJ â€– â‰¤ (n/2) Â·Î³Mult(R) Â·
â€–((BskJ )âˆ’1)T â€– Â· â€–BIâ€–.
Lemma 4. Suppose Ïˆ is a valid ciphertext after Tweak 2
which decrypts to pi. Then, pi = Ïˆ âˆ’ bvskJ Ã— Ïˆe mod BI .
4.2 Decryption Complexity of Tweaked Scheme
To decrypt, we compute
(Ïˆ âˆ’Bsk1J Â· bBsk2J Â· Ïˆe) mod BI
where Ïˆ âˆˆ Zn, Bsk1J âˆˆ ZnÃ—n, Bsk2J âˆˆ QnÃ—n, and BI is a basis
of an ideal I of R = Z[x]/f(x). From Tweak 1, we have the
promise that the coefficients of Bsk2J Â· Ïˆ are all within 1/4
of an integer. Optionally, Tweak 2 ensures that Bsk1J is the
identity matrix and Bsk2J is a rotation matrix. We split the
decryption computation into the following sequence of steps:
Step 1: Generate n vectors with sum Bsk2J Â· Ïˆ
Step 2: From the n vectors x1, . . . ,xn, generate integer
vectors y1, . . . ,yn+1 with sum b
âˆ‘
xie.
Step 3: Compute pi â† Ïˆ âˆ’Bsk1J Â· (
âˆ‘
yi) mod BI
In Step 1, to obtain the n vectors, we perform the multi-
plications associated to the inner products associated to the
matrix-vector multiplication; we do not discuss this step in
detail, since (we will find that) Step 2 is already too expen-
sive to permit bootstrappability.
Regarding Step 2, recall that Evaluate takes as input cir-
cuits with mod-BI gates â€“ i.e., arithmetic gates whose in-
puts and outputs are in R mod BI . However, in general
â€œbase-BI ,â€ it is unclear how to handle the carries needed
for adding the vectors in Step 2 without resorting to high-
degree polynomials that require more multiplicative depth
that our initial construction can evaluate. To handle this
complication, we use the plaintext space P = {0, 1} mod BI ,
regardless of the underlying ideal I . We emulate boolean op-
erations, where carries are constant-depth. (This plaintext
space restriction is unnecessary if we use the initial construc-
tion without bootstrapping.) We have the following lemma.
Lemma 5. For i âˆˆ [1, t], let ai = (. . . , ai,1, ai,0, ai,âˆ’1, . . .)
be a real number given in binary representation mod BI with
the promise that
âˆ‘
i ai mod 1 âˆˆ [âˆ’1/4, 1/4]. There is a mod-
BI circuit C for generating t+ 1 integers z1, . . . , zt+1 (also
represented in binary) whose sum is bâˆ‘i aie, such that if
the generalized circuit g(C)â€™s inputs are in B(rin), then its
outputs are in B(rout) for:
rout â‰¤ (Î³Mult(R) Â· n Â· â€–BIâ€– Â· (1 + Î³Mult(R) Â· rin)t Â· t)polylog(t)
For â€–BIâ€– â‰¤ rin, t â‰¤ n, and Î³Mult(R) = nâ„¦(1), we have:
rout â‰¤ (Î³Mult(R) Â· rin)t+polylog(t)
Proof (fragment). Let aâˆ—i be the integer part of ai and
let aâ€ i = (ai,âˆ’1, ai,âˆ’2, . . .) be the fractional part. Let T =
dlog te+ 2. Let bi = (aâ€ i,âˆ’1, . . . , aâ€ i,âˆ’T ). First, we claim that
bâˆ‘ aâ€ i e = bâˆ‘ bie. This claim follows from the promise thatâˆ‘
i a
â€ 
i is within 1/4 of an integer, and that
âˆ£âˆ£âˆ£âˆ£âˆ£
âˆ‘
i
aâ€ i âˆ’
âˆ‘
i
bi
âˆ£âˆ£âˆ£âˆ£âˆ£ =
âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£
jâˆˆ[T+1,âˆ]âˆ‘
i
2âˆ’j Â· ai,âˆ’j
âˆ£âˆ£âˆ£âˆ£âˆ£âˆ£ < 1/4
Our t+ 1 output integers will be aâˆ—1, . . . , a
âˆ—
t , b
âˆ‘
bie.
Our strategy for computing bâˆ‘ bie is first to compute, for
each j âˆˆ [1, T ], the binary representation cj of the Hamming
weight of (b1,âˆ’j , . . . , bt,âˆ’j). Then, we finish by computing
the sum bâˆ‘Tj=1 2âˆ’j Â· cje; this latter term is much easier to
compute than the original term, since it only consists of T
numbers, rather than t.
This strategy is straightforward when I = (2 Â· e1) and the
plaintext space is {0, 1} mod I . The binary representation
of the Hamming weight of (b1, . . . , bt) is given by
(e2blog tc (b1, . . . , bt) mod 2, . . . , e20(b1, . . . , bt) mod 2)
where ei(x1, . . . , xt) is the ith elementary symmetric poly-
nomial over x1, . . . , xt. (See Lemma 4 of [14].) These poly-
nomials can be computed in time poly(t), and the fact that
rout is exponential in t comes from the fact that the degree
of these polynomials is upper bounded by t. There are minor
complications when I 6= (2 Â· e1) (omitted).
175
Unfortunately, Step 2 uses t = n, implying rDec/rEnc â‰¥
rout/rin â‰¥ 2n, and therefore the above analysis cannot show
that the initial construction is both bootstrappable and se-
cure. However, Lemma 5 will be relevant to our final scheme,
as will the following lemma regarding Step 3:
Lemma 6. Using a constant depth circuit having polyno-
mial fan-in AddBI gates and constant fan-in MultBI gates,
we can compute Ïˆ âˆ’ Bsk1J Â· (
âˆ‘
yi) mod BI from a binary
representation (using the bits {0, 1} mod BI) of the terms
of the expression.
The proof of Lemma 6 involves converting the binary rep-
resentation of the terms to a more â€œnaturalâ€ mod-BI repre-
sentation, at which point the computation is trivially obvi-
ously constant depth. As a toy example for intuition, sup-
pose we have mod-13 gates, where the numbers 0, . . . , 12 are
represented by 13 different â€œfrequenciesâ€ (not in terms of a
binary representation), and Add13 and Mult13 perform ad-
dition and multiplication modulo 13 â€œautomatically.â€ To ob-
tain the natural representation of r mod 13 as one of the 13
frequencies given the binary representation ...b1b0 (each bit
in {0, 1} mod 13), we precompute the aj â† 2j mod 13 and
output Add13(...,Mult13(a1, b1),Mult13(a0, b0)). This takes
constant depth even if r has a polynomial number of bits
using polynomial-fan-in Add13 gates. Essentially the same
considerations apply in the proof of Lemma 6. The simplest
case is where I = (2) and the conversion is unnecessary.
5. SQUASHING THE DEC. CIRCUIT
The circuit complexity of decryption in E2 is too high to
permit bootstrapping. The culprit is Step 2 â€“ i.e., adding
n numbers. Here, we describe how transform the scheme
so that Decrypt adds only a sub-linear quantity of numbers.
Importantly, this transformation does not affect the set of
permitted circuits at all. However, the transformation does
induce an additional hardness assumption. By choosing pa-
rameters appropriately, the scheme becomes bootstrappable.
5.1 The Transformation, Abstractly
At a high level, our transformation works by splitting the
initial decryption algorithm into two phases â€“ an initial com-
putationally intensive preprocessing phase performed with-
out the secret key (by the encrypter), followed by a com-
putationally lightweight phase using the secret key (by the
decrypter). In short, the encrypter preprocesses its own ini-
tial ciphertext, leaving less work for the decrypter to do.
Interestingly, this two-phase approach to decryption is pre-
cisely what one finds in server aided cryptography.
In detail, let Eâˆ— be an initial encryption scheme (which
concretely will become E2). From Eâˆ—, we construct a modi-
fied scheme E that uses two new algorithms, SplitKeyE and
ExpandCTE , that will remain abstract for now.
KeyGenE(Î»). Runs (pk
âˆ—, skâˆ—)
Râ† KeyGenEâˆ—(Î») and (sk, Ï„ ) Râ†
SplitKeyE(sk
âˆ—,pkâˆ—). The secret key is sk. The public key pk
is (pkâˆ—, Ï„ ).
EncryptE(pk, pi). Runs Ïˆ
âˆ— â† EncryptEâˆ— (pkâˆ—, pi). It then
sets Ïˆ to include Ïˆâˆ— and the output of ExpandCTE(pk, Ïˆ
âˆ—).
(ExpandCTE makes heavy use of tag Ï„ .)
DecryptE(sk, Ïˆ). Uses sk and the expanded ciphertext to
decrypt more efficiently. DecryptE(sk, Ïˆ) should work when-
ever DecryptEâˆ— (sk
âˆ—, Ïˆâˆ—) works.
AddE(pk, Ïˆ1, Ïˆ2). Extracts (Ïˆâˆ—1 , Ïˆ
âˆ—
2) from (Ïˆ1, Ïˆ2), computes
Ïˆâˆ— â† AddEâˆ—(pkâˆ—, Ïˆâˆ—1 , Ïˆâˆ—2), and outputs Ïˆ which includes Ïˆâˆ—
and the output of ExpandCTE(pk, Ïˆ
âˆ—). MultE(pk, Ïˆ1, Ïˆ2) is
analogous.
The security of the transformation relies on the following
problem, which is completely abstract at this point.
Definition 12 (SplitKey Distinguishing Problem).
The challenger sets (skâˆ—, pkâˆ—)
Râ† KeyGenEâˆ— and b Râ† {0, 1}.
If b = 0, it sets (sk, Ï„ )
Râ† SplitKey(skâˆ—,pkâˆ—). If b = 1, it
sets (sk, Ï„ )
Râ† SplitKey(âŠ¥,pkâˆ—), where âŠ¥ is a special symbol.
The problem: guess b given (Ï„, skâˆ—,pkâˆ—).
Theorem 10. Suppose that there is an algorithm A that
breaks the semantic security of E above with advantage .
Then, there exist algorithms B0 and B1, running in about the
same time as A, such that either B0â€™s advantage against the
SplitKey Distinguishing Problem or B1â€™s advantage against
the semantic security of Eâˆ— is at least /3.
5.2 The Transformation, Concretely
Let (skâˆ—,pkâˆ—) be an E2 key pair. Let Î³set(n) and Î³subset(n)
be functions, where the former is Ï‰(n) and poly(n) and the
latter is Ï‰(1) and o(n). Here are the concrete instantiations
SplitKeyE , ExpandCTE , and DecryptE used to construct E3.
SplitKeyE(sk
â€ ,pkâˆ—). Takes as input skâ€ , which may be either
skâˆ— or âŠ¥. If the former, it extracts the vector vskâˆ—J from skâˆ—;
if the latter, it sets vsk
âˆ—
J â† 0. It outputs (sk, Ï„ ), where:
â€¢ Ï„ is a set of Î³set(n) vectors t1, . . . , tÎ³set(n) that are
uniformly random in Jâˆ’1 mod BI , except there exists
a subset S âŠ† {1, . . . , Î³set(n)} of cardinality Î³subset(n)
such that
âˆ‘
iâˆˆS ti âˆˆ vsk
âˆ—
J + I .
â€¢ sk is a matrix Î³subset(n)Ã—Î³set(n) matrix M of 0â€™s and
1â€™s, where Mij = 1 iff j is the ith member of S.
ExpandCTE(pk, Ïˆ
âˆ—). Outputs ci â† ti Ã— Ïˆâˆ— mod BI for i âˆˆ
[1, Î³set(n)]. These terms are represented in binary using
{0, 1} mod BI , as in E2.
DecryptE(sk, Ïˆ). Takes as input the secret key sk and a
ciphertext Ïˆ. It performs the following steps:
Step 0: Set the vectors wij â†Mij Â· cj
Step 1: Set the vectors xi â†
âˆ‘Î³set(n)
j=1 wij
Step 2: From Î³subset(n) vectors x1, . . . ,xn, generate integer
vectors y1, . . . ,yÎ³subset(n)+1 with sum b
âˆ‘
xie.
Step 3: Compute pi â† Ïˆ âˆ’ (âˆ‘ yi) mod BI
SplitKeyE splits v
skâˆ—
J into Ï„ , which is a set of vectors with
a hidden sparse subset whose sum is vsk
âˆ—
J modulo I , and sk,
which is a set of incidence matrix encoding the subset. To
generate Ï„ , one may, for example, just set t1, . . . , tÎ³set(n)âˆ’1
to be uniformly random vectors in Jâˆ’1 âˆ©P(BI). Then, one
sets tÎ³set(n) â† vsk
âˆ—
J âˆ’
âˆ‘Î³subset(n)âˆ’1
i=1 ti mod BI . Then one
permutes the vectors.
In DecryptE , Steps 2 and 3 are as in E2 (Section 4), with
the crucial difference that Step 2 adds only Î³subset(n) vec-
tors. In Steps 0 and 1, DecryptE sets xi to be the Î³subset(n)
â€œrelevantâ€ vectors in {ci} â€“ i.e., the ones associated to the
subset. Correctness should be clear.
Without Tweak 2, we could have instead used a Î³set(n)-
sized set of matrices with a hidden Î³subset(n)-sized subset
whose sum is related to (BskJ )
âˆ’1. This would have resulted
in a larger public key.
176
5.3 Bootstrapping Achieved
We analyzed Steps 2 and 3 in Section 4.2. It is obvious
that Step 0 requires only constant depth. We claim that
Step 1 requires only constant depth, but why? Comput-
ing
âˆ‘Î³set(n)
j=1 wij is very cheap because, in the set {wij :
j âˆˆ [1, Î³set(n)}, there is only one nonzero vector. There-
fore, when we add the vectors, no expensive carry opera-
tions are required; we simply â€œXORâ€ the vectors together
using polynomial-fan-in AddBI operations, using constant
depth. At last, we have the following theorem.
Theorem 11. The scheme E3 is bootstrappable when
Î³subset(n) â‰¤
(
log(rDec/m)
Î± Â· 2c Â· log(Î³Mult(R) Â· rEnc)
)
where m arises from the re-definition of CE in the Tweaks
(m = 2 when just Tweak 1 is used), Î± > 1 is chosen so that
(Î± âˆ’ 1) Â· Î³subset(n) is greater than the polylog(Î³subset(n))
term coming from Lemma 5, and c is a constant represent-
ing the depth needed in a circuit having AddBI gates with
Î³Mult(R) = n
â„¦(1) fan-in and MultBI gates with constant fan-
in to sequentially perform DecryptE Steps 0, 1, 3, and 4, and
a NAND gate.
Proof. As in the proof of Theorem 8, for a c-level circuit,
if the inputs to the generalized circuit are in B(r), the out-
puts are in B((Î³Mult(R)Â·r)2c ). Combining with Lemma 5, we
have that if the inputs to our generalized NAND-augmented
decryption circuit are in B(rEnc), the output is in
(Î³Mult(R) Â· rEnc)2
cÂ·(Î³subset(n)+polylog(Î³subset(n)))
The result follows when this value is at most rDec/m.
For example, suppose Î³Mult(R) Â· rEnc is polynomial in n, and
rDec = 2
nC for C < 1. In this case, Î³subset(n) can be polyno-
mial in n (but sub-linear). The constant c is not very large,
though in practice one would want to optimize it beyond
what we have done.
5.4 On the New Hardness Assumption
Concretely, the SplitKey Distinguishing Problem becomes:
Definition 13 (SplitKey DP, concrete version). Let
Î³set(n) and Î³subset(n) be functions as above, and BI a basis
of an ideal I. The challenger sets (skâˆ—, pkâˆ—)
Râ† KeyGenEâˆ—
and b
Râ† {0, 1}, where skâˆ— includes the secret vector vskâˆ—J âˆˆ
R. If b = 1, it sets vsk
âˆ—
J â† 0. It sets Ï„ to be a set of
Î³set(n) vectors t1, . . . , tÎ³set(n) that are uniformly random in
Jâˆ’1 mod BI subject to the constraint that there exists a sub-
set S âŠ† {1, . . . , Î³set(n)} of cardinality Î³subset(n) such thatâˆ‘
iâˆˆS ti âˆˆ vsk
âˆ—
J +I. The problem: guess b given (Ï„, sk
âˆ—,pkâˆ—).
This problem is related to the following problem, which has
been analyzed in connection with server-aided cryptography
[34, 51, 44, 38, 43], and which should not be confused with
the low-density knapsack problem [45].
Definition 14 (Sparse Subset Sum Problem (SSSP)).
Let Î³set(n) and Î³subset(n) be functions as above. Let q be
a positive integer. The challenger sets b
Râ† {0, 1}. If b = 0
it generates Ï„ as a set of Î³set(n) integers {a1, . . . , aÎ³set(n)}
in [âˆ’q/2, q/2] that are uniformly random, except that there
exists a subset S âŠ† {1, . . . , Î³set(n)} of cardinality Î³subset(n)
such that
âˆ‘
iâˆˆS ai = 0 mod q. If b = 1, it sets the elements
without the constraint. The problem: guess b given Ï„ .
Known attacks on the SSSP[51, 44, 38, 43] are feasible
only for limited choices of parameters. Some of these [51]
(and previous related results [58, 17]) essentially amount to a
time-space tradeoff whose complexity is Î³set(n)
O(Î³subset(n));
these only require us to take Î³subset(n) = Ï‰(1). Nguyen and
Shparlinski [43] present a lattice-based cryptanalysis of the
SSSP that provably succeeds with advantage at least
1âˆ’ (Î³subset(n)Î³set(n)+2 Â· Î±)/q
where Î± is a term that is greater than 1. The attack breaks
down when Î³set(n) exceeds log q.
Though we omit details, current attacks against our con-
crete version SplitKey DP begin to break down when Î³set(n)
exceeds log det(IJ). The intuition is that, once Î³set(n) is
sufficiently large, there will be exponentially many subsets
in Ï„ (not necessarily sparse) whose vector sum is congruent
to vsk
âˆ—
J ; lattice reduction techniques have trouble extracting
the sparse subset from among the many subset solutions.
6. PERFORMANCE
Our scheme relies on two assumptions. The first assump-
tion underlies the security E1 and its approximation factor is
mildly impacted by the tweaks of E2. The second arises from
the addition of Ï„ to the public key. Interestingly, the two as-
sumptions counterbalance each other: increasing Î³subset(n)
seems to make the second problem harder, but at the ex-
pense of increasing the approximation factor in the first
problem, making the first problem easier.
Using a crude analysis, the breaking time for the second
problem using known attacks is roughly 2Î³subset(n). (We
ignore constants and logarithmic factors in the exponent.)
The approximation factor for the first problem is also roughly
2Î³subset(n). Using the rule of thumb that a lattice prob-
lem for approximation factor 2k takes time about 2n/k, the
breaking time for the first problem is roughly 2n/Î³subset(n).
Setting Î³subset(n) â† âˆšn maximizes the minimal breaking
time at about 2
âˆš
n. To make this breaking time truly expo-
nential in the security parameter Î», we need n â‰ˆ Î»2.
For each gate, we evaluate the circuit DE homomorphi-
cally. (Actually, there is a tradeoff here, since a â€œgateâ€ can
be taken to be a â€œnormal circuitâ€ of depth greater than 1.)
Though it is a shallow circuit, the computational complex-
ity of DE itself in E3 (not evaluated homomorphically in
the encryption scheme) is quite high (but poly(Î»)), primar-
ily due to the large unary representation of the secret key in
E3. The fact that decryption is performed homomorphically,
with ciphertext elements inR mod BpkJ being used instead of
plaintext elements in R mod BI , multiplies the complexity
by another factor that is quasi-linear in n Â· Î³subset(n), since
roughly log det(IJ) â‰ˆ n Â· log rDec/rEnc â‰ˆ n Â· Î³subset(n) bits
of precision are needed, but again this is polynomial in Î».
Two optimizations are: 1) one can reduce the size of the E3
secret key substantially by allowing a modest increase in the
depth of the decryption circuit, and 2) the homomorphic de-
cryption circuit can take the ciphertext bits as input directly
[15] (rather than the encrypted ciphertext bits). Making the
full scheme practical remains an open problem (though E1
is quite practical for shallow circuits).
177
7. CIRCUIT PRIVACY
We omit full details due to lack of space, but mention
that one can construct an algorithm RandomizeCTE for our
E2 that can be applied to ciphertexts output by EncryptE2
and EvaluateE2 , respectively, that induces equivalent output
distributions. The circuit privacy of E2 immediately implies
the (leveled) circuit privacy of our (leveled) fully homomor-
phic encryption scheme.
The idea is simple: to construct a random encryption Ïˆâ€²
of pi from a particular encryption Ïˆ of pi, we simply add
an encryption of 0 that has a much larger random â€œerrorâ€
vector than Ïˆ â€“ super-polynomially larger, so that the new
error vector statistically obliterates all information about
Ïˆâ€™s error vector. This entails another re-definition of CE .
8. ACKNOWLEDGMENTS
We thank Boaz Barak, Dan Boneh, Ran Canetti, Shafi
Goldwasser, Iftach Haitner, Yuval Ishai, Tal Rabin, Yael
Tauman Kalai, Salil Vadhan, and Brent Waters for very
helpful discussions.
9. REFERENCES
[1] M. Ajtai. Generating hard instances of lattice problems
(extended abstract). STOC â€™96, pp. 99â€“108.
[2] M. Ajtai and C. Dwork. A public key cryptosystem with
worst-case / average-case equivalence. STOC â€™97, pp. 284â€“293.
[3] J.H. An, Y. Dodis, and T. Rabin. On the security of joint
signature and encryption. Eurocrypt â€™02, pp. 83â€“107.
[4] F. Armknecht and A.-R. Sadeghi. A new approach for
algebraically homomorphic encryption. Eprint 2008/422.
[5] L. Babai. On LovaÂ´szâ€™s lattice reduction and the nearest lattice
point problem. Combinatorica 6 (1986), 1â€“14.
[6] D. Barrington. Bounded-width polynomial-size branching
programs recognize exactly those languages in NC1. STOC
â€™86, pp. 1â€“5.
[7] D. Beaver. Minimal-latency secure function evaluation.
Eurocrypt â€™00, pp. 335â€“350.
[8] J. Benaloh. Verifiable secret-ballot elections. Ph.D. thesis, Yale
Univ., Dept. of Comp. Sci., 1988.
[9] J. Black, P. Rogaway, and T. Shrimpton. Encryption-scheme
security in the presence of key-dependent messages. SAC â€™02,
pp. 62â€“75.
[10] M. Blaze, G. Bleumer, and M. Strauss. Divertible protocols
and atomic proxy cryptography. Eurocrypt â€™98, pp. 127â€“144.
[11] D. Boneh, E.-J. Goh, and K. Nissim. Evaluating 2-DNF
formulas on ciphertexts. TCC â€™05, pp. 325â€“341.
[12] D. Boneh, S. Halevi, M. Hamburg, and R. Ostrovsky.
Circular-Secure Encryption from Decision Diffie-Hellman.
Crypto â€™08, pp. 108â€“125.
[13] D. Boneh and R. Lipton. Searching for Elements in Black-Box
Fields and Applications. Crypto â€™96, pp. 283â€“297.
[14] J. Boyar, R. Peralta, and D. Pochuev. On the Multiplicative
Complexity of Boolean Functions over the Basis (âˆ§,âŠ•, 1).
Theor. Comput. Sci. 235(1), pp. 43â€“57, 2000.
[15] R. Canetti. Personal communication, 2008.
[16] R. Canetti, H. Krawczyk, and J.B. Nielsen. Relaxing
chosen-ciphertext security. Crypto â€™03, pp. 565â€“582.
[17] D. Coppersmith and G. Seroussi. On the minimum distance of
some quadratic residue codes. IEEE Trans. Inform. Theory 30
(1984), 407â€“411.
[18] W. van Dam, S. Hallgren, and L. Ip. Quantum Algorithms for
Some Hidden Shift Problems. SIAM J. Comput., v. 36., no. 3,
pp. 763â€“778, 2006.
[19] I. Damgard and M. Jurik. A Length-Flexible Threshold
Cryptosystem with Applications. ACISP â€™03, pp. 350â€“356.
[20] T. ElGamal. A Public-Key Cryptosystem and a Signature
Scheme Based on Discrete Logarithms. Crypto â€™84, pp.
469â€“472.
[21] M. Fellows and N. Koblitz. Combinatorial cryptosystems
galore! Contemporary Mathematics, v. 168 of Finite Fields:
Theory, Applications, and Algorithms, FQ2, pp. 51â€“61, 1993.
[22] S. Goldwasser and D. Kharchenko. Proof of plaintext
knowledge for the Ajtai-Dwork cryptosystem. TCC 2005, pp.
529â€“555.
[23] S. Goldwasser and S. Micali. Probabilistic encryption and how
to play mental poker keeping secret all partial information.
STOC â€™82, pp. 365â€“377.
[24] S. Halevi and H. Krawczyk. Security under key-dependent
inputs. ACM CCS â€™07.
[25] J. Hoffstein, J. Silverman, and J. Pipher. NTRU: A Ring
Based Public Key Cryptosystem. In Proc. of ANTS â€™98, LNCS
1423, pages 267â€“288.
[26] Y. Ishai and A. Paskin. Evaluating Branching Programs on
Encrypted Data. TCC â€™07.
[27] A. Kawachi, K. Tanaka, K. Xagawa. Multi-bit cryptosystems
based on lattice problems. PKC â€™07, pp. 315â€“329.
[28] A.K. Lenstra, H.W. Lenstra, L. LovaÂ´sz. Factoring polynomials
with rational coefficients. Math. Ann. 261(4) (1982) 515â€“534.
[29] F. Levy-dit-Vehel and L. Perret. A Polly Cracker system based
on satisfiability. In Coding, Crypt. and Comb., Prog. in
Comp. Sci. and App. Logic, v. 23, pp. 177â€“192.
[30] L. Ly. A public-key cryptosystem based on Polly Cracker,
Ph.D. thesis, Ruhr-UniversitaÂ¨t Bochum, Germany, 2002.
[31] L. Ly. Polly two â€“ a new algebraic polynomial-based public-key
scheme. AAECC, 17(3-4), 2006.
[32] V. Lyubashevsky and D. Micciancio. Generalized compact
knapsacks are collision resistant. ICALP â€™06.
[33] V. Lyubashevky and D. Micciancio. Asymptotically efficient
lattice-based digital signatures. TCC â€™08.
[34] T. Matsumoto, K. Kato, and H. Imai. Speeding up secret
computations with insecure auxiliary devices. Crypto â€˜88, pp.
497â€“506.
[35] U. Maurer and D. Raub. Black-Box Extension Fields and the
Inexistence of Field-Homomorphic One-Way Permutations.
Asiacrypt â€™07, pp. 427â€“443.
[36] C.A. Melchor, G. Castagnos, and P. Gaborit. Lattice-based
homomorphic encryption of vector spaces. ISIT â€™08, pp.
1858â€“1862.
[37] C.A. Melchor, P. Gaborit, and J. Herranz. Additive
Homomorphic Encryption with t-Operand Multiplications.
Eprint 2008/378.
[38] J. Merkle. Multi-round passive attacks on server-aided RSA
protocols. ACM CCS â€™00, pp. 102â€“107.
[39] D. Micciancio. Improving Lattice Based Cryptosystems Using
the Hermite Normal Form. CaLC â€™01, pp. 126â€“145.
[40] D. Micciancio. Improved cryptographic hash functions with
worst-case / average-case connection. STOC â€™02, pp. 609â€“618.
[41] D. Micciancio. Generalized compact knapsacks, cyclic lattices,
and efficient one-way functions from worst-case complexity
assumptions. FOCS â€™02, pp. 356â€“365.
[42] D. Naccache and J. Stern. A New Public-Key Cryptosystem
Based on Higher Residues. ACM CCS â€™98.
[43] P.Q. Nguyen and I. Shparlinski. On the Insecurity of Some
Server-Aided RSA Protocol. Asiacrypt â€™01, pp. 21â€“35.
[44] P.Q. Nguyen and J. Stern. The Beguin-Quisquater server-aided
RSA protocol from Crypto â€˜95 is not secure. Asiacrypt â€˜98, pp.
372â€“379.
[45] A.M. Odlyzko. The rise and fall of knapsack cryptosystems. In
Crypt. and Comp. Num. Th., Proc. Sympos. Appl. Math., vol.
42, AMS, 1990, pp. 75â€“88.
[46] T. Okamoto and Uchiyama. A New Public-Key Cryptosystem
as Secure as Factoring. Eurocrypt â€™98, pp. 308â€“318.
[47] P. Paillier. Public-Key Cryptosystems Based on Composite
Degree Residuosity Classes. Eurocrypt â€™99, pp. 223â€“238.
[48] C. Peikert and A. Rosen. Efficient collision-resistant hashing
from worst-case assumptions on cyclic lattices. TCC â€™06, pp.
145â€“166.
[49] C. Peikert and A. Rosen. Lattices that Admit Logarithmic
Worst-Case to Average-Case Connection Factors. STOC â€™07,
pp. 478â€“487.
[50] C. Peikert and B. Waters. Lossy Trapdoor Functions and Their
Applications. STOC â€™08, pp. 187â€“196.
[51] B. Pfitzmann and M. Waidner. Attacks on protocols for
server-aided RSA computation. Eurocrypt â€™92, pp. 153â€“162.
[52] M. Prabhakaran and M. Rosulek. Homomorphic Encryption
with CCA Security. ICALP â€™08.
[53] O. Regev. On Lattices, Learning with Errors, Random Linear
Codes, and Cryptography. STOC â€™05, pp. 84â€“93.
[54] R. Rivest, L. Adleman, and M. Dertouzos. On data banks and
privacy homomorphisms. In Foundations of Secure
Computation, pp. 169â€“180, 1978.
[55] R. Rivest, A. Shamir, and L. Adleman. A method for obtaining
digital signatures and public-key cryptosystems. In Comm. of
the ACM, 21:2, pages 120â€“126, 1978.
[56] T. Sander, A. Young, and M. Yung. Non-interactive
cryptocomputing for NC1. FOCS â€™99, pp. 554â€“567, 1999.
[57] C.P. Schnorr. A Hierarchy of Polynomial Time Lattice Basis
Reduction Algorithms. Theoretical Computer Science,
53(2-3):201â€“224, 1987.
[58] D.R. Stinson. Some baby-step giant-step algorithms for the low
hamming weight discrete logarithm problem. Mathematics of
Computation, vol. 71, no. 237, pages 379â€“391, 2001.
178
