A Simpler Proof Theory for Nominal Logic
James Cheney
University of Edinburgh
(jcheney@inf.ed.ac.uk)
Abstract. Nominal logic is a variant of first-order logic equipped with a “fresh-
name quantifier” Nand other features useful for reasoning about languages with
bound names. Its original presentation was as a Hilbert axiomatic theory, but sev-
eral attempts have been made to provide more convenient Gentzen-style sequent
or natural deduction calculi for nominal logic. Unfortunately, the rules for Nin
these calculi involve complicated side-conditions, so using and proving proper-
ties of these calculi is difficult. This paper presents an improved sequent calculus
NL⇒ for nominal logic. Basic results such as cut-elimination and conservativ-
ity with respect to nominal logic are proved. Also, NL⇒ is used to solve an
open problem, namely relating nominal logic’s N-quantifier and the self-dual ∇-
quantifier of Miller and Tiu’s FOλ∇.
1 Introduction
Gabbay and Pitts [8] have introduced a new way of reasoning about names and binding,
in which α-equivalence and capture-avoiding substitution can be defined in terms of the
basic concepts of swapping and freshness. This approach provides a cleaner treatment
of α-equivalence than the classical first-order approach in which α-equivalence and
capture-avoiding substitution are defined by mutual recursion. On the other hand, unlike
higher-order techniques for dealing with names and binding, the semantics of this model
of name-binding is relatively straightforward, so well-understood mathematical tools
like structural induction can be used to reason about syntax with bound names.
These ideas have been incorporated into a logic called nominal logic [12]. Nominal
logic is typed, first-order equational logic augmented with:
– name-types ν, ν′, . . . inhabited by countably many names a, b, . . .;
– a swapping operation (− −) ·− : ν → ν → τ → τ for each name-type ν and type
τ , which acts on values by exchanging occurrences of names;
– a freshness relation − # − : ν → τ → o1 for each name-type ν and type τ , that
holds between a name and a value independent of the name;
– an abstraction type constructor 〈−〉− and abstraction function symbol 〈−〉− : ν →
τ → 〈ν〉τ which constructs values equal up to consistent renaming, axiomatized as
follows:
∀a, b, x, y.〈a〉x = 〈b〉y ⇐⇒ (a = b ∧ x = y) ∨ (a # y ∧ x = (a b) · y) ;
– a some/any fresh-name quantifier Nthat is self-dual (¬ Na.ϕ ⇐⇒ Na.¬ϕ);
– and freshness and equivariance principles which state that fresh names can always
be chosen and truth is preserved by name-swapping, respectively.
1 o is the type of propositions
1.1 The Problem
This paper is concerned with developing simple rules for reasoning with the N-quan-
tifier. Pitts’ original formalization of nominal logic was a Hilbert-style collection of
first-order axioms (which we call NL). There were no new inference rules for N. In-
stead, Nwas defined using the axiom scheme ∀x.( Na.ϕ ⇐⇒ ∃a.a # x ∧ ϕ), where
FV (ϕ) ⊆ {a, x}. While admirable from a reductionist point of view, Hilbert systems
have well-known deficiencies for modeling actual reasoning. Instead, Gentzen-style
natural deduction and sequent systems provide a more intuitive approach to formal rea-
soning in which logical connectives are explained as proof-search operations. Gentzen
systems are especially useful for computational applications, such as automated deduc-
tion and logic programming. A sequent calculus formalization would also be convenient
for relating nominal logic with other logics by proof-theoretic translations.
Gentzen-style rules for Nhave been considered in previous work. Pitts [12] pro-
posed sequent and natural deduction rules for Nbased on the observation that
∀a.(a # x ⊃ ϕ(a, x)) ⊃ Na.ϕ(a, x) ⊃ ∃a.(a # x ∧ ϕ(a, x)) .
These rules (see Figure 1(NL)) are symmetric, emphasizing N’s self-duality. However,
they are not closed under substitution, which greatly complicates the the proof of cut-
elimination or proof-normalization properties.
Gabbay [6] introduced Fresh Logic (FL), an intuitionistic natural deduction cal-
culus for nominal logic, and studied semantic issues including soundness and com-
pleteness as well as proving proof-normalization. Gabbay and Cheney [7] presented a
similar sequent calculus called FLSeq. In FL, Gabbay introduced a technical device
called slices for obtaining rules that are closed under substitution. Technically, a slice
ϕ[a#u] of a formula ϕ is a decomposition of the formula as ϕ(a, x)[u/x] for fresh
variables x, such that a does not appear in any of the u. Slices were also used in the
FLSeq rules (see Figure 1(FLSeq)). The slice-based rules shown in Figure 1(FLSeq)
are closed under substitution, so proving cut-elimination for these rules is relatively
straightforward once several technical lemmas involving slices have been proved. Not-
ing that the FLSeq rules are structurally similar to ∀L and ∃R, respectively, Gabbay
and Cheney observed that alternate rules in which NL was similar to ∃L and NR sim-
ilar to ∀R were possible (see Figure 1(FL′Seq)). These rules seem simpler and more
deterministic; however, they still involve slices.
Gabbay and Cheney presented a proof-theoretic semantics for nominal logic pro-
gramming based on FLSeq. However, this analysis suggested an interpretation of N-
quantified formulas that was radically different from the approach used in the αProlog
nominal logic programming language [2]. The proof-search interpretation of Na.ϕ sug-
gested by FLSeq is “search for a slice ϕ[a#u] of ϕ and substitution t for a such that
t # u and solve ϕ(t, u)”, while in αProlog, the interpretation of Na.ϕ is “generate a
fresh name a′ and solve ϕ(a′)”. The approach motivated by the FLSeq proof-theoretic
semantics seems much more complicated than experience with αProlog suggests.
Gabbay and Cheney also gave a translation from FOλ∇, a logic introduced by
Miller and Tiu that also includes a self-dual quantifier, ∇ [9] into FLSeq. This trans-
lation was sound (mapped derivable sequents to derivable sequents), but incomplete
Γ, a # x⇒ ϕ,∆ (†)
Γ ⇒ Na.ϕ,∆ NR
Γ, a # x, ϕ⇒ ∆ (†)
Γ, Na.ϕ⇒ ∆ NL (NL)
Γ ` u # t Γ ` ϕ[u/a] (∗)
Γ ` Na.ϕ NI
Γ ` Na.ϕ Γ ` u # t
Γ, ϕ[u/a] ` ψ (∗)
Γ ⇒ ψ NE (FL)
Γ, u # t⇒ ϕ[u/a] (∗)
Γ, u # t⇒ Na.ϕ NR
Γ, u # t, ϕ[u/a] ⇒ ψ (∗)
Γ, u # t, Na.ϕ⇒ ψ NL (FLSeq)
Γ, a # t⇒ ϕ (∗), (∗∗)
Γ ⇒ Na.ϕ NR
Γ, a # t, ϕ⇒ ψ (∗), (∗∗)
Γ, Na.ϕ⇒ ψ NL (FL′Seq)
Σ#a : Γ ⇒ ϕ (a /∈ Σ)
Σ : Γ ⇒ Na.ϕ NR
Σ#a : Γ, ϕ⇒ ψ (a /∈ Σ)
Σ : Γ, Na.ϕ⇒ ψ NL (NL⇒)
(†) x = FV (Γ, Na.ϕ,∆) (∗) ϕ = ϕ[a#t] (∗∗) a 6∈ FV (Γ, ψ)
Fig. 1. Evolution of rules for N
(mapped some non-derivable sequents to derivable ones). Gabbay and Cheney conjec-
tured that their translation would be complete relative to FOλ∇ extended with weak-
ening and exchange for ∇.
In this paper we present a simplified sequent calculus for nominal logic, called
NL⇒, in which slices are not needed in the rules for N(or anywhere else), and which
seems more compatible with the proof-search reading of Nin αProlog. Following
Urban, Pitts, and Gabbay [14, 6], we employ a new syntactic class of name-symbols
a, b, . . .. Like variables, such name-symbols may be bound (by N), but unlike variables,
two distinct name-symbols are always regarded as denoting distinct name values. In
place of slices, we introduce variable contexts that encode information about freshness.
Specifically, contextsΣ#a:ν may be formed by adjoining a fresh name-symbol a which
is also assumed to be semantically fresh for any value mentioned in Σ. Our rules for N
(Figure 1(NL⇒)) are in the spirit of the original rules and are very simple.
Besides the sequent calculus itself, we present two applications. First, we verify that
NL⇒ and Pitts’ axiomatization NL are equivalent. Second, we present and prove the
soundness and completeness of a new translation from FOλ∇ to nominal logic, solving
a problem left unsolved by Gabbay and Cheney. We have also found that the original
translation is complete relative to FOλ∇ extended with ∇-weakening and contraction.
The structure of this paper is as follows: Section 2 presents the sequent calculus
NL⇒ along with proofs of structural properties and conservativity of NL⇒ relative to
NL. In Section 3, we present sound and complete translations from FOλ∇ (with and
without ∇-weakening and exchange) to NL⇒. Section 4 discusses additional related
and future work, and Section 5 concludes.
2 Sequent Calculus
The sequent calculus in this section is a generalization of the one presented in Chapter 4
of the author’s dissertation [5]. Full proofs can be found there and in a companion
technical report [3].
2.1 Syntax and Well-Formedness
The types τ , terms t, and formulas ϕ of NL⇒ are generated by the following grammar:
τ ::= o | δ | ν | τ → τ ′ | 〈ν〉τ t, u ::= c | a | λx:τ.t | t u | x
ϕ, ψ ::= > | ⊥ | t | ϕ ∧ ψ | ϕ ∨ ψ | ϕ ⊃ ψ | ∀x:τ.ϕ | ∃x:τ.ϕ | Na:ν.ϕ
The base types are datatypes δ, name-types ν, and the type o of propositions; additional
types are formed using the function and abstraction type constructors. Variables x, y
are drawn from a countably infinite set V ; also, name-symbols a, b are drawn from a
disjoint countably infinite set A. The letters a, b are typically used for terms of some
name-sort ν. Note that λ-terms are included in this language and are handled in a tra-
ditional fashion. In particular, terms are considered equal up to αβη-equivalence. Sim-
ilarly, ∀,∃, and N-quantified formulas are identified up to α-equivalence. We assume
given a signature that maps constant symbols c to types τ , and containing at least the
following declarations:
eqτ : τ→τ→o freshντ : ν→τ→o swapντ : ν→ν→τ→τ absντ : ν→τ→〈ν〉τ
for all name-types ν and types τ . The notations t ≈ u, t # u, (t u) · v, and 〈t〉u are
syntactic sugar for eq t u, fresh t u, swap t u v, and abs t u, respectively.
The contexts used in NL⇒ are generated by the grammar:
Σ ::= · | Σ, x:τ | Σ#a:ν
We often abbreviate ·, x:τ and ·#a:ν to x:τ and a:ν respectively, and may omit type
declarations when no ambiguity ensues. We write ω for a term that may be either a
name-symbol a or a variable x. The functions FV (−), FN(−), FV N(−) calculate
the sets of free variables, name-symbols, or both variables and name-symbols of a term
or formula. Note that abstraction 〈−〉− is just a function symbol and does not bind its
first argument (which may be any term of type ν), and so FN(〈a〉t) = FN(a)∪FN(t),
whereas Na.ϕ does bind a, so FN( Na.ϕ) = FN(ϕ) − {a}. We write ω:τ ∈ Σ if the
binding ω:τ is present inΣ. We writeΣ;Σ′ for the result of concatenating two contexts
such that FV N(Σ) ∩ FV N(Σ′) = ∅.
Remark 1. The inclusion of λ-terms and identification of terms and formulas with
bound names up to α-equivalence may be objectionable because it appears that we are
circularly attempting to define binding in terms of binding. This is not the case. A key
contribution of Gabbay and Pitts’ approach is that it shows how one can formally justify
a traditional, informal approach to binding syntax by constructing syntax trees modulo
α-equivalence as simple mathematical objects in a particularly clever way [8][5, Ch.
3–4]. We assume that this or some other standard technique for dealing with binding in
nominal logic’s terms and formulas is acting behind the scenes.
We write Σ ` t : τ or Σ ` ϕ : o to indicate that t is a well-formed term of type τ
or ϕ is a well-formed formula. From the point of view of typechecking, the freshness
information given by the context is irrelevant. There are only two nonstandard rules for
typechecking:
ω:τ ∈ Σ
Σ ` ω : τ
Σ#a:ν ` ϕ : o
Σ ` Na:ν.ϕ : o
Terms viewed as formulas must, as usual, be of type o. Quantification using ∀ and ∃ is
only allowed over types not mentioning o; N-quantification is only allowed over name-
types.
Let TmΣ = {t | Σ ` t : τ} be the set of well-formed terms in context Σ. We
associate a set of freshness formulas |Σ| to each context Σ as follows:
| · | = ∅ |Σ, x : τ | = |Σ| |Σ#a : ν| = |Σ| ∪ {a # t | t ∈ TmΣ}
For example, a # x, b # a, and b # f x y ∈ |x:τ#a:ν, y:τ ′#b:ν′| (provided f :
τ → τ ′ → σ is a function symbol). We say that Σ is stronger than Σ′ (Σ′ ≤ Σ) if
TmΣ′ ⊆ TmΣ and |Σ′| ⊆ |Σ|. For example, a, x ≤ x#a, y.
Lemma 1 (Term Weakening). If Σ ` t : τ and Σ ≤ Σ′ then Σ′ ` t : τ .
Lemma 2 (Term Substitution). If Σ ` t : τ and Σ, x : τ ;Σ′ ` u : τ ′ then Σ;Σ′ `
u[t/x] : τ ′.
2.2 The Rules
Judgments are of the form Σ : Γ ⇒ ∆, where Σ is a context and Γ,∆ are multisets of
formulas. We define classical and intuitionistic versions of NL⇒. Classical NL⇒ is
based on the classical sequent calculus G3c [11] (see Figure 2), whereas Intuitionistic
NL⇒ (INL⇒) is based on the intuitionistic calculusG3im (in which⊃, ∀R, and ∃L-
rules are restricted to a single-conclusion form). Both versions include two additional
logical rules, NL and NR, shown in Figure 1(NL⇒). In addition, NL⇒ includes sev-
eral nonlogical rules (Figure 4) defining the properties of swapping, equality, freshness
and abstraction. Figure 5 lists some admissible rules.
Many of the nonlogical rules correspond to first-order universal axioms of nominal
logic (Figure 3), which may be incorporated into sequent systems in a uniform fashion
using the Ax rule without affecting cut-elimination [11]. The remaining nonlogical
rules are as follows. Rule A2 expresses an invertibility property for abstractions: two
abstractions are equal only if they are structurally equal or equal by virtue of A1. A3
says that all values of abstraction type are formed using the abstraction function symbol.
The F rule expresses the freshness principle: that a name fresh for a given context may
always be chosen. Finally, the Σ# rule allows freshness information to be extracted
from the context Σ. It states that in context Σ, any constraint in |Σ| is valid.
2.3 Structural Properties
We now list some routinely-verified properties of NL⇒ derivations. We write `n J to
indicate that judgment J has a derivation of height at most n.
Σ : Γ, p t⇒ p t,∆ hyp
Σ : Γ ⇒ >,∆ >R Σ : Γ,⊥ ⇒ ∆ ⊥L
Σ : Γ ⇒ ϕ,∆ Σ : Γ ⇒ ψ,∆
Σ : Γ ⇒ ϕ ∧ ψ,∆ ∧R
Σ : Γ, ϕ1, ϕ2 ⇒ ∆
Σ : Γ, ϕ1 ∧ ϕ2 ⇒ ∆ ∧L
Σ : Γ ⇒ ϕ1, ϕ2,∆
Σ : Γ ⇒ ϕ1 ∨ ϕ2,∆ ∨R
Σ : Γ, ϕ⇒ ∆ Γ,ψ ⇒ ∆
Σ : Γ, ϕ ∨ ψ ⇒ ∆ ∨L
Σ : Γ, ϕ⇒ ψ,∆
Σ : Γ ⇒ ϕ ⊃ ψ,∆ ⊃R
Σ : Γ ⇒ ϕ,∆ Σ : Γ, ψ ⇒ ∆
Σ : Γ, ϕ ⊃ ψ ⇒ ∆ ⊃L
Σ, x : Γ ⇒ ϕ,∆ (x 6∈ Σ)
Σ : Γ ⇒ ∀x.ϕ,∆ ∀R
Σ ` t : σ Σ : Γ,∀x:τ.ϕ, ϕ[t/x] ⇒ ∆
Σ : Γ,∀x:τ.ϕ⇒ ∆ ∀L
Σ ` t : σ Σ : Γ ⇒ ∃x:τ.ϕ, ϕ[t/x],∆
Σ : Γ ⇒ ∃x:τ.ϕ,∆ ∃R
Σ, x : Γ, ϕ⇒ ∆ (x 6∈ Σ)
Σ : Γ,∃x.ϕ⇒ ∆ ∃L
Σ : Γ, t ≈ t⇒ ∆
Σ : Γ ⇒ ∆ ≈R
Σ : Γ, t ≈ u, P (t), P (u) ⇒ ∆
Σ : Γ, t ≈ u, P (t) ⇒ ∆ ≈S
Fig. 2. Classical typed first-order equational logic (G3c)
Lemma 3 (Weakening). If `n Σ : Γ ⇒ ∆ is derivable then so is `n Σ : Γ, ϕ⇒ ∆.
Lemma 4 (Context Weakening). If `n Σ : Γ ⇒ ∆ and Σ ≤ Σ′ then `n Σ′ : Γ ⇒
∆
Lemma 5 (Substitution). If `n Σ ` t : τ and Σ, x:τ ;Σ′ : Γ ⇒ ∆ then `n Σ;Σ′ :
Γ [t/x]⇒ ∆[t/x].
The remaining structural transformations do not preserve the height of derivations.
However, they do preserve the logical height of the derivation, which is defined as
follows.
Definition 1. The logical height of a derivation is the maximum number of logical rules
in any branch of the derivation. We write `ln J to indicate that J has a derivation of
logical height ≤ n.
Lemma 6 (Admissibility of EV L, EV R). If `ln Σ : Γ, (a b) · ϕ ⇒ ∆, then so is
`ln Σ : Γ, ϕ ⇒ ∆. Similarly, if `ln Σ : Γ ⇒ (a b) · ϕ,∆ is derivable, then so is
`ln Σ : Γ ⇒ ϕ,∆.
Lemma 7 (Admissibility of hyp∗). The judgment Σ : Γ, ϕ⇒ ϕ,∆ is derivable for
any ϕ.
Proof (Sketch). Induction on the construction of ϕ. The only new case is for ϕ =
Na.ψ(a, x). By induction we know that Σ#a#b : Γ, ψ(b, x) ⇒ ψ(b, x). Using equiv-
ariance we have Σ#a#b : Γ, (a b) · ψ(a, x) ⇒ ψ(b, x). Since x ⊂ FV (Σ), using
Σ# we know that a # x, b # x, hence (a b) · x ≈ x, so using equational rea-
soning we have (a b) · ψ(a, x) ≈ ψ(b, x). Then using NL and NR we can conclude
Σ : Γ, Na.ψ ⇒ Na.ψ,∆. uunionsq
(S1) (a a) · x ≈ x
(S2) (a b) · (a b) · x ≈ x
(S3) (a b) · a ≈ b
(E1) (a b) · c ≈ c
(E2) (a b) · (t u) ≈ ((a b) · t) ((a b) · u)
(E3) p(x) ⊃ p((a b) · x)
(E4) (a b) · λx.e[x] ≈ λx.(a b) · e[(a b) · x]
(F1) a # x ∧ b # x ⊃ (a b) · x ≈ x
(F2) a # b (a : ν, b : ν
′, ν 6≡ ν′)
(F3) a # a ⊃ ⊥
(F4) a # b ∨ a ≈ b
(A1) a # y ∧ x ≈ (a b) · y ⊃ 〈a〉x ≈ 〈b〉y
Fig. 3. Equational and freshness axioms
Σ : Γ, P ,Q1 ⇒ ∆ · · · Σ : Γ, P ,Qn ⇒ ∆
Σ : Γ, P ⇒ ∆ Ax
V
P ⊃ WQ an axiom instance
Σ : Γ, 〈a〉t ≈ 〈b〉u, a ≈ b, t ≈ u⇒ ∆ Σ : Γ, 〈a〉t ≈ 〈b〉u, a # u, t = (a b) · u⇒ ∆
Σ : Γ, 〈a〉t ≈ 〈b〉u⇒ ∆ A2
Σ ` t : 〈ν〉σ Σ, a:ν, x:σ : Γ, t ≈ 〈a〉x⇒ ∆ (a, x /∈ Σ)
Σ : Γ ⇒ ∆ A3
Σ#a : Γ ⇒ ∆ (a /∈ Σ)
Σ : Γ ⇒ ∆ F
Σ : Γ, t # u⇒ ∆ (t # u ∈ |Σ|)
Σ : Γ ⇒ ∆ Σ#
Fig. 4. Nonlogical rules
Σ : Γ ⇒ ∆
Σ : Γ, ϕ⇒ ∆ W Σ : Γ, ϕ⇒ ϕ,∆ hyp
∗ Σ : Γ ⇒ ϕ,∆ Σ : Γ ′, ϕ⇒ ∆′
Σ : Γ, Γ ′ ⇒ ∆,∆′ cut
Σ : Γ, ϕ, ϕ⇒ ∆
Σ : Γ, ϕ⇒ ∆ C
Σ : Γ, (a b) · ϕ⇒ ∆
Σ : Γ, ϕ⇒ ∆ EV L
Σ : Γ ⇒ (a b) · ϕ,∆
Σ : Γ ⇒ ∆,ϕ EV R
Fig. 5. Some admissible rules of NL⇒
Lemma 8 (Inversion). The ⊃L, ∃L, ∧L, and ∨L rules are invertible, in the sense of
lemma 2.3.5 and 4.2.8 of Negri and von Plato [11]. In addition, NL is invertible: if
`ln Σ : Γ, Na.ϕ⇒ ∆ is derivable then so is `ln Σ#a : Γ, ϕ⇒ ∆ for fresh a.
Lemma 9 (Contraction). If `ln Σ : Γ, ϕ, ϕ ⇒ ∆ is derivable then so is `ln Σ :
Γ, ϕ⇒ ∆.
2.4 Cut-Elimination
Lemma 10 (Admissibility of Cut). If Σ : Γ ⇒ ∆,ϕ and Σ : Γ ′, ϕ ⇒ ∆′ have
cut-free derivations then so does Σ : Γ, Γ ′ ⇒ ∆,∆′.
Proof (Sketch). We show the most interesting case, that for principal cuts on N-quanti-
fied formulas. In this case, the derivations are of the form
Π
Σ#a : Γ ⇒ ϕ,∆
Σ : Γ ⇒ Na.ϕ,∆ NR
Π ′
Σ#a : Γ ′, ϕ⇒ ∆′
Σ : Γ ′, Na.ϕ⇒ ∆′ NL
where without loss of generality we assume that the same fresh name a 6∈ Σ was used
in both sub-derivations. Since ϕ is smaller than Na.ϕ, we can obtain a derivation Π ′′ of
Σ#a : Γ, Γ ′ ⇒ ∆,∆′ from Π and Π ′ by the induction hypothesis. Then
Π ′′
Σ#a : Γ, Γ ′ ⇒ ∆,∆′
Σ : Γ, Γ ′ ⇒ ∆,∆′ F
follows using rule F . uunionsq
Theorem 1 (Cut-elimination). If Σ : Γ ⇒ ∆ has any derivation then it has a cut-free
derivation.
Corollary 1 (Consistency). There is no derivation of Σ : · ⇒ ⊥.
Corollary 2 (Orthognality). Suppose Σ : Γ ⇒ ∆ and Γ,∆ have no subterms of the
form 〈a〉t (respectively, λx.t). Then there is a derivation of Σ : Γ ⇒ ∆ that does not
use any nonlogical rules involving abstraction (respectively, λ).
2.5 Conservativity
In this section, we show thatNL⇒ is conservative relative to Pitts’ original axiomatiza-
tion NL [12]. That is, every theorem of NL is provable in NL⇒, and no new theorems
become provable. For convenience, we assume that the same underlying first-order se-
quent calculus is used for NL and NL⇒.
Write `NL Σ : Γ ⇒ ∆ if there is a first-order equational sequent proof of Σ :
Γ, Γ ′ ⇒ ∆. for some set of NL axioms Γ ′. Write `NL⇒ Σ : Γ ⇒ ∆ if Σ : Γ ⇒ ∆ is
derivable in NL⇒ without using any rules involving λ. Write `IX for the intuitionistic
version of provability in system X , that is, provability using only single-conclusion
sequents.
We translate NL formulas ϕ to NL⇒ formulas ϕ∗ by replacing all subformulas of
the form Na.ϕ(a) with Na.ϕ∗(a), for fresh name-symbols a. This translation is uniquely
defined up to α-equivalence. For example, ( Na. Nb.p(a, b))∗ = Na. Nb.p(a, b).
To prove the reverse direction of conservativity, it is necessary to show that NL⇒
sequents involving fresh name-symbols and contexts Σ#a are equivalent to sequents
involving only variables.
Lemma 11 (Name-Elimination). Suppose Σ mentions only variables and `ln Σ#a :
Γ [a] ⇒ ∆[a]. Then `ln Σ, a : Γ [a], a # Σ ⇒ ∆[a], where a # Σ is an abbreviation
for {a # x | x ∈ Σ}.
Theorem 2 (Conservativity). `(I)NL Σ : Γ ⇒ ∆ if and only if `(I)NL⇒ Σ : Γ ∗ ⇒
∆∗
Remark 2 (Semantics). Conservativity justifies NL⇒’s description as a sequent cal-
culus for nominal logic. Although this paper focuses exclusively on proof theory at
the expense of more traditional model theoretic semantics, conservativity guarantees
that NL⇒ inherits Pitts’ nominal set semantics for nominal logic (as well as suffering
from the same completeness problem). Space constraints preclude further discussion;
however, these issues are considered in detail in Cheney’s dissertation and a paper in
preparation.
3 A Sound and Complete Translation of FOλ∇
Miller and Tiu introduced a sequent calculus called FOλ∇, which abbreviates “First-
order Logic with λ-terms and the∇-quantifier” [9]. Like N, the∇ quantifier is self-dual.
However, Nand ∇ have distinctly different properties. Nominal logic and FOλ∇ have
similar aims (reasoning about languages in which binding and fresh name-generation
play an important role), so it is of interest to determine the relationship between FOλ∇
and INL⇒. Also, FOλ∇ has only been studied using proof theory, but nominal logic
has a well-understood semantics [12], so relating the two systems may also elucidate
the semantics of FOλ∇.
In FOλ∇, formulas are generalized to formulas-in-context σ . ϕ, where σ is a
list of local parameters (variables introduced by ∇) and ϕ is a formula built out of
first-order connectives and quantifiers or ∇x.ψ. We abbreviate “formula-in-context”
to “c-formula”. Local parameter contexts are subject to α-renaming, so that a . p(a)
and b . p(b) are considered equal c-formulas. However, c-formulas are not considered
equivalent up to reordering or extension of the contexts. Thus, a, b . p(a), a . p(a), and
b, a . p(a) are all considered different c-formulas.
The sequent calculus rules dealing with ∇ are as follows:
Σ : Γ ⇒ (σ, x) . ϕ
Σ : Γ ⇒ σ .∇x.ϕ ∇R
Σ : Γ, (σ, x) . ϕ⇒ A
Σ : Γ, σ .∇x.ϕ⇒ A ∇L
where in either case x must not already appear in σ or Σ. However, x may appear in
some other local context.
Most of the other sequent rules of FOλ∇ are standard, except for the presence of
local contexts. For example,
Σ : Γ, σ . ϕ, σ . ψ ⇒ A
Σ : Γ, σ . ϕ ∧ ψ ⇒ A ∧L
Σ : Γ ⇒ σ . ϕ Σ : Γ ⇒ σ . ψ
Σ : Γ ⇒ σ . ϕ ∧ ψ ∧R
are the rules dealing with ∧. The only exceptions are the ∀ and ∃ rules. In ∀R and ∃L,
the bound variable is “lifted” to show its dependence on local parameters. Dually, in ∀L
and ∃R, the term substituted for the bound variable may depend on local parameters.
Here are the ∀-rules; the rules for ∃ are similar.
Σ, h:τσ → τ : Γ ⇒ σ . A[h σ/x]
Σ : Γ ⇒ σ . ∀τx.A ∀R
Σ, σ ` t : τ Σ : Γ, σ . A[t/x]⇒ C
Σ : Γ, σ . ∀τx.A⇒ C ∀L
Although∇ and Nhave some properties in common and seem to have similar moti-
vations, the relation between them is not obvious. For example, INL⇒ includes name-
types, and Nmay only quantify over them; FOλ∇ has no name-types, and ∇ may
quantify over any simple type. In addition, Nadmits weakening (ϕ ⇐⇒ Na.ϕ where
a 6∈ FN(ϕ)) and exchange ( Na. Nb.ϕ ⇐⇒ Nb. Na.ϕ), and satisfies ∀x.ϕ(x) ⊃
Na.ϕ(a) ⊃ ∃x.ϕ(x). None of these inferences are derivable with ∇ substituted for N.
On the other hand, ∇ commutes with all propositional connectives, ∀, and ∃, while N
only commutes with propositional connectives.
Gabbay and Cheney studied the problem of embedding FOλ∇ into nominal logic.
They presented a translation (which we call TGC) from FOλ∇ to FLSeq satisfying
a soundness property: if J is derivable in FOλ∇ then its translation [[J ]] is derivable
in FLSeq. However, their translation did not satisfy the corresponding completeness
property: some non-derivable judgments of FOλ∇ were translated to derivable FLSeq
judgments. In particular, the translation failed to reconcile the different behavior of N
and ∇ with respect to weakening and exchange principles.
In the rest of this section, we present a modified translation and prove its sound-
ness and completeness. We also sketch a proof that the original translation is complete
with respect to FOλ∇ with ∇-weakening and exchange. Full proofs will be given in a
companion technical report [4].
Our translation T departs from TGC in two ways. First, TGC translated c-formulas
such as x.ϕ∧ψ by first using N-quantifiers for the local context, then translating ϕ∧ψ,
and finally substituting n(a) for x, resulting in Na.[[ϕ]][n(a)/x] ∧ [[ψ]][n(a)/x]. In this
approach, the head symbol of a translated c-formula was hidden beneath a sequence
of N-quantifiers, which made TGC difficult to analyze. Instead, our translation delays
N-quantification as long as possible and preserves the head symbol for most formulas:
for example, the prior example translates to [[x . ϕ]] ∧ [[x . ψ]]. Any N-quantification is
delayed as long as possible, that is, until the base case for atomic formulas.
The second change is the translation of atomic formulas. As noted earlier, the va-
lidity of c-formulas is sensitive to both the order and number of local parameters in
context. To deal with this, we relativize atomic formulas to their local contexts. This
is accomplished by adding an argument to each atomic formula symbol for a list of
names representing the local context. Let ν∗ be a type with constructors nil : ν∗ and
cons : ν → ν∗ → ν∗, that is, a type of lists of names. We use a conventional comma-
separated list notation for lists: [a, b, c] = cons(a, cons(b, cons(c, nil))). The transla-
tion of an atomic c-formula σ . pt is Na.p∗ [a] t[nτ (a)/σ], where if p : τ → o then
p∗ : ν∗ → τ → o.
Otherwise, T is similar to TGC . Ordinary ∀ and ∃-quantified values are lifted to
equivariant functions applied to lists of names. For example, σ . ∀x:τ ′.p(x) was trans-
lated to Na.∀h:τ1 → · · · τn → τ ′.ev(h) ⊃ p(h nτ (a)), where each ai is the name
representing xi, and ev(x) = ∀a : ν.a # x.
The new translation is shown in full in Figure 6. The function [[·]] translates judg-
ments, contexts, and c-formulas of FOλ∇ to judgments, formula multisets, and for-
mulas of INL⇒ respectively. Note that the context Σ is translated to a set of hy-
potheses ev(x), one for each x ∈ Σ. Here are two examples of the new transla-
tion. The formula ∇x.p ⇐⇒ p is translated to Na.p∗ [a] ⇐⇒ p∗ []. Likewise,
we translate ∇x, y.p x y ⇐⇒ ∇y, x.p x y to Na, b.p∗ [a, b] (n(a))(n(b)) ⇐⇒
Nb, a.p∗ [b, a] (n(a)) (n(b)). Neither of these translated formulas is derivable in nomi-
nal logic.
Lemma 12. If Σ `FOλ∇ t : τ then Σ `INL⇒ t : τ ; in addition, Σ : [[Σ]] ⇒ ev(t).
Also, if Σ : Γ ⇒ A is well-formed then so is [[Σ : Γ ⇒ A]].
Proposition 1 (Soundness). If Σ : Γ ⇒ A is derivable in FOλ∇ then [[Σ : Γ ⇒ A]]
is derivable in INL⇒.
Proof. Similar to, but simpler than, the proof for TGC . uunionsq
[[σ .>]] = >
[[σ .⊥]] = ⊥
[[σ . p t]] = Na.p∗ [a] (t[nτ (a)/σ])
[[σ . ϕ ∧ ψ]] = [[σ . ϕ]] ∧ [[σ . ψ]]
[[·]] = ·
[[σ . ϕ ∨ ψ]] = [[σ . ϕ]] ∨ [[σ . ψ]]
[[σ . ϕ ⊃ ψ]] = [[σ . ϕ]] ⊃ [[σ . ψ]]
[[σ . ∀x:τ.ϕ]] = ∀h:τσ→τ .ev(h) ⊃ [[σ . ϕ[hσ/x]]]
[[σ . ∃x:τ.ϕ]] = ∃h:τσ→τ .ev(h) ∧ [[σ . ϕ[hσ/x]]]
[[σ .∇x:τ.ϕ]] = [[σ, x:τ . ϕ]]
[[Σ, x:τ ]] = [[Σ]], ev(x) (ev(x) = ∀a:ν.a # x)
[[Σ : Γ ⇒ A]] = Σ : [[Σ]], [[Γ ]] ⇒ [[A]]
Fig. 6. Translation T from FOλ∇ to INL⇒
Theorem 3 (Completeness). If [[Σ : Γ ⇒ A]] is derivable in INL⇒ then Σ : Γ ⇒ A
is derivable in FOλ∇.
Proof (Sketch). We break the proof into the following steps:
1. Identify two normal forms for INL⇒ proofs, and show that proofs of translated
sequents can be normalized.
2. Show that proofs of the first normal form are proofs of initial sequents.
3. Show that proofs of the second normal form correspond to applications of FOλ∇
rules.
In the analysis to follow, it simplifies matters to eliminate as many nonlogical rules
as possible from derivations. By the orthogonality property, we need not consider the
rules for abstraction in translated derivations, since abstractions are not used in the
translation. In addition, the nonlogical rules F3 and F4 can also be eliminated, as we
shall now show.
Lemma 13. Suppose Σ has no name-variables. If Σ ` a : ν, then for some a ∈ Σ,
Σ : · ⇒ a ≈ a.
Proposition 2. If [[Σ : Γ ⇒ A]] is derivable then it has a derivation that does not use
F3 or F4.
Proof. To show that F3 cannot be used in a derivation of a translated sequent, note that
[[Γ ]] and [[A]] do not mention equality or freshness, and the formulas [[Σ]] = ∀a.a #
x1, . . . ,∀a.a # xn cannot be instantiated to xi # xi since the variables xi are not of
name-type. We can therefore show that no sequent occurring in the derivation of a trans-
lated sequent can contain a # a using methods similar to those used for consistency
and orthogonality.
Consider a subderivation ending with F4, of the form
Σ : Γ, a # b⇒ ϕ Σ : Γ, a ≈ b⇒ ϕ
Σ : Γ ⇒ ϕ
Name-variables are never introduced in translated derivations, so by Lemma 13, we
have Σ ⇒ a ≈ a, Σ : · ⇒ b ≈ b for some a, b ∈ Σ. If a = b then clearly Σ : · ⇒ a ≈
b, so we can use the second subderivation and cut to derive Σ : Γ ⇒ ϕ. On the other
hand, if a 6= b then clearly Σ : · ⇒ a # b and also Σ : · ⇒ a # b. Using cut and the
subderivation Σ : Γ, a # b we can derive Σ : Γ ⇒ ϕ. uunionsq
Definition 2. A derivation is in first normal form if it uses only the rules NL, NR, hyp,
and nonlogical rules.
A derivation beginning with a left- or right-rule is in second normal form provided
that if the toplevel rule is ∀L, ∀R, ∃L, or ∃R, then the next rule used is ⊃L, ⊃R, ∧L,
or ∧R, respectively.
Before proving that translated derivations always have normal forms, we need some
additional technical machinery. We write ϕˆ(t) for the formula ev(t) ⊃ ϕ(t); transla-
tions of universal c-formulas are always of the form ∀x.ϕˆ(x). We write Γˆ (t) for a set
of formulas ϕˆ1(tn), . . . , ϕˆn(tn) such that ∀x.ϕˆi(x) ∈ [[Γ ]] for each i.
Lemma 14. If Σ is a FOλ∇ context, Σ#a ` t : τ and Σ#a : [[Σ]] ⇒ ev(t) then
Σ ` t : τ .
Lemma 15. If Σ is a FOλ∇ context, Σ#a : [[Σ]], [[Γ ]], Γˆ (t) ⇒ ev(t) then either
Σ : [[Γ ]]⇒ ϕ has a normal derivation for any formula ϕ, or Σ#a : [[Σ]]⇒ ev(t).
Lemma 16. If Σ : Γ ⇒ ϕ has a derivation using only nonbranching nonlogical rules,
then it has either a first normal form derivation or one that starts with F or a logical
rule.
Proposition 3. If [[Σ : Γ ⇒ A]] is derivable, then it has a normal derivation.
Proof (Sketch). First, by Corollary 2 and Proposition 2, [[Σ : Γ ⇒ A]] must have a
derivation that does not use the rules A1, A2, A3, F3 or F4.
Because of subtleties involved in the interaction between the F and ∀L rule, we
need a stronger induction hypothesis. We prove that if Σ#a : [[Σ]], [[Γ ]], Γˆ (t) ⇒ [[A]]
has a derivation, then Σ : [[Σ]], [[Γ ]]⇒ [[A]] has a normal derivation.
Using Lemma 16, the sequent either has a first normal form derivation (in which
case we are done) or begins with F or a logical rule. If it starts with a propositional
rule applied to an element of [[Γ ]], then we are done. The induction steps for F and ∀L
are immediate. For ∃L, ∀R, we can use the invertibility of ∧L and⊃R respectively and
then use ∀L. This leaves the cases for ∃R and for ⊃L applied to an element of Γˆ . For
⊃L we must have subderivations of Σ#a ` t : τ and Σ#a : [[Γ ]], Γˆ (t), ϕ(t) ⇒ [[A]].
Using the lemmas we can show that the witnessing term t does not mention any names,
and so we can construct a derivation starting with ∀L and ⊃L. In the similar case of
∃R, we also need the invertibility of ∧R. uunionsq
We next show that if the derivation is in first normal form, then the FOλ∇ sequent
is derivable. We need two auxiliary facts.
Lemma 17. Suppose x#a ` t : τ and pi · [a] = [b]. Then x#a#b : · ⇒ pi · t ≈
t[b1/a1, . . . , bn/an]
Lemma 18. Suppose that Σ has no name-variables and Γ consists of freshness and
equality formulas only. If Σ : Γ, p t⇒ p u then for some permutation pi of names in Σ,
we have Σ : Γ ⇒ pi · t ≈ u.
Proof. The proof is by induction on the structure of the derivation. Only the hypothesis
and nonbranching nonlogical rules can be involved, of these cases, only F poses a
challenge. In the case for F , the pi obtained by induction may mention the fresh name
a introduced by F ; however, a cannot appear in t or u, so b = pi−1(a) must not appear
in t, and so pi′ = pi ◦ (a b) also works since pi′ · t = pi · (a b) · t = pi · t = u. uunionsq
Proposition 4. Let [[Σ : Γ ⇒ A]] have a first-normal form derivation. Then Σ : Γ ⇒
A is derivable.
Proof. If [[Σ : Γ ⇒ A]] has a first normal form derivation, then A and some element B
of Γ must be of the form σ .∇x.p t. Without loss of generality, we consider the case
where no ∇-quantifiers appear. After stripping off the initial sequence of NL and NR
rules, there must be a subderivation of
Σ#a#b : [[Σ]], [[Γ ]], p∗ [a] θ(t)⇒ p∗ [b] θ′(u)
for some names a, b, where θ = [n(a)/σ] and θ′ = [n(b)/σ′]. Note that θ and θ′ are
one-to-one and so invertible on on their ranges, and that Σ#a ` θ(t) : τ (that is, none
of the b appear in θ(t)).
By Lemma 18, there must be a ground permutation pi such that Σ : · ⇒ pi ·
([a] θ(t)) ≈ [b] θ′(u). Clearly, pi · [a] = [b], so by Lemma 17 we have u[n(b)/σ′] =
θ′(u) ≈ pi · θ(t) ≈ θ(t)[b1/a1, . . . , bn/an] = t[n(b)/σ]. Since [n(b)/σ′] is invertible,
we have u ≈ t[n(b)/σ][σ′/n(b)] = t[σ′/σ], which implies σ . p t ≡α σ′ . p u. uunionsq
Proof (Completeness Theorem). In FOλ∇,∇ commutes with all propositional connec-
tives, ∀, and ∃. Therefore, every judgment is equivalent to one in which ∇-quantifiers
only occur around atomic formulas, that is, in subformulas of the form ∇x.p t. So it
suffices to consider only judgments of this form.
The proof is by induction on the complexity of the judgment Σ : Γ ⇒ A. If the
normalized derivation is of the first form, then by Proposition 4, the sequent is derivable.
If the normalized derivation is of the second form, there are many subcases, one for each
possible starting left- or right-rule. The cases for propositional rules are straightforward.
The remaining cases are those for ∀ and ∃. We will show that translated sequents derived
using ∀L/R, ∃L/R in INL⇒ can be derived using ∀L/R and ∃L/R in FOλ∇.
If the final step of the derivation is ∀R, then the derivation must be of the form
Σ, h : [[Σ]], ev(h), [[Γ ]]⇒ [[σ . ϕ[hσ/x]]]
Σ, h : [[Σ]], [[Γ ]]⇒ ev(h) ⊃ [[σ . ϕ[hσ/x]]] ⊃R
Σ : [[Σ]], [[Γ ]]⇒ ∀h.ev(h) ⊃ [[σ . ϕ[hσ/x]]] ∀R
Note that [[Σ]], ev(h) = [[Σ, h]], so the topmost sequent is of the form [[Σ, h : Γ ⇒
σ . ϕ[hσ/x]]]. By induction, Σ, h : Γ ⇒ σ . ϕ[hσ/x] is derivable, and using ∀R, we
conclude Σ : Γ ⇒ σ . ∀x.ϕ. The ∃L case is similar.
If the final inference is ∀L, then the derivation must be of the form
Σ ` t : τσ → τ
Σ : [[Σ]], [[Γ ]]⇒ ev(t) Σ : [[Σ]], [[Γ ]], [[σ . ϕ[hσ/x]]][t/h]⇒ [[A]]
Σ : [[Σ]], [[Γ ]], ev(t) ⊃ [[σ . ϕ[hσ/x]]]⇒ [[A]] ⊃L
Σ : [[Σ]], [[Γ ]],∀h.ev(h) ⊃ [[σ . ϕ[hσ/x]]]⇒ [[A]] ∀L
Since Σ does not mention name-constants, we have Σ ` t : τσ → τ and also Σ, σ `
t σ : τ in FOλ∇. Note that [[σ . ϕ[hσ/x]]][t/h] = [[σ . ϕ[t σ/x]]] so we also have
Σ : [[Σ]], [[Γ ]], [[σ . ϕ[t σ/x]]]⇒ [[A]], which is the same as [[Σ : Γ, σ . ϕ[t σ/x]⇒ A]].
By induction, Σ : Γ, σ . ϕ[t σ/x] ⇒ A is derivable, and since Σ, σ ` t σ : τ , we can
use ∀L to conclude that Σ : Γ, σ . ∀x.ϕ⇒ A. The ∃R case is similar. uunionsq
Remark 3. If we modify the translation step for atomic formulas by defining [[σ.p t]] =
Na.p t[n(a)/σ] then we obtain a translation TWX that is essentially the same as TGC ,
and is complete with respect to FOλ∇ with ∇-weakening and exchange principles.
We write θ : σ ↪→ σ′ to indicate that θ is a partial injective renaming mapping σ
to σ′. We say that c-formulas are WX-equivalent (σ . A ≡WX σ′ . B) if there is a
θ : σ ↪→ σ′ such that θ(A) = B. For example, x, y . p(x, y) ≡WX y, x, z . p(x, y).
Note that ≡WX subsumes α-equivalence. Let FOλ∇WX be FOλ∇ except that atomic
c-formulas are considered equal modulo ≡WX .
It is not difficult to show that the formulas ∇x.ϕ ⇐⇒ ϕ (where x 6∈ FV (ϕ)) and
∇x.∇y.ϕ ⇐⇒ ∇y.∇x.ϕ are derivable in FOλ∇WX for any formula ϕ. In addition,
using the same techniques as above, we can show that the translation is sound and
complete relative to FOλ∇WX . The proof is the same as that for completeness relative
to FOλ∇, except that we need to show that Proposition 4 holds for atomic c-formulas
equal modulo ≡WX instead of α-equivalence.
4 Related and Future Work
Besides previous formalizations of nominal logic by Pitts, Gabbay, and Cheney (sur-
veyed in Section 1.1), several other logics and type systems have considered rules for
N-quantified formulas or types. Caires and Cardelli [1] investigated a logic incorporat-
ing proof rules for N-quantified formulas based on maintaining a set of side-conditions
involving freshness constraints. However, the freshness constraints are not formulas of
their logic. These rules are similar in spirit to (and partly inspired) the slice-based rules
of FL and FLSeq. Another related system is the type system of Nanevski [10], which
includes rules similar to those of FL for N-quantified types. A third closely related sys-
tem is Scho¨pp and Stark’s dependent type theory for names and binding [13], in which
a bunched context is used to store freshness information. Our freshness contexts and
rules for Nare simpler special cases of the contexts and rules in their theory.
There are several directions for future work. NL⇒ may be useful for developing an
improved proof-theoretic semantics for nominal logic programming. Natural deduction
calculi or type theories for nominal logic based on our approach could be used as the
basis of proof checkers and interactive theorem provers for nominal logic. The existence
of translations from FOλ∇ to NL⇒ suggest that FOλ∇ can be interpreted using the
semantics of nominal logic. Moreover, a semantic approach may lead to a simpler proof
of the completeness of the translations.
5 Conclusions
This paper makes two contributions. First, we present a new sequent calculus for nom-
inal logic which avoids the slices used in the rules for Nin FL and FLSeq. Instead,
our calculus deals with Nusing freshness contexts that encode freshness information
as well as typing information. Although this is partly a matter of taste, we believe that
our approach is easier to use and analyze and provides a more transparent reading of
Nas a proof search operation than any previous system. In particular, the proofs of
cut-elimination and conservativity relative to Pitts’ axiomatization seem simpler and
require fewer technical lemmas than previous attempts.
The second contribution of this paper is an improved translation from FOλ∇ to
intuitionistic nominal logic (INL⇒), which explains the behavior of the∇-quantifier in
terms of N. We show that FOλ∇ can be soundly and completely interpreted in INL⇒,
so any argument carried out in FOλ∇ can also safely be carried out in INL⇒. In
addition, we argued that the translation originally proposed by Gabbay and Cheney is
complete relative to FOλ∇ with weakening and exchange for ∇.
Acknowledgments Discussions with Ian Stark and Uli Scho¨pp and the anonymous
reviewers’ comments were of great value in improving this paper.
References
1. Luı´s Caires and Luca Cardelli. A spatial logic for concurrency–II. Theoretical Computer
Science, 322(3):517–565, September 2004.
2. J. Cheney and C. Urban. Alpha-Prolog: A logic programming language with names, binding
and alpha-equivalence. In Proc. 20th Int. Conf. on Logic Programming (ICLP 2004), number
3132 in LNCS, pages 269–283, 2004.
3. James Cheney. A simpler proof theory for nominal logic. Technical Report EDI-INF-RR-
0237, LFCS, University of Edinburgh, November 2004.
4. James Cheney. A sound and complete translation of generic judgments into nominal logic.
Technical report, LFCS, University of Edinburgh, 2005. In preparation.
5. James R. Cheney. Nominal Logic Programming. PhD thesis, Cornell University, Ithaca, NY,
August 2004.
6. M. J. Gabbay. Fresh logic: A logic of FM, 2003. Submitted.
7. M. J. Gabbay and J. Cheney. A proof theory for nominal logic. In Proceedings of the 19th
Annual IEEE Symposium on Logic in Computer Science (LICS 2004), pages 139–148, Turku,
Finland, 2004.
8. M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax with variable binding.
Formal Aspects of Computing, 13:341–363, 2002.
9. Dale Miller and Alwen Tiu. A proof theory for generic judgments: extended abstract. In
Proc. 18th Symp. on Logic in Computer Science (LICS 2003), pages 118–127. IEEE Press,
2003.
10. Aleksandar Nanevski. Meta-programming with names and necessity. In Proc. 8th ACM
SIGPLAN Int. Conf. on Functional Programming, pages 206–217. ACM Press, 2002.
11. Sara Negri and Jan von Plato. Structural Proof Theory. Cambridge University Press, 2001.
12. A. M. Pitts. Nominal logic, a first order theory of names and binding. Information and
Computation, 183:165–193, 2003.
13. Ulrich Scho¨pp and Ian Stark. A dependent type theory with names and binding. In Pro-
ceedings of the 2004 Computer Science Logic Conference, number 3210 in Lecture notes in
Computer Science, pages 235–249, Karpacz, Poland, 2004.
14. C. Urban, A. M. Pitts, and M. J. Gabbay. Nominal unification. Theoretical Computer Sci-
ence, 323(1–3):473–497, 2004.
