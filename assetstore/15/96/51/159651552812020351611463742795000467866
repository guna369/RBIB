Canonical DecHrCoeawansiotnongiTcCaralTnTRsRfSosSrsminto Equivalent
Claus Hintermeier
INRIA-Lorraine & CRIN-CNRS 615, rue du Jardin Botanique, BP101, 54600 Villers-l s-Nancy
France E-mail: hinterme@loria.fr
Abstract. We prove constructively that the class of ground-con uent
and decreasing conditional term rewriting systems (CTRSs) (without extra variables) coincides with the class of orthogonal and terminating, unconditional term rewriting systems (TRSs). TRSs being included in CTRSs, this result follows from a transformation from any groundcon uent and decreasing CTRS specifying a computable function f into a TRS with the mentioned properties for f. The generated TRS is ordersorted, but we outline a similar transformation yielding an unsorted TRS.
1 Introduction
Many formalisms for algebraic speci cations use conditional equations. Several speci c procedures (like narrowing, induction techniques etc.) extending the unconditional case, have been de ned. However, it is well-known that nite unconditional algebraic speci cations with hidden functions are su cient to describe any computable algebra Bergstra and Tucker, 1987], i.e. any algebra with decidable word problem. Therefore, nite conditional algebraic speci cations with or without hidden functions cannot add any further computable algebras to the class of those being expressible by nite unconditional speci cations with hidden functions.
Analogously, canonical TRSs allow to simulate any Turing machine (cf. Huet and Lankford, 1978; Dauchet, 1989]). Consequently, adding conditions cannot result in more expressivity with respect to computable functions. This result was con rmed by the construction of a canonical TRS with hidden functions for any decidable number algebra by Bergstra and Tucker in Bergstra and Tucker, 1980]. However, apart from the case of orthogonal Bergstra and Klop, 1986] and easily safely transformable Giovannetti and Moisi, 1987] CTRSs, no constructive transformation from CTRSs into unconditional TRSs was developed and proven to be sound yet up to our knowledge.
The general goal of this paper is thus to nd a transformation of an arbitrary ground-con uent, decreasing CTRS into an equivalent TRS, close to the CTRS
in the sense of size, complexity and algebraic interpretation and without explicit restriction of the evaluation strategy. The transformation can be used

in the context of parallel implementations of conditional term rewriting, where it allows to reuse speci c hardware/compiling techniques developed for the unconditional case Goguen, 1987; Aida et al., 1990; Kirchner and Viry, 1992].
Con uence and termination, as required here, is also a common restriction used to achieve completeness of narrowing. We therefore discuss the use of our transformation for proving soundness and completeness of bottom-up strategies for conditional narrowing by reusing the proofs for corresponding strategies in the unconditional case.
Related Work
One way to get a transformation from CTRSs to corresponding TRSs is the construction of a Turing machine, which can be coded as a single left-linear unconditional rewrite rule Dauchet, 1989]. However, working with such Turing machine encodings is of course not practical. Another way is the compilation of the CTRS, as proposed, e.g., by S. Kaplan Kaplan, 1987], who transforms
CTRSs into LISP code. Slight changings in the code generation, eliminating LISP operations involving static memory (setq) and other built-ins (like the
equality test eq), result in a program that can be interpreted in combinatory logics. The latter having only left-linear, unconditional axioms, we get the wanted result.
Nevertheless, the correctness of the compiled code is only guaranteed under innermost evaluation Kaplan, 1987]. This is an additional explicit restriction, which we would like to avoid, as well as the code size incrementation by a factor asymptotically proportional with n log(n) (supposing n be the size of the original code), which is inherent to the translation into combinatory logics. Note that the code size also depends on the signature, since the size of the replacement of the LISP built-in eq grows asymptotically like m2, if the considered signature contains m function symbols.
Similarly, the target code for the CTRS compilation may be the one of an abstract machine, like in numerous implementations integrating functional and logic programming paradigms (e.g. Bosco et al., 1989]), often extending the Warren abstract machine principles. This is also impractical, since abstract machines typically use static memory and we do not know of any interpreter for the corresponding code in form of an unconditional term rewriting system.
For orthogonal, i.e. left-linear and non-overlapping (not necessarily terminating) CTRSs, an e ective transformation was given in Bergstra and Klop, 1986]. In the case of a easily safely transformable CTRS, a non-linear generalisation of orthogonal CTRSs for rules containing at most one condition, a similar transformation can be found in Giovannetti and Moisi, 1987]. H. Aida, J. Goguen and J. Meseguer proposed a transformation of non-linear canonical CTRSs in Aida et al., 1990] using additional arguments and explicit strategy restrictions, but without detailed proofs.
In the functional-logic programming domain, Dershowitz and Plaisted, 1988] and Dershowitz and Okada, 1990] discuss the use of transformations of con-

ditional into unconditional equational theories. In Josephson and Dershowitz, 1989], a transformation of conditional equations into unconditional ones is given in the context of narrowing, i.e. it is possible to backtrack when a condition is not satis ed, in contrast to the work presented in this paper. Sivakumar, 1989] contains a transformation for the purpose of handling non-decreasing equations and for the detection of unfeasible conditions during completion of CTRSs.
A transformation of rst-order logics into discriminator varieties, i.e. algebras containing an if-then-else operation, is proposed in Burris, 1992], based on work by McKenzie and Ackermann. Burris and Jeong (unpublished) also proved linear reducibilty of rst-order logic to unconditional equational logics. Further (unpublished) transformations were used by Chtourou/Rusinowitch and Arts/Zantema, respectively, in the termination domain, however, without preserving equivalences.

Outline of the Transformation

Let R be a form (g !

Cd TifRVSiw2 i1t:h:no]usti

eRxtsr0ia),

variables. The where Var(d)

rules in
i2 1::n]

R are in (V ar(si )

genVearra(lso0if))the

Var(g) and R in Dershowitz

is one of the and Okada,

relations 1990]. If all

!rulRes

(in1)R, #uRse(c2o)nodrit?io!!nsRof(t3y)p, ede(1n)eodnlays,

then R is called natural. In case of type (2) conditions, it is called join-CTRS

and when only type (3) conditions occur, then R is a normal-CTRS.

R is called decreasing, if there is a well-founded conservative extension > of

the rewrite relation is es (l) > (si);

!(tiR)

which for all

contains the substitutions

proper and

subterm relation and satall i 2 1::n]. Our general

conditions for the CTRS to be transformed are decreasingness and con uence

on ground terms. Furthermore, as usual for practical term rewriting systems, we

assume the signature and the rule set to be nite. Under these conditions, nat-

ural and join CTRSs coincide and any join CTRS can be simulated by a normal

CTRS Dershowitz and Okada, 1990], with the help of auxiliary functions which

semantically play the role of hidden operations. Hence, we can assume w.l.o.g.

the CTRS to be normal.

Consider the following example of a con uent and terminating -CTRS for

concatenating lists using the constructors nil and cons from Dershowitz and

Okada, 1990]:

R

=

8>< >:

car(cons(x; y)) ! x; cdr(cons(x; y)) ! y; append(x; y) ! y if null(x) append(x; y) ! cons(car(x);

null(nil) ! tt; null(cons(x; y)) ! ?!R tt; append(cdr(x); y))

ff; if null(x)

?!R

ff

9>= >;

Now, assume we try to replace the two axioms for append by the following unconditional one:

append(x; y) ! if null(x) then y else cons(car(x); append(cdr(x); y))

Remark that the if-then-else used here is the unconditional term rewriting operation with the following two axioms:

if tt then x else y ! x; if ff then x else y ! y

However, the resulting TRS is now non-terminating (cf. Dershowitz and

Okada, 1990]), since the rule can always be applied to the occurrence of append

in the right hand side. The basic idea of our transformation consists in de-

scribing equationally the application of a conditional rewrite rule. Evaluation of

the conditions and their satis ability test is performed by forcing implicitly an

innermost, also called bottom-up, strategy for the evaluation of functions. This

can easily be realized by the use of three ordered sorts. The rst one, called

IrrTerms, contains all irreducible terms, which have a top function symbol of

the form firr. The second one, called T erms, contains additionally -terms,

which may have subterms of sort IrrTerms.

The last one, FrozenTerms is for so-called frozen terms, i.e. for those con-

taining a function symbol of the form ffz. All possible right hand sides r of rules

from R are kept frozen, in order to inhibit their reduction, until the correspond-

ing condition evaluates to true. Therefore, we replace r by a term where every

function symbol g is replaced by gfz, for which no axioms are given. When a

matcher is found and the instantiated condition is satis ed, then and only then

r will be transformed into its original form while applying the matcher.

All arguments of a function are required to be of sort IrrTerms. Functions

will therefore only be applied if all arguments are irreducible, i.e. when we are

sure to get either T (true) or F (false) when normalising the condition of a

rule in R. If none of these conditions is satis ed, then we are sure to get an

irreducible term, i.e. we can replace the top function symbol f by firr. This

technique requires matching to be done by rewriting. Hence, we need to dis-

tinguish variables in non-linear matching patterns, which is impossible without

negation. The adopted solution to this problem replaces variables x in match-

ing patterns, conditions and right hand sides of rules in R by corresponding

constants dx which can easily be distinguished.

y,

rTesopielclutisvterlayt,eitnhims,altecthdinxg; dpyabtteetrhnes.cIonnstthaentfsolrleopwriensgenwtiengastshuemvearxia; ybletso

x and be of

sort IrrTerms. Now, to come back to the example of R, our transformation

yields the following rule as replacement for append's conditional axioms:

append(x; y) ! try cond

m(nautlclhfzp(bd(xa)p=pe=ndtitrirrr(d)x; dy); appendirr(x; y))

then else try cond then else

m(acdnopyanuptselclfnhfzzdp((icbdra(rxar()pfxz=p;(eyd=n)xd)f;ifraripr(rpd)exn; ddyfz)(;cadprpfezn(ddxir)r;(dxy;)y)))

Remark that all used operations are de ned by unconditional rewrite rules given in detail in the sequel of the paper. Informally described, the try-cond-

then-else operation takes four arguments and tries rst to solve the match-

ing problem If successful,

mit aintcsthapnbt(iaaptpesenthdeirrc(odnxd;idtiyo)n; ainpptehnedsiercr(oxn;dy)a)rgiunmthenet

rst argument. with the found

matcher. Let us focus on the lower try-cond-then-else term, i.e. the condition is nullfz(dx) == ffirr. Recall that instantiating a term results in removing all fz-marks. Hence, the terms in the condition get reducible and normalising them

results in irreducible terms, i.e. marked overall by irr. This allows us to decide

the satisfaction of the condition through simple syntactic equality as done by

evaluating the operation == via rewriting, giving either T or F .

Now, if the condition evaluates to T , the term append(x; y) is replaced by the

nsuabmteerlymccoonrsrfezs(pcoanrdfzi(ndgxw);iatphptehnedrfzig(hcdtrhfaz(nddx)s;iddey)o)f,

append's second axiom in R, instantiated by the matcher.

Remark that only then this subterm corresponding with the right hand side

gets reducible since the fz marks are again removed. This freezing of the former

right hand side until the corresponding condition evaluates to true prevents us

from non-termination as in the naive transformation presented rst. In case that both subterms representing the conditions of append's rules in R evaluate to F, append(x; y) is replaced by appendirr(x; y), i.e. the irr-mark is added on top.

conLsiedter?a!!tioRn0s

stand for the for the other

normalisation relation for rules in R and operation

asynmy bToRlsSwRit0h.oAutnaalxoigoomuss

in lead us to the TRS ( 0; R0), s.t. for all -ground terms t, t ?!! R0 t0

i t ?!! R operations

t0. Hence, ( and sorts for

0; R0) gives ( ; R).

an

order-sorted

speci

cation

with

hidden

AthebLycaefttoerTggo(ertyt;inoRgf)iatssltlmaonpodedrefaoltsri.otLnhesetafqnuudrotthcioeenrnmsttoatrenertmsAnjaoltgbeienbtrhae,ohafAl(gieb;rRgaiv)A,e0btohebientgsauinibneaidltgifaerlborimna

A0 of A generated by (cf. Bergstra and Tucker, 1987]). Then, hT ( T ( ; R), if we take to be a one-sorted signature, but not T ( T ( ; R), due to auxiliary operations and constants.

00;; RR00))ji

= =

We start with the de nition of the conditional framework, followed by the

tRra0 nws.fro.rtm. Rat.ioFninianltloy,awneodridsecru-sssorctoemd pslpeexciityc,aptoiossnibalnedexptreonosfisonosf

the properties of and applications

of the transformation. All notations are compatible with the ones used in Der-

showitz and Jouannaud, 1990; Kirchner et al., 1988; Dershowitz and Okada, 1990]. In particular, we call a TRS orthogonal Dershowitz and Jouannaud, 1990],

if it is left-linear all critical pairs are trivial, i.e. of the form (t; t). The reader is

supposed to have basic knowledge in order-sorted rewriting.

2 The Conditional TRS
isL;yejmt2bo0l=s::k(oF]f,iia).eir2.itn0y:o:kio]vobenerllyao,nadauisnnsgusomirstianeldgl,owFneidita.enRsdeigmFnaajrtkutorteh,bawet ohdveierserjlooFianidtceofdonrstiagtinwnaostfudurinessctticniaocnnt easily be transformed into non-overloaded ones via bijective operator renaming.

Let the

furthermore F>0 set of terms over

beanSdia2

1se::tk]oFf ivaarnidabFles

=
X

S
, Ti2(

0:):kf] oFri.thTos(e

;X) over

stands for without

variables, called ground terms.

Let R be a nite, normal, ground-con uent and decreasing CTRS Der-

ss0hy:mo:kwb]i,otlzleotannRdtfhOedkelenafdottahe,at1nh9de90ssi]edt(efooofrfrtsuhhleeosrrtudlecea.nnLoinengticRfal,fiC.beTe. RaolSfl)tr.hueFleofsorilnleoawRchinwgfitfoh2rmfF:ans; nto2p

Rf

=

8><lf1 : >:lfm :

f ...

(t1 1

;

:

:

:

t1n

)

f

(tm 1

;

:

:

:

tmn

)

! !

r1 rm

if if

c1; 9>= cm >;

draepenrpicRlveiaee!dtmioaaontrfkrtseotismhnpaee!tctttieshnresmletlexfiati,cdioin.g2rtahp1eh:i:dmcerr]iuvalareetipolranibo,ertlihstyeunsifetdwhehtroeendiesivsentironlgjfiu<iisshia,prsup.ltlei.esl.dfjAactoruoewlcdcruibtree-

3 The Corresponding Unconditional TRS

We now cation

(giv0e; Ra 0t)r.aRns0foisrma TatRioSnporfo(vab; Rly)cionntouaenntoradnedr-tseorrmteidnautnincogn(dseiteiosencatliospne4c)i-.

3.1 Constructing 0 from

First we de ne 0 to be (S0; F0) with F0 containing F Firr Ffz Fvars,

where Fvars = sets de ned as

fffdixrrj

9l jf

2R 2F

:
g

axnd2fVfafzr(jl)fg,2FFirgr,

and Ffz are respectively,

mirror s.t. f,

function firr and

ffz have the same arity. Additionally, F0 contains some operations de ned later

on, for which we assume that their names do not occur in F Firr Ffz Fvars.

Let S0 denote the sort ordering. S0 contains the following ordered sorts:

IrrT erms S0 T erms S0 F rozenT erms; V ars S0 F rozenT erms

Let X 0 be a set of S0-sorted variables and (x :: A) be the shorthand for 'x is of sort A'. In order to internalise the matching algorithm needed to simulate cTcafuoonFnnndrcdsottzfiiaetofninonzTtneddar:xemlcFosrlauf(rXrlsoeaosz0tr),ietonbwVnTeseaeafrrrsesmphi:nsroenTrFsteeh!0nr.amtAnFdsallnnrffyoou!zrnvec(naTtrTieoi0aer;nbrXmslmef0s)s,-xw.tfeiTitcrrhmTorneasrt:rmaoiisftIny(rteX(hrdfTe0))ie,mn=rTmeaInnrstrriniTnuoenl!FeremdolIsefrs(aoXrRdrTt0t)seob.raytmnhdase

3.2 Rule Transformation

IIwffn(hxwoi1creh;d:ew:ar:ra;entxotgnrmt)oo,uiwmnahdpiceprttleeyhrximst1h;swe,: i:wti:ht;ehxunnnceocreeondpndrtdieotisitoemionnntaaalttclha,hexleficofu(tmtr-i1lri;enl:nfie:ta:oar;frtrgineau)wmfaruigetnnaecitntsrisuootlnfeftsh,f(xew1tfeo;u:nn:ace:te;tidxoernntms)o,.

compare possible variable linear. Unfortunately, it is

images, since impossible to

the pattern decide the

f(ti ; : : :; di e1rence

toinf)

may be nontwo variables

x and y without negation, i.e. we need to replace them by constants dx and

dy, respectively. Distinguishing variables is necessary to do the merging part of

matching and to apply substitutions to variables, both using rewrite rules.

Furthermore, since we want a rule only to be applied if all arguments are

irreducible, we need to attach at any node in the pattern the label irr. This

motivates the de nition of the following two term transformations, used later on

to give the transformation of Rf for each f 2 F, x 2 X 0:

(:)irr f (t1 ;

:::T:T; tenrxm)iisrrrr(X==0

)f!irr x ::

I(TtrIi1rrrrrTT;e:err:mm: ;sst(inXrr0))

(:)cl f (t1

;::T: T: ;etrnmx)scc(llX==0

)f!irr dx

(TtFc1lr;o:z:en:;Ttecnrlm) s

(X

0

)

Let solve and match be operations representing the matching algorithm described in section 3.4 and be a matching equation constructor. Now we can represent the matching problem, which was presented in a simpli ed form using matchpb in the introduction, as the following term:

i0

=

match(solve(f

(

ti 1

;

:

:

:

;

tin)cl

firr(x1; : : :; xn); nil))

The labels f

zalirneatedrymmneondteisonaenddfrreepelzaincigngofvtahrieabrilgehstbhyatnhdeirsicdoerrreisopfonlfid,ini.ge.caotntsatcahnitnsg,

is performed by the following term transformation:

(:)fz f (t1 ;

:
:

TT ::;

etrnmx)ffszz(X==0)fd!xfz

(Ttf1Fzr;oz:e:n:T; tefnrzm)s

(X

0)

The condition (csofnnzdi=ti=onsa0lcn,lt)o:

ci of : :)); be T

lfi

is

represented

by

the

term

c0i

=

(sfz 1

==

s0

cl
1

)

^

(:

:

:

^

a. sRsuemmienmgbtehrethematptteyrmcosnljaubnecltleiodnb, yi.eir. ri,nlickaesethtohsaetplrfiodisucuend-

by cl, are irreducible. Now, the set of rule, assuming xi :: IrrT erms for i 2

rules Rf 1::n]:

can

be

replaced

by

the

following

lf0

:

f (x1 ;

: : :; xn)

!

try else

0 cond t1ry

c0 1

then

rfz 1

...

else else

tfriyrr

(xm0 1;c:o:n:d; xcn0m);then

rmfz

where try-cond-then-else results in the instantiated right hand side if there is

a match and the instantiated condition evaluates to T, otherwise in the fourth

argument. This de corresponding rule

nition in R is

prevents ri from being not applicable. Due to

instantiated and reduced, if the the de nition of decreasingness,

R((errmiiT))ahmmrekaadyytihcbaaeeturgestnrehecenaeotseibnzre-etttewhorafemenRnin0Fac(oltiiims)onlfpionuirnetaaitnnrhgyiwsw.cr,ia.ttssh..et.t.thLheee(tcsoiiRrz)ie0FgreionddfaueRlnceso.esttetoothfFer,usiel.etes.fralf0enddjufctht2iiosnFseogtf.

of unconditional rules originates in the point when the conditions are evaluated.

The semantics of conditional rules suppose a rule to be applied only if its con-

dition is satis ed. Here, in R0, a function will only be evaluated if its arguments

are irreducible, i.e. we force a bottom-up strategy. Therefore, the sort IrrTerms

has to contain exactly all tirr for each t in the original signature . Conse-

quently, we add for any operation symbol g with arity(g) = n 0 in which

does not occur on the top of a left hand side in R, the following rules, where

x1; : : :; xn :: IrrT erms:

g(x1; : : :; xn) ! girr(x1; : : :; xn)

3.3 Auxiliary Functions

In this section, we de ne formally the if then else construct and some boolean

valued operations for deciding syntactic equality and inequality. They are given

in order to prove sort Bool be in S

0t,hxe

existence of orthogonal :: Bool and consider the

rules for these functions. Let the following operator declarations:

F; T : ^ : Bool Bool _ : Bool Bool
== : F rozenT erms === : F rozenT erms if then else : Bool T erms

! Bool ! Bool ! Bool FrozenTerms ! Bool FrozenTerms ! Bool Terms ! Terms

We start with boolean conjunction and disjunction:

x ^ T ! x; x ^ F ! F; T ^ x ! x; F ^ x ! F; x _ T ! T; x _ F ! x; T _ x ! T; F _ x ! x:

Next we de ne syntactic equality == used for the translation of the con-

dAistsiounmsincgi.

Let c; d

x 2

F::0

following axioms: 0

Bool and fT; Fg,

fx;i

;gyi2

::F>F0 0r,osz.etn. Tc

erms 6= d,

for i f 6=

2 g,

1::max(m; we can use

n)]. the

== (c; c)

! T;

== (c; d)

! F;

== ==

(f (f

((xx11

; ;

: :

: :

: :

; ;

xxnn));;

fg((yy11;;

: :

: :

:; :;

yymn))))

! !

(==
F:

(x1;

y1)

^

(:

:

:

^

==

(xn;

yn))

:

:

:);

Remark that these rules are schemas for all combinations of c; d and f; g, respectively. The de nition of syntactic inequality === is dual. Note that the number of rules needed for == and === is a quadratic function over the number of function symbols in F. The if then else mix x function is de ned analogously as in the introduction, using T and F instead of tt and ff, respectively.
3.4 Matching by Term Rewriting The complete unconditional term rewriting system R0 for R is the set of all rules
iosdins.fits.aRRjAol(s0F0iSond(jtpvew.2alpurAr1eisi:tn:amttmdbeh]slnaoeVltsiSacdenhrioeds(elajse(rorMsjlic)fynor))tiro\b)n=eMm(dStafhijtnei2csghst1,aihi:zn:iomesgsru]oapVbSfnrsaodRotrlbi(tt(lMhauetjnmet)id))loaMn=q=stua;;si,ud.sibrsMfoa.stfte.ictcitVhsdaioelojtln2ehyfs.oe1onRr:nn:mmoeaFm]tlVs.oea(jxrs2ckijsa)1ttl:.hl:e=maNdt] ostvtjtjahe.reiTtashhbitazljieets,
matchers are unique in this framework. Our matching algorithm is derived from the set of transformation rules (in the style of Jouannaud and Kirchner, 1991]) shown in Figure 1.

Delete Decompose Con ict
Merging
MergingClash
SymbolClash

M^t t

=) M

M ^ nf (s1; : : : ; s ) ) M ^ ^ ^= s1
M ^ nf (s1; : : : ; s ) ) F=

nf (t1; : : : ; t )

n nt1 : : : s

t

mg(t1 ; : : : ; t )

6if f = g

M ^ ^x t1 ) M ^= 2 Xif x
M ^ ^x t1 )= F

x t2 x t1
and t1 = t2 x t2

2 X 6if x

and t1 = t2

M ^ nf (t1; : : : ; t ) x

)= F

if x 2 X

Fig. 1. MATCH : Matching using Transformation Rules

After wise, the with =
Let P

nnrSeoosjrr2moml1vaa:e:llmidfso;]afrMtmxiojano7!tbcwhtiauPtijhnbg;et,dPhtihirsseesoseeuftmctohcpfeetsryfsuo;clreFomsn,ajViwulunej2crote1bi:o2t:mnaSi]nbx0e,Fjisn.igtf.uS:djoe,l

(M) = ;. if Sol(M) ned as T.

Other=f g

P resuccess; F ailure S0 P resolved S0 MatchP b:

We de ne the pro le of the matching operations as follows:

match : MatchP b

! Presolved

merge : P resolved

! Presolved

solve : MatchP b MatchP b ! MatchP b

solve : P resolved P resolved ! P resolved

solve : P resuccess P resuccess ! P resuccess

: F rozenT erms IrrT erms ! MatchP b

: V ars IrrT erms

! Presuccess

nil : ! P resuccess

none : ! F ailure

We start with the axiomatization of match, merge and solve. Here we need

to know the maximal number of variables in a rule guring in R, denoted

by Vmax, in order to have an upper bound for the number of variables in a

matcher. We can assume Vmax to be given, since the number of rules is -

nite and the rules have a nite number of variables. Assume z :: MatchP b.

Informally, match can be given by match(z) = none if Sol(z) = f g. Other-

wsoilsveTe,(hidefx1Smoal(twzch)1i;nissgoltvaheleg(o:s:riin:tsgholmelvtoein(tdsxeflkffxi1s

7! wk;

nwi1l);

a two

: :

: :

::);)x.k

7!

wk

step process.

gg, let First,

match(z) be an arbitrary

matching problem constructed with solve, and nil is transformed into a

rst presolved form, s.t. all decompositions and clash detections are performed.

Tyd;ihryre1s;ae:n:ad:ryefmpiraerxr;(fmgoir;rnmr)e2:d:FbIyrirrrsT,oelsvr.tem. ifst,sirezrlf.6=::LgMeitrarutsocharsPasrubimtayne(dfxi;crxrir1)r;=;:d:in:rxr6=n2:m:FF=0irrorazrsei.ntty.T(cegirrirmrr)6=s:,

0

solve(cirr cirr; z)

! z;

solve(cirr dirr; z)

! none;

solve(x y; none)

! none;

sol sol

vvee((ffsiiorrlrrv((exx(11x;;1::

: :

: :

;;yxx1nn; ))solvfgei(irr:rr:((:yys11o;;l::v::e::(;;xyynmn));;

z) z) yn

! none; ! ; z) : : :)):

Remark that the right hand sides of the matching equations for solve can be

assumed to be ground terms, since we are only interested in ground con uence

of R0. Therefore, solve always returns a matching problem of sort P resolved.

The second step consists in the merge steps necessary to decide if there is an

ambiguity in the image for a variable.

Consequently, match and IrrT erms, z :: P resolved, z1

:m: Perrgeesubcecceosms ea,nadsszu2m::inFgaivl1u;rve2:

::

V

ars,

w1;

w2

::

mmaertcghe((szo1l)ve(z;

nil))

! !

smoelvreg(ezV;mnaixl()z; 1);

mmeartcghe((nz2o)ne)

! !

nz2o;ne;

merge(soeeilfvll(ssevee(1vnif1=o(n=ve1w:v=21=;^=sowvlv12e)=(tv=h2ewn2sw)o2tlhv; eze()nv))2m!erwge2(;smolevreg(ev(1solvwe(1v;1z)) w1; z)))

Here, mergeVmax fore, we need to

(z) stands for the overload if then

eVlsmeaxtotiBmoeoslappPlirceastoiolvneodf2m!erPgereosnolzv.eTdh. eRree--

mark that as long as merge traverses the list, it is of sort MatchPb. Only after

merge has disappeared, the result is of sort Presuccess or Failure. This de ni-

tion of merge is also the reason why variables need to be replaced by constants:

We need to variables.

decide

the

di

erence

v1

===

v2,

which

is

not

possible

with

'real'

This realisation of matching by term rewriting, especially the merge op-

eration, may for implementation issues result in a considerable slow-down in

comparison with R, although its asymptotical complexity O(n), where n is the

size of the initial matching problem, seems to be the same. However, we claim

that in both of our envisaged applications for the transformation reuse of par-

allel, unconditional rewrite rule machines for CTRSs and soundness/correctness

proofs for conditional narrowing this does not play any role. In the rst case,

matching instructions are already present in the machine architecture and can

therefore replace the rewrite rules. In the second case, the rewrite rules have a

pure proof theoretic purpose and are never applied in reality.

3.5 How to Apply Substitutions

In apply, the rst argument represents the substitution calculated by match

and the second argument is a frozen term containing constants instead of vari-

ables. Remark that apply erases fz-marks. Assuming f 2 F, x :: P resuccess,

yd1e;

: : :yn ne:

::

F rozenT erms,

z

::

T erms,

w

::

I rrT erms

and

v1; v2

::

V ars,

we

apply : P resuccess F rozenT erms ! T erms

apply(nil; z)

! z;

aaaappppppppllllyyyy((((xsxxo;;;lfffv(iferyz(r1(v(y;1y:11:;;:::;:w:y::;;n;yx)y)n)n;)))v)2)

! ! ! !

iffff((iraa(rvpp(1ppallp=yyp((=lxxy;;(vyyx211;)))y;;t1h::)::e;::n:;;:aaw:pp; ppaelllpyysp((elxxya;;(pyyxpnn;l))yy))n(;;x));;v2):

Therefore, apply's rst axiom represents the application of the empty substitution, the second to fourth stand for the homomorphism property of substitutions and the last provides recursive search of a variable replacement in the term representation of a substitution.

3.6 Trying Alternatives
The axiomatisation of try-cond-then-else is done with the help of an auxiliary function called trycond-cond-then-else. The rst operation actually only checks if there exists a matcher for the matching problem given as rst argument and the latter tests the satisfaction of the condition, given in the second argument instantiated by the matcher, if there is one. If the instantiated condition evaluates to T, then the third argument, also instantiated by the matcher, is returned. In

any other case, the fourth argument becomes the result of the operation. Hence, we get the following operator pro les:

try cond then else : MatchPb Bool FrozenTerms Terms ! Terms
trycond cond then else : Presuccess Bool FrozenTerms Terms ! Terms

z2

::LTeterxm; xs.1 T::hPenretshuecacxesiosm, xs2ar:e:

Failure, y as follows:

::

Bool,

z1

::

F rozenT erms

and

try try try try

ccxxootrnn12yddcccoooxxnnnddccdooyynnxdd1tthhcFTeeonnntthhdzze11eanneepllzpzss1l1eeyee(zzlxl22ss1ee;

y) z2 z2

! t!!!hezazn22p:;zp1lye(lxs;ezz12);;

4 Properties of R0

In this section, we prove the correspondence of R0 with R on T ( ), which can be summarised as follows:

8t 2 T ( ); (t ?!! R t0 i t ?!! R0 t0irr)

aoWnf edcostnanrautlelwynictteehromtfhiRenac0,otirtorhneecotenfxeRissst0efononcreTouo(fr

am).daLtecerhtiviRantg0MioonpsetirnaantRdio0fnofsor,rRfoa0lnlnoywRdee0dFrib.vyattihoen

proof in R

4.1 Termination and Correctness of Matching

Lemma 1. R0M is terminating.

Proof. Using the precedence following below for an LPO-ordering, termination of these functions was proved with ELIOS-OBJ Gnaedig, 1992]:

try cond then else > trycond cond then else > match > merge > solve > apply > if then else; ==; === >
^; _ > T; F; none; nil

Now, we
Lemma
variable

show the soundness/completeness
2. Let for all i 2 1::n]; ti 2 T ( disjoint matching problem in T ( ;

of
)
X

our rules and M

in
=

RV0M
i2

w.r.t. 1::n] si

). Let furthermore:

MATCH:
ti be a

M

=

match(solve(scl 1

tirr 1

;

solve(:

:

:

;

solve(scnl

tinrr; nil) : : :)))

Then, and =
=F i

MATCH
so=lvneo(dnxe1.

calculates a matcher = fxi u1; solve(: : : ; solve(dxm

7!umui;gnii2l)1:::m: :]))i).

M ?!! R0
FurthermMore,

Proof. First, note that MATCH is locally con uent, sort decreasing and termi-

narabtiintrga,riy.es.tcroanteguyenwt,itthooM. TAhTerCefHor.e,LweteDcaencocamlcpuolastee aansdolCutoionn oicftMbeuasipnpgliaedn

rst and only if none of these rules are applicable any more, we use Delete

and nally Merging and MergingClash. Remark that SymbolClash is not

needed since all ti are ground. It is su cient to prove that the normalisation of

rMst

corresponds implies the

oonnee-otof -MonAe TwCithHs.uch

a

strategy

and

that

the

termination

of

the

Clearly, Decompose is applicable to some s t i solve's third axiom is applicable to scl tirr. Furthermore, Con ict corresponds in the same strict way with solve's second and fourth axiom, Delete with the rst one. Together with

the fact that solve's last axiom gives the propagation of none to the top, we have

= none after solve if the set of MATCH rules Decompose, Con ict and Delete applied with the strategy corresponding with solve's application gives

F. Furthermore, since these rules only depend on single equations, they cannot

be applicable anymore on the corresponding problem if solve has terminated.

Now, and only now match becomes applicable, since its argument is of sort

P resolved. Then, after

Let the

tdrxaversualboef

the the

rst rst

mmaertcghei,naglleMqueatrigoinnginanMd M's ecurgrrienngtCfolarmsh.

steps possible with this x u in MATCH are done using merge's last axiom.

Since the maximal number of distinct variable constants dx in M is Vmax, it is

su all

cient to let merge traverse the current
possible Merging and MergingClash

term Vmax steps, each

times in order to time propagating

perform the rst

equation to the end.

Since this does not produce any new matching equations, no more steps us-
ing Decompose, Con ict or Delete are applicable now, i.e. MATCH must

have terminated on the corresponding matching problem in T ( ; X ), too. Con-

sequently, the lemma holds.

4.2 Con uence of R0
The con uence of R0 is independent from the ground con uence of R, since we forced bottom-up evaluation and lexicographic rule choice, which results in a unique normal form. Consequently, given a normalising rewriting sequence for some t in R, all alternative rewrite sequences for t di er only in the evaluation ordering of incomparable subterms, which are independent and therefore do not change the resulting normal form. Lemma 3. All rules in R0 are orthogonal and sort-decreasing, i.e. R0 is con u-
ent by construction. Proof. Orthogonal, sort-decreasing TRSs are parallel closed and every left-linear, parallel closed TRS is strongly con uent (cf. Huet, 1980], Lemma 3.3).

4.3 Correspondence with R

Itnn0oirtnmhiRasl,sfeoucrstmiinogn(t,b0)woirtertowimnil-Rlupp0 raoenvvdealvtuhiacatetiovinferassonamd. elegxriocuognrdaptehrimc rut lheacshtohicee,nothrmenalitfohrams

cl
us

tLdoeesnttoaitnteetfhtxhejefo7!clolortrwijerircntggnj2elsfJis

be de ned as in section roefspR. 0faxsj f7!olltocjwlgsj:2J, if

2. The = fxj

substitutions irr and 7! tjgj2J. This allows

Theorem 4. R. If t ?!R

Lte0t

t at

=f the

(t1; : top

: :; tn) 2
position

T(
with

), s.t. the

all rst

subterms are possible rule

irreducible by
lfi in R, then

f (tirr ; 1

:

:

:;

tinrr)

?!R0

t00

=

irr(ri). If no lfi is applicable, then t ?!R0 tirr.

Proof. The proof is an induction on t w.r.t. the termination ordering < for R.

First, remark that apply realizes the application of a substitution cl, given by

match, on some term sfz. This corresponds with the application of a T ( ; X )-

substitution to s 2 T ( ; X ).

By the induction hypothesis together with Lemma 2 we get the correctness

eoevvfaatllhuueaatteeevdsalttuooattThioenintoeRrfmc0iarnepdrreemtsreyenmtabi0teciroonnthdoafct0iRtirhriesn(dcrfe.ifcrzLeeeamlssimnegza,

2yi.)iee..ldasppliyr(r (ri0 ;i)c,0i)sicnacne

be
i0

HbeecnoNcmeo,wets,rnysioncncoeendlofirtihaseptnphleyel(serk0s;dtcias0kcp)apcrladicnsaabbllyleriernumdleuaicintniinoRng,ahwlyteeprokntnahotewisviesfsobrineatellhvekaliu<nastit,eadnthttiaoattFedi0.

rutriagytheOtcs-othnhtaoednrdwnthoisseniende,eeioolfrsfenlaof0gpipalvfilneyd(fisfikr0(ar;tp(ci1trp0ki1r)rl;irc:;ca:a:b::n;l:et;b,intreintrrh)ree)ivns=anlfutooairrrtmrea.dalllitskoedF2t.o

irr (ri ).

1::m], Hence,

etithheeraxiok0 mesvaol-f

Thus, we get the correctness of R0 w.r.t. bottom-up evaluation with lexicographic rule priority in R.

Corollary 5. with ti 2 T (
an evaluation

For every
) for i 2

1b:o:ntt]o, mre-suppecntionrgmlaelxisicaotgioranpht1ic?r!ulRe

t1 ?!R0 tinrr in R0.

t2 : : : ?!R tn
priority, there

in R
exists

of nTorhmisallefaodrsmussinimRm0.ediately to a second corollary concerning the uniqueness

Corollary 6. Let t 2 T ( ). If t ?!! R t00 and 9t0; t ?!! R0 t0, then t0 = (t00)irr.

Proof. (t00)irr

Corollary 5 gives us ?!R0 t0. Hence, t0 =

(tt00?)i!rr ,Rs0in(cte00

)irr. Now, con uence of R0 gives (t00)irr is irreducible by de nition.

us

4.4 Termination of R0

Before we give the proof of termination for all R0-derivations starting with some

t 2 T ( ), let follows: s R substitution ,

R be de ned analogously p if there is a rule l : g s.t. (g) = s and p = (si)

to ! for

dsDoiemfrseVhioi2w2IiItsz.i

and Okada, 1990] as !R s0i in R and a

Theorem 7. All t 2 T ( ) evaluate in R0 within a nite number of steps.

Proof. Assume, for contradiction, there is an in nite derivation starting with t using R0. The goal of this proof is to extract an in nite evaluation of t in R. First of all, recall that all rules in R0F are inapplicable at top of some term u containing a strict subterm not of sort IrrTerms, since the variables of the left haouffastnset0drottsaoissdss]e!uomma?ree!e two!Ref.r0Flsm.ootr.otgsf.0I]ts!rhorrecTtafenIorrlmolronTswl.yeinHrtmgaenkfsoce,reipm,.elta.hfcoweeriattrhfhstoeteurRitnn0FoopnrrmeietrweaatlrdioisetriirsnnivggianastltRiloepsn0Mt:ra.itcTtohrsiuasbbatolevlroemw!ss

?! ?! ?! ?! ?! ?!u t u t u t : : : ;!R R !R R !R R0

0
01 F

!

0 M

1

1
02 F

!

0 M

2

2
03 F

!

0 M

lowRuchetcmeeuFlryrauerrankutfeht0cteeehrr=smasttakotr.,sryiean,tncoleedtgReeutv0Msetarhyseissuisnttmreirencmtitthiesnaudatbetttirnheivrgeam,dttieohorneifvr.uaeLtieiij!sotinfn,ucoirotknhtea>r0imn,0soi,sroesno.tltfyh. seRoontr0Fetlry-mIstRrertp0MrTsae-nasrstbmfeosposrs--. mation :del, which transforms terms of sort IrrT erms into ones of sort T erms by erasing irr-marks and changing the sort of variables accordingly, be de ned as follows:

(:)del : T erms ! T erms

f

irfr

((tt11

; ;

: :

: :

: :

; ;

ttnn))ddeell

= =

f f

((ttdd1eell

1

; ;

: :

: :

: :

; ;

ttdndneell))

(x :: IrrT erms)del = x :: T erms (x :: T erms)del = x :: T erms

Now, we can contradiction to

construct an in nite descending T ( the decreasingness of R. We pass

)-term sequence along the in nite

d(derji)vjat0ioinn

in order to extract it. Let d0 be t.

uotiRsifkm0?a-tiAehp1rs.repsesilIdnuidfcumeausrcbekieivqblje!aulwketeteinootrc0enhiedura,ruukv.scndje!ieetnklsiccl.oetuRnooksett0um0rh.kueaijTc!rrrtrwkhkeiidisstnehc(astodothrjmer)te0hedspiejsuorkincvk0a0d0anstfaoionwornndiktlwy0ht0he>htreheaekpla,pnfsaettinhtcetue,naitehenwandnetciiontsneukgoninpwtrueuitrmtlhehedebsiepnorwmaaRoretsf

wasonimtdhIefwauuekkRs0j0!k-kfrioperrweakrdli0lu0tesc>tesestkpet,spotihnfarenontmhiwneesudtkaaeddnreidtlviaauttotdkieeod(lnuarkusigndhtiktri0lr+h(u1ark.n)0F]0d!.uksRr)itddehemeel.ramrirkorr(terh,)ad,tkc0tf+h. 2iTsbhceeocororrmeemsepso4un,dkdie0ns0l

tainiroennOinittiehcreordr(nwectr0ri)iasv,edaw,itchaiotelilnroer.necHmt0oeiansticnhienie,ntrgawobRdesuo0Fcclau-esndtteebapnypsepctmlheyseustsiRthty0Fitsao-kssfteeteqhppueleaanRpccep0Felii-necsdtoaenntpsostirnuiunskct.atoAinrodtlnlieaortptethrdooecrgceoecdtanusdareinesrecursively to the subderivation starting with irr(c0) and append the result at athsesCheRnolew)dadnrojl+fyin1,(dtfhoDj)ere0areslxjlhtjorkaw0c.itt0ezd.aBsnuedqtuOtehkniascdeiasi,sin1i9nc9o0nn]t.itrea.dBicytiocnontsotrtuhcetidoenc,rewaesinggetnedsjs(?o!f RR,
We conjecture the termination of R0 for all 0-terms. However, this of no interest for our goal in this section: Corollary 8. 8t 2 T ( ); (t ?!! R t0 i t ?!! R0 t0irr) Proof. The right-to-left direction is a consequence of the ground-con uence of R and Corollary 5. From left to right, we can use Theorem 7 with Corollary 6.

5 Complexity

In the following we will brie y and informally discuss complexity issues concern-

ing our transformation. The asymptotic complexity for the code size is quadratic

w.r.t. set in

the R.

number of operator symbols in F The complexity of simpli cation

ianndR0liniseainr

w.r.t. the size of the best/average/worst

rule case

equally linear w.r.t. the one of innermost reductions with lexicographic rule prior-

ity in R, which should represent the worst case. Using the transformation naively

may result in an even worse behaviour, because of the realisation of matching

by rewriting, which replaces probably built-in functions. However, both kinds

of term rewriting systems can easily be compiled into e cient functional or im-

perative languages. Hence, the compiled R and the compiled

dRi 0ersehnocueldbebtewesemnatlhleer

runtime than in

behaviour the naive

of the use

especially when matching by rewriting is replaced by built-in functions.

6 Possible Extensions

We discuss some possible further work, which was not considered in this article, but which should be worth being mentioned.

Unsorted TRS. In order to obtain from R0 an unsorted rewrite system R00 the

iponproetprhaoetsoelerdfstrguhiilraernsdinhasFivdeiertroo)ftblhf0ee

heavily expanded. Instead of the in section 3, we have to use (for following terms:

variable arguments any combination of

f

(girr 1

y( 11

;

:

:

:

;

y p1 1

);

:

:

:

;

gnirr

(yn1

;

:

:

:

;

ynpn

)):

All theorems of this paper observing that the unsorted

slhf0 oiusldonelxytaenpdpliwcaitbhleouatt

problems to this case, the top of some term t

after if all

strict subterms of t are completely marked by irr, provided the derivation starts

with a term theorems, is

sitnillTf(orc)e.dHinenRce0,0.bottom-up

evaluation,

which

is

essential

for

our

All innermost derivations. In order to preserve all innermost derivations

instead of only those, where the rst rule guring in R is applied, we might add

another axiom for the x2 :: P resuccess, y1 ::

Btroyo-lc,ozn1d; -zt2h:e:nF-erloszeenopTeerramtios,n,z3as::suTmerinmgs:x1

::

M atchP

b,

terlsyext1ryccoonnddyx12thcoenndz1T then z2 else z3 ! apply(x2; z2)

Remark that this destroys the orthogonality of R0. Maintaining all derivations,

especially the outermost, is far more complicated and not a conservative extension of our technique.

Sorted CTRSs. Although operationally subsumed by conditions, sorts can

help structuring CTRSs and o er partial functions on the model level. There-

fore, an extension of the transformation for sorted CTRSs should be considered,

too. In fact, our transformation may be extended to this case: Every sort S in

=
Sirr in S,

(F;
S0
the

S) must simply be doubled with a subsort Sirr

S0irr holds whenever subsort declarations

S Sirr

S

S0. Finally, we have S0 IrrT erms and S

S0 S. Additionally, to add for all sorts S S0 T erms. Function

declarations are mirrored in the same way, except that try-cond-then-else must

have operator pro les re ecting the sort of the right hand sides of the conditional

rules. The remaining parts of the transformation maybe kept unchanged.

Non-ground Terms. In order to handle non-ground terms, we need to use
the matching included in the rewrite relation. This can be done along the lines of Aida et al., 1990] using extra-arguments. However, in general the resulting system is then clearly no more orthogonal, but the explicit strategy restriction in Aida et al., 1990] may be replaced by sorted rewriting following our approach.

Extra-variables. An extension of the used techniques to standard CTRSs with
wtsehexoertnmoraubsgvythaorrseiba0iwecblrlpietosinsissgnifibzatlhfeatenebrdystiycrneolsepntalcoanafcttiieBnangetairsottifinlnzingo=gfs=attehnpsed0iwccGliusiarenrnetzcnhiinte(gcmcefor.ar,dtr1ceeh9sp8inno9igtn;idGoeiqnnaungoazftsiilnuof0gbn,esprtw,aitig1tue9ht9i3ot1.hn2bes)] current substitution. But any further details are clearly beyond the scope of this paper. However, this extension may be particularly interesting for a development of narrowing using CTRSs with extra-variables, as recently done for orthogonal CTRSs by Hanus Hanus, 1994].

7 Applications
We give two sample applications of the transformation, in order to underline our claim of usefulness of the transformation.

Parallel Implementation of CTRSs. This was the original problem moti-
vating this work. There are projects of building parallel term rewriting machines. One major goal in the design is, of course, a maximum of simplicity for the architecture a motto that has proven its usefulness by the creation of RISC machines. Hence, most of the projects on such machines deal with unconditional TRSs, but people would also like to be able to treat CTRSs. Our transformation provides a way to use TRS hardware for CTRSs, but once more, a naive use does not provide entire satisfaction, since either the TRS is order-sorted or it contains a big number of rules. This may be avoided by the use of two kinds of ags in term nodes: irr and fz. This is in the vein of decorated TRSs Hintermeier et al., 1994] and ultra ne grained parallelisation techniques for TRSs Kirchner and Viry, 1992]. It may provide a very simple extension of existing architectures.

Narrowing. Any kind of innermost narrowing strategy that is complete for

unconditional term rewriting systems (see Hanus, 1994a] for an overview) can

be reused to do complete narrowing with conditional term rewriting systems.

The sorts used in our transformation automatically provide irreducible solutions.

However, there are slight di culties with the normalisation of non-ground terms,

since the left-linear axiomatization of == enumerates all ground instances when

used with narrowing. A solution is to give up left-linearity and to replace the

axiom (== a restriction

(c; to

c) ! T ) by the non-linear (== completely de ned functions (cf.

(x; x) ! Fribourg's

Tw)o,rktogoenthSeLrOwGit)h.

However, we may extend the result to incompletely de ned functions by reusing

Comon's work on disuni cation. The immediate results of this transformation

are relatively weak, e.g. in comparison to LSE-narrowing for CTRSs without

extra-variables, as de ned by Bockmayr and Werner (these Proceedings). After

an extension of the transformation for CTRSs with extra-variables, it may be

possible to achieve further results.

8 Conclusion
The achieved transformation proves in a constructive way the equivalence of the class of ground-con uent, decreasing CTRSs without extra-variables and (ground-)con uent, terminating TRSs. The transformed system is orthogonal, with one rule only for each function and preserves innermost derivations. The size of the transformed rule set is proportional to m2 n, where m is the cardinality of F and n is the number of rules in the CTRS. It may be used in proving CTRS properties or, practically, for the reuse of hardware designed for the unconditional case.
However, the transformation does not help us proving the ground-con uence of a CTRS, since not all derivations are preserved. In fact, applying the transformation to any non-con uent CTRS results in a con uent TRS. The key to this property of the transformation is the lexicographic rule priority w.r.t. the CTRS, which is realized by the TRS. Using the rule priority explicitly while giving the CTRS should be considered harmful. We think that ground con uence, which

gives the non-ambiguityof operation results, should still be guaranteed by the use of appropriate techniques (cf. e.g. Bergstra and Klop, 1986; Ganzinger, 1991a; Bachmair et al., 1992]). Analogously, the transformation does not seem to help proving termination of the CTRS.
Acknowledgements: I would like to thank C. and H. Kirchner for their
support, P. Viry, I. Alouini and V. Antimirov for discussion on this topic as well as D. Lugiez and M. Rusinowitch for their comments on the project.
References
Aida et al., 1990] H. Aida, G. Goguen, and J. Meseguer. Compiling concurrent rewriting onto the rewrite rule machine. In S. Kaplan and M. Okada, editors, Proceedings 2nd International Workshop on Conditional and Typed Rewriting Systems, Montreal (Canada), volume 516 of LNCS, pages 320 332. Springer-Verlag, June 1990. Bachmair et al., 1992] L. Bachmair, H. Ganzinger, C. Lynch, and W. Snyder. Basic paramodulation and superposition. In Proceedings 11th International Conference on Automated Deduction, Saratoga Springs (N.Y., USA), pages 462 476, 1992. Bergstra and Klop, 1986] J. A. Bergstra and J. W. Klop. Conditional rewrite rules: Con uency and termination. Journal of Computer and System Sciences, 32(3):323 362, 1986. Bergstra and Tucker, 1980] J. A. Bergstra and J. V. Tucker. A characterisation of computable data types by means of a nite equational speci cation method. In J.W. de Bakker and J. van Leuwen, editors, Proceedings 7th ICALP Conference, Noordwijkerhout, volume 81 of LNCS, pages 76 90. Springer-Verlag, 1980. Bergstra and Tucker, 1987] J. A. Bergstra and J. V. Tucker. Algebraic speci cations of computable and semicomputable data structures. Theoretical Computer Science, 50:137 181, 1987. Bertling and Ganzinger, 1989] H. Bertling and H. Ganzinger. Compile-time optimization of rewrite-time goal solving. In N. Dershowitz, editor, Proceedings 3rd Conference on Rewriting Techniques and Applications, Chapel Hill (N.C., USA), volume 355 of LNCS, pages 45 58. Springer-Verlag, April 1989. Bosco et al., 1989] P.G. Bosco, C. Cecchi, and C. Moiso. An extension of WAM for K-LEAF: a WAM-based compilation of conditional narrowing. In Proceedings Sixth International Conference on Logic Programming, Lisboa (Portugal), pages 325 339. The MIT press, 1989. Burris, 1992] S. Burris. Discriminator varieties and symbolic computation. Journal of Symbolic Computation, 13(2):175 208, February 1992. Dauchet, 1989] M. Dauchet. Simulation of Turing machines by a left-linear rewrite rule. In N. Dershowitz, editor, Proceedings 3rd Conference on Rewriting Techniques and Applications, Chapel Hill (N.C., USA), volume 355 of LNCS, pages 109 120. Springer-Verlag, April 1989. Dershowitz and Jouannaud, 1990] N. Dershowitz and J.-P. Jouannaud. Handbook of Theoretical Computer Science, volume B, chapter 6: Rewrite Systems, pages 244 320. Elsevier Science Publishers B. V. (North-Holland), 1990. Also as: Research report 478, LRI. Dershowitz and Okada, 1990] N. Dershowitz and M. Okada. A rationale for conditional equational programming. Theoretical Computer Science, 75:111 138, 1990.

Dershowitz and Plaisted, 1988] N. Dershowitz and D. A. Plaisted. Equational Programming, pages 21 56. J. Richards, Oxford, 1988. Machine Intelligence 11: The Logic and Acquisition of knowledge. Ganzinger, 1991a] H. Ganzinger. A completion procedure for conditional equations. Journal of Symbolic Computation, 11:51 81, 1991. Ganzinger, 1991b] H. Ganzinger. Order-sorted completion: the many-sorted way. Theoretical Computer Science, 89(1):3 32, 1991. Giovannetti and Moisi, 1987] E. Giovannetti and C. Moisi. Notes on the elimination of conditions. In J.-P. Jouannaud and S. Kaplan, editors, Proceedings 1st International Workshop on Conditional Term Rewriting Systems, Orsay (France), volume 308 of LNCS. Springer-Verlag, July 1987. Gnaedig, 1992] I. Gnaedig. ELIOS-OBJ: Theorem proving in a speci cation language. In B. Krieg-Br ckner, editor, Proceedings of the 4th European Symposium on Programming, volume 582 of LNCS, pages 182 199. Springer-Verlag, February 1992. Goguen, 1987] J. A. Goguen. The rewrite rule machine project. In Proceedings of the second international conference on supercomputing, Santa Clara, California, May 1987. Hanus, 1994a] M. Hanus. The integration of functions into logic programming: From theory to practice. Journal of Logic Programming, 19&20:583 628, 1994. Hanus, 1994] M. Hanus. On extra variables in (equational) logic programming. Technical Report MPI-I-94-246, Max-Planck-Institut Saarbr cken, 1994. Hintermeier et al., 1994] C. Hintermeier, C. Kirchner, and H. Kirchner. Dynamically-typed computations for order-sorted equational presentations. In S. Abiteboul and E. Shamir, editors, Proc. 21st ICALP Conference, volume 820 of LNCS, pages 450 461. Springer-Verlag, 1994. Huet and Lankford, 1978] G. Huet and D. S. Lankford. On the uniform halting problem for term rewriting systems. Technical Report 283, IRIA - Laboria, France, 1978. Huet, 1980] G. Huet. Con uent reductions: Abstract properties and applications to term rewriting systems. Journal of the ACM, 27(4):797 821, October 1980. Preliminary version in 18th Symposium on Foundations of Computer Science, IEEE, 1977. Josephson and Dershowitz, 1989] N. Alan Josephson and Nachum Dershowitz. An implementation of narrowing. Journal of Logic Programming, 6(1&2):57 77, March 1989. Jouannaud and Kirchner, 1991] J.-P. Jouannaud and Claude Kirchner. Solving equations in abstract algebras: a rule-based survey of uni cation. In Jean-Louis Lassez and G. Plotkin, editors, Computational Logic. Essays in honor of Alan Robinson, chapter 8, pages 257 321. The MIT press, Cambridge (MA, USA), 1991. Kaplan, 1987] S. Kaplan. A compiler for conditional term rewriting systems. In P. Lescanne, editor, Proceedings 2nd Conference on Rewriting Techniques and Applications, Bordeaux (France), volume 256 of LNCS, pages 25 41, Bordeaux (France), May 1987. Springer-Verlag. Kirchner and Viry, 1992] Claude Kirchner and P. Viry. Implementing parallel rewriting. In B. Fronh fer and G. Wrightson, editors, Parallelization in Inference Systems, volume 590 of LNAI, pages 123 138. Springer-Verlag, 1992. Kirchner et al., 1988] Claude Kirchner, H l ne Kirchner, and J. Meseguer. Operational semantics of OBJ-3. In Proceedings of 15th ICALP Conference, volume 317 of LNCS, pages 287 301. Springer-Verlag, 1988. Sivakumar, 1989] G. Sivakumar. Proofs and computations in conditional equational theories. Phd thesis, University of Illinois, Urbana-Champaign (IL/USA), 1989.

