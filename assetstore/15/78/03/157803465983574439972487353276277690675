Explicit Substitutions 
M. Abadi* L. Cardelli* 
Abstract 
The )tu-calculus is a refinement of the &calculus 
where substitutions are manipulated explicitly. The 
Acr-calculus provides a setting for studying the theory 
of substitutions, with pleasant mathematical proper- 
ties. It is also a useful bridge between the classical 
&calculus and concrete implementations. 
1 Introduction 
Substitution is the e’minence gtise of the X-calculus. 
The classical p rule, 
(Xx.a)b +p a{b/x} 
uses substitution crucially though informally. Here 
a and b denote two terms, and a{b/z} represents 
a where al1 free occurrences of z are replaced with 
b. This substitution does not belong in the calculus 
proper, but rather in an informal meta-level. Similar 
situations arise in dealing with all binding constructs, 
from universal quantifiers to type abstractions. 
A naive reading of the p rule suggests that the sub- 
stitution of b for 1: should happen at once, when the 
rule is applied. In implementations, substitutions in- 
variably happen in a more controlled way. This is 
due to practical considerations, relevant in the im- 
plementation of both logics and programming lan- 
guages. The term a{b/z} may contain many copies 
of b (for instance, if a = azzt); without sophisti- 
cated structure-sharing mechanisms [13], performing 
substitutions immediately causes a size explosion. 
Therefore, in practice, substitutions are delayed 
and explicitly recorded; the application of substitu- 
tions is independent, and not coupled with the ,.0 rule. 
‘Digital Equipment Corporation, Systems Research Center. 
t Ecole Normale Supbieure; part of this work was completed 
while at Digital Equipment Corporation. 
tINRIA Rocquencourt; part of this work was completed 
while at Digital Equipment Corporation. 
Permission to copy without fee all or part of this material is granted 
provided that the copies are not made or distributed for direct 
commercial advantage, the ACM copyright notice and the title of the 
publication and its date appear, and notice is given that copying is by 
pcrmkion of the Association for Computing Machinery. To copy other- 
wise. or to republish, requires a fee and/or specific permission. 
0 1990 ACM 089791-3434/90/0001/0031 $1.50 31 
P.-L. Curien+ J.-J. Livyt 
The correspondence between the theory and its im- 
plementations becomes highly nontrivial, and the cor- 
rectness of the implementations can be compromised, 
In this paper we study the Ao-calculus, a refine- 
ment of the X-calculus [l] where substitutions are ma- 
nipulated explicitly. Substitutions have syntactic rep- 
resentations, and if a is a term and s is a substitution 
then the term a[s] represents u with the substitution 
s. We can now express a p rule with delayed substi- 
tution, called Beta: 
(Ax.u)b -‘Bela +/z) ’ id] 
where (b/z) . id is syntax for the substitution that 
replaces z with b and affects no other variable (“.>’ 
represents extension and id the identity substitution). 
Of course, additional rules are needed to distribute 
the substitution later on. 
The Au-calculus is a suita.ble setting for st.udying 
the theory of substitutions, where we can express and 
prove desirable mathematical properties. For exam- 
ple, the calculus is Church-Rosser and it is a con- 
servative extension of the X-calculus. Moreover, the 
Xa-calculus is strongly connected with the categorical 
understanding of the X-calculus, where a substitution 
is interpreted as a composition [5]. 
We propose the Xa-calculus as a step in closing 
the gap between the classical Lcalculus and concrete 
implementations. The calculus is a vehicle in design- 
ing, understanding, verifying, and comparing imple- 
mentations of the X-ca.lculus, from interpreters to ma- 
chines. Other applications are in the analysis of type- 
checking algorithms for higher-order languages and in 
the mechanization of logical systems. 
When one considers weak reduction strategies, the 
treatment of substitutions can remain quite simple- 
and then our approach may seem overly general. 
Weak reduction strategies do not compute in the 
scope of A’s. Then, there arise no nested substitutions 
or substitutions in the scope of A’s. All substitutions 
are at the top level, as simple environments. An an- 
cestor of the &r-calculus, the Xpcalculus, suffices in 
this setting [5]. 
However, strong reduction strategies are useful in 
general, both in logics and in typechecking higher- 
order programming languages. In fact, strong reduc- 
tion strategies are useful in all situations where sym- 
bolic matching has to be conducted in the scope of 
binders. Thus, a general treatment of substitutions 
is required, where substitutions may occur at the top 
level and deep inside terms. 
In some respects, the Ao-calculus resembles the cal- 
culi of combinators, particularly those of categorical 
combinators [4]. The Xa-calculus and the combina- 
tor calculi all give full formal accounts of the pro- 
cess of computation, without suffering from unpleas- 
ant complications in the (informal) handling of vari- 
ables. They all make it easy to derive machines for 
the X-calculus and to show the correctness of these 
machines. From our perspective, the advantage of 
the )ta-calculus over combinator calculi is that it re- 
mains closer to the original A-calculus. 
There are actually several versions of the calculus of 
substitutions. We start out by discussing an untyped 
calculus. The main value of the untyped calculus is 
for studying evaluation methods. We give reduction 
rules that extend those of the classical X-calculus and 
investigate their confluence. \Ve concentrate on a pre- 
sentation that relies on De Bruijn’s numbering for 
variables [2], and briefly discuss presentations with 
more traditional variable names. 
Then we proceed to consider typed calculi of sub- 
stitutions, in De Bruijn notation. We discuss typ- 
ing rules for a first-order system and for a higher- 
order system; we prove some of their central proper- 
ties. The typing rules are meant to serve in designing 
typechecking algorithms. In particular, their study 
has been of help for both soundness and efficiency in 
the design of the Quest typechecking algorithm (31. 
We postpone discussion of the untyped calculi to 
section 3 and of the typed calculi to sections 4 and 5. 
We now proceed with a gentle technical overview. 
2 Informal overview 
We start with a review of De Bruijn notation, and 
then preview untyped, first-order, and second-order 
calculi of substitutions. 
2.1 De Bruijn notation 
In De Bruijn notation, variable occurrences are re- 
placed with positive integers (caIIed De Bruijn in- 
dices); binding occurrences of variables become un- 
necessary. The positive integer n refers to the variable 
bound by the n-th surrounding X binder, for example: 
The syntax of the untyped Xo-calculus is: 
Terms a::= lIab))LaIu[s] 
Substitutions s ::= id)l]a.s]sot 
This syntax of substitutions corresponds to the in- 
dex manipulations described in the previous section: 
Xx.Xy.xy becomes xx21 l id is the identity substitution {i/i} (for all i) 
In first-order typed systems, the binder types must 
be preserved, for example: 
Xx:A.Ay:B.xy becomes XA.XB. 21 
In second-order systems, type variables too are re- 
placed with De Bruijn indices: 
hAJx:A.x becomes AAl. 
De Bruijn notation is unreadable, but it leads to sim- 
ple formal systems. Hence we use indices in inference 
rules, but variable names in examples. 
Classical /3 reduction and substitution must be 
adapted for De Bruijn notation. In order to reduce 
(/\a)b, it does not suffice to substitute b into a in the 
appropriate places. If there are occurrences of 2, 3, 
4, . . . in a, these become “one off,” since one of the X 
binders surrounding a has been removed. Hence, all 
the remaining free indices in a must be decremented; 
the desired effect is obtained with an infinite substi- 
tution: the /? rule becomes 
(h)b -+p a{b/l,i/2,2/3,...) 
When pushing this substitution inside a, we may 
come across a X term (Xc)(b/i, l/2,2/3,. . .}. In this 
case, we must be careful to avoid replacing the oc- 
currences of 1 in c with b, since these occurrences 
correspond to a bound variable and the substitution 
should not affect them. Hence we must “shift” the 
substitution. In addition, we must “lift” all the in- 
dices of b in order to prevent captures. We obtain 
ik{i/l, b{2/1,3/2,...}/2,2/3,...}. 
This informal introduction to De Bruijn not,ation 
should suffice to give the flavor of things to come. 
2.2 An untyped calculus 
We shall study a simple set of algebraic operators 
that perform all these index manipulations-without 
* . * ‘s, even though we treat infinite substitutions that 
replace all indexes. If s represents the infinite substi- 
tution {a1/i,a2/2,a3/3,. . .}, we write a[s] for a with 
the substitution s. A term of the form a[s] is called a 
closure. The change from { }‘s to [ 1’s emphasizes that 
the substitution is no longer a meta-level operation. 
32 
l t (shift) is the substitution {(i+ 1)/i}; for exam- 
ple, l[l] = 2. Thus, we need only the index I; 
n+lis coded as l[l”], where I” is the composition 
ofnshifts,lo... 0 t. We also write 1’ for id. 
l its] is the value of the De Bruijn index i in the 
substitution s, also written s(i) when s is viewed 
as a function. 
l a . s (the cons of (z onto s) is the substitution 
{a/i, s(i)/(i + I)}; for example, 
a . id = {a/i, l/2,2/3,. . .) 
1 +T = {l/lJ(1)/2,T(2)/3,. . .} = id 
l s o t (the composition of s and t) is the substi- 
tution such that a[s o t] = a[s][t], hence s o t = 
{s(i)/i) ot = (s(i)[l]/i) and, for example, 
id 0 t = {id(i)[2]/i} = {t(i)/i} = t 
to(a.s) = {t(i)[u. s]/i} = {s(i)/ij = s 
At this point, we have shown most of the algebraic 
properties of the substitution operations. In addition, 
composition is associative and distributes over cons 
(that is, (a . s) o t = u[s] . (s o t)). Moreover, the last 
example above indicates that I o s is the “rest” of s, 
without the first component of s; thus, i[s].(fos) = s. 
Using this notation, we can write the Beta rule as 
(Aa)b ~~~~~ a[b . id] 
To complement this rule, we can write rules to eval- 
uate 1, for instance 
l[c.s] -+c 
and rules to push substitution inwards, for instance 
In particular, we can derive an intriguing law for the 
distribution of substitution over X: 
This law uses all the operators (except id), and sug- 
gests that this choice of operators is natural, perhaps 
inevitable. In fact, there are many possible varia- 
tions, but we shall not discuss them here. 
Explicit substitutions complicate the structure of 
bindings somewhat. For example, consider the term 
(X(i[2.id]))[aeid]. We may be tempted to think that 1 
is bound by X, as it would be in a standard De Bruijn 
reading. However, the substitution [2 . id] intercepts 
the index, giving the value 2 to I. Then, after crossing 
over X, the index 2 is renamed to 1 and receives the 
value a. One should keep these complications in mind 
in examining Aa formulas-for example, in deciding 
whether a formula is closed, in the usual sense. 
33 
2.3 A first-order calculus 
When we move to a typed calculus, we introduce 
types both in terms and in substitutions. We assume 
a set of constant types I<. The syntax becomes: 
Types A ::= Ir’ 1 A ---f B 
Environments E ::= nil/A, E 
Terms a ::= 1) ab 1 XA.a 1 a[s] 
Substitutions s ::= idJ+:A.sjsot 
The environments are used in the type inference 
rules, as is commonly done, to record the types of 
the free variables of terms. Naturally, in this set- 
ting, environments are indexed by De Bruijn indices. 
The environment Al, AZ, . . . , A,, nil associates type 
Ai with index i. For example, the axiom for I and 
the rule for X abstraction are: 
A,E I- 1:A 
A,E t- b:B 
E 1 r4A.b:A-+B 
In the first-order Xa-calculus, environments also 
serve as the “types” of substitutions. 1C’e write s :_ E 
to say that the substitution s “has” the environment 
E. For example, the typing rule for cons is: 
E I- a:A E I- s :. E’ 
E I- a:A 9s :, A, E’ 
The main use of this new notion is in typing closures. 
Since s provides the context in which a should be 
understood, the approach is to compute the environ- 
ment E’ of s, and then type a in that environment: 
E I- s :. E’ E’ I- a:A 
E I- ~$1 : A 
2.4 A second-order calculus 
When we move to a second-order system, new sub- 
tleties appear, because substitutions may contain 
types, and environments may contain place-holders 
for types; for example, Bool::Ty . id :. Ty, nil. 
The typing rules become more complex because 
types may contain type variables, which must be 
looked up in the appropriate environments (this 
problem arises in full generality with dependent 
types [12]). In particular, the typing axiom for I 
shown above becomes the rule: 
E I- A::Ty 
A,E t- l:A[t] 
The extra shift is required because A is understood 
in the environment E in the hypothesis, while it is 
understood in A, E in the conclusion. An alterna- 
tive (but heavy) solution would be to have separate 
index sets for ordinary term variables and for type 
variables, and to manipulate separate term and type 
environments as well. 
Another instance of this phenomenon is in the rule 
for X abstraction, given above. Notice that A must 
have been proved to be a type in the environment 
E, while B is understood in A,E in the assumption. 
Then A -+ B is understood in E in the conclusion. 
This means that the indices of B are “one off)) in A -+ 
B. The rule for application takes this into account; a 
substitution is applied to B to “unshift” its indices: 
Et b:AdB Et a:A 
E t- b(a) : B[a:A . id] 
The B[a:A . id] part is reminiscent of the rule found 
in calculi for dependent types, and this is the correct 
technique for the version of such calculi with explicit 
substitutions. However, since here we do not deal 
with dependent types, a will never be substituted in 
B (B wilI never contain the index 1). The substitu- 
tion is still needed to shift the other indices in B. 
The main difficulty in our second-order calculus 
arises in typing closures. The approach described for 
the first order, while still viable, is not sufficient. For 
example, if nof is the usual negation on Bool, we cer- 
tainly want to be able to type 
(Xi.nol(l))[Bool s id] 
or, in a more familiar notation, 
Let x = Boo1 in kX.noi(z) 
(We interpret Let via asubstitution, not via a A,) Our 
strategy for the first-order calculus was to type the 
substitution, obtaining an environment (X::Ty) + id, 
and then type )tz:X.noi(z) in (X::Ty) . id. Unfortu- 
nately, to type this term, it does not suffice to know 
that X is a type; we must know that X is Bool. To 
solve this difficulty, we have rules to push a substi- 
tution inside a term and then type the result. As in 
calculi with dependent types, the tasks of deriving 
types and applying substitutions are inseparable. 
Finally, as discussed below, surprises arise in writ- 
ing down the precise rules; for example the rule for 
typing conses has to be modified. Even the form of 
the judgement E k s :. E’ must be reconsidered. 
Higher-order calculi (possibly with dependent type 
constructions) are also of theoretical and practical im- 
portance. We do not discuss them formally below, 
however, for we believe that the main complications 
arise already at the second order. 
3 The untyped k-calculus 
In this section we present the untyped )ta-calculus. 
We propose a basic set of equational axioms for the 
Aa-calculus in De Bruijn notation. The equations 
induce a rewriting system; this rewriting system suf- 
fices for the purposes of computation. We show that 
the rewriting system is confluent, and thus provides 
a convenient theoretical basis for more deterministic 
implementations of the Xa-calculus. We also consider 
some variants of the axiom system and treatments us- 
ing variable names. 
As in the classical &calculus, actual implementa- 
tions would resort to particular rewriting strategies. 
We discuss a normal-order strategy for Xa evaluation. 
Then we focus on a more specialized reduction sys- 
tem, still based on normal order, which provides a 
suitable basis for abstract XC machines. We describe 
one machine, which extends Krivine’s weak reduction 
machine [ll] with strong reduction. 
3.1 The basic rewriting system 
The syntax of the untyped Ao-calculus is the one 
given in the informal overview, 
Terms a ::= 11 ab 1 Xa 1 a[s] 
Substitutions s::= idlrladslsot 
Notice that we have not included metavariables over 
the sorts of terms and substitutions-we consider 
only closed terms, and this suffices for our purposes. 
(In De Bruijn notation, the variables 1,2,. . . are con- 
stants rather than metavariables.) 
In this notation, we now define an equational the- 
ory for the Xa-calculus, by proposing a set of equa- 
tions as axioms. When they are al1 oriented from 
left to right, the equations become rewrite rules and 
give rise to a rewriting system. The equations fall 
into two subsets: a singleton Beta, the equivalent of 
the classical /3 rule, and ten rules for manipulating 
substitutions, which we call u collectively. 
Beta (Xa)b = a[b . id] 
VarId i[id] = 1 
VarCcms l[a . s] = a 
APP 
Ah 
Wbl = (4mw> 
(xa)[s] = x(a[i . (s 0 T>]> 
CIOS 44 PI = a[s 0 t] 
IdL idos=s 
34 
ShiftId toid=t 
ShiftCons f o (u . s) = s 
Map (a . s) 0 t = u[t] 1 (s 0 t) 
Ass (61 0 $2) 0 s3 = $1 0 (sa 0 s3) 
The equational theory follows from these axioms 
and rules for replacing equals for equals. 
Our choice of presentation is guided by the struc- 
ture of terms and substitutions. The Beta rule elim- 
inates A’s and creates substitutions; the function of 
the other rules is to eliminate substitutions. Two 
rules deal with the evaluation of 1. The next three 
deal with pushing substitutions inwards. The re- 
maining five express substitution computations. We 
prove below that the substitution rules always pro- 
duce unique normal forms; we denote by cr(u) the u 
normal form of a. 
The classical p rule is not directly included, but 
it can be simulated. The crucial fact is that, if 
Ql,...) an,... is a sequence of consecutive integers 
after some point, then the meta-level substitution 
{al/l,. . . ,u,/n,. . .} corresponds closely to an ex- 
plicit substitution: 
Proposition 3.1 If there ezist m 2 0 and p 2 
0 such that am+g = p + q foT all q 2 1, then 
a{al/l, , . . , u,/n, . . ,} = a(u[ai . a2 . . . . . a, . IPI). 
Therefore, the simulation of the ,0 rule consists in 
first applying Beta and then (J until a (I normal form 
is reached. 
As usual, we want a confluence theorem. This the- 
orem will guarantee that all rewrite sequences yield 
identical results, and thus that the strategies used by 
different implementations are equivalent: 
Theorem 3.2 Beta + u is confluent. 
The proof does not rely on standard rewriting tech- 
niques, as Beta + 0 does not pass the Knuth-Bendix 
test (but u does). We come back to this point below. 
Instead, the proof relies on the termination and 
confluence of 6, the confluence of the classical X- 
calculus, and Hardin’s interpretation technique [7]. 
First we show that CY is noetherian (that is, d re- 
ductions always terminate) and confluent. 
Proposition 3.3 u is noetherian and confluent. 
Since 0 is noetherian, let us examine the form of CT 
normal forms. A substitution in normal form is nec- 
essarily in the form ai . (ur . (. . . (a,,, . U) . .)) where 
U is either id or a composition IO (. . . (I 0 I). . #). A 
term in normal form is entirely free of substitutions, 
except in subterms such as i[l”], which codes the De 
Bruijn index n+l. Thus, a term in normal form is a 
classical &calculus term (module the equivalence of 
i[r”] and n+i). 
In summary, the syntax of u normal forms is: 
Terms a ::= r]l[t”]lablXu 
Substitutions s::= idIfnlu.s 
After these remarks on u, we can apply Hardin’s 
interpretation technique to show that the full Au sys- 
tem is confluent. First, we review Hardin’s method. 
Let X be a set equipped with two relations R and 
S. Suppose that R is noetherian and confluent, and 
denote by R(t) the R normal form of I; that 5’~ is a 
relation included in (R U S)* on the set of R normal 
forms; and that, for any z and y in X, if S(I, y) then 
SWW R(Y)). A n easy diagram chase yields that if 
SR is confluent then so is (R U S)‘. 
In our case, we take R to be the relation induced 
by u, that is, R(r, y) holds if zr reduces to y with the 
u rules. We take SR to be classical p conversion, that. 
is, SR(Z, y) holds if y is obtained from z by replacing 
a subterm of the form (Xu)b with u(a[b id]). 
Thus two lemmas suffice for proving confluence: 
Lemma 3.4 p is confEvent on u normalforms. 
Lemma 3.5 If u ~~~~~ b then u(u) -i; a(b). If 
S -Beta t then u(s) +; u(t). 
3.2 Variants 
Some subsystems of u are reasonable first steps to 
deterministic evaluation algorithms. ?Ve can restrict 
u in three different ways. The rule Clos can be re- 
moved. The inference rule 
s = s’ t = t’ 
sot = dot 
can be removed, and the inference rule for the closure 
operator can be restricted to 
s = s’ 
1 [s] = l(s’] 
These restrictions (even cumulated) do not prevent 
us from obtaining u normal forms and confluence, 
through the interpretation technique. 
Confluence properties suggest a second kind of vari- 
ant. Although Beia $ u is confluent, when we view it 
as a standard rewriting system on first-order terms it 
is not even locally confluent. The subtle point is that 
we have proved confluence on closed Xu terms, that 
is, on terms exclusively constructed from the opera- 
tors of the Xu-calculus: In contrast, checking critical 
35 
pairs involves considering open terms over this signa- 
ture, with metavariables (that is, variables x and u 
ranging over terms and substitutions, different from 
De Bruijn indexes 1,2,. . .). 
Consider, for example, the critical pair: 
NWbM -+* a[b[u] . u] 
((Xa)b)[u] +* a[b[u] * (u 0 id)] 
For local confluence, we would want the equation 
(s o id) = s, but this equation is not a theorem of 
c. Similar critical pair considerations suggest the ad- 
dition of four new rules: 
us from the claimed counterexample. There are two 
additional cases for term u normal forms: 
Terms a::= l]i[t”]]ab]Xa]x]x[s] 
We believe that confluence can be proved in this 
case by the interpretation technique. Confluence on 
normal forms would be obtained through an encoding 
of the normal forms in the X-calculus extended with 
constants, which is known to be confluent (x becomes 
a constant; x[s] becomes a constant applied to the 
elements of s). 
3.3 The Xo-calculus with names 
Id a[id] = a 
IdR soid-s 
VarShift l.t= id 
scans l[s] . (to s) = s 
These additional rules are well justified from a theo- 
retical point of view. However, confluence on closed 
terms can be established without them, and they are 
not computationally significant. Moreover some of 
them are admissible (that is, every closed instance is 
provable). More precisely Id and IdR are admissible 
in u, and SCons is admissible in c~ + VarShij?. 
Let us discuss a more traditional formulation of the 
calculus, with variable names z, y, z, . . , , a.s a small 
digression. Two ways seem viable. 
In one approach, we consider the syntax: 
Terms a ::= x(ab(Xx.a)a[s] 
Substitutions s::=id~(a/++ot 
The corresponding theory includes axioms such as: 
Beta (X~.a)b = a[(b/~) . id] 
Varl x[(a/x) * s] = a 
Var2 X[(QlY) . 4 = 44 (x # Y> 
Var3 x[id] = x 
We should particularly draw attention to the last 
rule, SCons. It expresses that a substitution is equal 
to its first element appended in front of the rest. 
This rule is reminiscent of the surjective-pairing rule, 
which deserved much attention in the classical X- 
calculus. Klop has showed that sujective pairing de- 
stroys confluence for the X-calculus [IO]. 
Abs (~x.4[4 = XY.(4(Y/4 .sI) 
(y occurs in neither a nor s) 
The rules correspond closely to the basic ones pre- 
sented in De Bruijn notation. The Abs rule does not 
require a shift operator, but involves a condition on 
variable occurrences. (The side condition could be 
weakened.) The consideration of the critical pairs 
generated by the previous rules immediately suggests 
new rules, for example: 
Similarly, we conjecture that our system is not con- 
fluent when we have metavariables for both terms and 
substitutions. (Local confluence still holds.) The fol- 
lowing term, inspired by Klop’s counterexample [lo], 
seems to work as a counterexample to confluence: 
Y(Y(XAx[l[u o (I . zd)] . (to (u o ((21) id)))])) 
wJ4 . WY) - s> = WY) . Wx) .s> (x f Y> 
These are unpleasant rules. The given rule destroys 
the existence of substitution normal forms. Intu- 
itively, we may take this as a hint that this calcu- 
lus with names does not really enjoy nice confluence 
features. In this respect, the calculus in De Bruijn 
notation seems preferable. 
There is an alternative solution, with the shift op- 
erator. The syntax is now: 
where Y is a fixpoint combinator, x is a term 
metavariable, and u is a substitution metavariable. 
The reader may wonder what thwarts the tech- 
niques used in the last subsection. The point is that 
in Lemma 3.5, our reduction to the classical substitu- 
tion lemma depended on the syntax of substitutions 
in normal form, which is not so simple any more (the 
syntax allows in particular expressions of the form 
u o (1 . id), as in the claimed counterexample). 
Terms a ::= xlablJtx.ala[s] 
Substitutions s::= ia~t((a/z)~s~so2 
\?e can go half way in adding metavariahles. If 
we add only term metavariables, the syntax of sub- 
stitution CT normal forms is unchanged. This protects 
In this notation, intuitively, x[I] refers to x after the 
first binder. The equations are the ones of the Xa- 
calculus in De Bruijn notation except for: 
36 
Beta (Ax.a)b = a[(b/x) . id] 
Varl x[(u/x) . s] = a 
Var2 4WY) ’ 4 = zbl tx # Y) 
Var3 x[id] = 2 
Abs (Xz.a)[s] = xx.(u[(x/x) . (s 0 t)]) 
This framework may be useful for showing the dif- 
ferences between dynamic and lexical scopes in pro 
gramming languages. The rules here correspond to 
lexical binding, but dynamic binding is obtained by 
erasing the shift operator in rule A bs. 
3.4 A normal-order strategy 
As usual, we want a complete rewriting strategy-a 
deterministic method for finding a normal form when- 
ever one exists. Here we study normal-order strate- 
gies (the leftmost-outermost redex is chosen at each 
step). Completeness follows from the completeness of 
the normal-order strategy for the X-calculus. 
The normal-order algorithm naturally decomposes 
into two parts: a weak normal-order algorithm, for 
obtaining weak head normal forms, and recursive calls 
on this algorithm. In our setting, weak head normal 
forms are defined as follows: 
Definition 3.6 A weak head normal form (whnffor 
short) is a Ag term of the form Aa or nal - - - a,,,. 
We write 1 p for the usual (one step) weak normal- 
order fl reduction in the A-calculus, and write -% for 
the (one step) weak normal-order Beta + u reduction 
in the Xa-calculus. Clearly, 1, and 2 are related: 
Proposition 3.7 If a r, b then either u(a) 2, a(b) 
or U(U) and o(b) are identicd. The 1 reduction of 
a ?erminates (with a weak head normal form) i# the 
Z:p reduction of u(a) terminates. 
CorollarS; 3.8 1 is a complete strategy. 
We can also define a system “3, which incorpo- 
rates some slight optimizations (present also in our 
abstract machine, below). In “-“, the rule 
((Au) [s])b “1 a[b . s] 
replaces the rules 
(An)b 5 a[b . id] 
The new rule is an optimization justified by the v 
reduction steps 
ttwsl)b 1* a[(~ (s o t)) o (b . id)] -+* a[b I s] 
which is not allowed in z. 
Both -5 and “2 are weak in the sense that they do 
not reduce under X’s. In addition, “1 is also weak in 
the sense that substitutions are not pushed under X’s. 
In this respect, “1 models environment machines- 
while 5 is closer to combinator reduction machines. 
We do not exactly get weak head normal forms- 
for instance, 2 does not reduce even (X11)(X11) or 
(l[(~ll) . id])(Xll). This motivates a syntactic re- 
striction which entails no loss of generality: we start 
with closures, and all conses have the form a[s].t. Un- 
der this restriction, we cannot start with (~ll)(Xll)~ 
but instead have to write ((Xil)(All))[id], which has 
the expected, nonterminating behavior. We obtain: 
Proposition 3.9 If a 2 b then either C(U) and 
b(b) are identical or u(a) 4, o(b). The y reduc- 
tion terminates (with a term of the form (Xa)[s] or 
ml . . . a,,,) iff the 1, reduction of u(a) terminates. 
3.5 Towards an implementation 
As a further refinement, we adapt “2, to manipulate 
only expressions of the forms c[1] and s o t. The sub- 
stitution t corresponds to the “global environment ,” 
whereas substitutions deeper in a or s correspond to 
“local declarations.” In defining our machine, we take 
the view that the linear representation of a can he 
read as a sequence of machine instructions acting on 
the graph representation of t. 
In this approach, some of the original rules are no 
longer acceptable, since they do not yield expressions 
of the desired forms, For example, the reduct of the 
App rule, (u[s])(b[s]), is not a closure. In order to 
reduce (ab)[s], we have to reduce a[sJ to a weak head 
normal form first. In the machine discussed below! 
we use a stack for storing b[s]. 
The following reducer whnf () embodies these mod- 
ifications to Y. The reducer takes a pair of argu- 
ments, the term a and the substitution s of a clo 
sure, and returns another pa.ir, of one of the forms 
(nai . ..a., id) and (Au’, s’). To compute whnf 0, the 
following axioms and rules should be applied, in the 
order of their listing. W’e proceed by cases on the 
structure of a, and when a is n by cases on the SLPUC- 
ture of s, and when s is a composition t o t’ by cases 
on the structure of t. 
(Xu)[s] : A(a[l -(s or)]) whnf(ia, s) = (An, s) 
37 
whnf(a, sj = (Ad, s’j 
whnf(ab, s) = zohnf(a’, b[s] . s’) 
zuhnf(a,sj = (a’, id) (a’ not an abstraction) 
whnf(ab, sj = (a’(b[s]j, id) 
whnf(n, id) = (n, id) 
whnf(n, t) = (n+l, id) 
whnf(1, u[s] * tj = whnf(a, s) 
whnf (n+i, a . s) = whnf (n, s) 
whnf(n, s o s’) = whnf (n[s], s’) 
whnf(n[id], s) = whnf (n, s) 
whnf(n[t], s) = urh?zf(n+i, sj 
whnf(i[a . ~1,s’) = whnf(a, s’j 
whnf(nti[a. ~1,s’) = whnf(n[s],s’j 
zuhnf(nfs o s’], s”) = zuhnf(n[s], s’ o s”) 
whnf(a[s], s’j = whnf(a, s o s’) 
A simple extension of the rules yields normal forms: 
whnf(a,sj = (Xa’,t) 
d(a, sj = A(nf (a’, 1 . (10 t))) 
whnf(a, s> = (n(al[sll) . . . (~mI~m3)j 4 
nf(a,s) = n(nf(al, slj). . . (nf(a,, smj> 
The precise soundness property of whnf() is: 
Proposition 3.10 Given a and s, whnf(a,s) = 
(a’, s’) is provable if and only if u(a’[s’]) is the weak 
head normal form of o(a[s]j. 
The last step we consider is the derivation of a tran- 
sition machine from the rules for whnf(j. One basic 
idea is to implement the recursive call on u[s] during 
the evaluation of (ab)[s] by using a stack to store the 
argument b[s]. Thus, the stack contains closures. 
The following table represents an extension of Kriv- 
ine’s abstract machine [ll, 5]. The first column rep- 
resents the “current state,” the second one represents 
the “next state.” Each line has to be read as a tran- 
sition from a triplet (Subst., Term, Stack) to a triplet 
of the same nature. To evaluate a program a in the 
global environment s, the machine is started in state 
(s, a, ( )), where ( ) is the empty stack. The ma- 
chine repeatedly uses the first applicable rule. The 
machine stops when no transition is applicable any 
more. These termination states have one of the forms 
(id,n,ul . ... . a,) and (s,Xu, ( )), which represent 
nul a, and (Xa)[s], respectively. 
The machine can be rest,arted when it stops, 
and then we have a full normal form X reducer. 
Subst Term Stack 
t n S 
u[s] * t 1 S 
a.s n+l S 
sod n S 
S ab S 
S Xa b.5’ 
S n[id] S 
S 4tl S 
S’ l[aas] S 
S’ nti[a.s] S 
S” n[s 0 s’] S 
S’ 44 S 
Subst Term Stack 
id n+l S 
S a S 
S n s 
.d 44 s 
S a b[s] .S 
6.s a S 
S n S 
S n+i S 
S’ a S 
S’ 44 s 
s’ 0 s” n[sl s 
s 0 s’ a S 
Specifically, when the machine terminates with the 
triplet (s,Xa, ( >>, we restart it in the initial state 
(1 . (s 0 t),a, ( )I, and when the machine termi- 
nates wit.h the triplet (id,n, ul[s1] . . . . . a,[~,] . ( )), 
we restart n copies of the machine in the states 
(Sl,al,oj,...,(s,,a,,o). 
The machine is correct: 
Proposition 3.11 Starting in the state (s,a, ( )), 
the machine terminates in (id,n, al . . . . . a,,,) ifl 
whnf(a, s) = (nal . . . am, id), and it terminates in 
(s, Xa, ( )j ifl whnf(a, s) = (Xa, s). 
By now, we are far away from the wiidiy non- 
deterministic basic rewriting system ‘of Section 3.1. 
However, through the derivations, we have managed 
to keep some understanding of the successive refine- 
ments and to guarantee their correctness. In great 
part, this has been possible bec.ause the Xc-calculus 
is more concrete than the X-calculus, and hence an 
easier starting point. 
4 First-order theories 
In the previous section, we have seen how to derive 
a machine that can be used as a sensible implemen- 
tation of the untyped )ra-calculus, a.nd in turn of the 
untyped X-calculus. Different implementation issues 
arise in typed systems. For typed calculi, we need not 
just an execution machine, but also a typechecker. As 
will become apparent when we discuss second-order 
systems, explicit substitutions can also help in deriv- 
ing typecheckers. Thus, we want a typechecker for 
the Xu-calculus. 
At the first order, the typechecker does not present 
much diffculty. In addition to the usual rules for a 
classica.1 syst,em Ll, we nlust handle the typechecking 
of substitutions. Inspection of the rules of Ll shows 
38 
that this can be done easily, since the rules are deter- 
ministic. 
In this section we describe the first-order typed Xa- 
calculus. We prove that it preserves types under re- 
ductions, and that it is sound with respect to the 
X-calculus. We move on to the second-order calculus 
in the next section. We start by recalling the syntax 
and the type rules of the first-order X-calculus with 
De Bruijn’s notation. 
Types A ::= K 1 A -+ B 
Environments E ::= nil 1 A, E 
Terms a ::= n 1 AA.a 1 ab 
Definition 4.1 (Theory Ll) 
{Ll-var) A,E I- i:A 
(Ll-varn) 
E I- n:B 
A,E t n+i: B 
(Ll-lambda) 
A,E t b:B 
E I- AA.b:A-+B 
W-vp) . 
E t- b:A+B E I- a:A 
E I- ba:B 
We do not include the p rule, because we now focus A term in u normal form is typeable in S1 iff it. is 
on typechecking-rather than on evaluation. typeable in Ll, and cr reduction -u preserve typings: 
The first-order &r-calculus has the syntax: 
Types A ::= KIA --+ B 
Lemma 4.3 For all a in c~ normalform, E 5.1 ~1.4 
iffE h1 a:A. 
Environments E ::= nil IA, E 
Terms a::= l(ab(XA.a(a[s] 
Substitutions s::= idItja:A.slsot 
Lemma 4.4 (Subject reduction) If a -d CL’ ancf 
E kl a:A, then E I-..1 a’:A. Simzlnrly, ifs -r s’ 
and E’ bl s :. E”, then E’ bl s’ :. E”. 
The type rules come in two groups, one for giving 
types to terms, and one for giving environments to 
substitutions. The two groups interact through the 
rule for closures. 
Definition 4.2 (Theory Sl) 
(Sl-var) A,E t 1:A 
(Sl-lambda) 
A,E k b:B 
E t- XA.b: A - B 
W-44 
E t- b:A+B E !- a:A 
E k ba:B 
(Sl-40s) 
E I- s :. E’ E’k a:A 
E t- a[s] : A 
(ST-id) E k id :. E 
(Sl-shift) A,E k t:.E 
(S l-cons) 
E I- u:A Et- s:.E’ 
E I- a:A.s:.A,E’ 
(Sl-Comp) 
E k s’, :. E” El’ t 5’ :. E’ 
E k s’ o s” :. E’ 
In Sl, we include neither the Beta nor the u axioms. 
Clearly, typechecking is decidable in Sl. \Ve pro- 
ceed to show that Sl is sound. I-is a yrelirninar\.. 
we prove two lemmas. The first lemma relies on the 
notion of u normal form: which was defined in the 
previous section. We use a modified version of the cr 
rules for typed terms; four of the rules change. 
VarCons l[a:A . s] = a 
Abs (X.4.a)[s] = X=l.(a[l:A . (s 0 t)]) 
ShiftCons t o (a:A s) = s 
Map (u:A . s) o t = a[t] :A (s o t) 
The typed version of u enjoys the propertirs of t11e 
untyped version. 
Together, the two lemmas give us soundness: 
Proposition 4.5 (Soundness) If E ksl a:.4 then 
E k~l a(a):A. 
One may wonder whether a cornpletemss result 
holds, as a converse to our soundness result. T:nfw- 
tunately, the answer is no. For instance. if Ll gives a 
t,ype to a but not to b, then Sl cannot give a type to 
l[a.b.id], while Ll gives a type to a(l[cl.b. in]), that 
is, to a. However, if Ll gives types to a aud b. then 
Sl gives a type to 11~~ . b. id]. Conversely, if S1 gives 
a type to l[a . 6. id], theu Ll gives types to a and b. 
These observations suggest a reformulation of the 
sounduess and completeness claim. Informally, me 
would like to show that Sl can give a type to a tcrl1-i 
iff I,1 can give a type to the normal forms of the terns 
a,nd of some subterms tlrat c normalization discardc.. 
39 
5 Second-order theories 
Type rules and typecheckers are also needed for 
second-order calculi. Unfortunately, the situation is 
more complex than at the first order, because types 
include binding constructs (quantifiers). These in- 
teract with substitutions in the same subtle ways in 
which A interacts with substitutions, (We have no 
equivalent of ,O reduction here, but this too reappears 
in higher-order typed systems.) 
In implementing a typechecker (or proofchecker) 
for the second or higher orders, we face the same 
concerns of efficient handling of substitution and cor- 
rectness of implementation that pushed us from the 
untyped X-calculus to the untyped Au-calculus. It is 
nice to discover that we can apply the same concept 
of explicit substitutions to tackle typechecking prob- 
lems as well. 
In order to carry out this plan, we must first ob- 
tain a second-order system with explicit substitu- 
tions, which already incurs several difficulties. Then 
we must refine the system, and obtain an actual type- 
checking algorithm. During this enterprise, we should 
keep in mind the goal of deriving an algorithm that 
is correct and close to a sensible implementation by 
virtue of handling substitutions explicitly. 
Second-order theories are considerably more com- 
plex than untyped or first-order theories, both in 
number of rules and in subtlety. The complication 
is already apparent in the De Bruijn formulation 
of the ordinary second-order X-calculus (L2, below). 
The complication intensifies in the second-order Au- 
calculus (S2) b ecause of unexpected difficulties. (We 
mentioned some of them in the overview.) 
\T’e begin with a description of L2, then we define 
S2 and prove that it is sound with respect to L2. 
Unlike Ll L2, and even Sl, the new system S2 is 
not deterministic. Therefore, we also define a second- 
order typechecking algorithm S2alg, and prove that 
it is sound with respect to S2. 
The syntax and the type rules for the second-order 
X-calculus are: 
Types A::=n(A+B)VA 
Environments E ::= nil 1 A, E 1 Ty, E 
Terms a ::= n 1 XA.a 1 An 1 a6 1 aB 
Definition 5.1 (Theory L2) 
(L’Z-nil) t nil env 
( L’L-ext) 
I- E env E t A::Ty 
I- A,E env 
(L2-ext2) 
(L2-tvar) 
(L2-tvarn) 
(L2-tvarn2) 
(LZtfun) 
(L2-tgen) 
(LS-var) 
(LZvarn) 
(L2-varn2) 
(La-lambda) 
(L2-Lambda) 
W-awl 
(L2-APP) 
t E env 
t- Ty,E env 
t E env 
Ty,E I- i::Ty 
E I- n::Ty E I- A::Ty 
A,E I- n+l::Ty 
E I- n::Ty 
Ty,E I- n+i :: Ty 
E I- A::Ty A,E I- B::Ty 
E I- A-+B::Ty 
Ty,E t- B::Ty 
E I- VB::Ty 
E t A::Ty 
A, E t I : A(l) 
Et- n:B E I- A::Ty 
A,E I- n+i: B(f) 
E I- n:B 
Ty,E t n+l : B(t) 
A,E t- b:B 
E I- XA.b:A+B 
Ty,E I- b:B 
E t AG :VB 
Et b:A+B E f- a:A 
E I- b(a) : B{a:A a id} 
E I- b:VB E i- A::Ty 
E t b(A) : B(A::Ty . id) 
We now move on to the S2 system, with the follow- 
ing syntax: 
Types A ::= 1 1 A + B 1 VA 1 A[s] 
Envi~omnents E ::= nil 1 A? E ) Ty, E 
Terms a ::= I ) 4lA.a 1 Au J ab I aB 1 u[sj 
Substitutions s ::= icl )t 1a:A.s 1A::Ty.s ]sot 
In the previous section, we have seen how to for- 
mulate a first-order Acr-calculus (Sl) by adding one 
40 
closure rule and a group, of substitution rules to the 
first-order &calculus (Ll). In Sl, the task of deriv- 
ing types can be separated from the task of applying 
substitutions. As indicated in the informal overview, 
this approach does not extend to S2. The rules of 
S2 described below are structured in such a way that 
substitutions are automatically pushed inside terms 
during typechecking. The unfortunate side effect is 
a small explosion in the number of rules. We do not 
include an analogue for Sl-clos (in fact, we conjecture 
that it is admissible). 
S2 is formulated with equivalence judgments, for 
example judgments of the form E l- a - b : A. This 
judgment means that a and 6 are equivalent terms of 
type A in the environment E. We can recover the 
standard judgments, with definitions such as 
E k a:A z&f E I- a-a:A 
In S2, equivalence judgments are needed because it is 
not always possible to prove directly E l- a : A, but 
only E l- b : A for a term b that is cr-equivalent to a 
(as in the example above). Formally, in order to prove 
E 1 a - a : A, we first prove E I- a - b : A, and 
then use symmetry and transitivity. Similarly, it is 
not always possible to prove directly E I- a : A, but 
instead E l- a : B for a type B that is u-equivalent 
to A-then we “retype” a from J3 to A. 
We have seen in section 2 how the typing axiom 
for i has to be modified. Similar considerations show 
that the rule for conses, Sl-cons, needs to be modified 
as well, and suggest the following, tentative rule: 
E t- a-b: A[s] E k s-t:.E’ 
E I- A[s] N B[t] :: Ty - 
E I- a:A . s - b:B . t :. A, E’ 
Note that, in the hypothesis, we require that a have 
type A[s] rather than A: the reason is that A is well- 
formed in E’ rather than in E. Furthermore, we re- 
quire that s and t be equivalent substitutions of type 
E’, but in truth their type is irrelevant. This suggests 
a new approach: we deal with judgments of the form 
E I- s - t subs$, 
where p records the length 1 E’ 1 of E’. 
In fact, we could hardly do more than keep track 
of the lengths of substitutions. As the following ex- 
ample illustrates, the type of a substitution cannot be 
determined satisfactorily. In the tentative rule above, 
let E = nil, s = t = Bool::Ty . id, a = b = true, and 
A = I and B = Bo~l. We obtain 
nil I- true:1 es - true: Boo1 . t :. I ::Ty, nil 
where we would more naturally expect Bool::Ty, nil. 
The information that i is Boo1 is not found in the en- 
vironment: s has to be used to check that i is indeed 
Boal. It seems thus that the type of a substitution 
cannot be intrinsically defined. 
With these explanations in mind, the reader should 
be able to approach the rules of the theory S2. 
Definition 5.2 (Theory S2) See appendix 7. 
S2 is sound, in the following sense: 
Proposition 5.3 (Soundness) 
1. If E k..~ a - b : A 
then a(E) b2 u(a) : a(A) and U(U) = a(b). 
2. IfE I-.Yz A-B::Ty 
then a(E) htz cr(A) :: Ty and a(A) = a(B). 
3. If FSP E - E’ env 
then 
4. UE 
l 
~b2 a(E) env and o(E) = a( E’). 
$2 s - s’ substp then for some vn and n 
u(s) = G1 . _. . . Gk . 1” and a(~‘) = 
G’,, .a. .G:,-r”, 
for all q < 772, either G,=Gb=A :: T> 
and a(E) t-L2 A :: Ty for some A, 
or G, = a:A, Gi = a:A’, o(.d[l? o s]) = 
o(A’[tQos’]), and c(E) htz a : a(-l[tq OS]) 
for some a, A, and A’, 
p=m+jEI--n. 
As for Sl, we speculate that the soundness claim for 
S2 can be strengthened, and that a converse com- 
pleteness result then holds. 
We now provide a typechecking algorithm S2alg for 
the second-order calculus. The algorithm is formal- 
lat,ed as a set of rules, for easy comparison with S2. 
For terms that are not closures, S2alg snd L2 op- 
era.te identically. However, these are the least inter- 
esting cases: an actual implementation would manip- 
ulate only closures (as in subsection 3.5). In order to 
typecheck a term a[~], the strategy is to analyze sim- 
pler and simpler components of a lvhile accumulating 
more and more complex substitutious in s. \\‘hen we 
reach an index, we extract the relevant infori,~atir~rl 
from the substitution or from t,he environment. 
Informally, the algorithmic flow of control for each 
rule is: stdrt with the given parts of the conclusion. 
recursively do what the assumpt.ions on top require. 
accumulate the results, and from them prod,Jce the 
unknown parts of the conclusion. For example, if we 
want to type a in the environment E, we select an 
41 
inference rule of S2alg by inspecting the shape of its 
conclusion. Then we move on to the assumptions of 
this rule, recursively; we solve the typing problems 
presented by each of them, and collect the results to 
produce a type for the original term a. 
Some of the rules involve tests for type equivalence; 
two auxiliary 9eduction” judgments are used: 
E k s .x+ s’ subst, and E I- AU A’::Ty 
In these judgments, s’ and A’ are in a sort of weak 
head normal form, namely: s’ is never a composition 
and if A’ is a closure then it has the form i[l”]. 
Definition 5.4 (SZalg) See appendix 8. 
To show that S2alg really defines an algorithm, we 
first notice that only one rule can be applied bottom- 
up in each situation. For the judgments E I- A::Ty 
and E l- A u A’::Ty, we test applicability by cases 
on A: when A = B[s], by cases on B; and when B = I 
by cases on the reduction of s. For E I- a : A, we 
proceed by cases on a; when a = b[s], by cases on b; 
and when b = I by cases on the reduction of s. For 
E t- s su bst, , we proceed by cases on s, and when 
s = t o u by cases on t. For E k s ru s’ subs& 
u-e proceed by cases on s; when s = t o u, by cases 
on t; and when t = 1 by cases on the reduction of U. 
FinalIS*, E t- A ++ B :: Ty is handled by cases on the 
reductions of A and B. 
The following invariants can be used to show that 
the algorithm considers all the cases that may arise 
when the input terms are well typed: 
l IfE l- sms’ subst, then’s’ has one of the 
forms id, l”, a:,4 t, and A::Ty . t. 
l If E t- A u A’ :: Ty then A’ has one of the 
forms 1, 1[~“], B + C, and VB. 
Finally, the algorithm always terminates, with suc- 
cess or failure, because every rule either reduces the 
size of terms or moves terms towards a normal form. 
The algorithm S2alg is sound with respect to S2. 
For example, if E l-szalg A :: Ty then we can prove 
E ks2 -4 - A :: Ty. We conjecture that the algo- 
rithm is also complete, in the sense that for example 
ifE bss A-A’::Tythen E ~~~~~ A::Ty. 
6 Conclusion 
The usual presentations of the X-calculus discreetly 
pla>r dolvn the handling of substitutions. This helps 
in developing the metatheory of the A-calculus, at a 
suitable level of abstraction, We hope to have demon- 
strated the benefits of a more explicit treatment of 
substitutions, both for untyped systems and typed 
systems. The theory and the manipulation of explicit 
substitutions can be delicate, but useful for correct 
and efficient implementations. 
Acknowledgements We have benefited from dis- 
cussions on untyped systems with P. CrCgut, T. Har- 
din, E. Muller, and A. Suarez, and from C. Hibbard’s 
editorial help. 
7 Appendix: Theory 
7.1 Type equivalence 
E I- ANB::Ty 
E l- B-A::Ty 
s2 
E l- A-B::Ty E I- B-C::Ty 
E t- A^,C::Ty 
I- E env 
Ty, E I- 1 - 1:: Ty 
E l- A-A’::Ty A,E l- B-B’::Ty 
E I- A--+B-A’--+B’::Ty 
Ty, E I- B - B’ :: Ty 
E t- QB - QB’ :: Ty 
I- E enu 
E t- i[id] N 1 ::Ty 
E t- 1::Ty E t- A::Ty 
A, E t l[t] - l[r] :: Ty 
E I- 1::Ty 
Ty,E l- i[l] w i[t] :: Ty 
E I- i[t”] :: Ty E I- A::Ty 
A, E I- l[t”+‘] - l[t”+‘] :: Ty 
E I- l[t”] :: Ty 
Ty,E l- l[T"+']- l[T”+‘] :: Ty 
E t- A::Ty . s substp 
E I- i[A::Ty . s] - A :: Ty 
El- s - s’ sub&, E I- l[s'] :: Ty 
E I- i[s] - i[s’] :: Ty 
E t- A[s] -+ B[l:A.(s o I)] :: Ty 
E t- (A + B)js] - A[s] + B[l:A . (s o t)] :: Ty 
E t V(B[l :: Ty. (sot)]) :: Ty 
E l- (VB)[s] - V(B[i::Ty . (s o l)]) :: Ty 
E l- A[sot]::Ty 
E t- A[s][t] - A[s o t] :: Ty 
E I- A-B::Ty t- E - E’ enu 
E’ l- A-B::Ty 
42 
7.2 Term equivalence 
E I- a-b:A 
E t- b-a:A 
E I- a-b:A E t- b-c:A 
E I- a-c:A 
E t- A::Ty 
A, E I- 1 - 1 : A[t] 
E I- A-A’::Ty A,E I- b-b’:B 
E I- XA.b - XA’.b’ : A + B 
Ty,E t b-b’: B 
E I- hb-Ab’:VB 
E I- b-b’:A+B E t a-a’:A 
E t- b(a) - b’(a’) : B[a:A * id] 
E I- b-b’:QB E I- A-A’::Ty 
E I- b(A) - b’(A’) : B[A::Ty . id] 
E I- 1:A 
E I- l[id] - 1 : A 
Et- 1:A E t B::Ty 
B, E I- l[tl - l[tl : Attl 
Et i:A 
TY,E I- l[t] - l[tl : A[tl 
E I- i[t”] : A E t B::Ty 
B, E I- l[t”+l] - l[t”+‘] : A[t] 
E I- l[t”] : A 
Ty,E I- l[t”+l] - l[t”+‘] : A[tl 
E I- a:A .s subsip 
E t- l[a:A.s]-a:A[s] 
EI-s-s’ subsfp E t- l[s’] : A 
E t I[S] - I[s’] : A 
E I- XA[s].b[l:A . (sot)] : B 
E I- (AA.b)[s] - XA[s].b[l:A . (s o t)] : B 
E t A(b[l::Ty + (so r)) : B 
E t (Ab)[s] - A(b[i::Ty . (s o t)]) : B 
E I- W>(+l> : A 
E t- W[sI - (bbl)(a[sl> : A 
E t- wl)Msl) : B 
E I- %Wl - P+~l)(Abl) : B 
E t- a[s ot] : A 
E I- a[s][t] - a[s ot] : A 
E I- a-b:A Et A-B::Ty 
E I- a-b:B 
E t a-b:A t E-E’ env 
E’ I- a-b:A 
7.3 Substitution equivalence 
E t- s - t subst, 
E t- t - s substp 
E t s - t sub& E I- t - u subsi, 
E t s - u subst, 
t E env 
E r- id - id substlEt 
E t A::Ty 
A, E t t - t substIE, 
I- E env 
Ty,E t 1 - t substIE 
E t .s - t subst, E t A[s] - B[t] :: TJ 
E I- a - b:A[s] 
E t a:A . s - b:B -t subst,+I 
E t A-B::Ty E I- s - t subst, 
E I- A::Ty .s - B::Ty.t substp+l 
E I- s - s’ substp 
E t idos-s’ s,ubst, 
E t t subs+, 
E t r o id - t subst, 
Et s-s’ subst, E I- a : A[s] 
E t to (a:A s) - s’ substp 
E I- s-s’ substp E I- .4::Ty 
E t t o (A::Ty s) - s’ substp 
E I- s - s’ szrhstp+I 
E I- tos - 10s’ subsip 
E t a[t]:A . (s o t) substp 
E t (a:A . s) o 1 - a[t]:A s (s o t) subsf,, 
E t A[t]::Ty (sot) subsip 
E t- (A::Ty . s) o t - A[t]::Ty (s o t) .subatp 
E I- so (1 o IL) subsi>, 
E t (sot)orr - s o (t o u) subhip 
E k s - t substp t E- E’ ~1111 
E’ t s N t substp 
43 
7.4 Environment equivalence 
t E - E’ env 
I- E’ - E env 
I- E-E’ env I- E’- E” env 
I- E-E” env 
t- nil - nil env 
I- E - E’ env E I- AaB::Ty 
I- A,E-B,E’ env 
t E - E’ env 
I- Ty,E- Ty, E’ env 
8 Appendix: Algorithm S2alg 
8.1 Inference for types 
I- E env 
Ty,E I- i::Ty 
E I- A::Ty A,E I- B::Ty 
E k A-+B::Ty 
Ty,E I- B::Ty 
E I- VB :: Ty 
Ty, E I- s w id sub&, 
Ty, E I- l[s] :: Ty 
E J- i::Ty E !- A::Ty 
A, E t- i[t] :: Ty 
Et- i::Ty 
Ty, E I- l[t] :: Ty 
E I- l[t”] :: Ty E I- A::Ty 
A, E t- I[,“+‘] :: Ty 
E t- i[t”] :: Ty 
Ty, E t i[t”+‘] :: Ty 
E k s w A::Ty . t subs& 
E I- I[S] :: Ty 
Eks’L,t” s&t, E I- i[t”] :: Ty 
E t- l[s]::Ty 
E I- A[s] :: Ty 
A[s], E I- B[I : A. (s o t)] :: Ty 
E I- (A4 -+ B)[s] :: Ty 
Ty, E I- B[l::Ty ’ (so t)] :: Ty 
E k (VB)[s] :: Ty 
8.2 Inference for terms 
E I- A::Ty 
A, E I- 1 : A[t] 
E I- A::Ty A,E I- b:B 
Et AA.b:A-+B 
Ty,E I- b:B 
E t hb:\dB 
Et b:A-+B E t a:A 
E I- b(a) : B[a:A . id] 
E t- b:VB E I- A::Ty 
E I- b(A) : B[A::Ty 3 id] 
A, E t s R++ id subst, 
A, E t- i[s] : A[t] 
E t 1:A E I- B::Ty 
B, E I- 1-h] : A[t] 
E I- i:A 
TY,E t l[tl : AhI 
E I- l[t”] : A E k B::Ty 
B, E I- l[t”+‘] : A[t] 
E t l[t”] : A 
TY,E t l[t”+‘] : A[t] 
E I- s m a:A .t substp 
E I- l[s] : A[t] 
Et s-f” substp E t i[t”] : A 
E I- I[S] : A 
A[s], E k b[l : A + (so I)] : B 
E t (XA.b)[s] : A[s] + B 
Ty, E t- b[i::Ty . (s o t)] : B 
E l- (hb)[s] : VB 
E t b[s]:A-+B E I- a[s] : A’ 
E I- A++A’::Ty 
E t- (b(a))[s] : B[a[s] : A . id] 
E I- b[s] : VB E I- A[s] :: Ty 
E I- (b(A))[s] : B[A[s]::Ty . id] 
E t A[sot]::Ty 
E k A[s][t] :: Ty 
E t a[sot] : A 
E t a[s][t] : A 
44 
8.3 Inference for substitutions 
t E env 
E I- id subsilel 
E I- A::Ty 
A, E I- t substlEt 
t E env 
Ty, E k r substlst 
E t a:B E I- s substp 
E I- A[s] c+ B :: Ty 
E I- a : A . s substp+l 
E I- A::Ty E I- s substp 
E k A::Ty . s subsipS 
E I- s subst, 
E I- id o s subs$ 
E I- s subst,+l 
E k t o s substp 
E I- a[t] : A. (s o t) subs$ 
E I- (Q : A -s) o t substp 
E t A[t]::Ty . (sot) subst, 
E I- (A::Ty . s) o t substp 
E t so (t ou) subst, 
E t (sot)ou subst, 
8.4 Substitution reduction 
t E env 
E t id ry id substl,q 
E t i::Ty 
A, E t t - t substtq 
t E env 
Ty, E t t - t subst\,q 
E t A[s] :: Ty E I- a:B 
E t B w A[s] :: Ty E t s subst, 
E t a : A. s w a : Aa s substp+l 
E t A::Ty E t s subst, 
E I- A::Ty - s ru A::Ty 1 s substp+l 
E t s w s’ subst,, 
E t idos - s’ substp 
E t s - id substp+l 
E t t o s ‘u 1 substp 
Etsut” substp+l 
E t to s r~* tnS1 substp 
E t s-a:A.s’ subst,+l 
E !- s’ - s” sub& 
E t t OS - s” substp 
E t s ‘L* A::Ty .s’ substp+l 
E t s’ u s” substp 
E t fos-s” su bsiP 
E t a[t] : A (s o 1) subst, 
E t (u : A. s) o t ru u[t] : A. (s o t) subst, 
E t A[t]::Ty . (sot) substp 
E t (A::Ty.s)ot Q A[t]::Ty . (s o t) subsip 
E t so (t o u) - v svbstp 
E t (s o t) o u - v substp 
8.5 Type reductions 
I- E env 
Ty,E t IC\AI::T~ 
E t- A::Ty. A,E k B::Ty 
Et A--,B-A-B::Ty 
Ty,E t B::Ty 
E t VBvVB::Ty 
Ty, E t s - id subst, 
Ty, E I- l[s] - 1 :: Ty 
Et s-T” substp E t i[r”] :: Ty 
E I- i[s] - i[t”] :: Ty 
E t s ry A::Ty s’ suhstp 
E t A[s’] w B :: Ty 
E I- i[s] - B :: Ty 
E t A[s] :: Ty 
A[s],E I- B[l: A.(so~)]::Ty 
E t (A 3 B)[s] r\~ A[s] i B[I : =1 (s o t)] :: Ty 
Ty,E t B[i::Ty+of)] ::T> 
E t- (VB)[s] - V(B[i::Ty (s o t)]) :: Ty 
E t A[sot]-B::Ty 
E t A[s][t] - B :: Ty 
45 
8.6 Type equivalence 
E t .4~1::Ty E t A’ r\~ 1 :: Ty 
E t AoA’::Ty 
E I- Arr*B-+C::Ty 
E t A’wB’--+C’::Ty 
E k B++B’::Ty B,E t C-C’ ::Ty 
E t Awd4’::Ty 
Et AuVB::Ty E t A’wVB’::Ty 
Ty,E I- B+-+B’::Ty 
E t A++A’::Ty 
E t A ‘u l[t”] :: Ty E C A’ Q l[t”] :: Ty 
E k A+-+A’::Ty 
8.7 Inference for environments 
t nil env 
t E env E t A::Ty 
t A, E env 
t E env 
t Ty, E env 
References 
[I] H.P. Barendregt, The Lambda Calculus: Its Syn- 
tar and Semantics, North Holland, 1985. 
[2] S. De Bruijn, Lambda-calcuIus Notation with 
Nameless Dummies, a Tool for Automatic For- 
mula X,Ianipulation, Indag. Mat. 34, pp. 381-392, 
1972. 
[3] L. Cardelli, Typeful Programming, SRC Report 
?\‘o. 45, Digital Equipment Corporation, 1989. 
[4] H.P. Curry and R. Feys, Combinatory Logic, 
Vol. 1, North Holland, 1958. 
[>] P.-L. Curien, The Xp-calculi: An Abstract 
Framework for Closures, unpublished (prelimi- 
nary version printed as LIENS report, 1988). 
[G] P.-L. Curien, Categorical Combinators, Seqmen- 
iral’ .-llgoriihms and Functional Programming, 
Pitman, 1986. 
[S] T. Hardin, A. Laville, Proof of Termination of 
the Rewriting System SUBST on CCL, Theoret- 
ical Computer Science 46, pp. 305-312, 1986. 
[9] G. Huet, D.C. Oppen, Equations and Rewrite 
Rules: A Survey, in Formal Languages Theory: 
Perspectives and Open Problems (R. Book, edi- 
tor), pp. 349-393, Academic Press, 1980. 
[lo] J.W. Klop, Combinatory Reduction Systems, 
Math. Center Tracts 129, Amst.erdam, 1980. 
[ll] J.-L. Krivine, unpublished. 
[I21 P. Martin-Lijf, Intuitionistic Type Theory, notes 
by G. Sambin of a series of lectures given in 
Padova in 1980, Bibliopolis, 1984. 
[13] C.P. Wadsworth, Semantics and Pragmatics of 
the Lambda Calculus, Dissertation, Oxford Uni- 
versity, 1971. 
[7] T. Hardin, Confluence Results for the Pure 
Strong Categorical Combinatory Logic, to ap- 
pear in Theoretical Computer Science, 1988. 
46 
