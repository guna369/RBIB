Intersection Type Assignment Systems
(Theoretical Computer Science, 151(2):385-435, 1995)
Steffen van Bakel
Afdeling Informatica, Universiteit Nijmegen, Toernooiveld 1, 6525 ED Nijmegen, Nederland
steffen@cs.kun.nl
Abstract
This paper gives an overview of intersection type assignment for the Lambda Calculus,
as well as compare in detail variants that have been defined in the past. It presents the
essential intersection type assignment system, that will prove to be as powerful as the well-
known BCD-system. It is essential in the following sense: it is an almost syntax directed
system that satisfies all major properties of the BCD-system, and the types used are the
representatives of equivalence classes of types in the BCD-system. The set of typeable terms
can be characterized in the same way, the system is complete with respect to the simple type
semantics, and it has the principal type property.
Introduction
In the recent years several notions of type assignment for several (extended) lambda calculi
have been studied. The oldest among these is a well understood and elegantly defined
notion of type assignment on lambda terms, known as the Curry type assignment system
[14]. It expresses abstraction and application, and can be used to obtain a (basic) functional
characterization of terms. It is well known that in that system, the problem of typeability
Given a term M, is there a basis B and a type σ such that B `M:σ?
is decidable, and that it has the principal type property. These two properties found their
way into programming, mainly through the pioneering work of R. Milner [28]. He intro-
duced a functional programming language ML, of which the underlying type system is an
extension of Curry’s system. The extension consists of the introduction of polymorphic func-
tions, i.e. functions that can be applied to various kinds of arguments, even of incomparable
type. The formal motivation of this concept lies directly in the notion of principal types.
Though the Curry system is already powerful and convenient for use in programming
practice, it has drawbacks. It is, for example, not possible to assign a type to the term
(λx.xx), and terms that are β-equal can have different principal type schemes. The In-
tersection Type Discipline as presented in [10] by M. Coppo, M. Dezani-Ciancaglini, and
B. Venneri (a more enhanced system was presented in [6] by H. Barendregt, M. Coppo, and
M. Dezani-Ciancaglini) is an extension of Curry’s system that does not have these draw-
backs. The extension being made consists mainly of allowing for term variables (and terms)
to have more than one type. Intersection types are constructed by adding, next to the type
constructor ‘→’ of Curry’s system, the type constructor ‘∩’ and the type constant ‘ω’. This
slight generalization causes a great change in complexity; in fact, now all terms having a
(head) normal form can be characterized by their assignable types, a property that imme-
diately shows that type assignment (even in the system that does not contain ω, see [1]) is
undecidable. Also, by introducing this extension a system is obtained that is closed under
β-equality: if B `M:σ and M=β N, then B ` N:σ.
The type assignment system presented in [6] (the BCD-system) is based on the system as
presented in [10]. It defines the set of intersection types T∩ in a more general way by treating
1
Theoretical Computer Science, 151(2):385-435, 1995 2
‘∩’ as a general type constructor, and introduces two derivation rules for introduction and
elimination of intersections; the handling of intersection in this way is inspired by the sim-
ilarity between intersection and logical conjunction. A big contribution of [6] to the theory
of intersection types is the introduction of a filter λ-model and the proof of completeness of
type assignment; to achieve the latter, the system is strengthened further by introducing a
partial order relation ‘≤’ on types as well as adding the type assignment rule (≤).
A disadvantage of the BCD-system is that type assignment in this system is undecidable.
In recent years, some decidable restrictions have been studied. The first was the Rank2
intersection type assignment system [2], as first suggested by D. Leivant in [26], that is very
close to the notion of type assignment as used in ML. The key idea for this system is to
restrict the set of types to those of the shape ((σ1∩· · ·∩σn)→τ), where the σ1, . . . ,σn are types
that do not contain intersections.
This Rank 2 system was later used as a basis for the notion of type assignment as studied
by M. Coppo and P. Giannini in [12]. In that paper the idea behind the let-construct of
ML is generalized. In ML, quantification of type-variables is introduced, with the normal
restriction that a term variable can only be bound if it does not occur free in the basis
(context) for a term; only those type-variables can be instantiated by types. Similarly in [12],
only those type-variables can be expanded (for the notion of expansion, see Subsection 5.1).
Since the operation of expansion uses also the notion of quantification, intersection types in
this system are limited to those that have the same shape, instead of allowing for arbitrary
intersections. The system studied by F. Damiani and P. Giannini in [15] is a restriction of the
system in [12], in that an (→I)-step can only be performed against the types actually used for
the term-variable; the notion of type assignment of that paper is, therefore, called relevant.
That intersection types can be used as a basis for programming languages was first dis-
cussed by J. Reynolds in [32]. This led to the development of the (typed) programming
language Forsythe [33], and to the work of B.C. Pierce [30, 31], who studied intersection
types and bounded polymorphism in the field of typed lambda calculi. Because there only
typed systems are considered, the systems are decidable.
Another disadvantage of the BCD-system is that it is too general: in this system there are
several ways to deduce a desired result, due to the presence of the derivation rules (∩I), (∩E)
and (≤). These rules not only allow of superfluous steps in derivations, but also make it
possible to give essentially different derivations for the same result. Moreover, in [6] the
relation ≤ induced an equivalence relation ∼ on types. Equivalence classes are big (for
example: ω∼ (σ→ω), for all types σ) and type assignment is closed for ∼.
The BCD-system has the principal type property, as was shown in [34]; the set of operations
needed for this system consists of substitutions, expansions, and rises; although for every
M the set {〈B,σ〉 | B `M:σ} can be generated using those operations specified in [34], the
problem of type-checking
Given a term M and type σ, is there a basis B such that B `M:σ?
is complicated. This is not only due to the undecidability of the problem, but even a semi-
algorithm is difficult to define, due to the equivalence relation. Moreover, because of the
general treatment of intersection types, the sequence of operations needed to go from one
type to another is normally not unique.
The Essential Type Assignment System as presented in this paper is a true restriction of the
BCD-system that satisfies all properties of that system, and is also an extension of Curry’s
system. It will be shown that, in order to prove a completeness result using intersection
types, there is no need to be as general as in [6]; this result can also be obtained for the
essential system. The main advantage of the essential system over the BCD-system is that
the set of types assignable to a term is significantly smaller. An other advantage of the
Theoretical Computer Science, 151(2):385-435, 1995 3
essential system is that derivations are syntax-directed: there is, unlike in the BCD-system,
a one-one relationship between terms and skeletons of derivations. These two features are
supported by a less complicated type structure.
The system presented here is also an extension of the strict type assignment system as
presented in [1]. The major difference is that the essential system will prove to be closed
for η-reduction: If B `E M:σ and M→η N, then B `E N:σ. This does not hold for the strict
system.
This paper also gives an overview of various notions of intersection type assignment, in
order to give insight and intuition, and to compare in detail the various systems and their
development. The main objective of this paper is to show that the treatment of intersection
types as in [6] has been too general; the same results could have been obtained for a far less
complicated system, that follows more closely the syntactical structure of terms, and treats
the type ω not as a type constant, but as the empty intersection. Great advantages of this
approach are a less complicated type language, less complicated proofs, and more precise
and elegant definitions. For example, the operations that are defined in this paper, needed
in a proof for the principal type property are ‘orthogonal’: there is no overlap.
Also, some results already known for, for example, the BCD-system or one of the CDV-
systems will be shown to hold for the essential system ( `E ).
• If B `E M:σ and M→η N, then B `E N:σ.
• If B `E M:σ and M=β N, then B `E N:σ.
• B `E M:σ and σ 6=ω, if and only if M has a head normal form.
• B `E M:σ and ω does not occur in B and σ, if and only if M has a normal form.
• `E has the principal type property.
In general, this will be done using different techniques like, for example, for Theorems 2.8,
2.10, 3.10, and 3.12; the proof of Theorem 6.27 uses a standard technique, but is based on
new ideas.
The outline of this paper is as follows. Section 1 will give an overview of, in total, five no-
tions of intersection type assignment, that will be compared and discussed. Subsection 1.1
presents the Coppo-Dezani system as defined in [7], Subsection 1.2 presents two Coppo-
Dezani-Venneri systems as first defined in [10], Subsection 1.3 presents the Barendregt-
Coppo-Dezani system that can be found in [6], and Subsection 1.4 presents the strict system
of [1].
Section 2 contains the presentation of the essential type assignment system, an extension
of the strict system, and a restriction of the BCD-system that will prove to be equally pow-
erful as the BCD-system. In that subsection it will be shown that type assignment in this
system is closed for β-equality (Theorem 2.10) and η-reduction (Theorem 2.8). In Section 3
an approximation theorem will be proved: B `E M:σ ⇐⇒ ∃ A ∈ A(M) [B `E A:σ] (Theo-
rem 3.10), using a notion of computability. With this result, a characterization of the sets of
terms having a (head) normal form will be given (Theorem 3.12). In Section 4, soundness
and completeness of essential type assignment will be proved (respectively in Theorem 4.12
and Theorem 4.17). The section starts with formulating the relation between the BCD- and
the essential system in Subsection 4.1. In Subsection 4.2 a filter λ-model will be defined,
that is used in Subsection 4.3 to prove completeness of type assignment with respect to the
simple type semantics (see Definition 1.9).
For three of these systems presented in the past (one CDV system, the BCD system and the
strict system) the principal type property has been shown to hold in, respectively, [9], [34],
and [4]; in Section 5 the constructions of the proofs of the various papers will be discussed.
Finally, in Section 6, the proof for the principal type property for the essential system will be
Theoretical Computer Science, 151(2):385-435, 1995 4
sketched.
The results presented in this paper first appeared, in a condensed and slightly different
form, in [3].
Notations
In this paper, the symbol ϕ will be a type-variable; Greek symbols like α, β, µ, ρ, σ, and τ will
range over types, and pi will be used for principal types. ‘→’ will be assumed to associate
to the right, and ‘∩’ binds stronger than ‘→’. M, N are used for lambda terms, x, y, z for
term-variables, M[N/x] for the usual operation of substitution in terms, and A for terms
in λ⊥-normal form. B is used for bases, B\x for the basis obtained from B by erasing the
statement that has x as subject, and P for principal bases. All symbols can appear indexed.
Two types (bases, pairs of basis and type) are disjoint if and only if they have no type-
variables in common. Notions of type assignment are defined as ternary relations on bases,
terms, and types, that are denoted by ` , possibly indexed if necessary. If in a notion of type
assignment for M there are basis B and type σ such that B `M:σ, then M is typed with σ,
and σ is assigned to M.
1 A historical perspective
Type assignment for the Lambda Calculus was first studied by H.B. Curry in [13]. (See
also [14].) Curry’s system – the first and most primitive one – expresses abstraction and
application and its major advantage is that the problem of type assignment is decidable. The
types used in this system are those obtained from type-variables and the type-constructor
→ ‘arrow’.
Definition 1.1 i) The set of Curry-types is inductively defined by:
a) All type-variables ϕ0, ϕ1, . . . are Curry-types.
b) If σ and τ are Curry-types, then so is σ→τ.
ii) Curry-type assignment and Curry-derivations are defined by the following natural deduc-
tion system.
[x:σ]
:
M:τ
(→I): (a)
λx.M:σ→τ
M:σ→τ N:σ
(→E):
MN:τ
(a) If x:σ is the only statement about x on which M:τ depends.
The main results proved for this system are:
• The principal type property: for every typeable M there is a pair 〈P,pi〉, such that:
P `M:pi, and for every pair 〈B,σ〉 such that B `M:σ, there exists a substitution Sub
such that Sub (〈P,pi〉) = 〈B,σ〉.
• Decidability of type assignment.
• Strongly normalizability of all typeable terms.
Curry’s system has drawbacks: it is for example not possible to assign a type to the lambda
term (λx.xx), and although the lambda terms (λcd.d) and ((λxyz.xz(yz))(λab.a)) are β-
equal, the principal type schemes for these terms are different, ϕ0→ϕ1→ϕ1 and (ϕ1→ϕ0)→ϕ1→ϕ1,
Theoretical Computer Science, 151(2):385-435, 1995 5
respectively. The Intersection Type Discipline as presented in the following subsections is an
extension of Curry’s system for the pure Lambda Calculus that does not have these draw-
backs. It has developed over a period of several years; in the sequel, not just the final version
will be presented, but various systems that appeared between 1980 and 1992 will be shown,
in order to develop a concise overview of the field.
1.1 The Coppo-Dezani type assignment system
The first paper by M. Coppo and M. Dezani-Ciancaglini from the University of Turin, Italy
that introduced intersection types is [7] (in this paper, instead of the word ‘intersection’, the
word ‘sequence’ was used). The system presented in this paper is a true extension of Curry’s
system: the extension made is to allow of more than one type for term-variables in the (→I)-
derivation rule and therefore to allow of, also, more than one type for the right hand term
in the (→E)-derivation rule.
Definition 1.1 i) The set of types considered in [7] is inductively defined by:
a) All type-variables ϕ0, ϕ1, . . . are types.
b) If σ1, . . . ,σn are types (n ≥ 1), then σ1∩· · ·∩σn is a sequence.
c) If σ1∩· · ·∩σn is a sequence and σ is a type, then σ1∩· · ·∩σn→σ is a type.
ii) Type assignment and derivations are defined by the following natural deduction system.
M:σ1 . . . M:σn
(∩I):
M:σ1∩· · ·∩σn
[x:σ1∩· · ·∩σn]
:
M:σ
(→I): (a)
λx.M:σ1∩· · ·∩σn→σ
x:σ1∩· · ·∩σn
(∩E):
x:σi
M:σ1∩· · ·∩σn→σ N:σ1∩· · ·∩σn
(→E):
MN:σ
(a) If x:σ1∩· · ·∩σn is the only statement about x on which M:τ depends.
The main properties of that system proved in [7] are:
• Subject reduction: If B `M:σ and M→β N, then B ` N:σ.
• Normalizability of typeable terms: If B `M:σ, then M has a normal form.
• Typeability of all terms in normal form.
• Closure for β-equality in the λI-calculus: if B `M:σ and M=β N, then B ` N:σ.
• In the λI-calculus: B `M:σ if and only if M has a normal form.
It is even possible to prove that, in this system: If B `M:σ, then M is strongly normalizable
(in fact, this follows from a similar result of [1]; there the BCD-system without ω is studied,
which is a supersystem of the CD-system).
That the system is closed under subject reduction can be illustrated by the following ‘Cut
and Paste’ proof: Suppose that B ` (λx.M)N:σ. By (→E), there is a sequence σ1∩· · ·∩σn such
that
B ` λx.M:σ1∩· · ·∩σn→σ and B ` N:σ1∩· · ·∩σn.
Since (→I) should be the last step performed for the first result and (∩I) should be the last
step for the latter, also
B,x:σ1∩· · ·∩σn `M:σ and B ` N:σi, for 1≤ i≤ n.
Theoretical Computer Science, 151(2):385-435, 1995 6
Then a derivation for B `M[N/x]:σ can be obtained by replacing, in the derivation for
B,x:σ1∩· · ·∩σn `M:σ, the sub-derivation {x:σ1∩· · ·∩σn} ` x:σi by the derivation for B ` N:σi,
for every 1≤ i≤ n.
The problem to solve in a proof for closure under β-equality is then that of β-expansion:
if B `M[N/x]:σ, then B ` (λx.M)N:σ.
When restricting to λI-terms, the term-variable x occurs in M and the term N is a subterm of
M[N/x], so N is typed in the derivation for B `M[N/x]:σ, probably with several different
types σ1, . . . ,σn. In the CD-system a derivation for
B,x:σ1∩· · ·∩σn `M:σ
can be obtained by replacing in the derivation for B `M[N/x]:σ, all occurrences of N:σi
by the derivation for {x:σ1∩· · ·∩σn} ` x:σi. Then, obviously, using (→I), (∩I), and (→E), the
redex can be typed.
The system is not closed for β-expansion for the full λK-calculus: when the term-variable
x does not occur in M, the term N is a not a subterm of M[N/x], and if there is no ρ such
that B ` N:ρ, the redex cannot be typed.
Take, for example, the two lambda terms ((λxy.y)((λz.zz)(λz.zz))) and (λy.y) (notice that
the first term reduces to the second). Then of course ` λy.y:σ→σ, but it is impossible to type
the term ((λxy.y.)((λz.zz)(λz.zz))). This can be understood from the fact that all typeable
terms are normalizable; the subterm ((λz.zz)(λz.zz)) has no normal form, so is not typeable.
For a more intricate example that remains within the set of typeable terms, take the two
lambda terms (λyz.(λb.z)(yz)) and (λyz.z) (again the first term reduces to the second). It is
easy to show that
{z:σ,y:τ} ` z:σ,
but it is impossible to give a derivation for (λb.z)(yz):σ from the same basis. This is caused
by the fact that ((λb.z)(yz)) can only be typed in this system from a basis in which the
predicate for y is an arrow type scheme. It is for example possible to derive
{z:σ,y:σ→τ} ` (λb.z)(yz):σ.
Therefore, it is possible to derive
` λyz.(λb.z)(yz):(σ→τ)→σ→σ and ` λyz.z:τ→σ→σ,
but not to give a derivation for λyz.(λb.z)(yz):τ→σ→σ.
From this initial system several others emerged. The best known and most frequently
quoted is the one presented in [6], but there are two earlier papers ([10] and [9]) that investi-
gate interesting systems which can be regarded as in-between those of in [7] and [6]. In fact,
the system that will be presented in Section 2 is more close to the system of [10] that to that
of [6].
1.2 The Coppo-Dezani-Venneri type assignment systems
In [10] two type assignment systems are presented, that, in approach, are more general than
the Coppo-Dezani system: in addition to the type constructors ‘→’ and ‘∩’, they also contain
the type constant ‘ω’. The first type discipline as presented in [10] (a similar system was
presented in [35]) is a true extension of the one presented in [7]; the second one limits the
use of intersection types in bases. By introducing the type constant ω next to the intersection
types, a system is obtained that is closed under β-equality for the full λK-calculus: if M=β
N, where M and N are lambda terms, then B `M:σ ⇐⇒ B ` N:σ.
Definition 1.2 i) The set of types is inductively defined in [10] by:
Theoretical Computer Science, 151(2):385-435, 1995 7
a) All type-variables ϕ0, ϕ1, . . . are types.
b) ω is a type.
c) If σ1, . . . ,σn are types, (n ≥ 1), then σ1∩· · ·∩σn is a sequence.
d) If σ1∩· · ·∩σn is a sequence and σ is a type, then σ1∩· · ·∩σn→σ is a type.
ii) Every type can be written as σ1→·· ·→σn→σ, where σ1, . . . ,σn are sequences, and σ is a
type-variable or ω. The type is called tail-proper if σ 6=ω.
iii) Type assignment and derivations are in [10] defined by:
[x:σi] · · · [x:σn]
:
M:σ
(→I): (a)
λx.M:τ→σ
M:σ1 . . . M:σn
(∩I):
M:σ1∩· · ·∩σn
(ω):
M:ω
M:σ1∩· · ·∩σn→σ N:σ1∩· · ·∩σn
(→E):
MN:σ
(a) If x:σ1, . . . , x:σn are all and nothing but the statements about x on which M:σ
depends, and τ is a sequence that at least contains all σ1, . . . ,σn.
Notice that ω is treated as a true type constant; the view of the strict intersection system
presented in [1] (see Subsection 1.4) and that of the essential system presented in this paper
(see Section 2) is to treat ω as the empty intersection.
The changes with respect to the system of [7] are small, but important. First of all, the
type constant ω, assignable to all terms, is introduced, which makes all terms having a
head normal form typeable; the type ω is needed to cover the subterms that have no normal
form. Also, the (∩E) rule of [7] is implicitly present in (→I).
The main properties of this system proved in [10] are:
• If B `M:σ and M=β N, then B ` N:σ.
• B `M:σ and σ is tail-proper, if and only if M has a head normal form.
• B `M:σ and ω does not occur in B and σ, if and only if M has a normal form.
That the system is now also closed for β-expansion, is solved by the introduction of the
type constant ω and the sequences. The type constant ω is the universal type, i.e. each term
can be typed by ω. It can be used in the expansion from B `M[N/x]:σ to B ` (λx.M)N:σ to
type N if N does not occur in M[N/x], and there is no other type ρ such that B ` N:ρ.
If N does not occur in M[N/x], x does not occur in M, and there is a derivation for
B ` λx.M:ω→σ. Since N is typeable by ω, by derivation rule (→E) also B ` (λx.M)N:σ.
The sequences allow, as in the CD-system, for a term-variable to have different types within
a derivation; they are used for the cases that N occurs more than once in M[N/x], and these
occurrences were typed in the derivation for B `M[N/x]:σ with different types. (See also
Lemma 2.9.)
Definition 1.3 i) The set of normalized types is inductively defined in [10] by:
a) All type-variables ϕ0, ϕ1, . . . are normalized types.
b) ω is a normalized sequence.
c) If σ1, . . . ,σn are normalized types (n ≥ 1) and, for 1≤ i≤ n, σi 6=ω, then σ1∩· · ·∩σn is
a normalized sequence.
Theoretical Computer Science, 151(2):385-435, 1995 8
d) If σ1∩· · ·∩σn is a normalized sequence and σ is a normalized type, where σ 6=ω, then
σ1∩· · ·∩σn→σ is a normalized type.
ii) On the set of types, the relation ∼ is defined by:
a) ϕ∼ ϕ.
b) σ1∩· · ·∩σi∩σi+1∩· · ·∩σn∼ σ
′
1∩· · ·∩σ
′
i+1∩σ
′
i∩· · ·∩σ
′
n ⇐⇒
∀ 1≤ i≤ n [σi∼ σ
′
i ].
c) σ→τ∼ σ′→τ′ ⇐⇒ σ∼ σ′ & τ∼ τ′.
Observe that the only normalized non-tail-proper type is ω.
A good justification for identification of types through ∼ can be found in the definition
of type-semantics (Definition 1.9). Notice that, in fact, normalizing types as done here is just
the same as treating ω as an empty intersection; the set of normalized types coincides with
the set of strict types (see Definition 1.12), and normalized sequences correspond to strict
intersection types.
The second type assignment system presented in [10] is a restricted version of the first.
Since it limits the possible bases that can be used in a derivation, it is not a proper extension
of Curry’s system: if B `M:σ and the term-variable x does not occur in B, then for (λx.M)
only the type ω→σ can be derived. This system is also used in [19].
Definition 1.4 Restricted type assignment and restricted derivations are in [10] defined by:
[x:σ1] · · · [x:σn]
:
M:σ
(→I): (a)
λx.M:σ1∩· · ·∩σn→σ
M:σ1 . . . M:σn
(∩I): (b)
M:σ1∩· · ·∩σn
(ω):
M:ω
M:σ1∩· · ·∩σn→σ N:σ1∩· · ·∩σn
(→E):
MN:σ
(a) If σ 6=ω and x:σ1, . . . , x:σn are all and nothing but the statements about x on which
M:σ depends. If n = 0, so in the derivation for M:σ there is no premise whose subject is
x, then σ1∩· · ·∩σn = ω.
(b) If for 1≤ i≤ n, σi 6=ω.
This notion of type assignment is relevant in the sense of [15]: in the (→I)-rule, only those
types actually used in the derivation can be abstracted. This implies that, for example, for
the lambda term (λab.a) the type σ→τ→σ cannot be derived.
It is obvious that B `M:σ in the restricted system implies B `M:σ in the unrestricted one
and that the converse does not hold. In both systems, types are not invariant by η-expansion,
since for example ` λx.x:ϕ→ϕ, but not ` λxy.xy:ϕ→ϕ. Moreover, type assignment in the
unrestricted system is not invariant under η-reduction: for example
` λxy.xy:(σ→τ)→σ∩ρ→τ, but not ` λx.x:(σ→τ)→σ∩ρ→τ.
This is due to the fact that, in the unrestricted system, there is no way to obtain x:σ∩ρ→τ
from x:σ→τ. In the restricted system, in the (→I)-rule, only types actually used for a term
variable can be collected. This means that the statement λxy.xy:(σ→τ)→σ∩ρ→τ cannot be
derived, since the type ρ is not used for the application xy.
The closure under η-reduction, however, holds for the restricted system; properties of this
restricted system proved in [10] are:
• If B `M:σ, then σ is a normalized type.
Theoretical Computer Science, 151(2):385-435, 1995 9
• If B `M:σ and M→η N, then B ` N:σ.
1.3 The Barendregt-Coppo-Dezani type assignment system
The type assignment system presented in [6] by H. Barendregt, M. Coppo and M. Dezani-
Ciancaglini is based on the first, unrestricted system as presented in [10]. It extended the set
of types to T∩, introduced a partial order relation ‘≤’ on types, added the type assignment
rule (≤), and introduced a more general form of the rules concerning intersection. The rule
(≤) was mainly introduced to prove completeness of type assignment.
In this paper, it was shown that the set of types derivable for a lambda term in the ex-
tended system is a filter, i.e. a set closed under intersection and right-closed for ≤. The
interpretation of a lambda term by the set of types derivable for it – [[M]]ξ – is defined in
the standard way and gives a filter λ-model F∩. The main result of that paper is that, using
this model, completeness is proved by proving the statement: `∩ M:σ ⇐⇒ [[M]] ∈ υ(σ),
where υ : T∩ → F∩ is a simple type interpretation as defined in [23] (see Definition 1.9.(ii)).
In order to prove the ‘⇐’-part of this statement (completeness), the relation ≤ is needed.
Other interesting applications of filter λ-models can be found in [8], [11], [16], and [17].
Definition 1.5 i) T∩, the set of types in [6] is inductively defined by:
a) All type-variables ϕ0, ϕ1, . . . ∈T∩.
b) ω∈T∩.
c) If σ and τ∈T∩, then σ→τ and σ∩τ∈T∩.
ii) On T∩, the type inclusion relation ≤ is inductively defined by:
a) σ≤ σ.
b) σ≤ω.
c) ω≤ω→ω.
d) σ∩τ≤ σ, σ∩τ≤ τ.
e) (σ→τ)∩(σ→ρ)≤ σ→τ∩ρ.
f) σ≤ τ≤ ρ ⇒ σ≤ ρ.
g) σ≤ τ & σ≤ ρ ⇒ σ≤ τ∩ρ.
h) ρ≤ σ & τ≤µ ⇒ σ→τ≤ ρ→µ.
iii) σ∼ τ ⇐⇒ σ≤ τ≤ σ.
T∩ may be considered modulo ∼ . Then ≤ becomes a partial order.
Notice that, because of part (i.c), ‘∩’ is now also a general type constructor. This is in
harmony with the fact that also ω is treated as a ‘normal’ type constant, but is not motivated
by the type system itself. The decision to treat ‘∩’ in this way stems from a, in the eyes
of this author, wrong line of thought. In order to solve the problem of completeness of
type assignment, first the set of types is expanded, where the introduction of a relation on
normalized types with contra-variance in the arrow would have done the trick. The goal of
this paper is to show that, had the authors restricted themselves to the normalized types of
[10] (Definition 1.3) and introduced a relation ≤ on those types (essentially composed of
parts (ii.a), (ii.b), (ii.d), (ii.f), (ii.g), and (ii.h)), they would have obtained a system with the
same expressiveness as that one they defined. This system would then have been identical
to the essential system as presented in this paper (Section 2).
Definition 1.6 i) Type assignment and derivations are in [6] defined by the following natural
deduction system.
Theoretical Computer Science, 151(2):385-435, 1995 10
[x:σ]
:
M:τ
(→I): (a)
λx.M:σ→τ
M:σ→τ N:σ
(→E):
MN:τ
M:σ M:τ
(∩I):
M:σ∩τ
M:σ∩τ
(∩E):
M:σ
M:σ∩τ
M:τ
M:σ σ≤ τ
(≤):
M:τ
(ω):
M:ω
(a) If x:σ is the only statement about x on which M:τ depends.
ii) B `∩ M:σ means that M:σ is derivable from a basis B using these rules.
An advantage of the presentation in [6] is, clearly, a very easy type definition and easy
understandable derivation rules. But this advantage is superficial, since all difficulties now
show up while proving theorems; especially the complexity of ≤ and ∼ causes confusion.
For this notion of type assignment, the following properties hold:
Lemma 1.7 i) B `∩ MN:σ ⇐⇒ ∃ τ [B `∩ M:τ→σ & B `∩ N:τ].
ii) B `∩ λx.M:σ ⇐⇒ ∃ ρ,µ [σ = ρ→µ & B,x:ρ `∩ M:µ].
iii) B `∩ x:σ ⇐⇒ ∃ ρ [x:ρ∈B & ρ≤σ].
In the BCD-system, there are several ways to deduce a desired result, due to the presence
of the derivation rules (∩I), (∩E) and (≤), which allow superfluous steps in derivations. In
the CDV-systems, these rules are not present and there is a one-one relationship between
terms and skeletons of derivations. In other words: those systems are syntax directed. The
BCD-system has the same expressive power as the previous unrestricted CDV-system: all
solvable terms have types other than ω, and a term has a normal form if and only if it has a
type without ω-occurrences.
The main result of [6] is the proof for completeness of type assignment. The construction
of a filter λ-model and the definition of a map from types to elements of this model (a simple
type interpretation) make that proof possible: if the interpretation of the term M is an element
of the interpretation of the type σ, then M is typeable with σ.
Filters and the filter λ-model F∩ are defined by:
Definition 1.8 i) A filter is a subset d ⊆ T∩ such that:
a) ω∈ d.
b) σ,τ∈ d ⇒ σ∩τ∈ d.
c) σ≥ τ∈ d ⇒ σ∈ d.
ii) F∩ = {d | d is a filter}.
iii) For d1,d2∈F∩ define d1 · d2 = {τ∈T∩ | ∃σ∈ d2 [σ→τ∈ d1]}.
Notice that, because of part (i.a), a filter is never empty.
The following properties are proved in [6]:
• ∀M∈Λ [{σ | ∃ B [B `∩ M:σ}∈F∩]].
Theoretical Computer Science, 151(2):385-435, 1995 11
• Let ξ be a valuation of term-variables in F∩ and Bξ = {x:σ | σ ∈ ξ (x)}. For M∈Λ define
[[M]]ξ = {σ | Bξ `∩ M:σ}. Using the definition of Hindley and Longo [24] it is shown
that 〈F∩, · , [[ ]]〉 is a λ-model.
In constructing a complete system, the semantics of types plays a crucial role. As in [17],
[29], and essentially following [22], a distinction can be made between several notions of
type interpretations and semantic satisfiability. There are, roughly, three notions of type
semantics that differ in the meaning of an arrow type scheme: inference type interpreta-
tions, simple type interpretations and F type interpretations. These different notions of type
interpretations induce of course different notions of semantic satisfiability.
Definition 1.9 i) Let 〈D, · , ε〉 be a continuous λ-model. A mapping υ : T∩ → ℘(D) = {X |
X ⊆ D} is a type interpretation if and only if:
a) {ε · d | ∀ e∈ υ(σ) [d · e∈ υ(τ)]} ⊆ υ(σ→τ).
b) υ(σ→τ) ⊆ {d | ∀ e∈ υ(σ) [d · e∈ υ(τ)]}.
c) υ(σ∩τ) = υ(σ)∩υ(τ).
ii) Following [23], a type interpretation is simple if also:
υ(σ→τ) = {d | ∀ e∈ υ(σ) [d · e∈ υ(τ)]}.
iii) A type interpretation is called an F type interpretation if it satisfies:
υ(σ→τ) = {ε · d | ∀ e∈ υ(σ) [d · e∈ υ(τ)]}.
Notice that, in part (ii), the containment relation ⊆ of part (i.b) is replaced by =, and that in
part (iii) the same is done with regard to part (i.a).
These notions of type interpretation lead, naturally, to the following definitions for seman-
tic satisfiability (called inference-, simple- and F-semantics, respectively).
Definition 1.10 i) Let M = 〈D, · , [[ ]]〉 be a λ-model and ξ a valuation of term-variables
in D. Then [[M]]
M
ξ ∈D is the interpretation of M in M via ξ.
ii) Define ` by (whereM is a λ-model, ξ a valuation and υ a type interpretation):
a) M,ξ,υ ` M:σ ⇐⇒ [[M]]
M
ξ ∈ υ(σ).
b) M,ξ,υ ` B ⇐⇒ M,ξ,υ ` x:σ for every x:σ∈ B.
c) 1) B ` M:σ ⇐⇒ ∀M,ξ,υ [M,ξ,υ ` B ⇒ M,ξ,υ ` M:σ].
2) B `s M:σ ⇐⇒ ∀M,ξ, simple type interpretations υ
[M,ξ,υ ` B ⇒ M,ξ,υ ` M:σ].
3) B `F M:σ ⇐⇒ ∀M,ξ,F type interpretations υ
[M,ξ,υ ` B ⇒ M,ξ,υ ` M:σ].
Since no confusion is possible, the superscript on [[ ]] is omitted.
The main result of [6] is obtained by proving:
Property 1.11 i) Soundness. B `∩ M:σ ⇒ B `s M:σ.
ii) Completeness. B `s M:σ ⇒ B `∩ M:σ.
The proof of completeness is obtained in a way very similar to that of Theorem 4.17. The
results of [6] in fact show that type assignment in the BCD-system is complete with respect
to simple type semantics; this in contrast to strict type assignment (presented in [1], see also
the next subsection), that is complete with respect to the inference semantics.
Theoretical Computer Science, 151(2):385-435, 1995 12
1.4 The strict type assignment system
The strict type assignment system as defined in [1] is a restriction of the system of [6]; it
is a type assignment system in which the relation ≤ and the derivation rule (≤) are no
longer present. The elimination of ≤ induces a set of strict types, that is actually the set
of normalized tail-proper types of [10]. Moreover, there the relation ≤S on strict types is
presented, that is more restricted than just the relation ≤ restricted to strict types. Instead,
it is the relation generated by interpreting the type-constructor ∩ as intersection on sets;
in particular, ≤S is not defined over ‘→’-types, so part (ii.h) of Definition 1.5 is missing.
The derivation rules used are similar to those of the unrestricted system in [10]. This implies
that, formally, the strict system is a system in between the two presented in [10]; a significant
difference with the restricted system of [10] is that type assignment in the strict system is not
relevant in the sense of [15].
Although the rather strong restrictions imposed, the provable results for the strict system
are very close to those for the system of [6]. For example, the sets of normalizable terms
and those having a normal form can be equally elegantly characterized. The main difference
between the two systems is that the strict system is not closed for η-reduction, whereas the
BCD-system is.
The strict system gives rise to a strict filter λ-model FS, that satisfies all major properties of
the filter λ-model F∩ as presented in [6], but is an essentially different λ-model, equivalent to
Engeler’s model DA [18]. In [1] was shown that soundness for the notion of type assignment
of [6] is lost if instead of simple type semantics, the inference type semantics is used. Take,
for example, the statement λx.x:(σ→σ)→(σ∩τ)→σ: this statement is derivable in the system
`∩ , but it is not valid in FS. With the use of the inference type semantics, in [1] soundness
and completeness for strict type assignment was proved, without having the necessity of
introducing ≤; this was done using FS.
The set of types assignable to a term M in the strict system is significantly smaller than the
set of types assignable to M in the BCD-system. In particular, the problem of type checking
for the strict system is, because of the smaller equivalence classes, less complicated than for
the BCD-system.
Strict types are the types that are strictly needed to assign a type to a term in the BCD-
system. In the set of strict types, intersection type schemes and the type constant ω play a
limited role. Perhaps the most important change from the systems presented before is that
the type constant ω is no longer treated as an arbitrary type, that can be handled in any way.
Instead, ω is taken to be the empty intersection: if n = 0, then σ1∩· · ·∩σn≡ω, so ω does not
occur in an intersection subtype. Moreover, intersection type schemes (so also ω) occur in
strict types only as subtypes at the left-hand side of an arrow type scheme, as in the types
of [7], [9], and [10].
Definition 1.12 i) Ts, the set of strict types, and TS, the set of strict intersection types, are
defined by mutual induction by:
a) All type-variables ϕ0, ϕ1, . . . ∈Ts, and if τ∈Ts and σ∈TS, then σ→τ∈Ts.
b) If σ1, . . . ,σn ∈Ts (n ≥ 0), then σ1∩· · ·∩σn ∈TS.
ii) On TS, the relation ≤S is defined by:
a) ∀ 1≤ i≤ n (n ≥ 1) [σ1∩· · ·∩σn≤S σi].
b) ∀ 1≤ i≤ n (n ≥ 0) [σ≤S σi] ⇒ σ≤S σ1∩· · ·∩σn.
c) σ≤S τ≤S ρ ⇒ σ≤S ρ.
iii) On TS, the relation ∼S is defined by:
a) σ≤S τ≤S σ ⇒ σ∼S τ.
Theoretical Computer Science, 151(2):385-435, 1995 13
b) σ∼S ρ & τ∼S µ ⇒ σ→τ∼S ρ→µ.
Notice that Ts is a proper subset of TS, and that the second part of (i.a) can also be formulated
as: If σ,σ1, . . . ,σn ∈ Ts (n ≥ 0), then σ1∩· · ·∩σn→σ∈ Ts. Moreover, σ∼S ρ if and only if σ can
be obtained from ρ by premuting components of an intersection subtype, e.g. in σ∩ρ→τ∼S
ρ∩σ→τ.
The definition of ∼S as in [1] did not contain part 1.12. (iii.b), but was defined by: σ ≤S
τ≤S σ ⇐⇒ σ∼S τ. As was remarked by Professor G. Plotkin of the University of Edinburgh,
Scotland (private communication), defining the equivalence relation on types in that way
causes an anomaly in the definition of type-interpretation. In particular, the types σ∩ρ→τ
and ρ∩σ→τ would be incomparable, which implies that the interpretation of an arrow type
σ→τ is no longer a map from the interpretation of σ onto the interpretation of τ.
Definition 1.13 i) Strict type assignment and strict derivations are defined by the following
natural deduction system (where all types displayed are strict, except for σ in the rule
(→I)):
M:σ1∩· · ·∩σn→σ N:σ1 . . . N:σn
(→E): (n ≥ 0)
MN:σ
[x:σ]
:
M:τ
(→I): (a)
λx.M:σ→τ
x:σ1∩· · ·∩σn
(∩E): (b)
x:σi
(a) If x:σ is the only statement about x on which M:τ depends.
(b) n ≥ 2,1≤ i ≤ n.
ii) B s` M:σ is used for: M:σ is derivable from B using a strict derivation, and `S is defined
by: B `S M:σ if and only if: there are σ1, . . . ,σn (n ≥ 0) such that σ≡ σ1∩· · ·∩σn, and for
every 1≤ i≤ n, B s` M:σi.
Notice that the derivation rule (∩E) is only performed on variables and that the derivation
rules (ω) and (∩I) of the BCD-system are implicitly present in the derivation rule (→E).
Moreover, a derivation in the `S system with conclusion M:ω cannot be composed with
any other derivation. The derivation rule (∩E) could be replaced by a rule for (≤S), in
the spirit of the rule (≤) of the BCD-system, but allowed only for term-variables. Also,
the derivation rules (→I) and (∩E) together correspond to the derivation rule (→I) of the
unrestricted CDV-system (Definition 1.2).
The strict filter λ-model FS is defined in a way very similar to F∩ defined in [6], by defining
filters of types and a map from terms to filters.
Definition 1.14 i) A subset d of TS is called a strict filter if and only if:
a) σ1, . . . ,σn ∈ d (n ≥ 0) ⇒ σ1∩· · ·∩σn ∈ d.
b) τ∈ d & τ≤S σ ⇒ σ∈ d.
ii) If V ⊆ TS, then ↑SV is the smallest strict filter that contains V, and ↑Sσ = ↑S{σ}.
iii) FS = {d ⊆ TS | d is a strict filter}. Application on FS is defined by:
d · e = ↑S{τ | ∃ σ∈ e [σ→τ∈ d]}.
Notice that if types are not considered modulo ∼S then part (i.b) should also contain: τ ∈
d & τ∼S σ ⇒ σ∈ d. Notice also that every strict filter contains ω.
Theoretical Computer Science, 151(2):385-435, 1995 14
The filter λ-models FS and F∩ are not isomorphic as complete lattices, since, for example,
in F∩ the filter ↑(σ∩τ)→σ is contained in ↑σ→σ, but in FS the strict filter ↑S(σ∩τ)→σ is
not contained in ↑Sσ→σ. Moreover, they are not isomorphic as λ-models since in F∩ the
meaning of (λxy.xy) is contained in the meaning of (λx.x), while this does not hold in FS.
Another difference is that, while the analogue of G in F∩ chooses the minimal representative
of functions, this is not the case in FS. Moreover, it is straightforward to show that FS is
equivalent to Engeler’s model DA.
The main results of [1] are:
• Soundness and completeness of type assignment with respect to inference type semantics.
• If B `∩ M:σ then there are B′,σ′ ∈TS such that B
′ `S M:σ
′, σ′≤ σ and B≤ B′.
• Conservativity. Let B,σ∈TS. If B `∩ M:σ, then B `S M:σ.
• In the BCD-system without ω, restricted to the λI-calculus: B `s M:σ ⇐⇒ B `∩ M:σ.
• In the BCD-system without ω: {M |M is typeable by means of the derivation rules (∩I),
(∩E), (→I) and (→E)} = {M |M is strongly normalizable}.
2 The essential intersection type assignment system
In this section the essential type assignment system is presented, a restricted version of the
system presented in [6], together with some of its properties. The major feature of this
restricted system is, compared to the BCD-system, a restricted version of the derivation
rules and the use of strict types. It also forms a slight extension of the strict type assignment
system that was presented in [1] (see Subsection 1.4); the main difference is that the strict
system is not closed for η-reduction, whereas the essential system presented here is.
Recall Definition 1.12. The relation ≤E on TS, to be defined below, is a natural extension
of the relation ≤S, that was only defined for intersection types. Notice that, in the definition
of ≤E, the arrow type constructor is contra-variant in its left-hand argument.
Definition 2.1 i) The relation ≤E is defined on TS like ≤S, by adding the last alternative.
a) ∀ 1≤ i≤ n (n ≥ 1) [σ1∩· · ·∩σn≤E σi].
b) ∀ 1≤ i≤ n (n ≥ 0) [σ≤E σi] ⇒ σ≤E σ1∩· · ·∩σn.
c) σ≤E τ≤E ρ ⇒ σ≤E ρ.
d) ρ≤E σ & τ≤E µ ⇒ σ→τ≤E ρ→µ.
ii) On TS, the relation ∼E is defined by: σ∼E τ ⇐⇒ σ≤E τ≤E σ.
iii) B≤E B
′ if and only if for every x:σ′ ∈ B′ there is an x:σ ∈ B such that σ≤E σ
′, and B∼E
B′ ⇐⇒ B≤E B′≤E B.
Also the relations ≤ , ∼ , and ≤S are extended to bases.
Notice that ≤E is exactly the relation ≤ restricted to TS (see also Property 4.2), so if σ≤E τ,
then σ≤ τ, and that ∼S is a true subrelation of ∼E, since, for example, (σ→τ)∩(σ∩ρ→τ)∼E
σ→τ, but this does not hold in ∼S. Moreover, TS may be considered modulo ∼E; then ≤E
becomes a partial order, and from now on in this paper types are considered modulo ∼E.
Unless stated otherwise, if a type is written as σ1∩· · ·∩σn, then all σ1, . . . ,σn are assumed to
be strict. Remember that ω is defined to be the emtpy intersection.
Definition 2.2 If B1, . . . ,Bn are bases, then Π{B1, . . . ,Bn} is the basis defined as follows:
x:σ1∩· · ·∩σm ∈Π{B1, . . . ,Bn} if and only if {x:σ1, . . . ,x:σm} is the set of all statements about x
that occur in B1 ∪ . . . ∪ Bn.
Theoretical Computer Science, 151(2):385-435, 1995 15
Often B∪ {x:σ} (or B,x:σ) will be written for the basis Π{B,{x:σ}}, when x does not occur
in B.
For the relation ≤E, the following properties hold:
Lemma 2.3 i) σ≤S τ ⇒ σ≤E τ.
ii) ϕ≤E σ ⇐⇒ σ≡ ϕ. So {σ |σ∼E ϕ} = {ϕ}.
iii) ω≤E σ ⇐⇒ σ≡ω. So {σ |σ∼E ω} = {ω}.
iv) σ→τ≤E ρ∈Ts ⇐⇒ ∃ α∈TS, β∈Ts [ρ≡ α→β & α≤E σ & τ≤E β].
v) σ1∩· · ·∩σn≤E τ∈Ts ⇒ ∃ 1≤ i≤n [σi≤E τ].
vi) σ≤E τ ⇒ ∃ σ1, . . . ,σn,τ1, . . . ,τm [σ = σ1∩· · ·∩σn & τ = τ1∩· · ·∩τm & ∀ 1≤ j≤m ∃ 1≤ i≤ n
[σi≤E τj]].
Proof: Easy.
The essential type assignment system is constructed from the set of strict types and an
extension of the derivation rules as in Definition 1.13. In this way, a syntax directed system
is obtained, that satisfies the main properties of the BCD-system.
Definition 2.4 i) Essential type assignment and essential derivations are defined by the fol-
lowing natural deduction system (where all types displayed are strict, except σ in the
rules (→I) and (≤E)):
M:σ1∩· · ·∩σn→τ N:σ1. . . N:σn
(→E): (n ≥ 0)
MN:τ
[x:σ]
:
M:τ
(→I): (a)
λx.M:σ→τ
x:σ σ≤E τ
(≤E):
x:τ
(a) If x:σ is the only statement about x on which M:τ depends.
B e` M:σ is defined as: M:σ is derivable from B using an essential derivation.
ii) Define `E by: B `E M:σ if and only if: there are σ1, . . . ,σn (n≥ 0) such that σ≡σ1∩· · ·∩σn
and B e` M:σi, for every 1≤ i≤ n.
Notice that the difference between the strict system and the essential one lies only in the
derivation rule for term variables. Instead of a rule (∩E), that is in fact defined using the
relation ≤S, the essential system contains a similar rule using ≤E.
The introduction of two different notions of derivability seems somewhat superfluous. In
fact, the ‘real’ notion of type assignment is that defined as e` ; the symbol `E is mainly
introduced for convenience, as an abbreviation.
For these notions of type assignment, the following properties hold:
Lemma 2.5 i) B `E x:σ ⇐⇒ ∃ ρ∈TS [x:ρ∈B & ρ≤E σ].
ii) B e` MN:σ ⇐⇒ ∃ τ∈TS [B e` M:τ→σ & B `E N:τ].
iii) B e` λx.M:σ ⇐⇒ ∃ ρ∈TS, µ∈Ts [σ = ρ→µ & B,x:ρ e` M:µ].
iv) B e` M:σ ⇐⇒ B `E M:σ & σ∈Ts.
v) B `E M:σ ⇐⇒ ∃ σ1, . . . ,σn [σ = σ1∩· · ·∩σn & ∀ 1≤ i≤n [B e` M:σi]].
vi) B `E M:σ ⇐⇒ {x:τ∈B | x∈FV(M)} `E M:σ.
vii) B `E M:σ & B′≤E B ⇒ B′ `E M:σ.
Theoretical Computer Science, 151(2):385-435, 1995 16
viii) B `E M:σ & M@∼M
′ ⇒ B′ `E M′:σ.
Proof: Easy.
Although the rule (≤E) is defined only for term-variables, `E is closed for ≤E.
Lemma 2.6 If B `E M:σ and σ≤E τ, then B `E M:τ, so the following is an admissible rule in `E:
M:σ σ≤E τ
(≤E):
M:τ
Proof: By induction on `E.
i) σ = ω. Then, by Lemma 2.3.(iii), τ = ω. Obviously, B `E M:τ.
ii) σ = σ1∩· · ·∩σn. By Lemma 2.5.(v), for every 1≤ i≤ n, B e` M:σi. By Lemma 2.3.(vi), there
are τ1, . . . ,τm∈Ts such that τ = τ1∩· · ·∩τm and, for every 1≤ j≤m, there is a 1≤ i≤n such
that σi ≤E τj. By induction, for every 1≤ j≤m, B e` M:τj. But then, by Lemma 2.5.(v),
B `E M:τ.
iii) σ∈Ts. This part is proven by induction on M.
a) M≡ x. Then B≤E {x:σ}≤E {x:τ}, so, by Lemma 2.5.(i), B `E x:τ.
b) M≡ λx.M′. Then, by Lemma 2.5.(iii), there are ρ ∈ TS, µ ∈ Ts such that σ = ρ→µ
and B,x:ρ e` M
′:µ. By Lemmas 2.3.(vi) and 2.3.(iv) there are ρ1, . . . ,ρn,µ1, . . . ,µn
such that τ = (ρ1→µ1)∩· · ·∩ (ρn→µn), and for 1 ≤ i ≤ n, ρi ≤E ρ and µ ≤E µi. By
Lemma 2.5.(vii), for 1 ≤ i ≤ n, B,x:ρi e` M
′:µ, and by induction B,x:ρi e` M
′:µi.
So, by Lemma 2.5.(iii), for every 1 ≤ i ≤ n, B e` λx.M′:ρi→µi, so, to conclude, by
Lemma 2.5.(v), B `E λx.M′:τ.
c) M≡M1M2. Then, by Lemma 2.5.(ii), there is a µ ∈ TS such that B e` M1:µ→σ and
B `E M2:µ. Since σ≤E τ, also µ→σ≤E µ→τ and, by induction, B e` M1:µ→τ. Then,
by Lemma 2.5.(ii), B `E M1M2:τ.
Now it is easy to prove that type assignment in this system is closed under η-reduction.
The proof for this result is split in two parts, Lemma 2.7 and Theorem 2.8. The lemma is also
used in the proof of Lemmas 3.4, Theorem 3.8, and Theorem 6.21.
Lemma 2.7 B,x:σ e` Mx:τ & x 6∈FV(M) ⇒ B e` M:σ→τ.
Proof: B,x:σ e` Mx:τ & x 6∈FV(M) ⇒ (2.5.(ii))
∃ µ [B,x:σ e` M:µ→τ & B,x:σ `E x:µ] ⇒ (2.5.(i), x not in M)
∃ µ [B e` M:µ→τ & σ≤E µ] ⇒ (2.1)
∃ µ [B e` M:µ→τ & µ→τ≤E σ→τ] ⇒ (2.6)
B e` M:σ→τ.
Theorem 2.8 If B `E M:σ and M→η N, then B `E N:σ.
Proof: Only the part σ∈Ts is shown. The proof is completed by induction on the definition of
→η , of which only the part λx.Mx→η M is shown, where x does not occur free in M. The
other parts are dealt with by straightforward induction. Then: B e` λx.Mx:σ ⇒ (2.5.(iii))
∃ ρ,µ [σ = ρ→µ & B,x:ρ e` Mx:µ] ⇒ (2.7) B e` M:σ.
For example, ∅ `E λxy.xy:(σ→τ)→σ∩ρ→τ and ∅ `E λx.x:(σ→τ)→σ∩ρ→τ
are both easy to derive.
As in [9, 6, 1], it is possible to prove that the essential type assignment system is closed
under =β. In the first paper, this result was obtained by a ‘Cut and Paste’-proof (see Sub-
section 1.1). In the latter two papers this result was obtained by building a filter λ-model as
sketched in Section 1.3; from the fact that every M is interpreted by the set of its assignable
types, and that set is a filter, the result is then immediate (see also Corollary 4.16). In this
Theoretical Computer Science, 151(2):385-435, 1995 17
paper the result will first be obtained directly, without constructing a filter model; in this
way the precise behaviour of the type constructor ‘∩’ and the type constant ω can be made
apparent.
First, a substitution lemma is proved. Notice that, unlike for many other notions of type
assignment (Curry’s system, the CD-system, the polymorphic type discipline [20]), the im-
plication holds in both directions.
Lemma 2.9 ∃ ρ [B,x:ρ `E M:σ & B `E N:ρ] ⇐⇒ B `E M[N/x]:σ.
Proof: By induction on M. Only the case σ∈ Ts is considered, of which only the non-trivial
parts are shown.
i) M≡ x.
(⇒) ∃ ρ [B,x:ρ e` x:σ & B `E N:ρ] ⇒ (2.5.(i))
∃ ρ [ρ≤E σ & B `E N:ρ] ⇒ (2.5.(iv) & 2.6)
B e` x[N/x]:σ.
ii) M≡ y 6= x.
(⇐) B e` y[N/x]:σ ⇒ B e` y:σ & B `E N:ω.
iii) M≡λy.M′. By Lemma 2.5.(iii) and induction.
iv) M≡M1M2.
(⇐) B e` M1M2[N/x]:σ ⇒ (2.5.(ii) & IH)
∃ ρ1,ρ2,τ [B,x:ρi e` M1:τ→σ & B `E N:ρ1 &
B,x:ρ2 `E M2:τ & B `E N:ρ2] ⇒ (ρ = ρ1∩ρ2 & 2.5.(v) & 2.5.(vii))
∃ ρ [B,x:ρ e` M1M2:σ & B `E N:ρ].
Theorem 2.10 M=β N ⇒ (B `E M:σ ⇐⇒ B `E N:σ), so the following rule is an admissible rule
in `E:
M:σ M=β N
(=β):
N:σ
Proof: By induction on the definition of =β. The only part that needs attention is that of a
redex, B `E (λx.M)N:σ ⇐⇒ B `E M[N/x]:σ, where σ∈Ts; all other cases follow by straight-
forward induction. To conclude, notice that, if B `E (λx.M)N:σ, then, by Lemma 2.5.(ii) &
(iii), ∃ ρ [B,x:ρ `E M:σ & B `E N:ρ]. The result follows then by applying Lemma 2.9.
3 Approximation and normalization results
In [34] an approximation theorem is proved, that formulates the relation between the types
assignable to a term and those assignable to its approximants, as defined in [37] (see Defini-
tion 3.1 below).
Property 3.1 B `∩ M:σ if and only if there exists A∈A(M) such that B `∩ A:σ.
In this section, an ‘essential’ variant of this property will be proved; for every M,B and σ
such that B `E M:σ, there is an A∈A(M) such that B `E A:σ. In [34] this result is obtained
through a normalization of derivations, where all (→I)–(→E) pairs, that derive a type for
a redex (λx.M)N, are replaced by one for its reduct M[N/x], and all pairs of (∩I)–(∩E) are
eliminated. (This technique is also used in [9] and [6]. It requires a rather difficult notion of
length of a derivation to show that this process terminates.) In this paper, this result will be
proved using the computability technique, following Tait [36], as was done in [11], and [17].
Theoretical Computer Science, 151(2):385-435, 1995 18
With this result, it can be shown that the BCD-system is conservative over the essential
system (Theorem 4.5), and prove that the set of all terms having a (head) normal form are
typeable in e` (with a type without ω-occurrences) (Theorem 3.12).
3.1 Approximate normal forms
The notion of approximant was first presented by C. Wadsworth [37] and is defined using the
notion of terms in λ⊥-normal form (like in [5], ⊥ is used, instead of Ω; also, the symbol@∼ is
used as a relation on Λ⊥-terms, inspired by a similar relation defined on Bo¨hm-trees in [5]).
Definition 3.1 i) The set of Λ⊥-terms is defined as the set Λ of lambda terms, extended
by: ⊥∈Λ⊥.
ii) The notion of reduction →β⊥ is defined as →β , extended by:
a) λx.⊥ →β⊥ ⊥.
b) ⊥M→β⊥ ⊥.
iii) The set of normal forms for elements of Λ⊥ with respect to →β⊥ is the setN of λ⊥-normal forms
or approximate normal forms and is inductively defined by:
a) ⊥∈N.
b) If A∈N, A 6=⊥, then λx.A∈N.
c) If A1, . . . , An∈N (n ≥ 0), then xA1· · ·An∈N.
The rules of the essential system are generalized to terms containing ⊥ by allowing for the
terms to be elements of Λ⊥. This implies that, because essential type assignment is almost
syntax directed, if ⊥ occurs in a term M and B `E M:σ, then either σ = ω, or in the derivation
for M:σ, ⊥ appears in the right hand subterm of an application on which the rule (→E) is
used with n = 0. Moreover, the terms λx.⊥ and ⊥M1· · ·Mn are typeable by ω only.
Definition 3.2 i) The relation @∼ ⊆ (Λ⊥)
2 is defined by:
a) ⊥@∼M.
b) x@∼ x.
c) M@∼M
′ ⇒ λx.M@∼λx.M
′.
d) M1@∼M
′
1 & M2@∼M
′
2 ⇒ M1M2@∼M
′
1M
′
2.
For A∈N, M∈Λ, if A@∼M, then A is a direct approximant of M.
ii) The relation v ⊆ N × Λ is defined by:
A v M ⇐⇒ ∃M′=β M [A@∼M
′].
If AvM, then A is an approximant of M.
iii) A(M) = {A ∈ N | Av M}.
The following properties of approximants hold:
Lemma 3.3 i) If A∈A(xM1 . . .Mn) and A′∈A(N), then
AA′∈A(xM1 . . .MnN).
ii) If A∈A(Mz) and z 6∈FV (M), then either:
a) A≡A′z, z 6∈FV (A), and A′∈A(M), or
b) λz.A∈A(M).
Proof: Easy.
Theoretical Computer Science, 151(2):385-435, 1995 19
3.2 Approximation result
In this subsection, the approximation theorem will be proved. For reasons of readability, in
this subsection ∃ A∈A(M) [B `E A:σ] will be abbreviated by App (B,M,σ).
Lemma 3.4 i) App (B,xM1· · ·Mn,σ→τ) & App (B′,N,σ) ⇒
App (Π{B,B′},xM1· · ·MnN,τ).
ii) App (B ∪ {z:σ},Mz,τ) & z 6∈FV(M) & τ∈Ts ⇒ App (B,M,σ→τ).
iii) App (B,C[M[N/x]],σ) ⇒ App (B,C[(λx.M)N],σ).
Proof: i) A∈A(xM1· · ·Mn) & B `E A:σ→τ & A
′∈A(N) & B `E A
′:τ ⇒
(3.3.(i) & 2.5.(ii))
AA′∈A(xM1· · ·MnN) & Π{B,B′} `E AA′:τ.
ii) A∈A(Mz) & B,z:σ `E A:τ & z 6∈FV(M) ⇒ (3.3.(ii))
a) A≡A′z & z 6∈FV(A′) & A′∈A(M) & B,z:σ e` A′z:τ ⇒ (2.7)
A′∈A(M) & B e` A′:σ→τ.
b) λz.A∈A(M) & B,z:σ e` A:τ ⇒ λz.A∈A(M) & B e` λz.A:σ→τ.
iii) Since M=β M
′ implies A(M) = A(M′).
In order to prove that for each term typeable in `E an approximant with the same type
can be found, a notion of computability is introduced.
Definition 3.5 Comp(B,M,ρ) is inductively defined by:
i) Comp(B,M, ϕ) ⇐⇒ B `E M:ϕ & App (B,M, ϕ).
ii) Comp(B,M,σ→τ) ⇐⇒
( Comp(B′,N,σ) ⇒ Comp(Π{B,B′},MN,τ) ).
iii) Comp(B,M,σ1∩· · ·∩σn) ⇐⇒ ∀ 1≤ i≤ n [Comp (B,M,σi)].
Notice that Comp(B,M,ω) holds as special case of part (iii).
Lemma 3.6 Take σ and τ such that σ≤E τ. Then Comp(B,M,σ) ⇒ Comp(B,M,τ).
Proof: By straightforward induction on the definition of ≤E.
Lemma 3.7 Comp (B,C[M[N/x]],σ) ⇒ Comp(B,C[(λx.M)N],σ).
Proof: By induction on the structure of types. The case that σ is a type-variable follows from
Theorem 2.10 and Lemma 3.4.(iii).
Theorem 3.8 i) B `E xM1· · ·Mn:ρ & App (B,xM1· · ·Mn,ρ) ⇒
Comp(B,xM1· · ·Mn,ρ).
ii) Comp(B,M,ρ) ⇒ B `E M:ρ & App (B,M,ρ).
Proof: Simultaneously by induction on the structure of types. The only interesting case is
when ρ = σ→τ; the other cases are dealt with by induction.
i) B `E xM1· · ·Mn:σ→τ & App (B,xM1· · ·Mn,σ→τ) ⇒ (IH.(ii))
( Comp(B′,N,σ) ⇒ B `E xM1· · ·Mn:σ→τ & B′ `E N:σ &
App (B,xM1· · ·Mn,σ→τ) & App (B′,N,σ) ) ⇒ (2.5.(ii) & 3.4.(i))
( Comp(B′,N,σ) ⇒ Π{B,B′} `E xM1· · ·MnN:τ &
App (Π{B,B′},xM1· · ·MnN,τ) ) ⇒ (IH.(i))
( Comp(B′,N,σ) ⇒ Comp(Π{B,B′},xM1· · ·MnN,τ) ) ⇒ (3.5.(ii))
Comp(B,xM1· · ·Mn,σ→τ).
Theoretical Computer Science, 151(2):385-435, 1995 20
ii) Comp(B,M,σ→τ) & z 6∈FV(M) ⇒ (IH.(i))
Comp(B,M,σ→τ) & Comp({z:σ},z,σ) & z 6∈FV(M) ⇒ (3.5.(ii))
Comp(B ∪ {z:σ},Mz,τ) & z 6∈FV(M) ⇒ (IH.(ii))
B∪ {z:σ} `E Mz:τ & App (B ∪ {z:σ},Mz,σ) & z 6∈FV(M) ⇒
(2.7 & 3.4.(ii))
B `E M:σ→τ & App (B,M,σ→τ).
Notice that, by part (ii), in particular Comp({x:σ},x,σ), for all x,σ.
Theorem 3.9 If B = {x1:µ1, . . . ,xn:µn}, B `E M:σ, and, for every 1≤ i≤n, Comp(Bi,Ni,µi), then
Comp(Π{B1, . . . ,Bn},M[N1/x1, . . . ,Nn/xn],σ).
Proof: By induction on the structure of types, of which only the part σ∈Ts is presented. This
is shown by induction on the structure of derivations.
(→I) Then M≡λy.M′, σ = ρ→τ, and B,y:ρ `E M′:τ.
B = {x1:µ1, . . . ,xn:µn} & ∀ 1≤ i≤ n [Comp (Bi,Ni,µi)] &
B,y:ρ `E M′:τ ⇒ (IH)
(Comp (B′,N,ρ) ⇒
Comp(Π{B1, . . . ,Bn,B′},M′[N1/x1, . . . ,Nn/xn,N/y],τ)) ⇒ (3.7)
(Comp (B′,N,ρ) ⇒
Comp(Π{B1, . . . ,Bn,B′}, (λy.M′[N1/x1, . . . ,Nn/xn])N,τ)) ⇒
(3.5.(ii))
Comp(Π{B1, . . . ,Bn}, (λy.M
′)[N1/x1, . . . ,Nn/xn],ρ→τ).
(→E) Then M≡M1M2, B `E M1:ρ→σ, and B `E M2:ρ.
B = {x1:µ1, . . . ,xn:µn} & ∀ 1≤ i≤ n [Comp (Bi,Ni,µi)] &
B `E M1:ρ→σ & B `E M2:ρ ⇒ (IH)
Comp(Π{B1, . . . ,Bn},M1[N1/x1, . . . ,Nn/xn],ρ→σ) &
Comp(Π{B1, . . . ,Bn},M2[N1/x1, . . . ,Nn/xn],ρ) ⇒ (3.5.(ii))
Comp(Π{B1, . . . ,Bn}, (M1M2)[N1/x1, . . . ,Nn/xn],σ).
(≤E) By Lemma 3.6.
As for the BCD-system and the strict system, the relation between types assignable to a
lambda term and those assignable to its approximants can be formulated as follows:
Theorem 3.10 B `E M:σ ⇐⇒ ∃ A∈A(M) [B `E A:σ].
Proof: (⇒) B `E M:σ ⇒ (3.9) Comp(B,M,σ) ⇒ (3.8.(ii))
∃ A∈A(M) [B `E A:σ].
(⇐) If B `E A:σ, then by the remark made after Definition 3.1, ⊥ appears only in sub-
terms that are typed by ω. Since A∈A(M), there is an M′ such that M′=β M and A@∼
M′. Then, by Lemma 2.5.(viii), B `E M′:σ and, by Theorem 2.10, also B `E M:σ.
3.3 Normalization results
To prepare the characterization of terms by their assignable types, first is proved that a term
in λ⊥-normal form is typeable without ω, if and only if it does not contain ⊥. This forms
the basis for the result that all normalizable terms are typeable without ω.
Lemma 3.11 i) If B `E A:σ and B,σ are ω-free, then A is ⊥-free.
ii) If A is ⊥-free, then there are ω-free B and σ, such that B e` A:σ.
Proof: By induction on A.
Theoretical Computer Science, 151(2):385-435, 1995 21
i) As before, only the part σ∈Ts is shown; only the part A≡ xA1· · ·An is of interest. Then,
by Lemma 2.5.(ii) and (i), there are σ1, . . . ,σn,τ1, . . . ,τn,τ, such that x:τ1→·· ·→τn→τ ∈ B,
for every 1≤ i≤ n, B `E Ai:σi, and τ1→·· ·→τn→τ≤E σ1→·· ·→σn→σ. So, especially, for
every 1≤ i≤ n, σi ≤E τi. By Theorem 2.8, also for every 1≤ i≤ n, B `E Ai:τi. Since each
τi occurs in B, all are ω-free, so by induction each Ai is ⊥-free. Then also xA1· · ·An is
⊥-free.
ii) a) A≡ λx.A′. By induction there are B,τ such that B e` A′:τ and B,τ are ω-free. If x
does not occur in B, take an ω-free σ∈ Ts. Otherwise, there exist x:σ∈ B, and σ is
ω-free. In any case, B\x `E λx.A′:σ→τ, and B\x and σ→τ are ω-free.
b) A≡xA1· · ·An, with (n≥ 0). By induction there are B1, . . . ,Bn and σ1, . . . ,σn such that
for every 1≤ i≤ n, Bi e` Ai:σi, and Bi,σi are ω-free. Take σ strict, such that ω does
not occur in σ, and B = Π{B1, . . . ,Bn,{x:σ1→·· ·→σn→σ}}. Then B `E xA1· · ·An:σ,
and B and σ, are ω-free.
Now, as in [1] for the strict system, it is possible to prove that the essential type assignment
system satisfies the main properties of the BCD-system.
Theorem 3.12 i) ∃ B,σ [B e` M:σ & B,σ ω-free] ⇐⇒ M has a normal form.
ii) ∃ B,σ [B e` M:σ] ⇐⇒ M has a head normal form.
Proof: i) (⇒) If B e` M:σ, then, by Theorem 3.10, ∃ A ∈ A(M) [B `E A:σ]. Because of
Lemma 3.11.(i), this A is ⊥-free. By Definition 3.1, there exists M′ =β M such that
A @∼ M
′. Since A is ⊥-free, in fact A≡ M′, so M′ itself is in normal form, so,
especially, M has a normal form.
(⇐) If M′ is the normal form of M, then it is a ⊥-free approximate normal form.
Then, by Lemma 3.11.(ii), there are ω-free B,σ such that B e` M
′:σ. Then, by Theo-
rem 2.10, B e` M:σ.
ii) (⇒) If B e` M:σ, then, by Theorem 3.10, ∃ A ∈ A(M) [B `E A:σ]. By Definition 3.1,
there exists M′=β M such that A@∼M. Since σ∈ Ts, A 6≡ ⊥, so A is either λx.A1 or
xA1· · ·An, with n ≥ 0. Since AvM′, M′ is either λx.M1, or xM1· · ·Mn. Then M has
a head-normal form.
(⇐) If M has a head-normal form, then there exists M′=β M such that M
′ is either
x, λx.M1 or xM1· · ·Mn, with each Mi∈Λ.
a) M′≡λx.M1. Since M1 is in head-normal form, by induction there are B,σ∈Ts such
that B `E M1:σ. If x:τ∈ B, then B\x e` λx.M1:σ→τ, otherwise B e` λx.M1:ω→τ.
b) M′≡ xM1· · ·Mn, (n ≥ 0). Take σ∈Ts, then
Π{B1, . . . ,Bn,{x:ω→·· ·→ω→σ}} e` xM1· · ·Mn:σ.
Corollary 3.13 i) ∃ B,σ [B `E M:σ & B,σ ω-free] ⇐⇒ M has a normal form.
ii) ∃ B,σ [B `E M:σ & σ 6=ω] ⇐⇒ M has a head normal form.
4 Soundness and completeness of essential type assignment
4.1 The relation between the BCD- and the essential system
The essential system is the nucleus of the BCD-system: in this subsection it will be shown
that, for any derivation in the BCD-system, it is possible to find an equivalent derivation in
the essential system.
The proof is based on the fact that for every σ∈T∩ there is a σ∗ ∈TS such that σ∼ σ
∗, and
the Approximation Theorem 3.10.
Theoretical Computer Science, 151(2):385-435, 1995 22
Definition 4.1 (cf. [22, 1]) i) For every σ∈T∩, σ∗ ∈TS is inductively defined as follows:
a) ϕ∗ = ϕ.
b) (σ→τ)∗ = (σ∗→τ1)∩· · ·∩ (σ∗→τn), if τ∗ = τ1∩· · ·∩τn (n ≥ 0), each τi ∈Ts.
c) (σ1∩· · ·∩σn)∗ = τ∗1 ∩· · ·∩τ
∗
m, where {τ1, . . . ,τm} = {σi ∈ {σ1, . . . ,σn} | σ
∗
i 6=ω}.
ii) B∗ = {x:σ∗ | x:σ ∈ B}.
Since TS is a proper subset of T∩, σ∗ is also defined for σ ∈ TS. Notice that ω∗ = ω, as a
special case of part (i.c), and that (σ→ω)∗ = ω, as a special case of part (i.b).
Lemma 4.2 i) [22, 1] For every σ∈T∩, σ∼σ∗.
ii) T∩ modulo ∼ is isomorphic to TS modulo ∼E .
iii) σ≤ τ ⇒ σ∗≤E τ∗.
iv) σ∈TS ⇒ σ = σ
∗.
Proof: Easy.
The proof for the main theorem of this section is achieved by proving first, that for every
term in N, typeable in `∩ , a derivation in the essential system can be built for which basis
and type in the conclusion are equivalent, and afterwards generalizing this result to arbitrary
lambda terms.
Theorem 4.3 B `∩ A:σ ⇒ B∗ `E A:σ∗.
Proof: By induction on the structure of terms in N, using Lemmas 1.7, 2.5, and 4.2.(iii).
The relation between the two different notions of type assignment is formulated as follows:
Theorem 4.4 B `∩ M:σ ⇒ B∗ `E M:σ∗.
Proof: B `∩ M:σ ⇒ (3.1) ∃ A∈A(M) [B `∩ A:σ] ⇒ (4.3)
∃ A∈A(M) [B∗ `E A:σ∗] ⇒ (3.10) B∗ `E M:σ∗.
The BCD system is a conservative extension of the essential system.
Theorem 4.5 Conservativity. Let B,σ∈TS. If B `∩ M:σ, then B `E M:σ.
Proof: B `∩ M:σ ⇒ (4.4) B∗ `E M:σ∗ ⇒ (4.2.(iv)) B `E M:σ.
Obviously, since the essential system is a subsystem of the BCD-system, the implication in
the other direction also holds: If B `E M:σ, then B `∩ M:σ.
Also using this last result, it is possible to prove completeness of essential type assignment
with respect to the simple type semantics (see Theorem 4.18).
4.2 An essential filter λ-model
As in [6] and [1], a filter λ-model can be constructed. Names will be used to distinguish
between the definition of filters in those papers and the one given here.
Definition 4.6 i) A subset d of TS is an essential filter if and only if:
a) σ1, . . . ,σn ∈ d (n ≥ 0) ⇒ σ1∩· · ·∩σn ∈ d.
b) τ∈ d & τ≤E σ ⇒ σ∈ d.
ii) If V is a subset of TS, then ↑EV is the smallest essential filter that contains V, and ↑Eσ =
↑E{σ}.
iii) FE = {d ⊆ TS | d is an essential filter}. Application on FE is defined by:
d · e = ↑E{τ | ∃ σ ∈ e [σ→τ ∈ d]}.
Theoretical Computer Science, 151(2):385-435, 1995 23
Notice that every strict filter (Definition 1.14) is an essential filter, and that an essential filter
is a filter in the sense of Definition 1.8.
If no confusion is possible, the subscript on ↑ will be omitted. Notice that an essential
filter is never empty; because of part (i.a), for all d, ω ∈ d. Notice also that the application
on filters as in Definition 1.8 is not useful for FE, since it would not be well defined. As in
[1], application must be forced to yield filters, since in each arrow type scheme σ→τ∈TS, τ
is strict. <FE, ⊆> is a cpo and henceforward it will be considered with the corresponding
Scott topology.
For essential filters the following properties hold:
Lemma 4.7 i) σ∈↑τ ⇐⇒ τ≤E σ.
ii) σ∈↑{τ | B e` M:τ} ⇐⇒ σ∈{τ |B `E M:τ}. (So {σ |B `E M:σ}∈FE.)
Proof: Easy.
Definition 4.8 Define F: FE→[FE→FE] and G: [FE→FE]→FE by:
i) F d e = d · e.
ii) G f = ↑{σ→τ | τ∈ f (↑σ)}.
It is easy to check that F and G are continuous.
Theorem 4.9 <FE, ·>, with F and G as defined in 4.8, is a λ-model.
Proof: By [5].5.4.1 it is sufficient to prove that F◦G = Id[FE→FE].
F◦G f d = ↑{µ | ∃ρ∈ d [ρ→µ∈↑{σ→τ | τ∈ f (↑σ)}]} = (4.7.(i))
↑{µ | ∃ρ∈ d [µ∈ f (↑ρ)]} = f (d).
Remark that between FE and FS the same relation exists as between F∩ and FS, as dis-
cussed after Definition 1.14.
Definition 4.10 Let ξ be a valuation of term variables in FE.
i) [[M]]ξ , the interpretation of terms in FE via ξ is inductively defined by:
a) [[x]]ξ = ξ(x).
b) [[MN]]ξ = F [[M]]ξ [[N]]ξ .
c) [[λx.M]]ξ = G (λ d∈FE.[[M]]ξ(d/x)).
ii) Bξ = {x:σ | σ∈ ξ(x)}.
Theorem 4.11 For all M, ξ: [[M]]ξ = {σ |Bξ `E M:σ}.
Proof: By induction on the structure of lambda terms.
i) [[x]]ξ = ξ(x). Since {y:ρ | ρ∈ ξ(y)} `E x:σ ⇐⇒ σ∈ ξ(x).
ii) [[MN]]ξ = ↑{τ | ∃ σ [Bξ `E N:σ & Bξ `E M:σ→τ]} = (2.5.(ii) & (iv))
↑{τ | Bξ e` MN:τ} = (4.7.(ii))
{τ | Bξ `E MN:τ}
iii) [[λx.M]]ξ =
↑{σ→τ | Bξ(↑σ/x) `E M:τ} = (2.5.(iv))
↑{σ→τ | Bξ(↑σ/x) e` M:τ} = (B
′
ξ = Bξ\x)
↑{σ→τ | B′ξ ∪ {x:µ | µ∈↑σ} e` M:τ} = (4.7.(i))
↑{σ→τ | B′ξ ∪ {x:σ} e` M:τ} = (2.5.(iii))
↑{σ→τ | B′ξ e` λx.M:σ→τ} = (2.5.(vi))
↑{σ→τ | Bξ e` λx.M:σ→τ} = (2.5.(iii) & 4.7.(ii))
{ρ | Bξ `E λx.M:ρ}.
Theoretical Computer Science, 151(2):385-435, 1995 24
4.3 Soundness and completeness
In this subsection completeness for the `E systemwill be proved. This is done in a way very
similar to the one used in [6], using the essential filter λ-model as defined in the previous
subsection.
Theorem 4.12 Soundness. B `E M:σ ⇒ B `s M:σ.
Proof: By induction on the structure of derivations.
The method followed in [6] for the proof of completeness of type assignment is to define
a simple type interpretation υ that satisfies: for all types σ, υ(σ) = {d ∈ F∩ | σ ∈ d}. The
approach taken here is to define a type interpretation, and to show that it is simple.
Definition 4.13 i) ν0 : TS → ℘(FE) is defined by:
ν0 (σ) = {d∈FE | σ∈ d}.
ii) ξB(x) = {σ∈TS | B `E x:σ}.
Theorem 4.14 i) The map ν0 is a simple type interpretation.
ii) If σ≤E τ, then ν0 (σ) ⊆ ν0 (τ).
Proof: i) It is sufficient to check the conditions of Definition 1.9.(ii).
a) ∀ e [e∈ ν0 (σ) ⇒ d · e∈ ν0 (τ)] ⇐⇒ (4.6.(iii))
∀ e [e∈ ν0 (σ) ⇒ ↑{β | ∃α∈ e [α→β∈ d]}∈ ν0 (τ)] ⇐⇒ (4.13.(i))
∀ e [σ∈ e ⇒ τ∈↑{β | ∃α∈ e [α→β∈ d]}] ⇐⇒ (τ∈Ts)
∀ e [σ∈ e ⇒ ∃α∈ e [α→τ∈ d]] ⇐⇒ (for ⇒, take e = ↑σ)
σ→τ∈ d.
b) Trivial.
ii) Easy.
Lemma 4.15 i) B `E M:σ ⇐⇒ BξB `E M:σ.
ii) FE, ξB, ν0 `s B.
Proof: i) Because for every x, ξB(x) is an essential filter.
ii) x:σ∈ B ⇒ ((i)) σ∈ {τ | BξB `E x:τ} ⇒ σ∈ [[x]]ξB .
So [[x]]ξB ∈ {d∈FE | σ∈ d} = ν0 (σ).
Since the interpretation of terms by their derivable types gives a λ-model, the following
corollary is immediate and an alternative proof for Theorem 2.10.
Corollary 4.16 If M=β N and B `E M:σ, then B `E N:σ.
Proof: Since FE is a λ-model, if M=β N, then [[M]]Bξ = [[N]]Bξ ;
so {σ | B `E M:σ} = {σ | B `E N:σ}.
Notice that because of the way in which `E is defined, Corollary 4.16 also holds if `E is
replaced by e` .
Theorem 4.17 Completeness. Let σ∈TS, then B `s M:σ ⇒ B `E M:σ.
Proof: B `s M:σ ⇒ (1.10. (ii.c.2), 4.15.(ii) & 4.14)
FE, ξB, ν0 `s M:σ ⇒ (1.10.(i))
[[M]]ξB ∈ ν0 (σ) ⇒ (4.13.(i))
σ∈ [[M]]ξB ⇒ (4.11)
BξB `E M:σ ⇒ (4.15.(i))
B `E M:σ.
Theoretical Computer Science, 151(2):385-435, 1995 25
Using the relation between the two notions of type assignment that was defined in the
previous subsection, soundness and completeness of essential type assignment can also be
proved using the result of [6] (Property 1.11).
Theorem 4.18 Soundness and completeness of essential type assignment. Let B and σ contain
types in TS. Then B `E M:σ ⇐⇒ B `s M:σ.
Proof: (⇒) B `E M:σ ⇒ B `∩ M:σ ⇒ (1.11.(i)) B `s M:σ.
(⇐) B `s M:σ ⇒ (1.11.(ii)) B `∩ M:σ ⇒ (4.5) B `E M:σ.
5 Systems with principal types
It is well known that Curry’s system has the principal type property: M is typeable if and
only if there is a pair 〈P,pi〉 of basis and type, called the principal pair for M, such that:
• P `M:pi, and
• for every pair 〈B,σ〉 such that B `M:σ, there exists an operation O (from a specified set
of operations) such that O (〈P,pi〉) = 〈B,σ〉.
The type pi is then called the principal type for M. For Curry’s system the operation O
consists entirely of substitutions, i.e. operations that replace type-variables by types. Princi-
pal type schemes for Curry’s system are defined by J.R. Hindley in [21]. In this paper the
author actually proved the existence of principal types for an object in Combinatory Logic,
but the same construction can be used for a proof of the principal type property for terms
in Lambda Calculus. The basic idea used in [21] is to define a unification-algorithm, that is
used to construct the principal type for an application form the principal types deduced for
its components. Since substitution is an easy operation, in Curry’s system the set
{〈B,σ〉 | B `M:σ}
can be computed in a simple way from the principal pair for M.
There exist three intersection systems for which the principal type property is proved:
a CDV-system in [9], the BCD-system in [34], and the strict system in [4]. The technique
used for the proofs of these properties is very different for the one used for Curry’s sytem.
The principal type scheme for a term is in [9], [34], and [4] studied through the notion of
approximant of a term; terms with a finite number of approximants have finite principal
type schemes, while terms with a infinite number of approximants have ‘infinite’ principal
type schemes. It should be noted that, using intersection types, also terms without normal
form or, in particular, terms that have an ‘infinite’ normal form have types. Therefore, a
functional characterization of these terms, through a principal type, cannot be represented
in a finite way.
5.1 The operation of expansion
As mentioned in the introduction of [9], using intersection types different types can be
assigned to the same component of a given term. Therefore, the structure of derivation does
not follow the syntactic structure of terms, and with the only operation of substitution, for
a given term, not all types can be obtained. This difficulty is overcome in [9] by introducing
the (context-dependent) operation of expansion.
The definition of expansion is very complicated. It is an operation on types that deals with
the replacement of (sub)types by a number of copies of that type. Expansion on types cor-
responds to the duplication of (sub)derivations: a subderivation in the right-hand side of an
Theoretical Computer Science, 151(2):385-435, 1995 26
(→E)-step is expanded by copying. In this process, the types that occur in the subderivation
are also copied: the types in the conclusion and in the basis of the subderivation will be
instantiated into a number of copies.
Suppose the following is a correct derivation:
x:σ→τ
B
AA 
N:σ
xN:τ
then, in general, the expansion that replaces σ by σ1∩· · ·∩σn creates the following derivation:
x:σ1∩· · ·∩σn→τ
B1
AA 
N:σ1
· · ·
Bn
AA 
N:σn
xN:τ
Suppose that µ is a subtype of σ that is expanded into n copies. If ρ→µ is also a subtype
of σ, then just replacing µ by an intersection of copies of µ, would generate ρ→(µ1∩· · ·∩µn).
This is a not a legal type in [9] and [4]. Defining an operation of expansion by saying
that it should expand the subtype ρ→µ into the type (ρ→µ1)∩· · ·∩ (ρ→µn) – which is by
definition of the relation ≤ a type equivalent to ρ→(µ1∩· · ·∩µn) – would give an expan-
sion that is sound, but not sufficient. The subtype ρ→µ will, therefore, be expanded into
(ρ1→µ1)∩· · ·∩(ρn→µn), where the ρ1, . . . ,ρn are copies of ρ. This means that also all other
occurrences of ρ should be expanded into ρ1∩· · ·∩ρn, with possibly the same effect on other
types.
Apparently, the expansion of µ can have a more than local effect on σ. Therefore, the
expansion of a type is defined in a such a way that, before the replacement of types by
intersections, all sub-types are collected that are affected by the expansion of µ. Then types
are traversed top down, and types are replaced if they end with one of the sub-types found.
5.2 The system of [9]
In [9] principal type schemes are defined for a type assignment system that is like the re-
stricted one from [10], but uses the set of types of the unrestricted system. The reason to
not use the normalized types as well is the fact that ω is treated as a type constant; since
ω can be substituted for ϕ in σ→ϕ, also σ→ω is considered a type. The principal type
property is achieved by defining principal pairs of basis and type for terms in λ⊥-normal
form, specifying the operations of expansion and substitution, proved sufficient to generate
all possible pairs for those terms from their principal pair, and generalizing this result to
arbitrary lambda terms. This technique is the same as for example used in [34], [4], and
Section 6 of this paper.
The set of ground pairs for a term A∈N, as defined in [9], is proved to be complete for
A, in the sense that all other pairs for A can be generated from a ground pair for A. Ground
pairs are those that express the essential structure of a derivation, and types in it are as
general as possible with respect to substitutions.
The proof of the principal type property is obtained by first proving the following:
• If B ` A:σ with A∈N, then there is a substitution Sub and a ground pair 〈B′,σ′〉 for A
such that Sub (〈B,σ〉) = 〈B′,σ′〉.
Theoretical Computer Science, 151(2):385-435, 1995 27
• If 〈B,σ〉 is a ground pair for A ∈ N and 〈B′,σ′〉 can be obtained from 〈B,σ〉 by an
expansion, then 〈B′,σ′〉 is a ground pair for A.
• For all A∈N, every ground pair for A is complete for A.
In the construction of principal pairs for lambda terms, first for every A ∈ N a par-
ticular pair Pp(A) is chosen of basis P and type pi, called the principal basis scheme and
principal type scheme of A, respectively (see Definition 6.5). This pair is called the principal pair
of A.
The proof is completed by proving:
• Pp(A) is a ground pair for A.
• B `M:σ if and only if there exists A∈A(M) such that B ` A:σ.
• {Pp (A) | A∈A(M)} is complete for M.
For an example of a ground pair, and its relation to the operation of expansion, take the
pair 〈∅, (ω→(ϕ0→ϕ0)→ϕ1)→ϕ1〉, which is the principal pair of (λx.x⊥(λy.y)).
[x : ω→(ϕ0→ϕ0)→ϕ1] [y : ϕ0]
λy.y : ϕ0→ϕ0x⊥ : (ϕ0→ϕ0)→ϕ1
x⊥(λy.y) : ϕ1
λx.x⊥(λy.y) : (ω→(ϕ0→ϕ0)→ϕ1)→ϕ1
Let Exp be the expansion that copies the subderivation for λy.y:ϕ0→ϕ0, then
Exp (〈∅, (ω→(ϕ0→ϕ0)→ϕ1)→ϕ1)〉 =
〈∅, (ω→(ϕ2→ϕ2)∩(ϕ3→ϕ3)→ϕ1)→ϕ1〉,
which is, by the results mentioned above, a ground pair for (λx.x⊥(λy.y)).
[x : ω→(ϕ2→ϕ2)∩(ϕ3→ϕ3)→ϕ1] [y : ϕ2]
λy.y : ϕ2→ϕ2
[y : ϕ3]
λy.y : ϕ3→ϕ3x⊥ : (ϕ2→ϕ2)∩(ϕ3→ϕ3)→ϕ1
x⊥(λy.y) : ϕ1
λx.x⊥(λy.y) : (ω→(ϕ2→ϕ2)∩(ϕ3→ϕ3)→ϕ1)→ϕ1
(See Definition 6.11.)
5.3 The system of [34]
For the system as defined in [6], principal type schemes can be defined as in [34]. There three
operations are provided – substitution, expansion, and rise – that are sound and sufficient
to generate all suitable pairs for a term M from its principal pair.
In this paper, all constructions and definitions are made modulo the equivalence relation
∼. In fact, the complexity inserted in the type language of [6] by allowing for intersection
types on the right of the arrow type constructor, disturbs greatly the accessibility of this
paper. As shown in Section 6, the results of [34] can also be obtained for the essential system
presented here, that is equally powerful.
The first operation defined is substitution, that is defined without restriction: the type that
is to be substituted can be every element of T∩. Next, the operation of expansion is defined,
which is a generalization of the notion of expansion defined in [9]. Both substitution and
expansions are in the natural way extended to operations on bases and pairs. The third
operation defined (on pairs) is the operation of rise: it consists of adding applications of the
derivation rule (≤) to a derivation. All defined operations are sound in the following sense:
Theoretical Computer Science, 151(2):385-435, 1995 28
• (Soundness) Let for A∈N, B,σ be such that B `∩ A:σ, O be an operation of substitution,
expansion or rise, and O (〈B,σ〉) = 〈B′,σ′〉. Then B′ `∩ A:σ′.
Linear chains of operations are defined as sequences of operations that start with a number
of expansions, followed by a number of substitutions, and that end with one rise. (In [34],
linear chains are defined as those sequences of operations that start with a number of ex-
pansions, followed by a number of substitutions or rises; both are allowed. This definition
is not complete, in the sense that the fact that the chain ends with one rise is essential in the
proof for completeness.) As in [9], principal pairs are defined for terms in λ⊥-normal form.
The proof of the principal type property is completed by, using the above approximation
theorem, proving first that, when A(M) is finite, then {Pp (A) | A∈A(M)} has a maximal
element (see Theorem 6.28 and Definition 6.29). The following is proved:
Property 5.1 i) (Completeness) Let A∈N. For any pair 〈B,σ〉 such that B `∩ A:σ there exists
a linear chain C such that C (Pp(A)) = 〈B,σ〉.
ii) Let B `∩ M:σ.
a) A(M) is finite. Then {Pp (A) | A∈A(M)} has a maximal element, say 〈P,pi〉. Then there
exists a chain C, such that C (〈P,pi〉) = 〈B,σ〉.
b) A(M) is infinite. Then there exist a pair 〈P,pi〉∈{Pp (A) |A∈A(M)} and a chain C, such
that C (〈P,pi〉) = 〈B,σ〉.
5.4 The system of [4]
The proof of the principal type property for the strict system as presented in [4] is achieved
in a way similar to, but significantly different from, the two techniques sketched above. In
that paper, three operations on pairs of basis and types are defined: substitution, expansion,
and lifting. The operation of lifting resembles the operation of rise as defined in [34], the
operation of substitution is a modification of the one normally used, and the operation of
expansion coincides with the one given in [9, 34].
In order to prove that the operations defined are sufficient, three subsets of the set of all
pairs of basis and type are defined, namely: principal pairs, ground pairs, and primitive
pairs. (The definition of ground pairs coincides with the one given in [9].) In that paper is
shown that these form a true hierarchy, that the set of ground pairs for a term is closed under
the operation of expansion, that the set of primitive pairs is closed under the operation of
lifting, and that the set of pairs is closed for substitution.
The main result of that paper is reached by showing that the three operations defined
are complete: if 〈B,σ〉 is a suitable pair for a term A in λ⊥-normal form, and 〈P,pi〉 is the
principal pair for A, then there are a sequence of operations of expansion Exp, an operation
of lifting Lift, and a substitution Sub, such that
〈B,σ〉 = Sub (Lift (Exp
→
(〈P,pi〉))).
Finally, this result is generalized to arbitrary lambda terms.
Because of technical reasons, substitution is in [4] defined as (ϕ 7→α), where ϕ is a type-
variable and α∈Ts ∪ {ω}, so it can also replace type-variables by the type constant ω (this is
not needed in the proofs of Section 6). Although substitution is normally defined on types
as the operation that replaces type-variables by types, for strict types this definition would
not be correct. For example, the replacement of ϕ by ω would transform σ→ϕ (or σ∩ϕ) into
σ→ω (σ∩ω), which is not a strict type. Therefore, for strict types substitution is not defined
as an operation that replaces type-variables by types, but as a mapping from types to types,
that, in a certain sense, ‘normalizes while substituting’.
Theoretical Computer Science, 151(2):385-435, 1995 29
The operation of expansion, as defined in [4], corresponds to the one given in [9] and is a
simplified version of the one defined in [34]. A difference is that in those definitions subtypes
are collected, whereas the definition of expansion in [4] (see Definition 6.11) collects type-
variables.
Recall Definition 2.1. Observe that strict type assignment is not closed for the relation ≤E,
so the following does not hold:
If B `S M:σ and σ≤E τ, then B `S M:σ.
As a counter example, take {x:σ→σ} s` x:σ→σ. Notice that σ→σ ≤E σ∩τ→σ, but it is im-
possible to derive {x:σ→σ} `S x:σ∩τ→σ.
The operation of lifting as defined in [4] (see Definition 6.22) is based on the relation ≤E, in
the same way as the operation of rise is based on ≤. As shown there, and illustrated above,
that operation is not sound on all pairs 〈B,σ〉. (In fact, as argued in [4], it is impossible
to formulate an operation that performs the desired lifting and is sound on all pairs.) The
reason for this is that introducing a derivation rule, allowed on all terms, using the relation
≤E, corresponds to a η-reduction step (see Theorem 2.8), and the strict system is not closed
for η-reduction. Since strict type assignment is not closed for ≤E , and the operation of lifting
applies ≤E to a derivation, it is clear that a conflict arises.
However, in [4] it is shown that the operation defined there is sound on primitive pairs.
The definition for primitive pairs is based on the definition of ground pairs as given in [9].
The main difference between ground pairs and primitive pairs is that in a primitive pair a
predicate for a term-variable (bound or free) is not the smallest type needed, but can contain
some additional, irrelevant types. The problem mentioned above is then solved by allowing
liftings only on primitive pairs for terms.
The result of [4] follows from:
• Every principal pair is a ground pair.
• – For every expansion Exp, if 〈B,σ〉 is a ground pair for A and Exp (〈B,σ〉) = 〈B′,σ′〉,
then 〈B′,σ′〉 is a ground pair for A.
– If B `S A:σ and Exp (〈B,σ〉) = 〈B
′,σ′〉, then B′ `S A:σ
′.
• Every ground pair is a primitive pair.
• For all A∈N, liftings Lift: if 〈B,σ〉 is a primitive pair for A, then Lift (〈B,σ〉) is a primitive
pair for A.
• Every primitive pair is a (normal) pair.
• If B `S A:σ, then for every substitution Sub: if Sub (〈B,σ〉) = 〈B,σ
′〉, then B′ `S A:σ
′.
Although lifting is not sound on all pairs, using the results mentioned above it is possi-
ble to prove that the three operations defined in [4] are sufficient (complete): for every pair
〈B,σ〉 and A ∈ N, if B `S A:σ, then there exists a number of expansion, one lifting, and a
substitution, such that 〈B,σ〉 can be obtained from Pp(A) by performing these operations
in sequence. As in [34], this result is then generalized to arbitrary lambda terms (see Prop-
erty 5.1 and Theorem 6.30).
6 Principal type property for the essential system
Using a technique different from those discussed above, in this section the proof for the
principal type property of the essential system will be given. For each lambda term the
principal pair (of basis and type) will be defined. Four operations on pairs of basis and
Theoretical Computer Science, 151(2):385-435, 1995 30
types will be defined, namely expansion, covering, substitution, and lifting, that are correct
and sufficient to generate all derivable pairs for lambda terms in the essential system.
A relevant restriction of the essential system will be presented ( `R ), that is close to the
system defined in Definition 1.4. For this system, the principal type property will be proved,
using a technique different from the one used in [9]. In fact, it will be shown that, if B `R M:σ
and 〈P,pi〉 is the principal pair for M, then there is a chain C of operations, consisting of
expansions, one covering, and one substitution, such that C (〈P,pi〉) = 〈B,σ〉. Using this
result, the principal type property for the essential system will be proved.
In [4], the main problem to solve was to find an operation of lifting that was able to take the
special role of the relation ≤S into account. As argued in Subsection 5.4, for the strict system
there exist no operation of lifting that is sound on all pairs. Since the essential system is more
liberal than the strict one, in the sense that the essential system is closed for the relation ≤E
, the operation of lifting as defined in [4] is a sound operation for the essential system (see
Theorem 6.23). It is then easy to show that, with just the operations as defined in [4], the
principal type property holds for the essential system.
In this subsection a different proof will be presented, that follows a new approach. The
most significant difference between proofs for the principal type property made in other pa-
pers and the one presented here, is that, in a certain sense, the operations presented in this
section are more elegant. In [34], there is an overlap between operations; for example, inter-
sections can be introduced by expansions as well as by substitutions and rise. Also, in [4] the
step from the pair 〈B,σ〉 to 〈B,ω〉 can be made using a lifting as well as a substitution. The
operations of expansion, covering, and substitution as defined in this paper are ‘orthogonal’
in that sense; no kind of operation can be mimicked by another kind of operation.
The difference between the operations specified in [4] and this paper lie in the fact that
here the operation of substitution has been changed, in a subtle, natural, but drastic way:
a substitution can no longer replace a type-variable by ω. In the papers discussed above
that possibility existed and, especially in [9] and [4], caused inconvenience, since there a
‘normalization-after-substitution’ was called for, explicitly defined in [9], and part of the
definition of substitution in [4]. The approach of this paper will be to allow of only substitu-
tions of type variables by strict types, and to introduce a separate operation of covering, that
deals with the assignment of ω to subterms.
6.1 Relevant intersection type assignment
The next definition presents a restricted variant of the essential system, that is similar to that
of Definition 1.4, and is the system used in [19]. Since bases play a more significant role in
this system, the presentation of the derivation rules differs from the one used above.
Definition 6.1 i) Relevant intersection type assignment and relevant intersection derivations are
defined by the following natural deduction system (where all types displayed are in Ts,
except for σ in rules (→E) and (→I)):
(Ax): {x:σ} `R x:σ
B1 `R M:σ→τ B2 `R N:σ
(→E):
Π{B1,B2} `R MN:τ
B1 `R M:σ1 · · · Bn `R M:σn
(∩I): (n ≥ 0)
Π{B1, . . . ,Bn} `R M:σ1∩· · ·∩σn
Theoretical Computer Science, 151(2):385-435, 1995 31
B,x:σ `R M:τ
(→I):
B `R λx.M:σ→τ
B `R M:τ
(a)
B `R λx.M:ω→τ
(a) If x does not occur in B.
ii) `R is defined by: B `R M:σ if and only if there is a relevant derivation that has B `R M:σ
as conclusion.
Notice that, by rule (∩I), ∅ `R M:ω, for all terms M. Notice moreover, that this system is
indeed relevant, in the sense that only those statements occur in bases that are actually used
for the derived statement.
For terms in N, the relation between the essential and the relevant system is formulated
by:
Lemma 6.2 If A is in λ⊥-normal form and B `E A:σ, then there are B
′,σ′ such that B′ `R A:σ
′,
σ′≤E σ and B≤E B′.
Proof: By induction on the structure of terms in N.
i) B ` ⊥:ω, then B′ = ∅, and σ′ = ω.
ii) B `E λx.A′:α→β, with A′ 6=⊥, then B∪ {x:α} `E A′:β. By induction, there are B′,ρ′,β′
such that β′≤Eβ, B∪ {x:α}≤EB
′ ∪ {x:α′}, and B′ ∪ {x:α′} `R A
′:β′. Then also B′ `R λx.A
′:α′→β′,
α′→β′≤E α→β, and B≤E B′.
iii) B `E xA1· · ·An:σ, with n ≥ 0. Then there are σ1, . . . ,σn such that, for 1≤ i≤ n, B `E Ai:σi,
and B `E x:σ1→·· ·→σn→σ. By induction, for every 1≤ i≤ n, there are Bi,σ
′
i , such that
Bi `R Ai:σ
′
i , σ
′
i ≤E σi, and B≤E Bi. Then also B≤E Π{B1, . . . ,Bn,{x:σ
′
1→·· ·→σ
′
n→σ}}, and
Π{B1, . . . ,Bn,{x:σ′1→·· ·→σ
′
n→σ}} `R xA1· · ·An:σ.
Using the same technique as in Subsection 3.2, the following theorem can be proved.
Theorem 6.3 B `R M:σ ⇐⇒ ∃ A∈A(M) [B `R A:σ].
Using this approximation result for the relevant system, the following becomes easy.
Theorem 6.4 If B `E M:σ, then there are B′,σ′ such that B′ `R M:σ′, σ′≤E σ and B≤E B′.
Proof: If B `E M:σ then, by Theorem 3.10, there is an A ∈ A(M) such that B `E A:σ. By
Lemma 6.2, there are B′,σ′ such that B′ `R A:σ′, σ′≤E σ and B≤E B′. Then, by Theorem 6.3,
B′ `R M:σ′.
In the construction of principal pairs for lambda terms, first, for any A ∈ N, a partic-
ular pair Pp(A) of basis P and type pi is chosen, which will be called respectively the
principal basis scheme and principal type scheme of A. Principal pairs for the relevant, and the
essential system are defined by:
Definition 6.5 i) Let A∈N. Pp(A), the principal pair of A, is defined by:
a) Pp(⊥) = 〈∅,ω〉.
b) Pp(x) = 〈{x:ϕ}, ϕ〉.
c) If A 6=⊥, and Pp(A) = 〈P,pi〉, then:
1) If x occurs free in A, and x:σ∈ P, then Pp(λx.A) = 〈P\x,σ→pi〉.
2) Otherwise Pp(λx.A) = 〈P,ω→pi〉.
d) If for 1≤ i≤ n, Pp (Ai) = 〈Pi,pii〉 (disjoint in pairs), then
Pp(xA1· · ·An) = 〈Π{P1, . . . ,Pn,{x:pi1→·· ·→pin→ϕ}}, ϕ〉,
Theoretical Computer Science, 151(2):385-435, 1995 32
where ϕ is a type-variable that does not occur in Pp(Ai), for 1≤ i≤ n.
ii) P = {〈P,pi〉 | ∃ A∈N [Pp(A) = 〈P,pi〉]}.
The following result is almost immediate:
Lemma 6.6 If Pp(A) = 〈P,pi〉, then P `R A:pi and P `E A:pi.
Proof: Easy.
The notion of principal pairs for terms in N will be generalized to arbitrary lambda terms
in Definition 6.29.
The principal pairs in the systems as presented in [9], [34], and [4] are exactly the same.
Since the essential type assignment system is a sub-system of the BCD-system (in the sense
that if B `E M:σ, then also B `∩ M:σ, but not vice-versa), and it is a super-system for both the
strict and the restricted CDV-system, it not surprising that the principal pairs in the essential
system turn out to be exactly the same as the principal pairs in all the other systems.
6.2 Operations
Substitution is normally defined on types as the operation that replaces type-variables by
types, without restriction. The notion of substitution defined here replaces type-variables by
strict types only. Although this is a severe restriction with regard to the usual approach, the
operation will proven to be sufficient.
Definition 6.7 i) The substitution (ϕ 7→α) : TS → TS, where ϕ is a type-variable and α∈Ts,
is defined by:
a) (ϕ 7→α) (ϕ) = α.
b) (ϕ 7→α) (ϕ′) = ϕ′, if ϕ 6≡ ϕ′.
c) (ϕ 7→α) (σ→τ) = (ϕ 7→α) (σ)→ (ϕ 7→α) (τ).
d) (ϕ 7→α) (σ1∩· · ·∩σn) = (ϕ 7→α) (σ1) ∩· · ·∩ (ϕ 7→α) (σn).
ii) If Sub1 and Sub2 are substitutions, then so is Sub1◦Sub2,
where Sub1◦Sub2 (σ) = Sub1 (Sub2 (σ)).
iii) Sub (B) = {x:Sub (α) | x:α∈ B}.
iv) Sub (〈B,σ〉) = 〈Sub (B),Sub (σ)〉.
The operation of substitution is sound for the relevant system.
Theorem 6.8 If B `R A:σ, then for every substitution Sub: if Sub (〈B,σ〉) = 〈B′,σ′〉, then B′ `R A:σ′.
Proof: By straightforward induction on the definition of `R.
The following is needed in the proof of Theorem 6.27.
Lemma 6.9 Let τ∈Ts and Sub be a substitution such that Sub (τ) = τ′. Then:
i) If Sub (B∪ {x:σ}) = B′ ∪ {x:σ′}, then Sub (〈B,σ→τ〉) = 〈B′,σ′→τ′〉.
ii) If for every 1≤ i≤n, Sub (〈Bi,σi〉) = 〈B
′
i,σ
′
i 〉, then
Sub (〈Π{B1, . . . ,Bn,{x:σ1→·· ·→σn→τ}},τ〉) =
〈Π{B′1, . . . ,B
′
n,{x:σ
′
1→·· ·→σ
′
n→τ
′}},τ′〉.
Proof: Immediately by Definition 6.7.
The operation of expansion of types defined here corresponds to the notion of expansion
as defined in [34] and [4]. A difference between the notions of expansion as defined in [9]
and [34] is that in those papers a set of types involved in the expansion is created. As in [4],
Theoretical Computer Science, 151(2):385-435, 1995 33
here just type-variables are collected, so the definition of expansion presented here is less
complicated.
Definition 6.10 i) If B is a basis and σ ∈ TS, then T〈B,σ〉 is the set of all strict subtypes
occurring in the pair 〈B,σ〉.
ii) The last type-variable of a strict type is defined by:
a) The last type-variable of ϕ is ϕ.
b) The last type-variable of σ1∩· · ·∩σn→σ is the last type-variable of σ.
Definition 6.11 For every µ∈Ts, n≥ 2, basis B, and σ∈TS, the quadruple 〈µ,n,B,σ〉 deter-
mines an expansion Exp〈µ,n,B,σ〉 : TS → TS, that is constructed as follows.
i) The set of type-variables Vµ(〈B,σ〉) affected by Exp〈µ,n,B,σ〉 is constructed by:
a) If ϕ occurs in µ, then ϕ∈Vµ(〈B,σ〉).
b) If the last type-variable of τ∈T〈B,σ〉 is in Vµ(〈B,σ〉), then for all type-variables ϕ that
occur in τ: ϕ∈Vµ(〈B,σ〉).
ii) Suppose Vµ(〈B,σ〉) = {ϕ1, . . . , ϕm}. Choose m× n different type-variables ϕ
1
1, . . . , ϕ
n
1 , . . . ,
ϕ1m, . . . , ϕ
n
m, such that each ϕ
i
j does not occur in 〈B,σ〉, for 1≤ i≤ n and 1≤ j≤m. Let,
for 1≤ i≤ n, Subi be such that Subi (ϕj) = ϕ
i
j, for 1≤ j≤m.
iii) Exp〈µ,n,B,σ〉 (τ) is obtained by traversing τ top-down and replacing every subtype α by
Sub1 (α)∩· · ·∩Subn (α), if the last type-variable of α is in Vµ(〈B,σ〉), i.e.:
a) Exp〈µ,n,B,σ〉 (τ1∩· · ·∩τn) = Exp〈µ,n,B,σ〉 (τ1) ∩· · ·∩ Exp〈µ,n,B,σ〉 (τn).
b) If the last type-variable of τ is in Vµ(〈B,σ〉), then Exp〈µ,n,B,σ〉 (τ) = Sub1 (τ) ∩· · ·∩
Subn (τ).
c) Otherwise,
1) Exp〈µ,n,B,σ〉 (ρ→µ) = Exp〈µ,n,B,σ〉 (ρ) → Exp〈µ,n,B,σ〉 (µ).
2) Exp〈µ,n,B,σ〉 (ϕ) = ϕ.
iv) Exp〈µ,n,B,σ〉 (B
′) = {x:Exp〈µ,n,B,σ〉 (ρ) | x:ρ∈ B
′}.
v) Exp〈µ,n,B,σ〉 (〈B
′,σ′〉) = 〈Exp〈µ,n,B,σ〉 (B
′),Exp〈µ,n,B,σ〉 (σ
′)〉.
Instead of Exp〈µ,n,B,σ〉, the notation 〈µ,n,B,σ〉 will be used.
Example 6.12 Let µ be the type (ϕ1→ϕ2)→(ϕ3→ϕ1)→ϕ3→ϕ2, and Exp be the expansion
〈ϕ1, 2,∅,µ〉. Then Vϕ1 (〈∅,µ〉) = {ϕ1, ϕ3}, and
Exp (µ) = ((ϕ4∩ϕ5)→ϕ2)→((ϕ6→ϕ4)∩(ϕ7→ϕ5))→(ϕ6∩ϕ7)→ϕ2.
Notice that both 〈∅,µ〉 and Exp (〈∅,µ〉) are pairs for the term λxyz.x(yz) in `E:
y : ϕ3→ϕ1 z : ϕ3
yz : ϕ1x : ϕ1→ϕ2
x(yz) : ϕ2
λz.x(yz) : ϕ3→ϕ2
λyz.x(yz) : (ϕ3→ϕ1)→ϕ3→ϕ2
λxyz.x(yz) : (ϕ1→ϕ2)→(ϕ3→ϕ1)→ϕ3→ϕ2
Theoretical Computer Science, 151(2):385-435, 1995 34
y : (ϕ6→ϕ4)∩(ϕ7→ϕ5)
y : ϕ7→ϕ5
z : ϕ6∩ϕ7
z : ϕ7
yz : ϕ5
y : (ϕ6→ϕ4)∩(ϕ7→ϕ5)
y : ϕ6→ϕ4
z : ϕ6∩ϕ7
z : ϕ6
yz : ϕ4x : (ϕ4∩ϕ5)→ϕ2
x(yz) : ϕ2
λz.x(yz) : (ϕ6∩ϕ7)→ϕ2
λyz.x(yz) : ((ϕ6→ϕ4)∩(ϕ7→ϕ5))→(ϕ6∩ϕ7)→ϕ2
λxyz.x(yz) : ((ϕ4∩ϕ5)→ϕ2)→((ϕ6→ϕ4)∩(ϕ7→ϕ5))→(ϕ6∩ϕ7)→ϕ2
For an operation of expansion the following property holds:
Lemma 6.13 Let Exp = 〈µ,n,B,σ〉 be an expansion. Exp (τ) = τ1∩· · ·∩τn with for every 1≤ i≤ n,
τi is a trivial variant of τ, or Exp (τ)∈Ts.
Proof: Immediately by Definition 6.11.
The following lemmas are needed in the proofs of the following theorems. The first states
that if the last type-variable of the type in a pair is affected by an expansion, then all type-
variables in that pair are affected.
Lemma 6.14 Let B′ `R A:τ, where τ∈Ts with last type-variable ϕ, and 〈µ,n,B,σ〉 be an expansion
such that T〈B′,τ〉 ⊆ T〈B,σ〉. If ϕ∈Vµ(〈B,σ〉), then, for every type-variable ϕ
′ that occurs in 〈B′,τ〉,
ϕ′∈Vµ(〈B,σ〉).
Proof: By induction on the structure of elements of N.
i) A≡ x, then B′ = {x:τ}. Since the last type-variable of τ is in Vµ(〈B,σ〉), and
τ∈T〈{x:τ},τ〉 ⊆ T〈B,σ〉,
all type-variables that occur in τ are in Vµ(〈B,σ〉).
ii) A≡ λx.A′, then τ = α→β, and B′ ∪ {x:α} `R A
′:β (if α = ω, then B′ ∪ {x:α} = B′). Since
the last type-variable of α→β is the last type-variable of β, and
T〈B′∪{x:α},β〉 ⊆ T〈B′,α→β〉 ⊆ T〈B,σ〉,
by induction, all type-variables in 〈B′ ∪ {x:α},β〉 are in Vµ(〈B,σ〉). So all type-variables
in 〈B′,α→β〉 are in Vµ(〈B,σ〉).
iii) A≡ xA1· · ·Am. Then there are τ1, . . . ,τm, B1, . . . , Bm, such that for every 1 ≤ j ≤ m,
Bj `R Aj:τj, and B
′ = Π{B1, . . . ,Bm,{x:τ1→·· ·→τm→τ}}. Since the last type-variable of
τ is in Vµ(〈B,σ〉), and
τ1→·· ·→τm→τ∈T〈Π{B0,...,Bm,{x:τ1→···→τm→τ}},τ〉 ⊆ T〈B,σ〉,
every type-variable in τ1→·· ·→τm→τ is in Vµ(〈B,σ〉). If, for 1≤ j≤m, τj = τ
1
j ∩· · ·∩τ
k j
j ,
then, for every 1≤ l≤ kj, the last type-variable of τ
l
j is in Vµ(〈B,σ〉), and
T〈Bj,τlj 〉
⊆ T〈Π{B0,...,Bm,{x:τ1→···→τm→τ}},τ〉 ⊆ T〈B,σ〉,
so all type-variables in 〈Bj,τ
l
j 〉 are in Vµ(〈B,σ〉), for 1≤ j ≤ m, 1 ≤ l ≤ kj. So all type-
variables in 〈Π{B1, . . . ,Bm,{x:τ1→·· ·→τm→τ}},τ〉 are in Vµ(〈B,σ〉).
Lemma 6.15 Let B′ `R A:τ, where τ∈Ts, and Exp = 〈µ,n,B,σ〉 be an expansion such that T〈B′,τ〉 ⊆ T〈B,σ〉.
Then either there are B1, . . . ,Bn, τ1, . . . ,τn, such that
Exp (〈B′,τ〉) = 〈Π{B1, . . . ,Bn},τ1∩· · ·∩τn〉
Theoretical Computer Science, 151(2):385-435, 1995 35
and, for every 1≤ i≤n, 〈Bi,τi〉 is a trivial variant of 〈B
′,τ〉, or Exp (〈B′,τ〉) = 〈B′′,τ′〉, with τ′∈
Ts.
Proof: By Lemmas 6.13, and 6.14.
Notice that, in particular, this lemma holds for the case that 〈B′,τ〉 = 〈B,σ〉.
The following property is needed in the proofs for the fact that expansion is sound (Theo-
rem 6.17), and for completeness of chains of operations (Theorem 6.27).
Property 6.16 ([4]) Let Exp be an expansion, σ∈Ts such that the last type-variable of σ is not affected
by Exp, and Exp (σ) = σ′. Then:
i) Exp (〈B∪ {x:τ},σ〉) = 〈B′ ∪ {x:τ′},σ′〉, if and only if Exp (〈B,τ→σ〉) = 〈B′,τ′→σ′〉.
ii) Let Exp (〈Bi,σi〉) = 〈B
′
i ,σ
′
i 〉, for every 1≤ i≤n. Then
Exp (〈Π{B1, . . . ,Bn,{x:σ1→·· ·→σn→σ}},σ〉) =
〈Π{B′1, . . . ,B
′
n,{x:σ
′
1→·· ·→σ
′
n→σ
′}},σ′〉.
The following theorem states that expansion is sound for relevant type assignment.
Theorem 6.17 If B `R A:σ and Exp an expansion such that Exp(〈B,σ〉) = 〈B′,σ′〉, then B′ `R A:σ′.
Proof: By induction on the definition of `R , of which only the part σ ∈ Ts is shown. By
Lemma 6.15 either:
i) σ′ = σ1∩· · ·∩σm, B′ = Π{B1, . . . ,Bm}, and each 〈Bi,σi〉 is a trivial variant of 〈B,σ〉 and,
therefore, Bi `R A:σi. So, by rule (∩I), B
′ `R A:σ′.
or
ii) σ′ ∈ Ts. This part is proved by induction on the structure of elements of N. Notice that
the case that A≡⊥ need not be considered.
a) A≡ λx.A′, σ = α→β, and B∪ {x:α} `R A
′:β. Let σ′ = α′→β′. (Notice that, if α
= ω, by Definition 6.11, also α′ = ω). By Lemma 6.16.(i), Exp (〈B∪ {x:α},β〉) =
〈B′ ∪ {x:α′},β′〉, and, by induction, B′ ∪ {x:α′} `R A′:β′. Then also B′ `R λx.A′:α′→β′.
b) A≡ xA1· · ·An, with n ≥ 0, B = Π{B1, . . . ,Bn,{x:σ1→·· ·→σn→σ}}, and Bi `R Ai:σi,
for 1≤ i≤ n. Let, for 1≤ i≤ n, Exp (〈Bi,σi〉) = 〈B
′
i,σ
′
i 〉, then, by induction, for every
1≤ i≤ n, B′i `R Aj:σ
′
i . Then, by Lemma 6.16.(ii),
Exp (〈Π{B1, . . . ,Bm,{x:σ1→·· ·→σn→σ}},σ〉) =
〈Π{B′1, . . . ,B
′
m,{x:σ
′
1→·· ·→σ
′
n→σ
′}},σ′〉.
Then Π{B′1, . . . ,B
′
m,{x:σ
′
1→·· ·→σ
′
n→σ
′}} `R xA1· · ·Am:σ′.
The third operation on pairs defined in this section is the operation of covering. It is,
unlike the definition of lifting and rise, not defined on types, but directly on pairs, using the
relation ≺≺ defined on pairs. This relation is inspired by the relation @∼ on terms in N,
and the relation between the principal pairs of two terms that are in that relation (see also
Theorem 6.28).
Definition 6.18 The relation on pairs ≺≺ is defined by:
i) 〈B,σ〉≺≺ 〈∅,ω〉.
ii) ∀ 1≤ i≤ n (n ≥ 2) [〈Bi,σi〉≺≺ 〈B
′
i,σ
′
i 〉] ⇒
〈Π{B1, . . . ,Bn},σ1∩· · ·∩σn〉≺≺ 〈Π{B′1, . . . ,B
′
n},σ
′
1∩· · ·∩σ
′
n〉.
iii) 〈B∪ {x:ρ},µ〉≺≺ 〈B′ ∪ {x:ρ′},µ′〉 ⇒ 〈B,ρ→µ〉≺≺ 〈B′,ρ′→µ′〉.
iv) ∀ 1≤ i≤ n [〈Bi,σi〉≺≺ 〈B
′
i,σ
′
i 〉] ⇒
Theoretical Computer Science, 151(2):385-435, 1995 36
〈Π{B1, . . . ,Bn,{x:σ1→·· ·→σn→σ}},σ〉 ≺≺
〈Π{B′1, . . . ,B
′
n,{x:σ
′
1→·· ·→σ
′
n→σ}},σ〉.
Definition 6.19 A covering Cov is an operation denoted by a pair of pairs ≺〈B0,τ0〉, 〈B1,τ1〉
such that 〈B0,τ0〉≺≺ 〈B1,τ1〉, and is defined by:
Cov(〈B,σ〉) = 〈B1,τ1〉, if 〈B,σ〉 = 〈B0,τ0〉,
= 〈B,σ〉, otherwise.
As mentioned above, the operation of covering defined here is inspired by the relation @∼
on terms in N, and, in fact, is very close to a notion defined in [27]. In that paper principal
typings for the type assignment system as presented in [25] are studied. That system is a
combination of the BCD-system and the polymorphic type discipline as presented in [20],
and can be seen as an extension of the BCD-system by adding quantification over type-
variables.
In [27], for every A in λ⊥-normal form a relation ⊆A is defined on the inductively defined
set of pairs 〈B,σ〉 admissible for A (i.e. such that B ` A:σ). This relation satisfies:
If 〈B1,σ1〉 ⊆A 〈B2,σ2〉, then both pairs are admissible for A.
It is, for example, straightforward to show that 〈B1,σ1〉 ⊆A 〈B2,σ2〉, when restricted to `E ,
implies 〈B1,σ1〉 ≺≺ 〈B2,σ2〉. Notice that the structure of a term A is present in the relation
⊆A , but absent in ≺≺ , although of course Definition 6.18 follows in part the syntactic
structure of terms in N (part (iii) and (iv)).
The operation of covering is not sound for `E.
Example 6.20 It is easy to check that 〈{x:α∩(α→α)},α〉≺≺〈{x:ω→α},α〉. Notice that {x:α∩(α→α)} `E x:α
is derivable, but not {x:ω→α} `E x:α.
The operation of covering is sound for the relevant system.
Theorem 6.21 For every covering ≺〈B,σ〉, 〈B′,σ′〉, if B `R A:σ, then B′ `R A:σ′.
Proof: By induction on the structure of types.
i) σ′ = ω, B′ = ∅. Trivial.
ii) σ′ = σ′1∩· · ·∩σ
′
n, n ≥ 2. Then B = Π{B1, . . . ,Bn}, σ = σ1∩· · ·∩σn, and, for every 1 ≤
i ≤ n, Bi `R A:σi. By Definition 6.18.(ii), B
′ = Π{B′1, . . . ,B
′
n}, and, for every 1 ≤ i ≤ n,
≺〈Bi,σi〉, 〈B
′
i ,σ
′
i 〉 is a covering. Then, by induction, B
′
i `R A:σ
′
i , so also B
′ `R A:σ′1∩· · ·∩σ
′
n.
iii) σ′ ∈Ts. By induction on A.
a) A≡ λx.A′. If B `R λx.A′:σ, then σ = ρ→µ, B,x:ρ `R A′:µ, and σ′ = ρ′→µ′. Since
≺〈B,ρ→µ〉, 〈B′,ρ′→µ′〉 is a covering, by Definition 6.18.(iii), also ≺〈B∪ {x:ρ},µ〉, 〈B′ ∪ {x:ρ′},µ′〉
is a covering, so, by induction, B′,x:ρ′ `R A′:µ′, so B′ `R λx.A′:ρ′→µ′.
b) A≡ yA1· · ·An, with n ≥ 0. Since B `R yA1· · ·An:σ, there are B1, . . . , Bn, σ1, . . . ,σn,
such that B = Π{B1, . . . ,Bn,{x:σ1→·· ·→σn→σ}}, and Bi `R Ai:σi, for every 1≤ i≤n.
Then there are B′1, . . . ,B
′
n, σ
′
1, . . . ,σ
′
n, such that for every 1≤ i≤n, ≺〈Bi,σi〉, 〈B
′
i,σ
′
i 〉 is
a covering, and B′ = Π{B′1, . . . ,B
′
n,{x:σ
′
1→·· ·→σ
′
n→σ}}. Then by induction, for 1≤
i≤ n, B′i `R Ai:σ
′
i , so also
Π{B′1, . . . ,B
′
n,{x:σ
′
1→·· ·→σ
′
n→σ}} `R yA1· · ·An:σ.
The last operation needed in this paper is that of lifting, as first presented in [4]:
Definition 6.22 A lifting Lift is an operation denoted by a pair of pairs <〈B0,τ0〉,〈B1,τ1〉>
such that τ0≤E τ1 and B1≤E B0, and is defined by:
i) Lift (σ) = τ1, if σ = τ0; otherwise, Lift(σ) = σ.
Theoretical Computer Science, 151(2):385-435, 1995 37
ii) Lift (B) = B1, if B = B0; otherwise, Lift(B) = B.
iii) Lift (〈B,σ〉) = 〈Lift(B),Lift(σ)〉.
The operation of lifting is sound for essential type assignment.
Theorem 6.23 If B `E M:σ and <〈B,σ〉,〈B′,σ′〉> is a lifting, then
B′ `E M:σ′.
Proof: By definition 6.22, B′≤E B, and σ≤E σ′. The proof follows from Lemmas 2.5.(vii) and
2.6.
Notice that the definition of covering differs from that of lifting, in that <〈B0,τ0〉, 〈B1,τ1〉>
is a lifting only if B1≤E B0 and σ0≤E σ1. For a covering, this is normally not the case.
Example 6.24 Since by 6.18.(i) 〈{y:ϕ}, ϕ〉≺≺ 〈∅,ω〉,
by 6.18.(iv) also 〈{x:ϕ→ϕ′,y:ϕ}, ϕ′〉≺≺ 〈{x:ω→ϕ′}, ϕ′〉,
so by 6.18.(iii) 〈{x:ϕ→ϕ′}, ϕ→ϕ′〉≺≺ 〈{x:ω→ϕ′},ω→ϕ′〉,
and, again by 6.18.(iii), 〈∅, (ϕ→ϕ′)→ϕ→ϕ′〉≺≺ 〈∅, (ω→ϕ′)→ω→ϕ′〉,
but not (ϕ→ϕ′)→ϕ→ϕ′≤E (ω→ϕ
′)→ω→ϕ′, and neither (ω→ϕ′)→ω→ϕ′≤E (ϕ→ϕ
′)→ϕ→ϕ′.
6.3 Completeness of operations
In this subsection, completeness of the above specified operations will be proved, both for
the relevant as for the essential system. First the notion of chain of operations is introduced.
Definition 6.25 i) A chain is an object [O1, . . . ,On], where each Oi is an operation of ex-
pansion, covering, substitution, or lifting, and
[O1, . . . ,On] (〈B,σ〉) = On (· · ·(O1 (〈B,σ〉))· · ·).
ii) On chains the operation of concatenation is denoted by ∗ , and
[O1, . . . ,Oi] ∗ [Oi+1, . . . ,On] = [O1, . . . ,On].
iii) A relevant chain is a chain of expansions, concatenated with a chain consisting of at most
one substitution, and at most one covering, in that order.
iv) An essential chain is a relevant chain, concatenated with one operation of lifting.
The next theorem shows that for every suitable pair for a term A, there exists a chain such
that the result of the application of this chain to the principal pair of A produces the desired
pair. Part (i) of the Lemmas 6.9, and 6.16 are needed for the inductive step in case of
an abstraction term, part (iii.b) of the proof, part (ii) of those lemmas are needed for the
inductive step in case of an application term, part (iii.c). Notice that, by construction, all
operations mentioned in that part satisfy the conditions required by these lemmas.
Theorem 6.26 If B `R A:σ and Pp(A) = 〈P,pi〉, then there exists a relevant chain C such that
C (〈P,pi〉) = 〈B,σ〉.
Proof: By induction on the definition of `R.
i) ∅ `R A:ω. Take Cov = ≺〈P,pi〉, 〈∅,ω〉, which, by Definition 6.19.(i), is a covering. Take
C = [Cov].
ii) B `R A:σ1∩· · ·∩σn. Then there are B1, . . . ,Bn such that for 1≤ i≤ n, Bi `R A:σi, and B =
Π{B1, . . . ,Bn}. Let Exp = 〈pi,n,P,pi〉, then
Exp (〈P,pi〉) = 〈Π{P1, . . . ,Pn},pi1∩· · ·∩pin〉,
Theoretical Computer Science, 151(2):385-435, 1995 38
with Pp(A) = 〈Pi,pii〉. By induction, there exist relevant chains C1, . . . , Cn such that for
1≤ i≤ n, Ci (〈Pi,pii〉) = 〈Bi,τi〉. Let, for 1≤ i≤ n, Ci = Exp
→
i ∗ [Subi] ∗ [Covi], and B
′
i ,τ
′
i be
such that
Exp
→
i ∗ [Subi] (〈Pi,pii〉) = 〈B
′
i,τ
′
i 〉, and Covi = ≺〈B
′
i ,τ
′
i 〉, 〈Bi,τi〉.
Then, by Definition 6.18.(ii),
Cov = ≺〈Π{B′1, . . . ,B
′
n},τ
′
1∩· · ·∩τ
′
n〉, 〈Π{B1, . . . ,Bn},τ1∩· · ·∩τn〉
is a covering. Take
C = [Exp] ∗Exp
→
1 ∗ · · · ∗Exp
→
n ∗ [Sub1 ◦ · · · ◦ Subn] ∗ [Cov].
iii) B `R A:σ, so σ∈ Ts. This part is proved by induction on the structure of elements of N.
Notice that the case that A≡⊥ need not be considered.
a) A≡ x. Then B = {x:σ}, P = {x:ϕ}, and pi = ϕ. Take
C = [(ϕ 7→ σ)].
b) A≡λx.A′.
1) x∈ FV(A′). Then there are α,β such that σ = α→β, B,x:α `R A′:β, and Pp(λx.A′)
= 〈P,µ→pi〉, where Pp(A′) = 〈P∪ {x:µ},pi〉. By induction there exists a relevant
chain C′ = Exp
→
∗ [Sub] ∗ [Cov’] such that
C′ (〈P∪ {x:µ},pi〉) = 〈B∪ {x:α},β〉.
Let α′,β′,B′ be such that
Exp
→
∗ [Sub] (〈P∪ {x:µ},pi〉) = 〈B′ ∪ {x:α′},β′〉,
and
Cov′ = ≺〈B′ ∪ {x:α′},β′〉, 〈B∪ {x:α},β〉.
Since β ∈ Ts, by construction also β′ ∈ Ts and, by Lemmas 6.16.(i) and 6.9.(i),
Exp
→
∗ [Sub] (〈P,µ→pi〉) = 〈B′,α′→β′〉. Take
Cov = ≺〈B′,α′→β′〉, 〈B,α→β〉,
which, by Definition 6.18.(iii), is a covering. Take
C = Exp
→
∗ [Sub] ∗ [Cov].
2) x 6∈ FV(A′). Then there is β such that σ = ω→β, and B `R A′:β. Then Pp(λx.A′)
= 〈P,ω→pi〉, where Pp(A′) = 〈P,pi〉. By induction there exists a relevant chain C′
= Exp
→
∗ [Sub] ∗ [Cov’] such that
C′ (〈P,pi〉) = 〈B,β〉.
Let B′,β′ be such that
Exp
→
∗ [Sub] (〈P,pi〉) = 〈B′,β′〉, and Cov′ = ≺〈B′,β′〉, 〈B,β〉.
Since β ∈ Ts, by construction also β′ ∈ Ts and, by Lemma 6.16.(i), and 6.9.(i),
Exp
→
∗ [Sub] (〈P,ω→pi〉) = 〈B′,ω→β′〉. Take
Cov = ≺〈B′,ω→β′〉, 〈B,ω→β〉,
which, by Definition 6.18.(iii), is a covering. Take
C = Exp
→
∗ [Sub] ∗ [Cov].
c) A≡xA1· · ·Am. Then there are σ1, . . . ,σm, B1, . . . , Bm, such that B = Π{B1, . . . ,Bm,{x:σ1→·· ·→σm→σ}},
and, for every 1≤ j≤m, Bj `R Aj:σj, and
P = Π{P1, . . . ,Pm,{x:pi1→·· ·→pim→ϕ}}, pi = ϕ,
Theoretical Computer Science, 151(2):385-435, 1995 39
with for every 1≤ j≤m, Pp(Aj) = 〈Pj,pij〉, in which ϕ does not occur. By induction,
there are relevant chains C1, . . . , Cm such that, for 1≤ j≤m, Cj (〈Pj,pij〉) = 〈Bj,σj〉.
Let, for 1≤ j≤m, Cj = Exp
→
j ∗ [Subj] ∗ [Covj], and B
′
j,σ
′
j be such that
Exp
→
j ∗ [Subj] (〈Pj,pij〉) = 〈B
′
j,σ
′
j 〉,
and
Covj = ≺〈B
′
j,σ
′
j 〉, 〈Bj,σj〉.
Let Exp
→
= Exp
→
1 ∗ · · · ∗Exp
→
m, and Sub = Sub1◦· · ·◦Subm◦(ϕ 7→ σ), then, because of Lem-
mas 6.16.(ii) and 6.9.(ii):
Exp
→
∗ [Sub] (〈Π{P1, . . . ,Pm,{x:pi1→·· ·→pim→ϕ}}, ϕ〉) =
〈Π{B′1, . . . ,B
′
m,{x:σ
′
1→·· ·→σ
′
m→σ}},σ〉.
Then, by Definition 6.18.(iv),
Cov = ≺〈Π{B′1, . . . ,B
′
m,{x:σ
′
1→·· ·→σ
′
m→σ}},σ〉,
〈Π{B1, . . . ,Bm,{x:σ1→·· ·→σm→σ}},σ〉,
is a covering. Take
C = Exp
→
∗ [Sub] ∗ [Cov].
Now, for essential type assignment the completeness of the here specified operations be-
comes easy to prove:
Theorem 6.27 If B `E A:σ and Pp(A) = 〈P,pi〉, then there exists an essential chain C such that
C (〈P,pi〉) = 〈B,σ〉.
Proof: By Lemma 6.2 there are B′,σ′ such that B′ `R A:σ, σ′ ≤E σ, and B ≤E B′. By The-
orem 6.26, there exists a relevant chain C such that such that C (〈P,pi〉) = 〈B′,σ′〉. Since
<〈B′,σ′〉,〈B,σ〉> is a lifting, by Definition 6.25.(iv), there exists an essential chain such that
C (〈P,pi〉) = 〈B,σ〉.
Like in [9, 34, 4], it can be proved that there exists a precise relation between terms in N
and principal pairs, both equipped with an appropriate ordering. This relation is in [34]
defined using substitution of type-variables by the type constant ω. Using the notion of
substitution defined here, this approach cannot be taken; instead, the relation ≺≺ on pairs
as given in Definition 6.18 is used.
Theorem 6.28 〈P ,〉 is a meet semilattice isomorphic to 〈N, @∼ 〉.
Proof: Pp is, as function from N to P , by Definition 6.5.(ii), surjective. It is injective because
of Theorems 4.9, 4.11, and 6.27. That Pp respects the order, i.e. if A@∼ A
′, then Pp(A′) ≺≺
Pp(A), follows by straightforward induction.
Definition 6.29 (cf. [34, 4]) i) Let M be a term. Let Π(M) be the set of all principal pairs
for all approximants of M:
Π(M) = {Pp (A) | A∈A(M)}.
ii) Π(M) is an ideal in P , and therefore:
a) If Π(M) is finite, then there exists a pair 〈P,pi〉 =
⊔
Π(M), where 〈P,pi〉 ∈ P . This
pair is then called the principal pair of M.
b) If Π(M) is infinite,
⊔
Π(M) does not exist in P . The principal pair of M is then the
infinite set of pairs Π(M).
The proof of the principal type property for the essential system is completed by the
following:
Theoretical Computer Science, 151(2):385-435, 1995 40
Theorem 6.30 Let B and σ be such that B `E M:σ.
i) A(M) is finite. Let 〈P,pi〉 be the principal pair of M. Then there exists an essential chain C such
that C (〈P,pi〉) = 〈B,σ〉.
ii) A(M) is infinite. Then there exist a pair 〈P,pi〉 ∈ Π(M) and an essential chain C such that
C (〈P,pi〉) = 〈B,σ〉.
Proof: From B `E M:σ and Theorem 3.10 follows ∃ A∈A(M) [B `E A:σ]. Then:
i) By Definition 6.29, there exists AM ∈A(M) such that Pp(M) = Pp(AM) = 〈P,pi〉. Since
Pp(AM) is minimal in P , so Pp(AM) ≺≺ Pp(A), by Theorem 6.28, AM is maximal in
A(M), so A@∼ AM. Then, by Lemma 2.5.(viii), also B `E AM:σ.
ii) By Definition 6.29, 〈P,pi〉 = Pp(A)∈Π(M).
In any case, by Theorem 6.27, there exists an essential chain such that C (〈P,pi〉) = 〈B,σ〉.
The same result, using relevant chains rather than essential chains, can be formulated for
the relevant system.
Conclusions
This paper presented the essential intersection type assignment system, as a true restriction
of the BCD-system that satisfies all properties of that system, where derivations are syntax-
directed. Since all properties of the BCD-system are shown to hold for the essential system,
the treatment of intersection types as in [6] has been too general. Instead of introducing ∩
as a general type-constructor, and ω as a type-constant, it is better to treat ω as the empty
intersection, and to allow intersections only on the left of the→.
References
[1] S. van Bakel. Complete restrictions of the Intersection Type Discipline. Theoretical Computer
Science, 102:135–163, 1992.
[2] S. van Bakel. Partial Intersection Type Assignment of Rank 2 in Applicative Term Rewriting
Systems. Technical Report 92-03, Department of Computer Science, University of Nijmegen,
1992.
[3] S. van Bakel. Essential Intersection Type Assignment. In R.K. Shyamasunda, editor, Proceedings
of FST&TCS ’93. 13th Conference on Foundations of Software Technology and Theoretical Computer
Science, Bombay, India, volume 761 of Lecture Notes in Computer Science, pages 13–23. Springer-
Verlag, 1993.
[4] S. van Bakel. Principal type schemes for the Strict Type Assignment System. Logic and Computa-
tion, 3(6):643–670, 1993.
[5] H. Barendregt. The Lambda Calculus: its Syntax and Semantics. North-Holland, Amsterdam, re-
vised edition, 1984.
[6] H. Barendregt, M. Coppo, and M. Dezani-Ciancaglini. A filter lambda model and the complete-
ness of type assignment. Journal of Symbolic Logic, 48(4):931–940, 1983.
[7] M. Coppo and M. Dezani-Ciancaglini. An Extension of the Basic Functionality Theory for the
λ-Calculus. Notre Dame, Journal of Formal Logic, 21(4):685–693, 1980.
[8] M. Coppo, M. Dezani-Ciancaglini, F. Honsell, and G. Longo. Extended type structures and filter
lambda models. In G. Lolli, G. Longo, and A. Marcja, editors, Logic Colloquium 82, pages 241–262,
Amsterdam, the Netherlands, 1984. North-Holland.
[9] M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. Principal type schemes and λ-calculus se-
mantics. In J.R. Hindley and J.P. Seldin, editors, To H.B. Curry, Essays in combinatory logic, lambda-
calculus and formalism, pages 535–560. Academic press, New York, 1980.
[10] M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. Functional characters of solvable terms.
Zeitschrift fu¨r Mathematische Logik und Grundlagen der Mathematik, 27:45–58, 1981.
Theoretical Computer Science, 151(2):385-435, 1995 41
[11] M. Coppo, M. Dezani-Ciancaglini, and M. Zacchi. Type Theories, Normal Forms and D∞-
Lambda-Models. Information and Computation, 72(2):85–116, 1987.
[12] M. Coppo and P. Giannini. A complete type inference algorithm for simple intersection types. In
J.-C. Raoult, editor, Proceedings of CAAP ’92. 17th Colloquim on Trees in Algebra and Programming,
Rennes, France, volume 581 of Lecture Notes in Computer Science, pages 102–123. Springer-Verlag,
1992.
[13] H.B. Curry. Functionality in combinatory logic. In Proc. Nat. Acad. Sci. U.S.A., volume 20, pages
584–590, 1934.
[14] H.B. Curry and R. Feys. Combinatory Logic, volume 1. North-Holland, Amsterdam, 1958.
[15] F. Damiani and P. Giannini. A Decidable Intersection Type System based on Relevance. In
M. Hagiya and J.C. Mitchell, editors, Proceedings of TACS ’94. International Symposium on Theoret-
ical Aspects of Computer Software, Sendai, Japan, volume 789 of Lecture Notes in Computer Science,
pages 707–725. Springer-Verlag, 1994.
[16] M. Dezani-Ciancaglini and I. Margaria. F-semantics for intersection type discipline. In G. R.
Kahn, D. B. Macqueen, and G. Plotkin, editors, Semantics of data types. International sympo-
sium, Sophia-Antipolis, France, volume 173 of Lecture Notes in Computer Science, pages 279–300.
Springer-Verlag, 1984.
[17] M. Dezani-Ciancaglini and I. Margaria. A characterisation of F-complete type assignments. The-
oretical Computer Science, 45:121–157, 1986.
[18] E. Engeler. Algebras and combinators. Algebra universalis, 13(3):389–392, 1981.
[19] P. Gardner. Discovering Needed Reductions Using Type Theory. In M. Hagiya and J.C. Mitchell,
editors, Proceedings of TACS ’94. International Symposium on Theoretical Aspects of Computer Software,
Sendai, Japan, volume 789 of Lecture Notes in Computer Science, pages 555–597. Springer-Verlag,
1994.
[20] J.Y. Girard. The System F of Variable Types, Fifteen years later. Theoretical Computer Science,
45:159–192, 1986.
[21] J.R. Hindley. The principal type scheme of an object in combinatory logic. Transactions of the
American Mathematical Society, 146:29–60, 1969.
[22] J.R. Hindley. The simple semantics for Coppo-Dezani-Salle´ type assignment. In M. Dezani and
U. Montanari, editors, International symposium on programming, volume 137 of Lecture Notes in
Computer Science, pages 212–226. Springer-Verlag, 1982.
[23] J.R. Hindley. The Completeness Theorem for Typing λ-terms. Theoretical Computer Science,
22(1):1–17, 1983.
[24] R. Hindley and G. Longo. Lambda calculus models and extensionality. Zeitschrift fu¨r Mathema-
tische Logik und Grundlagen der Mathematik, 26:289–310, 1980.
[25] B. Jacobs, I. Margaria, andM. Zacchi. Filter Models with Polymorphic Types. Theoretical Computer
Science, 95:143–158, 1992.
[26] D. Leivant. Polymorphic Type Inference. In Proceedings 10th ACM Symposium on Principles of
Programming Languages, Austin Texas, pages 88–98, 1983.
[27] I. Margaria and M. Zacchi. Principal Typing in a ∀∩-Discipline. Logic and Computation. To appear.
[28] R. Milner. A theory of type polymorphism in programming. Journal of Computer and System
Sciences, 17:348–375, 1978.
[29] J.C. Mitchell. Polymorphic Type Inference and Containment. Information and Computation,
76:211–249, 1988.
[30] B.C. Pierce. Programming with Intersection Types and Bounded Polymorphism. PhD thesis, Carnegie
Mellon University, School of Computer Science, Pitssburgh, 1991. CMU-CS-91-205.
[31] B.C. Pierce. Intersection Types and Bounded Polymorphism. In M. Bezem and J.F. Groote,
editors, Proceedings of TLCA ’93. International Conference on Typed Lambda Calculi and Applica-
tions, Utrecht, the Netherlands, volume 664 of Lecture Notes in Computer Science, pages 346–360.
Springer-Verlag, 1993.
[32] J.C. Reynolds. The essence of Algol. In J.W. de Bakker and J.C. van Vliet, editors, Algorithmic
languages, pages 345–372. North-Holland, 1981.
[33] J.C. Reynolds. Preliminary design of the programming language Forsythe. Technical Report
CMU-CS-88-159, Carnegie Mellon University, Pitssburgh, 1988.
[34] S. Ronchi della Rocca and B. Venneri. Principal type schemes for an extended type theory.
Theoretical Computer Science, 28:151–169, 1984.
Theoretical Computer Science, 151(2):385-435, 1995 42
[35] P. Salle´. Une extension de la the´orie des types. In G. Ausiello and C. Bo¨hm, editors, Automata,
languages and programming. Fifth Colloquium, Udine, Italy, volume 62 of Lecture Notes in Computer
Science, pages 398–410, Udine, Italy, 1978. Springer-Verlag.
[36] W.W. Tait. Intensional interpretation of functional of finite types. Journal of Symbolic Logic, 32,
1967.
[37] C.P. Wadsworth. The relation between computational and denotational properties for Scott’s
D∞-models of the lambda-calculus. SIAM J. Comput., 5:488–521, 1976.
