UNIVERSIDADE DE BRASI´LIA
INSTITUTO DE CIEˆNCIAS EXATAS
DEPARTAMENTO DE MATEMA´TICA
Formalizac¸a˜o da Prova do Teorema de Existeˆncia de
Unificadores Mais Gerais em Teorias de
Primeira-Ordem
Por
Andre´ia Borges Avelar
Bras´ılia
2009
UNIVERSIDADE DE BRASI´LIA
INSTITUTO DE CIEˆNCIAS EXATAS
DEPARTAMENTO DE MATEMA´TICA
Formalizac¸a˜o da Prova do Teorema de Existeˆncia de
Unificadores Mais Gerais em Teorias de
Primeira-Ordem
Por
Andre´ia Borges Avelar1
Orientador: Prof. Dr. Mauricio Ayala Rinco´n
Coorientador: Prof. Dr. Andre´ Luiz Galdino
1O autor contou com o apoio financeiro do CNPq.
A He´lio, Ante´ria e Elaine.
A Sabedoria e´ mais mo´vel que qualquer movimento
e, por sua pureza, tudo atravessa e penetra.
As virtudes sa˜o seus frutos;
ela ensina a temperanc¸a e a prudeˆncia,
a justic¸a e a fortaleza,
que sa˜o, na vida, os bens mais u´teis aos homens.
Sb 7,24; 8,7b
Agradecimentos
Agradec¸o a Deus por ter me concedido forc¸as para concluir este trabalho, consolo nos momentos
dif´ıceis, coragem e equil´ıbrio para vencer os obsta´culos.
Agradec¸o a` minha famı´lia, toda a compreensa˜o e apoio, que sem du´vida foram fundamentais
para a conclusa˜o deste trabalho.
Agradec¸o de maneira especial ao meu orientador, Prof. Mauricio Ayala Rinco´n, por que foi
paciente, me concedeu um voto de confianc¸a, foi um excelente orientador e amigo.
Agradec¸o ao meu coorientador, Prof. Andre´ Luiz Galdino, a grande ajuda durante a reali-
zac¸a˜o deste trabalho e as valiosas dicas.
Agradec¸o os Profs. Fla´vio e Ma´rio Benevides, as valiosas sugesto˜es durante a correc¸a˜o deste
trabalho.
Agradec¸o ao Prof. Ce´lius, as conversas animadoras e por muitas vezes ter sido um amigo
que soube ouvir.
Agradec¸o a Prof. Ca´tia, porque tambe´m acreditou que eu seria capaz de concluir este trabalho
e me deu o seu apoio.
Agradec¸o ao amigo Martins e a` amiga Luciene, que me concederam um apoio importante
nos momentos mais dif´ıceis.
Aos amigos Joa˜o Marcelo e Joa˜o Vı´tor, a companhia e incentivo durante os estudos para o
exame de qualificac¸a˜o.
Agradec¸o ao amigo Vagner e a` amiga Fla´via, o apoio, as conversas descontra´ıdas e a com-
panhia ta˜o agrada´vel que tornou os estudos das mate´rias que fizemos juntos muito mais fa´ceis.
Agradec¸o ao amigo Wagner, porque sempre acreditou que eu concluiria este trabalho e foi
um grande incentivador.
Agradec¸o a` amiga Thaynara, a companhia ta˜o alegre que foi muito motivadora nos momentos
conclusivos deste trabalho.
Aos amigos Daniel, Daniele, Leonardo, Fa´bio, Ana Cristina e Kaliana, que tame´m estiveram
presentes nos u´ltimos meses e com os quais passei momentos muito agrada´veis.
Por fim, agradec¸o a todos os amigos, professores e funciona´rios do Departamento de Mate-
ma´tica da UnB, que de alguma forma contribu´ıram para a finalizac¸a˜o deste trabalho.
Resumo
Neste trabalho apresenta-se uma formalizac¸a˜o do teorema de existeˆncia de unificadores
mais gerais em teorias de primeira ordem. Tal formalizac¸a˜o foi desenvolvida na linguagem
de especificac¸a˜o de ordem superior, do assistente de prova PVS. A prova mecaˆnica e´ muito
semelhante a`s provas encontradas em livros-texto, as quais se baseiam na correc¸a˜o do ja´
conhecido algoritmo de unificac¸a˜o de Robinson de primeira ordem. A prova do teorema foi
aplicada dentro de uma teoria completa, desenvolvida em PVS, para sistemas de reescrita
de termos, a fim de obter uma formalizac¸a˜o completa do Teorema dos Pares Cr´ıticos de
Knuth-Bendix. Para chegar a esta formalizac¸a˜o foi constru´ıda uma especificac¸a˜o em PVS
de uma teoria para unificac¸a˜o de primeira ordem, onde foram formalizadas as propriedades
de generalidade e terminac¸a˜o de uma versa˜o do algoritmo de unificac¸a˜o de Robinson
restrito a termos unifica´veis.
Palavras-chave: Verificac¸a˜o formal, unificac¸a˜o de primeira ordem, unificador mais geral,
PVS.
vi
Abstract
This work presents the formalization of the theorem of existence of most general unifiers
in first-order theories. The formalization was developed in the higher-order specification
language, of the proof assistant PVS. The mechanical proof is very similar to that found
in textbooks, which are based on proving the correction of the well-known Robinson’s
first-order unification algorithm. The proof of the theorem was applied within a complete
theory, also developed in PVS, for term rewriting systems in order to obtain the full
formalization of the Knuth-Bendix Critical Pair theorem. To reach this formalization, it
was build in PVS a specification of a theory for first-order unification, where properties of
generality and termination of a version of the Robinson’s unification algorithm restricted
to unifiable terms were formalized.
Keywords: Formal verification, first-order unification, most general unifier, PVS.
vii
Lista de Tabelas
4.2.1 Construtor resolving_diff . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
4.2.2 Construtor sub_of_frst_diff . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
4.2.3 Construtor unification_algorithm . . . . . . . . . . . . . . . . . . . . . . . . 47
4.2.4 Lemas sobre resolving_diff . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
4.2.5 Lemas sobre sub_of_frst_diff . . . . . . . . . . . . . . . . . . . . . . . . . . 50
4.2.6 Principais lemas sobre sub_of_frst_diff . . . . . . . . . . . . . . . . . . . . . . 51
4.2.7 Lemas sobre unification_algorithm . . . . . . . . . . . . . . . . . . . . . . . . 52
5.0.1 Ana´lise Quantitativa da sub-teoria unification . . . . . . . . . . . . . . . . . . . 93
viii
Lista de Figuras
2.2.1 Algoritmo de unificac¸a˜o de Robinson . . . . . . . . . . . . . . . . . . . . . . . . 14
2.2.2 Versa˜o do algoritmo de unificac¸a˜o de Robinson . . . . . . . . . . . . . . . . . . . . 15
4.1.1 Estrutura hiera´rquica da sub-teoria unification . . . . . . . . . . . . . . . . . . 44
4.3.1 A´rvore de prova do teorema unification. . . . . . . . . . . . . . . . . . . . . . . 54
4.4.1 In´ıcio da a´rvore de prova do lema unification_algorithm_gives_unifier . . . . . . 58
4.4.2 Ramo principal da a´rvore de prova do lema unification_algorithm_gives_unifier . 60
4.4.3 In´ıcio da a´rvore de prova do lema unification_algorithm_gives_mg_subs . . . . . . 65
4.4.4 Parte da a´rvore de prova do lema unification_algorithm_gives_mg_subs . . . . . . 67
4.4.5 Parte da a´rvore de prova do lema unification_algorithm_gives_mg_subs . . . . . . 72
4.5.1 In´ıcio da a´rvore de prova do lema vars_ext_sub_of_frst_diff_decrease . . . . . . 76
4.5.2 Parte da a´rvore de prova do lema vars_ext_sub_of_frst_diff_decrease . . . . . . 78
4.5.3 Parte da a´rvore de prova do lema vars_ext_sub_of_frst_diff_decrease . . . . . . 80
4.5.4 In´ıcio da a´rvore de prova do lema sub_of_frst_diff_unifier_o . . . . . . . . . . . 82
4.5.5 Parte final da a´rvore de prova do lema sub_of_frst_diff_unifier_o . . . . . . . . 85
4.5.6 Parte final da a´rvore de prova do lema sub_of_frst_diff_unifier_o . . . . . . . . 88
ix
I´ndice
Resumo vi
Abstract vii
Lista de Tabelas viii
Lista de Figuras ix
1 Introduc¸a˜o 1
1.1 Motivac¸a˜o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 Organizac¸a˜o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
2 Unificac¸a˜o de Primeira Ordem 4
2.1 Unificac¸a˜o: Visa˜o Informal do Problema, Histo´ria e Aplicac¸o˜es . . . . . . . . . . 4
2.1.1 Visa˜o Informal do Problema de Unificac¸a˜o . . . . . . . . . . . . . . . . . . 4
2.1.2 Histo´ria e Aplicac¸o˜es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
2.2 O Problema de Unificac¸a˜o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.2.1 Assinaturas, Termos e Substituic¸o˜es . . . . . . . . . . . . . . . . . . . . . 8
2.2.2 O Problema de Unificac¸a˜o e as Substituic¸o˜es mais Gerais . . . . . . . . . 12
2.2.3 O Algoritmo de Unificac¸a˜o . . . . . . . . . . . . . . . . . . . . . . . . . . 14
x
xi
3 Semaˆntica do PVS 26
3.1 A Linguagem de Especificac¸a˜o do PVS . . . . . . . . . . . . . . . . . . . . . . . . 26
3.2 O Assistente de Provas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
3.3 A Checagem de Tipos em PVS . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
3.4 As Regras de Prova do PVS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
3.4.1 Regras Estruturais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
3.4.2 Regra de Corte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.4.3 Regras para Axiomas Proposicionais . . . . . . . . . . . . . . . . . . . . . 33
3.4.4 Regras de Contexto . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.4.5 Regras Condicionais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.4.6 Regras de Igualdade . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
3.4.7 Regras de Igualdade Booleana . . . . . . . . . . . . . . . . . . . . . . . . 35
3.4.8 Regras de Reduc¸a˜o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
3.4.9 Regras de Extensionalidade . . . . . . . . . . . . . . . . . . . . . . . . . . 36
3.4.10 Regra de Restric¸a˜o de Tipo . . . . . . . . . . . . . . . . . . . . . . . . . . 36
3.5 Sub-teorias da Teoria TRS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
3.5.1 A Sub-teoria term . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
3.5.2 A Sub-teoria positions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
3.5.3 A Sub-teoria subterm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
3.5.4 A Sub-teoria substitution . . . . . . . . . . . . . . . . . . . . . . . . . . 41
4 Formalizac¸a˜o da Teoria de Unificac¸a˜o 43
4.1 Estrutura Hiera´rquica da Teoria unification . . . . . . . . . . . . . . . . . . . . 43
4.2 Organizac¸a˜o da Teoria unification . . . . . . . . . . . . . . . . . . . . . . . . . 44
4.3 Formalizac¸a˜o do Teorema Sobre a Existeˆncia de mgu’s . . . . . . . . . . . . . . . 53
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm . . . . . . 57
4.4.1 Lema unification_algorithm_gives_unifier . . . . . . . . . . . . . . 58
4.4.2 Lema unification_algorithm_gives_mg_subs . . . . . . . . . . . . . . 65
xii
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff . . 74
4.5.1 Lema vars_ext_sub_of_frst_diff_decrease . . . . . . . . . . . . . . . 75
4.5.2 Lema sub_of_frst_diff_unifier_o . . . . . . . . . . . . . . . . . . . . 81
4.5.3 Lema ext_sub_of_frst_diff_unifiable . . . . . . . . . . . . . . . . . . 89
5 Conclusa˜o e Trabalhos Futuros 92
5.1 Trabalhos Relacionados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
5.2 Trabalhos Futuros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
A O Co´digo da Especificac¸a˜o 97
B Formalizac¸a˜o do lema sub_of_frst_diff_remove_x 103
Refereˆncias Bibliogra´ficas 113
Cap´ıtulo 1
Introduc¸a˜o
Neste trabalho apresentamos uma especificac¸a˜o no assistente de prova PVS, de uma ver-
sa˜o do algoritmo de unificac¸a˜o de Robinson, bem como a formalizac¸a˜o da correc¸a˜o deste
algoritmo. Como resultado da correc¸a˜o do algoritmo, formaliza-se um teorema que esta-
belece a existeˆncia de unificadores mais gerais para dois termos unifica´veis, em sistemas de
primeira ordem. Para este resultado, ja´ bem estabelecido em computac¸a˜o, encontramos
va´rias aplicac¸o˜es em lo´gica computacional, que va˜o deste a completude do princ´ıpio de
resoluc¸a˜o de primeira ordem [26] a` correc¸a˜o do procedimento de completac¸a˜o de Knuth-
Bendix [14] para sistemas de reescrita de termos, ale´m de aplicac¸o˜es em linguagens de
programac¸a˜o, como mecanismos de infereˆncia de tipos. Esta especificac¸a˜o/formalizac¸a˜o
consiste de um desenvolvimento de uma teoria em PVS a qual denominamos unification.
1.1 Motivac¸a˜o
O desenvolvimento de uma teoria em PVS para tratar da existeˆncia de unificadores mais
gerais foi motivado pela formalizac¸a˜o de uma biblioteca em PVS para sistemas de reescrita
de termos [8], a teoria trs, em que o resultado que estabelece a existeˆncia e unicidade de
unificadores mais gerais era tratado como um axioma.
A teoria trs foi desenvolvida com o objetivo de fornecer uma formalizac¸a˜o de conceitos
ba´sicos, atrave´s dos quais fosse poss´ıvel especificar e formalizar outros conceitos e resulta-
dos da teoria de sistemas de reescrita de termos. Contudo a teoria trs estava incompleta,
no sentido de que possuia um resultado na˜o formalizado. Assim, o objetivo inicial deste
1
1.2 Organizac¸a˜o 2
trabalho foi o de obter uma formalizac¸a˜o de um teorema que garantisse a existeˆncia de
unificadores mais gerais para termos de primeira ordem e com isto ter uma teoria em
PVS para sistemas de reescrita de termos completa. Com este objetivo foi realizado o
desenvolvimento da sub-teoria unification.
A teoria trs e´ composta por um conjunto de sub-teorias. Assim, para chegar a uma
formalizac¸a˜o do teorema que estabelece a existeˆncia de unificadores mais gerais a teoria
unification foi desenvolvida como uma sub-teoria da teoria trs. Isto significa que a
sub-teoria unification importa algumas sub-teorias da teoria trs, onde encontramos
especificac¸o˜es de conceitos ba´sicos, como por exemplo as definic¸o˜es de termos, posic¸o˜es,
substituic¸o˜es, etc., e a formalizac¸a˜o de va´rios resultados. Assim, nas teorias importadas
encontramos uma base teo´rica completa para o desenvolvimento de uma teoria sobre
unificac¸a˜o.
1.2 Organizac¸a˜o
No decorrer desta apresentac¸a˜o quando usamos a palavra teoria ou sub-teoria em ita´lico,
estamos nos referindo a` especificac¸a˜o de uma teoria desenvolvida no assistente de prova
PVS, e quando usamos formalizac¸a˜o estamos nos referindo a` prova mecaˆnica feita em
PVS de algum resultado ou teorema.
No Cap´ıtulo 2 apresentamos a teoria de unificac¸a˜o de primeira ordem, que envolve
a introduc¸a˜o e definic¸a˜o de conceitos tratados em unificac¸a˜o como termos, substituic¸o˜es,
unificadores mais gerais, etc., ale´m de apresentarmos uma versa˜o do algoritmo de uni-
ficac¸a˜o de Robinson, para em seguida verificar analiticamente a correc¸a˜o e completude
deste algoritmo. No Cap´ıtulo 3 apresentamos uma visa˜o geral da semaˆntica do assistente
de prova PVS, e expomos as especificac¸o˜es, feitas anteriormente em PVS no trabalho de
Galdino e Ayala-Rinco´n [8], dos conceitos e definic¸o˜es apresentados no Cap´ıtulo 2. No
Cap´ıtulo 4 apresentamos a organizac¸a˜o da teoria unification, os principais aspectos da
especificac¸a˜o e a formalizac¸a˜o dos teoremas da teoria, que sa˜o aqueles onde verificamos a
correc¸a˜o do algoritmo de unificac¸a˜o e a existeˆncia de unificadores mais gerais para termos
unifica´veis, ale´m destes apresentamos a formalizac¸a˜o de alguns lemas importantes para a
1.2 Organizac¸a˜o 3
verificac¸a˜o da correc¸a˜o do algoritmo. Em seguida, apresentamos a conclusa˜o e trabalhos
futuros, ale´m de alguns trabalhos relacionados. No Apeˆndice A, apresentamos o co´digo da
especificac¸a˜o da sub-teoria unification, mas o seu desenvolvimento completo encontra-
se dispon´ıvel em http://ayala.mat.unb.br/publications.html, juntamente com a teoria
trs. No Apeˆndice B, apresentamos um exemplo de uma formalizac¸a˜o detalhada de um
dos lemas da sub-teoria unification.
Acreditamos que esta seja a primeira formalizac¸a˜o completa de uma teoria em PVS
para unificac¸a˜o de primeira ordem.
Cap´ıtulo 2
Unificac¸a˜o de Primeira Ordem
O problema de unificac¸a˜o tem sido estudado em va´rias a´reas da cieˆncia da computac¸a˜o,
incluindo deduc¸a˜o automa´tica, programac¸a˜o lo´gica, complexidade computacional, entre
outras. Neste cap´ıtulo apresentamos o conceito de unificac¸a˜o de uma maneira informal,
seguimos expondo um levantamento histo´rico e algumas aplicac¸o˜es mostrando onde o
problema de unificac¸a˜o foi originalmente introduzido, e enta˜o finalizamos apresentando o
problema de unificac¸a˜o de maneira formal.
2.1 Unificac¸a˜o: Visa˜o Informal do Problema, Histo´-
ria e Aplicac¸o˜es
2.1.1 Visa˜o Informal do Problema de Unificac¸a˜o
Unificac¸a˜o e´ um processo fundamental sobre o qual va´rios me´todos de deduc¸a˜o automa´-
tica sa˜o baseados. A teoria que envolve o problema de unificac¸a˜o surge da necessidade de
formalizar aplicac¸o˜es espec´ıficas deste processo. Esta teoria proveˆ definic¸o˜es para noc¸o˜es
importantes como instanciac¸a˜o, termos unifica´veis, unificadores mais gerais, etc., inves-
tiga propriedades destas noc¸o˜es, ale´m de buscar e analizar algoritmos de unificac¸a˜o que
podem ser utilizados em va´rios contextos.
Em muitas aplicac¸o˜es de unificac¸a˜o o interesse na˜o esta´ apenas em responder o pro-
blema de decisa˜o para unificac¸a˜o, isto e´, dizer“sim”ou“na˜o”para responder se dois termos
s e t sa˜o unifica´veis. Se estes dois termos sa˜o unificave´is, busca-se tambe´m uma soluc¸a˜o,
isto e´, uma substituic¸a˜o que torne estes dois termos ideˆnticos. Tal substituic¸a˜o e´ chamada
4
2.1 Unificac¸a˜o: Visa˜o Informal do Problema, Histo´ria e Aplicac¸o˜es 5
um unificador de s e t. Em geral um problema de unificac¸a˜o pode ter va´rias soluc¸o˜es, mas
felizmente nas va´rias aplicac¸o˜es de unificac¸a˜o, o interesse na˜o esta´ em encontrar todos os
unificadores para um determinado problema, mas sim em determinar um unificador mais
geral, isto e´, um unificador a partir do qual obtem-se todos os outros por instanciac¸a˜o.
Exemplo 2.1.1: Considere os termos f(x, y) e f(y, x). Note que estes dois termos podem
ser unificados substituindo-se x e y pelo mesmo termo s, e como existe uma infinidade de
termos poss´ıveis, temos que este problema possui infinitas soluc¸o˜es. Contudo a substitui-
c¸a˜o dada por θ := {x/y} e´ um unificador mais geral do problema, visto que para qualquer
termo s, temos que {x/s, y/s} = {y/s} ◦ θ.
Portanto, um algoritmo de unificac¸a˜o na˜o deve responder apenas se um dado problema
de unificac¸a˜o tem ou na˜o soluc¸a˜o, ale´m disso, se espera que o algoritmo compute um
unificador mais geral para o problema.
Ate´ este ponto falamos apenas de unificac¸a˜o sinta´tica de termos de primeira ordem,
isto significa que os termos devem ser sintaticamente iguais e que na˜o temos varia´veis de
segunda ordem, isto e´, varia´veis para func¸o˜es. Por exemplo, os termos f(x, y) e h(x, y) ob-
viamente na˜o podem ser sintaticamente iguais em unificac¸a˜o de primeira ordem, contudo
se H e´ uma varia´vel de segunda ordem, os termos f(x, y) e H(x, y) podem ser sintati-
camente iguais, via substituic¸o˜es, em unificac¸a˜o de segunda ordem. Mas neste trabalho
estamos interessados apenas em unificac¸a˜o de primeira ordem.
2.1.2 Histo´ria e Aplicac¸o˜es
Baseamos esta sec¸a˜o nos surveys de Knight [13] e de Baader e Snyder [3], que utilizamos
como fonte para as refereˆncias bibliogra´ficas que citamos.
Em 1930, Jacques Herbrand [10] apresentou em sua tese de doutorado um algoritmo
na˜o determin´ıstico para computar um unificador de dois termos. Mas foi em 1965, que o
nome unificac¸a˜o e a primeira investigac¸a˜o formal sobre o assunto aparecem no trabalho de
Robinson [26], que introduziu unificac¸a˜o como sendo a operac¸a˜o ba´sica para o seu princ´ıpio
de resoluc¸a˜o, mostrando que termos unifica´veis possuem um unificador mais geral; ale´m
de descrever um algoritmo, veja Figura 2.2.1, para computar tal unificador e provar que
2.1 Unificac¸a˜o: Visa˜o Informal do Problema, Histo´ria e Aplicac¸o˜es 6
este algoritmo de fato computa um unificador mais geral para um conjunto unifica´vel
de expresso˜es bem formadas. Em 1964, Jim Guard [9] estudava independentemente o
problema de unificac¸a˜o sob o nome de matching e cinco anos depois, em 1970, Reynolds
[25] discutiu termos de primeira ordem usando teoria de reticulado e mostrou que tambe´m
existe uma u´nica generalizac¸a˜o mais espec´ıfica de quaisquer dois termos unifica´veis. Em
1970, segundo Baader e Snyder [3], as noc¸o˜es de unificac¸a˜o e unificador mais geral foram
independentemente reinventadas por Knuth e Bendix [14] como uma ferramenta para
testar conflueˆncia local de sistemas de reescrita de termos atrave´s de pares cr´ıticos.
A versa˜o original do algoritmo de unificac¸a˜o de Robinson e´ ineficiente, pois e´ expo-
nencial em tempo de execuc¸a˜o e em espac¸o. Por isso surgiu um grande interesse em
obter algoritmos de unificac¸a˜o eficientes. O pro´prio Robinson passou a pesquisar sobre a
eficieˆncia na unificac¸a˜o, e argumentou em [27] que uma representac¸a˜o mais concisa para
os termos era necessa´ria. Com sua nova formulac¸a˜o, Robinson conseguiu uma grande
melhoria na complexidade de espac¸o exigida por seu algoritmo de unificac¸a˜o.
Assim, em pesquisas sobre complexidade computacional, surgem va´rios trabalhos em
busca de eficieˆncia no processo de unificac¸a˜o. Em 1972, Boyer e Moore [4] apresentam
um algoritmo de unificac¸a˜o que divide a estrutura dos termos, este algoritmo era eficiente
em espac¸o, mas ainda exponencial em tempo de execuc¸a˜o. Em 1975, Venturini-Zilli [31]
consegue reduzir a complexidade de tempo do algoritmo de unificac¸a˜o de Robinson para
tempo quadra´tico. Em 1976, no seu trabalho sobre unificac¸a˜o de ordem superior [11], Huet
apresenta um procedimento baseado em classes de equivaleˆncia de subtermos, que era
quase linear em tempo de execuc¸a˜o. Ainda em 1976, Paterson e Wegman [23], descobrem
um algoritmo de unificac¸a˜o realmente linear, baseado sobre um me´todo que consistia
na propagac¸a˜o da relac¸a˜o de classes de equivaleˆncia do algoritmo de Huet. Em 1976,
Martelli e Montanari [16], independentemente descobrem outro algoritmo de unificac¸a˜o
linear. Eles chegam a este algoritmo a partir da estrutura de termos proposta por Boyer
e Moore. Mas so´ em [17], no ano de 1982, e´ que Martelli e Montanari apresentam uma
descric¸a˜o completa de um algoritmo de unificac¸a˜o eficiente, mas este u´ltimo algoritmo na˜o
era realmente linear. Em 1983, Corbin e Bidoit [5] reabilitam o algoritmo de unificac¸a˜o
de Robinson usando novas estruturas de dados. Eles conseguem reduzir a complexidade
2.1 Unificac¸a˜o: Visa˜o Informal do Problema, Histo´ria e Aplicac¸o˜es 7
de tempo do algoritmo de Robinson, que era exponencial, para O(n2), e afirmam que o
algoritmo e´ mais simples que o proposto por Martelli e Montanari ale´m de ser superior
na pra´tica.
O algoritmo de unificac¸a˜o de Robinson usa a representac¸a˜o de termos em lo´gica de
primeira ordem dados por uma sequeˆncia de s´ımbolos, que e´ uma representac¸a˜o bastante
simples, onde os termos podem ser vistos como um arranjo linear. Esta representac¸a˜o
por sequeˆncia de s´ımbolos e´ equivalente a` representac¸a˜o por a´rvores. Mas este tipo de
representac¸a˜o e´ mais u´til quando os termos na˜o assumem formas muito complicadas. De
fato, nesta representac¸a˜o pode ser necessa´rio gerar estruturas de termos exponencialmente
grandes durante o processo de unificac¸a˜o.
No sentido de contornar este problema, alguns algoritmos de unificac¸a˜o usam uma
representac¸a˜o de termos por grafos, chamamos esta representac¸a˜o de grafo ac´ıclico direto,
ou pela sigla em ingleˆs DAG, como e´ mais comumente chamada. Esta abordagem dos
termos contorna o problema de duplicac¸a˜o de subtermos gerado por substituic¸o˜es, atrave´s
de uma representac¸a˜o por grafos que podem dividir estruturas. Em tal representac¸a˜o,
todos os ve´rtices do grafo sa˜o rotulados. A ide´ia central e´ na˜o permitir que subtermos
ideˆnticos aparec¸am em posic¸o˜es distintas de um termo. Isto e´ feito atrave´s de uma atuali-
zac¸a˜o de ponteiros, que passam a indicar um outro subtermo depois de uma instanciac¸a˜o.
Podemos ter mais de um ponteiro direcionado para uma mesma estrututra, isto consiste
em dividir estruturas. Um algoritmo que utiliza tal estrutura de dados, necessita de uma
estrutura adicional para ponteiros que ligam a cada varia´vel um termo que seja sua ins-
taˆncia por uma substituic¸a˜o. Com esta representac¸a˜o para termos, a complexidade do
algoritmo passa a ser quadra´tica. De fato, Corbin e Bidoit utilizam esta representac¸a˜o
para os termos, a fim de reduzir a complexidade de tempo do algoritmo de unificac¸a˜o de
Robinson para tempo quadra´tico.
2.2 O Problema de Unificac¸a˜o 8
2.2 O Problema de Unificac¸a˜o
Nesta sec¸a˜o apresentamos o problema de unificac¸a˜o analiticamente, isto e´, expomos uma
ana´lise alge´brica do problema, primeiro introduzindo as definic¸o˜es e a notac¸a˜o que utiliza-
mos para tratar do problema de unificac¸a˜o, em seguida definimos o problema de unificac¸a˜o
em si, para enta˜o apresentar a versa˜o do algoritmo de unificac¸a˜o de Robinson que utiliza-
mos na formalizac¸a˜o proposta por este trabalho. Conclu´ımos provando analiticamente a
correc¸a˜o deste algoritmo. Na apresentac¸a˜o desta sec¸a˜o, utilizamos as notac¸o˜es e definic¸o˜es
de [2] e de [1].
2.2.1 Assinaturas, Termos e Substituic¸o˜es
Nas sec¸o˜es anteriores ja´ temos introduzido alguns elementos presentes na teoria que en-
volve o problema de unificac¸a˜o, sem defin´ı-los formalmente. Alguns destes elementos, sa˜o
o que chamamos de termos, substituic¸o˜es, unificadores, por exemplo. Passemos agora a
uma definic¸a˜o formal destes elementos. Primeiro introduzimos a seguinte notac¸a˜o para
varia´veis, constantes e s´ımbolos de func¸a˜o:
• Varia´veis: {u, v, w, x, y, z},
• Constantes: {a, b, c},
• S´ımbolos de func¸a˜o: {f, g, h}.
Os termos sa˜o constru´ıdos a partir de s´ımbolos de func¸a˜o, associados a um natural n
que representa a sua aridade, e varia´veis. Por exemplo, se g e´ um s´ımbolo de func¸a˜o de
aridade 3 e u, v e w sa˜o varia´veis, enta˜o g(u, v, w) e´ um termo. Enta˜o, antes de definirmos
formalmente o que e´ um termo, vamos introduzir a noc¸a˜o de assinatura.
Definic¸a˜o 2.2.1: Uma assinatura Σ e´ um conjunto de s´ımbolos de func¸a˜o, onde a
cada f ∈ Σ e´ associado a um nu´mero natural n, que chamamos a aridade de f . Para cada
n > 0, denotamos o conjunto de todos os elementos n-a´rios de Σ por Σn. Os elementos
de Σ0 sa˜o s´ımbolos de constante, isto e´, as constantes sa˜o func¸o˜es com aridade 0.
2.2 O Problema de Unificac¸a˜o 9
Por exemplo, se queremos considerar um grupo G, que e´ um conjunto na˜o vazio de
elementos, munido de uma operac¸a˜o bina´ria associativa, que chamamos de produto; de
uma operac¸a˜o una´ria para denotar o inverso de um elemento de G; ale´m do elemento
neutro, usamos a seguinte assinatura: ΣG := {e, i, f}, onde e e´ uma constante, isto e´,
uma func¸a˜o de aridade 0, que denota o elemento neutro, i e´ um s´ımbolo de func¸a˜o una´rio
e f e´ um s´ımbolo de func¸a˜o bina´rio.
Tendo em ma˜os a definic¸a˜o de assinatura, podemos agora definir o que vem a ser um
termo. Lembrando que estamos tratando sempre de termos de primeira ordem. A noc¸a˜o
de termo e´ definida recursivamente da seguinte forma:
Definic¸a˜o 2.2.2: Seja Σ uma assinatura e V um conjunto de varia´veis, enta˜o o conjunto
T (Σ,V) de todos os Σ-termos, ou simplesmente termos, sobre V e´ dado por:
• V ⊂ T (Σ,V), isto e´, toda varia´vel e´ um termo;
• Se f ∈ Σn e´ um s´ımbolo de func¸a˜o de aridade n > 0 e t1, . . . , tn ∈ T (Σ,V) sa˜o
termos, enta˜o f(t1, . . . , tn) ∈ T (Σ,V) e´ um termo, isto e´, para n = 0 temos que toda
constante e´ um termo, e toda aplicac¸a˜o de s´ımbolos de func¸a˜o de aridade n > 0 em
termos, e´ ainda um termo.
Por exemplo, considerando a assinatura
ΣG = {e, i, f}, temos que se x, y ∈ G sa˜o
elementos de G, enta˜o f(f(x, y), f(e, i(x))) e´
um ΣG-termo, isto e´, f(f(x, y), f(e, i(x))) ∈
T (ΣG, G). Encontramos na representac¸a˜o
por a´rvores uma forma bastante pra´tica de
representar um termo. Para ilustrar veja
ao lado a representac¸a˜o por a´rvore do termo
f(f(x, y), f(e, i(x))). 221
22211211
1 2
ε
y i
f
f f
x
x
e
Note que na figura acima utilizamos a numerac¸a˜o por sequeˆncias de inteiros positivos
para os no´s da a´rvore. Com esta numerac¸a˜o podemos nos referir as posic¸o˜es do termo.
Veja por exemplo que o no´ raiz esta´ rotulado com ε, que na nossa notac¸a˜o representa a
sequeˆncia vazia, e se refere ao primeiro s´ımbolo de func¸a˜o f que aparece no termo. O
2.2 O Problema de Unificac¸a˜o 10
primeiro no´ a esquerda se refere ao subtermo na posic¸a˜o 1 do termo principal, que e´ dado
por f(x, y). A seguir, temos algumas definic¸o˜es acerca de termos.
Nas definic¸o˜es seguintes sejam Σ uma assinatura, V um conjunto de varia´veis e s e t
termos de T (Σ,V).
Definic¸a˜o 2.2.3: O conjunto de posic¸o˜es do termo s, denotado por Pos(s), e´ um con-
junto de sequeˆncias de nu´meros naturais, que e´ definido indutivamente como segue:
• Se s ∈ V , enta˜o Pos(s) = ε.
• Se s = f(s1, . . . , sn), enta˜o
Pos(s) := {ε} ∪
n⋃
i=1
{ip | p ∈ Pos(si)}.
O comprimento de um termo s, denotado por |s|, e´ a cardinalidade do conjunto Pos(s).
Definic¸a˜o 2.2.4: Para cada p ∈ Pos(s), o subtermo de s na posic¸a˜o p, denotado por
s|p, e´ definido por induc¸a˜o no comprimento de p como segue:
• s|ε := s, para p = ε.
• f(s1, . . . , sn)|iq := si|q, para p = iq.
Note que, para p = iq, se p ∈ Pos(s), enta˜o s e´ da forma f(s1, . . . , sn) com i 6 n.
Definic¸a˜o 2.2.5: O conjunto de varia´veis que ocorrem em um termo s, denotado
por Vars(s), e´ dado por:
Vars(s) := {x ∈ V | ∃p ∈ Pos(s) tal que s|p = x}.
Dizemos que p ∈ Pos(s) e´ uma posic¸a˜o de varia´vel do termo s, se s|p e´ uma varia´vel.
Para falar de unificac¸a˜o ainda precisamos introduzir a noc¸a˜o de substituic¸a˜o. A t´ıtulo
de notac¸a˜o, utilizaremos letras gregas minu´sculas {σ, α, β, . . .}, para denotar substituic¸o˜es.
Definic¸a˜o 2.2.6: Seja Σ uma assinatura e V um conjunto enumera´vel de varia´veis. Uma
T(Σ,V)-substituic¸a˜o, ou simplesmente substituic¸a˜o, e´ uma func¸a˜o σ : V → T (Σ,V) tal
que:
2.2 O Problema de Unificac¸a˜o 11
(a) σ(x) 6= x, somente para um nu´mero finito de varia´veis.
(b) O conjunto de varia´veis para as quais σ(x) 6= x, e´ chamado o domı´nio de σ, e
denotado por:
Dom(σ) := {x ∈ V | σ(x) 6= x}.
(c) A imagem de σ e´ o conjunto composto por todo termo s tal que s = σ(x) para algum
x no domı´nio de σ. Denotamos tal conjunto por:
Ran(σ) := {σ(x) | x ∈ Dom(σ)}.
A substituic¸a˜o σ para a qual Dom(σ) = ∅, isto e´, σ(x) = x, ∀x ∈ V , denominamos
substituic¸a˜o identidade e a denotaremos por id.
Note que, pela Definic¸a˜o 2.2.6, temos que uma substituic¸a˜o tem domı´nio finito. Assim,
podemos usar a seguinte notac¸a˜o de conjunto
σ := {x1/r1, . . . , xn/rn},
para denotar uma substituic¸a˜o σ cujo domı´nio seja dado por Dom(σ) = {x1, . . . , xn} e
cuja imagem seja dada por Ran(σ) = {r1, . . . , rn}.
Observamos que uma substituic¸a˜o σ pode ser extendida homeomorficamente ao con-
junto de termos T (Σ,V), por uma aplicac¸a˜o σˆ : T (Σ,V)→ T (Σ,V), da seguinte forma:
• Para s = x ∈ V , definimos σˆ(s) := σ(x).
• Para s = f(s1, . . . , sn), definimos σˆ(s) := f(σˆ(s1), . . . , σˆ(sn)).
No processo proposto pelo algoritmo de unificac¸a˜o sa˜o feitas composic¸o˜es entre substi-
tuic¸o˜es ate´ que se chegue a uma soluc¸a˜o do problema. Assim, e´ preciso definir o que vem
a ser composic¸a˜o de substituic¸o˜es.
Definic¸a˜o 2.2.7: Sejam σ := {x1/r1, . . . , xn/rn} e α := {y1/s1, . . . , ym/sm} substitui-
c¸o˜es. Enta˜o definimos a composic¸a˜o σ ◦ α como sendo a substituic¸a˜o:
σ ◦ α := {y1/σˆ(s1), . . . , yn/σˆ(sn), x1/r1, . . . , xn/rn},
eliminando qualquer ligac¸a˜o yj/σˆ(sj), para a qual yj = σˆ(sj) e qualquer ligac¸a˜o xi/ri,
para a qual xi ∈ {y1, . . . , ym}.
2.2 O Problema de Unificac¸a˜o 12
2.2.2 O Problema de Unificac¸a˜o e as Substituic¸o˜es mais Gerais
Ate´ este ponto todas as definic¸o˜es e notac¸o˜es colocadas, tiveram o objetivo de preparar
a base para podermos falar do que e´ o nosso principal interesse, o problema de unifica-
c¸a˜o. Ja´ colocamos na primeira sec¸a˜o deste cap´ıtulo que o problema de unificac¸a˜o e´ mais
geralmente tratado no seguinte contexto: dados dois termos quaisquer queremos saber se
existe uma substituic¸a˜o que torna os dois termos ideˆnticos e estudar formas de obter tal
substituic¸a˜o bem como as propriedades matema´ticas da mesma. De maneira mais formal,
apresentamos na Definic¸a˜o 2.2.8 em que consiste o processo de unificac¸a˜o envolvendo dois
termos quaisquer, mais a frente na Definic¸a˜o 2.2.10, falamos do problema de unificac¸a˜o.
Note que a definic¸a˜o a seguir e´ constru´ıda sobre a noc¸a˜o de teoria equacional, que
nada mais e´ do que um conjunto de pares (s, t), onde s e t sa˜o termos de T (Σ,V), tais
que s e t pertencem a uma mesma classe de equivaleˆncia induzida por um conjunto de
Σ-identidades E em T (Σ,V). Em notac¸a˜o matema´tica:
≈E:= {(s, t) ∈ T (Σ,V)× T (Σ,V) | E  s ≈ t}.
Definic¸a˜o 2.2.8: Unificac¸a˜o e´ o processo de resolver o seguinte problema de satisfa-
zibilidade: Dada uma teoria equacional E e dois termos s e t em T (Σ,V), encontrar
uma substituic¸a˜o σ tal que σˆ(s) ≈E σˆ(t). Dizemos que σ e´ um unificador de s e t, e
σ ∈ U(s, t), onde U(s, t) denota o conjunto formado por todos os unificadores dos termos
s e t.
Por exemplo, considere os termos s = f(a, x) e t = f(y, h(b)). Tais termos sa˜o ditos
unifica´veis, pois substituir x por h(b) e y por a torna-os ideˆnticos e iguais a f(a, h(b)).
Assim, neste caso um unificador de s e t e´ dado por σ := {x/h(b), y/a}.
Neste trabalho, nos concentramos no caso em que a teoria equacional E e´ vazia. Este
caso e´ do nosso interesse pois e´ neste contexto que se fala sobre o teorema dos pares
cr´ıticos de Knuth-Bendix, formalizado na teoria trs, onde a existeˆncia de unificadores
mais gerais foi originalmente axiomatizada, e que visamos completar. Quando E = ∅ o
processo de unificac¸a˜o recebe o nome especial de unificac¸a˜o sinta´tica.
Para estudarmos as propriedades das substituic¸o˜es computadas por um algoritmo de
2.2 O Problema de Unificac¸a˜o 13
unificac¸a˜o, precisamos ainda de algumas noc¸o˜es importantes e que nos interessam acerca
de substituic¸o˜es. Como ja´ colocamos anteriormente, em geral na˜o se esta´ interessado
em um algoritmo que compute todos os unificadores de um dado problema, mas sim em
um unificador especial, um que seja mais geral. Assim, definimos o que vem a ser uma
substituic¸a˜o mais geral.
Definic¸a˜o 2.2.9: Uma substituic¸a˜o σ e´ mais geral que uma substituic¸a˜o σ′ se existe
uma substituic¸a˜o δ tal que σ′ = δ ◦ σ. Neste caso dizemos que σ′ e´ uma instaˆncia de σ
e denotamos este fato por σ . σ′, onde . e´ uma relac¸a˜o sobre substituic¸o˜es que e´ uma
pre´-ordem.
Agora podemos definir o que e´ um problema de unificac¸a˜o.
Definic¸a˜o 2.2.10: Uma instaˆncia do problema de unificac¸a˜o e´ um conjunto finito de
equac¸o˜es S = {s1 ?= t1, . . . , sn ?= tn}. O problema e´ determinar se existe uma substituic¸a˜o
σ tal que σ(si) = σ(ti), para todo i = 1, . . . , n.
Note que na definic¸a˜o de problema de unificac¸a˜o, temos n equac¸o˜es, envolvendo pares
de termos que devemos responder se sa˜o unifica´veis e em seguida buscar uma substituic¸a˜o
que seja um unificador de todos os n pares de termos. Mas o algoritmo de unificac¸a˜o
apresentado na Sec¸a˜o 2.2.3, tem como paraˆmetros apenas um par de termos, isto e´, o
algoritmo apresentado busca responder, para dois termos s e t, se existe uma substituic¸a˜o
σ tal que σˆ(s) = σˆ(t). Contudo, o algoritmo pode ser extendido a uma instaˆncia do
problema de unificac¸a˜o como definido acima.
Definic¸a˜o 2.2.11: Dizemos que uma substituic¸a˜o σ e´ um unificador ou soluc¸a˜o de um
problema de unificac¸a˜o S, se σˆ(si) = σˆ(ti) para todo si
?
= ti ∈ S, i = 1, . . . , n. Denotamos
ainda por U(S) o conjunto de todos os unificadores de S, e dizemos que S e´ unifica´vel se
U(S) 6= ∅.
Agora podemos definir o que e´ um unificador mais geral de um problema de unificac¸a˜o.
Por simplicidade, de agora em diante vamos fazer uso da sigla mgu, que vem da expressa˜o
em ingleˆs most general unifier, para significar que estamos falando de um unificador mais
geral.
2.2 O Problema de Unificac¸a˜o 14
In´ıcio Unification Algorithm(A: Conjunto na˜o vazio de expresso˜es bem
formadas)
Passo 1. Defina σ0 = id e k = 0, e va´ para o passo 2.
Passo 2. Se Aσk na˜o e´ unita´rio, va´ para o passo 3. Caso contra´rio, defina
σA = σk e termine.
Passo 3. Defina Vk como sendo o menor, e Uk como o sendo o pro´ximo, na
orden lexicogra´fica do conjunto de diferenc¸as Bk de Aσk. Se Vk
e´ uma varia´vel, e na˜o ocorre em Uk, defina σk+1 = [Vk/Uk] ◦ σk,
adicione 1 a k, e retorne ao passo 2. Caso contra´rio, termine.
Fim
Figura 2.2.1: Algoritmo de unificac¸a˜o de Robinson original encontrado em [26].
Definic¸a˜o 2.2.12: Dizemos que uma substituic¸a˜o σ e´ um mgu de um problema de
unificac¸a˜o S se:
• σ ∈ U(S) e
• Para todo σ′ ∈ U(S) vale que σ . σ′.
Em outras palavras, uma substituic¸a˜o σ e´ um mgu de um problema de unificac¸a˜o S, se
e´ um unificador de S e se para qualquer outra substituic¸a˜o σ′ que seja tambe´m unificador
de S, existe uma substituic¸a˜o δ tal que σ′ = δσ.
2.2.3 O Algoritmo de Unificac¸a˜o
Agora temos material suficiente para apresentar a versa˜o do algoritmo de unificac¸a˜o de
Robinson, em seguida provar a correc¸a˜o e a completude deste algoritmo. Na Figura 2.2.2
temos este algoritmo. Apresentamos tambe´m na Figura 2.2.1 o algoritmo original de
Robinson, extra´ıdo de [26], para que se possa fazer uma comparac¸a˜o entre os dois e ver
que consistem do mesmo processo.
Antes de partirmos para a verificac¸a˜o da correc¸a˜o da versa˜o do algoritmo de unificac¸a˜o
de Robinson, o algoritmo Robinson-Unification, proposto na Figura 2.2.2, vamos enfatizar
2.2 O Problema de Unificac¸a˜o 15
01: k := 0 (varia´vel global)
σ0 := id
02: BEGIN Robinson-Unification(s, t)
03: IF s = t THEN σk+1 := id
04: ELSE
05: p← posic¸a˜o da “primeira diferenc¸a” entre os termos s e t
(tomada mais externamente e mais a` esquerda)
06: IF s|p /∈ V e t|p /∈ V THEN fail
07: ELSE
08: IF s|p ∈ V e s|p ∈ V(t|p) THEN fail
09: ELSE
10: IF t|p ∈ V e t|p ∈ V(s|p) THEN fail
11: ELSE
12: IF s|p ∈ V THEN x := s|p e r := t|p
13: ELSE x := t|p e r := s|p
14: σk+1 := {x/r} (substituic¸a˜o que resolve a primeira diferenc¸a)
15: k := k + 1
16: return Robinson-Unification(σˆk(s), σˆk(t)) ◦ σk
17: END
Figura 2.2.2: Versa˜o do Algoritmo de Unificac¸a˜o de Robinson, onde
k e´ iniciado como zero e σ0 como a identidade
a notac¸a˜o que sera´ adotada de agora em diante, para termos uma refereˆncia desta notac¸a˜o
e evitar confuso˜es. Como sugere o algoritmo de unificac¸a˜o, adotamos a seguinte notac¸a˜o:
• σk, para k ∈ {0, . . . , n, . . .}, denota um conjunto de varia´veis globais, que indicam
a ligac¸a˜o feita no k-e´simo passo do algorimo de unificac¸a˜o, sendo que σ0 e´ iniciada
globalmente como a substituic¸a˜o identidade;
• k e´ uma varia´vel global de controle das chamadas recursivas do algoritmo, iniciada
globalmente como zero;
• σ′k indica a substituic¸a˜o iterada, computada ate´ o k-e´simo passo do algoritmo de
unificac¸a˜o, usada na demonstrac¸a˜o;
2.2 O Problema de Unificac¸a˜o 16
• σ indica a substituic¸a˜o final, obtida pelo algoritmo de unificac¸a˜o, para dois termos
unifica´veis s e t, usada nas provas.
Observe que, como ja´ mencionamos anteriormente, no algoritmo da Figura 2.2.2, nos
concentramos no caso em que o conjunto de equac¸o˜es S, que define problema de unificac¸a˜o,
e´ unita´rio. Isto e´, S := {s ?= t}. Note tambe´m que a cada iterac¸a˜o, o algoritmo de
unificac¸a˜o tem um novo conjunto de termos de entrada, obtido a partir do anterior e da
substituic¸a˜o gerada pelo passo anterior. A fim de que o algoritmo esteja correto, desejamos
que estes novos termos tambe´m sejam unifica´veis, caso s e t o sejam. Observe ainda que
o algoritmo e´ um processo que sempre termina, como provaremos adiante, pois a cada
selec¸a˜o da varia´vel x e do termo r, substitui-se todas as ocorreˆncias de x nos termos s
e t pelo termo r, e como r na˜o possui ocorreˆncias de x, temos que a cardinalidade do
conjunto dado pela unia˜o dos conjuntos de varia´veis dos termos em questa˜o, diminui a
cada iterac¸a˜o do algoritmo, e como a unia˜o dos conjuntos de varia´veis dos termos s e
t e´ um conjunto finito, temos que o algoritmo termina. Em seguida vamos enunciar e
demonstrar cada um destes fatos. Comec¸amos pelo seguinte lema auxiliar:
Lema 2.2.13: Uma equac¸a˜o x
?
= r, onde x ∈ Vars(r) e x 6= r, na˜o tem soluc¸a˜o.
Demonstrac¸a˜o: Observe que na˜o faz sentido considerar o caso em que o termo r e´ uma
varia´vel, pois caso r seja uma varia´vel deve ser, por hipo´tese, diferente de x. Contudo
temos tambe´m que x pertence a Vars(r). Logo, se r e´ uma varia´vel deve ser igual a
x, o que e´ uma contradic¸a˜o. Portanto, suponha que r = f(r1, ..., rn) e que existe uma
substituic¸a˜o σ tal que σˆ(x) = σˆ(r). Assim,
x ∈ Vars(r) ⇒ ∃p ∈ Pos(r) tal que r|p = x.
⇒ σˆ(r|p) = σˆ(x) = σˆ(r).
⇒ σˆ(r|p) = σˆ(r)
⇒ (σˆ(r))|p = σˆ(r)
⇒ p = .
Mas se p = , enta˜o r|p = r. Contudo, r|p = x. Logo, r = x. O que e´ um absurdo, pois por
hipo´tese r 6= x. Portanto, temos que na˜o existe uma substituic¸a˜o σ tal que σˆ(x) = σˆ(r),
isto e´, nas condic¸o˜es das hipo´teses do lema, a equac¸a˜o x
?
= r, na˜o tem soluc¸a˜o.
2.2 O Problema de Unificac¸a˜o 17
Nos dois lemas seguintes vamos demonstrar fatos fundamentais para a demonstrac¸a˜o
do Teorema 2.2.18, onde provamos que a substituic¸a˜o computada pelo algoritmo de uni-
ficac¸a˜o, tomando como entradas dois termos unifica´veis s e t, e´ de fato um mgu de s e t.
No primeiro lema provamos que para dois termos unifica´veis e diferentes, se tomamos a
substituic¸a˜o que resolve a primeira diferenc¸a entre estes termos, onde a primeira diferenc¸a
e´ tomada na posic¸a˜o mais externa e mais a` esquerda dos termos, enta˜o as instaˆncias dos
termos por esta substituic¸a˜o sa˜o ainda dois termos unifica´veis. No segundo lema, pro-
vamos um resultado importante para garantir a terminac¸a˜o do algoritmo de unificac¸a˜o,
provamos que a unia˜o dos conjuntos de varia´veis dos termos obtidos por instanciac¸a˜o nas
chamadas recursivas do algoritmo de unificac¸a˜o sempre diminui. Precisamente, a cada
iterac¸a˜o do algoritmo este conjunto passa a ter uma varia´vel a menos: aquela capturada
na iterac¸a˜o imediatamente anterior do algoritmo de unificac¸a˜o.
Lema 2.2.14: (Preservac¸a˜o da Generalidade) Sejam s e t dois termos unifica´veis
e σk, para k 6= 0, a ligac¸a˜o computada pelo algoritmo de unificac¸a˜o no k-e´simo passo.
Note que σk e´ a substituic¸a˜o que resolve a primeira diferenc¸a entre os termos σˆ
′
k−1(s) e
σˆ′k−1(t), onde σ
′
k−1 e´ a substituic¸a˜o iterada computada pelo algoritmo de unificac¸a˜o ate´ o
(k − 1)-e´simo passo. Enta˜o, σˆ′k−1(s) e σˆ′k−1(t) sa˜o unifica´veis e
∀θ ∈ U( σˆ′k−1(s), σˆ′k−1(t) ), ∃δ tal que θ = δ ◦ σk.
Demonstrac¸a˜o: Vamos mostrar que a assertiva do lema e´ de fato verdadeira para δ = θ,
isto e´, ∀θ ∈ U(σˆ′k−1(s), σˆ′k−1(t)), θ = θ ◦ σk. No caso em s = t, temos que σ1 = id e e´
trivial que θ = θ ◦ id. O caso em que s 6= t, segue por induc¸a˜o em k:
B.I.: Para k = 1: por hipo´tese temos que σ0 = id e os termos s e t sa˜o unifica´veis. Ale´m
disso, ∀θ ∈ U(s, t), θ = θ ◦ σ1. De fato, se p e´ a posic¸a˜o onde ocorre a primeira
diferenc¸a entre os termos s e t, e se s|p e´ uma varia´vel que na˜o ocorre em t|p, enta˜o
a seguinte afirmac¸a˜o e´ verdadeira: ∀θ ∈ U(s, t) e ∀y ∈ V , θ(y) = (θ ◦σ1)(y). Vamos
analisar as possibilidades para a varia´vel y:
2.2 O Problema de Unificac¸a˜o 18
y = s|p: Neste caso, temos que:
θ(y) = θ(s|p), pois y = s|p
= θˆ(s|p), pela observac¸a˜o da definic¸a˜o de substituic¸a˜o
= θˆ(t|p), pois θ ∈ U(s, t)
= θˆ(σ1(s|p)), pois σ1 = {s|p/t|p}
= (θ ◦ σ1)(s|p), por definic¸a˜o
= (θ ◦ σ1)(y).
y 6= s|p: Neste caso, temos diretamente que θ(y) = (θ ◦ σ1)(y). Pois, como y 6= s|p
temos que y /∈ Dom(σ1), o que implica que σ1(y) = y.
O caso em que t|p e´ uma varia´vel que na˜o ocorre em s|p e´ ana´logo.
P.I.: Suponha que a hipo´tese seja va´lida para k, vamos mostrar que tambe´m e´ va´lida
para k + 1, isto e´, vamos mostrar que:
σˆ′k−1(s) e σˆ
′
k−1(t) sa˜o unifica´veis e
∀θ ∈ U( σˆ′k−1(s), σˆ′k−1(t) ), θ = θ ◦ σk
⇓
σˆ′k(s) e σˆ
′
k(t) sa˜o unifica´veis e
∀θ ∈ U( σˆ′k(s), σˆ′k(t) ), θ = θ ◦ σk+1.
Primeiro, vamos verificar que os termos σˆ′k(s) e σˆ
′
k(t) sa˜o unifica´veis. Isto equivale
a mostrar que o conjunto U(σˆ′k(s), σˆ′k(t)) e´ na˜o vazio. Observe que σ′k = σk ◦ σ′k−1,
pois a substituic¸a˜o iterada obtida no k-e´simo passo do algoritmo de unificac¸a˜o e´
igual a` composic¸a˜o da ligac¸a˜o obtida neste passo com a substituic¸a˜o iterada obtida
no passo anterior. Assim,
θ ∈ U(σˆ′k−1(s), σˆ′k−1(t)) ⇒ θˆ(σˆ′k−1(s)) = θˆ(σˆ′k−1(t))
⇒ (θ̂ ◦ σk)(σˆ′k−1(s)) = (θ̂ ◦ σk)(σˆ′k−1(t))
⇒ θˆ(( ̂σk ◦ σ′k−1)(s)) = θˆ(( ̂σk ◦ σ′k−1)(t))
⇒ θˆ(σˆ′k(s)) = θˆ(σˆ′k(t))
⇒ θ ∈ U(σˆ′k(s), σˆ′k(t)).
2.2 O Problema de Unificac¸a˜o 19
Portanto, sabendo que o conjunto U(σˆ′k(s), σˆ′k(t)) e´ na˜o vazio, resta verificar que
∀θ ∈ U(σˆ′k(s), σˆ′k(t)), θ = θ ◦ σk+1. De fato, sabemos que σk+1 e´ a ligac¸a˜o obtida
no (k + 1)-e´simo passo do algoritmo de unificac¸a˜o e, portanto temos as seguintes
possibilidades exclusivas para σk+1, onde a primeira possibilidade representa o caso
em que σˆ′k(s) = σˆ
′
k(t) e as duas u´ltimas possibilidades representam o caso em que
σˆ′k(s) 6= σˆ′k(t).
i) σk+1 = id: Neste caso e´ trivialmente verdade que θ = θ ◦ σk+1 , pois θ = θ ◦ id
qualquer que seja a substituic¸a˜o θ, em particular para θ ∈ U(σˆ′k(s), σˆ′k(t)) temos
que o resultado tambe´m e´ va´lido.
ii) σk+1 = {(σˆ′k(s))|p/(σˆ′k(t))p}: Neste caso temos que (σˆ′k(s))|p e´ uma varia´vel
que na˜o ocorre em (σˆ′k(t))|p, e p e´ a posic¸a˜o onde ocorre a primeira diferenc¸a
mais externa e mais a` esquerda entre os termos σˆ′k(s) e σˆ
′
k(t). Assim, para uma
varia´vel y qualquer vamos mostrar que θ(y) = (θ ◦ σk+1)(y). Analogamente a`
ana´lise de casos feita na base de induc¸a˜o, temos:
y = (σˆ′k(s))|p: Neste caso, temos que:
θ(y) = θ((σˆ′k(s))|p)
= θˆ((σˆ′k(s))|p), pela observac¸a˜o da definic¸a˜o de substituic¸a˜o
= θˆ((σˆ′k(t))|p), pois θ ∈ U(σˆ′k(s), σˆ′k(t))
= θˆ(σk+1((σˆ
′
k(s))|p)), pois σk+1((σˆ′k(s))|p) = (σˆ′k(s))|p
= (θ ◦ σk+1)((σˆ′k(s))|p), por definic¸a˜o
= (θ ◦ σk+1)(y).
y 6= (σˆ′k(s))|p: Neste caso, temos diretamente que θ(y) = (θ ◦ σk+1)(y). Pois,
como y e´ diferente de (σˆ′k(s))|p, temos que y /∈ Dom(σk+1), o que implica
que σk+1(y) = y.
iii) σk+1 = {(σˆ′k(t))|p/(σˆ′k(s))p}: Este caso e´ inteiramente ana´logo ao caso (ii)
anterior e portanto na˜o o repetiremos aqui.
Assim, conclu´ımos que os termos σˆ′k(s) e σˆ
′
k(t) sa˜o unifica´veis e ∀θ ∈ U(σˆ′k(s), σˆ′k(t))
vale que θ = θ ◦ σk+1, para todo natural k. Logo, segue a demonstrac¸a˜o do lema.
2.2 O Problema de Unificac¸a˜o 20
Note que no Lema 2.2.14, demonstramos que os termos gerados por instanciac¸a˜o dos
termos s e t iniciais, pela substituic¸a˜o iterada σ′k−1, computada ate´ o (k− 1)-e´simo passo,
sa˜o ainda unifica´veis pela mesma substituic¸a˜o θ unificador de s e t. Esta demonstrac¸a˜o
difere da geralmente encontrada em livros texto e envolve uma discussa˜o sobre o domı´nio
de θ.
Lema 2.2.15: (Terminac¸a˜o) Sejam s e t dois termos unifica´veis, tais que s 6= t, e
σ′k−1, para k > 0, a substituic¸a˜o iterada, obtida na (k − 1)-e´sima iterac¸a˜o do algoritmo
de unificac¸a˜o, tendo como entrada dois termos unifica´veis s e t. Assim, se σk e´ a ligac¸a˜o
obtida na k-e´sima iterac¸a˜o do algoritmo e se σˆ′k−1(s) 6= σˆ′k−1(t), enta˜o
Card( Vars(σˆk(σˆ′k−1(s))) ∪ Vars(σˆk(σˆ′k−1(t))) )
< Card( Vars(σˆ′k−1(s)) ∪ Vars(σˆ′k−1(t)) ).
Demonstrac¸a˜o: De fato, sabemos que se σˆ′k−1(s) 6= σˆ′k−1(t), enta˜o na iterac¸a˜o seguinte
o algoritmo de unificac¸a˜o busca a posic¸a˜o p onde ocorre a primeira diferenc¸a entre os
termos σˆ′k−1(s) e σˆ
′
k−1(t), e a partir desta posic¸a˜o computa a ligac¸a˜o σk, para a qual temos
duas opc¸o˜es:
a) σk = {(σˆ′k−1(s))|p/(σˆ′k−1(t))|p}, quando (σˆ′k−1(s))|p e´ uma varia´vel que na˜o ocorre em
(σˆ′k−1(t))|p.
b) σk = {(σˆ′k−1(t))|p/(σˆ′k−1(s))|p}, quando (σˆ′k−1(t))|p e´ uma varia´vel que na˜o ocorre em
(σˆ′k−1(s))|p.
Em ambos os casos a ana´lise e´ a mesma, portanto vamos considerar apenas um caso.
Assim, suponha que σk seja como no item (a). Como (σˆ
′
k−1(s))|p e´ uma varia´vel que na˜o
ocorre em (σˆ′k−1(t))|p, temos que, denotando (σˆ′k−1(s))|p por x e (σˆ′k−1(t))|p por r:
x /∈ Vars(σˆk(σˆ′k−1(s))) e x /∈ Vars(σˆk(σˆ′k−1(t)))
⇒ x /∈ Vars(σˆk(σˆ′k−1(s))) ∪ Vars(σˆk(σˆ′k−1(t))),
pois σk substitui todas as ocorreˆncias de x por r. Logo, os termos instanciados por σk
na˜o possuem a varia´vel x. Por outro lado, temos que:
x ∈ Vars(σˆ′k−1(s)) ∪ Vars(σˆ′k−1(t)),
2.2 O Problema de Unificac¸a˜o 21
pois x e´ um subtermo do termo σˆ′k−1(s).
Ale´m disso, como r e´ um subtermo do termo σˆ′k−1(t), temos que σk na˜o introduz no
conjunto Vars(σˆk(σˆ′k−1(s))) ∪ Vars(σˆk(σˆ′k−1(t))), varia´veis distintas das que ocorriam no
conjunto Vars(σˆ′k−1(s)) ∪ Vars(σˆ′k−1(t)). Assim,
Card( Vars(σˆk(σˆ′k−1(s))) ∪ Vars(σˆk(σˆ′k−1(t))) )
= Card( Vars(σˆ′k−1(s)) ∪ Vars(σˆ′k−1(t)) )− 1
⇓
Card( Vars(σˆk(σˆ′k−1(s))) ∪ Vars(σˆk(σˆ′k−1(t))) )
< Card( Vars(σˆ′k−1(s)) ∪ Vars(σˆ′k−1(t)) ).
Da´ı segue a demonstrac¸a˜o do lema.
Como ja´ comentamos anteriormente, na linha 08 do algoritmo verificamos se o sub-
termo de s na posic¸a˜o p e´ uma varia´vel e se ocorre no subtermo de t na posic¸a˜o p. E
caso a resposta seja negativa, passamos a` linha 10, onde fazemos esta mesma verificac¸a˜o
para o termo t em vez de s. Isto nos garante que quando realizarmos a ligac¸a˜o {x/r}, o
termo r na˜o possui ocorreˆncias da varia´vel x. Esta verificac¸a˜o e´ importante, pois garante
a correc¸a˜o do algoritmo, contudo torna-o ineficiente, pois pode ser que seja necessa´rio
gerar termos exponencialmente grandes durante o processo de unificac¸a˜o.
Nos teoremas seguintes, verificamos que o algoritmo de unificac¸a˜o e´ correto e completo,
isto e´, para quaisquer dois termos s e t o algoritmo da´ uma resposta, caso s e t na˜o sejam
unifica´veis o algoritmo falha, mas caso s e t sejam unifica´veis o algoritmo computa uma
substituic¸a˜o que e´ de fato um mgu de s e t.
Teorema 2.2.16: (Correc¸a˜o) Sejam s e t dois termos unifica´veis. Se σ e´ a substituic¸a˜o
computada pelo algoritmo de unificac¸a˜o, enta˜o σ ∈ U(s, t).
Demonstrac¸a˜o: Vamos verificar este fato por induc¸a˜o em n = Card(Vars(s)∪Vars(t)).
B.I.: Para n = 0, temos que Vars(s) = ∅ e Vars(t) = ∅. Portanto os termos s e t sa˜o
termos funcionais, sem ocorreˆncias de varia´veis, que sa˜o unifica´veis. Logo, devemos
2.2 O Problema de Unificac¸a˜o 22
ter s = t, mas neste caso a substituic¸a˜o computada pelo algoritmo de unificac¸a˜o e´
a substituic¸a˜o id. E e´ trivialmente verdade que id(s) = id(t) para s = t. Portanto
σ = id ∈ U(s, t).
P.I.: Suponha que a hipo´tese seja va´lida para n − 1 e vamos mostar que tambe´m sera´
para n. O caso em que s = t e´ trivial e o argumento e´ o mesmo da base de induc¸a˜o,
portanto vamos nos ater ao caso em que s 6= t. Pelo Lema 2.2.15 temos que se σ1
e´ a substituic¸a˜o computada pelo algoritmo de unificac¸a˜o em um passo de execuc¸a˜o,
enta˜o
Card( Vars(σˆ1(s)) ∪ Vars(σˆ1(t)) ) = Card( Vars(s) ∪ Vars(t) ) − 1.
Assim, supondo que a substituic¸a˜o computada pelo algoritmo de unificac¸a˜o para os
termos σˆ1(s) e σˆ1(t), que pelo Lema 2.2.14 sa˜o unifica´veis, e´ um elemento do conjunto
U(σˆ1(s), σˆ1(t)), vamos mostrar que o mesmo vale para os termos s e t. Note que, se
θ = Robinson-Unification(σˆ1(s), σˆ1(t)), e se σ = Robinson-Unification(s, t), enta˜o
σ = θ ◦ σ1. De fato, esta e´ a composic¸a˜o retornada pelo algoritmo de unificac¸a˜o.
Assim,
θ ∈ U(σˆ1(s), σˆ1(t)) ⇒ θˆ(σˆ1(s)) = θˆ(σˆ1(t))
⇒ ̂(θ ◦ σ1)(s) = ̂(θ ◦ σ1)(t)
⇒ σˆ(s) = σˆ(t)
⇒ σ ∈ U(s, t).
Com isto conclu´ımos a demonstrac¸a˜o do teorema.
Acabamos de verificar que a substituic¸a˜o computada pelo algoritmo de unificac¸a˜o
para dois termos unifica´veis s e t e´ de fato um unificador de s e t. No teorema seguinte
verificamos que esta substituic¸a˜o e´ mais geral que qualquer outra substituic¸a˜o que unifique
os termos s e t.
Teorema 2.2.17: (Generalidade) Sejam s e t dois termos unifica´veis. Se σ e´ a subs-
tituic¸a˜o computada pelo algoritmo de unificac¸a˜o, enta˜o para toda substituic¸a˜o θ ∈ U(s, t)
temos que σ . θ.
2.2 O Problema de Unificac¸a˜o 23
Demonstrac¸a˜o: Novamente vamos usar induc¸a˜o em n = Card(Vars(s)∪Vars(t)) para
verificar este fato. Note que queremos mostrar que ∀θ ∈ U(s, t), ∃δ tal que θ = δ ◦ σ.
B.I.: Pelo mesmo argumento do lema anterior, temos que para n = 0 os termos s e t
devem ser iguais. Neste caso σ = id. Assim, ∀θ ∈ U(s, t), θ = θ ◦ σ. Logo, σ e´ mais
geral que θ.
P.I.: Suponha que a hipo´tese seja va´lida para n − 1 e vamos mostrar que tambe´m sera´
para n. O caso em que s = t e´ trivial e o argumento e´ o mesmo da base de induc¸a˜o.
Portanto vamos nos ater ao caso em que s 6= t. Pelo Lema 2.2.15 temos que se σ1
e´ a substituic¸a˜o computada pelo algoritmo de unificac¸a˜o em um passo de execuc¸a˜o,
enta˜o
Card( Vars(σˆ1(s)) ∪ Vars(σˆ1(t)) ) = Card( Vars(s) ∪ Vars(t) ) − 1.
Assim, supondo que a substituic¸a˜o computada pelo algoritmo de unificac¸a˜o para os
termos σˆ1(s) e σˆ1(t), que pelo Lema 2.2.14 sa˜o unifica´veis, e´ mais geral que qualquer
elemento do conjunto U(σˆ1(s), σˆ1(t)), vamos mostrar que o mesmo vale para os
termos s e t.
Primeiro observamos que, pelo Lema 2.2.14, temos:
∀θ ∈ U(s, t), ∃α tal que θ = α ◦ σ1.
Afirmamos que α ∈ U(σˆ1(s), σˆ1(t)). De fato,
θ ∈ U(s, t) ⇒ θˆ(s) = θˆ(t)
⇒ (α̂ ◦ σ1)(s) = (α̂ ◦ σ1)(t)
⇒ αˆ(σˆ1(s)) = αˆ(σˆ1(t))
⇒ α ∈ U(σˆ1(s), σˆ1(t)).
Observe ainda que se σ′1 = Robinson-Unification(σˆ1(s), σˆ1(t)), e se σ = Robinson-
Unification(s, t), enta˜o σ = σ′1 ◦ σ1. De fato, esta e´ a composic¸a˜o computada pelo
algoritmo de unificac¸a˜o.
2.2 O Problema de Unificac¸a˜o 24
Assim, temos que para σ′1 = Robinson-Unification(σˆ1(s), σˆ1(t)), existe uma substi-
tuic¸a˜o δ tal que α = δ ◦ σ′1, por hipo´tese de induc¸a˜o. Logo,
θ = α ◦ σ1 ⇒ θ = δ ◦ σ′1 ◦ σ1
⇒ θ = δ ◦ σ.
Ou seja, para todo θ ∈ U(s, t), existe δ tal que θ = δ ◦ σ, onde σ e´ a substituic¸a˜o
computada pelo algoritmo de unificac¸a˜o para os termos s e t. Logo, temos que σ e´
mais geral que θ seja qual for θ ∈ U(s, t). Em outras palavras σ . θ.
Teorema 2.2.18: (Completude) Sejam s e t dois termos quaisquer. Se s e t sa˜o
unifica´veis, enta˜o o algoritmo de unificac¸a˜o finaliza apresentando um unificador mais
geral de s e t. Caso s e t na˜o sejam unifica´veis o algoritmo de unificac¸a˜o para reportando
tal fato.
Demonstrac¸a˜o: Para verificar a completude do algoritmo de unificac¸a˜o, devemos ana-
lisar o caso em que os termos do paraˆmetro de entrada na˜o sa˜o unifica´veis, e verificar
que neste caso o processo de unificac¸a˜o falha e o caso em que os termos sa˜o unifica´veis, e
verificar que neste caso o algoritmo computa um mgu.
No caso em que s e t na˜o sa˜o unifica´veis, nenhum σ gerado pelo algoritmo sera´ soluc¸a˜o
de s
?
= t. Portanto o algoritmo deve parar reportanto tal fato. Isto se da´ nas linhas 06,
08 e 10 do algoritmo.
• Na linha 06 do algoritmo, verificamos se na posic¸a˜o onde ocorre a primeira diferenc¸a
entre os termos s e t, os dois subtermos s|p e t|p na˜o sa˜o varia´veis. Caso obtenha-
mos uma resposta positiva para esta verificac¸a˜o, temos que nesta posic¸a˜o ocorrem
apenas s´ımbolos de func¸a˜o nos dois termos. E como trata-se da posic¸a˜o onde ocorre
a primeira diferenc¸a, conclu´ımos que estes s´ımbolos de func¸a˜o sa˜o sintaticamente
distintos. Logo, os termos s e t na˜o sa˜o unifica´veis e o algoritmo para reportando
tal fato.
• Na linha 08 do algoritmo verificamos, caso o subtermo s|p seja uma varia´vel, se
s|p ocorre no subtermo t|p. Mas caso tenhamos uma resposta positiva para esta
verificac¸a˜o, enta˜o s|p e´ uma varia´vel diferente do termo t|p e, ale´m disso s|p ∈
2.2 O Problema de Unificac¸a˜o 25
Vars(t|p). Logo, segue do Lema 2.2.13 que a equac¸a˜o s|p ?= t|p na˜o tem soluc¸a˜o.
Enta˜o o algoritmo para e reporta que s e t na˜o sa˜o unifica´veis.
• Na linha 10 do algoritmo faz-se a mesma verificac¸a˜o realizada na linha 05, pore´m
agora para saber se t|p ∈ Vars(s|p), caso t|p seja uma varia´vel. Enta˜o da mesma
forma, se a resposta para esta verificac¸a˜o e´ positiva, o algoritmo para reportando
que os termos s e t na˜o sa˜o unifica´veis.
Caso os termos s e t sejam unifica´veis, a substituic¸a˜o gerada pelo algoritmo de unifi-
cac¸a˜o e´ um mgu de s e t. De fato, devemos demonstrar que se σ e´ a substituic¸a˜o gerada
pelo algoritmo, enta˜o σ e´ uma soluc¸a˜o da equac¸a˜o s
?
= t e para toda substituic¸a˜o α que
tambe´m seja unificador de s e t existe uma substituic¸a˜o δ tal que α = δ ◦σ. Mas este fato
segue diretamente dos teoremas 2.2.16 e 2.2.17.
Cap´ıtulo 3
Semaˆntica do PVS
O PVS1 (Prototype Verification System) e´ um sistema de especificac¸a˜o e verificac¸a˜o que
proveˆ um ambiente integrado para desenvolvimento e ana´lise de especificac¸o˜es formais, e
suporta uma ampla gama de atividades envolvendo criac¸a˜o, ana´lise, modificac¸a˜o, geren-
ciamento e documentac¸a˜o de teorias e provas. O PVS e´ basicamente composto por uma
Linguagem de Especificac¸a˜o fortemente integrada com um poderoso Assistente de Prova
Interativo, um Typechecker, ale´m de outras ferramentas como bibliotecas de especificac¸a˜o,
dentre outras. Neste cap´ıtulo apresentamos uma visa˜o geral sobre a semaˆntica do PVS
e as principais ferramentas utilizadas na especificac¸a˜o que apresentamos no Cap´ıtulo 4.
Para mais detalhes sobre a semaˆntica do PVS ver [19], o qual e´ a base das sec¸o˜es 3.3 e 3.4
deste cap´ıtulo. Para mais detalhes sobre a linguagem de especificac¸a˜o do PVS, o provador
e o sistema em si, veja os manuais [21,22,30], os quais formam a base das sec¸o˜es 3.1 e 3.2.
Para mais detalhes sobre a teoria trs, brevemente apresentada na sec¸a˜o 3.5, ver [8].
3.1 A Linguagem de Especificac¸a˜o do PVS
A linguagem de especificac¸a˜o do PVS e´ baseada em lo´gica de ordem superior simples-
mente tipada, e e´ desenvolvida para permitir especificac¸o˜es suscintas e leg´ıveis, ale´m de
construc¸o˜es efetivas de prova. Dentro de uma teoria os tipos podem ser definidos a partir
de tipos mais ba´sicos, como booleanos, nu´meros naturais, etc.
1Dispon´ıvel em http://pvs.csl.sri.com
26
3.2 O Assistente de Provas 27
Exemplo 3.1.1: Por exemplo, para definir uma substituic¸a˜o idempotente foi constru´ıda
a especificac¸a˜o do tipo idempotent_sub, apresentada abaixo. Tal especificac¸a˜o consta da
sub-teoria substitution, e foi definida a partir do tipo boll e tambe´m a partir do tipo
Sub, pois sigma e´ um objeto previamente declarado como sendo de tipo Sub, o que significa
que sigma e´ uma substituic¸a˜o.
idempotent_sub?(sigma): bool = comp(sigma, sigma) = sigma
idempotent_sub: TYPE = (idempotent_sub?)
Uma especificac¸a˜o em PVS consiste de uma colec¸a˜o de teorias. E cada teoria con-
siste de um conjunto de s´ımbolos para os nomes dos tipos e constantes introduzidas na
teoria, ale´m de axiomas, definic¸o˜es e teoremas associados. Como exemplo tomamos a
especificac¸ao da sub-teoria unification, apresentada no Apeˆndice A.
3.2 O Assistente de Provas
O objetivo principal do assistente de prova do PVS e´ dar suporte a` construc¸a˜o de provas
leg´ıveis, isto e´, o processo de verificac¸a˜o busca ser pro´ximo de uma prova que far´ıamos
no papel, logo permite interac¸a˜o humana, de forma que a prova possa ser facilmente
entendida e comunicada a outras pessoas. No sentido de fazer com que as provas sejam
facilmente desenvolvidas, o assistente de prova do PVS proveˆ uma colec¸a˜o poderosa de
comandos de prova, que quando combinados corretamente desenvolvem uma estrate´gia
de prova que visa realizar racioc´ınios lo´gicos, proposicionais e aritme´ticos, com o uso de
definic¸o˜es e lemas.
O assistente de prova do PVS foi desenvolvido com base na semaˆntica usual de Gent-
zen da Teoria da Prova. Isto significa que os objetivos em PVS sa˜o apresentados como
sequentes Γ ` ∆, onde Γ e ∆ sa˜o sequeˆncias finitas de fo´rmulas.
O assistente de prova mante´m uma a´rvore de prova, e o objetivo e´ obter uma a´rvore de
prova que seja completa, isto e´, uma a´rvore em que todos as folhas sa˜o reconhecidas como
verdadeiras. Cada no´ da a´rvore e´ um objetivo de prova, representado por um sequente
3.3 A Checagem de Tipos em PVS 28
da forma Γ ` ∆ que consiste de uma sequeˆncia de fo´rmulas Γ chamadas antecedentes e
uma sequeˆncia de fo´rmulas ∆ chamadas consequentes. A interpretac¸a˜o de um sequente e´
que a conjunc¸a˜o dos antecedentes implica a disjunc¸a˜o dos consequentes, isto e´, para Γ =
{A1, A2, A3, . . .} e ∆ = {B1, B2, B3, . . .}, temos que (A1∧A2∧A3 . . .) ⊃ (B1∨B2∨B3 . . .).
3.3 A Checagem de Tipos em PVS
Sabemos que os tipos formam um mecanismo poderoso para detectar erros sinta´ticos e
semaˆnticos, isto e´ feito atrave´s de uma operac¸a˜o de checagem de tipos, que em PVS e´ man-
tida pelo typechecker. A lo´gica expressiva do PVS proporciona uma boa integrac¸a˜o entre o
typechecker e o assistente de prova. O typechecker, explora o poder dedutivo do assistente
de prova para provar automaticamente as condic¸o˜es de correc¸a˜o de tipos, ou TCC’s do
ingleˆs type correctness conditions, que sa˜o obrigac¸o˜es de prova geradas pela operac¸a˜o de
checagem de tipos. Estas obrigac¸o˜es de prova, surgem por exemplo quando realizamos
a checagem de tipos de um termo em confronto com um subtipo de um predicado. Tais
obrigac¸o˜es tambe´m aparecem como sub-objetivos de prova durante uma formalizac¸a˜o.
Em PVS os tipos ba´sicos consistem de Booleanos, bool, e nu´meros reais, real. O PVS
e´ uma linguagem de especificac¸a˜o fortemente tipada, onde os tipos sa˜o constru´ıdos a partir
dos tipos ba´sicos, atrave´s de func¸o˜es e produtos de tipos, e expresso˜es sa˜o constru´ıdas a
partir das constantes e varia´veis por meio de aplicac¸o˜es, abstrac¸o˜es e sequeˆncias.
A operac¸a˜o de checagem de tipos e´ feita dentro de um contexto. Em PVS, um contexto
Γ e´ uma sequeˆncia de declarac¸o˜es, onde cada declarac¸a˜o e´ ou uma declarac¸a˜o de tipo,
s:TYPE, ou uma declarac¸a˜o de constante, c:T, onde T e´ um tipo, ou uma declarac¸a˜o de
varia´vel, x:VAR T. Isto pode ser visto como uma func¸a˜o parcial que associa a cada s´ımbolo
uma espe´cie que pode ser ou TYPE, ou CONSTANT, ou VARIABLE e um tipo a cada s´ımbolo
de constante e varia´vel. De maneira mais formal, definimos:
Definic¸a˜o 3.3.1: Seja Γ um contexto e s um s´ımbolo com declarac¸a˜o D e r um s´ımbolo
qualquer. Enta˜o,
1. (Γ, s : D)(s) = D
3.3 A Checagem de Tipos em PVS 29
2. r 6= s⇒ (Γ, s : D)(r) = Γ(r)
3. Se s na˜o e´ declarado em Γ, enta˜o Γ(s) e´ indefinido.
4. Para qualquer s´ımbolo, s a espe´cie de s em Γ e´ dada por kind(Γ(s)).
5. Se kind(Γ(s)) e´ CONSTANT ou VARIABLE, enta˜o o tipo de Γ(s) e´ o tipo associado a s
em Γ.
As regras de tipos em uma teoria simplesmente tipada sa˜o dadas pela definic¸a˜o recur-
siva de uma func¸a˜o parcial τ que associa:
(i) a um termo a, bem tipado em relac¸a˜o a um contexto Γ, um tipo τ(Γ)(a).
(ii) a um tipo A, bem formado em relac¸a˜o a um contexto Γ, a palavra-chave TYPE como
resultado de τ(Γ)(A).
(iii) a um contexto ∆, bem formado em relac¸a˜o a um contexto Γ, a palavra-chave CONTEXT
como resultado de τ(Γ)(∆).
Normalmente, as regras de tipos sa˜o apresentadas como regras de infereˆncia, mas em
PVS uma apresentac¸a˜o funcional e´ mais apropriada, pois desta forma obtemos uma argu-
mentac¸a˜o de correc¸a˜o de provas mais natural e direta. Assim temos a seguinte definic¸a˜o
para as regras de tipo, que em PVS representam a operac¸a˜o de typechecking.
Definic¸a˜o 3.3.2: Regras de tipos
τ()({}) = CONTEXT
τ()(Γ, s : TYPE) = CONTEXT, se Γ(s) e´ indefinido e τ()(Γ) = CONTEXT
τ()(Γ, c : T ) = CONTEXT, se Γ(c) e´ indefinido, τ(Γ)(T ) = TYPE
e τ()(Γ) = CONTEXT
τ()(Γ, x : VAR T ) = CONTEXT, se Γ(x) e´ indefinido, τ(Γ)(T ) = TYPE
e τ()(Γ) = CONTEXT
τ(Γ)(s) = TYPE, se kind(Γ(s)) = TYPE
τ(Γ)([A→ B]) = TYPE, se τ(Γ)(A) = τ(Γ)(B) = TYPE
τ(Γ)([A1, A2]) = TYPE, se τ(Γ)(Ai) = TYPE para 1 ≤ i ≤ 2
3.3 A Checagem de Tipos em PVS 30
τ(Γ)(s) = type(Γ(s)), se kind(Γ(s)) ∈ {CONSTANT, VARIABLE}
τ(Γ)(f a) = B, se τ(Γ)(f) = [A→ B] e τ(Γ)(a) = A
τ(Γ)(λ(x : T ) : a) = [T → τ(Γ, x : VAR T )(a)], se Γ(x) e´ indefinido
e τ(Γ)(T ) = TYPE
τ(Γ)((a1, a2)) = [τ(Γ)(a1), τ(Γ)(a2)]
τ(Γ)(pi a) = Ti, onde τ(Γ)(a) = [T1, T2]
Exemplo 3.3.1: Seja Ω um contexto onde bool : TYPE, TRUE : bool e FALSE : bool. Assim,
neste contexto as regras de tipo sa˜o dadas por:
τ()({}) = TYPE
τ()(Ω) = TYPE
τ(Ω)([[bool, bool]→ bool]) = TYPE
τ(Ω)((TRUE, FALSE)) = [bool, bool]
τ(Ω)(p2(TRUE, FALSE)) = bool
τ(Ω)(λ(x : boll) : TRUE) = [bool→ bool]
Note que nas regras de tipos a boa formac¸a˜o do contexto em questa˜o na˜o e´ explici-
tamente verificada, contudo tais regras preservam a boa formac¸a˜o do contexto em cada
chamada recursiva, enta˜o se o contexto inicial e´ bem formado, todos os contextos inter-
media´rios o sera˜o tambe´m.
Um termo bem tipado s com um tipo designado por τ dentro de um contexto Γ e´ dito
um termo de tipo τ(Γ)(s) no contexto Γ.
Expomos no Cap´ıtulo 4 a apresentac¸a˜o da formalizac¸a˜o de uma teoria para unificac¸a˜o
de primeira ordem. Obviamente esta teoria passou pela operac¸a˜o de checagem de tipos,
que e´ feita explicitamente atrave´s do comando M-x type-check-prove ou M-x tcp, mas
tambe´m e´ realizada automaticamente pelo PVS durante uma formalizac¸a˜o. Assim, alguns
TCC’s foram gerados e mostraremos abaixo um deles como exemplo.
Exemplo 3.3.2: Na Tabela 4.2.1 apresentamos um dos treˆs construtores, denominado
3.3 A Checagem de Tipos em PVS 31
resolving_diff, especificado com o objetivo de obter uma func¸a˜o que compute unificado-
res mais gerais. O resultado da checagem de tipos deste construtor gera sete TCC’s, um
deles e´ apresentado aqui para exemplificar a importaˆncia da checagem de tipos e como
obtemos resultados com o procedimento realizado pelo typechecking representado pelas re-
gras da Definic¸a˜o 3.3.2. Na Sec¸a˜o 4.2, apresentamos este construtor detalhadamente, mas
para entender este exemplo precisamos saber que este construtor age recursivamente em
dois paraˆmetros de tipo termo que sa˜o diferentes e especificados como tipos dependentes
unifica´veis. Assim, com a operac¸a˜o de checagem de tipos esperamos, durante o processo
de recursa˜o, aplicar este construtor a termos que ainda sejam unifica´veis e diferentes, isto
e´, preserva a tipagem. Portanto, o typechecker gera uma obrigac¸a˜o de prova, um TCC,
apresentado pelo PVS como segue:
Subtype TCC generated (at line 100, column 57) for
subtermOF(t, #(k + 1))
expected type {t: term |
unifiable(subtermOF(s, #(1 + k)), t) &
NOT subtermOF(s, #(1 + k)) = t}
proved - complete
resolving_diff_TCC4: OBLIGATION
FORALL (s: term, (t: term | unifiable(s, t) & s /= t), f: symbol,
st: {args: finite_sequence[term] | args‘length = arity(f)}):
NOT st‘length = 0 AND s = app(f, st) IMPLIES
(FORALL (fp: symbol,
stp:{args: finite_sequence[term] | args‘length = arity(fp)}):
t = app(fp, stp) IMPLIES
(FORALL (k: below[stp‘length]):
k = min({kk: below[stp‘length] |
subtermOF(s, #(kk + 1)) /= subtermOF(t, #(kk + 1))})
IMPLIES
unifiable(subtermOF(s, #(1 + k)), subtermOF(t, #(k + 1)))
&
NOT subtermOF(s, #(1 + k)) = subtermOF(t, #(k + 1))));
Este TCC foi gerado para o termo subtermOF(t, #(k + 1)) e o tipo esperado para este
termo e´ que ele seja unifica´vel com o termo subtermOF(s, #(k + 1)) e diferente deste, esta
informac¸a˜o vem descrita no “cabec¸alho” do TCC. Logo no corpo do TCC, onde temos a
obrigac¸a˜o de prova a ser demonstrada, isto e´, sob as hipo´teses de que s e t sejam dois
termos unifica´veis e diferentes, onde o termo s e´ uma aplicac¸a˜o, devemos ter que o termo
subtermOF(t, #(k + 1)) e´ do tipo esperado. Esta verificac¸a˜o se faz necessa´ria devido ao
3.4 As Regras de Prova do PVS 32
cara´ter recursivo do construtor resolving_diff.
O PVS ainda oferece o recurso de declarar tipos dependentes, isto e´, alguns dos tipos
dos paraˆmetros de uma especificac¸a˜o podem ser dependentes de paraˆmetros anteriores.
Este recurso foi importante na especificac¸a˜o proposta neste trabalho, pois nos permitiu
trabalhar com termos unifica´veis, como observamos no exemplo anterior, onde temos que
sobre o termo t existe a condic¸a˜o unifiable(s, t), que indica que sobre o tipo do termo
t existe a condic¸a˜o de que t seja unifica´vel com o termo s.
3.4 As Regras de Prova do PVS
As regras de prova do PVS sa˜o apresentadas em termos de ca´lculo de sequentes. Como
mencionamos na Sec¸a˜o 3.2, um sequente e´ da forma Σ `Γ Λ, onde Γ e´ o contexto, Σ e´ o
conjunto das fo´rmulas que compo˜em o antecedente e Λ representa o conjunto das fo´rmulas
que compo˜em o consequente. Sobre um sequente desta forma devemos fazer a seguinte
leitura: a conjunc¸a˜o das fo´rmulas de Σ implica a disjunc¸a˜o das fo´rmulas de Λ.
3.4.1 Regras Estruturais
Com as regras estruturais podemos rearranjar um sequente ou enfraqueceˆ-lo, introduzindo
novas fo´rmulas na conclusa˜o.
A regra (W ) apresentada em 3.4.1, representa uma poderosa regra de enfraquecimento.
Todas as regras estruturais podem ser expressas em termos desta. Esta regra permite
derivar um sequente mais fraco de um mais forte, por meio de introduc¸a˜o de fo´rmulas no
antecedente ou no consequente. Este fato e´ expresso pela condic¸a˜o que se impo˜e de que
Σ1 ⊆ Σ2 e Λ1 ⊆ Λ2.
Σ1 `Γ Λ1
Σ2 `Γ Λ2 (W ), se Σ1 ⊆ Σ2 e Λ1 ⊆ Λ2 (3.4.1)
As regras de contrac¸a˜o (C `) e (` C), apresentadas abaixo, permitem substituir
va´rias ocorreˆncias de uma mesma fo´rmula no antecedente ou no consequente por uma
3.4 As Regras de Prova do PVS 33
u´nica ocorreˆncia.
a,Σ `Γ Λ
a, a,Σ `Γ Λ (C `)
Σ `Γ a,Λ
Σ `Γ a, a,Λ (` C)
As regras de comutac¸a˜o (X `) e (` X), afirmam que a ordem das fo´rmulas tanto do
antecedente quanto do consequente e´ insignificante.
Σ1, b, a,Σ2 `Γ Λ
Σ1, a, b,Σ2 `Γ Λ (X `)
Σ `Γ Λ1, b, a,Λ2
Σ `Γ Λ1, a, b,Λ2 (` X)
3.4.2 Regra de Corte
A regra de corte (Cut) pode ser usada para introduzir a ana´lise de casos sobre uma fo´rmula
a, dentro de uma prova de um sequente da forma Σ `Γ Λ. Isto leva a dois sub-objetivos
da forma Σ, a `Γ Λ e Σ `Γ a,Λ, que podem ser vistos como assumindo a em um ramo da
prova e ¬a no outro ramo da prova.
(τ(Γ)(a) ∼ bool)Γ Σ, a `Γ Λ Σ `Γ a,Λ
Σ `Γ Λ (Cut)
3.4.3 Regras para Axiomas Proposicionais
Na regra (Ax), simplesmente temos afirmac¸a˜o trivial de que a segue de a.
Σ, a `Γ a,Λ (Ax)
As regras (FALSE `) e (` TRUE), afirmam que se em um dado sequente existe uma
ocorreˆncia de FALSE no antecedente ou uma ocorreˆncia de TRUE no consequente, enta˜o este
sequente e´ um axioma.
Σ, FALSE `Γ Λ (FALSE `) Σ `Γ TRUE,Λ (` TRUE)
3.4 As Regras de Prova do PVS 34
3.4.4 Regras de Contexto
Algumas fo´rmulas valem em um contexto simplesmente porque elas ja´ fazem parte do
contexto, ou como uma fo´rmula mesmo ou como uma declarac¸a˜o de constante. Nisto
consiste a assertiva das regras (ContextFormula) e (ContextDefinition) abaixo.
`Γ a (ContextFormula), se a e´ uma fo´rmula em Γ.
`Γ s = a (ContextDefinition), se s : T = a e´ uma definic¸a˜o de constante em Γ
Um contexto Γ pode ser estendido, atrave´s das regras (Context `) e (` Context), por
fo´rmulas no antecedente ou negac¸a˜o de fo´rmulas no consequente.
Σ, a `Γ,a Λ
Σ, a `Γ Λ (Context `)
Σ `Γ,¬a a,Λ
Σ `Γ a,Λ (` Context)
A regra (ContextW ), e´ uma regra de enfraquecimento do contexto que e´ bastante u´til,
pois mostra que uma derivac¸a˜o e´ mono´tona em relac¸a˜o a um contexto.
Σ `Γ Λ
Σ `Γ′ Λ (ContextW ), se Γ e´ um prefixo de Γ
′
3.4.5 Regras Condicionais
As regras (IF `) e (` IF ) teˆm o objetivo de eliminar as ocorreˆncias de IF-THEN-ELSE em
uma prova. Contudo estas regras na˜o sa˜o usuais pois elas aumentam o contexto.
Σ, a, b `Γ,a Λ Σ, c `Γ,¬a a,Λ
Σ, IF(a, b, c) `Γ Λ (IF `)
Σ, a `Γ,a b,Λ Σ `Γ,¬a a, c,Λ
Σ `Γ IF(a, b, c),Λ (` IF )
3.4 As Regras de Prova do PVS 35
3.4.6 Regras de Igualdade
As regras de transitividade e simetria para a igualdade podem ser derivadas das regras
de igualdade (Refl) e (Repl) abaixo. Nestas regras a notac¸a˜o a[e] indica uma ou mais
ocorreˆncias de e na fo´rmula a, tal que na˜o existem ocorreˆncias de varia´veis livres em e.
Similarmente, a notac¸a˜o Λ[e] indica ocorreˆncias de e em Λ.
Σ `Γ a = a,Λ (Refl)
a = b,Σ[b] `Γ Λ[b]
a = b,Σ[a] `Γ Λ[a] (Repl)
3.4.7 Regras de Igualdade Booleana
Na regra (Repl TRUE) temos a asserc¸a˜o de que uma fo´rmula a no antecedente pode ser
tratada como uma fo´rmula de igualdade no antecedente da forma a = TRUE. Similarmente
a regra (Repl FALSE) asserta que uma fo´rmula a no consequente pode ser vista como uma
igualdade da forma a = FALSE, no antecedente. Ja´ a regra TRUE-FALSE, afirma que as
constantes booleanas TRUE e FALSE sa˜o distintas.
Σ[TRUE], a `Γ Λ[TRUE]
Σ[a], a `Γ Λ[a] (Refl TRUE)
Σ[FALSE], a `Γ Λ[FALSE]
Σ[a] `Γ a,Λ[a] (Repl FALSE)
Σ, TRUE = FALSE `Γ Λ (TRUE− FALSE)
3.4.8 Regras de Reduc¸a˜o
As regras de reduc¸a˜o (β) e (pi), sa˜o axiomas de igualdade, que nos possibilitam reali-
zar simplificac¸o˜es o´bvias, para aplicac¸o˜es envolvendo lambda abstrac¸o˜es e projec¸a˜o de
produtos.
`Γ (λ(x : T ) : a)(b) = a[b/x] (β) `Γ pi(a1, a2) = ai (pi), para i = 1, 2
3.4 As Regras de Prova do PVS 36
3.4.9 Regras de Extensionalidade
As regras de extensionalidade (FunExt) e (TupExt), sa˜o regras que estabelecem igual-
dade para expresso˜es funcionais e de produto respectivamente. A regra de extensionali-
dade para func¸o˜es introduz uma constante de Skolem s para estabelecer que duas func¸o˜es
f e g sa˜o iguais quando os resultados das aplicac¸o˜es destas func¸o˜es a um argumento qual-
quer de s sa˜o iguais. A regra de extensionalidade para produto nos diz que dois produtos
sa˜o iguais se as suas projec¸o˜es correspondentes sa˜o iguais.
Σ `Γ,s:A (f s) =B[s/x] (g s),Λ
Σ `Γ f =[x:A→B] g,Λ (FunExt), se Γ(s) e´ indefinido
Σ `Γ p1(a) =T1 p1(b),Λ Σ `Γ p2(a) =T2[(p1 a)/x] p2(b),Λ
Σ `Γ a =[x:T1T2] b,Λ (TupExt)
3.4.10 Regra de Restric¸a˜o de Tipo
A regra de restric¸a˜o de tipo (Typepred), e´ usada para suprir a necessidade de uma regra
que introduza a restric¸a˜o de tipo sobre um termo como uma fo´rmula no antecedente de
um dado sequente.
τ(Γ)(a) = A pi(A)(a),Σ `Γ Λ
Σ `Γ Λ (Typepred)
Exemplo 3.4.1: Vejamos por exemplo a prova do teorema Vars_is_var, da sub teoria
subterm, onde formalizamos o fato de que o conjunto de varia´veis de um termo que e´
uma varia´vel e´ igual ao pro´prio termo. Nesta prova o primeiro sequente e´ apresentado da
seguinte forma:
|-------
{1} FORALL (t: term[variable, symbol, arity]):
vars?(t) => Vars(t) = ({y: (V) | y = t})
3.4 As Regras de Prova do PVS 37
A este sequente aplicamos a regra de prova skeep, a fim de skolemizar as varia´veis
ligadas. Em seguida decompomos a igualdade de conjuntos presente na fo´rmula, com a
regra decompose-equality e com isto temos um novo sequente:
[-1] vars?(t)
|-------
{1} Vars(t)(x!1) = (x!1 = t)
Neste ponto a estrate´gia adotada e´ a de converter a igualdade da fo´rmula 1 em uma
dupla implicac¸a˜o com a regra iff. Em seguida expandimos a definic¸a˜o de Vars e realizamos
uma simplificac¸a˜o proposicional, o que faz com que a prova se divida em dois sub-objetivos,
o primeiro deles dado por:
{-1} EXISTS (p: positions?(t)): subtermOF(t, p) = x!1
[-2] vars?(t)
|-------
{1} x!1 = t
No objetivo acima, pela fo´rmula -1 que existe uma posic¸a˜o p, pertencente ao conjunto
de posic¸o˜es do termo t, tal que o subtermo de t nesta posic¸a˜o e´ igual a` varia´vel x!1. Mas
como o termo t e´ uma varia´vel, temos que esta posic¸a˜o e´ a raiz, o que implica que t e´
igual x!1. Assim, skolemizando a varia´vel da fo´mula -1 e expandindo algumas definic¸o˜es,
chegamos a esta conclusa˜o. E isto completa este ramo da prova, pois a fo´mula 1 representa
a negac¸a˜o do fato de t ser igual x!1.
No ramo seguinte da prova, temos a outra parte da dupla-implicac¸a˜o, representada
pelo seguinte sequente:
{-1} x!1 = t
[-2] vars?(t)
|-------
{1} EXISTS (p: positions?(t)): subtermOF(t, p) = x!1
Note que agora, sabendo que t e´ igual x!1, pela fo´rmula -1, e que t e´ uma varia´vel,
pela fo´rmula -2, queremos verificar que existe uma posic¸a˜o p, pertencente ao conjunto
de posic¸o˜es do termo t, tal que o subtermo de t nesta posic¸a˜o e´ igual a` x!1. Mas pela
fo´rmula 1, temos que tal posic¸a˜o na˜o existe. Enta˜o a estrate´gia e´ instanciar a fo´rmula 1
com a posic¸a˜o raiz. Com isto novamente completamos este ramo da prova, apo´s expandir
a definic¸a˜o de subtermOF. Em seguida provamos em um outro objetivo que a posic¸a˜o raiz
faz parte do conjunto de posic¸o˜es do termo t e com isto completamos a formalizac¸a˜o deste
lema.
3.5 Sub-teorias da Teoria TRS 38
3.5 Sub-teorias da Teoria TRS
Nesta sec¸a˜o apresentamos algumas sub-teorias da teoria trs, onde encontramos as especi-
ficac¸o˜es e formalizac¸o˜es dos conceitos iniciais definidos no Cap´ıtulo 2, como por exemplo
as definic¸o˜es de termos, posic¸o˜es, substituic¸o˜es, etc. A especificac¸a˜o destes conceitos e a
formalizac¸a˜o de va´rios resultados acerca dos mesmos, compo˜e o que chamamos de uma
a´lgebra de termos e formam base para o desenvolvimento da sub-teoria unification.
3.5.1 A Sub-teoria term
Como vimos na Definic¸a˜o 2.2.2, termos sa˜o definidos recursivamente. Contudo o PVS
na˜o permite definic¸o˜es de tipos recursivos, pois uma definic¸a˜o ou declarac¸a˜o de tipo em
um contexto deve conter somente s´ımbolos previamente declarados no contexto. Para
contornar esta situac¸a˜o o PVS oferece o mecanismo chamado DATATYPE, que e´ uma forma
de definic¸a˜o de tipo recursivo. Para mais informac¸o˜es sobre o mecanismo abstract datatype
do PVS veja [18]. Assim, a forma que se encontrou de especificar a noc¸a˜o de termos em
PVS foi utilizando a ferramenta DATATYPE.
A especificac¸a˜o de termos e´ apresentada na sub-teoria term como abaixo:
term[variable: TYPE+, symbol: TYPE+, arity: [symbol -> nat]] : DATATYPE
BEGIN
vars(v: variable): vars?
app(f:symbol, args:{args:finite_sequence[term] | args‘length=arity(f)}): app?
END term
Note que os termos sa˜o definidos como sendo uma varia´vel, ou uma aplicac¸a˜o de um
s´ımbolo f a um argumento args composto por uma sequeˆncia finita de termos, sendo
que o s´ımbolo f tem aridade igual ao comprimento da sequeˆncia de termos. Veja que a
chamada recursiva do DATATYPE e´ promovida por args.
3.5 Sub-teorias da Teoria TRS 39
3.5.2 A Sub-teoria positions
A sub-teoria positions conte´m a especificac¸a˜o da noc¸a˜o de conjunto de posic¸o˜es de um
termo e formalizac¸o˜es de algumas propriedades envolvendo posic¸o˜es.
positionsOF(t: term): RECURSIVE positions =
(CASES t OF
vars(t): only_empty_seq,
app(f, st): IF length(st) = 0
THEN
only_empty_seq
ELSE
union(only_empty_seq,
IUnion((LAMBDA (i: upto?(length(st))):
catenate(i, positionsOF(st(i-1)) ))))
ENDIF
ENDCASES)
MEASURE t BY <<
Note que no construtor positionsOF, obtemos um tipo positions, que e´ um conjunto
de posic¸o˜es. Por sua vez, uma posic¸a˜o e´ definida como um tipo finseq[posnat], isto
e´, uma sequeˆncia finita de naturais. O conjunto de posic¸o˜es de um termo, obtido pelo
construtor positionsOF, e´ especificado conforme a Definic¸a˜o 2.2.3.
Dentre os lemas formalizados na sub-teoria positions, os mais importantes para o
desenvolvimento da sub-teoria unification e que foram mais diretamente usados nas
formalizac¸o˜es apresentadas em unification foram os lemas positions_of_terms_finite
e positions_of_arg, cuja especificac¸a˜o apresentamos abaixo:
positions_of_terms_finite : LEMMA is_finite(positionsOF(t))
positions_of_arg : LEMMA
FORALL ( (s : term | app?(s) ), k : below[length(args(s))] ) :
positionsOF(s)( #[posnat]( k+1 ) )
O primeiro estabelece que o conjunto de posic¸o˜es de um termo e´ finito. O segundo
estabelece que se um termo s e´ uma aplicac¸a˜o e se k e´ um natural menor que o comprimento
da sequeˆncia de argumentos do termo s, enta˜o k+1 pertence ao conjunto de posic¸o˜es do
termo s.
3.5 Sub-teorias da Teoria TRS 40
3.5.3 A Sub-teoria subterm
Na sub-teoria subterm temos a especificac¸a˜o da definic¸a˜o de subtermo, encontrada na
Definic¸a˜o 2.2.4.
subtermOF(t: term, (p: positions?(t))): RECURSIVE term =
(IF length(p) = 0
THEN
t
ELSE
LET st = args(t),
i = first(p),
q = rest(p) IN
subtermOF(st(i-1), q)
ENDIF)
MEASURE length(p)
A especificac¸a˜o do construtor subtermOF e´ a principal desta teoria, contudo encontra-
mos a especificac¸a˜o de outra definic¸a˜o importante, a de conjunto de varia´veis de um termo
t, denotado por Vars(t).
Temos tambe´m na teoria subterm a formalizac¸a˜o de va´rios resultados acerca de termos
e subtermos que foram largamente utilizados nas formalizac¸o˜es da sub-teoria unification.
Por exemplo, temos a formalizac¸a˜o dos lemas vars_of_term_finite e term_eq_subterm,
cuja especificac¸a˜o apresentamos abaixo:
vars_of_term_finite: LEMMA is_finite(Vars(t))
term_eq_subterm : LEMMA
positionsOF(s)(p) AND subtermOF(s, p) = s IMPLIES p = empty_seq
O primeiro estabelece que o conjunto de varia´veis de um termo e´ finito. Este resultado
e´ certo, pois como vimos os termos sa˜o definidos como sendo finitos. O segundo estabelece
que se p pertence ao conjunto de posic¸o˜es de um termo s e se o subtermo de s nesta posic¸a˜o
e´ o pro´prio s, enta˜o a posic¸a˜o p e´ a posic¸a˜o raiz ou, como tratado na especificac¸a˜o, e´ uma
sequeˆncia vazia.
3.5 Sub-teorias da Teoria TRS 41
3.5.4 A Sub-teoria substitution
Na sub-teoria substitution encontramos as especificac¸o˜es que, de certa forma, sa˜o as mais
importantes para o desenvolvimento da sub-teoria unification. Temos nesta subteoria a
especificac¸a˜o das noc¸o˜es de substituic¸a˜o, domı´nio e imagem de uma substituic¸a˜o, conforme
apresentado na Definic¸a˜o 2.2.6, ale´m da definic¸a˜o de conjunto de varia´veis da imagem de
uma substituic¸a˜o.
Dom(sig): set[(V)] = {x: (V) | sig(x) /= x}
Ran(sig): set[term] =
{y: term | EXISTS (x: (V)): member(x, Dom(sig)) & y = sig(x)}
VRan(sig): set[(V)] = IUnion(LAMBDA (x | Dom(sig)(x)): Vars(sig(x)))
Sub?(sig): bool = is_finite(Dom(sig))
Observamos que sig e´ uma varia´vel declarada no preaˆmbulo da sub-teoria substitu-
tion como sendo do tipo [(V) -> term], isto e´, sig e´ uma aplicac¸a˜o de um conjunto de
varia´veis em um conjunto de termos, sem nenhuma restric¸a˜o sobre estes conjuntos. Assim,
a forma escolhida para definir substituic¸a˜o, foi definir um novo tipo Sub, que corresponde
a responder verdadeiro ou falso para a questa˜o de o domı´nio de sig ser finito.
Temos ainda na sub-teoria substitution a especificac¸a˜o da definic¸a˜o de extensa˜o ho-
meomo´rfica de uma substituic¸a˜o a um conjunto de termos. Tal especificac¸a˜o foi de grande
importaˆncia para o desenvolvimento da sub-teoria unification.
3.5 Sub-teorias da Teoria TRS 42
ext(sigma)(t): RECURSIVE term =
CASES t OF
vars(t): sigma(t),
app(f, st): IF length(st) = 0
THEN t
ELSE
LET
sst = (# length := st‘length,
seq := (LAMBDA (n: below[st‘length]):
ext(sigma)(st(n)))#)
IN
app(f, sst)
ENDIF
ENDCASES
MEASURE t BY <<
Encontramos ainda nesta teoria a formalizac¸a˜o de va´rios resultados sobre substituic¸o˜es
que foram largamente aplicados durante as formalizac¸o˜es da sub-teoria unification. Por
exemplo, temos alguns resultados importantes sobre composic¸a˜o de substituic¸o˜es:
subs_o: LEMMA Sub?(comp(sigma, tau))
ext_o: LEMMA ext(comp(sigma, tau)) = ext(sigma) o ext(tau)
o_ass: LEMMA comp(comp(sigma, delta), tau) = comp(sigma, comp(delta, tau))
O lema subs_o estabelece que a composic¸a˜o de substituic¸o˜es e´ ainda uma substituic¸a˜o.
O lema ext_o estabelece que a extensa˜o homeomo´rfica de uma composic¸a˜o de duas subs-
tituic¸o˜es e´ igual a` composic¸a˜o das extenso˜es homeomo´rficas das substituic¸o˜es. O lema
o_ass estabelece que a composic¸a˜o de substituic¸o˜es e´ associativa.
Cap´ıtulo 4
Formalizac¸a˜o da Teoria de Unificac¸a˜o
Neste cap´ıtulo vamos apresentar a especificac¸a˜o da teoria unification, que constru´ımos
buscando formalizar o teorema de existeˆncia de unificadores mais gerais em teorias de pri-
meira ordem. Para tanto, especificamos uma func¸a˜o composta de treˆs construtores para
representar a versa˜o do algoritmo de unificac¸a˜o de Robinson apresentada no Cap´ıtulo 2,
restrita a termos unifica´veis. Na Sec¸a˜o 4.1, apresentamos a estrutura hiera´rquica da teoria
unification. Na Sec¸a˜o 4.2, vamos explicar a organizac¸a˜o desta teoria e os principais cons-
trutores especificados. Na Sec¸a˜o 4.3, apresentamos de maneira detalhada a formalizac¸a˜o
do teorema que fala sobre a existeˆncia de mgu’s, que e´ baseado no fato de que o algoritmo
de unificac¸a˜o computa unificadores mais gerais. Na Sec¸a˜o 4.4 apresentamos a formaliza-
c¸a˜o dos lemas onde afirmamos que a substituic¸a˜o, computada na especificac¸a˜o proposta,
e´ de fato um mgu de dois termos unifica´veis. Na Sec¸a˜o 4.5, apresentamos a formalizac¸a˜o
de lemas importantes, onde temos garantida a terminalidade do algoritmo de unificac¸a˜o,
e que foram fundamentais para a formalizac¸a˜o dos lemas da sec¸a˜o anterior. Com estes
teoremas provamos a completude da versa˜o do algoritmo de unificac¸a˜o de Robinson.
4.1 Estrutura Hiera´rquica da Teoria unification
Nesta sec¸a˜o vamos apresentar a hierarquia da teoria unification, isto e´, veremos so-
bre quais teorias a teoria unification foi constru´ıda. Na Figura 4.1.1, mostramos esta
estrutura hiera´rquica, onde e´ poss´ıvel observar quais sub-teorias da teoria trs foram
importadas pela sub-teoria unification, sendo que apenas a sub-teoria substitution e´
importada diretamente. A teoria ars [7], representa um conjunto de sub-teorias para
43
4.2 Organizac¸a˜o da Teoria unification 44
Sistemas Abstratos de Reduc¸a˜o, a hierarquia desta teoria pode ser observada em [8]. As
teorias identity, finite_sets e finite_sequences, sa˜o as teorias para definir a func¸a˜o
identidade, conjuntos finitos e sequeˆncias finitas, respectivamante, importadas do prelu´dio
do PVS. Para mais informac¸o˜es sobre a biblioteca do prelu´dio do PVS ver [20].
unification


substitution


identity extending_rename

compatibility
 
replacement

finite_sets ars[term]
subterm
 
IUnion_extra positions

oo

variables_term

finite_sequences_extras

term // finite_sequences
Figura 4.1.1: Estrutura hiera´rquica da sub-teoria unification
4.2 Organizac¸a˜o da Teoria unification
A fim de especificar uma func¸a˜o que compute unificadores mais gerais para dois ter-
mos unifica´veis, foram definidos separadamente treˆs construtores. Observe que estamos
considerando termos unifica´veis, isto e´, na˜o consideramos para esta especificac¸a˜o o caso
de falha no processo de unificac¸a˜o. Fazemos isto porque queremos demonstrar especifi-
camente que existe um mgu, computado via algoritmo de unificac¸a˜o, para dois termos
unifica´veis quaisquer, que e´ o resultado necessa´rio na formalizac¸a˜o do teorema dos pares
cr´ıticos de Knuth-Bendix [6]. Apresentamos a seguir a descric¸a˜o destes construtores bem
como a especificac¸a˜o de cada um. Depois apresentaremos brevemente as sec¸o˜es da teoria
unification onde formalizamos va´rias propriedades destes construtores.
4.2 Organizac¸a˜o da Teoria unification 45
Tabela 4.2.1: Especificac¸a˜o do construtor resolving_diff
resolving_diff(s : term, (t : term | unifiable(s,t) & s /= t ) ):
RECURSIVE position =
(CASES s OF
vars(s) : empty_seq,
app(f, st) :
IF length(st) = 0 THEN empty_seq
ELSE
(CASES t OF
vars(t) : empty_seq,
app(fp, stp) :
LET k : below[length(stp)] =
min({kk : below[length(stp)] |
subtermOF(s,#(kk+1)) /= subtermOF(t,#(kk+1))}) IN
add_first(k+1,
resolving_diff(subtermOF(s,#(k+1)),subtermOF(t,#(k+1))))
ENDCASES)
ENDIF
ENDCASES)
MEASURE s BY <<
resolving diff: Na Tabela 4.2.1 temos a estrutura da especificac¸a˜o deste construtor,
que toma como paraˆmetros dois termos unifica´veis e diferentes s e t e retorna uma
posic¸a˜o p, que e´ a posic¸a˜o onde ocorre a primeira diferenc¸a entre os termos s e t. Note
que neste construtor os termos do argumento de entrada devem ser, na˜o somente
unifica´veis, mas tambe´m diferentes, isto porque simplesmente na˜o faz sentido buscar
diferenc¸as em termos iguais. Esta posic¸a˜o e´ obtida buscando-se a diferenc¸a mais a
esquerda e mais externa entre os dois termos. Note que nesta posic¸a˜o, se os termos
sa˜o unifica´veis, devemos ter que s|p e´ uma varia´vel ou t|p e´ uma varia´vel. Este
construtor age recursivamente e tem como medida a ordem bem-fundada <<, que
e´ gerada automaticamente pela operac¸a˜o de checagem de tipos (typechecking) da
sub-teoria term. Podemos interpretar esta medida como uma ordem de imersa˜o
de subtermos em termos, isto e´, dado um termo finito s qualquer subtermo de s
tem comprimento menor que s, o que significa que a cardinalidade do conjunto
de posic¸o˜es de qualquer subtermo de s e´ menor que a cardinalidade do conjunto de
posic¸o˜es de s, Definic¸a˜o 2.2.3. Isto torna a recursa˜o finita, pois consideramos termos
com um conjunto finito de posic¸o˜es, segundo o lema positions_of_terms_finite
formalizado na sub-teoria positions.
4.2 Organizac¸a˜o da Teoria unification 46
Tabela 4.2.2: Especificac¸a˜o do construtor sub_of_frst_diff
sub_of_frst_diff(s:term, (t:term | unifiable(s,t) & s /= t )): Sub =
LET k : position = resolving_diff(s,t) IN
LET sp = subtermOF(s,k) , tp = subtermOF(t,k) IN
IF vars?(sp)
THEN (LAMBDA (x : (V)) : IF x = sp THEN tp ELSE x ENDIF)
ELSE (LAMBDA (x : (V)) : IF x = tp THEN sp ELSE x ENDIF)
ENDIF
sub of frst diff: Na Tabela 4.2.2 apresentamos a especificac¸a˜o deste construtor, que
tambe´m toma como argumentos dois termos unificave´is e diferentes s e t, e retorna
uma substituic¸a˜o. O objetivo deste construtor e´ computar uma substituic¸a˜o que
resolva a primeira diferenc¸a entre os termos s e t. Isto e´ feito a partir da posic¸a˜o
computada pelo construtor resolving_diff. Portanto, se p = resolving_diff(s, t)
e´ a posic¸a˜o onde ocorre a primeira diferenc¸a mais a direita e mais externa entre
os termos s e t e se σ = sub_of_frst_diff(s, t), enta˜o σˆ(s|p) = σˆ(t|p). Veja que
os termos do argumento de entrada deste construtor tambe´m devem ser diferentes,
ja´ que partimos da posic¸a˜o encontrada pelo construtor anterior. A forma como
obtemos esta substituic¸a˜o neste construtor e´ a seguinte: se p e´ a posic¸a˜o obtida
em resolving_diff(s, t), fazemos uma verificac¸a˜o para saber se o subtermo s|p e´
uma varia´vel, digamos x, e caso o seja retorna-se uma substituic¸a˜o que liga x ao
subtermo t|p, isto e´, σ := {x/t|p}. Caso contra´rio, devemos ter que o subtermo t|p
e´ uma varia´vel, digamos x, e neste caso a substituic¸a˜o e´ dada por σ := {x/s|p}.
unification algorithm: Apresentamos na Tabela 4.2.3 a especificac¸a˜o deste construtor,
que toma como argumentos dois termos unifica´veis s e t, e computa uma substi-
tuic¸a˜o σ, que e´ um mgu de s e t. Este fato esta´ formalizado em dois lemas que
apresentamos na Sec¸a˜o 4.4. Note que agora na˜o exigimos que os termos sejam
diferentes, isto porque neste construtor estamos interessados em considerar a subs-
tituic¸a˜o identidade, que e´ claramente a substituic¸a˜o que soluciona a equac¸a˜o s
?
= t
quando temos s = t. Assim, no caso em que os termos s e t sa˜o iguais, unifi-
cation_algorithm retorna a substituic¸a˜o identidade, caso s e t sejam diferentes,
4.2 Organizac¸a˜o da Teoria unification 47
Tabela 4.2.3: Especificac¸a˜o do construtor unification_algorithm
unification_algorithm(s : term, (t : term | unifiable(s,t))) :
RECURSIVE Sub =
IF s = t THEN identity
ELSE LET sig = sub_of_frst_diff(s, t) IN
comp( unification_algorithm((ext(sig))(s) , (ext(sig)(t))) , sig)
ENDIF
MEASURE Card(union(Vars(s), Vars(t)))
unification_algorithm retorna uma substituic¸a˜o dada pela composic¸a˜o da substi-
tuic¸a˜o obtida em sub_of_frst_diff, digamos σ1, com a substituic¸a˜o dada por mais
um passo de unification_algorithm aplicado a σˆ1(s) e σˆ1(t). Portanto, se no k-
e´simo passo o construtor retornar uma substituic¸a˜o σ tal que σˆ(s) = σˆ(t), enta˜o
devemos ter σ = id ◦ σk ◦ . . . ◦ σ1, onde
σj = unification_algorithm(σˆj−1(. . . σˆ1(s)), σˆj−1(. . . σˆ1(t))),
para j = 1, . . . , k. Isto significa que unification_algorithm age recursivamente
e esta recursa˜o e´ finita pois adotamos como medida a cardinalidade do conjunto
Vars(s) ∪ Vars(t), que e´ um conjunto finito, pois o conjunto de varia´veis de um
termo finito e´ finito, e a cada passo eliminamos uma varia´vel de um conjunto finito
de varia´veis. O fato de que para um termo s, Vars(s) e´ finito esta´ formalizado no
lema vars_of_term_finite da sub-teoria subterm.
Assim, com os treˆs construtores apresentados acima, especificamos uma func¸a˜o para
computar unificadores mais gerais de dois termos unifica´veis. Mas e´ preciso verificar que
a especificac¸a˜o destes construtores esta´ correta e que realmente obtemos um mgu com o
aux´ılio desta especificac¸a˜o.
Para verificar que na˜o ha´ falhas na especificac¸a˜o realizamos um procedimento de che-
cagem de tipos, invocado pela rotina type check prove. Ao realizar este procedimento o
PVS tenta verificar automaticamente obrigac¸o˜es de prova geradas pelo typecheker, con-
tudo ocorrem casos em que estas obrigac¸o˜es de prova sa˜o geradas mas o provador do PVS e´
incapaz de verifica´-las automaticamente, pois ocorrem situac¸o˜es em que uma estrate´gia de
4.2 Organizac¸a˜o da Teoria unification 48
prova mais especifica e direcionada faz-se necessa´ria. Nestes casos fazemos a verificac¸a˜o de
tais obrigac¸o˜es de prova, com o aux´ılio das ferramentas de prova que o PVS possui. Estas
obrigac¸o˜es de prova, que tambe´m podem surgir como sub-objetivos de prova durante uma
demonstrac¸a˜o, sa˜o denominadas type correctness conditions (ou TCC), e surgem quando
um termo passa por uma checagem de tipos confrontada com um subtipo esperado de
predicado.
Para verificar que os treˆs construtores juntos realmente computam um mgu de dois
termos unifica´veis foram formalizados va´rios teoremas auxiliares, onde provamos va´rias
propriedades sobre cada um dos construtores. Estes teoremas foram organizados em treˆs
sec¸o˜es da teoria unification da seguinte forma:
Lemmas about “resolving diff”: Como o pro´prio nome da sec¸a˜o sugere, demonstra-
mos aqui va´rios lemas sobre o construtor resolving_diff. Para demonstrar os
lemas desta sec¸a˜o foram fundamentais os TCC’s gerados pela checagem de tipos
do construtor resolving_diff. Na Tabela 4.2.4, apresentamos a especificac¸a˜o des-
tes lemas, e em seguida, comentamos brevemente em que consiste cada um deles.
Observe que em todos os lemas desta sec¸a˜o temos como hipo´tese que os termos s
e t sa˜o unifica´veis e diferentes. Na descric¸a˜o dos lemas feita a seguir, denotaremos
a posic¸a˜o onde ocorre a primeira diferenc¸a entre os termo s e t por p, isto e´, p =
resolving_diff(s, t).
resol_diff_nonempty_implies_funct_terms: Neste lema provamos que se p na˜o e´ a
posic¸a˜o raiz, enta˜o os dois termos sa˜o funcionais.
resol_diff_to_rest_resol_diff: Este e´ um lema construtivo, onde mostramos que
se p na˜o e´ a posic¸a˜o raiz e se p = i ◦ q, enta˜o a primeira diferenc¸a entre os
subtermos s|i e t|i esta´ na posic¸a˜o q.
position_s_resolving_diff e position_t_resolving_diff: Nestes lemas provamos
que p ∈ Pos(s) e p ∈ Pos(t), respectivamente. Note que precisamos destes dois
lemas porque o termo t possui um tipo dependente em relac¸a˜o ao termo s.
resolving_diff_has_diff_argument: Neste lema provamos que s|p 6= t|p. Note que
este lema e´ importante, pois no construtor sub_of_frst_diff precisamos deste
4.2 Organizac¸a˜o da Teoria unification 49
Tabela 4.2.4: Especificac¸a˜o dos lemas sobre o construtor resolving_diff
resol_diff_nonempty_implies_funct_terms : LEMMA
FORALL (s: term, (t: term | unifiable(s, t) & s /= t)):
resolving_diff(s,t) /= empty_seq IMPLIES
(app?(s) AND app?(t))
resol_diff_to_rest_resol_diff : LEMMA
FORALL (s: term, (t: term | unifiable(s, t) & s /= t)):
LET rd = resolving_diff(s,t) IN
rd /= empty_seq IMPLIES
resolving_diff(subtermOF(s,#(first(rd))),
subtermOF(t,#(first(rd)))) = rest(rd)
position_s_resolving_diff : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t, p : position):
p = resolving_diff(s, t) IMPLIES positionsOF(s)(p);
position_t_resolving_diff : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t, p : position):
p = resolving_diff(s, t) IMPLIES positionsOF(t)(p);
resolving_diff_has_diff_argument : LEMMA
FORALL (s : term, t : term | unifiable(s,t) & s /= t,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
p = resolving_diff(s, t) IMPLIES
subtermOF(s, p) /= subtermOF(t, p)
resolving_diff_has_unifiable_argument : LEMMA
FORALL (s : term, t : term | unifiable(s,t) & s /= t,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
p = resolving_diff(s, t) IMPLIES
unifiable(subtermOF(s, p), subtermOF(t, p))
resolving_diff_vars : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
p = resolving_diff(s, t) IMPLIES
vars?(subtermOF(s, p)) OR vars?(subtermOF(t, p))
resultado, que alia´s surge como um TCC de sub_of_frst_diff.
resolving_diff_has_unifiable_argument: Neste lema provamos que s|p e t|p sa˜o
unifica´veis. Da mesma forma que o anterior, este lema tambe´m e´ importante,
pois no construtor sub_of_frst_diff precisamos deste resultado, que tambe´m
surge como um TCC de sub_of_frst_diff.
resolving_diff_vars: Neste lema provamos que ou s|p e´ uma varia´vel, ou t|p e´ uma
4.2 Organizac¸a˜o da Teoria unification 50
Tabela 4.2.5: Especificac¸a˜o de alguns lemas sobre o construtor sub_of_frst_diff
dom_sub_of_frst_diff_is : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t, sig : Sub):
sig = sub_of_frst_diff(s, t) AND p = resolving_diff(s, t)
IMPLIES
IF vars?(subtermOF(s, p))
THEN Dom(sig) = singleton(subtermOF(s, p))
ELSE Dom(sig) = singleton(subtermOF(t, p))
ENDIF
var_sub_1stdiff_not_member_term : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s ,t) IN
FORALL ( x | member(x,Dom(sig)), r | member(r,Ran(sig) )) :
NOT member(x, Vars(r))
sub_of_frst_diff_remove_x : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Dom(sig)(x) IMPLIES
(NOT member(x, Vars(ext(sig)(s)))) AND
(NOT member(x, Vars(ext(sig)(t))))
vars_sub_of_frst_diff_s_is_subset_union : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
subset?(Vars(ext(sig)(s)), union( Vars(s), Vars(t)))
vars_sub_of_frst_diff_t_is_subset_union : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
subset?(Vars(ext(sig)(t)), union( Vars(s), Vars(t)))
union_vars_ext_sub_of_frst_diff : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t) :
LET sig = sub_of_frst_diff(s, t) IN
union(Vars(ext(sig)(s)), Vars(ext(sig)(t)))
= difference(union( Vars(s), Vars(t)), Dom(sig))
varia´vel. Trata-se de um resultado simples mas que precisamos formalizar.
Lemmas about “sub of frst diff”: Nesta sec¸a˜o, formalizamos lemas sobre o constru-
tor sub_of_frst_diff. Para demonstrar os lemas desta sec¸a˜o foi preciso formali-
zar alguns lemas auxiliares dispostos na sec¸a˜o denominada Auxiliary lemmas about
substitutions and unifiers, que encontram-se no Apeˆndice A. Apresentamos nas
tabelas 4.2.5 e 4.2.6, a especificac¸a˜o dos lemas sobre o construtor sub_of_frst_diff.
4.2 Organizac¸a˜o da Teoria unification 51
Tabela 4.2.6: Especificac¸a˜o dos principais lemas sobre o construtor sub_of_frst_diff
sub_of_frst_diff_unifier_o : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
member(rho, U(s, t)) IMPLIES
LET sig = sub_of_frst_diff(s, t) IN
EXISTS theta : rho = comp(theta, sig)
ext_sub_of_frst_diff_unifiable : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
unifiable(ext(sig)(s), (ext(sig)(t)))
vars_ext_sub_of_frst_diff_decrease : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Card(union( Vars(ext(sig)(s)), Vars(ext(sig)(t))))
< Card(union( Vars(s), Vars(t)))
Comentaremos aqui os lemas da Tabela 4.2.5, os lemas apresentados na Tabela 4.2.6
sera˜o descritos e comentados mais detalhadamente na Sec¸a˜o 4.5. Pore´m, ressaltamos
que os lemas da Tabela 4.2.6, foram particularmente interessantes de demonstrar e
a formalizac¸a˜o destes foi fundamental para conclu´ırmos TCC’s importantes sobre o
construtor unification_algorithm. Novamente, todos os lemas da Tabela 4.2.5 teˆm
como hipo´tese que os termos s e t sa˜o unifica´veis e diferentes. Na descric¸a˜o destes
lemas, feita a seguir, σ indicara´ a substituic¸a˜o dada por sub_of_frst_diff(s, t) e p
a posic¸a˜o dada por resolving_diff(s, t).
dom_sub_of_frst_diff_is: Neste lema formalizamos um resultado importante so-
bre o domı´nio de σ, afirmamos que ale´m de ser unita´rio, exitem apenas duas
possibilidades, ou Dom(σ) = {s|p} ou Dom(σ) = {t|p}.
var_sub_1stdiff_not_member_term: Neste lema provamos que se uma varia´vel x e´
tal que x ∈ Dom(σ) enta˜o para todo termo r, da imagem de σ, vale que x na˜o
pertence a Vars(r).
sub_of_frst_diff_remove_x: Neste lema afirmamos que os termos σˆ(s) e σˆ(t) na˜o
possuem ocorreˆncias da varia´vel x, que pertence ao domı´nio de σ.
vars_sub_of_frst_diff_s_is_subset_union: Neste lema, provamos que o conjunto
Vars(σˆ(s)) e´ subconjunto da unia˜o dos conjuntos Vars(s) e Vars(t).
4.2 Organizac¸a˜o da Teoria unification 52
Tabela 4.2.7: Especificac¸a˜o dos lemas sobre o construtor unification_algorithm
unification_algorithm_gives_unifier : LEMMA
unifiable(s,t) IMPLIES member(unification_algorithm(s, t), U(s, t))
unification_algorithm_gives_mg_subs : LEMMA
member(rho, U(s, t)) IMPLIES unification_algorithm(s, t) <= rho
vars_sub_of_frst_diff_t_is_subset_union: Neste lema formalizamos o mesmo re-
sultado do lema anterior para o termo t, isto e´, mostramos que Vars(σˆ(t)) e´
um subconjunto de Vars(s) ∪ Vars(t).
union_vars_ext_sub_of_frst_diff: Neste lema provamos o fato de que o conjunto
Vars(σˆ(s)) ∪ Vars(σˆ(t)) e´ exatamente igual ao conjunto Vars(s) ∪ Vars(t)
menos uma varia´vel, aquela do domı´nio de σ. Este lema juntamente com os
dois anteriores foram de grande importaˆncia na formalizac¸a˜o do lema deno-
minado vars_ext_sub_of_frst_diff_decrease (Tabela 4.2.6), o qual garante a
terminalidade do construtor unification_algorithm.
Lemmas about “unification algorithm”: Nesta sec¸a˜o formalizamos dois lemas sobre
o construtor unification_algorithm, onde provamos que a substituic¸a˜o obtida em
unification_algorithm(s, t), sendo s e t dois termos unifica´veis, e´ de fato um mgu
de s e t. E estes dois lemas sa˜o o ponto de partida para provar o u´ltimo teorema
que formalizamos, o que garante a existeˆncia de mgu’s para dois termos unifica´veis
e cuja formalizac¸a˜o apresentamos e discutimos na Sec¸a˜o 4.3. Na Tabela 4.2.7, apre-
sentamos a especificac¸a˜o desta sec¸a˜o. Na Sec¸a˜o 4.4 apresentamos a formalizac¸a˜o
destes lemas e aqui uma breve descric¸a˜o de cada um.
unification_algorithm_gives_unifier: Neste provamos que a substituic¸a˜o dada
por unification_algorithm(s, t) e´ um unificador de s e t.
unification_algorithm_gives_mg_subs: Neste provamos que a substituic¸a˜o dada
por unification_algorithm(s, t) e´ mais geral que qualquer substituic¸a˜o que
seja unificador de s e t.
4.3 Formalizac¸a˜o do Teorema Sobre a Existeˆncia de mgu’s 53
Ainda temos na parte inicial da teoria unification especificac¸o˜es de conceitos impor-
tantes onde definimos elementos fundamentais em teoria de unificac¸a˜o. Tais definic¸o˜es sa˜o
as de instaˆncia de um termo, substituic¸a˜o mais geral, unificac¸a˜o entre dois termos, mgu
ale´m de lemas auxiliares, onde demonstramos que dois termos, funcionais e unifica´veis,
teˆm o mesmo s´ımbolo de func¸a˜o na posic¸a˜o raiz e o mesmo nu´mero de argumentos. E´
poss´ıvel observar o co´digo da especificac¸a˜o destes conceitos no Apeˆndice A. Ale´m disso,
foi necessa´rio formalizar outros lemas que, por uma questa˜o de organizac¸a˜o, foram espe-
cificados nas sub-teorias position, substitution e subterm.
Nas sec¸o˜es seguintes discutiremos os lemas mais importantes desta especificac¸a˜o, apre-
sentando as suas formalizac¸o˜es.
4.3 Formalizac¸a˜o do Teorema Sobre a Existeˆncia de
mgu’s
Nesta sec¸a˜o vamos apresentar a formalizac¸a˜o do teorema principal deste trabalho. O
teorema unification, que afirma que quaisquer dois termos unifica´veis possuem um uni-
ficador mais geral. A especificac¸a˜o deste teorema encontra-se na sec¸a˜o Existence of a
most general unifier da teoria unification. Vejamos abaixo a especificac¸a˜o deste teo-
rema.
unification : LEMMA
unifiable(s,t) => EXISTS theta : mgu(theta)(s,t)
Em seguida vamos enunciar o teorema e apresentar a formalizac¸a˜o de sua prova. Na
Figura 4.3.1 mostramos a a´rvore da prova do teorema unification, onde e´ poss´ıvel vi-
sualizar de mareira mais intuitiva a estrutura da demonstrac¸a˜o do teorema. Na a´rvore
o s´ımbolo ` representa o sequente que temos num dado momento da prova. As regras
de prova adotadas sa˜o enunciadas ao longo das arestas da a´rvore, posicionadas depois de
cada sequente que antecede a sua aplicac¸a˜o.
4.3 Formalizac¸a˜o do Teorema Sobre a Existeˆncia de mgu’s 54
` [raiz]
(skeep)
` [1]
(inst 1 “unification algorithm(s,t)”)
` [2]
(expand “mgu”)
` [3]
(split)
RRRR
RRRR
RRR
mmm
mmm
mmm
m
[4] ` ` [5]
(rewrite “unification algorithm gives unifier”) (skeep)
` [6]
(rewrite “unification algorithm gives mg subs”)
Figura 4.3.1: A´rvore de prova do teorema unification.
Teorema 4.3.1: Sejam s e t dois termos unifica´veis, enta˜o existe uma substituic¸a˜o θ que
e´ um mgu de s e t.
Na demonstrac¸a˜o deste teorema, utilizamos os lemas sobre o construtor unifica-
tion_algorithm, intitulados unification_algorithm_gives_unifier e unification_algo-
rithm_gives_mg_subs, cuja formalizac¸a˜o apresentaremos na Sec¸a˜o 4.4. A utilizac¸a˜o destes
dois lemas torna a demonstrac¸a˜o do Teorema 4.3.1 bastante simples. Isto porque no
Teorema 4.3.1 mostramos apenas que dois termos unifica´veis teˆm um mgu, que e´ obtido
via algoritmo de unificac¸a˜o. O fato de que o algoritmo de unificac¸a˜o realmente computa
um mgu, e´ mostrado nos dois lemas que utilizamos nesta prova. Enta˜o vamos apresentar
em detalhes a prova formal do teorema unification.
Demonstrac¸a˜o: Comec¸amos a demonstrac¸a˜o com o seguinte objetivo de prova,
4.3 Formalizac¸a˜o do Teorema Sobre a Existeˆncia de mgu’s 55
• Sequente representado pelo no´ [raiz],
|-------
{1} FORALL (s, t: term[variable, symbol, arity]):
unifiable(s, t) => (EXISTS theta: mgu(theta)(s, t))
Este objetivo e´ o teorema que queremos demonstrar, ou seja, o objetivo principal que
na a´rvore (Figura 4.3.1) de prova esta´ representado pelo no´ [raiz]. O primeiro comando
de prova utilizado e´ o skeep, da biblioteca do PVS Field. Este comando e´ usado para
skolemizar as varia´veis das fo´rmulas quantificadas universalmente. Contudo skeep na˜o
introduz novos nomes para constantes, ele mante´m os nomes das varia´veis ligadas. Assim,
depois de aplicar a regra skeep, obtivemos o seguinte sequente:
• Sequente representado pelo no´ [1],
{-1} unifiable(s, t)
|-------
{1} EXISTS theta: mgu(theta)(s, t)
A este sequente aplicamos a regra (inst 1 “unification_algorithm(s, t))”, que tal-
vez seja a mais importante desta prova, pois fica claro como faremos a demonstrac¸a˜o deste
teorema, ja´ que neste momento instanciamos a fo´rmula 1 com a substituic¸a˜o obtida pela
aplicac¸a˜o de unification_algorithm aos termos s e t. Isto e´, estamos lanc¸ando ma˜o do
fato, previamente demonstrado na teoria unification, mas que aqui sera´ apresentado na
Sec¸a˜o 4.4, de que unification_algorithm computa unificadores mais gerais. Da´ı temos o
sequente:
• Sequente representado pelo no´ [2],
[-1] unifiable(s, t)
|-------
{1} mgu(unification_algorithm(s, t))(s, t)
Logo em seguida utilizamos a regra (expand“mgu”), onde expandimos a definic¸a˜o de mgu,
o que nos direciona para a utilizac¸a˜o dos lemas sobre o construtor unification_algorithm.
E temos o sequente:
4.3 Formalizac¸a˜o do Teorema Sobre a Existeˆncia de mgu’s 56
• Sequente representado pelo no´ [3],
[-1] unifiable(s, t)
|-------
{1} member(unification_algorithm(s, t), U(s, t)) &
(FORALL tau: member(tau, U(s, t))
IMPLIES unification_algorithm(s, t) <= tau)
Neste ponto, afim de dividir a prova da conjugac¸a˜o do sucedente, utilizamos o comando
de prova split, que seleciona e divide uma fo´rmula conjuntiva, neste caso a fo´rmula
selecionada e´ a fo´rmula 1 do sequente representado pelo no´ [3].
Depois da aplicac¸a˜o da regra split, a a´rvore de prova se divide em dois ramos, isto
significa que a partir deste ponto da prova temos dois sub-objetivos de prova. O primeiro
onde temos que provar que a substituic¸a˜o dada por unification_algorithm e´ um unifica-
dor dos termos s e t e o segundo onde temos que provar que esta mesma substituic¸a˜o e´
mais geral do que qualquer outra substituic¸a˜o que seja um unificador dos termos s e t, mas
como ja´ mencionamos anteriormente, estes dois fatos foram previamente formalizados na
teoria como resultados dos lemas que sera˜o apresentados nas sec¸o˜es 4.4.1 e 4.4.2.
Assim, no sequente representado pelo no´ [4], temos que provar que a substituic¸a˜o dada
por unification_algorithm(s, t) e´ um unificador de s e t.
• Sequente representado pelo no´ [4],
[-1] unifiable(s, t)
|-------
{1} member(unification_algorithm(s, t), U(s, t))
Mas este e´ o resultado do lema unification_algorithm_gives_unifier. Portanto a
regra de prova aplicada a este sequente e´ (rewrite “unification_algorithm_gives_uni-
fier)”, onde o comando de prova rewrite tenta determinar automaticamente as instan-
ciac¸o˜es necessa´rias para combinar a conclusa˜o do lema com as expresso˜es das fo´rmulas
que estamos tentando reescrever. Apo´s este comando o provador encontra a devida ins-
tanciac¸a˜o e completa este ramo da prova, isto e´, a folha deste ramo da a´rvore torna-se
verdadeira.
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 57
Enta˜o, automaticamente passamos ao pro´ximo objetivo da prova, expresso no sequente
representado pelo no´ [5], onde temos que provar que a substituic¸a˜o dada por unifica-
tion_algorithm(s, t) e´ uma substituic¸a˜o que e´ mais geral do que qualquer outra substi-
tuic¸a˜o que seja um unificador dos termos s e t.
• Sequente representado pelo no´ [5],
[-1] unifiable(s, t)
|-------
{1} FORALL tau: member(tau, U(s, t))
IMPLIES unification_algorithm(s, t) <= tau
Note que neste sequente a fo´rmula 1 e´ universalmente quantificada, portanto o primeiro
comando de prova que aplicamos e´ skeep, o que nos leva ao u´ltimo objetivo da prova, o
sequente representado pelo no´ [6].
• Sequente representado pelo no´ [6].
{-1} member(tau, U(s, t))
[-2] unifiable(s, t)
|-------
{1} unification_algorithm(s, t) <= tau
Neste ponto, utilizamos novamente o comando de prova rewrite, aplicando o lema
unification_algorithm_gives_mg_subs. Novamente o provador faz a instanciac¸a˜o neces-
sa´ria automaticamente e completa este ramo da prova. Com isto completamos a prova
deste teorema.
Completar a a´rvore de prova significa concluir que todas as folhas da a´rvore sa˜o ver-
dadeiras. Logo temos uma prova do objetivo principal da prova, representado pelo no´
[raiz]. Portanto, mostramos que se s e t sa˜o dois termos unifica´veis, enta˜o existe uma
substituic¸a˜o que e´ um unificador mais geral de s e t.
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor uni-
fication_algorithm
Apresentamos a formalizac¸a˜o dos lemas onde verificamos que a substituic¸a˜o computada
pelo algoritmo de unificac¸a˜o e´ soluc¸a˜o do dado problema de unificac¸a˜o e que e´ mais
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 58
geral. Tratam-se dos lemas aplicados diretamente na formalizac¸a˜o do Teorema 4.3.1.
Estes lemas correspondem aos teoremas sobre correc¸a˜o e generalidade do algoritmo de
unificac¸a˜o apresentados na Sec¸a˜o 2.2.3.
4.4.1 Lema unification_algorithm_gives_unifier
Nesta sec¸a˜o apresentamos a formalizac¸a˜o de um dos lemas sobre o construtor unificati-
on_algorithm, onde provamos que a substituic¸a˜o computada por este construtor aplicado
a dois termos unifica´veis, e´ um unificador destes dois temos. Na Tabela 4.2.7 temos a
especificac¸a˜o deste lema. Este lema corresponde ao Teorema 2.2.16, onde provamos que
o algoritmo de unificac¸a˜o e´ correto. Apresentamos a a´rvore de prova deste lema dividida
nas figuras 4.4.1 e 4.4.2.
Lema 4.4.1: Seja σ = unification algorithm(s, t), onde s e t sa˜o dois termos unifi-
ca´veis, enta˜o temos que σ e´ um unificador de s e t.
` [raiz]
(measure-induct+ “Card(union(Vars(s), Vars(t)))” (“s”“t”))
Figura 4.4.2 ` [7] ?
(hide-all-but 1)
`
(rewrite “finite union[(V)]”)
fffff
fffff
fffff
f
XXXXX
XXXXX
XXXXX
X
` `
(rewrite “vars of term finite”) (rewrite “vars of term finite”)
Figura 4.4.1: In´ıcio da a´rvore de prova do Lema 4.4.1. Os ramos denotados por ?, que sa˜o dois, sa˜o
ideˆnticos ao ramo abaixo do no´ [7]. Tais ramos sa˜o gerados pela operac¸a˜o de checagem de tipos. O ramo
principal da prova consta da Figura 4.4.2.
Demonstrac¸a˜o: Assim, como na apresentac¸a˜o anterior, comec¸amos expondo a a´rvore
de prova gerada pelo PVS. Como ja´ comentamos, dividimos a a´rvore de prova em duas
figuras. Na Figura 4.4.1, mostramos o topo da a´rvore de prova, onde e´ poss´ıvel visualizar o
no´ [raiz] e o in´ıcio das ramificac¸o˜es obtidas pela aplicac¸a˜o da primeira regra utilizada. Na
Figura 4.4.2, mostramos o ramo principal da a´rvore de prova, onde se da´ a formalizac¸a˜o
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 59
do lema propriamente. Os outros ramos, que podemos visualizar na Figura 4.4.1, sa˜o
provenientes da checagem de tipos realizada pelo PVS.
Note que no construtor unification_algorithm utilizamos como medida a cardinali-
dade do conjunto dado pela unia˜o dos conjuntos de varia´veis dos termos s e t, denotada
por: Card(union(Vars(s), Vars(t))). Portanto, a demonstrac¸a˜o deste lema seguira´ por
induc¸a˜o nesta medida. Vamos expor a formalizac¸a˜o deste lema apresentando alguns obje-
tivos de prova, como sa˜o mostrados na interface do PVS, fazendo em seguida uma breve
explicac¸a˜o do objetivo e das regras aplicadas a este. O objetivo inicial e´ apresentado da
seguinte forma:
• Sequente representado pelo no´ [raiz].
|-------
{1} FORALL (s, t: term[variable, symbol, arity]):
unifiable(s, t) IMPLIES
member(unification_algorithm(s, t), U(s, t))
A este objetivo aplicamos a regra measure-induct+ sobre a cardinalidade da unia˜o do
conjunto de varia´veis dos termos, que quer dizer que a nossa estrate´gia de prova e´ fazer
induc¸a˜o na medida “Card(union(Vars(s), Vars(t)))”. A aplicac¸a˜o desta regra nos leva a
treˆs sub-objetivos: o primeiro deles e´ o nosso objetivo principal, onde provamos por casos
o lema propriamente dito; os dois outros sub-objetivos sa˜o resultado de uma checagem de
tipos realizada pelo PVS, onde temos que provar que o conjunto union(Vars(s), Vars(t))
e´ finito.
Assim, no primeiro destes sub-objetivos, provamos a hipo´tese do lema, que sera´ feita
por casos. Este sub-objetivo se apresenta da seguinte forma:
• Sequente representado pelo no´ [1].
{-1} FORALL (y_1: term[variable, symbol, arity]),
(y_2: term[variable, symbol, arity]):
Card(union(Vars(y_1), Vars(y_2))) <
Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
unifiable(y_1, y_2) IMPLIES
member(unification_algorithm(y_1, y_2), U(y_1, y_2))
{-2} unifiable(x!1, x!2)
|-------
{1} member(unification_algorithm(x!1, x!2), U(x!1, x!2))
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 60
Figura 4.4.1
` [1]
(case “x!1 = x!2”)
fffff
ffff
\\\\\\\\\\\
\\\\\\\\\\\
\\\\
[2] ` ` [4]
(hide -2 -3)
(inst -1 “ext(sub of frst diff(x!1, x!2))(x!1)”
“ext(sub of frst diff(x!1, x!2))(x!2)”)
ggggg
ggg KKK
` ` `
(expand “unification algorithm”)
(lemma
“vars ext sub of frst diff decrease”)
(assert)
` `
(assert) (inst -1 “x!1”“x!2”)
YYYYYY
YYYY
ffffff
fff
` ` `
(assert) (assert)
(expand* “member”“U”“unifier”) `
[3] ` (hide -1)
(assert) `
(lemma “ext sub of frst diff unifiable”)
`
(inst -1 “x!1”“x!2”)
`
(assert)
`
(hide -1)
` [5]
(lema “unifier o”)
`
(inst -1 “x!1”“unification algorithm(
ext(sub of frst diff(x!1, x!1))(x!1),
ext(sub of frst diff(x!1, x!1))(x!2))”
“x!2”“sub of frst diff(x!1, x!2)”)
`
(assert)
`
(hide -2)
` [6]
(expand “unification algorithm” 2)
`
(propax)
Figura 4.4.2: Ramo principal da a´rvore do prova do Lema 4.4.1. A parte inicial da a´rvore consta da
Figura 4.4.1.
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 61
Neste sequente temos a hipo´tese de induc¸a˜o dada pelo antecedente -1, ale´m da hipo´tese
de que os termos x!1 e x!2 sa˜o unifica´veis, e o nosso objetivo e´ provar o consequente 1.
Neste ponto da prova aplicamos a regra “case” que nos leva a considerar dois casos. O
primeiro caso onde “x!1 = x!2”, e no segundo o caso onde “x!1 6= x!2”.
Vejamos rapidamente o primeiro caso, onde “x!1 = x!2”, apresentado pelo provador
do PVS na forma do seguinte sequente:
• Sequente representado pelo no´ [2].
{-1} x!1 = x!2
[-2] FORALL (y_1: term[variable, symbol, arity]),
(y_2: term[variable, symbol, arity]):
Card(union(Vars(y_1), Vars(y_2))) <
Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
unifiable(y_1, y_2) IMPLIES
member(unification_algorithm(y_1, y_2), U(y_1, y_2))
[-3] unifiable(x!1, x!2)
|-------
[1] member(unification_algorithm(x!1, x!2), U(x!1, x!2))
Neste sequente comec¸amos aplicando a regra (hide -2 -3), onde escondemos as fo´r-
mulas -2 e -3, pois elas na˜o sera˜o necessa´rias na demonstrac¸a˜o deste ramo da prova.
Assim obtemos um sequente simplificado onde temos apenas as fo´rmulas -1 e 1. Neste
ponto da prova utilizamos a estrate´gia de expandir as definic¸o˜es de “member”, “unifica-
tion_algorithm”, “U” e “unifier”, onde “unifier” aparece quando expandimos “U”. Assim,
obtemos o seguinte sequente:
• Sequente representado pelo no´ [3]
[-1] x!1 = x!2
|-------
{1} ext(identity)(x!1) = ext(identity)(x!2)
Se olharmos na especificac¸a˜o do construtor unification_algorithm, apresentada na
Tabela 4.2.3, veremos que para x!1 = x!2 este construtor retorna substituic¸a˜o identidade.
Da´ı, obtemos na fo´rmula 1 a negac¸a˜o do fato de a substituic¸a˜o identidade pertencer ao
conjunto dos unificadores de x!1 e x!2. Mas isto nos leva a uma contradic¸a˜o, visto
que na fo´rmula -1 temos que x!1 = x!2. Portanto com a regra assert, que emprega
procedimentos de decisa˜o para simplificar as fo´rmulas, completamos este ramo da prova.
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 62
Vejamos agora o caso em que “x!1 6= x!2”. Aqui comec¸amos com o seguinte objetivo
de prova:
• Sequente representado pelo no´ [4]
[-1] FORALL (y_1: term[variable, symbol, arity]),
(y_2: term[variable, symbol, arity]):
Card(union(Vars(y_1), Vars(y_2))) <
Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
unifiable(y_1, y_2) IMPLIES
member(unification_algorithm(y_1, y_2), U(y_1, y_2))
[-2] unifiable(x!1, x!2)
|-------
{1} x!1 = x!2
[2] member(unification_algorithm(x!1, x!2), U(x!1, x!2))
Neste primeiro sequente deste ramo da prova, note que temos a hipo´tese que diferencia
este caso do anterior na fo´rmula 1, que por estar no consequente representa a negac¸a˜o de
“x!1 = x!2”. Ale´m disso, temos a hipo´tese de induc¸a˜o na fo´rmula -1. Neste ponto da prova,
vamos instanciar a fo´rmula -1 com os termos “ext(sub_of_frst_diff(x!1, x!2))(x!1)” e
“ext(sub_of_frst_diff(x!1, x!2))(x!2)”. Assim, temos que se
Card(union( Vars(ext(sub_of_frst_diff(x!1, x!2))x!1),
Vars(ext(sub_of_frst_diff(x!1, x!2))x!2) ))
< Card(union( Vars(x!1), Vars(x!2) ))
e se os termos
ext(sub_of_frst_diff(x!1, x!2))x!1 e ext(sub_of_frst_diff(x!1, x!2))x!1
sa˜o unifica´veis, enta˜o a substituic¸a˜o dada por
unification_algorithm( ext(sub_of_frst_diff(x!1, x!2)),
ext(sub_of_frst_diff(x!1, x!2)) )
e´ um unificador destes termos.
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 63
Mas estes dois resultados esta˜o previamente formalizados na teoria. Tratam-se dos
lemas vars_ext_sub_of_frst_diff_decrease e ext_sub_of_frst_diff_unifiable da sec¸a˜o
Lemmas about“sub_of_frst_diff” da teoria unification, cuja formalizac¸a˜o apresentamos
na Sec¸a˜o 4.5 e cuja especificac¸a˜o apresentamos na Tabela 4.2.6. Assim, apo´s alguns passos
de prova, onde fazemos a instanciac¸a˜o ja´ mencionada e realizamos alguns procedimentos
de simplificac¸a˜o, obtemos o seguinte sequente de prova:
• Sequente representado pelo no´ [5].
[-1] member(unification_algorithm(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2)),
U(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2)))
[-2] unifiable(x!1, x!2)
|-------
[1] x!1 = x!2
[2] member(unification_algorithm(x!1, x!2), U(x!1, x!2))
Neste u´ltimo sequente, temos que a fo´rmula -1 e a fo´rmula 2, sa˜o equivalentes. Apenas
temos que nos dar conta do fato de que dadas duas substituic¸o˜es α e β, e dois termos
unifica´veis s e t, se α e´ um unificador de β̂(s) e β̂(t), enta˜o a composic¸a˜o α ◦ β e´ um
unificador de s e t. Este resultado esta´ demonstrado no lema unifier_o da sec¸a˜o Auxiliary
lemmas about substitutions and unifiers, cuja formalizac¸a˜o apresentamos no Apeˆndice
A, que vamos aplicar neste momento da prova. Assim, utilizando este lema, fazendo as
devidas instanciac¸o˜es, e apo´s alguns passos de prova para simplificar obtemos o seguinte:
• Sequente representado pelo no´ [6]
[-1] member(comp(unification_algorithm(
ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2)),
sub_of_frst_diff(x!1, x!2)),
U(x!1, x!2))
|-------
[1] x!1 = x!2
[2] member(unification_algorithm(x!1, x!2), U(x!1, x!2))
Note que agora esta´ clara a equivaleˆncia entre as fo´rmulas -1 e 2. Assim, neste ponto
expandimos a definic¸a˜o de unification_algorithm e com isto completamos este ramo da
prova, desde que x!1 6= x!2.
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 64
Tendo completado a formalizac¸a˜o dos dois ramos de prova gerados pela aplicac¸a˜o
da regra case “x!1 = x!2”, completamos o ramo principal da prova. Ressaltamos que
nestes dois ramos da prova, omitimos alguns sub-objetivos de prova, que temos que provar
principalmente quando usamos a estrate´gia de aplicar um outro lema da teoria, pois nestes
casos o PVS gera sub-objetivos de prova onde temos que verificar asserc¸o˜es acerca do tipo
das varia´veis usadas para instanciar os lemas utilizados.
Nos dois ramos seguintes da prova, como ja´ mencionamos anteriormente, temos que
provar que os termos esta˜o bem tipados. Temos dois objetivos de prova, onde “questiona-
se” sobre a finitude da unia˜o dos conjuntos de varia´veis dos termos, isto e´, temos que
provar que, dados dois termos s e t enta˜o V ars(s) ∪ V ars(t) e´ um conjunto finito.
A demonstrac¸a˜o destes dois ramos, novamente segue pela aplicac¸a˜o de dois outros
lemas, um da teoria finite_sets do prelu´dio do PVS, denominado finite_union, que
diz que a unia˜o de dois conjuntos finitos e´ ainda um conjunto finito. Mas ao aplicar
este lema somos levados a provar que os conjuntos de varia´veis dos dois termos em ques-
ta˜o sa˜o conjuntos finitos, e isto segue de um outro lema da teoria subterm denominado
vars_of_term_finite, que afirma que o conjunto de varia´veis de um termo e´ finito. Assim,
para ilustrar o que acabamos de explicar, apresentamos a seguir o objetivo de um destes
ramos da prova. O outro ramo prova-se com a mesma sequeˆncia de comandos de prova.
Temos o seguinte sequente inicial:
• Sequente representado pelo no´ [7]
|-------
{1} is_finite[(V)]
(union[((V))]
(Vars[variable, symbol, arity](s!1),
Vars[variable, symbol, arity](t!1)))
[2] FORALL (s, t: term[variable, symbol, arity]):
unifiable(s, t) IMPLIES
member(unification_algorithm(s, t), U(s, t))
A este sequente aplicamos os lemas mencionados acima, realizamos os procedimentos
de prova necessa´rios para encontrar as devidas instanciac¸o˜es, realizamos as simplificac¸o˜es
necessa´rias e com isto conclu´ımos este ramo da prova.
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 65
Tendo completado a formalizac¸a˜o dos ramos de prova gerados pela aplicac¸a˜o da re-
gra measure-induct+“Card(union(Vars(s), Vars(t)))”(“s”“t”), conclu´ımos a prova do
lema.
4.4.2 Lema unification_algorithm_gives_mg_subs
Nesta sec¸a˜o apresentamos a formalizac¸a˜o do lema sobre o construtor unification_algo-
rithm, onde provamos que a substituic¸a˜o computada por este construtor aplicado a dois
termos unifica´veis, e´ uma substituic¸a˜o mais geral que qualquer outra substituic¸a˜o que
seja um unificador destes dois temos. Na Tabela 4.2.7 temos a especificac¸a˜o deste lema.
Este lema corresponde ao Teorema 2.2.17, onde provamos a generalidade da substituic¸a˜o
computada pelo algoritmo de unificac¸a˜o. Apresentamos a a´rvore de prova deste lema nas
figuras 4.4.3, 4.4.4 e 4.4.5.
` [raiz]
(measure-induct+ “Card(union(Vars(s), Vars(t)))” (“s”“t”))
ZZZZZZZZ
ZZZZZZZZ
ZZZZZZZZ
ZZ
Figura 4.4.4 ` ` [13] ?
(hide-all-but (-1 1)) (hide -1 2)
[12] ` `
(expand “member”“U”“unifiable”) (rewrite “finite union[(V)]”)
mmm
mmm
mm
QQQ
QQQ
QQ
` ` `
(inst 1 “rho!1”)
(rewrite
“vars of term finite”)
(rewrite
“vars of term finite”)
Figura 4.4.3: In´ıcio da a´rvore de prova do Lema 4.4.2. A ramificac¸a˜o denotada por ? representa outros
dez sub-objetivos de prova gerados pelo typechecker. Tais objetivos sa˜o provados ou da mesma forma que
o ramo abaixo do no´ [12] ou da mesma forma que o ramo abaixo do no´ [13]. O ramo principal consta das
figuras 4.4.4 e 4.4.5.
Lema 4.4.2: Sejam σ = unification algorithm(s, t) e θ ∈ U(s, t), onde s e t sa˜o dois
termos unifica´veis, enta˜o existe uma substituic¸a˜o δ tal que θ = δ ◦ σ.
Demonstrac¸a˜o: Similarmente ao que foi feito na formalizac¸a˜o do Lema 4.4.1, tambe´m
neste lema a prova se dara´ por induc¸a˜o na medida Card(union(Vars(s),Vars(t))). Assim,
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 66
temos o seguinte objetivo inicial de prova, sobre o qual invocamos o comando de prova
measure-induct+:
• Sequente representado pelo no´ [raiz].
|-------
{1} FORALL (rho: Sub[variable, symbol, arity],
s, t: term[variable, symbol, arity]):
member(rho, U(s, t)) IMPLIES
unification_algorithm(s, t) <= rho
Apo´s aplicar a regra measure-induct+, o provador gera treze sub-objetivos de prova.
O primeiro destes sub-objetivos consiste do ramo principal da a´rvore de prova, os outros
sub-objetivos sa˜o resultado da checagem de tipos realizada pelo PVS. Na Figura 4.4.3, e´
poss´ıvel visualizar a ramificac¸a˜o inicial da a´rvore de prova do Lema 4.4.2, onde consta o
no´ [raiz] e duas das ramificac¸o˜es geradas pela checagem de tipos. O ramo principal da
prova e´ apresentado nas figuras 4.4.4 e 4.4.5.
Vamos apresentar a formalizac¸a˜o do objetivo principal da prova. Apresentamos a
a´rvore prova do ramo principal por partes. Na Figura 4.4.4 temos a primeira parte deste
ramo. Comec¸amos este ramo da a´rvore de prova com o seguinte sequente:
• Sequente representado pelo no´ [1].
{-1} FORALL (y_1: term[variable, symbol, arity],
y_2: term[variable, symbol, arity]):
FORALL (rho: Sub[variable, symbol, arity]):
Card(union(Vars(y_1), Vars(y_2))) <
Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
member(rho, U(y_1, y_2)) IMPLIES
unification_algorithm(y_1, y_2) <= rho
|-------
{1} FORALL (rho: Sub[variable, symbol, arity]):
member(rho, U(x!1, x!2)) IMPLIES
unification_algorithm(x!1, x!2) <= rho
Note que este sequente e´ bastante semelhante ao apresentado na posic¸a˜o correspon-
dente na a´rvore de prova do Lema 4.4.1. Enta˜o, temos a hipo´tese de induc¸a˜o apresentada
na fo´rmula -1 e o nosso objetivo e´ provar o consequente 1. Assim, comec¸amos aplicando a
regra skeep para skolemizar a fo´rmula universalmente quantificada 1. Em seguida usamos
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 67
Figura 4.4.3
[1] `
(skeep)
`
(case “x!1 = x!2”)
dddddddd
dddddddd
ddddddd
VVVVV
VVVVV
VV
[2] ` ` [4]
(hide (-2 -3))
(inst -1 “ext(sub of frst diff(x!1, x!2))(x!1)”
“ext(sub of frst diff(x!1, x!2))(x!1)”)
jjjj
jjjj
jj
RRRR
RRRR
` [5] ` `
(expand*
“unfication algorithm”“<=”)
(lemma “sub of frst diff unifier o”) (assert)
` ` `
(assert) (inst -1 “rho”“x!1”“x!2”)
ggggg
ggggg
g
WWWWW
WWWWW
W (hide 2 3)
` ` ` `
(inst 1 “rho”) (assert) (assert)
` ` ` (expand“member”“U”“unifiable”)
(hide -) (skeep -1) (hide -1 2 3) `
[3] ` ` ` (inst 1 “rho”)
(inst -2 “theta”) (expand “member”“U”“unifiable”)
(rewrite “subs o identity”) ` [6] `
(lemma “vars ext sub of frst diff decrease”) (inst 1 “rho”)
`
(inst -1 “x!1”“x!2”)
`
(assert)
`
(hide -1)
Figura 4.4.5
Figura 4.4.4: In´ıcio do ramo principal da a´rvore de prova do Lema 4.4.2. A parte final deste ramo da
prova consta da Figura 4.4.5.
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 68
a regra case, para considerar o caso em que x!1 = x!2 e o caso em que x!1 6= x!2. Logo,
neste ponto a prova se divide em dois sub-objetivos que apresentamos a seguir.
No primeiro caso, onde x!1 = x!2, temos o seguinte sub-objetivo de prova:
• Sequente representado pelo no´ [2].
{-1} x!1 = x!2
[-2] FORALL (y_1: term[variable, symbol, arity],
y_2: term[variable, symbol, arity]):
FORALL (rho: Sub[variable, symbol, arity]):
Card(union(Vars(y_1), Vars(y_2))) <
Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
member(rho, U(y_1, y_2)) IMPLIES
unification_algorithm(y_1, y_2) <= rho
[-3] member(rho, U(x!1, x!2))
|-------
[1] unification_algorithm(x!1, x!2) <= rho
Neste sequente comec¸amos aplicando a regra (hide -2 -3), que significa que estamos
“escondendo” as fo´rmulas -2 e -3, onde -2 representa a hipo´tese de induc¸a˜o, mas na˜o sera˜o
necessa´rias neste ramo da prova, pois como ja´ comentamos anteriormente, no caso em
que x!1 = x!2 o construtor unification_algorithm retorna a substituic¸a˜o identidade. E
note que a substituic¸a˜o identidade e´ mais geral que qualquer outra substituic¸a˜o. Assim,
o que fazemos neste ramo da prova e´ expandir as definic¸o˜es de unification_algorithm
e da pre´-ordem <=, que usamos aqui para dizer que uma substituic¸a˜o e´ mais geral que
outra. Feito isto e depois de realizar algumas simplificac¸o˜es, instanciamos a fo´rmula 1
com a substituic¸a˜o rho e obtemos o sequente:
• Sequente representado pelo no´ [3]
|-------
[1] rho = comp(rho, identity)
Neste sequente apenas temos que nos dar conta de que a composic¸a˜o de qualquer
substituic¸a˜o α com a substutuic¸a˜o identidade e´ igual a α. Este fato esta´ formalizado no
lema subs_o_identity da sub-teoria substitution. Assim, utilizamos a regra rewrite
que procura uma instanciac¸a˜o para o lema invocado. Com isto completamos este ramo
da prova.
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 69
Passemos ao caso em que x!1 6= x!2, onde comec¸amos com o objetivo de prova, dado
pelo sequente:
• Sequente representado pelo no´ [4]
[-1] FORALL (y_1: term[variable, symbol, arity],
y_2: term[variable, symbol, arity]):
FORALL (rho: Sub[variable, symbol, arity]):
Card(union(Vars(y_1), Vars(y_2))) <
Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
member(rho, U(y_1, y_2)) IMPLIES
unification_algorithm(y_1, y_2) <= rho
[-2] member(rho, U(x!1, x!2))
|-------
{1} x!1 = x!2
[2] unification_algorithm(x!1, x!2) <= rho
Neste primeiro sequente deste ramo da prova, temos a hipo´tese que diferencia este
caso do anterior na fo´rmula 1, que por estar no consequente representa a negac¸a˜o de
x!1 = x!2. Ale´m disso, temos a hipo´tese de induc¸a˜o na fo´rmula -1. Da mesma forma
que fizemos no Lema 4.4.1, vamos comec¸ar instanciando -1 com os termos dados por
ext(sub_of_frst_diff(x!1, x!2))(x!1) e ext(sub_of_frst_diff(x!1, x!2))(x!2).
Feita esta instanciac¸a˜o, temos o seguinte sequente:
• Sequente representado pelo no´ [5]
{-1} FORALL (rho: Sub[variable, symbol, arity]):
Card(union(Vars(ext(sub_of_frst_diff(x!1, x!2))(x!1)),
Vars(ext(sub_of_frst_diff(x!1, x!2))(x!2))))
< Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
member(rho,
U(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2)))
IMPLIES
unification_algorithm(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2))
<= rho
[-2] member(rho, U(x!1, x!2))
|-------
[1] x!1 = x!2
[2] unification_algorithm(x!1, x!2) <= rho
Note que depois de instanciar a hipo´tese de induc¸a˜o ainda temos uma fo´rmula com
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 70
uma varia´vel quantificada universalmente, esta varia´vel e´ do tipo Sub, isto e´, uma subs-
tituic¸a˜o. Enta˜o precisamos instanciar esta fo´rmula com uma substituic¸a˜o espec´ıfica.
Vemos no corpo da fo´rmula que esta substituic¸a˜o deve ser um unificador dos termos
ext(sub_of_frst_diff(x!1, x!2))(x!1) e ext(sub_of_frst_diff(x!1, x!2))(x!2). Para
obter esta substituic¸a˜o, ao inve´s de usar o lema ext_sub_of_frst_diff_unifiable, que
estabelece que os termos sa˜o unifica´veis, o que por skolemizac¸a˜o nos daria uma subs-
tituic¸a˜o, escolhemos usar um o lema sub_of_frst_diff_unifier_o, onde afirmamos que
para qualquer unificador dos termos s e t existe uma substituic¸a˜o θ, que composta com
a substituic¸a˜o que resolve a primeira diferenc¸a da´ este unificador. Usamos esta θ para
instanciar a fo´rmula -1, e depois mostramos que θ e´ um unificador dos termos dados por
ext(sub_of_frst_diff(x!1,x!2))(x!1) e ext(sub_of_frst_diff(x!1, x!2))(x!2). As-
sim, apo´s alguns passos de simplificac¸a˜o temos o sequente:
• Sequente representado pelo no´ [6]
[-1] rho = comp(theta, sub_of_frst_diff(x!1, x!2))
{-2} Card(union(Vars(ext(sub_of_frst_diff(x!1, x!2))(x!1)),
Vars(ext(sub_of_frst_diff(x!1, x!2))(x!2))))
< Card(union(Vars(x!1), Vars(x!2)))
IMPLIES
member(theta,
U(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2)))
IMPLIES
unification_algorithm(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2))
<= theta
[-3] member(rho, U(x!1, x!2))
|-------
[1] x!1 = x!2
[2] unification_algorithm(x!1, x!2) <= rho
Observando a fo´rmula -2, que e´ resultado da hipo´tese de induc¸a˜o, temos que se
Card(union( Vars(ext(sub_of_frst_diff(x!1, x!2))x!1),
Vars(ext(sub_of_frst_diff(x!1, x!2))x!2) ))
< Card(union( Vars(x!1), Vars(x!2) ))
(4.4.1)
e se a substituic¸a˜o θ, obtida atrave´s do lema usado anteriormente, e´ um unificador dos ter-
mos ext(sub_of_frst_diff(x!1, x!2))(x!1) e ext(sub_of_frst_diff(x!1, x!2))(x!2),
enta˜o a substituic¸a˜o dada por
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 71
unification_algorithm( ext(sub_of_frst_diff(x!1, x!2)),
ext(sub_of_frst_diff(x!1, x!2)) ),
e´ mais geral que θ.
Assim, novamente vamos usar o lema vars_ext_sub_of_frst_diff_decrease, que es-
tabelece o resultado 4.4.1. Em seguida, apo´s alguns passos de prova, realizamos uma
simplificac¸a˜o proposicional com o uso da regra prop, o que faz com que tenhamos dois
ramos na a´rvore de prova a partir deste ponto. A segunda parte da a´rvore de prova, que
conte´m estes ramos esta´ representada na Figura 4.4.5. No primeiro sequente do principal
destes ramos temos:
• Sequente representado pelo no´ [7]
{-1} unification_algorithm(ext(sub_of_frst_diff(x!1, x!2))(x!1),
ext(sub_of_frst_diff(x!1, x!2))(x!2))
<= theta
[-2] rho = comp(theta, sub_of_frst_diff(x!1, x!2))
[-3] member(rho, U(x!1, x!2))
|-------
[1] x!1 = x!2
[2] unification_algorithm(x!1, x!2) <= rho
Neste sequente o nosso objetivo e´ provar a assertiva da fo´rmula 2. Para isto, expan-
dimos unification_algorithm na fo´rmula 2, em seguida expandimos <=, que nos gera
fo´rmulas quantificadas existencialmente. Neste ponto temos o sequente:
• Sequente representado pelo no´ [8]
[-1] unification_algorithm(ext(sig1)(x!1), ext(sig1)(x!2)) = sig2
[-2] sub_of_frst_diff(x!1, x!2) = sig1
{-3} EXISTS tau: theta = comp(tau, sig2)
[-4] rho = comp(theta, sig1)
[-5] member(rho, U(x!1, x!2))
|-------
[1] x!1 = x!2
{2} EXISTS tau: rho = comp(tau, comp(sig2, sig1))
Depois de skolemizar a varia´vel quantificada em -3, instanciamos 2 com esta mesma
varia´vel. Assim, apo´s alguns passos de prova e algumas simplificac¸o˜es, temos o objetivo:
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 72
Figura 4.4.4
`
(prop)
UUUU
UUUU
UUU
eeeeeee
eeeeeee
eeeeeee
ee
[7] ` `
(name-replace “sig1”
“sub of frst diff(x!1, x!2)” :hide? nil)
(hide 2 3)
`
(name-replace “sig2”
“unification algorithm(ext(sig1)(x!1), ext(sig1)(x!2))” :hide? nil) `
` (name-replace “sig1”“sub of frst diff(x!1, x!2)” :hide? nil)
(expand “unification algorithm” 2) `
` (replaces -2)
(replace -2 2) ` [10]
` (expand* “member”“U”“unifier”)
(replace -1 1) ` [11]
` (rewrite “ext o”)
(expand “<=”) `
[8] ` (expand “o”)
(skeep -3) `
` (propax)
(inst 2 “tau”)
`
(hide -1 -2 -5 1)
`
(replaces -1)
[9] `
(rewrite “o ass”)
Figura 4.4.5: Parte final do ramo principal da a´rvore de prova do Lema 4.4.2. A parte inicial deste
ramo da prova consta da Figura 4.4.4.
4.4 Formalizac¸a˜o dos Lemas Sobre o Construtor unification_algorithm 73
• Sequente representado pelo no´ [9]
{-1} rho = comp(comp(tau, sig2), sig1)
|-------
{1} rho = comp(tau, comp(sig2, sig1))
Neste sequente, temos que:
sig1 = sub_of_frst_diff(x!1, x!2) e
sig2 = unification_algorithm(ext(sig1)(x!1), ext(sig1)(x!2)).
Note que a fo´rmula -1 e´ igual a` fo´rmula 1, apenas temos que nos dar conta de que a
composic¸a˜o de substituic¸o˜es e´ associativa, isto e´, dadas as substituic¸o˜es τ , σ1 e σ2, vale
que ((τ ◦ σ1) ◦ σ2) = (τ ◦ (σ1 ◦ σ2)). Mas este resultado esta formalizado no lema o_ass da
sub-teoria substitution.
No ramo seguinte da prova, temos o seguinte objetivo:
• Sequente representado pelo no´ [10]
{-1} sub_of_frst_diff(x!1, x!2) = sig1
{-2} member(comp(theta, sig1), U(x!1, x!2))
|-------
{1} member(theta, U(ext(sig1)(x!1), ext(sig1)(x!2)))
Neste sequente devemos verificar que a substituic¸a˜o obtida pela aplicac¸a˜o do lema
sub_of_frst_diff_unifier_o, e´ de fato um unificador dos termos ext(sig1)(x!1) e
ext(sig1)(x!2). Para isto, apenas expandimos as definic¸o˜es de meber, U e unifier que
aparece devido as expanso˜es anteriores. Feito isto, temos o objetivo:
• Sequente representado pelo no´ [11]
[-1] sub_of_frst_diff(x!1, x!2) = sig1
{-2} ext(comp(theta, sig1))(x!1) = ext(comp(theta, sig1))(x!2)
|-------
{1} ext(theta)(ext(sig1)(x!1)) = ext(theta)(ext(sig1)(x!2))
Onde temos que verificar que dadas duas substituic¸o˜es θ e σ quaisquer, vale que θ̂ ◦ σ =
θˆ ◦ σˆ. Mas este resultado esta´ formalizado no lema ext_o da sub-teoria substitution.
Assim, reescrevemos com este lema e completamos este ramo da prova.
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 74
Com isto, completamos o ramo principal da prova. Ressaltamos que nos ramos da
prova descritos acima, omitimos alguns sub-objetivos, que aparecem como resultado da
checagem de tipos realizada pelo PVS, usamos a estrate´gia de aplicar um outro lema da
teoria, nestes casos temos que provar asserc¸o˜es acerca do tipo dos termos.
Em todos os ramos seguintes da prova, temos que provar asserc¸o˜es acerca de tipos.
Em alguns destes objetivos temos que provar que a unia˜o dos conjuntos de varia´veis dos
termos e´ finita. A demonstrac¸a˜o destes ramos, assim como fizemos na demonstrac¸a˜o
do Lema 4.4.1, segue pela aplicac¸a˜o de dois outros lemas, um da teoria finite_sets
do prelu´dio do PVS, denominado finite_union e um da teoria subterm denominado
vars_of_term_finite. Como ja´ descrevemos este ramo de prova na apresentac¸a˜o da for-
malizac¸a˜o do Lema 4.4.1, na˜o repetiremos aqui. Nos outros ramos da prova, temos apenas
que mostrar que os termos sa˜o unifica´veis. Assim, temos sempre um sequente da forma:
• Sequente representado pelo no´ [12]
[-1] member(rho!1, U(s!1, t!1))
|-------
[1] unifiable(s!1, t!1)
Note que na fo´rmula -1 temos que a substituic¸a˜o rho!1 faz parte do conjunto de unifi-
cadores dos termos s!1 e t!1. Assim, expandimos as definic¸o˜es de member, U e unifiable,
em seguida instanciamos a fo´rmula 1, que passa a ser quantificada existencialmente, com
a substituic¸a˜o rho!1 o que completa este ramo da prova.
Com isto completamos todos os ramos da prova do lema.
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o
Construtor sub_of_frst_diff
Nesta sec¸a˜o apresentamos a formalizac¸a˜o dos lemas sobre o construtor sub_of_frst_diff,
cuja especificac¸a˜o consta na Tabela 4.2.6. A formalizac¸a˜o destes lemas surge da neces-
sidade de verificar que o construtor unification_algorithm esta´ totalmente definido em
relac¸a˜o aos tipos dos termos. Ale´m disso, com estes lemas, verificamos propriedades essen-
ciais do algoritmo de unificac¸a˜o, uma delas e´ a de terminac¸a˜o. A terminac¸a˜o do algoritmo
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 75
proposto nesta especificac¸a˜o fica garantida pelo lema que apresentamos primeiro nesta
sec¸a˜o, o Lema 4.5.1. Nos lemas 4.5.2 e 4.5.3, apresentados nas sec¸o˜es 4.5.2 e 4.5.3, for-
malizamos o fato de que resolver diferenc¸as em termos unifica´veis leva a termos ainda
unifica´veis. Estes foram os lemas essenciais no passo indutivo da demosntrac¸a˜o de cada
um dos lemas apresentados na Sec¸a˜o 4.4. Os lemas desta sec¸a˜o correspodem aos lemas
sobre generalidade local e terminac¸a˜o do algoritmo de unificac¸a˜o apresentados na Sec¸a˜o
2.2.3.
4.5.1 Lema vars_ext_sub_of_frst_diff_decrease
Como ja´ mencionamos anteriormente, com este lema temos garantida a terminac¸a˜o do
algoritmo de unificac¸a˜o, isto se deve ao fato de que a cada passo do algoritmo retiramos
um elemento de um conjunto finito, o que portanto e´ um processo finito. A especificac¸a˜o
deste lema esta´ apresentada na Tabela 4.2.6. Na Sec¸a˜o 2.2, demonstramos o Lema 2.2.15,
onde provamos a terminac¸a˜o do algoritmo de unificac¸a˜o e que corresponde a este cuja
formalizac¸a˜o apresentamos aqui. A a´rvore de prova deste lema e´ apresentada nas figuras
4.5.1, 4.5.2 e 4.5.3.
Lema 4.5.1: Sejam s e t dois termos unifica´veis e σ = sub_of_frst_diff(s, t), enta˜o
Card(Vars(σˆ(s)) ∪ Vars(σˆ(t))) < Card(Vars(s) ∪ Vars(t)).
Demonstrac¸a˜o: Na formalizac¸a˜o deste lema temos o seguinte objetivo de prova, ao
iniciarmos a demonstrac¸a˜o:
• Sequente representado pelo no´ [raiz]
|-------
{1} FORALL (s: term, t: term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Card(union(Vars(ext(sig)(s)), Vars(ext(sig)(t)))) <
Card(union(Vars(s), Vars(t)))
Comec¸amos skolemizando as varia´veis ligadas do consequente com a regra skosimp, que
ao contra´rio da regra skeep, skolemiza introduzindo novos nomes para as constantes, o que
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 76
` [raiz]
(skosimp*)
`
(assert)
`
(name-replace “sig1”
“sub of frst diff(s!1, t!1)” :hide? nil)
` [1]
(lemma “card diff subset[(V)]”)
`
(lemma “union vars ext sub of frst diff”)
`
(inst -1 “s!1”“t!1”)
`
(assert)
`
(replace -3 -1)
`
(replaces -1)
`
(inst -1 “Dom(sig1)”
“union(Vars(s!1), Vars(t!1))”)
eeeeee
eeeeee
eee
XXXXX
XXXXX
XXX
[2] ` `
(prop) (hide -1 2)
Figura 4.5.2 Figura 4.5.3 `
(typepred “sig1”)
`
(expand “Sub?”)
`
(propax)
Figura 4.5.1: In´ıcio da a´rvore de prova do Lema 4.5.1. O restante da a´rvore consta das figuras 4.5.2 e
4.5.3.
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 77
evita conflitos entre os nomes. Apo´s poucos passos de prova onde fazemos simplificac¸o˜es,
temos:
• Sequente representado pelo no´ [1]
{-1} sub_of_frst_diff(s!1, t!1) = sig1
|-------
{1} Card(union(Vars(ext(sig1)(s!1)), Vars(ext(sig1)(t!1)))) <
Card(union(Vars(s!1), Vars(t!1)))
Note que estamos denotando a substituic¸a˜o que resolve a primeira diferenc¸a por sig1.
Para chegar a uma contradic¸a˜o a partir de 1, utilizamos a seguinte estrate´gia: mostramos
em um outro lema, denominado union_vars_ext_sub_of_frst_diff, que
Vars(σˆ(s)) ∪ Vars(σˆ(t)) = Vars(s) ∪ Vars(t) \ Dom(σ),
e utilizamos o lema card_diff_subset da teoria finite_sets da biblioteca do prelu´dio do
PVS, onde se afirma que dados dois conjuntos A e B, vale que
A ⊂ B ⇒ Card(B \ A) = Card(B)− Card(A).
Assim, utilizando estes dois lemas, e apo´s alguns passo de prova, temos:
• Sequente representado pelo no´ [2]
{-1} subset?(Dom(sig1), union(Vars(s!1), Vars(t!1))) IMPLIES
card(difference(union(Vars(s!1), Vars(t!1)), Dom(sig1))) =
card(union(Vars(s!1), Vars(t!1))) - card(Dom(sig1))
[-2] sub_of_frst_diff(s!1, t!1) = sig1
|-------
[1] Card(difference(union(Vars(s!1), Vars(t!1)), Dom(sig1))) <
Card(union(Vars(s!1), Vars(t!1)))
A este sequente aplicamos a regra prop, que realiza uma simplificac¸a˜o proposicional
e divide a prova neste ponto em dois ramos. O primeiro destes ramos comec¸a com o
seguinte objetivo:
• Sequente representado pelo no´ [3]
{-1} card(difference(union(Vars(s!1), Vars(t!1)), Dom(sig1))) =
card(union(Vars(s!1), Vars(t!1))) - card(Dom(sig1))
[-2] sub_of_frst_diff(s!1, t!1) = sig1
|-------
[1] Card(difference(union(Vars(s!1), Vars(t!1)), Dom(sig1))) <
Card(union(Vars(s!1), Vars(t!1)))
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 78
Figura 4.5.1
[3] `
(case-replace “card(Dom(sig1)) = 1”)
hhhh
hhhh XXXXX
XXXXX
` `
(assert) (hide-all-but 1)
`
(rewrite “card one”)
`
(lemma “dom sub of frst diff is”)
`
(inst -1 “resolving diff(s!1, t!1)”
“s!1”“t!1”“sig1”)
`
(assert)
`
(prop)
ccccccccc
ccccccccc
cccccccc
TTTT
TTTT
` `
(inst 1 “subtermOF(s!1,
resolving diff(s!1, t!1))”)
vvv SSSS
SS
(lemma “resolving diff vars”)
` ` `
(expand*
“restrict”“singleton”)
(expand “V”)
(inst -1 “s!1”“t!1”
“resolving diff(s!1, t!1)”)
llll
ll PPP
PP
` ` `
(propax) (assert) (hide-all-but 1)
` `
(inst 2 “subtermOF(t!1,
resolving diff(s!1, t!1))”)
jjjj
jjjj
jj CC
CC
` ` (rewrite“position t resolving diff”)
(expand* “restrict”“singleton”) (expand “V”) `
` (lemma“position s resolving diff”)
(propax) `
(inst -1 “s!1”“t!1”
“resolving diff(s!1, t!1)”)
Figura 4.5.2: Parte da a´rvore de prova do Lema 4.5.1.
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 79
Neste ponto consideramos o caso em que card(Dom(sig1)) = 1. O que nos leva a
outros dois ramos de prova. O primeiro completamos com um assert, pois neste caso -1
e´ uma contradic¸a˜o de 1. E com isto completamos o ramo principal da prova. No segundo
caso, temos que provar que de fato card(Dom(sig1)) = 1, mas ja´ temos formalizado no
lema dom_sub_of_frst_diff_is, o fato de que o domı´nio da substituic¸a˜o que resolve a
primeira diferenc¸a e´ unita´rio. Assim, partindo deste lema, completamos este ramo da
prova, e depois de verificar outros ramos gerados pelo typechecker, chegamos ao seguinte:
• Sequente representado pelo no´ [4]
[-1] sub_of_frst_diff(s!1, t!1) = sig1
|-------
{1} subset?(Dom(sig1), union(Vars(s!1), Vars(t!1)))
[2] Card(difference(union(Vars(s!1), Vars(t!1)), Dom(sig1))) <
Card(union(Vars(s!1), Vars(t!1)))
Este sequente representa o segundo objetivo gerado pela aplicac¸a˜o da regra prop. Neste
queremos concluir que se σ = sub_of_frst_diff(s, t), enta˜o
Dom(σ) ⊂ Vars(s) ∪ Vars(t). (4.5.1)
Este objetivo esta representado pela fo´rmula 1 do sequente acima. Para concluir este
ramo da prova utilizamos novamente o lema dom_sub_of_frst_diff_is, onde mostramos
tambe´m que se p e´ a posic¸a˜o da primeira diferenc¸a entre os termos s e t, enta˜o temos
apenas duas possibilidades exclusivas para o domin´ınio de σ, ou Dom(σ) = {s|p} ou
Dom(σ) = {t|p}. Em ambos os casos temos que 4.5.1 e´ satisfeita, pois
Dom(σ) = {s|p} ⇒ Dom(σ) ⊂ Vars(s)
⇒ Dom(σ) ⊂ Vars(s) ∪ Vars(t)
ou
Dom(σ) = {t|p} ⇒ Dom(σ) ⊂ Vars(t)
⇒ Dom(σ) ⊂ Vars(s) ∪ Vars(t)
Assim, antes de aplicarmos o lema mencionado, realizamos alguns passos de prova,
onde expandimos as definic¸o˜es de subset?, member e union, aplicamos simplificac¸o˜es pro-
posicionais e decompomos uma igualdade chegando ao seguinte objetivo de prova:
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 80
Figura 4.5.1
` [4]
(hide 2)
`
(expand “subset?”)
`
(skosimp*)
`
(expand* “union”“member”)
`
(flatten)
` [5]
(expand “Vars”)
`
(lemma “dom sub of frst diff is”)
`
(inst -1 “resolving diff(s!1, t!1)”“s!1”“t!1”“sig1”)
`
(assert)
(expand* “restrict”“singleton”)
`
(prop)
eeeeee
eeeeee
eee
[[[[[[[[[
[[[[[[[[[
[[[[[[
` `
(decompose-equality -2) (decompose-equality -1)
mmmm
m SSSS
SS
` ` `
(inst -1 “x!1”) (inst -1 “x!1”) (hide-all-but 1)
` ` `
(assert) (assert)
` ` (rewrite “position t resolving diff”)
(hide-all-but (-1 2)) (hide-all-but (-1 3))
` `
(inst 1 “resolving diff(s!1, t!1)”) (inst 1 “resolving diff(s!1, t!1)”)
` `
(assert) (assert)
Figura 4.5.3: Parte da a´rvore de prova do Lema 4.5.1.
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 81
• Sequente representado pelo no´ [5]
[-1] Dom(sig1)(x!1)
[-2] sub_of_frst_diff(s!1, t!1) = sig1
|-------
{1} Vars(s!1)(x!1)
{2} Vars(t!1)(x!1)
A varia´vel x!1 surge quando expandimos a definic¸a˜o de subset? e skolemizamos a
varia´vel da fo´rmula quantificada universalmente que obtemos no consequente. Assim, o
que queremos neste objetivo e´ mostrar que se x!1 e´ uma varia´vel do domı´nio de sig1
(fo´rmula -1), enta˜o ou x!1 e´ uma varia´vel de Vars(s!1) (fo´rmula 1) ou x!1 e´ uma varia´vel
de Vars(t!1) (fo´rmula 2). Neste ponto utilizamos o lema dom_sub_of_frst_diff_is, e apo´s
alguns passos de prova, onde realizamos simpificac¸o˜es completamos este ramo da prova,
que tambe´m possui sub-ramos onde provamos alguns TCC’s gerados pelo typechecker.
4.5.2 Lema sub_of_frst_diff_unifier_o
Neste lema, provamos que sempre que uma substituic¸a˜o pertence ao conjunto de uni-
ficadores de dois termos unifica´veis, enta˜o existe uma outra substituic¸a˜o que composta
com aquela computada em um passo de execuc¸a˜o do algoritmo de unificac¸a˜o, resulta na
primeira. Este lema corresponde ao Lema 2.2.14, sobre generalidade local do algoritmo
de unificac¸a˜o. Na Tabela 4.2.6 temos a especificac¸a˜o do lema seguinte e nas figuras 4.5.4,
4.5.5 e 4.5.6 a sua a´rvore de prova.
Lema 4.5.2: Sejam s e t termos unifica´veis e diferentes e σ a substituic¸a˜o que resolve a
primeira diferenc¸a entre os termos s e t, isto e´, σ = sub_of_frst_diff(s, t). Enta˜o, para
todo unificador θ ∈ U(s, t), existe uma substituic¸a˜o δ tal que θ = δ ◦ σ.
Demonstrac¸a˜o: Na demonstrac¸a˜o deste lema, basicamente vamos mostrar que as subs-
tituic¸o˜es θ e δ ◦ σ possuem o mesmo domı´nio e a mesma imagem. Temos o seguinte
objetivo inicial de prova:
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 82
` [raiz]
(skosimp)
`
(assert)
`
(name-replace “sig!1”
“sub of frst diff(s!1, t!1)” :hide? nil)
`
(name “p!1”“resolving diff(s!1, t!1)”)
[1] `
(inst 1 “rho!1”)
`
(lemma “unifiable terms unifiable args”)
`
(inst -1 “rho!1”“s!1”“t!1”“p!1”)
XXXXXX
XXXXXX
XXX
ffffff
ffffff
ffff
` `
(assert) (hide-all-but (-1 1))
` `
(expand* “member”“U”“unifier”) (rewrite “position t resolving diff”)
` `
(decompose-equality -1) (lemma “position s resolving diff”)
` `
(expand “comp”) (inst -1 “s!1”“t!1”“p!1”)
` `
(case “vars?(subtermOF(s!1, p!1))”) (assert)
Figura 4.5.5 Figura 4.5.6
Figura 4.5.4: Ramificac¸a˜o inicial da a´rvore de prova do Lema 4.5.2. A parte final da a´rvore de prova
consta das figuras 4.5.5 e 4.5.6.
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 83
• Sequente representado pelo no´ [raiz]
|-------
{1} FORALL (rho: Sub[variable, symbol, arity], s: term,
t: term | unifiable(s, t) & s /= t):
member(rho, U(s, t)) IMPLIES
LET sig = sub_of_frst_diff(s, t) IN
EXISTS theta: rho = comp(theta, sig)
Comec¸amos skolemizando as varia´veis ligadas da fo´rmula 1. Apo´s alguns passos temos
o seguinte sequente, onde e´ poss´ıvel visualizar de forma mais clara o nosso objetivo de
prova.
• Sequente representado pelo no´ [1]
{-1} resolving_diff(s!1, t!1) = p!1
[-2] sub_of_frst_diff(s!1, t!1) = sig!1
[-3] member(rho!1, U(s!1, t!1))
|-------
[1] EXISTS theta: rho!1 = comp(theta, sig!1)
Temos uma substituic¸a˜o rho!1, que pela fo´rmula -3, e´ um unificador de s!1 e t!1.
Queremos chegar ao resultado da fo´rmula 1, isto e´, existe uma substituic¸a˜o theta que
composta com sig!1 resulta em rho!1 e, como vemos em -2, sig!1 e´ a substituic¸a˜o que
resolve a primeira diferenc¸a entre s!1 e t!1. A estrate´gia e´ instanciar a fo´rmula 1 com a
pro´pria rho!1. Mas como rho!1 unifica s!1 e t!1, temos em mente que
member(rho!1, U(s!1, t!1)) IMPLIES
member(rho!1, U(subtermOF(s!1, q!1), subtermOF(t!1, q!1))),
onde q!1 e´ uma posic¸a˜o qualquer dos termos s!1 e t!1. Assim, o que faremos e´ obser-
var o caso particular em que q!1 = p!1, onde vemos na fo´rmula -1 que p!1 e´ a posic¸a˜o
onde ocorre a primeira diferenc¸a entre os termos s!1 e t!1. Como ja´ sabemos que na
posic¸a˜o p!1 ou o subtermo de s!1 e´ uma varia´vel ou o subtermo de t!1 e´ uma varia´vel,
uma boa estrate´gia e´ analizar cada um destes casos. Assim prosseguimos e temos enta˜o
ramificac¸o˜es na a´rvore de prova. Apo´s alguns passos de prova, comec¸amos pelo caso em
que subtermOF(s!1,p!1) e´ uma varia´vel.
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 84
• Sequente representado pelo no´ [2]
{-1} vars?(subtermOF(s!1, p!1))
[-2] ext(rho!1)(subtermOF(s!1, p!1)) = ext(rho!1)(subtermOF(t!1, p!1))
[-3] resolving_diff(s!1, t!1) = p!1
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] ext(rho!1)(s!1) = ext(rho!1)(t!1)
|-------
[1] rho!1(x!1) = ext(rho!1)(sig!1(x!1))
Observe que temos uma nova varia´vel x!1 na fo´rmula 1, que aparece quando decompo-
mos a igualdade desta fo´rmula, isto e´, temos que se rho!1 = comp(theta, sig!1), enta˜o
rho!1(x!1) = ext(rho!1)(sig!1(x!1)), para qualquer varia´vel x!1. Enta˜o neste ponto da
prova, novamente vamos considerar casos. Primeiro o caso em que x!1 = subtermOF(s!1,
p!1). Neste caso, observe que pela definic¸a˜o de sub_of_frst_diff temos que:
• Sequente representado pelo no´ [3]
{-1} x!1 = subtermOF(s!1, p!1)
[-2] vars?(subtermOF(s!1, p!1))
[-3] ext(rho!1)(subtermOF(s!1, p!1)) = ext(rho!1)(subtermOF(t!1, p!1))
[-4] resolving_diff(s!1, t!1) = p!1
[-5] sub_of_frst_diff(s!1, t!1) = sig!1
[-6] ext(rho!1)(s!1) = ext(rho!1)(t!1)
|-------
[1] rho!1(x!1) = ext(rho!1)(sig!1(x!1))
Deste sequente, tiramos as seguintes concluso˜es:
Por definic¸a˜o de sig!1, temos que
ext(sig!1)(subtermOF(s!1, p!1)) = subtermOF(t!1, p!1).
Ale´m disso, estamos no caso em que x!1 = subtermOF(s!1, p!1) e sendo rho!1 um
unificador de s e t, enta˜o
ext(rho!1)(subtermOF(s!1, p!1)) = ext(rho!1)(subtermOF(t!1,p!1)).
Logo, conclu´ımos que
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 85
Figura 4.5.4
(case “vars?(subtermOF(s!1, p!1))”)
ggggg
ggggg
ggggg
[2] ` Figura 4.5.6
(case “x!1 = subtermOF(s!1, p!1)”)
iiii
iiii
iiii
WWWWW
WWWWW
WWWWW
[3] ` ` [5]
(replace -5 1 rl) (replace -4 2 rl)
` `
(expand “sub of frst diff” 1) (expand “sub of frst diff” 2)
` `
(assert) (assert)
` ` [6]
(replace -4 1) (hide-all-but 2)
` `
(replace -1 -3 rl) (typepred “x!1”)
` `
(hide-all-but -3 1) (expand “V”“ext”)
[4] ` `
(expand “ext” -1 1) (assert)
`
(propax)
Figura 4.5.5: Parte da a´rvore de prova do Lema 4.5.2. Representa o caso em que o termo
subtermOF(s!1, p!1) e´ uma varia´vel.
ext(rho!1)(x!1) = ext(rho!1)(subtermOF(t!1, p!1))
⇒ ext(rho!1)(x!1) = ext(rho!1)(ext(sig!1)(subtermOF(s!1,p!1)))
⇒ ext(rho!1)(x!1) = ext(rho!1)(ext(sig!1)(x!1)),
onde a u´ltima expressa˜o e´ justamente a fo´rmula 1 do sequente anterior. Assim, reali-
zando alguns passos de prova, onde reproduzimos o racioc´ınio descrito acima, obtemos o
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 86
sequente:
• Sequente representado pelo no´ [4]
[-1] ext(rho!1)(x!1) = ext(rho!1)(subtermOF(t!1, p!1))
|-------
[1] rho!1(x!1) = ext(rho!1)(subtermOF(t!1, p!1))
Note que temos uma contradic¸a˜o pois na fo´rmula 1 temos a negac¸a˜o de -1. Para con-
cluir este ramo da prova basta expandir a definic¸a˜o de ext, pois como x!1 e´ uma varia´vel,
enta˜o ext(rho!1)(x!1) = rho!1(x!1). Com isto completamos este ramo da prova.
No pro´ximo ramo estamos no caso em que x!1 6= subtermOF(s!1, p!1). O sequente
inicial e´ dado por:
• Sequente representado pelo no´ [5]
[-1] vars?(subtermOF(s!1, p!1))
[-2] ext(rho!1)(subtermOF(s!1, p!1)) = ext(rho!1)(subtermOF(t!1, p!1))
[-3] resolving_diff(s!1, t!1) = p!1
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] ext(rho!1)(s!1) = ext(rho!1)(t!1)
|-------
{1} x!1 = subtermOF(s!1, p!1)
[2] rho!1(x!1) = ext(rho!1)(sig!1(x!1))
Neste caso a demonstrac¸a˜o e´ mais direta, pois como x!1 e´ uma varia´vel que na˜o
pertence ao domı´nio de sig!1, enta˜o sig!1(x!1) = x!1. Assim, basta expandir a definic¸a˜o
de sig!1 em 2 e teremos diretamente que rho!1(x!1) = ext(rho!1)(x!1). Portanto, apo´s
alguns passos de prova, temos o sequente:
• Sequente representado pelo no´ [6]
[-1] vars?(subtermOF(s!1, p!1))
[-2] ext(rho!1)(subtermOF(s!1, p!1)) = ext(rho!1)(subtermOF(t!1, p!1))
[-3] resolving_diff(s!1, t!1) = p!1
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] ext(rho!1)(s!1) = ext(rho!1)(t!1)
|-------
[1] x!1 = subtermOF(s!1, p!1)
{2} rho!1(x!1) = ext(rho!1)(x!1)
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 87
Note que neste sequente a fo´rmula principal e´ o consequente 2. Assim, como ja´ men-
cionamos, expandimos ext e com isto completamos este ramo da prova.
No ramo seguinte consideramos o caso em que o termo subtermOF(t!1, p!1) e´ uma
varia´vel. Este ramo e´ inteiramente ana´logo ao que descrevemos acima, e na˜o o exporemos
aqui.
Passando ao ramo seguinte, temos o seguinte sequente:
• Sequente representado pelo no´ [7].
[-1] ext(rho!1)(subtermOF(s!1, p!1)) = ext(rho!1)(subtermOF(t!1, p!1))
[-2] resolving_diff(s!1, t!1) = p!1
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] ext(rho!1)(s!1) = ext(rho!1)(t!1)
|-------
{1} vars?(subtermOF(t!1, p!1))
[2] vars?(subtermOF(s!1, p!1))
[3] rho!1(x!1) = ext(rho!1)(sig!1(x!1))
Observe que neste ramo estamos considerando o caso em que nenhum dos termos
subtermOF(t!1, p!1) e subtermOF(s!1, p!1) e´ uma varia´vel. Mas ja´ sabemos que este
caso na˜o ocorre, e este fato esta´ formalizado no lema resolving_diff_vars , cuja es-
pecificac¸a˜o apresentamos na Tabela 4.2.4. Assim, com este lema apo´s feitas as devidas
instanciac¸o˜es temos o sequente:
• Sequente representado pelo no´ [8]
{-1} p!1 = resolving_diff(s!1, t!1) IMPLIES
vars?(subtermOF(s!1, p!1)) OR vars?(subtermOF(t!1, p!1))
[-2] resolving_diff(s!1, t!1) = p!1
|-------
[1] vars?(subtermOF(t!1, p!1))
[2] vars?(subtermOF(s!1, p!1))
Note que temos uma contradic¸a˜o, pois pela fo´rmula 1, subtermOF(t!1, p!1) na˜o e´ uma
varia´vel, e pela fo´rmula 2, subtermOF(s!1, p!1) na˜o e´ uma varia´vel, mas pela fo´rmula -1,
ou subtermOF(s!1, p!1) e´ uma varia´vel ou subtermOF(t!1, p!1) e´ uma varia´vel. Assim,
com uma aplicac¸a˜o da regra assert, completamos este ramo da prova.
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 88
Figura 4.5.4
(case “vars?(subtermOF(s!1, p!1))”)
YYYYYY
YYYYYY
YYYYYY
Figura 4.5.5 `
(case “vars?(subtermOF(t!1, p!1))”)
ffffff
ffffff
ffffff
PPP
PPP
PP
` ` [7]
(case “x!1 = subtermOF(t!1, p!1)”)
iiii
iiii
iiii
RRRR
RRRR
R (hide-all-but (-2 1 2))
` ` `
(replace -5 2 rl) (replace -4 3 rl)
` ` (lemma“resolving diff vars”)
(expand “sub of frst diff” 2)
(expand
“sub of frst diff” 3) `
` ` (inst -1 “s!1”“t!1”“p!1”)
PPP
PPP
PP


(assert) (assert) [8] ` `
` ` (assert) (hide 2 3)
(replace -4 2) (hide-all-but 3) `
` ` (rewrite“position t resolving diff”)
(replace -1 -3 rl) (typepred “x!1”) `
` ` (lemma“position s resolving diff”)
(hide-all-but (-3 2)) (expand “V”“ext”) `
` ` (inst -1 “s!1”“t!1”“p!1”)
(expand “ext” -1 2) (assert) `
` (assert)
(assert)
Figura 4.5.6: Parte da a´rvore de prova do Lema 4.5.2. Representa o caso em que o termo
subtermOF(s!1, p!1) na˜o e´ uma varia´vel. A ramificac¸a˜o abaixo no no´ [7], representa o caso em que
nem subtermOF(s!1, p!1) e nem subtermOF(t!1, p!1) sa˜o varia´veis.
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 89
Novamente apresentamos apenas o ramo principal da formalizac¸a˜o do Lema 4.5.2,
denominado sub_of_frst_unifier_o. Outros ramos gerados pela operac¸a˜o de checagem
de tipos na˜o sera˜o comentados aqui.
4.5.3 Lema ext_sub_of_frst_diff_unifiable
Nesta sec¸a˜o apresentamos a formalizac¸a˜o do lema ext_sub_of_frst_diff_unifiable, onde
provamos que os termos obtidos via instanciac¸a˜o, de dois termos unifica´veis e diferentes,
pela substituic¸a˜o computada pelo construtor sub_of_frst_diff aplicado a estes dois ter-
mos, sa˜o ainda termos unifica´veis.
O lema sub_of_frst_diff_unifiable foi necessa´rio na formalizac¸a˜o do Lema 4.4.1,
denominado unification_algorithm_gives_unifier. Tambe´m foi necessa´rio na demons-
trac¸a˜o de um importante TCC sobre o construtor unification_algorithm, onde deve-se
verificar que o construtor preserva a tipagem dos termos, no sentido de que os novos
termos gerados no processo de recursa˜o devem ser ainda unifica´veis.
O lema sub_of_frst_diff_unifiable corresponde a um dos resultados do Lema 2.2.14,
demonstrado no Cap´ıtulo 2, onde vimos a sua importaˆncia na verificac¸a˜o da completude do
algoritmo de unificac¸a˜o. A especificac¸a˜o deste lema consta da Tabela 4.2.6. A formalizac¸a˜o
deste lema e´ bastante simples, pois resulta de uma aplicac¸a˜o direta do Lema 4.5.2. Assim,
apresentaremos a formalizac¸a˜o deste lema sem expor a a´rvore de prova, que possui apenas
um ramo.
Lema 4.5.3: Sejam s e t termos unifica´veis e diferentes e σ a substituic¸a˜o que resolve a
primeira diferenc¸a entre os termos s e t, isto e´, σ = sub_of_frst_diff(s, t). Enta˜o, os
termos σˆ(s) e σˆ(t) sa˜o ainda unifica´veis.
Demonstrac¸a˜o: Comec¸amos a demonstrac¸a˜o deste lema com o seguinte objetivo de
prova:
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 90
|-------
{1} FORALL (s: term, t: term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
unifiable(ext(sig)(s), (ext(sig)(t)))
Como ja´ mencionamos anteriormente, a formalizac¸a˜o deste lema segue diretamente do
Lema 4.5.2. De fato, o lema ext_sub_of_frst_diff_unifiable e´ um corola´rio do lema
sub_of_frst_diff_unifier_o. Assim, apo´s skolemizar as varia´veis do sequente acima,
utilizamos a regra lemma, a fim de trazer para as fo´rmulas do antecedente a hipo´tese do
lema sub_frst_diff_unifier_o, e com isto obtemos o seguinte:
{-1} FORALL (rho: Sub[variable, symbol, arity], s: term,
t: term | unifiable(s, t) & s /= t):
member(rho, U(s, t)) IMPLIES
LET sig = sub_of_frst_diff(s, t) IN
EXISTS theta: rho = comp(theta, sig)
[-2] sub_of_frst_diff(s!1, t!1) = sig1
|-------
[1] unifiable(ext(sig1)(s!1), (ext(sig1)(t!1)))
Note que a fo´rmula -1 esta quantificada universalmente, e devemos instancia´-la ade-
quadamente com uma substituic¸a˜o que seja um unificador dos termos s!1 s!2. Esta
substituic¸a˜o saira´ do fato de que estes dois termos sa˜o unifica´veis. Assim, apo´s alguns
passos de prova, obtemos:
[-1] unifier(sigma)(s!1, t!1)
{-2} EXISTS theta: sigma = comp(theta, sig1)
[-3] sub_of_frst_diff(s!1, t!1) = sig1
|-------
[1] s!1 = t!1
[2] EXISTS sigma: unifier(sigma)(ext(sig1)(s!1), (ext(sig1)(t!1)))
Neste ponto da prova temos a fo´rmula -2, que e´ uma consequeˆncia direta do lema
sub_frst_diff_unifier_o, onde temos que existe uma substituic¸a˜o que composta com
sig1 resulta no unificador sigma. Enta˜o skolemizamos esta fo´rmula e usamos a varia´vel
skolemizada para instanciar a fo´rmula 2. Apo´s alguns passos de prova, temos:
4.5 Terminac¸a˜o e Formalizac¸a˜o de Lemas Sobre o Construtor sub_of_frst_diff 91
{-1} ext(comp(theta, sig1))(s!1) = ext(comp(theta, sig1))(t!1)
[-2] sub_of_frst_diff(s!1, t!1) = sig1
|-------
{1} ext(theta)(ext(sig1)(s!1)) = ext(theta)((ext(sig1)(t!1)))
Assim, como feito no Lema 4.4.2, temos que verificar que dadas duas substituic¸o˜es
θ e σ quaiquer, vale que θ̂ ◦ σ = θˆ ◦ σˆ. Novamente utilizamos o lema ext_o da teoria
substitution. Reescrevemos com este lema, utilizando a regra rewrite, e completamos a
prova.
Cap´ıtulo 5
Conclusa˜o e Trabalhos Futuros
Neste trabalho apresentamos uma formalizac¸a˜o para a teoria de unificac¸a˜o de primeira
ordem, desenvolvida em PVS como uma sub-teoria da teoria trs [8] para sistemas de
reescrita de termos, denominada unification. A sub-teoria unification foi desenvolvida
com base no algoritmo de unificac¸a˜o de Robinson, onde formalizamos e provamos a cor-
rec¸a˜o de uma versa˜o deste algoritmo, que corresponde a` existeˆncia de mgu’s para termos
unifica´veis.
Na teoria trs encontramos uma base so´lida de conceitos, como por exemplo as defi-
nic¸o˜es de termo, posic¸a˜o, substituic¸a˜o, dentre outros, ale´m de va´rios resultados forma-
lizados sobre tais conceitos que foram essenciais para o desenvolvimento da sub-teoria
unification.
A partir da formalizac¸a˜o da correc¸a˜o do algoritmo de unificac¸a˜o, feita em dois teoremas
onde provamos que a substituic¸a˜o computada pelo algoritmo de unificac¸a˜o, tendo como
entradas dois termos unifica´veis, e´ um elemento do conjunto de unificadores destes dois
termos e e´ tambe´m mais geral que qualquer outro elemento deste conjunto, chegamos a`
formalizac¸a˜o do resultado principal da sub-teoria unification, o teorema que estabelece
a existeˆncia de substituic¸o˜es mais gerais para dois termos unifica´veis, que completa a
teoria trs, ja´ que isto foi tratado anteriormente como um axioma. Em particular, na
prova do teorema dos pares cr´ıticos de Knuth-Bendix e´ necessa´rio, quando da aplicac¸a˜o
de juntabilidade de divergeˆncias geradas por instaˆncias de pares cr´ıticos. Assim, com a
conclusa˜o da formalizac¸a˜o deste teorema da sub-teoria unification, atingimos o objetivo
inicial deste trabalho que era desenvolver uma sub-teoria para tratar da existeˆncia e
unicidade de unificadores mais gerais dentro da teoria trs.
92
5.1 Trabalhos Relacionados 93
Na sub-teoria unification foram formalizados 27 lemas. Alguns lemas auxiliares foram
acrescentados a`s sub-teorias substitution, subterm e position, totalizando 14 lemas. Em
seguida apresentamos na Tabela 5.0.1 alguns dados quantitativos acerca da sub-teoria
unification. Estes dados consistem de informac¸o˜es sobre a quantidade de linhas de
especificac¸a˜o e de prova e sobre o tamanho da especificac¸a˜o e do arquivo de provas.
Tabela 5.0.1: Ana´lise Quantitativa da sub-teoria unification
Arquivos Linhas Tamanho
arquivo de especificac¸a˜o 274 9.6 KB
arquivo de provas 11404 637.4 KB
Ale´m dos lemas especificados, tivemos um total de 36 TCC’s gerados, isto e´, 36 obri-
gac¸o˜es de prova geradas automaticamente durante a checagem de tipos realizada pelo
typechecker do PVS. Dentre o total de TCC’s, 30 foram provados manualmente e 6 fo-
ram provados diretamente pelo provador, com alguma dependeˆncia em relac¸a˜o a TCC’s
anteriores.
Um ponto importante e bastante positivo do assistente de provas PVS, e´ que sua
linguagem de especificac¸a˜o permite desenvolver teorias com uma linguagem muito pro´xima
da encontrada nos livros texto. Assim, foi poss´ıvel desenvolver a sub-teoria unification
de forma que, mesmo um leitor na˜o familiarizado com o PVS na˜o encontre dificuldades
em compreender os conceitos formalizados.
5.1 Trabalhos Relacionados
Existem outras verificac¸o˜es de correc¸a˜o de algoritmos de unificac¸a˜o desenvolvidas em
outros assistentes de prova, por exemplo em LCF por Paulson [24], em Booyer-Moore
por Kaufmann [12], em ACL2 por Ruiz-Reina et al [29], em Coq por Joseph Rouyer [28].
Ha´ tambe´m uma formalizac¸a˜o em Isabelle, desenvolvida por Konrad Slind, denominada
Unify, e uma versa˜o melhorada desta, desenvolvida por Alexander Krauss, tambe´m em
Isabelle, denominada Unification.
5.1 Trabalhos Relacionados 94
A primeira formalizac¸a˜o do algoritmo de unificac¸a˜o foi a de Paulson, onde fez-se uma
verificac¸a˜o da teoria de Manna e Waldinger [15] para substituic¸o˜es e unificadores mais
gerais. Na teoria de Manna e Waldinger deriva-se um algoritmo de unificac¸a˜o a partir da
prova de que sua especificac¸a˜o e´ poss´ıvel. Em contraste com a representac¸a˜o de termos
que usamos neste trabalho, dada pela Definic¸a˜o 2.2.2, Paulson trata os termos como sendo
ou varia´veis ou constantes ou combinac¸o˜es de dois termos, isto e´, os termos sa˜o restritos a
serem bina´rios. A estrutura dos termos e´ constru´ıda recursivamente em LCF da seguinte
forma, onde COMB e´ um combinador bina´rio:
struct axm(“ : term”, ‘strict’,
[ ‘CONST’, [“c : const”];
‘VAR’, [“v : var”];
‘COMB’, [“t1 : term”; “t2 : term”]]); ;
A especificac¸a˜o da teoria Unify desenvolvida por Slind em Isabelle segue a mesma
abordagem feita por Paulson, implementando a formalizac¸a˜o de Manna e Waldinger com
algumas simplificac¸o˜es novas, contudo o algoritmo ainda e´ especificado com base em uma
estrutura de termos constru´ıdos por um combinador bina´rio:
datatype ’a uterm =
Var ’a
| Const ’a
| Comb "’a uterm" "’a uterm"
Ja´ a teoria Unification, que tambe´m e´ uma formalizac¸a˜o de um algoritmo de unifcac¸a˜o
de primeira ordem, e´ basicamente uma versa˜o melhorada da formalizac¸a˜o pre´via onde os
termos sa˜o tratados da mesma forma que o fazemos neste trabalho.
datatype ‘a trm =
Var ‘a
| Const ‘a
| App "‘a trm" "‘a trm" (infix "." 60)
Tanto na teoria Unify como na teoria Unification e´ definido um algoritmo de unificac¸a˜o
e depois prova-se a sua correc¸a˜o. Similarmente a` abordagem apresentada neste trabalho,
notamos que nas especificac¸o˜es feitas em Isabelle, a idempoteˆncia da substituic¸a˜o compu-
tada pelo algoritmo de unificac¸a˜o na˜o e´ necessa´ria para provar que o algoritmo e´ correto
ou que termina.
5.2 Trabalhos Futuros 95
Como observado anteriormente, o algoritmo de unificac¸a˜o de Robinson e´ ineficiente,
pois e´ exponencial em tempo de execuc¸a˜o e em complexidade de espac¸o. No trabalho de
Ruiz-Reina et al, e´ apresentada uma verificac¸a˜o de um algoritmo que usa uma estrutura de
dados eficiente, onde os termos sa˜o representados como grafos ac´ıclicos diretos, o resultado
e´ a formalizac¸a˜o da correc¸a˜o de um algoritmo de unificac¸a˜o quadra´tico em tempo de
execuc¸a˜o. Esta especificac¸a˜o e´ baseada na exposic¸a˜o de Corbin e Bidoit [5], onde os
autores mostram que uma escolha apropriada de uma estrutura de dados para representar
termos torna a complexidade do algoritmo de unificac¸a˜o de Robinson, que e´ sabidamente
exponencial, quadra´tica.
5.2 Trabalhos Futuros
Neste trabalho apresentamos uma especificac¸a˜o de um algoritmo que tem como entradas
dois termos unifica´veis, isto e´, exclu´ımos a possibilidade de falha no processo de unificac¸a˜o,
pois a fim de obter uma teoria em PVS para sistemas de reescrita de termos, era extrita-
mente necessa´rio mostrar a exiteˆncia de unificadores mais gerais para termos unifica´veis.
Assim, exerc´ıcios simples de formalizac¸a˜o podem ser propostos, no sentido de especificar
uma nova func¸a˜o, para representar uma versa˜o completa do algoritmo de unificac¸a˜o, que
seja total no conjunto de termos, pois esta que especificamos e´ total sobre o conjunto de
termos unifica´veis, onde essa restric¸a˜o foi poss´ıvel devido ao sistema de tipos dependentes
do PVS. Neste sentido, pode-se idealizar um novo operador que segue a mesma estrutura
do operador sub_of_frst_diff, mas detecte falhas. Para isto comec¸a-se propondo uma
adaptac¸a˜o no operador resolving_diff, que consiste em eliminar restric¸o˜es sobre os pa-
raˆmetros. As restric¸o˜es sobre os paraˆmetros do operador resolving_diff limitam a ac¸a˜o
deste operador a termos unifica´veis e diferentes. Assim, eliminariamos a restric¸a˜o que
limita os paraˆmetros a termos unifica´veis. Com isto, se a posic¸a˜o p da primeira diferenc¸a
entre os termos s e t, obtida pelo operador modificado resolving_diff, e´ tal que uma das
possibilidades ocorre:
• s|p e t|p sa˜o termos funcionais com s´ımbolos de func¸a˜o principais diferentes,
• s|p ∈ V e s|p ∈ Vars(t|p),
5.2 Trabalhos Futuros 96
• t|p ∈ V e t|p ∈ Vars(s|p),
enta˜o o operador modificado sub_of_frst_diff ira´ retornar uma substituic¸a˜o que poderia
ser denominada fail. Algumas mudanc¸as no operador unification_algorithm tambe´m
sera˜o necessa´rias, para considerar o caso em que a substituic¸a˜o computada por sub_-
of_frst_diff e´ fail. Outra proposta, mais elaborada de um projeto de formalizac¸a˜o, e´
desenvolver uma especificac¸a˜o de um algoritmo de unificac¸a˜o eficiente, como a de Ruiz-
Reina et-al para ACL2.
Ale´m disso, temos outras propriedades importantes sobre unificac¸a˜o e mgu que podem
ser formalizadas na sub-teoria unification. Dentre estas temos a propriedade de idem-
poteˆncia, que como vimos na˜o e´ necessa´ria na demonstrac¸a˜o de generalidade. Contudo
ja´ temos especificado o conceito de substituic¸a˜o idempotente bem como a formalizac¸a˜o
de uma propriedade necessa´ria e suficiente para que uma substituic¸a˜o seja idempotente.
Trata-se de um teorema da sub-teoria substitution onde temos que uma substituic¸a˜o
e´ idempotente se, e somente se o conjunto formado pelas varia´veis do domı´nio da subs-
tituic¸a˜o e o conjunto formado pelas varia´veis da imagem da substituic¸a˜o sa˜o disjuntos.
Assim, partindo deste lema pode-se formalizar um teorema que garanta a idempoteˆncia
da substituic¸a˜o computada pelo algoritmo de unificac¸a˜o. Outra propriedade ainda na˜o
formalizada e´ a de unicidade dos mgu’s. Para formalizar esta propriedade precisamos da
definic¸a˜o de renomeamento, que ja´ esta´ especificada na sub-teoria substitution. Essenci-
almente deve ser formalizado que para qualquer mgu θ ∈ U(s, t), se σ e´ o mgu computado
pelo algoritmo de unificac¸a˜o, enta˜o σ e´ uma variante de θ no sentido de que θ . σ e σ . θ.
Apeˆndice A
O Co´digo da Especificac¸a˜o
Neste apeˆndice apresentamos o co´digo completo da especificac¸a˜o da sub-teoria unifica-
tion, que no cap´ıtulo 4 foi apresentado por partes. Aqui e´ poss´ıvel ter uma visa˜o geral da
sub-teoria unification, observando todos os lemas formalizados e a disposic¸a˜o de cada
um dentro da especificac¸a˜o, que finaliza com o teorema 4.3.1.
%%-------------------** Term Rewriting System (TRS) **------------------------
%%
%% Authors : Andreia Borges Avelar and
%% Mauricio Ayala Rincon
%% Universidade de Brasilia - Brasil
%%
%% and
%%
%% Andre Luiz Galdino
%% Universidade Federal de Goias - Brasil
%%
%% Last Modified On: September 29, 2009
%%
%%----------------------------------------------------------------------------
unification[variable: TYPE+, symbol: TYPE+, arity: [symbol -> nat]]: THEORY
BEGIN
ASSUMING
IMPORTING variables_term[variable,symbol,arity],
sets_aux@countability[term],
sets_aux@countable_props[term]
var_countable: ASSUMPTION is_countably_infinite(V)
ENDASSUMING
IMPORTING substitution[variable,symbol, arity]
97
98
Vs: VAR set[(V)]
V1, V2: VAR finite_set[(V)]
V3: VAR finite_set[term]
x, y, z: VAR (V)
tau, sig, sigma,
delta, rho, theta: VAR Sub
st, stp: VAR finseq[term]
r, s, t, t1, t2: VAR term
n: VAR nat
p, q, p1, p2: VAR position
R: VAR pred[[term, term]]
%%%% Defining an instance of a term %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
instance(t, s): bool = EXISTS sigma: ext(sigma)(s) = t;
%%%% Defining substitution more general "<=" %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<=(theta, sigma): bool = EXISTS tau: sigma = comp(tau, theta)
mg_po: LEMMA preorder?(<=)
%%%% Defining unification between two terms %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
unifier(sigma)(s,t): bool = ext(sigma)(s) = ext(sigma)(t)
unifiable(s,t): bool = EXISTS sigma: unifier(sigma)(s,t)
U(s,t): set[Sub] = {sigma: Sub | unifier(sigma)(s,t)}
%%%% Defining a most general unifier "mgu" %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
mgu(theta)(s,t): bool = member(theta, U(s,t)) &
FORALL sigma: member(sigma, U(s,t)) IMPLIES theta <= sigma
%%%% Initial auxiliary lemma %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
uni_diff_equal_length_arg : LEMMA
FORALL (s: term, (t: term | unifiable(s, t) & s /= t), f: symbol,
st: {args: finite_sequence[term] | args‘length = arity(f)}):
NOT st‘length = 0 AND s = app(f, st) IMPLIES
(FORALL (fp: symbol, stp: {args: finite_sequence[term] |
args‘length = arity(fp)}): t = app(fp, stp) IMPLIES
(f = fp & st‘length = stp‘length))
%%%% Position of the first difference between %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% two unifiable and different terms %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
99
resolving_diff(s : term, (t : term | unifiable(s,t) & s /= t ) ):
RECURSIVE position =
(CASES s OF
vars(s) : empty_seq,
app(f, st) :
IF length(st) = 0 THEN empty_seq
ELSE
(CASES t OF
vars(t) : empty_seq,
app(fp, stp) :
LET k : below[length(stp)] =
min({kk : below[length(stp)] |
subtermOF(s,#(kk+1)) /= subtermOF(t,#(kk+1))}) IN
add_first(k+1,
resolving_diff(subtermOF(s,#(k+1)),subtermOF(t,#(k+1))))
ENDCASES)
ENDIF
ENDCASES)
MEASURE s BY <<
%%%% Lemmas about resolving_diff %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
resol_diff_nonempty_implies_funct_terms : LEMMA
FORALL (s: term, (t: term | unifiable(s, t) & s /= t)):
resolving_diff(s,t) /= empty_seq IMPLIES
(app?(s) AND app?(t))
resol_diff_to_rest_resol_diff : LEMMA
FORALL (s: term, (t: term | unifiable(s, t) & s /= t)):
LET rd = resolving_diff(s,t) IN
rd /= empty_seq IMPLIES
resolving_diff(subtermOF(s,#(first(rd))),
subtermOF(t,#(first(rd)))) = rest(rd)
position_s_resolving_diff : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t, p : position):
p = resolving_diff(s, t) IMPLIES positionsOF(s)(p);
position_t_resolving_diff : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t, p : position):
p = resolving_diff(s, t) IMPLIES positionsOF(t)(p);
resolving_diff_has_diff_argument : LEMMA
FORALL (s : term, t : term | unifiable(s,t) & s /= t,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
p = resolving_diff(s, t) IMPLIES
subtermOF(s, p) /= subtermOF(t, p)
resolving_diff_has_unifiable_argument : LEMMA
FORALL (s : term, t : term | unifiable(s,t) & s /= t,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
p = resolving_diff(s, t) IMPLIES
unifiable(subtermOF(s, p), subtermOF(t, p))
resolving_diff_vars : LEMMA
100
FORALL (s : term, t : term | unifiable(s, t) & s /= t,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
p = resolving_diff(s, t) IMPLIES
vars?(subtermOF(s, p)) OR vars?(subtermOF(t, p))
%%%% Auxiliary lemmas about substitutions and unifiers %%%%%%%%%%%%%%%%%%%%%%%%
unifier_o : LEMMA
member(sig, U(ext(theta)(s), ext(theta)(t))) IMPLIES
member(comp(sig, theta), U(s, t))
mgu_o : LEMMA
sig <= rho IMPLIES comp(sig, theta) <= comp(rho, theta)
unifier_and_subs : LEMMA
member(theta, U(s, t)) IMPLIES
(FORALL (sig: Sub): member(comp(sig, theta), U(s, t)))
idemp_mgu_iff_all_unifier : LEMMA
FORALL (theta: Sub | member(theta, U(s, t))):
mgu(theta)(s, t) & idempotent_sub?(theta) IFF
(FORALL (sig: Sub | member(sig, U(s, t))): sig = comp(sig, theta))
unifiable_terms_unifiable_args : LEMMA
FORALL (s : term, t : term,
p : position | positionsOF(s)(p) & positionsOF(t)(p)):
member(sig, U(s, t)) IMPLIES
member(sig, U(subtermOF(s, p), subtermOF(t, p)))
var_term_unifiable_not_var_in_term : LEMMA
FORALL (s : term, t : term ):
vars?(s) & unifiable(s, t) & s /= t IMPLIES
NOT member(s, Vars(t))
%%%% Substitution to fix the %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% first difference %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sub_of_frst_diff(s : term , (t : term | unifiable(s,t) & s /= t )) : Sub =
LET k : position = resolving_diff(s,t) IN
LET sp = subtermOF(s,k) , tp = subtermOF(t,k) IN
IF vars?(sp)
THEN (LAMBDA (x : (V)) : IF x = sp THEN tp ELSE x ENDIF)
ELSE (LAMBDA (x : (V)) : IF x = tp THEN sp ELSE x ENDIF)
ENDIF
%%%% Lemmas about "sub_of_frst_diff" %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
dom_sub_of_frst_diff_is : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t, sig : Sub):
sig = sub_of_frst_diff(s, t) AND p = resolving_diff(s, t)
IMPLIES
IF vars?(subtermOF(s, p))
THEN Dom(sig) = singleton(subtermOF(s, p))
101
ELSE Dom(sig) = singleton(subtermOF(t, p))
ENDIF
var_sub_1stdiff_not_member_term : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s ,t) IN
FORALL ( x | member(x,Dom(sig)), r | member(r,Ran(sig) )) :
NOT member(x, Vars(r))
sub_of_frst_diff_unifier_o : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
member(rho, U(s, t)) IMPLIES
LET sig = sub_of_frst_diff(s, t) IN
EXISTS theta : rho = comp(theta, sig)
ext_sub_of_frst_diff_unifiable : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
unifiable(ext(sig)(s), (ext(sig)(t)))
sub_of_frst_diff_remove_x : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Dom(sig)(x) IMPLIES
(NOT member(x, Vars(ext(sig)(s)))) AND
(NOT member(x, Vars(ext(sig)(t))))
vars_sub_of_frst_diff_s_is_subset_union : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
subset?(Vars(ext(sig)(s)), union( Vars(s), Vars(t)))
vars_sub_of_frst_diff_t_is_subset_union : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
subset?(Vars(ext(sig)(t)), union( Vars(s), Vars(t)))
union_vars_ext_sub_of_frst_diff : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t) :
LET sig = sub_of_frst_diff(s, t) IN
union(Vars(ext(sig)(s)), Vars(ext(sig)(t)))
= difference(union( Vars(s), Vars(t)), Dom(sig))
vars_ext_sub_of_frst_diff_decrease : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Card(union( Vars(ext(sig)(s)), Vars(ext(sig)(t))))
< Card(union( Vars(s), Vars(t)))
%%%% Function to compute a unifier of %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% two unifiable terms %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
unification_algorithm(s : term, (t : term | unifiable(s,t))) : RECURSIVE Sub =
IF s = t THEN identity
ELSE LET sig = sub_of_frst_diff(s, t) IN
102
comp( unification_algorithm(ext(sig)(s) , ext(sig)(t)) , sig)
ENDIF
MEASURE Card(union(Vars(s), Vars(t)))
%%%% Lemmas about "unification_algorithm" %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
unification_algorithm_gives_unifier : LEMMA
unifiable(s,t) IMPLIES member(unification_algorithm(s, t), U(s, t))
unification_algorithm_gives_mg_subs : LEMMA
member(rho, U(s, t)) IMPLIES unification_algorithm(s, t) <= rho
%%%% Existence of a most general unifier %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
unification : LEMMA
unifiable(s,t) => EXISTS theta : mgu(theta)(s,t)
END unification
Apeˆndice B
Formalizac¸a˜o do lema
sub_of_frst_diff_remove_x
Apresenta-se a formalizac¸a˜o do lema sub_of_frst_diff_remove_x, com o intuito de apre-
sentar uma formalizac¸a˜o completa, explicando cada regra de prova utilizada.
Neste lema formalizamos o fato de que, se s e t sa˜o dois termos unifica´veis e se σ e´
a substituic¸a˜o que resolve a primeira diferenc¸a entre os termos s e t enta˜o, se x e´ uma
varia´vel do domı´nio de σ, enta˜o x na˜o e´ membro de Vars(σˆ(s)) e nem de Vars(σˆ(t)). De
fato, sabemos que σ substitui todas as ocorreˆncias de x, em um termo instanciado por σ,
por σ(x).
Primeiro apresentamos a especificac¸a˜o deste lema, que tambe´m pode ser encontrada
no apeˆndice A.
sub_of_frst_diff_remove_x : LEMMA
FORALL (s : term, t : term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Dom(sig)(x) IMPLIES
(NOT member(x, Vars(ext(sig)(s)))) AND
(NOT member(x, Vars(ext(sig)(t))))
Durante a apresetac¸a˜o da formalizac¸a˜o, procederemos da seguinte forma: exporemos
um sequente e em seguida a regra aplicada a este sequente assim como vemos em PVS,
em seguida uma breve explicac¸a˜o da regra aplicada.
Assim, comec¸amos com o seguinte sequente:
103
104
|-------
{1} FORALL (x: (V), s: term, t: term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
Dom(sig)(x) IMPLIES
(NOT member(x, Vars(ext(sig)(s)))) AND
(NOT member(x, Vars(ext(sig)(t))))
Rule? (skosimp)
Com a regra skosimp skolemizamos as varia´veis ligadas da fo´rmula 1. E obtemos:
|-------
{1} LET sig = sub_of_frst_diff(s!1, t!1) IN
Dom(sig)(x!1) IMPLIES
(NOT member(x!1, Vars(ext(sig)(s!1)))) AND
(NOT member(x!1, Vars(ext(sig)(t!1))))
Rule? (assert)
Com a regra assert, realizamos simplificac¸o˜es atrave´s de procedimentos de decisa˜o. E
obtemos:
|-------
{1} Dom(sub_of_frst_diff(s!1, t!1))(x!1) IMPLIES
(NOT member(x!1, Vars(ext(sub_of_frst_diff(s!1, t!1))(s!1)))) AND
(NOT member(x!1, Vars(ext(sub_of_frst_diff(s!1, t!1))(t!1))))
Rule? (name-replace "sig!1" "sub_of_frst_diff(s!1, t!1)" :hide? nil)
Com a regra name-replace, apenas renomeamos e substituimos todas as ocorreˆncias
de sub_of_frst_diff(s!1, t!1) por sig!1. E obtemos:
{-1} sub_of_frst_diff(s!1, t!1) = sig!1
|-------
{1} Dom(sig!1)(x!1) IMPLIES
(NOT member(x!1, Vars(ext(sig!1)(s!1)))) AND
(NOT member(x!1, Vars(ext(sig!1)(t!1))))
Rule? (prop)
105
A regra prop e´ uma regra de simplificac¸a˜o proposicional. O sequente acima corresponde
a seguinte situc¸a˜o: D ⇒ A → (¬B ∨ ¬C), com a aplicac¸a˜o da regra prop temos uma
ramificac¸a˜o na prova onde sa˜o gerados dois objetivos, um da forma B,D,A⇒ e outro da
forma C,D,A⇒. Explicaremos em seguida apenas o primeiro ramo, o segundo e´ ideˆntico
e isto pode ser observado na sua formalizac¸a˜o que apresentamos sem comentar. Assim,
temos:
{-1} member(x!1, Vars(ext(sig!1)(s!1)))
[-2] sub_of_frst_diff(s!1, t!1) = sig!1
{-3} Dom(sig!1)(x!1)
|-------
Rule? (lemma "vars_subst_not_in")
Com esta regra, apenas trazemos para o antecedente uma nova fo´rmula que corres-
ponde ao lema “invocado”, que neste caso e´ o lema vars_subst_not_in. E obtemos:
{-1} FORALL (t: term[variable, symbol, arity],
sigma: Sub[variable, symbol, arity], x: (V)):
(Dom(sigma)(x) AND
(FORALL (r: term[variable, symbol, arity]):
Ran(sigma)(r) IMPLIES NOT member(x, Vars(r))))
IMPLIES NOT member(x, Vars(ext(sigma)(t)))
[-2] member(x!1, Vars(ext(sig!1)(s!1)))
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] Dom(sig!1)(x!1)
|-------
Rule? (inst -1 "s!1" "sig!1" "x!1")
Agora, instanciamos a hipo´tese do lema “invocado” com as devidas varia´veis. E obte-
mos:
106
{-1} (Dom(sig!1)(x!1) AND
(FORALL (r: term[variable, symbol, arity]):
Ran(sig!1)(r) IMPLIES NOT member(x!1, Vars(r))))
IMPLIES NOT member(x!1, Vars(ext(sig!1)(s!1)))
[-2] member(x!1, Vars(ext(sig!1)(s!1)))
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] Dom(sig!1)(x!1)
|-------
Rule? (assert)
Novamente realizamos simplificac¸o˜es com a regra assert. E obtemos:
[-1] member(x!1, Vars(ext(sig!1)(s!1)))
[-2] sub_of_frst_diff(s!1, t!1) = sig!1
[-3] Dom(sig!1)(x!1)
|-------
{1} FORALL (r: term[variable, symbol, arity]):
Ran(sig!1)(r) IMPLIES NOT member(x!1, Vars(r))
Rule? (skosimp)
Novamente skolemizamos as varia´veis ligadas da fo´rmula 1. E obtemos:
{-1} Ran(sig!1)(r!1)
{-2} member(x!1, Vars(r!1))
[-3] member(x!1, Vars(ext(sig!1)(s!1)))
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] Dom(sig!1)(x!1)
|-------
Rule? (hide -3)
Escondemos a fo´rmula -3, pois neste momento ela na˜o e´ necessa´ria na derivac¸a˜o, pore´m
continua na memo´ria do provador, caso desejemos reaveˆ-la. Assim, temos:
107
[-1] Ran(sig!1)(r!1)
[-2] member(x!1, Vars(r!1))
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] Dom(sig!1)(x!1)
|-------
Rule? (lemma "var_sub_1stdiff_not_member_term")
Novamente usamos a regra lema para trazer a`s fo´rmulas do antecedente o lema cha-
mado, que no caso e´ o lema var_sub_1stdiff_not_member_term. E obtemos:
{-1} FORALL (s: term, t: term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
FORALL (x: (V) | member(x, Dom(sig)),
r: term[variable, symbol, arity] | member(r, Ran(sig))):
NOT member(x, Vars(r))
[-2] Ran(sig!1)(r!1)
[-3] member(x!1, Vars(r!1))
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] Dom(sig!1)(x!1)
|-------
Rule? (inst -1 "s!1" "t!1")
Instanciamos a fo´rmula -1 com as devidas varia´veis. E obtemos:
{-1} LET sig = sub_of_frst_diff(s!1, t!1) IN
FORALL (x: (V) | member(x, Dom(sig)),
r: term[variable, symbol, arity] | member(r, Ran(sig))):
NOT member(x, Vars(r))
[-2] Ran(sig!1)(r!1)
[-3] member(x!1, Vars(r!1))
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] Dom(sig!1)(x!1)
|-------
Rule? (replaces -4)
Substituimos todas as ocorreˆncias de sub_of_frst_diff(s!1, t!1) em todas as fo´r-
mulas do sequente, por sig!1, e escondemos a fo´rmula -4. Com isto, obtemos:
108
{-1} LET sig = sig!1 IN
FORALL (x: (V) | member(x, Dom(sig)),
r: term[variable, symbol, arity] | member(r, Ran(sig))):
NOT member(x, Vars(r))
{-2} Ran(sig!1)(r!1)
{-3} member(x!1, Vars(r!1))
{-4} Dom(sig!1)(x!1)
|-------
Rule? (assert)
Novamente realizamos simplificac¸o˜es com a regra assert. E obtemos:
{-1} FORALL (x: (V) | member(x, Dom(sig!1)),
r: term[variable, symbol, arity] | member(r, Ran(sig!1))):
NOT member(x, Vars(r))
[-2] Ran(sig!1)(r!1)
[-3] member(x!1, Vars(r!1))
[-4] Dom(sig!1)(x!1)
|-------
Rule? (inst -1 "x!1" "r!1")
Istanciamos a fo´rmula -1 com as devidas varia´veis. Neste ponto da prova a operac¸a˜o
de checagem de tipos gera outro subobjetivo. Mas antes temos:
[-1] Ran(sig!1)(r!1)
[-2] member(x!1, Vars(r!1))
[-3] Dom(sig!1)(x!1)
|-------
{1} member[term[variable, symbol, arity]]
(r!1, Ran[variable, symbol, arity](sig!1))
Rule? (hide -2 -3)
Escondemos as fo´rmulas -2 e -3 e obtemos:
109
[-1] Ran(sig!1)(r!1)
|-------
[1] member[term[variable, symbol, arity]]
(r!1, Ran[variable, symbol, arity](sig!1))
Rule? (expand "member")
Expandimos a definic¸a˜o de member e com isto obtemos:
[-1] Ran(sig!1)(r!1)
|-------
{1} Ran[variable, symbol, arity](sig!1)(r!1)
Neste ponto obtemos uma contradic¸a˜o, o que nos leva a completar este ramo da prova.
Assim, passamos ao objetivo seguinte onde temos:
[-1] Ran(sig!1)(r!1)
[-2] member(x!1, Vars(r!1))
[-3] Dom(sig!1)(x!1)
|-------
{1} member[(V)](x!1, Dom[variable, symbol, arity](sig!1))
Rule? (hide -1 -2)
Escondemos as fo´rmulas -1 e -2 e passamos ao sequente:
[-1] Dom(sig!1)(x!1)
|-------
[1] member[(V)](x!1, Dom[variable, symbol, arity](sig!1))
Rule? (expand "member")
Novamente expandimos a definic¸a˜o de member e obtemos:
[-1] Dom(sig!1)(x!1)
|-------
{1} Dom[variable, symbol, arity](sig!1)(x!1)
110
Onde temos uma contradic¸a˜o. Com isto completamos este ramo da prova e passamos
ao objetivo seguinte.
Como comentamos anteriormente, o pro´ximo ramo da prova e´ verificado atrave´s da
mesma sequeˆncia de regras de provas que acabamos de descrever. Assim, mostramos a
prova deste ramo, mas sem comentar novamente cada regra.
{-1} member(x!1, Vars(ext(sig!1)(t!1)))
[-2] sub_of_frst_diff(s!1, t!1) = sig!1
{-3} Dom(sig!1)(x!1)
|-------
Rule? (lemma "vars_subst_not_in")
{-1} FORALL (t: term[variable, symbol, arity],
sigma: Sub[variable, symbol, arity], x: (V)):
(Dom(sigma)(x) AND
(FORALL (r: term[variable, symbol, arity]):
Ran(sigma)(r) IMPLIES NOT member(x, Vars(r))))
IMPLIES NOT member(x, Vars(ext(sigma)(t)))
[-2] member(x!1, Vars(ext(sig!1)(t!1)))
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] Dom(sig!1)(x!1)
|-------
Rule? (inst -1 "t!1" "sig!1" "x!1")
{-1} (Dom(sig!1)(x!1) AND
(FORALL (r: term[variable, symbol, arity]):
Ran(sig!1)(r) IMPLIES NOT member(x!1, Vars(r))))
IMPLIES NOT member(x!1, Vars(ext(sig!1)(t!1)))
[-2] member(x!1, Vars(ext(sig!1)(t!1)))
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] Dom(sig!1)(x!1)
|-------
Rule? (assert)
[-1] member(x!1, Vars(ext(sig!1)(t!1)))
[-2] sub_of_frst_diff(s!1, t!1) = sig!1
[-3] Dom(sig!1)(x!1)
|-------
{1} FORALL (r: term[variable, symbol, arity]):
Ran(sig!1)(r) IMPLIES NOT member(x!1, Vars(r))
Rule? (skosimp)
111
{-1} Ran(sig!1)(r!1)
{-2} member(x!1, Vars(r!1))
[-3] member(x!1, Vars(ext(sig!1)(t!1)))
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] Dom(sig!1)(x!1)
|-------
Rule? (hide -3)
[-1] Ran(sig!1)(r!1)
[-2] member(x!1, Vars(r!1))
[-3] sub_of_frst_diff(s!1, t!1) = sig!1
[-4] Dom(sig!1)(x!1)
|-------
Rule? (lemma "var_sub_1stdiff_not_member_term")
{-1} FORALL (s: term, t: term | unifiable(s, t) & s /= t):
LET sig = sub_of_frst_diff(s, t) IN
FORALL (x: (V) | member(x, Dom(sig)),
r: term[variable, symbol, arity] | member(r, Ran(sig))):
NOT member(x, Vars(r))
[-2] Ran(sig!1)(r!1)
[-3] member(x!1, Vars(r!1))
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] Dom(sig!1)(x!1)
|-------
Rule? (inst -1 "s!1" "t!1")
{-1} LET sig = sub_of_frst_diff(s!1, t!1) IN
FORALL (x: (V) | member(x, Dom(sig)),
r: term[variable, symbol, arity] | member(r, Ran(sig))):
NOT member(x, Vars(r))
[-2] Ran(sig!1)(r!1)
[-3] member(x!1, Vars(r!1))
[-4] sub_of_frst_diff(s!1, t!1) = sig!1
[-5] Dom(sig!1)(x!1)
|-------
Rule? (replaces -4)
{-1} LET sig = sig!1 IN
FORALL (x: (V) | member(x, Dom(sig)),
r: term[variable, symbol, arity] | member(r, Ran(sig))):
NOT member(x, Vars(r))
{-2} Ran(sig!1)(r!1)
{-3} member(x!1, Vars(r!1))
{-4} Dom(sig!1)(x!1)
|-------
Rule? (assert)
112
{-1} FORALL (x: (V) | member(x, Dom(sig!1)),
r: term[variable, symbol, arity] | member(r, Ran(sig!1))):
NOT member(x, Vars(r))
[-2] Ran(sig!1)(r!1)
[-3] member(x!1, Vars(r!1))
[-4] Dom(sig!1)(x!1)
|-------
Rule? (inst -1 "x!1" "r!1")
[-1] Ran(sig!1)(r!1)
[-2] member(x!1, Vars(r!1))
[-3] Dom(sig!1)(x!1)
|-------
{1} member[term[variable, symbol, arity]]
(r!1, Ran[variable, symbol, arity](sig!1))
Rule? (hide -2 -3)
[-1] Ran(sig!1)(r!1)
|-------
[1] member[term[variable, symbol, arity]]
(r!1, Ran[variable, symbol, arity](sig!1))
Rule? (expand "member")
[-1] Ran(sig!1)(r!1)
|-------
{1} Ran[variable, symbol, arity](sig!1)(r!1)
which is trivially true.
[-1] Ran(sig!1)(r!1)
[-2] member(x!1, Vars(r!1))
[-3] Dom(sig!1)(x!1)
|-------
{1} member[(V)](x!1, Dom[variable, symbol, arity](sig!1))
Rule? (hide -1 -2)
[-1] Dom(sig!1)(x!1)
|-------
[1] member[(V)](x!1, Dom[variable, symbol, arity](sig!1))
Rule? (expand "member")
[-1] Dom(sig!1)(x!1)
|-------
{1} Dom[variable, symbol, arity](sig!1)(x!1)
which is trivially true.
Refereˆncias Bibliogra´ficas
[1] Mauricio Ayala-Rinco´n. Fundamentos da Programac¸a˜o Lo´gica e Funcional - O
princ´ıpio de resoluc¸a˜o e a teoria de reescrita. Notas de aula, Quarta versa˜o,
Departamento de Matema´tica, Universidade de Bras´ılia, 2008. Dispon´ıvel em:
http://ayala.mat.unb.br/.
[2] Franz Baader and Tobias Nipkow. Term Rewriting and All That. Cambridge Uni-
versity Press, 1998.
[3] Franz Baader and Wayne Snyder. Unification Theory. In J.A. Robinson and A. Vo-
ronkov, editors, Handbook of Automated Reasoning, volume I, pages 447–533. Elsevier
Science Publishers, 2001.
[4] Robert S. Boyer and J. Strother Moore. The Sharing of Structure in Theorem-Proving
Programs. In Machine Intelligence 7, pages 101–116. University Press, 1972.
[5] Jacques Corbin and Michel Bidoit. A Rehabilitation of Robinson’s Unification Algo-
rithm. In IFIP Congress, pages 909–914, 1983.
[6] Andre´ Luiz Galdino. Uma Formalizac¸a˜o da Teoria de Reescrita em Linguagem de
Ordem Superior. PhD thesis, Universidade de Bras´ılia, 2008.
[7] Andre´ Luiz Galdino and Mauricio Ayala-Rinco´n. A Theory for Abstract Rewriting
Systems in PVS. CLEI - electronic journal, 11(2, paper 4), 2008.
113
114
[8] Andre´ Luiz Galdino and Mauricio Ayala-Rinco´n. A PVS Theory for Term Rewriting
Systems. Electronic Notes in Theoretical Computer Science, 247:67–83, 2009.
[9] James R. Guard. Automated Logic for Semi-Automated Mathema-
tics. AFCRL, Scientific Report 1:64–411, March 1964. Dispon´ıvel em:
http://handle.dtic.mil/100.2/AD602710.
[10] Jacques Herbrand. Recherches sur la The´orie de la De´monstration. Ph.d. thesis,
University of Paris, November 1971.
[11] Ge´rard Huet. Resolution D’Equations Dans Les Langages D’Ordre 1, 2,..., ω. PhD
thesis, University of Paris, 1976.
[12] Matt Kaufmann. Generalization in the Presence of Free Variables: A Mechanically-
Checked Proof for one Algorithm. Journal of Automated Reasoning, 7(1):109–158,
1991.
[13] Kevin Knight. Unification: A Multidisciplinary Survey. ACM Computing Surveys,
21(1), March 1989.
[14] Donald E. Knuth and Peter B. Bendix. Simple Word Problems in Universal Algebra.
Computational Problems in Abstract Algebra, pages 263–297, 1970.
[15] Zohar Manna and Richard Waldinger. Deductive Synthesis of the Unification Algo-
rithm. Science of Computer Programming, 1:5–48, 1981.
[16] Alberto Martelli and Ugo Montanari. Unification in Linear Time and Space: A
Structured Presentation. Technical Report Internal Report N0B76− 16, Ist. di Ela-
borazione delle Informazione, Consiglio Nazionale delle Ricerche, Pisa, Italy, 1976.
[17] Alberto Martelli and Ugo Montanari. An Efficient Unification Algorithm. Transac-
tions on Programming Languages and Systems, 4(2):258–282, April 1982.
[18] Sam Owre and Natarajan Shankar. Abstract Datatypes in PVS. Technical Report
SRI-CSL-93-9R, Computer Science Laboratory, SRI International, Menlo Park, CA,
December 1993. Extensively revised June 1997; Also available as NASA Contractor
Report CR-97-206264. Dispon´ıvel em: http://pvs.csl.sri.com/.
115
[19] Sam Owre and Natarajan Shankar. The Formal semantics of PVS. Technical report,
SRI-CSL-97-2, Computer Science Laboratory, SRI International, Menlo Park, CA,
August 1997. Dispon´ıvel em: http://pvs.csl.sri.com/.
[20] Sam Owre and Natarajan Shankar. The PVS Prelude Library. Technical report,
SRI-CSL-03-01, Computer Science Laboratory, SRI International, Menlo Park, CA,
March 2003. Dispon´ıvel em: http://pvs.csl.sri.com/.
[21] Sam Owre, Natarajan Shankar, John M. Rushby, and David W. J. Stringer-Calvert.
PVS Language Reference. Computer Science Laboratory, SRI International, Menlo
Park, CA, September 1999. Dispon´ıvel em: http://pvs.csl.sri.com/.
[22] Sam Owre, Natarajan Shankar, John M. Rushby, and David W. J. Stringer-Calvert.
PVS System Guide. Computer Science Laboratory, SRI International, Menlo Park,
CA, September 1999. Dispon´ıvel em: http://pvs.csl.sri.com/.
[23] Mike S. Paterson and Mark N. Wegman. Linear Unification. In Proceedings of the
Symposium on the Theory of Computing. ACM Special Interest Group for Automata
and Computability Theory (SIGACT), 1976. http://sigact.acm.org.
[24] Lawrence C. Paulson. Verifying the Unification Algorithm in LCF. Science of Com-
puter Programming, 5(2):143–169, 1985.
[25] John C. Reynolds. Transformational Systems and the Algebraic Structure of Atomic
Formulas. In Machine Intelligence 5, pages 135–151. Edinburgh University Press,
1970.
[26] John Alan Robinson. A Machine-Oriented Logic Based on the Resolution Principle.
Journal of the Association for Computing Machinery, 12(1):23–41, January 1965.
[27] John Alan Robinson. Computational Logic: The Unification Computation. Machine
Intelligence, 6:63–72, 1971.
[28] Joseph Rouyer. De´veloppement de l’Algorithme d’Unification dans le Calcul des
Constructions. Technical Report 1795, INRIA, November 1997.
116
[29] Jose´-Luis Ruiz-Reina, Francisco-Jesu´s Mart´ın-Mateos, Jose´-Antonio Alonso, and
Mar´ıa-Jose´ Hidalgo. Formal Correctness of a Quadratic Unification Algorithm. Jour-
nal of Automated Reasoning, 37(1-2):67–92, 2006.
[30] Natarajan Shankar, Sam Owre, John M. Rushby, and David W. J. Stringer-Calvert.
PVS Prover Guide. Computer Science Laboratory, SRI International, Menlo Park,
CA, September 1999. Dispon´ıvel em: http://pvs.csl.sri.com/.
[31] Marisa Venturini-Zilli. Complexity of the Unification Algorithm for First-Order Ex-
pressions. Calcolo, 12(4):361–371, December 1975.
