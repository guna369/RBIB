Nominal Uniﬁcation
Christian Urban Andrew Pitts Murdoch Gabbay
University of Cambridge, Cambridge, UK INRIA, Paris, France
Abstract
We present a generalisation of ﬁrst-order uniﬁcation to the practically important case of equations between terms involving binding operations. A substitution of terms for variables solves such an equation if it makes the equated terms -equivalent, i.e. equal up to renaming bound names. For the applications we have in mind, we must consider the simple, textual form of substitution in which names occurring in terms may be captured within the scope of binders upon substitution. We are able to take a “nominal” approach to binding in which bound entities are explicitly named (rather than using nameless, de Bruijn-style representations) and yet get a version of this form of substitution that respects -equivalence and possesses good algorithmic properties. We achieve this by adapting two existing ideas. The ﬁrst one is terms involving explicit substitutions of names for names, except that here we only use explicit permutations (bijective substitutions). The second one is that the uniﬁcation algorithm should solve not only equational problems, but also problems about the freshness of names for terms. There is a simple generalisation of classical ﬁrst-order uniﬁcation problems to this setting which retains the latter’s pleasant properties: uniﬁcation problems involving -equivalence and freshness are decidable; and solvable problems possess most general solutions.
Key words: Abstract Syntax, Alpha-Conversion, Binding Operations, Uniﬁcation
1 Introduction
Decidability of uniﬁcation for equations between ﬁrst-order terms and algorithms for computing most general uniﬁers form a fundamental tool of computational logic with many applications to programming languages and computer-aided reasoning. However, very many potential applications fall outside the scope of ﬁrst-order uniﬁcation, because they involve term languages with binding operations where at the very least we do not wish to distinguish terms differing up to the renaming of bound names. There is a large body of work studying languages with binders through the use of various -calculi as term representation languages, leading to
Theoretical Computer Science, 2004, Vol. 323(1-3), Pages 473-497.

higher-order uniﬁcation algorithms for solving equations between -terms modulo -equivalence. However, higher-order uniﬁcation is technically complicated without being completely satisfactory from a pragmatic point of view. The reason lies in the difference between substitution for ﬁrst-order terms and for -terms. The former is a simple operation of textual replacement (sometimes called grafting [1], or context substitution [2, Sect. 2.1]), whereas the latter also involves renamings to avoid capture. Capture-avoidance ensures that substitution respects equivalence, but it complicates higher-order uniﬁcation algorithms. Furthermore it is the simple textual form of substitution rather than the more complicated captureavoiding form which occurs in many informal applications of “uniﬁcation modulo
-equivalence”. For example, consider the following schematic rule which might form part of the inductive deﬁnition of a binary evaluation relation for the expressions of an imaginary functional programming language:
. (1)

Here , and are metavariables standing for unknown programming language

expressions. The binders

and

may very well capture

free occurrences of the variable named when we instantiate the schematic rule

by replacing the metavariable with an expression. For instance, using the rule

scheme in a bottom-up search for a proof of

(2)

we would use a substitution that does involve capture, namely

in order to unify the goal with the conclusion of the rule (1)—generating the new goal from the hypothesis of (1). The problem with this is that in informal practice we usually identify terms up to -equivalence, whereas textual substitution does not respect -equivalence. For example, up to -equivalence, the goal
(3)

is the same as (2). We might think (erroneously!) that the conclusion of rule (1)

is the same as

without changing the rule’s hypothesis—

after all, if we are trying to make -equivalence disappear into the infrastructure,

then we must be able to replace any part of what we have with an equivalent part.

So we might be tempted to unify the conclusion with (3) via the textual substitu-

tion , and then apply this substitution to the hypothesis to

obtain a wrong goal,

. Using -calculus and higher-order uniﬁ-

cation saves us from such sloppy thinking, but at the expense of having to make

explicit the dependence of metavariables on bindable names via the use of function

474

variables and application. For example, (1) would be replaced by something like

or, modulo -equivalence

(4)

. (5)

Now goal (3) becomes

and there is no problem unifying it with the

conclusion of (5) via a capture-avoiding substitution of for , for and

for .

This is all very ﬁne, but the situation is not as pleasant as for ﬁrst-order terms: higher-order uniﬁcation problems can be undecidable, decidable but lack most general uniﬁers, or have such uniﬁers only by imposing some restrictions [3]; see [4] for a survey of higher-order uniﬁcation. We started out wanting to compute with binders modulo -equivalence, and somehow the process of making possibly-capturing substitution respectable has led to function variables, application, capture-avoiding substitution and -equivalence. Does it have to be so? No!

For one thing, several authors have already noted that one can make sense of

possibly-capturing substitution modulo -equivalence by using explicit substitu-

tions in the term representation language: see [1,5–9]. Compared with those works,

we make a number of simpliﬁcations. First, we ﬁnd that we do not need to use

function variables, application or -equivalence in our representation language—

leaving just binders and -equivalence. Secondly, instead of using explicit substitu-

tions of names for names, we use only the special case of explicit permutations of

names. The idea of using name-permutations, and in particular name-swappings,

when dealing with -conversion was described in [10] and there is growing evi-

dence of its usefulness (see [11–13], for example). When a name substitution is

actually a permutation, the function it induces from terms to terms is a bijection;

this bijectivity gives the operation of permuting names very good logical proper-

ties compared with name substitution. Consider for example the -equivalent terms

and , where , and are distinct. If we apply the substitution (re-

naming all free occurrences of to be ) to them we get

and , which are

no longer -equivalent. Thus renaming substitutions do not respect -equivalence

in general, and any uniﬁcation algorithm using them needs to take extra precautions

to not inadvertently change the intended meaning of terms. The traditional solution

for this problem is to introduce a more complicated form of renaming substitution

that avoids capture of names by binders. In contrast, the simple operation of name-

permutation respects -equivalence; for example, applying the name-permutation

that swaps all occurrences of and (be they free, bound or binding) to the

terms above gives

and , which are still -equivalent. We exploit such

good properties of name-permutations to give a conceptually simple uniﬁcation

475

algorithm.

In addition to the use of explicit name-permutations, we also compute symbolically

with predicates expressing freshness of names for terms. Such predicates certainly

feature in previous work on binding (for example, Qu-Prolog’s not free in

predicate [8], the notion of “algebraic independence” in [14, Deﬁnition 3], and the

“non-occurrence” predicates of [15]). But once again, the use of such a freshness

predicate based upon name swapping rather than renaming, which arises naturally

from the work reported in [10,16], gives us a simpler theory with good algorith-

mic properties. It is easy to see why there is a need for computing with freshness,

given that we take a “nominal” approach to binders. (In other words we use con-

crete versions of binding and -equivalence in which bound entities are named ex-

plicitly, rather than using de Bruijn-style representations, as for example in [1,7].)

A basic instance of our generalised form of -equivalence identiﬁes

with

provided is fresh for , where the subterm

indicates an ex-

plicit permutation—namely the swapping of and —waiting to be applied to .

We write “ is fresh for ” symbolically as

; the intended meaning of this

relation is that does not occur free in any (ground) term that may be substituted

for . If we know more about we may be able to eliminate the explicit permuta-

tion in

; for example, if we knew that

holds as well as

, then

can be replaced by .

It should already be clear from these simple examples that in our setting the appropriate notion of term-equality is not a bare equation, , but rather a hypothetical judgement of the form
(6)

where is a freshness environment—a ﬁnite set freshness assumptions. For example

of

(7)

is a valid judgement of our nominal equational logic. Similarly, judgements about freshness itself will take the form

(8)

Two examples of valid freshness judgements are .

and

The freshness environment in judgements of the form (6) and (8) expresses freshness conditions that any textual substitution of terms for variables must respect in order for the right-hand side of the judgement to be valid after substitution. This explicit use of freshness makes the operation of textual substitution respect our generalised form of -equivalence. For example, if we were na¨ıvely to regard the terms and as -equivalent, then applying for example the capturing substitution or results into two terms that are not -equivalent

476

anymore. (A similar observation partly motivates the work in [17].) However, if we assume and as in (7), then all problematic substitutions are ruled out. In this way we obtain a version of -equivalence between terms with variables that is respected by textual substitutions (see Lemma 2.14 below), unlike the traditional notion of -equivalence.

Summary

We will represent languages involving binders using the usual notion of ﬁrst-order

terms over a many-sorted signature, but with certain distinguished constants and

function symbols. These give us terms with: distinguished constants naming bind-

able entities, that we call atoms; terms expressing a generic form of binding

of an atom in a term ; and terms representing an explicit permutation

of atoms waiting to be applied to whatever term is substituted for the variable .

Section 2 presents this term-language together with a syntax-directed inductive def-

inition of the provable judgements of the form (6) and (8) which for ground terms

(i.e. ones with no variables) agrees with the usual notions of -equivalence and

“not a free variable of”. However, on open terms our judgements differ from these

standard notions. Section 3 considers uniﬁcation in this setting. Solving equalities

between abstractions

entails solving both equalities

and

freshness problems

. Therefore our general form of nominal uniﬁcation

problem is a ﬁnite collection of individual equality and freshness problems. Such a

problem is solved by providing not only a substitution (of terms for variables),

but also a freshness environment (as above), which together have the property

that and hold for each individual equality

and freshness

in the problem . Our main result with respect to uniﬁca-

tion is that solvability is decidable and that solvable problems possess most general

solutions (for a reasonably obvious notion of “most general”). The proof is via a

uniﬁcation algorithm that is very similar to the ﬁrst-order algorithm given in the

now-common transformational style [18]. (See [19, Sect. 2.6] or [20, Sect. 4.6] for

expositions of this.) Section 4 considers the relationship of our version of “uniﬁ-

cation modulo -equivalence” to existing approaches. Section 5 assesses what has

been achieved and the prospects for applications.

Quiz

To appreciate the kind of problem that nominal uniﬁcation solves, you might like to try the following quiz about the -calculus [21] before we apply our algorithm to solve it at the end of Section 3.
Assuming and are distinct variables, is it possible to ﬁnd -terms that make the following pairs of terms -equivalent?

477

(1) and (2) and (3) and (4) and
If it is possible to ﬁnd a solution for any of these four problems, can you describe what all possible solutions for that problem are like? (The answers are given in Example 3.8.)

2 Nominal equational logic

We take a concrete approach to the syntax of binders in which bound entities are explicitly named. Furthermore we do not assume that the names of bound entities are necessarily variables (things that may be substituted for), in order to encompass examples like the -calculus [22], in which the restriction operator binds channel names and these are quite different from names of unknown processes. Names of bound entities will be called atoms. This is partly for historical reasons (stemming from the work by the second two authors [10]) and partly to indicate that the internal structure of such names is irrelevant to us: all we care about is their identity (i.e. whether or not one atom is the same as another) and that the supply of atoms is inexhaustible.

Although there are several general frameworks in the literature for specifying languages with binders, not all of them meet the requirements mentioned in the previous paragraph. Use of the simply typed -calculus for this purpose is common; but as discussed in the Introduction, it leads to a problematic uniﬁcation theory. Among ﬁrst-order frameworks, Plotkin’s notion of binding signature [23,24], being unsorted, equates names used in binding with names of variables standing for unknown terms; so it is not sufﬁciently general for us. A ﬁrst-order framework that does meet our requirements is the notion of nominal algebras in [15]. The nominal signatures that we use in this paper are a mild (but practically useful) generalisation of nominal algebras in which name-abstraction and pairing can be mixed freely in arities (rather than insisting as in [15] that the argument sort of a function symbol be normalised to a tuple of abstractions).

Deﬁnition 2.1. A nominal signature is speciﬁed by: a set of sorts of atoms (typical

symbol ); a disjoint set of sorts of data (typical symbol ); and a set of function

symbols (typical symbol ), each of which has an arity of the form

. Here

ranges over (compound) sorts given by the grammar

.

Sorts of the form classify terms that are binding abstractions of atoms of sort

over terms of sort . We will explain the syntax and properties of such terms in a

moment.

478

Example 2.2. Here is a nominal signature for expressions in a small fragment of ML [25]:
sort of atoms: sort of data: function symbols:

.

The function symbol constructs terms of sort representing value identiﬁers

(named by atoms of sort ); constructs application expressions from pairs of

expressions; , and construct terms representing respectively function ab-

stractions (

), local value declarations (

) and

local recursive function declarations (

). The arities of

the function symbols specify which are binders and in which way their arguments

are bound. For example, in the expression (

) there is

a binding occurrence of the value identiﬁer whose scope is both of and ;

and a binding occurrence of the value identiﬁer whose scope is just . These

binding scopes are reﬂected by the argument sort of the function symbol . This

kind of speciﬁcation of binding scopes is of course a feature of higher-order ab-

stract syntax [26], using function types

in simply typed -calculus where we

use abstraction sorts . We shall see that the latter have much more elementary

(indeed, ﬁrst-order) properties compared with the former.

Deﬁnition 2.3. Given a nominal signature, we assume that there are countably inﬁnite and pairwise disjoint sets of atoms (typical symbol ) for each sort of atoms
, and variables (typical symbol ) for each sort of atoms and each sort of data . The terms over a nominal signature and their sorts are inductively deﬁned as follows, where we write to indicate that a term has sort .

Unit value

.

Pairs

, if and .

Data

, if is a function symbol of arity

and .

Atoms , if is an atom of sort .

Atom-abstraction

, if is an atom of sort and .

Suspension

, if

is a ﬁnite list whose elements

are pairs of atoms, with and of the same sort, and is a variable of

sort , where is either a sort of data or a sort of atoms (i.e.

).

Recall that every ﬁnite permutation can be expressed as a composition of swappings ; the list of pairs of atoms occurring in a suspension term speciﬁes a
ﬁnite permutation of atoms waiting to be applied once we know more about the variable (by substituting for it, for example). We represent ﬁnite permutations in this way because it is really the operation of swapping which plays a fundamen-

479

tal roˆle in the theory. Since, semantically speaking, swapping commutes with all term-forming operations, we can normalise terms involving an explicit swapping operation by pushing the swap in as far as it will go, until it reaches a variable (applying the swapping to atoms that it meets on the way); the terms in Deﬁnition 2.3 are all normalised in this way, with explicit permutations “piled up” in front of variables giving what we have called suspensions. In case the permutation in a suspension is the empty list, we just write for .

Deﬁnition 2.4. The permutation action, , of a ﬁnite permutation of atoms

on a term is deﬁned as in Figure 1, making use of the following notations. The

composition of a permutation followed by a swap

is given by list-cons,

written

. (Note that we apply permutations to terms on the left, and hence

the order of the composition is from right to left.) The composition of followed by

another permutation is given by list-concatenation, written as . The identity

permutation is given by the empty list ; and the inverse of a permutation is given

by list reversal, written as .

Permutation actions have excellent logical properties (stemming from the fact that

they are bijections). We exploit these properties in our deﬁnition of -equivalence

for terms over a nominal signature, which is respected by substitution of terms for

variables even though the latter may involve capture of atoms by binders. To do

so we will need to make use of an auxiliary relation of freshness between atoms

and terms, whose intended meaning is that the atom does not occur free in any

substitution instance of the term. As discussed in the Introduction, our judgements

about term equivalence ( ) need to contain hypotheses about the freshness of

atoms with respect to variables (

); and the same goes for our judgements

about freshness itself ( ). Figure 2 gives a syntax-directed inductive deﬁnition

of equivalence and freshness using judgements of the form

and

where and are terms of the same sort over a given nominal signature, is an atom, and the freshness environment is a ﬁnite set of freshness constraints
, each speciﬁed by an atom and a variable. Rule ( -suspension) in Figure 2 makes use of the following deﬁnition.

Deﬁnition 2.5. The disagreement set of two permutations and is the set of

atoms

def

.

Note that every disagreement set occurring in either of the lists and then from Figure 1 we get sets, consider the judgement

is a subset of the ﬁnite set of atoms , because if does not occur in those lists,
. To illustrate the use of disagreement

480

def
if def if
otherwise

def def def def def

Fig. 1. Permutation action on terms, .

( -unit) ( -function symbol)

( -pair) ( -abstraction-1)

( -atom)

( -abstraction-2)

for all

( -suspension)

( -unit)

( -pair) ( -function symbol)

( -abstraction-1)

( -abstraction-2)

( -atom)

( -suspension)

Fig. 2. Inductive deﬁnition of and .

This holds by applying rule ( -suspension) in Figure 2, since the disagreement set

of the permutations

and is

.

Remark 2.6 (Freshness environments). Note that the freshness environment on the left-hand side of judgements in the rules in Figure 2 does not change from hypotheses to conclusion. So in the same way that we assume variables have attached sorting information, we could dispense with the use of freshness environments entirely by attaching the freshness information directly to variables. However, we ﬁnd the use of freshness environments more elegant (for one thing, without them two variables with the same name but different freshness information would have to be regarded as different). They also make life simpler when we come on to nominal uniﬁcation problems and their solutions in the next section.

481

Below we sketch a proof that is an equivalence relation. At ﬁrst sight this property might be surprising considering the “unsymmetric” deﬁnition of the rule ( abstraction-2). However it holds because of the good logical properties of the relation with respect to permutation actions. Although reasoning about is rather pleasant once equivalence is proved, establishing it ﬁrst is rather tricky—mainly because of the large number of cases, but also because several facts needed in the proof are interdependent. We ﬁrst show that permutations can be moved from one side of the freshness relation to the other by forming the inverse permutation, and that the freshness relation is preserved under permutation actions.

Lemma 2.7.

(1) If (2) If (3) If

then then then

. . .

PROOF. (1) and (2) are by routine inductions on the structure of , using the fact

that iff

; (3) is a consequence of (2) and the fact that permuta-

tions are bijections on atoms.

According to the deﬁnition of the permutation action given in Figure 1, if we push

a permutation inside a term, we need to apply the permutation to all atoms we

meet on the way. Suppose we apply two distinct permutations, say and , to

a term , then in general and are not -equivalent—the disagreement set

characterises all atoms which potentially lead to differences. However,

if we assume that all atoms in

are fresh for , then we can infer that the

permutation actions produce equivalent terms. This is made precise in the following

lemma.

Lemma 2.8. Given any and , if .

holds for all

, then

PROOF. By induction on the structure of , for all and the fact about disagreement sets that for all atoms , if then .

simultaneously, using

An example of this lemma is that ment, because the disagreement set

is a valid judgeis empty.

In addition some further simple properties of permutations and disagreement sets need to be established ﬁrst. A machine-checked proof of all results using the theorem prover Isabelle can be found at http://www.cl.cam.ac.uk/users/cu200/Unification.

482

The next lemma shows that respects the freshness relation.

Lemma 2.9. If

and , then

.

PROOF. Routine induction on the deﬁnition of using Lemma 2.7.

For showing transitivity of the relation , it will be necessary to deﬁne a measure that counts all term constructors occurring in a term.
Deﬁnition 2.10. The size of a term is the natural number deﬁned by:
def def def

Notice that the size of a term is preserved under permutation actions (i.e.

and respected by the relation in the sense that if

then

Theorem 2.11 (Equivalence).

is an equivalence relation.

.

)

PROOF. Reﬂexivity is by a simple induction on the structure of terms. Transitivity is by an induction on the size of terms: a slight complication is that many subcases need to be analysed (for example ﬁve subcases when dealing with abstractions) and also that transitivity needs to be shown by mutual induction with the fact that is preserved under permutation actions, that is

given any if

then

(9)

We illustrate the proof of transitivity for the case when

and

hold, with , and all distinct atoms, and we have to prove

. By the ( -abstraction-2) rule we can infer from the assumptions

the following facts:

(i) (iii)
Below we give the steps that prove

(ii) (iv)
.

483

(a) by (iii) and IH (9) (b) by (i), (a) and IH (transitivity) (c) by deﬁnition (d) by (ii), (iii) and Lemma 2.9 (e) by , (d) and Lemma 2.7(i) (f) by (c), (iv), (e) and Lemma 2.8 (g) by (b), (f) and IH (transitivity) (h) by (e), (g) and ( -abstraction-2)
The other cases are by similar arguments. Symmetry is then by a routine induction on the deﬁnition of using Lemma 2.8 and transitivity.

Now it is relatively straightforward to obtain the following properties of our equivalence relation with respect to permutation actions.

Corollary 2.12.

(1) (2) (3) Given any
.

if and only if if and only if and , if

. . then for all in

we have

PROOF. (i) follows immediately from Lemma 2.8 and transitivity; (ii) follows from (9) and (i); and (iii) is by a routine induction on the structure of using Lemma 2.9.

The main reason for using suspensions in the syntax of terms is to enable a definition of substitution of terms for variables that allows capture of free atoms by atom-abstractions while still respecting -equivalence. The following lemma establishes this. First we give some terminology and notation for term-substitution.

Deﬁnition 2.13. A substitution is a sort-respecting function from variables to

terms with the property that

for all but ﬁnitely many variables . We

write

for the ﬁnite set of variables satisfying

. If con-

sists of distinct variables and for , we sometimes

write as

(10)

We write for the result of applying a substitution to a term ; this is the

term obtained from by replacing each suspension

in (as ranges over

484

) by the term

got by letting act on the term

using the

deﬁnition in Figure 1. For example, if

and , then

. Given substitutions and , and freshness environments

and , we write

(a) and (b)

(11)

to mean, for (a), that

holds for each

that holds for all

and, for (b), .

Lemma 2.14 (Substitution). Substitution commutes with the permutation action: . Substitution also preserves and in the following sense:

(1) if (2) if

and , then and , then

; .

PROOF. The ﬁrst sentence follows by a routine induction on the structure of . The second follows by induction on the deﬁnition of and using Lemma 2.8.

We claim that the relation deﬁned in Figure 2 gives the correct notion of equivalence for terms over a nominal signature. This is reasonable, given Theorem 2.11 and the fact that, by deﬁnition, it satisﬁes rules ( -abstraction-1) and ( abstraction-2). Further evidence is provided by the following proposition, which shows that for ground terms agrees with the following more traditional deﬁnition of -equivalence.

Deﬁnition 2.15 (Na¨ıve -equivalence). Deﬁne the binary relation

between

terms over a nominal signature to be the least sort-respecting congruence relation

satisfying

whenever is an atom (of the same sort as ) not oc-

curring at all in the term . Here

indicates the result of replacing all free

occurrences of with in .

Proposition 2.16 (Adequacy). If and are ground terms (i.e. terms with no vari-

ables and hence no suspensions) over a nominal signature, then the relation

of Deﬁnition 2.15 holds if and only if

is provable from the rules in Fig-

ure 2. Furthermore,

is provable if and only if is not in the set

of

485

free atoms of , deﬁned by:

def def def def def

PROOF. The proof is similar to the proof of [10, Proposition 2.2].

For non-ground terms, the relations and differ! For example

always holds, whereas

is not provable unless . This disagree-

ment is to be expected, since we noted in the Introduction that is not preserved

by substitution, whereas from Lemma 2.14 we know that is.

3 Uniﬁcation

Given terms and of the same sort over a nominal signature, can we decide

whether or not there is a substitution of terms for the variables in and that makes

them equal in the sense of the relation introduced in the previous section? Since

instances of are established modulo freshness constraints, it makes more sense

to ask whether or not there is both a substitution and a freshness environment

for which

holds. As for ordinary ﬁrst-order uniﬁcation, solving

such an equational problem may throw up several equational subproblems; but an

added complication here is that because of rule ( -abstraction-2) in Figure 2, equa-

tional problems may generate freshness problems, i.e. ones involving the relation

. We are thus led to the following deﬁnition of uniﬁcation problems for nominal

equational logic.

Deﬁnition 3.1. A uniﬁcation problem over a nominal signature is a ﬁnite set of

atomic problems, each of which is either an equational problem

where

and are terms of the same sort over the signature, or a freshness problem

where is an atom and a term over the signature. A solution for consists of a

pair where is a freshness environment and is a substitution satisfying

for each for each

and .

We write

for the set of all solutions of a problem .

general solution for if given any other solution

is a most , then there is a

486

substitution satisfying

and

. (Here we are using the

notation of (11); and

denotes the substitution composition of followed by

, given by

def .) A solution

is idempotent

provided

.

We describe an algorithm which, given any nominal uniﬁcation problem, decides whether or not it has a solution and if it does, returns a most general (and idempotent) solution. The algorithm uses labelled transformations, directly generalising the presentation of ﬁrst-order uniﬁcation in [19, Sect. 2.6] which in turn is based upon the approach in [18]. (See also [20, Sect. 4.6] for a detailed exposition, but not using labels.) We use two types of labelled transformation between uniﬁcation problems, namely

and

where the substitution is either the identity , or a single replacement

;

and where the freshness environment is either empty , or a singleton

.

The legal transformations are given in Figure 3. This ﬁgure uses the notation

to indicate the union of problems and that are disjoint (

); and the

notation to indicate the problem resulting from applying the substitution to

all the terms occurring in the problem .

Algorithm. Given a uniﬁcation problem , the algorithm proceeds in two phases. In the ﬁrst phase it applies as many transformations as possible (non-deterministically). If this results in a problem containing no equational subproblems, then it proceeds to the second phase; otherwise it halts signalling failure. In the second
phase it applies as many transformations as possible (non-deterministically). If this does not result in the empty problem, then it halts signalling failure; otherwise overall it has constructed a transformation sequence of the form

(12)

(where does not contain any equational subproblems) and the algorithm returns

the solution

.

To show the correctness of this algorithm, we ﬁrst establish that all sequences of uniﬁcation transitions must terminate.

Lemma 3.2. There is no inﬁnite series of uniﬁcation transitions.

PROOF. Since every reduction sequence consists of two (possibly empty) subsequences, namely one containing only -steps and the other only -steps, we can show termination for both subsequences separately. For every uniﬁcation problem we deﬁne a measure of the size of to be the lexicographically ordered pair
See Remark 3.9 for discussion of this use of two phases.
487

( -unit) ( -pair) ( -function symbol) ( -abstraction-1) ( -abstraction-2)
( -atom) ( -suspension)

provided

( -variable)
( -unit) ( -pair) ( -function symbol) ( -abstraction-1) ( -abstraction-2) ( -atom) ( -suspension)

with provided does not occur in
provided provided with

Fig. 3. Labelled transformations.

of natural numbers

, where is the number of different variables used in

, and is the size (see Deﬁnition 2.10) of all equational problems in , that is

def

In every -step this measure decreases: the ( ?-variable) transition eliminates (completely) one variable from the uniﬁcation problem, and therefore decreases; the ( ?-suspension) transition may eliminate a variable and also decreases the size
; all other transitions leave the number of variables unchanged, but decrease . For the -steps the size
decreases in every step. Taking both facts together means that every reduction sequence must terminate.
The following lemmas help us to show that the algorithm gives correct results upon
488

termination. Lemma 3.3. If

then

.

PROOF. We have to prove that both substitutions agree (modulo ) on all vari-

ables in

. The only interesting case is for the substitutions applied

to , when we need to show that

. By Lemma 2.14 we

can commute the permutation to the outside and move it to the other side of

by Lemma 2.12—this gives

. The case then follows from

the assumptions by symmetry and commuting the permutation inside the substitu-

tion.

Lemma 3.4. Given a uniﬁcation problem , .

holds if and only if

PROOF. Simple calculation using the fact that

.

The following two lemmas show that the uniﬁcation transformations can be used to determine whether or not solutions exists and to describe all of them if they do exist.

Lemma 3.5.

(i) If

and then

and

(ii) If

and then

and

PROOF. We just give the details for two uniﬁcation transitions: the case for ( suspension) follows from Lemma 2.12(iii); and the ( -variable) case is a consequence of Lemmas 3.3 and 3.4.

Lemma 3.6.
(i) If (ii) If

and then and

then

PROOF. Once again, we just give the details for two uniﬁcation transitions: the

( -suspension) case follows from Lemma 2.8; and the ( -variable) case follows

from Lemma 3.4 and the fact that

, which holds by the side-

condition on the ( -variable) transition about the non-occurrence of in .

489

The following theorem establishes the correctness of the nominal uniﬁcation algorithm and is the central result of the paper.
Theorem 3.7 (Correctness). Given a uniﬁcation problem
(i) if the algorithm fails on , then has no solution; and (ii) if the algorithm succeeds on , then the result it produces is an idempotent
most general solution.

PROOF. When failure happens it is because of certain subproblems that mani-

festly have no solution (namely in the ﬁrst phase,

with , and

or

with occurring in ; in the second phase,

).

Therefore part (i) is a consequence of Lemma 3.5. For part (ii) one gets that a se-

quence like (12) exists, and thus

is in

by Lemma 3.6 and the fact that

. Furthermore from Lemma 3.5, we get

that any other solution

satisﬁes

and

,

so that

is indeed a most general solution. Since one of those solutions is the

most general solution

, we also know that

and hence that

is idempotent.

We now apply the nominal uniﬁcation algorithm to solve the quiz questions from the Introduction.

Example 3.8. Using the ﬁrst three function symbols of the nominal signature of

Example 2.2 to represent -terms, the Quiz at the end of the Introduction translates

into the following four uniﬁcation problems over that signature, where and are

distinct atoms of sort and

are distinct variables of sort :

def , def , def , def .

Applying the nominal uniﬁcation algorithm described above, we ﬁnd that

has no solution; has a most general solution given by
; has a most general solution given by has a most general solution given by
.

and and

and

;

490

( -abstraction-2) ( -abstraction-1)
( -pair) with ( -variable)
( -function symbol)

( -abstraction-1) ( -abstraction-2)
( -function symbol) ( -atom) with ( -variable) ( -function symbol)
( -function symbol) ( -atom) with ( -suspension)
Fig. 4. Example derivations
Derivations for and are sketched in Figure 4. Using the Adequacy property of Proposition 2.16, one can interpret these solutions as the following statements about the -terms mentioned in the quiz.

Quiz answers

(1) There is no -term making the ﬁrst pair of terms -equivalent.

(2) The only solution for the second problem is to take

and .

(3) For the third problem we can take to be any -term, so long as we take

to be the result of swapping all occurrences of and throughout .

(4) For the last problem, we can take to be any -term that does not contain

free occurrences of , so long as we take to be the result of swapping

all occurrences of and throughout , or equivalently (since is not

free in ), taking to be the result of replacing all free occurrences of

in with .

Remark 3.9 (Separation of the algorithm into two phases). We organised the algorithm into two phases: equation-solving followed by freshness-solving. Note that the second phase is crucial for the soundness of the algorithm. Consider for example the uniﬁcation problem consisting of two terms which are not -equivalent:
(13)
After applying the transformation ( -abstraction-2) one needs to solve the prob-

491

lem , whose ﬁrst component is solved by ( -atom). Failure is

only signalled by the algorithm in the second phase when attempting to solve the

unsolvable freshness problem

. The second phase, i. e. solving all fresh-

ness problems, ensures that the uniﬁers calculated by the algorithm are sound with

respect to our notion of -equivalence.

We used this separation of the algorithm into two phases in order to make the correctness proof easier. More efﬁcient algorithms would seek to minimise the amount of redundant calculations before failures are signalled, by solving freshness problems more eagerly. However, care needs then to be taken to not remove freshness constraints from problems too early. For example, consider the following uniﬁcation problem, which has no solution.

(14)

If one applies ﬁrst ( -suspension) followed by ( -variable), then one gets a

wrong result, namely

. The problem is that the substitution

has not been properly propagated to the freshness constraint

. If

freshness problems are solved more eagerly, then proper propagation of substitu-

tions into freshness constraints needs to be taken into account.

Remark 3.10 (Atoms are not variables). Nominal uniﬁcation uniﬁes variables, but

it does not unify atoms. Indeed the operation of identifying two atoms by renaming

one of them to be the other does not necessarily preserve the validity of the judge-

ments in Figure 2. For example,

holds if

; but renaming to

be in this judgement we get

, which does not hold so long as .

Referring to Deﬁnition 2.3, you will see that we do allow variables ranging over

sorts of atoms; and such variables can be uniﬁed like any other variables. However,

if is such a variable, then it cannot appear in abstraction position, i.e. as .

This is because we speciﬁcally restricted abstraction to range over atoms, rather

than over arbitrary terms of atom sort. Such a restriction seems necessary to obtain

single, most general, solutions to nominal uniﬁcation problems. For without such a

restriction, because of rule ( -abstraction-2) in Figure 2 we would also have to al-

low variables to appear on the left-hand side of freshness relations and in suspended

permutations. So then we would get uniﬁcation problems like

,

where , and are variables of atom sort; this has two incomparable solutions,

namely

and

.

492

4 Related work

Higher-order pattern uniﬁcation

Most previous work on uniﬁcation for languages with binders is based on forms

of higher-order uniﬁcation, i.e. solving equations between -terms modulo -

equivalence ( ) by capture-avoiding substitution of terms for function vari-

ables. Notable among that work is Miller’s higher-order pattern uniﬁcation used

in his logic programming language [3]. This kind of uniﬁcation retains the good

properties of ﬁrst-order uniﬁcation: a linear-time decision procedure and existence

of most general uniﬁers. This good behaviour of higher-order pattern uniﬁcation

is the result of equations being solved only modulo

(where -equivalence

is the restricted form of -equivalence that identiﬁes

and with

being a variable) and of -terms being restricted such that function variables may

only be applied to distinct bound variables. An empirical study by Michaylov and

Pfenning [27] suggests that most uniﬁcations arising dynamically in higher-order

logic programming satisfy Miller’s restrictions, but that it rules out some useful

programming idioms.

The main difference between higher-order pattern uniﬁcation and nominal uniﬁca-

tion is that the former solves a set of equations by calculating a capture-avoiding

substitution, while the latter calculates a possibly-capturing substitution and some

freshness constraints. Moreover, uniﬁers in higher-order pattern uniﬁcation solve

equations with respect to

; whereas in nominal uniﬁcation, uniﬁers solve

equations with respect to the equivalence deﬁned in Figure 2, which agrees

with -equivalence on ground terms (see Proposition 2.16), but differs from it on

open terms, since unlike -equivalence, it is respected by possibly-capturing sub-

stitutions (see Lemma 2.14). For us, the main disadvantage of higher-order pattern

uniﬁcation is the one common to most approaches based on higher-order abstract

syntax that was discussed in the Introduction: one cannot directly express the com-

mon idiom of possibly-capturing substitution of terms for metavariables. Instead

one has to encode metavariables as function variables applied to distinct lists of

(bound) variables,

, and use capture-avoiding substitution. At ﬁrst sight,

there seems to be a simple encoding for doing that. Consider for example the purely

equational nominal uniﬁcation problem

(15)

which is solved by

. The literal encoding as the higher-order pattern

uniﬁcation problem

does not work of course, because there is no

capture-avoiding substitution that solves this problem. However, can be made

dependent on yielding the uniﬁcation problem

(16)

493

which is solved by the capture-avoiding substitution of for . If one further

applies to the atom used by the encoding, then one can read back the orig-

inal solution

by applying some -reductions. There are however several

problems with this encoding. First, the encoding in general results in a quadratic

blow-up in the size of terms. For example the nominal uniﬁcation problem

(17)

solved by the uniﬁer

needs to be encoded so that and

depend on both and . This gives the higher-order pattern problem

(18)

In the general case, the encoding needs to make metavariables dependent on all atoms occurring in a nominal uniﬁcation problem, regardless of whether they actually occur in an individual equational problem. For example, if occurs elsewhere within the scope of abstractions of , , and , then needs to be encoded as
even though an individual equational problem might contain only and . Secondly, and more importantly, we cannot see how to encode our freshness constraints using this kind of higher-order patterns. (Note that in nominal uniﬁcation, freshness constraints do not necessarily come from analysing abstractions, rather they can be chosen arbitrarily.)
A more promising target for a reduction of nominal uniﬁcation to some form of higher-order pattern uniﬁcation is , a -calculus with de-Bruijn indices and explicit substitutions. Dowek et al [28] present a version of higher-order pattern uniﬁcation for in which uniﬁcation problems are solved, as in nominal uniﬁcation, by textual replacements of terms for variables; however a “pre-cooking” operation ensures that the textual replacements can be faithfully related to capture-avoiding substitutions. It seems possible that the freshness (as well as the equational) problems of nominal uniﬁcation can be encoded into higher-order pattern uniﬁcation problems over , using a non-trivial translation involving the use of the shift operator and the introduction of fresh uniﬁcation variables. The details of this encoding still remain to be investigated. Furthermore, it is not clear to us how to translate solutions obtained via the encoding back into solutions of the original nominal uniﬁcation problem. But even if it turns out that it is possible to reduce nominal uniﬁcation to the algorithm of Dowek et al, the calculations involved in translating our terms into patterns and then using higher-order pattern uniﬁcation seem far more intricate than our simple algorithm that solves nominal uniﬁcation problems directly. The conclusion we draw is that an encoding of nominal uniﬁcation problems into higher-order pattern uniﬁcation problems (using de Bruijn indices and explicit substitutions) might be possible, but such an encoding is no substitute in practice for having the simple, direct algorithm we presented here.

494

Hamana’s -uniﬁcation of -terms with “holes”
Hamana [5,29] manages to add possibly-capturing substitution to a language like Miller’s . This is achieved by adding syntax for explicit renaming operations and by recording implicit dependencies of variables upon bindable names in a typing context. The mathematical foundation for Hamana’s system is the model of binding syntax of Fiore et al [24]. The mathematical foundation for our work appeared at the same time (see [10]) and is in a sense complementary. For in Hamana’s system the typing context restricts which terms may be substituted for a variable by giving a ﬁnite set of names that must contain the free names of such a term; whereas we give a ﬁnite set of names which the term’s free variables must avoid. Since conversion is phrased in terms of avoidance, i.e. freshness of names, our approach seems more natural if one wants to compute -equivalences concretely. On top of that, our use of name permutations, rather than arbitrary renaming functions, leads to technical simpliﬁcations. In any case, the bottom line is that Hamana’s system seems more complicated than the one presented here and does not possess most general uniﬁers.
Qu-Prolog
The work [8,9] on uniﬁcation in Qu-Prolog is most closely related to that reported here. Qu-Prolog is a mature logic programming language addressing many problems we set out in the Introduction. To begin with, Qu-Prolog’s uniﬁcation algorithm uniﬁes terms modulo -equivalence and may produce solutions that, as in nominal uniﬁcation, depend on freshness constraints (in Qu-Prolog such constraints are represented by a predicate called not free in). Furthermore, metavariables are substituted in a possibly-capturing manner. However, there are also a number of differences between nominal uniﬁcation and uniﬁcation in Qu-Prolog. The most obvious difference is that the term language in Qu-Prolog is richer than our term language over nominal signatures; for example Qu-Prolog allows variables in binding position and permits explicit substitutions of terms for variables. This richness of the term language leads to a number of difﬁculties. First, the uniﬁcation problems in Qu-Prolog are only semi-decidable (whereas the nominal uniﬁcation problems are decidable) and as a result the algorithm employed in Qu-Prolog can leave as unsolved some uniﬁcation problems that are “too difﬁcult”. This means the uniﬁcation transformations in Qu-Prolog, while shown not to delete any solutions nor to introduce any new ones, do not always lead to problems from which an explicit solution can be obtained. Secondly, as we illustrated in Remark 3.10, the possibility of forming terms with uniﬁcation variables in binding position means that most general solutions may not exist.
Another difference arises from the fact that in Qu-Prolog binders are renamed via
495

capture-avoiding substitutions. This means that fresh names need to be introduced during uniﬁcation in order to respect -equivalence. This is not necessary in nominal uniﬁcation, because the permutation operation already respects -equivalence. In fact the introduction of fresh atoms during uniﬁcation leads to a more complicated notion of most general solution. Consider the following variant of the ( abstraction-2) transformation:

-abstraction-2

which is applicable provided

and is a fresh atom, not occurring elsewhere

in the problem. This rule is essentially the reﬁnement step that uniﬁes two ab-

stracted terms in Qu-Prolog (see [8, Page 105]). If we were to use ( -abstraction-

2 ) instead of ( -abstraction-2) in our nominal uniﬁcation algorithm, then when

applied to the problem

(19)

it would produce the solution

. While this

solution solves the problem, it is not a most general solution according to Deﬁni-

tion 3.1—we lost the information that is a completely fresh atom. On the other

hand, applying transformation ( -abstraction-2) to (19) leads to

—a most general solution.

Overall, the theory of Qu-Prolog’s uniﬁcation is more complex than that of nominal uniﬁcation: in nominal uniﬁcation we do not need to resort to a semantic notion of -equivalence in order to show the correctness of the nominal uniﬁcation algorithm; and the use of permutations makes our -relation much simpler compared with Qu-Prolog’s use of the traditional notion of -equivalence extended to terms with metavariables.

5 Conclusion and Future Work
In this paper we have proposed a new solution to the problem of computing possiblycapturing substitutions that unify terms involving binders up to -conversion. To do so we considered a many-sorted ﬁrst-order term language with distinguished collections of constants called atoms and with atom-abstraction operations for binding atoms in terms. This provides a simple, but ﬂexible, framework for specifying binding operations and their scopes, in which the bound entities are explicitly named. By using variables preﬁxed with suspended permutations, one can have substitution of terms for variables both allow capture of atoms by binders and respect -equivalence (renaming of bound atoms). The deﬁnition of -equivalence for the term language makes use of an auxiliary freshness relation between atoms and terms which generalises the “not a free atom of” relation from ground terms to terms with variables; furthermore, because variables stand for unknown terms,
496

type Gamma (var X) A :- mem (pair X A) Gamma. type Gamma (app M N) B :- type Gamma M (arrow A B),
type Gamma N A. type Gamma (lam x.M) (arrow A B) / x#Gamma :-
type (pair x A)::Gamma M B.
mem A A::Tail. mem A B::Tail :- mem A Tail.
Fig. 5. An example Prolog program
hence with unknown free atoms, it is necessary to make hypotheses about the freshness of atoms for variables in judgements about term equivalence and freshness. This reliance on “freshness”, coupled with name-swapping rather than renaming, lead to a new notion of uniﬁcation problem in which instances of both equivalence and freshness have to be solved by giving term-substitutions and (possibly) freshness conditions on variables in the solution. We showed that this uniﬁcation problem is decidable and unitary.
Cheney, Gabbay and Urban [30,31] are investigating the extent to which nominal uniﬁcation can be used in resolution-based proof search for a form of ﬁrst-order logic programming for languages with binders (with a view to providing better machine-assistance for structural operational semantics). Such a logic programming language should permit a concrete, “nominal” approach to bound entities in programs while ensuring that computation (which in this case is the computation of answers to queries) respects -equivalence between terms. This is illustrated with the Prolog-like program in Figure 5, which implements a simple typing algorithm for -terms. The third clause is the interesting one. First, note the term (lam x.M), which uniﬁes with any -abstraction. The binder x, roughly speaking, has in the “nominal” approach a value which can be used in the body of the clause, for example for adding (pair x A) to the context Gamma. Secondly, the freshness constraint x # Gamma ensures that Gamma cannot be replaced by a term that contains x freely. Since this clause is intended to implement the usual rule for typing
-abstractions

its operational behaviour is given by: choose fresh names for Gamma, x, M, A and

B (this is standard in Prolog-like languages), unify the head of the clause with the

goal formula, apply the resulting uniﬁer to the body of the clause and make sure that

Gamma is not replaced by a term that contains freely the fresh name we have chosen

for x. Similar facilities for functional programming already exist in the FreshML

language, built upon the same foundations: see [13] and

. We

are also interested in the special case of “nominal matching” and its application to

term-rewriting modulo -equivalence.

497

A note on complexity
If these applications show that nominal uniﬁcation is practically useful, then it becomes important to study its complexity. The presentations of the term language in Section 2 and of the algorithm in Section 3 were chosen for clarity and to make the proof of correctness easier, rather than for efﬁciency. One source of increased efﬁciency is to delay the application of permutations: instead of pushing permutation inside terms until they reach suspension as we do here, one should just push them under the ﬁrst constructor (pairing, function symbol application, or atomabstraction) in order to proceed with the next step of decomposition. However, the main inefﬁciency of the algorithm presented in Section 3 comes from the lack of sharing in terms and substitutions. Thus the uniﬁcation problem taken from [32]
which illustrates that the na¨ıve algorithm for classical ﬁrst-order uniﬁcation has exponential time complexity, also applies to the algorithm for nominal uniﬁcation given here. If one adapts a representation for terms using techniques developed in [32] or [33], which are based on directed acyclic graphs, then one easily arrives at an algorithm with quadratic time complexity. The reason for the quadratic, rather than linear, time-complexity is that permutations need to be applied to some atoms when deciding whether the rules ( -abstraction-1) or ( -abstraction-2) are applicable, and these permutations (represented as lists of swappings) might grow linearly with the number of nodes. Using a representation of permutations that allows for a more efﬁcient calculation of their action on atoms does not improve the quadratic time complexity, because it makes the operation of composing two permutations become linear, while this can be done in constant time when using the list-of-swappings representation. For higher-order patterns, Qian managed to developed a uniﬁcation algorithm with linear time-complexity [34]. It seems that adapting Qian’s algorithm to nominal uniﬁcation via an encoding of nominal terms into higher-order patterns as discussed in Section 4 will not solve this problem. For the encoding makes the resulting higher-order patterns quadratically longer than the original nominal terms, so this method would only provide another algorithm with quadratic time complexity.
To sum up, there is a version of nominal uniﬁcation with quadratic time complexity, but is it is still an open question whether a version can be developed with linear time complexity.
See http://www.cl.cam.ac.uk/users/cu200/Unification for the Isabelle proof scripts.
498

Acknowledgements
A preliminary version of this paper appeared as [35]. We thank James Cheney, Gilles Dowek, Roy Dyckhoff, Dale Miller, Frank Pfenning, Francois Pottier and Helmut Schwichtenberg for comments on this work. This research was supported by UK EPSRC grants GR/R29697 (Urban) and GR/R07615 (Pitts and Gabbay).
References
[1] G. Dowek, T. Hardin, C. Kirchner, Higher-order uniﬁcation via explicit substitutions, in: 10th Annual Symposium on Logic in Computer Science, IEEE Computer Society Press, Washington, 1995, pp. 366–374.
[2] C. A. Gunter, Semantics of Programming Languages: Structures and Techniques, Foundations of Computing, MIT Press, 1992.
[3] D. Miller, A logic programming language with lambda-abstraction, function variables, and simple uniﬁcation, Journal of Logic and Computation 1 (1991) 497–536.
[4] G. Dowek, Higher-order uniﬁcation and matching, in: A. Robinson, A. Voronkov (Eds.), Handbook of Automated Reasoning, Elsevier, 2001, Ch. 16, pp. 1009–1062.
[5] M. Hamana, A logic programming language based on binding algebras, in: N. Kobayashi, B. C. Pierce (Eds.), Theoretical Aspects of Computer Software, 4th International Symposium, TACS 2001, Sendai, Japan, October 29-31, 2001, Proceedings, Vol. 2215 of Lecture Notes in Computer Science, Springer-Verlag, Berlin, 2001, pp. 243–262.
[6] M. Hashimoto, A. Ohori, A typed context calculus, Theoretical Computer Science 266 (2001) 249–271.
[7] M. Sato, T. Sakurai, Y. Kameyama, A simply typed context calculus with ﬁrst-class environments, Journal of Functional and Logic Programming 2002 (4).
[8] P. Nickolas, P. J. Robinson, The Qu-Prolog uniﬁcation algorithm: Formalisation and correctness, Theoretical computer Science 169 (1996) 81–112.
[9] R. Paterson, Uniﬁcation of schemes of quantiﬁed terms, in: Proc. of UNIF 1990, 1990, unpublished proceedings.
[10] M. J. Gabbay, A. M. Pitts, A new approach to abstract syntax with variable binding, Formal Aspects of Computing 13 (2002) 341–363.
[11] L. Caires, L. Cardelli, A spatial logic for concurrency (part II), in: L. Brim, P. Janc˘ar, M. K˘ret´ınsky´, A. Kuc˘era (Eds.), CONCUR 2002 – Concurrency Theory, 13th International Conference, Brno, Czech Republic, August 20-23, 2002. Proceedings, Vol. 2421 of Lecture Notes in Computer Science, Springer-Verlag, Berlin, 2002, pp. 209–225.
499

[12] L. Cardelli, P. Gardner, G. Ghelli, Manipulating trees with hidden labels, in: A. D. Gordon (Ed.), Foundations of Software Science and Computation Structures, 6th International Conference, FOSSACS 2003, Warsaw, Poland. Proceedings, Vol. 2620 of Lecture Notes in Computer Science, Springer-Verlag, Berlin, 2003, pp. 216–232.
[13] M. R. Shinwell, A. M. Pitts, M. J. Gabbay, FreshML: Programming with binders made simple, in: Eighth ACM SIGPLAN International Conference on Functional Programming (ICFP 2003), Uppsala, Sweden, ACM Press, 2003, pp. 263–274.
[14] A. Salibra, On the algebraic models of lambda calculus, Theoretical Computer Science 249 (2000) 197–240.
[15] F. Honsell, M. Miculan, I. Scagnetto, An axiomatic approach to metareasoning on nominal algebras in HOAS, in: F. Orejas, P. G. Spirakis, J. Leeuwen (Eds.), 28th International Colloquium on Automata, Languages and Programming, ICALP 2001, Crete, Greece, July 2001. Proceedings, Vol. 2076 of Lecture Notes in Computer Science, Springer-Verlag, Heidelberg, 2001, pp. 963–978.
[16] A. M. Pitts, Nominal logic, a ﬁrst order theory of names and binding, Information and Computation 186 (2003) 165–193.
[17] M. Sato, T. Sakurai, Y. Kameyama, A. Igarashi, Calculi of meta-variables, in: M. Baaz (Ed.), Computer Science Logic and 8th Kurt Go¨del Colloquium (CSL’03 & KGC), Vienna, Austria. Proccedings, Vol. 2803 of Lecture Notes in Computer Science, Springer-Verlag, Berlin, 2003, pp. 484–497.
[18] A. Martelli, U. Montanari, An efﬁcient uniﬁcation algorithm, ACM Trans. Programming Languages and Systems 4 (2) (1982) 258–282.
[19] J. W. Klop, Term rewriting systems, in: S. Abramsky, D. M. Gabbay, T. S. E. Maibaum (Eds.), Handbook of Logic in Computer Science, Volume 2, Oxford Univerity Press, 1992, pp. 1–116.
[20] F. Baader, T. Nipkow, Term Rewriting and All That, Cambridge University Press, 1998.
[21] H. P. Barendregt, The Lambda Calculus: its Syntax and Semantics, North-Holland, 1984.
[22] R. Milner, J. Parrow, D. Walker, A calculus of mobile processes (parts I and II), Information and Computation 100 (1992) 1–77.
[23] G. D. Plotkin, An illative theory of relations, in: R. Cooper, Mukai, J. Perry (Eds.), Situation Theory and its Applications, Vol. 22 of CSLI Lecture Notes, Stanford University, 1990, pp. 133–146.
[24] M. P. Fiore, G. D. Plotkin, D. Turi, Abstract syntax and variable binding, in: 14th Annual Symposium on Logic in Computer Science, IEEE Computer Society Press, Washington, 1999, pp. 193–202.
[25] R. Milner, M. Tofte, R. Harper, D. MacQueen, The Deﬁnition of Standard ML (Revised), MIT Press, 1997.
500

[26] F. Pfenning, C. Elliott, Higher-order abstract syntax, in: Proc. ACM-SIGPLAN Conference on Programming Language Design and Implementation, ACM Press, 1988, pp. 199–208.
[27] S. Michaylov, F. Pfenning, An empirical study of the runtime behaviour of higher-order logic programs, in: D. Miller (Ed.), Proc. Workshop on the Prolog Programming Language, University of Pennsylvania, 1992, pp. 257–271, CIS Technical Report MS-CIS-92-86.
[28] G. Dowek, T. Hardin, C. Kirchner, F. Pfenning, Higher-order uniﬁcation via explicit substitutions: the case of higher-order patterns, in: Proc. of JICSLP, 1996, pp. 259– 273.
[29] M. Hamana, Simple -uniﬁcation for terms with context holes, in: C. Ringeissen, C. Tinelli, R. Treinen, R. M. Verma (Eds.), Proc. of UNIF 2002, 2002, unpublished proceedings.
[30] J. Cheney, C. Urban, Prolog, a fresh approach to logic programming modulo equivalence, in: J. Levy, M. Kohlhase, J. Niehren, M. Villaret (Eds.), Proc. of UNIF 2003, no. DSIC-II/12/03 in Departamento de Sistemas Informa´ticos y Computacio´n Technical Report Series, Universidad Polite´cnica de Valencia, 2003, pp. 15–19.
[31] M. Gabbay, J. Cheney, A proof theory for nominal logic, in: Nineteenth Annual IEEE Symposium on Logic in Computer Science, IEEE Computer Society Press, Washington, 2004.
[32] M. S. Paterson, M. N. Wegman, Linear uniﬁcation, Journal of Computer System Sciences 16 (2) (1978) 158–167.
[33] A. Martelli, U. Montanari, An efﬁcient uniﬁcation algorithm, ACM Transactions on Programming Languages and Systems 4 (2).
[34] Z. Qian, Uniﬁcation of higher-order patterns in linear time and space, Journal of Logic and Computation 6 (3) (1996) 315–341.
[35] C. Urban, A. M. Pitts, M. J. Gabbay, Nominal uniﬁcation, in: M. Baaz (Ed.), Computer Science Logic and 8th Kurt Go¨del Colloquium (CSL’03 & KGC), Vienna, Austria. Proceedings, Vol. 2803 of Lecture Notes in Computer Science, Springer-Verlag, Berlin, 2003, pp. 513–527.
501

