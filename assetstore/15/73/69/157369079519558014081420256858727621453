What are principal typings and what are they
good for?
Technical Memorandum MIT/LCS/TM{532
Trevor Jim

August 1995; revised November 1995
Abstract
We demonstrate the pragmatic value of the principal typing property,
a property distinct from ML's principal type property, by studying a type
system with principal typings. The type system is based on rank 2 inter-
section types and is closely related to ML. Its principal typing property
provides elegant support for separate compilation, including \smartest re-
compilation" and incremental type inference, and for accurate type error
messages. Moreover, it motivates a new rule for typing recursive deni-
tions that can type some interesting examples of polymorphic recursion.
Keywords: Polymorphic recursion, separate compilation, incremental
type inference, error messages, intersection types.
1 Introduction
We would like to make a careful distinction between the following two properties
of type systems.
Property A
Given: a term M typable in type environment A.
There exists: a type  representing all possible types for M in A.
Property B
Given: a typable term M .
There exists: a typing A `M :  representing all possible typings of M .
Property A is the familiar principal type property of ML. By analogy, we will
call Property B the principal typing property. The names are close enough to
give us pause. In fact, some authors have used \principal typings" in reference

545 Technology Square, Cambridge, MA 02139, trevor@theory.lcs.mit.edu. Supported by
NSF grants CCR{9113196 and CCR{9417382, and ONR Contract N00014{92{J{1310.
1
to Property A. But \principal typings" is also the name traditionally applied
to Property B, and we will not introduce a new name here.
Why do we care to make such a distinction? Property A|principal types|
is certainly useful. But Property B|principal typings|is more useful still.
We believe this has been overlooked because ML and its extensions completely
dominate current research on type inference; and we know of no sense in which
ML has principal typings. This was already noted by Damas in his disserta-
tion [6], but there have been subsequent claims that ML has the principal typing
property, indicating that the distinction between principal types and principal
typings is not widely appreciated. We examine ML's lack of principal typings
more closely in x6.
In this paper, we demonstrate the usefulness of the principal typing property
by studying a type system that has it. We emphasize that our results are
motivated entirely by the general principal typing property, and not by the
technical details of this particular case study. Any system with principal typings
can benet from our observations.
Nevertheless, we take some care in choosing our case study, so that its rel-
evance to current practice will be immediately evident. Therefore, we seek a
type system closely related to ML: it should be able to type all ML programs,
it should have decidable type inference, and the complexity of type inference
should be approximately the same as in ML.
The type system that satises all of these requirements is the system of
rank 2 intersection types. This system is closely related to the more well-known
rank 2 of System F|we will show that they type exactly the same terms|but
it possesses the additional property of principal typings. We use a variant of
the intersection system, called P
2
, as our case study.
The distinction between principal types and principal typings is evident in
the type inference algorithm for P
2
: it takes a single input, a term M , and
produces two outputs, an A and  such that A ` M : . The types required
of the free variables of M are specied by A; but A is a byproduct of type
inference, not a necessary input. Contrast this with Milner's algorithm for ML,
whose let-polymorphism relies on A being an input.
We illustrate the benets of principal typings in three areas: recursive de-
nitions, separate compilation, and accurate type error messages.
Recursive denitions. Two rules that have been used to type recursive
denitions in ML are given below.
(rec-simple)
A [ fx : g `M : 
A ` (xM ) : 
(where  is a simple type)
(rec-poly)
A [ fx : g `M : 
A ` (xM ) : 
(where  is an ML type scheme)
The rule (rec-simple) requires the body M of the recursive denition (xM )
to be typed under the assumption that x has a simple type. This restriction
2
is relaxed in (rec-poly), the rule of polymorphic recursion [26, 16], which
permits M to be typed under the assumption that x has a polymorphic type.
More terms are typable under (rec-poly) than (rec-simple), and practical
examples of programs requiring polymorphic recursion are a recurring topic
on the ML mailing list. But (rec-simple) is used in practice, because type
inference for (rec-poly) is undecidable [17, 9]. To understand why, consider
type inference using Milner's algorithm: in order to infer a type, , for the
denition M , we need to know the type to use for the free variable x, that is, .
In the case of (rec-poly), this \chicken and egg" problem cannot be solved.
The principal typing property suggests a new rule for typing recursive de-
nitions:
A [ fx : g `M : 
A ` (xM ) : 
(where    )
In this rule, the type  assumed for the recursive variable x need not be the same
as the type  derived for its denitionM . The type  expresses the requirements
on x needed to giveM the type ; as long as  meets these requirements (   ),
it is safe to assume it as the type of the denition.
Now the strategy for type inference becomes clear: infer the principal typing
A ` M :  for M , producing both  and  = A(x). It only remains to ensure
   , and this can be accomplished by subtype satisfaction, a procedure similar
to unication.
When we use this strategy to type recursive denitions in P
2
, we obtain an
interesting typing rule, lying between (rec-simple) and (rec-poly): it is able
to type some, but not all, examples of polymorphic recursion.
Separate compilation. In separate compilation, a large program is divided
into smaller modules, each of which is type checked and compiled in isolation.
The program as a whole is closed, but modules have free variables|a module
may refer to other modules. Types play an important role in compilation; for
instance, the data representations and calling conventions of a module may
depend on its type. Thus the compiled machine code of a module may depend
on the types of external variables that it references.
Consequently, most compilers require the user to specify the types of ex-
ternal variables referenced in each module. In P
2
, our ability to perform type
inference on program fragments with free variables means that the user need
not write these specications: the compiler can infer them itself. More signif-
icantly, principal typings will enable us to achieve smartest recompilation [27],
which guarantees that a module need not be recompiled unless its own deni-
tion changes. We also show that principal typings enable an elegant and ecient
solution to a related problem, incremental type inference [1].
Error messages. Most compilers for strongly typed languages do not do a
good job of pinpointing the location of type errors in programs; see Wand [30]
for a discussion. As a nal example of the utility of principal typings, we show
that principal typings help to produce error messages that accurately identify
the source of type errors.
3
Organization of the paper. We introduce the type system P
2
in x2,
and show its connection with rank 2 of System F. We describe how we type
recursive denitions in x3, and we show how principal typings support separate
compilation in x4. We describe how principal typings produce more accurate
type error messages in x5. In x6, we address the question of whether principal
typings exist for ML. We describe alternatives to principal typings in x7. In x8,
we describe an extension of P
2
with principal typings. We discuss related work
in x9, and we summarize our results in x10. Proofs of all theorems can be found
in a separate paper [11].
2 The type system
We now present our type system, in an expository manner. Uninteresting details
have been placed in an appendix. For the most part, the system relies on
familiar rules of subtyping and type assignment. However, the system is based
on a notion of rank, and there are some complications due to the need to stay
within rank. These complications are characteristic of all ranked systems.
Our programs are just the terms of the lambda calculus:
M ::= x j (M
1
M
2
) j (xM ):
Notice that our programs do not use ML's let-expressions. In our type system,
(let x = M in N ) can be considered an abbreviation for (xN )M .
We will be dening several classes of types, each of which is a restriction of
the types with quantication and intersection:
 ::= t j (
1
! 
2
) j (8t) j (
1
^ 
2
):
For those unfamiliar with intersection types, we present a brief example. A
term of type (^  ) is thought of as having both the type  and the type  . For
example, the identity function has both type (t! t) and (s! s) ! (s! s), so
(y:y) : (t! t) ^ ((s! s) ! (s! s)):
By this intuition, a quantied type stands for the innite intersection of its
instances:
(y:y) : (8u:u! u):
The types (t ! t) and (s ! s) ! (s ! s) are instances of (8u:u ! u), so in
some sense this typing is \more general" than the rst.
Our ranked system will allow only a limited use of intersections: they may
only appear to the left of a single arrow. For example, we will be able to derive
the following type in our system:
(x:xx) : 8s; t:(s ^ (s! t))! t:
4
This says that as long as the argument of the function (x:xx) has both the
types s and s! t, for some s and t, the result will be of type t. Note that this
term is not typable in ML. An appropriate argument for this function is the
identity function:
(x:xx)(y:y) : (8u:u! u):
Again, we will be able to derive this type in our system. This example is typable
in ML, provided it is translated into a let-expression:
(let x = (y:y) in xx) : (8u:u! u):
We now give the details of our ranked system, called P
2
. The sets T
0
, T
1
,
T
2
, and T
82
of types are dened inductively by the equations below.
T
0
= f t j t is a type variable g [ f(!  ) j ;  2 T
0
g;
T
1
= T
0
[ f( ^  ) j ;  2 T
1
g;
T
2
= T
0
[ f(!  ) j  2 T
1
;  2 T
2
g;
T
82
= T
2
[ f(8t) j  2 T
82
g:
The set T
0
is the set of simple types, and T
1
is the set of nite, nonempty
intersections of simple types. T
2
is the set of rank 2 intersection types: these
are types possibly containing intersections, but only to the left of a single arrow.
Note that rank here refers to the depth of intersections below arrows, not the
depth of nesting of arrows, and that T
0
= T
1
\T
2
. Finally, T
82
adds top-level
quantication of type variables to T
2
.
Just as we have several classes of types, we have several subtyping relations.
1
Their denition is simplied by observing the following conventions: we con-
sider types to be syntactically equal modulo renaming of bound type variables,
reordering of adjacent quantiers, and elimination of unnecessary quantiers;
and we consider `^' to be an associative, commutative, and idempotent oper-
ator, so that any T
1
type may be considered a nite, nonempty set of simple
types, written in the form (
V
i2I

i
), where each 
i
2 T
0
.
Denition 1 For i 2 f1; 2; 82g, we dene the relation 
i
as the least partial
order on T
i
closed under the following rules:
 If f
j
j j 2 Jg  f
i
j i 2 Ig, then (
V
i2I

i
) 
1
(
V
j2J

j
).
 If 
1

1

1
and 
2

2

2
, then (
1
! 
2
) 
2
(
1
! 
2
).
 If  
2
 , then  
82
 .
 If  2 T
0
, then (8t) 
82
ft := g.
 If  
82
 and t is not free in , then  
82
(8t ).
1
These could be combined into a single subtyping relation, but it is technically convenient
to keep them separate.
5
The rst rule says that 
1
expresses the natural ordering on intersection types.
The second rule says that
2
obeys the usual antimonotonic ordering on function
types, restricted to rank 2. The rules for 
82
express the intuition that a type
is a subtype of its instances (we write ft := g for the substitution of  for t
in ). They are equivalent to the following rule, similar to ML's notion of
generic instance:
 If f~s := ~g 
2
 , where ~ is a vector of simple types, and the type
variables
~
t are not free in (8~s), then 8~s 
82
8
~
t .
Note that we only allow instantiation of simple types. This ensures that instan-
tiation does not take us beyond rank 2. It also has less desirable implications,
e.g., (8t:t) is not a least type in the ordering 
82
: (8t:t) 6
82
(s^ (s! u))! u.
A fourth subtyping relation will play an important role in the type system.
The relation 
82;1
between T
82
and T
1
is the smallest relation satisfying the
rule:
 If  
82

i
for all i 2 I, then  
82;1
(
V
i2I

i
).
The relation 
82;1
is not a partial order; it is not even reexive. This is because
it relates types \across rank." Note that in a comparison
(8t) 
82;1
(
^
i2I

i
);
the type variable t may be instantiated dierently for each 
i
.
The typing judgments are of the form A ` M : , where  is a T
82
type,
and all of the types in A are T
1
types. The typing rules are given in Figure 1.
Example 2 Recall that the typings
(x:xx) : 8s; t:(s ^ (s! t))! t;
(y:y) : (8u:u! u);
hold in our system. Then by rule (sub),
(x:xx) : ((s! s) ^ ((s! s)! (s! s)))! (s! s):
And (8u:u! u) 
82
(s ! s) and (8u:u! u) 
82
((s ! s) ! (s ! s)), so by
rules (sub) and (app),
(x:xx)(y:y) : (s! s):
Finally, by rule (gen),
(x:xx)(y:y) : 8s:s! s:
We now give the denition of principal typings appropriate to our system.
6
(var) fx : (
V
i2I

i
)g ` x : 
i
0
(where i
0
2 I)
(abs)
A [ fx : g `M : 
A ` (xM ) :  ! 
(app)
A `M : (
V
i2I

i
)! ; (8i 2 I) A ` N : 
i
A ` (MN ) : 
(gen)
A `M : 
A `M : (8t)
t 62 FTV(A)
(sub)
A `M : 
A `M : 
 
82

(add-hyp)
A `M : 
A [ fx : g `M : 
Figure 1: Typing rules of P
2
. Types in type environments are in T
1
, and derived
types are in T
82
.
Denition 3
i) A typing B ` M :  is an instance of a typing A ` M :  if there
is a substitution S such that S 
82
 and B(x) 
1
S(A(x)) for all
x 2 dom(A).
ii) A principal typing for a term M is a typing A `M :  of which any other
typing of M is an instance.
This denition is standard, cf. [25]. Note in particular that the notion of instance
is monotonic in the derived type, but antimonotonic in the type environment.
The intuition is, a principal typing expects less of its free variables, and
provides more than any other typing judgment.
2.1 Comparison with Rank 2 of System F
The system P
2
is closely connected to 
2
, the restriction of System F to rank 2
types. Our presentation of 
2
is based on that of Kfoury and Tiuryn [15].
The types of System F are dened by the following grammar:
 ::= t j (
1
! 
2
) j (8t ):
We consider System F types to be syntactically equal modulo renaming of bound
type variables, reordering of adjacent quantiers, and elimination of unnecessary
quantiers.
7
(var) A
x
[ fx : g ` x : 
(abs)
A
x
[ fx : g `M : 
A ` (xM ) :  ! 
(app)
A `M :  ! ; A ` N : 
A ` (MN ) : 
(inst)
A `M : 8t
A `M : ft := g
(gen)
A `M : 
A `M : 8t
t 62 FTV(A)
Figure 2: Typing rules of 
2
. Types in type environments are in R(1), and
derived types are in R(2).
The types of System F can be organized into a hierarchy as follows. First,
dene R(0) = T
0
. Then for n  0, the set R(n + 1) is dened to be the least
set satisfying
R(n+ 1) = R(n) [ f(!  ) j  2 R(n);  2 R(n+ 1)g
[ f(8t) j  2 R(n+ 1)g:
The typing judgments are of the form A `M : , where  is an R(2) type,
and all of the types in A are R(1) types. The typing rules are given in Figure 2.
Theorem 4 A term M is typable in P
2
i M is typable in 
2
i M is typable
in the rank 2 intersection type system.
Thus the P
2
programs are exactly the 
2
programs. As we will see, however,
P
2
has the principal typing property, while no notion of principal typings is
known for 
2
[19].
Corollary 5 Typability in P
2
is DEXPTIME-complete.
The proof of Theorem 4 relies on the principal type property of ML and is given
in a separate paper [11]; a similar theorem has been shown independently by
Yokouchi [32]. Corollary 5 follows by the results of Kfoury and Tiuryn [15]
(
2
typability is polynomial time equivalent to ML typability), and Kfoury et
al. [18] and Mairson [22] (ML typability is DEXPTIME-complete).
8
2.2 Subtype satisfaction
In order to perform type inference, we must solve subtype satisfaction problems,
which generalize unication. Solving subtype satisfaction also gives a decision
procedure for subtyping. We will focus on the relation 
82;1
, as it is the most
important for type inference; all of the other relations can be handled in a
similar manner.
A 
82;1
-satisfaction problem  is a pair 9~s:P , where P is a set whose every
element is either: 1) an equality between simple types; or 2) an inequality
between a T
82
type and a T
1
type. A substitution S is a solution to 9~s:P if
there is a substitution S
0
such that S(t) = S
0
(t) for all t 62 ~s, S
0
 
82;1
S
0

for all inequalities (   ) 2 P , and S
0
 = S
0
 for all equalities ( =  ) 2 P .
We write MGS() for the set of most general solutions to a 
82;1
-satisfaction
problem  (as with unication, most general solutions are not unique).
Theorem 6
i) The relation 
82;1
is decidable.
ii) If a 
82;1
-satisfaction problem  is solvable, then there is a most general
solution for . Moreover, there is an algorithm that decides, for any ,
whether  is solvable, and, if so, returns a most general solution.
Algorithms for deciding 
82;1
subtyping and solving 
82;1
-satisfaction prob-
lems are given in Appendix B.
2.3 Type inference
The type inference algorithm is presented in the style favored by the intersection
type community: for any M , we dene a set, PP(M ), called the principal pairs
of M . Every element of PP(M ) is a pair hA; i such that A ` M :  is a
principal typing of M .
Denition 7 For any termM , the set PP(M ) is dened by the following cases.
 If M = x, then hfx : tg; ti 2 PP(x) for any type variable t.
 If M = xN , and hA; 8~si 2 PP(N ), where the type variables ~s are
distinct from all other type variables, then:
{ If x 62 dom(A), and t is a fresh type variable, then hA; 8t~s(t! )i 2
PP(xN ).
{ If x 2 dom(A), then hA
x
;Gen(A
x
; A(x)! )i 2 PP(xN ).
 If M = M
1
M
2
, and hA
1
; 8~s
1
i 2 PP(M
1
), then:
{ If 
1
= t (a type variable), t
1
and t
2
are fresh type variables, the type
variables of hA
2
; 
2
i 2 PP(M
2
) are fresh, U 2 MGS(f
2
 t
1
; t =
t
1
! t
2
g), and A = U (A
1
+A
2
), then
hA;Gen(A;Ut
2
)i 2 PP(M ):
9
{ If 
1
= (
V
i2I

i
) !  , (8i 2 I) the type variables of hA
i
; 
i
i 2
PP(M
2
) are fresh, U 2 MGS(f
i
 
i
j i 2 Ig), and A = U (A
1
+
P
i2I
A
i
), then
hA;Gen(A;U )i 2 PP(M ):
The following technical property is used to show that PP(M ) indeed species
a type inference algorithm: the set PP(M ) is an equivalence class of pairs under
permutations, i.e., hA
1
; 
1
i; hA
2
; 
2
i 2 PP(M ) i hA
1
; 
1
i = ShA
2
; 
2
i for some
bijection S of type variables. Therefore, in choosing hA; i 2 PP(M ) it is always
possible to guarantee that the type variables of hA; i are \fresh."
To perform type inference, simply follow the denition of PP(M ), choosing
\fresh" type variables and using the MGS algorithm as necessary.
Example 8 We show how the algorithm nds a principal typing for (x:xx).
i) PP(x) produces a pair hfx : t
1
g; t
1
i.
ii) PP(x) (again) produces a pair hfx : t
2
g; t
2
i.
iii) To calculate PP(xx), we nd a most general solution to
ft
2
 t
3
; t
1
= t
3
! t
4
g;
such as ft
2
:= t
3
; t
1
:= t
3
! t
4
g. Then
hfx : t
3
^ (t
3
! t
4
)g; t
4
i 2 PP(xx):
iv) Finally, PP(x:xx) produces
h;; 8t
3
; t
4
:(t
3
^ (t
3
! t
4
))! t
4
i:
Theorem 9 (Principal typings) If M is typable in P
2
, then there is a pair
hA; i 2 PP(M ) such that A `M :  is a principal typing for M .
3 Recursive denitions
We now add recursive denitions to our language: a term of the form (xM )
represents the program x such that x = M , where M may contain occurrences
of x.
As we remarked in the introduction, the principal typing property suggests
that we type recursive denitions by a rule of the following form.
(rec)
A [ fx : g `M : 
A ` (xM ) : 
 
82;1

The rule (rec) can type strictly more terms than the rule (rec-simple) of
ML. For example, the following term is typable in P
2
+ (rec), but not in
P
2
+ (rec-simple):
(x:(yz:z)(xx)) : 8t:t! t:
10
The self-application xx cannot be typed if x is assigned just a simple type.
However, (rec) cannot type as many terms as (rec-poly). For example,
the term (x:xx) has type (8t:t) in ML+(rec-poly), but it is not typable with
our rules.
It is interesting to compare (rec) with a rule, (fix'), that Mycroft [26]
suggested in the context of ML:
(fix')
A ` x
1
  x
n
:M
0
: 
1
!    ! 
n
! 
A ` (xM ) : 
Here M is a term with n occurrences of x, M
0
is M with each occurrence of x
renamed to a fresh variable x
i
, 
1
; : : : ; 
n
;  are simple types, and Gen(A;  )  
i
for all i  n.
The idea behind Mycroft's rule is that each of the nite occurrences of x inM
may have a dierent simple type (so long as M can be shown to satisfy those
types). The same idea explains the typing power of (rec). Note, however, that
this idea was not the motivation for (rec). Instead, (rec) arose as an instance
of a general rule motivated by the principal typing property. Other interesting
typing rules may arise as instances of the general rule, in type systems other
than P
2
.
Mycroft's rule is actually more powerful than (rec). The side condition,
Gen(A;  )  
i
, permits  to be generalized by any type variable not appearing
in A, including type variables appearing in the 
i
. This is not allowed by (rec).
The term (x:xx) is one place where this makes a dierence: it is typable with
(fix') but not (rec). For a more practical example, consider the following ML
code. It comes from the ML mailing list, and has arisen in practice.
datatype 'a T = EMPTY
| NODE of 'a * ('a T) T
fun collect EMPTY = nil
| collect (NODE(n,t)) =
n :: flatmap collect (collect t)
Here 'a T is a polymorphic tree type, and flatmap is the mapping function
of type ('a -> 'b list) -> 'a list -> 'b list. The function collect,
which collects all the labels of an 'a T and returns them in an 'a list, is
typable with (rec-poly) and with (fix'), but not with (rec). Of course, we
could generalize our rule along the lines of (fix'):
(rec')
A [ fx : g `M : 
A ` (xM ) : 
Gen(A; ) 
82;1

The system would retain principal typings and decidable type inference, but for
simplicity, we stay with (rec).
11
(letrec-simple)
(8j 2 I) A [ fx
i
: 
i
j i 2 Ig ` M
j
: 
j
(
j
2 T
0
)
A [ fx
i
: Gen(A;
i
) j i 2 Ig `M : 
A ` (letrec fx
i
= M
i
j i 2 Ig in M) : 
(letrec-var)
8j 2 I A [ fx
i
: 
i
j i 2 Ig `M
j
: 
j
(
j

82;1

j
)
A ` (letrec fx
i
= M
i
j i 2 Ig in x
i
0
) : 
i
0
i
0
2 I
(letrec)
A [ fx
i
: 
i
j i 2 Ig ` N : 
8j 2 I A `
^
(letrec fx
i
= M
i
j i 2 Ig in x
j
) : 
j
A ` (letrec fx
i
= M
i
j i 2 Ig in N) : 
N 62 fx
i
j i 2 Ig
Figure 3: Rules for typing mutually recursive denitions. The rule (letrec-
simple) is used by ML, while P
2
uses (letrec-var) and (letrec).
3.1 Mutual recursion
In order to support the applications of principal typings in the next section, we
add mutually recursive denitions to the language. Such denitions are written
(letrec x
1
= M
1
; : : : ; x
n
= M
n
in N )
or
(letrec fx
i
= M
i
j i 2 Ig in N );
where all of the x
i
are distinct.
The typing rules for letrec are given in Figure 3. ML uses the rule (letrec-
simple) to type mutual recursion. In (letrec-simple), the recursive deni-
tions must be typed under the assumption that the recursive variables have
simple type. In typing the body of the letrec, however, the types of the recur-
sive variables can be generalized, so that they can be used polymorphically.
We cannot use (letrec-simple) with P
2
, because P
2
does not permit quan-
tied types to appear in type environments. And it is not easily adapted to P
2
.
In ML, the polymorphic type Gen(A; 
i
) of x
i
is easily obtained from the simple
type 
i
used in typing the recursive denitions. The equivalent of Gen(A; 
i
) in
P
2
is some intersection (
V
j2J

j
), where each 
j
is an instance of Gen(A; 
i
). It
is not immediately clear how to get directly from 
i
to (
V
j2J

j
).
Instead, our rules for P
2
are based on the following observation: the typings
of any term (letrec B in N ) can be expressed in terms of the typings for
terms (letrec B in x), where x is a variable dened by B. Formally, for any
B = fx
1
= M
1
; x
2
= M
2
; : : : ; x
n
= M
n
g and M = (letrec B in N ), we dene
hhM ii to be the term
hhM ii = (let x
1
= (letrec B in x
1
)
.
.
.
x
n
= (letrec B in x
n
)
in N ):
The following lemma is easily proved.
12
Lemma 10 In ML+ (letrec-simple), A `M :  i A ` hhM ii : .
This is the intuition behind the rules (letrec-var) and (letrec) of Figure 3.
(letrec-var) is a straightforward generalization of the rule (rec) for terms
of the form (letrec B in x), where x is a variable dened in B. Lemma 10
suggests that we type other letrec expressions by a rule of the form
A ` hhletrec B in N ii : 
A ` (letrec B in N ) : 
(N is not dened by B)
Our rule (letrec) is obtained simply by desugaring the let-expression formed
by hhii into abstractions and applications, and considering how the resulting
term would be typed by (abs) and (app). We make the rule more compact by
using the notation A `
^
M : (
V
i2I

i
) to abbreviate (8i 2 I) A `M : 
i
.
We write 
R
2
for the system 
2
+ (rec-simple) + (letrec-simple), and
P
R
2
for the system P
2
+ (rec)+ (letrec-var) + (letrec).
Theorem 11 If M is typable in 
R
2
, then M is typable in P
R
2
.
Denition 12 The type inference algorithm of Denition 7 can be extended
to P
R
2
by adding the following cases.
 If M = (xN ) and hA; i 2 PP(N ), then:
{ If x 62 dom(A), and U 2 MGS(f  tg) where t is a fresh type
variable,
then hUA;Gen(UA;U)i 2 PP(M ).
{ If x 2 dom(A) and U 2MGS(f  A(x)g),
then hUA
x
;Gen(UA
x
; U)i 2 PP(M ).
 If M = (letrec fx
i
= M
i
j i 2 Ig in x
i
0
), where i
0
2 I,
and hA
i
; 
i
i 2 PP(M
i
) for i 2 I,
A
0
=
P
i2I
A
i
,
A
00
= A
0
[ fx
i
: t
i
j x
i
62 dom(A
0
); t
i
freshg,
U 2MGS(f
i
 A
00
(x
i
) j i 2 Ig),
and A = UA
00
fx
i
ji2Ig
,
then hA;Gen(A;U
i
0
)i 2 PP(M ).
 If M = (letrec fx
i
= M
i
j i 2 Ig in N ), where N 62 fx
i
j i 2 Ig, and
hA; i 2 PP(hhM ii),
then hA; i 2 PP(M ).
Theorem 13 (Principal typings) If M is typable in P
R
2
, then there is a pair
hA; i 2 PP(M ) such that A `M :  is a principal typing for M in P
R
2
.
13
An important limitation of our rules for mutual recursion is illustrated by
the following well-known example of Mycroft [26]:
map = f:l: if null l then nil
else f(hd l) :: map f (tl l)
squarelist = l: map (x: x x) l
complement = l: map (x: not x) l
This program is not typable under our rules (or ML's rules) when presented as a
single, mutually recursive denition. The function map is used polymorphically
by the other functions, and our rules do not allow sucient polymorphism for
the program to type. Note that map does not depend on the other functions; if
map is placed in a separate recursive denition, the program can be typed by
our rules.
Thus to type an unordered set of denitions, it is necessary to examine the
call graph of the program to determine an order in which to type the denitions.
This complication must be addressed by the applications of the next section.
2
4 Separate compilation
Any separate compilation system manages a collection of small program frag-
ments that together make up a single large program. Two questions must be
answered by such a system. First, does the program as a whole type check?
And second, how do we generate code for each program fragment, and how can
we combine these code fragments into an executable program?
We consider each of these questions in turn.
4.1 Incremental type inference
The problem of incremental type inference [1] can be described as follows. A
user develops a program in an incremental fashion, by entering a sequence of
denitions to a read-eval-print loop:
x
1
=M
1
; x
2
=M
2
; x
3
= M
3
; : : :
After each denition is entered, the compiler performs type inference to ensure
the type-correctness of the partial program. Denitions may be re-dened as
the programmer detects and corrects bugs, and they may be mutually recursive.
Most relevant, a \bottom-up" style of program development is made possible by
allowing denitions to refer to other denitions which have not yet been entered.
Incremental type inference is thus the type checking task of separate compi-
lation on an extremely ne scale: not just every module, but every denition is
typed and compiled separately.
2
A generalization of our rules along the lines of Mycroft's (fix') could handle the map
example, but not all such examples.
14
Consider a partial program x
1
= M
1
; : : : ; x
n
= M
n
, where duplicate def-
initions have been discarded. To check that the program is well-typed, it is
sucient to perform type inference on the expression
(letrec B
1
in    (letrec B
m
in 0)   )
derived from the call graph of the program: each B
i
is a strongly connected
component (SCC) of mutually recursive bindings, and the B
i
are topologically
sorted.
This can be accomplished by any type inference algorithm that works on
terms with free variables. But this is not enough to solve the incremental
problem eciently: when the user enters the next denition, x
n+1
= M
n+1
,
we must do better than just running the type inference algorithm on the new
expression
(letrec B
0
1
in    (letrec B
0
m
0
in 0)   ):
A close inspection of the P
R
2
type inference algorithmwill show that principal
typings are the key to ecient incremental type inference.
If P = (letrec B
1
in    (letrec B
m
in 0)   ) is our partial program, and
the variables dened by each B
i
are denoted x
i;1
; : : : ; x
i;n
i
, then by the P
R
2
equivalent of Lemma 10, type inference for P is equivalent to type inference for
the expression
hhP ii = (let x
1;1
= (letrec B
1
in x
1;1
)
.
.
.
x
1;n
1
= (letrec B
1
in x
1;n
1
)
.
.
.
x
m;1
= (letrec B
1
in x
m;1
)
.
.
.
x
m;n
m
= (letrec B
m
in x
m;n
m
)
in 0);
where let's are desugared into applications of abstractions.
We now show that type inference for such an expression is equivalent to
solving a subtype satisfaction problem constructed from the principal pair of
each (letrec B
i
in x
i;j
).
Denition 14 For any termM , we dene the set L

(M ) inductively as follows.
 If M = (xM
1
)M
2
,
and hA
1
; ; i 2 L

(M
1
)
hA
2
; 
2
i 2 PP(M
2
)
(
V
i2I

i
) =

t if x 62 dom(A
1
) and t is fresh,
A
1
(x) otherwise.
(8i 2 I) S
i
renames FTV(A
2
; 
2
) to fresh type variables
then hA
1
+ (
P
i2I
S
i
A
2
); ;  [ fS
i

2
 
i
j i 2 Igi 2 L

(M ).
15
 Otherwise, hA; ; ;i 2 L

(M ) i hA; i 2 PP(M ).
Lemma 15 hA; i 2 PP(M ) i for some A
0
; 
0
;  and U , hA
0
; 
0
; i 2 L

(M ),
U 2MGS(), and hA; i = hUA
0
;Gen(UA
0
; U
0
)i.
Therefore, we can perform type inference for P by calculating hA; ; i 2
L

(hhP ii), and nding a solution to . And L

(hhP ii) is calculated from the
principal pair of each (letrec B
i
in x
i;j
).
Now consider the incremental case. When the user enters the next denition,
x
n+1
= M
n+1
, we must perform type inference on a new partial program, P
0
.
Just as before, this means calculating a new 
0
from L

(hhP
0
ii). And again, this
requires the principal pair of each (letrec B
0
i
0
in x
i
0
;j
0
).
We now argue that L

(hhP
0
ii) can be constructed incrementally. First note
that the new denition may not change the SCC's of the existing call graph:
the SCCs change only when the new denition is mutually recursive with a
previous denition. So most often, (letrec B
0
i
0
in x
i
0
;j
0
) will equal some previous
(letrec B
i
in x
i;j
); and then, by the principal typing property, the principal pair
of (letrec B
i
in x
i;j
) is unchanged.
We even benet if the SCC's change. If B = fx
i
= M
i
j i 2 Ig is a new
SCC, we must calculate the principal pair of (letrec fx
i
= M
i
j i 2 Ig in x
j
)
for all j 2 I. This involves computing PP(M
i
) for each M
i
; but if i 6= n + 1,
then by the principal typing property, PP(M
i
) is unchanged.
Thus the principal pair for each denition need only be computed once, as it
is entered by the user; it does not need to be recomputed at each new denition
or re-denition. This is not the case in the system of Aditya and Nikhil, where a
new denition may cause the entire program to be reprocessed (see [8], p. 104).
We must also calculate a solution to the new satisfaction problem. How-
ever, the new problem may be almost identical to the previous problem. In
particular, if the new denition does not change the SCCs of the call graph,
the new satisfaction problem will be a superset of the old problem. We may be
able to incorporate large parts of the old solution into the new solution. Our
algorithm for subtype satisfaction, described in Appendix B, solves problems by
transforming them into equivalent, simpler problems until a solution is reached.
Such an algorithm is ideally suited to incorporating parts of the old solution.
The transformations that applied to the old problem will, for the most part, be
identical to the transformations applicable to the new problem.
Finally, we remark that the SCCs and topological sort may be computed
incrementally by o-the-shelf algorithms [10, 23].
4.2 Smartest recompilation
Once we have solved the type checking task of separate compilation, we face the
task of code generation. Types determine data representations, calling conven-
tions, and other implementation details. Thus we regard compilers as functions
from typing judgments to machine code. For example, the compilation of a
16
module M that imports a module x can be written
Compile(fx : g `M :  ) = hmachine code for Mi:
There are two diculties with this strategy. First, the compiler requires as
input a typing judgment, or, at least, the types of external variables. The
typical solution is to require the user to supply the types. A better solution is
available in P
2
, where the compiler itself can infer a judgment fx : g ` M : 
for a term M with free variable x.
The second diculty arises when we need to link all of the code fragments
together into a single program. In particular, consider recompilation, in which
a user changes a single module x and the system attempts to recompile as small
a portion of the entire program as possible. Certainly the denition of x must
be recompiled. Moreover, an unchanged module M that imports x may have
to be recompiled: if the type of x changes, then the typing judgment of M , and
thus its compiled output, changes.
This is where principal typings help. Suppose that we have compiled a
module M by compiling its principal typing, A ` M :  . At link time, we
discover that in order to be consistent with the rest of the program, we should
instead have compiledM by a dierent typing, B `M : . The principal typing
property tells us that the second judgment is an instance of the rst: in P
2
,
it can be obtained by substitution and subsumption from the principal typing.
More formally,
hB; i = ChA; i;
where C is an operator that applies substitution and subsumption to the pair
hA;  i.
Stating the problem in this way lets us study the operator C in isolation. The
operations of substitution and subsumption specied by C can be implemented
via coercions. These coercions can be \wrapped" around the code generated for
the typing A ` M :  at link time, making it behave like code generated for
B `M :  . That is,
Compile(B `M : )

=
Link(C;Compile(A `M :  ));
where Link produces machine code that implements the coercions specied by C.
Using this strategy, a module need not be recompiled unless its denition
changes. This property was dubbed smartest recompilation by Shao and Ap-
pel [27]. They achieved smartest recompilation for ML by relating ML to a
restriction of P
2
with principal typings.
Shao and Appel identied the following problem with smartest recompila-
tion. If a module references many free variables, e.g., functions from the stan-
dard library, then the type environment of the principal typing becomes large.
This can be alleviated in the following way. Let B be a type environment speci-
fying the T
82
types of our library functions. We modify our type system to use
two type environments, so that typings are of the form
A;B `M : :
17
We modify our old rules to ignore this new type environment, and add a rule
that allows us to use it:
(var-new) A;B [ fx : g ` x : 
This system does not have principal typings, but it does have a useful \weak"
form of principal typing property: given a term M typable in type environ-
ment B, there exists a typing A;B `M :  representing all possible typings for
M in B. We say that M has a principal typing with respect to the type envi-
ronment B, and that we have smartest compilation with respect to B. Since B
only species types for identiers that are relatively stable, we gain most of the
benets of full smartest recompilation.
As an aside, we remark that this immediately suggests an extension to the
type system: restore let-expressions to the language and add the rule
(let)
A;B `M : ; A;B
x
[ fx : g ` N : 
A;B ` (let x =M in N ) : 
We call this a \rank 2.5" system, since it lies between ranks 2 and 3. For
instance, it can type a term that is untypable in rank 2:
let g = (x:xx) in g(y:y) : 8t:t! t:
We will not pursue this further, because we already know how to extend P
2
to
a more general system, called P, that does not rely on let-polymorphism. The
description of P will appear in a future paper.
We do not claim that we have solved the smartest recompilation problem
for Standard ML. Standard ML has a rich module system, with type com-
ponents in modules, and generative, user-denable, recursive datatypes. Our
simple language does not support such features (nor does the work of Shao and
Appel [27]). However, we have identied principal typings, or some equivalent,
as the key ingredient of such a system.
5 Error messages
Up until now, we have concentrated on one benet of principal typings: a term
can be given a type without regard to the denitions of its free variables.
The ip side of this benet is that a denition can be typed independently
of its uses. We now show how this allows us to produce accurate error messages
when our type inference algorithm is faced with a program containing type
errors.
Consider a denition, (xM )N , in which some uses of the variable x cause
type errors: they require types that N cannot satisfy. To perform type inference,
we calculate the principal typings of both the operator and the operand, say
A ` (xM ) : (
V
i2I

i
)! ;
A
0
` N : 
0
:
18
By the principal typing property, we can calculate these principal typings in
any order. To complete type inference, we simply check whether we can satisfy
 = fS
i

0
 
i
j i 2 Ig;
where each S
i
renames FTV(A
0
; 
0
) to fresh type variables. At this point we
will discover all of the type errors related to x: for some i, the type S
i

0
will
not be able to satisfy the constraints expressed by 
i
. If we take care to label
each constraint with the use of x that produced it, we can output the oending
uses, all in one batch.
Contrast this with the situation in ML. Assuming the denition is polymor-
phic, we must perform type inference on a let-expression (let x = N in M ).
Without principal typings, we are forced to rst calculate the principal type, ,
of N . We then process M , instantiating  at each use of x. Errors are reported
as they are encountered, at each use. But note, the errors of one denition can
be interspersed with errors for other denitions, or with run-on errors. And the
type  may have been specialized for that particular (erroneous) use, leaving
the programmer to understand a type only remotely related to the type  of
the denition.
6 Does ML have principal typings?
We have deliberately stated the principal typing property in a broad way, so
that it can be applied to many dierent type systems.
3
In particular, we have
not precisely dened what it means to represent all possible typings, because
this will vary from one type system to another.
This imprecision makes it impossible for us to prove that a given type system
lacks the principal typing property. Nevertheless, we do not know of a sensible
formulation of principal typings for ML, and in particular, ML does not have
principal typings in the sense of our Denition 3. For example, consider the
following ML typings of the term xx.
fx : 8t:tg ` xx : 8t:t;
fx : 8t:t! tg ` xx : 8t:t! t:
Our intuition is that a principal typing expects less of its free variables and
provides more than any other typing. We certainly cannot hope to derive a
more general type for the term xx than (8t:t), so the rst judgment provides
more than the second. However, the rst judgment also makes a strong require-
ment on x: the type environment indicates that it too must have type (8t:t).
Thus the second judgment expects less than the rst, and neither typing is more
general than the other. Moreover, there is no typing more general than both
the typings above. The obvious candidate,
fx : 8t:t! tg ` xx : 8t:t;
3
In fact, we could have stated it more broadly still: we assumed typing judgments were of
the form A `M : , but this is not always the case.
19
is not derivable.
Why doesn't ML's principal type property imply the existence of principal
typings? You might think that the principal typing of a term could be obtained
from the principal type of the -closure of the term. But ML has only a restricted
abstraction rule:
A [ fx : 
1
g `M : 
2
A ` (xM ) : 
1
! 
2

1
; 
2
2 T
0
In ML, we cannot abstract over variables of polymorphic type; the only way of
introducing polymorphic variables is through let-expressions.
7 Living without principal typings
If we want to work in a language lacking the principal typing property, we may
still achieve some of its benets by nding a \representation" for all possible
typings. That is, we may relax the principal typing condition that the repre-
sentatives themselves be typings.
Pushed to an extreme, this is nonsense|after all, M itself is a represen-
tation of all typings of M ! But there is a middle ground. For example, the
\representation" may be a typing in another type system.
This idea was the basis of the smartest recompilation system of Shao and
Appel [27]. They dened a type system with the following property: for any ML
typable term M , there is a judgement in the Shao-Appel system that encodes
all of the ML typings for M , in an appropriate sense. They did not prove a
principal typing property for their system, but it is essentially identical to a
system of Damas [6]. Damas proved a principal typing theorem for his system,
and showed that it types exactly the same terms as ML.
The systems P
2
and 
2
are a second example of this phenomenon. We have
shown that P
2
has principal typings and types exactly the same terms as 
2
.
However, 
2
does not have principal typings in the sense of Denition 3. The
counterexample xx that we used for ML also works for 
2
. Unlike ML, 
2
has
a \true" abstraction rule; this is not a contradiction, because in addition to
lacking principal typings, 
2
lacks principal types [19].
And for a third example, Palsberg and Scott
4
have shown that the recursive
type system of Amadio and Cardelli [3] types exactly the same terms as a type
system based on constraints [7]. Palsberg has shown that the Amadio-Cardelli
system does not have principal typings, and Jim has shown that the constraint-
based system does have principal typings.
8 An extension
The system P
2
is the rank 2 fragment of a type system, P, that can type many
more terms. The description of P is beyond the scope of this paper. However,
we will present a few examples of its typing power.
4
Personal communication, September 1995.
20
If we dene terms M and N by
M = (g:g(f:f(x:x)));
N = (w:w(y:yy));
then the following typings hold in P:
M : 8t:((8s:((8u:u! u)! s)! s)! t)! t;
N : 8u:((8st:(s ^ (s! t))! t)! u)! u;
MN : 8t:t! t:
Only M is typable in ML or P
2
, and only at less informative types. Note that
in the type of M , the inner quantier, 8u, is under the left of four arrows, well
beyond rank 2.
The system P has the principal typing property, decidable type inference,
and a rule in the style of (rec) for typing recursive denitions. The crucial
technical advance is a way of solving subtype satisfaction problems for types
with quantiers and intersections at unlimited depth.
9 Related work
Principal typings are not a new concept. A number of existing type systems
have principal typings, including the simply typed lambda calculus [31], the
system of recursive types [5], the system of simple subtypes [25], and the system
of intersection types [4]. Our contribution is to highlight the practical uses
of the principal typing property, and to distinguish it from the principal type
property. A number of authors have published ohand claims that ML possesses
the principal typing property, despite the early remarks of Damas [6] to the
contrary.
The system of rank 2 intersection types is also not new, but as with the
principal typing property, it has attracted little attention. It was rst suggested
by Leivant in 1983 [21], but he did not give a formal denition of the type
inference algorithm or proof of correctness. In an oft-referenced 1984 paper [24],
McCracken gave a type inference algorithm for rank 2 of System F, inspired by
Leivant's ideas. This algorithm is incorrect. A correct algorithm for rank 2 of
System F was nally given by Kfoury and Wells [19] in 1993. Their algorithm is
completely unrelated to Leivant's algorithm. The earliest formal denition and
proof of Leivant's algorithm was published in 1993, by van Bakel [29].
Our addition of top-level quantication is a useful technical improvement
to the rank 2 intersection system. In particular, the simplicity of our rule for
typing recursive denitions is due to the power of quantiers and the subtyping
relation 
82;1
. It is possible to formulate an equivalent rule for typing recursive
denitions without top-level quantication, but the machinery is cumbersome
and simply duplicates the functionality of the quantiers.
We have shown that rank 2 of System F is closely related to our type sys-
tem. However, rank 2 of System F does not have principal types or principal
21
typings [19]. Launchbury and Peyton Jones [20] describe an interesting constant
with a rank 2 System F type. Rank 2 System F types are not part of our type
system, and we do not know how to handle their constant without resort to
a special typing rule. This is the same solution employed by Launchbury and
Peyton Jones.
The system of Aiken and Wimmers [2] uses ML's let-polymorphism, and,
therefore, we believe it does not have principal typings. The subsystem without
let-polymorphism, though, is still of interest, and may have principal typings
(but this is not clear). The constraint-based systems of Jones [12], Kaes [14],
and Smith [28] are also based on ML.
Constraint satisfaction, including subtype satisfaction, is an important com-
ponent of each of these systems. Our method for solving constraints involving
quantiers (
82;1
-satisfaction) is a signicant advance over these systems. Along
with intersections, this is the central mechanism by which let-polymorphism is
avoided and principal typings are achieved. In our work on the system P, we
will show how to solve some subtype satisfaction problems for types with quan-
tiers and intersections at unlimited depth, giving type inference for a system
with a much richer class of types.
10 Conclusion
We have shown that the principal typing property has practical applications,
including smartest recompilation, incremental type inference, and accurate type
error messages. Inspired by the principal typing property, we proposed a new
rule for typing recursive denitions. The type inference algorithm of our system
P
2
is easily extended to infer principal typings for recursive denitions under
the new rule, resulting in a type system with decidable type inference that can
type some interesting examples of polymorphic recursion.
A number of languages, including ML, seem to lack the principal typing
property. In such languages, we may achieve some of the benets of principal
typings by nding a way to represent all possible typings for a term. In partic-
ular, a term's principal typing in one type system may serve as a representative
of all of its typings in another type system. This technique serves for 
2
, whose
typings can be represented by principal typings in P
2
.
Although our primary goal was to draw attention to the principal typing
property, a secondary contribution is to draw attention to the system of rank 2
intersection types, which also seems to have been overlooked. Our particular
version of this system, P
2
, makes an important technical contribution by show-
ing how to solve subtype satisfaction problems for types containing quantiers.
Our types only have quantiers at top level, but the method is easily extended
to types with quantiers at unlimited depth, as we will show in a forthcoming
paper.
Acknowledgments. This paper has beneted from the comments of Assaf
Kfoury, Albert Meyer, Jens Palsberg, Mona Singh, Phil Wadler, and the POPL
22
referees. We thank Fritz Henglein for pointing out Mycroft's rule (fix') and
the work of Damas.
References
[1] Shail Aditya and Rishiyur Nikhil. Incremental polymorphism. In Func-
tional Programming Languages and Computer Architecture, volume 523 of
Lecture Notes in Computer Science, pages 379{405. Springer-Verlag, 1991.
[2] Alexander Aiken and Edward L. Wimmers. Type inclusion constraints
and type inference. In Functional Programming Languages and Computer
Architecture, pages 31{41. ACM Press, June 1993.
[3] Roberto M. Amadio and Luca Cardelli. Subtyping recursive types. ACM
Transactions on Programming Languages and Systems, 15(4):575{631,
September 1993.
[4] Henk Barendregt, Mario Coppo, and Mariangiola Dezani-Ciancaglini. A
lter lambda model and the completeness of type assignment. J. Symbolic
Logic, 48(4):931{940, December 1983.
[5] Felice Cardone and Mario Coppo. Type inference with recursive types:
Syntax and semantics. Information and Computation, 92(1):48{80, May
1991.
[6] Luis Manuel Martins Damas. Type Assignment in Programming Languages.
PhD thesis, University of Edinburgh, 1984.
[7] J. Eifrig, S. Smith, and V. Trifonov. Type inference for recursively con-
strained types and it application to OOP. In Proc. Mathematical Founda-
tions of Programming Semantics, 1995. To appear.
[8] Shail Aditya Gupta. An incremental type inference system for the program-
ming language Id. Master's thesis, Massachusetts Institute of Technology,
November 1990. Available as MIT/LCS Technical Report TR{488.
[9] Fritz Henglein. Type inference with polymorphic recursion. ACM Transac-
tions on Programming Languages and Systems, 15(2):253{289, April 1993.
[10] Monika Rauch Henzinger and Valerie King. Fully dynamic biconnectivity
and transitive closure. To appear in Proc. 36
th
Annual Symp. on Founda-
tions of Computer Science, 1995.
[11] Trevor Jim. Rank 2 type systems and recursive denitions. Technical Mem-
orandum MIT/LCS/TM{531, M.I.T. Lab. for Computer Science, August
1995.
[12] Mark P. Jones. Qualied Types: Theory and Practice. Cambridge Univer-
sity Press, November 1994.
23
[13] Jean-Pierre Jouannaud and Claude Kirchner. Solving equations in abstract
algebras: A rule-based survey of unication. In Jean-Louis Lassez and
Gordon Plotkin, editors, Computational Logic: Essays in Honor of Alan
Robinson, chapter 8, pages 257{321. MIT Press, 1991.
[14] Stefan Kaes. Typing in the presence of overloading, subtyping, and re-
cursive types. In Proceedings of the 1992 ACM Conference on Lisp and
Functional Programming, pages 193{204, 1992.
[15] A.J. Kfoury and J. Tiuryn. Type reconstruction in nite rank fragments of
the second-order -calculus. Information and Computation, 98(2):228{257,
June 1992.
[16] A.J. Kfoury, J. Tiuryn, and P. Urzyczyn. A proper extension of ML with
an eective type-assignment. In Conference Record of the Fifteenth Annual
ACM Symposium on Principles of Programming Languages, pages 58{69,
1988.
[17] A.J. Kfoury, J. Tiuryn, and P. Urzyczyn. Type reconstruction in the pres-
ence of polymorphic recursion. ACM Transactions on Programming Lan-
guages and Systems, 15(2):290{311, April 1993.
[18] A.J. Kfoury, J. Tiuryn, and P. Urzyczyn. An analysis of ML typability.
Journal of the ACM, 41(2), March 1994.
[19] A.J. Kfoury and J.B. Wells. A direct algorithm for type inference in the
rank 2 fragment of the second-order lambda-calculus. In Proceedings of
the 1994 ACM Conference on Lisp and Functional Programming, pages
196{207, 1994.
[20] John Launchbury and Simon L Peyton Jones. Lazy functional state threads.
In Proceedings of the ACM SIGPLAN '94 Conference on Programming
Language Design and Implementation, pages 24{35, 1994.
[21] Daniel Leivant. Polymorphic type inference. In Conference Record of the
Tenth Annual ACM Symposium on Principles of Programming Languages,
pages 88{98, 1983.
[22] Harry G. Mairson. Deciding ML typability is complete for deterministic
exponential time. In Conference Record of the Seventeenth Annual ACM
Symposium on Principles of Programming Languages, pages 382{401, 1990.
[23] Marchetti-Spaccamela, Nanni, and Rohnert. On-line graph algorithms for
incremental compilation. In Graph-Theoretic Concepts in Computer Sci-
ence, International Workshop WG, 1993.
[24] Nancy McCracken. The typechecking of programs with implicit type struc-
ture. In G. Kahn, D.B. MacQueen, and G. Plotkin, editors, Semantics
of Data Types, volume 173 of Lecture Notes in Computer Science, pages
301{315, June 1984.
24
[25] John Mitchell. Type inference with simple subtypes. J. Functional Pro-
gramming, 1(3):245{285, July 1991.
[26] A. Mycroft. Polymorphic type schemes and recursive denitions. In Pro-
ceedings of the International Symposium on Programming, Toulouse, vol-
ume 167 of Lecture Notes in Computer Science, pages 217{239. Springer-
Verlag, 1984.
[27] Zhong Shao and Andrew W. Appel. Smartest recompilation. In Conference
Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages, pages 439{450, 1993.
[28] Georey S. Smith. Principal type schemes for functional programs with
overloading and subtyping. Science of Computer Programming, 23:197{
226, 1994.
[29] Steen van Bakel. Intersection Type Disciplines in Lambda Calculus and
Applicative Term Rewriting Systems. PhD thesis, Mathematisch Centrum,
Amsterdam, February 1993.
[30] Mitchell Wand. Finding the source of type errors. In Conference Record
of the Thirteenth Annual ACM Symposium on Principles of Programming
Languages, pages 38{43, 1986.
[31] Mitchell Wand. A simple algorithm and proof for type inference. Funda-
menta Infomaticae, 10:115{122, 1987.
[32] Hirofumi Yokouchi. Embedding a second-order type system into an inter-
section type system. Information and Computation, 117(2):206{220,March
1995.
A Technical details of the type system
We use x; y; : : : to range over a countable set of (term) variables, and M;N; : : :
to range over terms. The terms of the language are just the terms of the lambda
calculus:
M ::= x j (M
1
M
2
) j (xM ):
Terms are considered syntactically equal modulo renaming of bound variables,
and we adopt the usual conventions that allow us to omit parentheses: appli-
cation associates to the left, and the scope of an abstraction x extends to the
right as far as possible. We write x
1
  x
n
:M for (x
1
(   (x
n
M )   )).
We use s; t; u : : : to range over a countable set, Tv, of type variables, and
; ; : : : to range over types. We dene several classes of types, each of which is
a restriction of the types with quantication and intersection:
 ::= t j (
1
! 
2
) j (8t) j (
1
^ 
2
):
25
The constructor `^' binds more tightly than `!', e.g.,  ^  ! t means ( ^
 ) ! t, and the scope of a quantier `8' extends as far to the right as pos-
sible. If
~
t = t
1
; t
2
; : : : ; t
n
, n  0, and  2 T
2
, we write (8
~
t) for the type
(8t
1
(8t
2
(: : : (8t
n
) : : :))).
A type environment is a nite set fx
1
: 
1
; : : : ; x
n
: 
n
g of (variable, type)
pairs, where the variables x
1
; : : : ; x
n
are distinct. We use A to range over type
environments. We write A(x) for the type paired with x in A, dom(A) for the
set fx j 9:(x :  ) 2 Ag, and A
x
for the type environmentA with any pair for the
variable x removed. We write A
1
[A
2
for the union of two type environments;
by convention we assume that the domains of A
1
and A
2
are disjoint. We dene
A
1
+ A
2
as follows: for each x 2 dom(A
1
) [ dom(A
2
),
(A
1
+ A
2
)(x) =
8
<
:
A
1
(x) if x 62 dom(A
2
);
A
2
(x) if x 62 dom(A
1
);
A
1
(x) ^A
2
(x) otherwise.
We write Gen(A; ) for the 8-closure of variables free in  but not A.
B A subtype satisfaction algorithm
A unication problem is a satisfaction problem involving only equalities. Uni-
cation algorithms, such as Robinson's algorithm, can determine, for any uni-
cation problem, whether a solution exists, and, if so, produce a most general
solution. Two problems are equivalent if they have the same solutions.
We will show how to transform a 
82;1
-satisfaction problem into an equiva-
lent unication problem. The transformation is dened by rules of the form
   ) 9~s:P:
The rules may need to introduce fresh type variables, that is, type variables
that do not appear on the left-hand side. These variables will appear in the
variables ~s of the right-hand side (but they are not the only source of variables
in ~s).
The rules are used to dene a rewrite relation on problems:
   ) 9
~
t:P
9~s:P
0
] f  g ) 9~s ]
~
t:P
0
[ P
The operator `]' is disjoint union; on the right of the consequent, it means that
the variables
~
t must be fresh (this can always be achieved by renaming).
The rules for transforming a 
82;1
-unication problem into a unication
problem are given in Figure 4. To see that these rules constitute an algorithm
for producing an equivalent unication problem, observe that the rules preserve
solutions, that the system is terminating, and that normal forms contain no
inequalities, and thus are unication problems.
26
(
1
! 
2
)  t ) 9t
1
; t
2
:ft
1
 
1
; 
2
 t
2
; t = t
1
! t
2
g
if t
1
; t
2
are fresh
(
1
! 
2
)  (
1
! 
2
)
) f
1
 
1
; 
2
 
2
g
  (
1
^ 
2
) ) f  
1
;   
2
g
t   ) ft = g
if  is a simple type
(8t)   ) 9tf  g
if  is not a ^-type, and t is not
free in 
Figure 4: Transformational rules for 
82;1
-satisfaction problems
A unication algorithm in a transformational style,
5
taken from [13], is given
in Figure 5. The normal forms of the rewrite system are in solved form, a set of
equations that corresponds immediately to a most general substitution. Note
the special problem F , used to denote failure of unication.
The combination of these two transformation systems is an algorithm for
nding most general solutions to 
82;1
-satisfaction problems. As a special case,
we obtain a decision procedure for subtyping: to see whether  
82;1
 , compute
a member of MGS(f  g) and check whether it is the identity (empty)
substitution.
5
This particular unication algorithm is inecient, because the size of the output may be
exponential in the size of the input. It is possible to specify ecient unication algorithms in
this style, but in order to simplify the presentationwe use this more straightforward algorithm.
27
P ] f = g ) P
P ] f
1
! 
2
= 
1
! 
2
g
) P [ f
1
= 
1
; 
2
= 
2
g
P ] ft
1
= t
2
g ) ft
1
:= t
2
gP [ ft
1
= t
2
g
if t
1
; t
2
2 FTV(P ) and t
1
6= t
2
P ] ft = g ) F
if t 2 FTV() and  62 Tv
P ] ft = g ) ft := gP [ ft = g
if t 62 FTV(),  62 Tv,
and t 2 FTV(P )
Figure 5: A set of transformational rules for solving unication of simple types.
28
