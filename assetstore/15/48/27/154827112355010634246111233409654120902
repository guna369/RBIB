Journal of Computer and System Sciences 73 (2007) 1045–1059

www.elsevier.com/locate/jcss

A 1.75-approximation algorithm for unsigned translocation distance
Yun Cui a, Lusheng Wang b,∗, Daming Zhu a
a School of Computer Science and Technology, Shandong University, PR China b Department of Computer Science, City University of Hong Kong, Hong Kong
Received 20 August 2005; received in revised form 11 April 2006 Available online 14 March 2007

Abstract
The translocation operation is one of the popular operations for genome rearrangement. In this paper, we present a 1.75approximation algorithm for computing unsigned translocation distance which improves upon the best known 2-approximation algorithm [J. Kececioglu, R. Ravi, Of mice and men: Algorithms for evolutionary distances between genomes with translocation, in: 6th ACM–SIAM Symposium on Discrete Algorithms, 1995, pp. 604–613]. © 2007 Elsevier Inc. All rights reserved.
Keywords: Unsigned translocation distance; Approximation algorithm
1. Introduction
Genome rearrangement is an important area in computational biology [6–10]. There are several basic operations, e.g., reversal, translocation, and transposition. Here we study the translocation operations. A chromosome X = x1, x2, . . . , xp is a sequence of genes, where each gene xi is represented by an integer. A gene xi has a direction. When the direction of every gene is known, we use a signed integer to indicate the direction. When the directions of genes are unknown, we use unsigned integers to represent the genes. Throughout this paper, each xi in a signed chromosome is a signed integer, and each xi in an unsigned chromosome is an unsigned integer. A signed genome is a set of signed chromosomes and an unsigned genome is a set of unsigned chromosomes.
For two unsigned chromosomes X = x1, x2, . . . , xm and Y = y1, y2, . . . , yn in a genome, a translocation swaps the segments in the chromosomes and generates two new chromosomes. A preﬁx–preﬁx translocation ρpp(X, Y, i, j ) generates two new chromosomes: x1, . . . , xi−1, yj , . . . , yn and y1, . . . , yj−1, xi, . . . , xm. A preﬁx–sufﬁx translocation ρps(X, Y, i, j ) generates two new chromosomes: x1, . . . , xi−1, yj−1, . . . , y1 and xm, . . . , xi , yj , . . . , yn.
For two signed chromosomes X = x1, x2, . . . , xm and Y = y1, y2, . . . , yn in a genome, a preﬁx–preﬁx translocation ρpp(X, Y, i, j ) generates two new chromosomes: x1, . . . , xi−1, yj , . . . , yn and y1, . . . , yj−1, xi, . . . , xm. A preﬁx–sufﬁx translocation ρps(X, Y, i, j ) generates two new chromosomes: x1, . . . , xi−1, −yj−1, . . . , −y1 and −xm, . . . , −xi, yj , . . . , yn.
* Corresponding author. E-mail addresses: yuncuiyc@hotmail.com (Y. Cui), cswangl@cityu.edu.hk (L. Wang), dmzhu@sdu.edu.cn (D. Zhu).
0022-0000/$ – see front matter © 2007 Elsevier Inc. All rights reserved. doi:10.1016/j.jcss.2007.03.009

1046

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

The translocation distance between two (signed/unsigned) genomes is the minimum number of translocations used to transform one genome into the other.
Hannenhalli designed the ﬁrst O(n3) algorithm [2] for computing translocation distance for signed genomes. The time complexity was improved to O(n2) in [3]. In [5], an error originated in [2] was ﬁxed. The problem of computing translocation distance for unsigned genomes was recently proved to be NP-hard [4]. Kececioglu and Ravi gave a ratio-2 approximation algorithm for the translocation distance for unsigned genomes [1].
In this paper, we present a ratio-1.75 approximation algorithm for computing the translocation distance of unsigned genomes which improves upon the best known 2-approximation algorithm [1]. Our algorithm uses the maximum match method to ﬁnd a cycle decomposition that contains enough number of 2-cycles (cycle containing exactly two black edges). By doing this, we give each unsigned gene a sign and the problem becomes the computation of translocation distance for signed genomes. Thus, we can use the algorithm in [3,5] for signed genomes to ﬁnally get an approximation solution.

2. Signed and unsigned translocation

The basic idea of our approximation algorithm for unsigned genomes is to carefully assign a sign to each gene in the genomes and use the algorithm for signed genomes to compute the translocation distance. The approximation ratio purely depends on the quality of the sign assignment of each gene.
First, let us introduce the computation method for signed genomes.

2.1. Signed translocation

Given signed genomes A and B, the breakpoint graph Gs(A, B) can be obtained as follows: for every chromosome X = x1, x2, . . . , xn of A, replace each xi with an ordered pair (l(xi), r(xi )) of vertices. If xi is positive, (l(xi), r(xi )) = (xit , xih); if xi is negative, (l(xi ), r(xi )) = (xih, xit ). The vertices r(xi ) and l(xi+1) are neighbors in A. The neighbors in B are deﬁned analogously. For two vertices u and v, if they are neighbors in A, then we use a black edge to connect them; if they are neighbors in B, then we use a grey edge to connect them.
Example 1. Let the two genomes be A = {(1, 2, 3), (4, −6, −5, 7)} and B = {(1, 2, 3), (4, 5, 6, 7)}. Both A and B contain two chromosomes. The breakpoint graph is shown in Fig. 1(a).

Every vertex in Gs(A, B) is incident with at most one black and one grey edge. Therefore, Gs(A, B) can be uniquely decomposed into cycles. A cycle containing exactly i black (grey) edges is called an i-cycle. A cycle is long if it is not a 1-cycle.
Let X = x1, x2, . . . , xp be a chromosome in A. A subpermutation (SP) is an interval xi, xi+1, . . . , xi+l in X containing at least three genes such that there is another interval of the same length yj , yj+1, . . . , yj+l in a chromosome Y of B satisfying {|xi |, |xi+1|, . . . , |xi+l|} = {|yj |, |yj+1|, . . . , |yj+l|}, xi = yj , xi+l = yj+l and xi , xi+1, . . . , xi+l−1, xi+l = yj , yj+1, . . . , yj+l−1, yj+l . Here xi and xi+l are the two ending genes of the SP. A minimal subpermutation (minSP) is a SP not containing any other SP. By the deﬁnition of SP, we have
Lemma 1. Let I = r(xi ), l(xi+1), r(xi+1), . . . , l(xj−1), r(xj−1), l(xj ) denote a SP in Gs(A, B), then the grey edge (r(xi), l(xj )) is not in Gs(A, B). Moreover, the two (ending) genes xi and xj cannot be neighbors in B.
The translocation distance for signed genomes is closely related to the number of cycles and the number of minSP’s. If all minSP’s in Gs(A, B) are in a SP, say, I , and the total number of minSP’s is even, then I is an even-isolation. Clearly there is at most one even-isolation in Gs(A, B).
Let n be the number of genes in the two genomes and N the number of chromosomes in the genomes. c denotes the total number of cycles in the breakpoint graph and s denotes the number of minSP’s. f is the remaining index which is deﬁned as follows: (1) f = 1 if s is odd; (2) f = 2 if there is an even-isolation; (3) f = 0 otherwise. Lemma 1 gives the formula to compute the translocation distance ds(A, B) for the two signed genomes A and B.

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

1047

Fig. 1. (a) The breakpoint graph for signed genome. (b) The breakpoint graph for unsigned genome.

Lemma 2. (See [2].) ds(A, B) = n − N − c + s + f.

(1)

2.2. Unsigned translocation

Consider unsigned genomes A and B. For every chromosome X = x1, x2, . . . , xn of A, xi and xi+1 are neighbors in A. The neighbors in B are deﬁned analogously. To deﬁne the breakpoint graph G(A, B), we use a vertex to represent a gene. Two vertices are connected with a black edge if they are neighbors in A and two vertices are connected with a grey edge if they are neighbors in B.

Example 2. Let the two genomes be A = {(1, 2, 3), (4, 6, 5, 7)} and B = {(1, 2, 3), (4, 5, 6, 7)}. Both A and B contain two chromosomes. The breakpoint graph is shown in Fig. 1(b).

Note that every vertex is incident either with one black and one grey edge, or with two black and two grey edges. Therefore, the cycle decompositions for G(A, B) are not unique. Once we have a cycle decomposition for the breakpoint graph of two unsigned genomes, we actually assign a sign to each gene in the genomes. Thus, one way to compute the translocation distance for two unsigned genomes is to (1) try all possible ways to get cycle decomposition (thus we can get a sign for each gene), and (2) compute the translocation distance for signed genomes and select the minimum value among all possible cycle decompositions.

3. The approximation algorithm

If we can give a good approximation of the cycle decomposition of the unsigned case, we can get a good approximation solution for the unsigned translocation distance. Our main idea of the approximation algorithm is to give a cycle decomposition of G(A, B) that contains the maximum number of 1-cycles and a sufﬁcient number of 2-cycles.

3.1. Why the ratio could be better than 2?

Now, we give an intuitive explanation that if we keep the maximum number of 1-cycles and maximum number of
2-cycles in assigning signs to genes, then the best performance ratio we can expect is 1.5.
Suppose that we ignore the effect of s and f in formula (1). That is, we assume that s = 0 and f = 0 in the optimal cycle decomposition. Then ds(A, B) = n − N − c. Let ci∗ be the number of i-cycles in the optimal cycle decomposition. Then

ds (A, B) = n − N − c = n − N − c1∗ − c2∗ − ci∗.
i3

(2)

n − N is the number of black edges in the breakpoint graph. We further assume that c1∗ = 0, c2∗ = 0 and all black

edges

are

in

3-cycles

in

the

optimal

cycle

decomposition.

In

this

case,

ds(A, B)

=

n−N

−

n−N 3

=

2 3

(n

−

N ).

If

in the approximation solution, we do not care about i-cycles for i 3, the distance for the approximation solution

could

be

n−

N.

Thus,

the

ratio

becomes

3 2

.

In

our

approximation

algorithm,

we

cannot

get

the

maximum

number

of

2-cycles, but we get a large number of 2-cycles. Besides, we have to design sophisticated ways to deal with the other

two parameters s and f in the analysis.

1048

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

3.2. The cycle decomposition algorithm

Given unsigned genomes A and B, a cycle decomposition of G(A, B) can be computed in the following three steps.

Step 1. Decomposition of 1-cycles.

If two vertices are joined by a black edge and a grey edge in G(A, B), then assign proper signs to the two vertices to obtain the 1-cycle containing the black edge and the grey edge. Thus, if two genes are neighbors in both genomes, the corresponding 1-cycle is kept in the cycle decomposition.

Step 2. Decomposition of 2-cycles.

From G(A, B), we deﬁne a new graph, called match graph, FAB as follows: (1) For every black edge in G(A, B)

with at least one end not assigned a sign in Step 1, we create a vertex of FAB . (2) For every two vertices of FAB (rep-

resenting two black edges in G(A, B)), we create an edge connecting them in FAB if the two black edges in G(A, B)

can form a 2-cycle. FAB can be constructed in O(n2) time where n is the number of genes.

Let M denote a maximum match of FAB . |M| is the size of the match. A maximum match of any graph can be

found

in

O

(|V

||E

|

1 2

)

time,

where

|V |

is

the

number

of

vertices

and

|E|

is

the

number

of

edges

[11].

Since

FAB

3
contains at most n vertices and O(n) edges, M can be found in O(n 2 ) time. Every edge in M represents a 2-cycle

of G(A, B). By the construction, two 2-cycles in M cannot share any black edge of G(A, B). However, they may

share a grey edge in G(A, B). In that case, the two 2-cycles cannot be kept in the cycle decomposition simultaneously.

A 2-cycle in M is isolated if it does not share any grey edge with any other 2-cycles in M. Otherwise, the 2-cycle is

related. Since a 2-cycle has two grey edges, it is related to at most two 2-cycles.

A related component U consists of related cycles C1, C2, . . . , Ck, where Ci is related to Ci−1 (2 i k), and

every 2-cycle in U is not related to any 2-cycle not in U . A related component involves at most two chromosomes,

and can be one of the four types shown in Fig. 2. In our cycle decomposition, we keep all the isolated 2-cycles and

alternatively select 2-cycles from every related component. Assume that a maximum match M of FAB contains z

isolated 2-cycles. In our cycle decomposition approach, we can keep at least

|M |−z 2

+ z, i.e.,

|M |+z 2

2-cycles in

Step 2.

Step 3. Decomposition of other long cycles.

After the decomposition of 2-cycles, the other long cycles can be arbitrarily selected from the remaining graph. The long cycles created in Step 2 are called selected cycles and the cycles created in Step 3 are called arbitrary cycles. Our approximation algorithm for unsigned translocation problem is as follows:

Fig. 2. The four cases of related components. Each of the related components in (a) and (b) is in one chromosome. Each of the related components in (c) and (d) is in two chromosomes.

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

1049

Algorithm 1:
Input: G(A, B) 1. Compute the cycle decomposition of G(A, B) as described before. Denote the resulting graph as GAs (A, B). 2. Solve the signed case using the standard algorithm.

Let n be the number of genes in the given genomes. G(A, B) and FAB can be constructed in O(n2) time. A max-

imum

match

of

FAB

can

be

found

in

3
O(n 2 )

time.

The

algorithm

in

[3]

requires

O (n2 )

time

to

compute

an

optimal

sequence of translocations for signed case. Thus, the total time required for our approximation algorithm is O(n2).

A minSP I = r(xi ), l(xi+1), r(xi+1), . . . , l(xj−1), r(xj−1), l(xj ) contains a cycle C if all vertices of C are in

{r(xi ), l(xi+1), r(xi+1), . . . , l(xj−1), r(xj−1), l(xj )}. A cycle C is outside I if no vertex of C is in {r(xi ), l(xi+1),

r(xi+1), . . . , l(xj−1), r(xj−1), l(xj )}.

Lemma 3. If a minSP contains a selected related 2-cycle in GAs (A, B), then this minSP contains at least one arbitrary cycle.

Proof. Suppose a minSP I contains a selected related 2-cycle C in a related component U of GAs (A, B), and U contains 2-cycles Cl, Cl+1, . . . , Cr , where Ci is related to Ci+1, l i r − 1. C can only be in a related component U of type (a) or (b) in Fig. 2. Assume that Cl contains the leftmost vertex of U .
(1) U is of type (a). If C = Ci , l i r − 1, then each black edge of Ci+1 is in an arbitrary cycle of I . If C = Cr , then each black edge of Cr−1 belongs to an arbitrary cycle. Since there is a grey edge connecting the leftmost and rightmost vertices of Cr , by Lemma 1, at least one black edge e of Cr−1 (that is in an arbitrary cycle) is in I . Since I is a minSP, by the deﬁnition of SP, I contains the whole cycle that e is in.
(2) U is of type (b). If C = Ci , l i r − 1, then the black edge of Ci+1 between the two black edges of Ci is in an arbitrary cycle of I . If C = Cr , then the black edge of Cr−1 which is between the two black edges of Cr (see Fig. 2(b)) is in an arbitrary cycle of I . 2

4. Analysis of the performance ratio

In this section, we will show that the performance ratio of the algorithm is 1.75. We use several new bounds in our analysis.
Suppose that each of the given genomes has n genes and N chromosomes. Let d(A, B) denote the (optimal) translocation distance between two unsigned genomes A and B, and Gospt(A, B) the breakpoint graph of an optimal cycle decomposition.

4.1. 1-Cycles

In this subsection, we will show that Step 1 in the cycle decomposition algorithm always leads to a good approximation solution.
Lemma 4. We modify Gospt(A, B) as follows: if two vertices in G(A, B) are connected by a black edge and a grey edge in G(A, B), then we re-assign the signs of the two genes to obtain a 1-cycle. Assume that the resulting breakpoint graph has c cycles and s minSP’s. We have d(A, B) n − N − c + s + f o, where f o is the remaining index for Gospt(A, B).
Proof. Suppose that Gospt(A, B) includes c cycles and s minSP’s. By Lemma 2, d(A, B) = n − N − c + s + f o. Consider two vertices xi and xi+1 that are neighbors in both genomes. Suppose that there are c(i) cycles and s(i) minSP’s in the breakpoint graph before xi and xi+1 are processed, and there are c (i) cycles and s (i) minSP’s after xi and xi+1 are processed. We want to show that c − s − c + s 0. It sufﬁces to show that c (i) − s (i) − c(i) + s(i) 0 for each i. To form the 1-cycle, we have the following two cases.

1050

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

Fig. 3. The cases for one cycle decomposition.
(1) The sign of one of xi and xi+1 is changed.
Without loss of generality, assume that the sign of xi is changed. In Fig. 3, (a1) and (a2) show the situations before and after changing the sign of xi . After changing the sign of xi , the black edges (r(xi−1), l(xi)) and (r(xi ), l(xi+1)) are in two different cycles. Thus, we have c (i) = c(i) + 1. Moreover, the number of minSP’s is not increased. Thus, we have s (i) s(i). Therefore, the lemma holds.
(2) The signs of both xi and xi+1 are changed.
Since we have to change the signs of both xi and xi+1 to get the 1-cycle, the grey edge (l(xi), r(xi+1)) must exist before changing the signs. Thus, the two black edges (r(xi−1), l(xi)) and (r(xi+1), l(xi+2)) are in one cycle before changing the signs. Three subcases arise. See Fig. 3(b1), (c1) and (d1). The situations after changing the signs are illustrated in Fig. 3(b2), (c2) and (d2), respectively.
In Fig. 3(b2), the number of cycles are increased by 2, i.e., c (i) = c(i) + 2. The number of minSP’s will be increased by at most 2 (in fact, at most 1), i.e., s (i) s(i) + 2. For the cases illustrated in Fig. 3(c2) and (d2), we have s (i) = s(i). Obviously, c (i) c(i). Thus, the lemma holds for this case. 2
4.2. A lower bound
In this subsection, we give a lower bound for d(A, B). This lower bound will be used as the starting point of our analysis.
Note that every minSP contains at least one long cycle. A simple minSP (S-MSP) is a minSP containing one 2-cycle as its unique long cycle. By deﬁnition, a simple minSP is a segment of genes in a chromosome containing 1-cycle(s) in the middle of the segment and a 2-cycle containing the two black edges at the two ends of the segments. The two grey edges in the 2-cycle must be “twisted” since by Lemma 1 (r(xi), l(xj )) cannot be a grey edge for the two ending genes xi and xj . The whole analysis of the approximation algorithm depends heavily on the special treatment of simple minSP’s.
Given unsigned genomes A and B, a candidate simple minSP (CS-MSP for short) is deﬁned as an interval Ic = xi, xi+1, . . . , xi+l−1, xi+l containing at least four genes in a chromosome of A such that there is another interval of the same length yj , yj+1, . . . , yj+l in a chromosome Y of B satisfying xi = yj , xi+l = yj+l and xi+k = yj+l−k (1 k l − 1). Any CS-MSP can be turned into a S-MSP by assigning proper signs to all genes in it. For convenience, we also call the unique 2-cycle in the S-MSP, the unique 2-cycle in the CS-MSP.
Given signed genomes A and B, let Is = xi, xi+1, . . . , xj−1, xj be a S-MSP in Gs(A, B). A cycle C = r(xi−1), l(xi), . . . , l(xj+1), r(xj ), . . . , r(xi−1) in Gs(A, B) containing the two black edges (r(xi−1), l(xi)) and (r(xj ), l(xj+1)) on the left and right of Is is a removable cycle. (See Fig. 4(a).) If there is a removable cycle C for Is , then Is is a removable simple minSP (RS-MSP for short).
Lemma 5. Given a RS-MSP Is = xi, xi+1, . . . , xj−1, xj , if we change the signs of xi and xj , then we have
(a) I1 = −xi, xi+1, . . . , xj−1, −xj is no longer a minSP;

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

1051

Fig. 4. The breakpoint graphs before and after a RS-MSP is destroyed.
(b) the number of cycles in the new breakpoint graph remains the same and the number of minSP’s is not increased. (c) Each of the black edges (r(xi ), l(xi+1)) and (r(xj−1), l(xj )) is in a long cycle containing a black edge that is
either (r(xi−1), l(xi )) or (r(xj ), l(xj+1)).
Proof. Since Is is a RS-MSP, it has a 2-cycle C = r(xi), l(xi+1), l(xj ), r(xj−1), r(xi) in Gs(A, B) (see Fig. 4(a)). Changing the signs of xi and xj destroys C (the removable cycle) and C and creates two new cycles C1 = r(xi−1), l(xi), r(xj−1), l(xj ), . . . , r(xi−1) and C2 = r(xi ), l(xi+1), r(xj ), l(xj+1), . . . , r(xi ) (see Fig. 4(b)). Thus, (c) holds. Moreover, the number of cycles remains the same. Since I1 = −xi , xi+1, . . . , xj−1, −xj is no longer a minSP and the segment I1 contains no minSP, the only possible new minSP created might be an old SP containing the segment I1. (In this case, the old SP becomes a new minSP.) Thus, the number of minSP’s is not increased. 2
The lower bound of d(A, B) we are going to develop is based on the modiﬁcation of CS-MSP’s in an optimal cycle decomposition Gospt(A, B).
Modifying an optimal cycle decomposition Gospt(A, B) Let Ic be a CS-MSP and l(Ic) and r(Ic) denote the leftmost and rightmost genes of Ic. The modiﬁcation method is
as follows:
ModiﬁcationMethod: Input: Gospt(A, B) 1. For every chromosome X of A. 2. Obtain possible 1-cycles as described in Step 1 of cycle decomposition. 3. For every chromosome X of A. 4. Process each CS-MSP Ic in X from left to right: 5. Assign proper signs to l(Ic) and r(Ic) to turn Ic into a S-MSP Is . 6. If Is is a RS-MSP, then remove it by changing the signs of both l(Is) and r(Is).
Theorem 1. c∗ and s∗ denote the number of cycles and number of minSP’s in the new breakpoint graph after ModiﬁcationMethod. We have d(A, B) n − N − c∗ + s∗ + f o, where f o is the remaining index for Gospt(A, B).
Proof. Suppose that the breakpoint graph includes c cycles and s minSP’s after Steps 1 and 2 of ModiﬁcationMethod. By Lemma 4, d(A, B) n − N − c + s + f o. Consider a CS-MSP Ic = xi, xi+1, . . . , xj−1, xj . Let Is be the S-MSP obtained by assigning signs for genes in Ic properly. Suppose that there are c (i) cycles and s (i) minSP’s in the breakpoint graph before the ith CS-MSP is processed, and there are c∗(i) cycles and s∗(i) minSP’s after that. We want to show that c∗ − s∗ − c + s 0. It sufﬁces to show that c∗(i) − s∗(i) − c (i) + s (i) 0 for each i.
(1) If obtaining Is requires no change of signs for xi and xj , then c∗(i) − s∗(i) − c (i) + s (i) = 0. (2) Consider the case where Is is obtained by changing the sign of one of xi and xj . Without loss of generality, we change the sign of xi (see Fig. 5(b)). Before the change of sign, the conﬁguration is shown as Fig. 5(a). The three black edges (r(xi ), l(xi+1)), (r(xj−1), l(xj )) and (r(xi−1), l(xi)) must be in the same cycle. After the change of the sign, (r(xi), l(xi+1)) and (r(xj−1), l(xj )) are in a 2-cycle, whereas (r(xi−1), l(xi)) is in another cycle. So, c∗(i) = c (i) + 1. If a new minSP Il = xl, xl+1, . . . , xi−1, xi is created on the left of Is , then xl, xl+1, . . . , xi−1, xi , xi+1, . . . , xj−1, xj is a SP. Moreover, this SP exists as a minSP just before the sign of xi is changed. Thus, s∗(i) s (i) + 1. Therefore, c∗(i) − s∗(i) c (i) − s (i).

1052

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

Fig. 5. Some cases of a CS-MSP in a breakpoint graph.

(3) If Is is obtained by changing the signs of both xi and xj , then there are three cases. Case 1. Is is a RS-MSP. In this case, Is is shown as in Fig. 4(a). Figure 4(b) shows the case before the change of signs. After the elimination of the RS-MSP, the case is back to the origin and thus c∗(i) − s∗(i) − c (i) + s (i) = 0.
Case 2. After changing the signs, Is is not a RS-MSP, the black edges (r(xi−1), l(xi)) and (r(xj ), l(xj+1)) are in two different cycles, and the black edges (r(xi), l(xi+1)) and (r(xj−1), l(xj )) are in one 2-cycle. See Fig. 5(d). Before the change of signs, these three cycles were in one cycle as shown in Fig. 5(c). Thus, c∗(i) = c (i) + 2.
When Is is obtained as in Fig. 5(d), it creates at most other two new minSP’s Il = xl, xl+1, . . . , xi−1, xi and Ir = xj , xj+1, . . . , xr−1, xr that are on the left and right of Is , respectively. If both Il and Ir are new minSP’s, then Il , Is and Ir are three consecutive minSP’s. Thus, xl, xl+1, . . . , xi, . . . , xj , . . . , xr−1, xr was a SP before changing the signs. Obviously, this SP was a minSP since it is a merging of the three minSP’s Il, Is and Ir (by changing the signs of xi and xj ). Thus, s∗(i) s (i) + 2. Therefore, c∗(i) − s∗(i) c (i) − s (i).
Case 3. Is is not a RS-MSP, and the black edges (r(xi−1), l(xi)) and (r(xj ), l(xj+1)) are in one cycle after changing the signs. See Fig. 5(f). Since Is is a S-MSP, the black edges (r(xi), l(xi+1)) and (r(xj−1), l(xj )) are in one 2-cycle. Before changing the signs, these two cycles formed one cycle as shown in Fig. 5(e). c∗(i) = c (i) + 1.
When Is is obtained, since the black edges (r(xi−1), l(xi)) on the left of Is and (r(xj ), l(xj+1)) on the right of Is are in one cycle, no new minSP is created (except Is ). Thus, s∗(i) s(i) + 1. Therefore, c∗(i) − s∗(i) − c (i) + s (i) 0. 2

4.3. A key inequality

of

Given unsigned genomes A and B, let i-cycles and se∗ the number of S-MSP’s

sc in

denote the number of CS-MSP’s in G(A, B). Let ci∗ denote the the new breakpoint graph after applying ModiﬁcationMethod.

number

If two CS-MSP’s share one gene in a chromosome, then they are adjacent. A CS-MSP chain consists of a sequence

of adjacent CS-MSP’s I1, . . . , Ii, Ii+1, . . . , In, where Ii and Ii+1 are adjacent for 1 i n − 1. If a CS-MSP chain is

not contained in any other CS-MSP chain, then it is a maximum CS-MSP chain.

Lemma 6. For any maximum CS-MSP chain in G(A, B), either all CS-MSP’s in the chain are turned into S-MSP’s, or none of them is turned into a S-MSP after the ModiﬁcationMethod in Section 4.2.

Proof. Assume a maximum CS-MSP chain in G(A, B) consists of CS-MSP’s I1, I2, . . . , Ik, where Ii and Ii+1 are adjacent for 1 i k − 1. There are two cases when applying ModiﬁcationMethod.

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

1053

Fig. 6. Remove RS-MSP’s on a maximum CS-MSP chain.
(1) I1 is turned into a S-MSP, but not a RS-MSP. Consider I2 = xi, xi+1, . . . , xj−1, xj . When applying ModiﬁcationMethod, the black edge (r(xi−1), l(xi)) is in the S-MSP derived from I1. Since (r(xi−1), l(xi)) and (r(xj ), l(xj+1)) cannot be in one cycle, I2 is turned into a S-MSP, but not a RS-MSP. The process goes on and all the Ik’s for k 2 are turned into S-MSP’s, but not RS-MSP’s.
(2) I1 = xl, xl+1, . . . , xi−1, xi is turned into a RS-MSP. See Fig. 6(a). When I1 is removed, the black edges (r(xl−1), l(xl)) and (r(xi−1), l(xi )) are in one cycle C1, while the black edges (r(xl), l(xl+1)) and (r(xi ), l(xi+1)) are in another cycle C2. Assume I2 = xi , xi+1, . . . , xj−1, xj . Since grey edge (l(xi), r(xj−1)) exists, C1 contains black edge (r(xj−1), l(xj )). Thus, C2 contains grey edge (l(xi+1), r(xj )) but not (l(xi+1), l(xj )). Therefore, the black edge (r(xj ), l(xj+1)) is in C2. See Fig. 6(b). When the signs of xi and xj are changed, a new cycle r(xi−1), l(xi), . . . , l(xj+1), r(xj ), . . . , r(xi−1) is created. This implies that I2 is turned into a RS-MSP. After the elimination of the RS-MSP, I2 is changed back as shown in Fig. 6(b). The process goes on and we can conclude that every Ip for p = 1, 2, . . . , k is turned into a RS-MSP in this case. 2
Theorem 2. i 2(i − 1)ci∗ 2(sc − se∗).
Proof. If a CS-MSP Ic is not turned into a S-MSP after applying ModiﬁcationMethod, then Ic is turned into a RSMSP and removed in Step 6 of ModiﬁcationMethod. First, we want to show that every black edge in the unique 2-cycle of the CS-MSP is in a long cycle (after ModiﬁcationMethod) containing at least one black edge that is not in any CS-MSP. There are two cases:
(1) Ic = xi, xi+1, . . . , xj−1, xj is not in a maximum CS-MSP chain. By Lemma 5, when Is is removed, the black edges (r(xi), l(xi+1)) and (r(xj−1), l(xj )) belong to two different long cycles and each of the long cycles has a black edge that is not in a CS-MSP.
(2) Ic is in a maximum CS-MSP chain. In this case, after applying ModiﬁcationMethod, all the vertices of CSMSP’s are in two long cycles, one containing the black edge (r(xl−1), l(xl)) on the left of the chain and the other containing the black edge (r(xr ), l(xr+1)) on the right of the chain (see Fig. 6(b)). Note that neither (r(xl−1), l(xl)) nor (r(xr ), l(xr+1)) is in any CS-MSP.
The total number of CS-MSP’s that are not turned into S-MSP’s after applying ModiﬁcationMethod is (sc − se∗). There are 2(sc − se∗) black edges in the unique 2-cycles of those CS-MSP’s. Since every such black edge after modiﬁcation is in a long cycle containing at least one black edge that is not in any CS-MSP, and the total number of black edges contained in those long cycles is at most i 2 ici∗, we have i 2(i − 1)ci∗ 2(sc − se∗). 2
For unsigned genomes A and B, let G∗s (A, B) be the breakpoint graph produced by running ModiﬁcationMethod on Gospt(A, B). GAs (A, B) is the breakpoint graph produced by Algorithm 1. f denotes the remaining index for GAs (A, B). We use dA(A, B) to represent the translocation distance obtained by Algorithm 1. Let d(A, B) be the (optimal) translocation distance between the two unsigned genomes. Now, we are ready to show the performance ratio.

1054

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

4.4. The performance ratio when f = 0

Assume that GAs (A, B) contains z isolated 2-cycles. Let z(o) denote the number of isolated 2-cycles outside all minSP’s. Consider the minSP’s containing only isolated 2-cycles and 1-cycles. Let s(s) denote the number of (simple) minSP’s containing only one isolated 2-cycle. s(m) denotes the number of minSP’s containing at least two isolated 2-cycles without any selected related 2-cycle or arbitrary 2-cycle. Let ci(o) be the number of arbitrary i-cycles (i 2) outside all minSP’s in GAs (A, B).

Theorem 3. If f = 0, then dA(A, B)

7 4

d

(A,

B

).

That

is,

the

performance

ratio

of

Algorithm

1

is

1.75

if

f

=

0.

Proof. By deﬁnition, 2s(m) + s(s) z − z(o). Thus, we have

s (m)

z − z(o) − s(s) .

2

(3)

SthuepnpuomsebtehraotfGi-Asc(yAcl,eBs i)nhGas∗s

s minSP’s. (A, B). By

ci (i 1) denotes the number of i-cycles in GAs (A, B). Similarly, ci∗ denotes Lemma 3, a minSP contains (at least) an isolated 2-cycle or an arbitrary cycle.

Thus, there are s − s(m) − s(s) minSP’s, each containing at least one arbitrary cycle. Since there are at least

|M |+z 2

selected 2-cycles created in Step 2 of the cycle decomposition algorithm, the number of arbitrary cycles in minSP’s is

less than or equal to

i

2

ci

−

(

|M 2

|

+

z 2

)

−

i 2 ci(o). We have

s − s(m) − s(s)

ci −

|M| + z 22

−

ci(o).

i2 i2

(4)

Combining (3) and (4), we have

s

ci −

ci(o)

−

|M | 2

−

z(o) 2

+

s (s ) .
2

i2 i2

(5)

By Lemma 2,

dA(A, B) = n − N − c1 − c2 − ci + s + f.
i3

(6)

From Theorem 1, we have

d(A, B) n − N − c1∗ − c2∗ − ci∗ + s∗ + f o.
i3

(7)

cLdoeenﬁt tnaΔiitni=osna74todmf (GoAs∗s,t(B|AM),|−B2)-dcaAync(dAleS,s,tBelpe)t.1cS2∗oinf=cteh|MeGc|∗sy−(cAlαe,

B) and GAs (A, B) contain all possible decomposition algorithm.) Since a cycle
(α 0). From (7) and (6), we have

1-cycles, c1 = decomposition

c1∗. of

(See G(A,

the B)

Δ

=

7 d (A,

B)

−

dA(A, B)

4

7 4

n − N − c1∗ − c2∗ −

ci∗ + s∗ + f o − n − N − c1 −

ci + s + f

i3 i2

=3 4

n − N − c1∗

−

5 4

c2∗

−

|M| − 2

α

−

7 4

ci∗

+

7s∗ 4

+

7 f
4

o

+

ci − s − f.

i3 i2

(8)

From (8) and (5), we have

Δ

1 4

n − N − c1∗ − c2∗ −

ci∗

+1 2

n − N − c1∗ − 2c2∗ − 3

ci∗

− |M| − α 2

i3 i3

+ 7s∗ + 7f o + 44

ci(o)

+

|M | 2

+

z(o) 2

−

s (s ) 2

−

f.

i2

(9)

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

1055

Since there are n − N black edges in G∗s (A, B) and each black edge is in a cycle, we have n − N = i 1 ici∗. That is,

n − N − c1∗ − c2∗ − ci∗ = (i − 1)ci∗.
i3 i2

(10)

From (9) and (10), we can immediately obtain

1 Δ
4

(i − 1)ci∗ + 2s∗ − 2s(s)

+1 2

(i

−

3)ci∗

+

5s∗ 4

+

α 2

+

7 f
4

o

+

ci(o)

+

z(o) 2

−

f.

i2 i4

i2

(11)

From Theorem 2, i 2(i − 1)ci∗ 2(sc − se∗). Moreover, by deﬁnitions, sc s(s) and s∗ se∗. Thus, we have

(i − 1)ci∗ + 2s∗ − 2s(s) 0.
i2

(12)

From (12), (11) becomes

1 Δ
2

(i

−

3)ci∗

+

5s∗ 4

+

α 2

+

7 f
4

o

+

ci(o)

+

z(o) 2

− f.

i4 i2

(13)

From the fact that all variables in (13) are non-negative, we can immediately conclude that Δ 0 when f = 0. 2

4.5. The performance ratio when f = 1 or 2

From formula (13), we have Δ 0 when s∗ 2. To ensure the 1.75 performance ratio for f = 1 or 2, we focus on the cases where s∗ = 0 or s∗ = 1.
A spanning edge is a grey edge whose vertices are on two chromosomes.

Lemma 7. If G∗s (A, B) has no minSP (s∗ = 0) and GAs (A, B) has at least one minSP, then G(A, B) has at least two spanning edges.

Proof. If G(A, B) does not have any spanning edge, then G∗s (A, B) has at least one minSP assuming A and B are not identical. This contradicts the assumption that G∗s (A, B) has no minSP. Thus, there is at least one spanning edge in G(A, B). Since every spanning edge must be in a cycle for any cycle decomposition, there are in fact at least two
spanning edges. 2

Lemma 8. If there are spanning edges and at least one minSP in GAs (A, B), then GAs (A, B) has at least one arbitrary cycle outside all SP’s or at least one isolated 2-cycle outside all SP’s.

Proof. Consider the cycle C containing the spanning edges in GAs (A, B). C can be an arbitrary cycle, a selected related 2-cycle or an isolated 2-cycle. Since C contains spanning edges, C must be outside all SP’s.
If C is a selected related 2-cycle, then it must be in a related component U of type (c) or (d) as in Fig. 2. Assume C shares a grey edge with a related 2-cycle C in U , then by the cycle decomposition algorithm, the two black edges of C are in arbitrary cycle(s). Consider the two black edges in C . Since the two ends of each of the black edges are incident to spanning edges (see Fig. 2(c) and (d)), the corresponding genes are neighbors with genes in the other chromosome. By the deﬁnition of SP, the black edges of C cannot be in a SP in GAs (A, B). This implies that at least one arbitrary cycle is outside all SP’s in GAs (A, B). 2
Lemma 9. Consider the case that G∗s (A, B) has no minSP (s∗ = 0) and GAs (A, B) has at least one minSP (s 1). If there is a unique long cycle as a 2-cycle C outside all minSP’s in GAs (A, B), then G∗s (A, B) has at least one i-cycle for i 4.

Proof. By Lemma 7, there are at least two spanning edges in both G∗s (A, B) and GAs (A, B). By the assumption, C contains the only two spanning edges in GAs (A, B). Since G∗s (A, B) has no minSP, C does not exist in G∗s (A, B).

1056

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

Fig. 7. (a) Only one long cycle as a 2-cycle is outside all minSP’s in GAs (A, B). (b) G∗s (A, B), where the sign at least two grey edges in a path connecting l(xi ) and l(xi+1), since xi and xi+1 are not neighbors in B. (c)

of xi is G∗s (A,

changed such that there are B), where the sign of xi is

changed such that there are at least two grey edges in a path connecting r(xi−1) and l(xi+2).

Assume C contains the black edge (r(xi), l(xi+1)) in chromosome 1 (see Fig. 7(a)) and the sign of xi is changed in G∗s (A, B).
In G∗s (A, B), there is a cycle C containing the vertex l(xi) and the only two spanning edges. (See Fig. 7(b) and (c). Since there are only two spanning edge in the graph, they must be in the same cycle.) There are two cases.
Case 1. The vertex l(xi+1) is in cycle C . (See Fig. 7(b).) The cycle decomposition algorithm ensures that there is no grey edge connects xi and xi−1 in G(A, B). (All possible 1-cycles are kept in both G∗s (A, B) and GAs (A, B).) Thus, in cycle C , there are at least another two grey edges (other than the two spanning edges) in the cycle C connecting the two vertices r(xi−1) and r(xi) (on chromosome 1). Therefore, there are at least four grey edges in cycle C .
Case 2. The vertex r(xi+1) is in cycle C . (See Fig. 7(c).) In this case, the grey edge (r(xi−1), l(xi+2)) does not exist in G∗s (A, B). (Otherwise, there is a long cycle C containing a grey edge (f (xi−1), f (xi+2)), where f (xi−1) ∈ {l(xi−1), r(xi−1)} and f (xi+2) ∈ {l(xi+2), r(xi+2)}, in GAs (A, B). Since the 2-cycle C containing r(xi ) and l(xi+1) is outside all minSP’s and the grey edge (f (xi−1), f (xi+2)) has one end on the left of r(xi) and one end on the right of l(xi+1), the long cycle C is also outside all minSP’s. This contradicts the assumption that C is the only long cycle outside all minSP’s in GAs (A, B).) Thus, there are at least another two grey edges (other than the two spanning edges) in the cycle C connecting the two vertices r(xi−1) and l(xi+2) (on chromosome 1). Therefore, there are at least four grey edges in cycle C . 2
Lemma 10. Suppose G∗s (A, B) has no minSP and GAs (A, B) has an even-isolation I . If I contains a long cycle C outside all minSP’s, then I contains at least one arbitrary or isolated cycle outside all minSP’s.

Proof. C can be an arbitrary cycle, an isolated 2-cycle, or a selected related 2-cycle. For the ﬁrst two cases, the lemma holds immediately. If C is a selected related 2-cycle, C is in a related component U of type (a) or (b) (see Fig. 2). Assume C shares a grey edge e with a related cycle C in U , then the two black edges of C are in one or two arbitrary cycle(s).
(1). U is of type (a). If C is outside C, then the arbitrary cycle(s) containing one or two of the black edges of C cannot be in any minSP (due to the two grey edges of C ). By Lemma 1, at least one of the black edges of C is in I (the two ends of e cannot be the two ending genes of the SP I ).
Consider the case where C is inside C. There are possibly minSP’s inside C. Let e be the other grey edge of C . The two genes xi and xj at the ends of edge e are neighbors in B. By Lemma 1, xi and xj cannot be the two ending genes in the same minSP inside C at the same time. Now, we want to show that at least one of the black edge (r(xi ), l(xi+1)) or (r(xj−1), l(xj )) is not in any minSP.
Without loss of generality, assume that r(xi) (or equivalently edge (r(xi ), l(xi+1))) is in a minSP I1 (xi as an ending gene) inside C. In this case, l(xj−1) will be the other end of I1 since the existence of the black edge (r(xi), l(xi+1)) and the grey edge e = (xi+1, xj−1). If this is true, the black edge (r(xj−1), l(xj )) cannot be in another minSP. (A minSP

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

1057

contains at least two black edges. The vertex r(xj−1) is not in I1. Since C is outside all minSP’s, the vertex r(xj ) is also outside all minSP’s.) Thus, the arbitrary cycle containing the black edge (r(xj−1), l(xj )) is not in any minSP.
(2) U is of type (b). Let e be the other grey edge of C . Since e and e are crossing with each other, the arbitrary
cycle containing black edge(s) of C cannot be in any minSP. (Otherwise, C is also in the same minSP.) 2

Lemma 11. Suppose GAs (A, B) has an even-isolation I and G∗s (A, B) has no minSP. Let s(s) denote the number of S-MSP’s in GAs (A, B) containing only one isolated 2-cycles and |M| − α the number of 2-cycles in G∗s (A, B).
(1) If any long cycle of I is in a minSP, then α s(s); (2) if a 2-cycle in I is outside all minSP’s and the rest of long cycles in I are in minSP’s, then α s(s) − 1.

Proof. Consider a S-MSP Is = r(xi ), l(xi+1), r(xi+1), . . . , l(xj−1), r(xj−1), l(xj ) in GAs (A, B). (See Fig. 4(a).) If any long cycle of I is in a minSP, then the grey edges (l(xi), l(xj+1)) and (r(xj ), r(xi−1)) do not exist in
GAs (A, B). (Otherwise, the minSP Is is inside the long cycle C containing the two black edges (r(xi−1), l(xi)) and (r(xj ), l(xj+1)) and one of the grey edges (l(xi), l(xj+1)) or (r(xj ), r(xi−1)) in I . (See Fig. 4(a).) Thus, C is not in
any minSP of I . This contradicts the assumption that any long cycle in I is in a minSP.) For the same reason, the grey edges (l(xi), r(xj+1)) and (r(xj ), l(xi−1)) do not exist in GAs (A, B). That is, the grey edges (xi , xj+1) and (xi−1, xj ) are not in G(A, B).
After removing the S-MSP Is in G∗s (A, B), the two new cycles are created, one containing the three edges (r(xi ), l(xi+1)), (l(xi+1), r(xj )), and (r(xj ), l(xj+1)) and the other containing the three edges (r(xi−1), l(xi)), (l(xi), r(xj−1)), and (r(xj−1), l(xj )) (see Fig. 4(b) and Fig. 6(b)) in G∗s (A, B) are not 2-cycles. Thus, we can conclude that for each S-MSP in I , G∗s (A, B) does not have any 2-cycle containing black edges (r(xi), l(xi+1)) or (r(xj−1), l(xj )) in the maximum match M. Note that, by the construction of M, M has a 2-cycle containing at least one of the black edges (r(xi ), l(xi+1)) and (r(xj−1), l(xj )). Moreover, |M|−α is the number of 2-cycles in G∗s (A, B). Thus, α = |M| − (|M| − α) s(s).
For the same reason, we can show that (2) if a 2-cycle in I is outside all minSP’s and the rest of long cycles in I are in minSP’s, then α s(s) − 1. 2

Let ci(oo) be the number of arbitrary i-cycles (i 2) outside all SP’s in GAs (A, B) and z(oo) be the number of isolated 2-cycles outside all SP’s in GAs (A, B).

Lemma 12. If GAs (A, B) contains some spanning edges and at least one minSP, then

1 2

(i − 3)ci∗ +

ci(oo)

+

z(oo) 2

i4 i2

1.

(14)

Proof. If GAs (A, B) contains some spanning edges, by Lemma 8, i 2 ci(oo) + z(oo) 1. If ci(oo) 1 or z(oo) 2, then the lemma holds immediately.
Now consider the case where ci(oo) = 0 and z(oo) = 1. That is, there is a unique long cycle as a 2-cycle outside all SP’s in GAs (A, B). By Lemma 9, i 4(i − 3)ci∗ 1. Thus we have (14) holds. 2

Theorem 4. dA(A, B)

7 4

d

(A,

B

).

Proof. We continue with the proof of Theorem 3. By formula (13), Δ 0 holds when f = 0 or (f = 1 and s∗ 1)

or (f = 2 and s∗ 2). Thus, we only have to consider the following cases.

Case 1. s∗ = 0 and f = 1. By Lemma 7, GAs (A, B) contains some spanning edges. By Lemma 12, (14) holds.

From (13) and (14), we know that Δ 0.

Case 2. s∗ = 1 and f = 2. If GAs (A, B) contains no spanning edge, then all chromosomes except the one with

the even isolation contain only 1-cycles. From ModiﬁcationMethod, G∗s (A, B) is derived from an optimal cycle

decomposition of G(A, B) with f 0

1. By formula (13), we have Δ

5 4

s∗

+

f

0

−

f

0. If GAs (A, B) contains

some spanning edges, by formulas (13) and (14), Δ 0 holds.

1058

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

Case 3. s∗ = 0 and f = 2. By Lemma 7, GAs (A, B) contains some spanning edges. Since there are at least two minSP’s in the even isolation I , there are at least two long cycles in minSP’s of I , at least one for each minSP. Besides,
there is at least one long cycle containing spanning edges outside I . Therefore, there are at least six black edges in long cycles of GAs (A, B), and they are also in long cycles of G∗s (A, B). Now, we want to show that

(i − 1)ci∗ 4.
i2

(15)

Assume that GAs (A, B) contains exactly six black edges in long cycles. Thus, there is a unique long cycle as a 2cycle outside I . By Lemma 9, there is at least one i-cycle (i 4) in G∗s (A, B). Thus, i 2(i − 1)ci∗ 3. Considering the other four black edges in long cycles, we have (15) holds.
If GAs (A, B) contains more than six black edges in long cycles, then G∗s (A, B) also contains more than six black
edges in long cycles.

(i − 1)ci∗ = i × ci∗ − ci∗,
i2 i2 i2

(16)

where i long cycles

2i in

×G∗sc(i∗Ais,

the B).

total number Let k 3 be

of black edges in long cycles in G∗s (A, B) an integer. If there are 2k + 1 black edges

and i in long

2 ci∗ is cycles,

the total then the

number number

of of

long cycles is at most k. In this case, we have

(i − 1)ci∗ = i × ci∗ − ci∗ 2k + 1 − k = k + 1 4.
i2 i2 i2

(17)

If there are 2k + 2 black edges in long cycles, then the number of long cycles is at most k + 1. In this case, we have

(i − 1)ci∗ = i × ci∗ − ci∗ 2k + 2 − (k + 1) = k + 1 4.
i2 i2 i2

(18)

Therefore, we can conclude that (15) holds. From (15), formula (11) can be transformed into

α − s(s) 1 Δ+
22

(i − 3)ci∗ +

ci(o)

+

z(o) 2

− 1.

i4 i2

(19)

Let I denote the even-isolation in GAs (A, B). There are three subcases: Case 3.1. All long cycles of I are in minSP’s. By Lemma 11, α s(s). By formulas (14) and (19), Δ 0.

Case 3.2. All the long cycles of I except one 2-cycle are in minSP’s. By Lemma 11, α s(s) − 1. By Lemma 10,

I contains at least one isolated cycle or at least one arbitrary cycle outside all minSP’s. Note that the above mentioned

isolated

cycle

or

arbitrary

cycle

is

inside

the

SP

I.

Therefore,

(14)

becomes

1 2

i 4(i − 3)ci∗ +

i

2

ci(o)

+

z(o) 2

3 2

.

By formula (19), Δ 0.

Case 3.3. In I , at least one i-cycle (i 3) or at least two 2-cycles of I are outside all minSPs. By Lemma 10,

I contains at least two isolated cycles or at least one arbitrary cycle outside all minSP’s. Again, the above mentions

cycles

are

inside

the

SP

I.

Thus,

(14)

becomes

1 2

i 4(i − 3)ci∗ +

i

2

ci(o)

+

z(o) 2

2. By formula (13), Δ

0. 2

Remarks. We have designed an 1.75-approximation algorithm for unsigned translocation distance. It is interesting to give an algorithm with better ratio since the gap between 1.75 and the lower bound 1.00017 [4] is still big.

Acknowledgments

Yun Cui and Lusheng Wang are fully supported by a grant from the Research Grants Council of the Hong Kong Special Administrative Region, China [Project No. CityU 1196/03E]. Daming Zhu is fully supported by NSFC 60573024.

References

[1] J. Kececioglu, R. Ravi, Of mice and men: Algorithms for evolutionary distances between genomes with translocation, in: 6th ACM–SIAM Symposium on Discrete Algorithms, 1995, pp. 604–613.

Y. Cui et al. / Journal of Computer and System Sciences 73 (2007) 1045–1059

1059

[2] Sridhar Hannenhalli, Polynomial-time algorithm for computing translocation distance between genomes, in: CPM ’95, 1995, pp. 162–176. [3] Lusheng Wang, Daming Zhu, Xiaowen Liu, Shaohan Ma, An O(n2) algorithm for signed translocation, J. Comput. System Sci. 70 (2005)
284–299. [4] Daming Zhu, Lusheng Wang, On the complexity of unsigned translocation distance, Theoret. Comput. Sci. 352 (2006) 322–328. [5] Anne Bergeron, Julia Mixtacki, Jens Stoye, On sorting by translocation, in: RECOMB ’05, 2005, pp. 615–629. [6] S. Hannenhalli, P.A. Pevzner, Transforming cabbage into turnip (polynomial algorithm for sorting signed permutations by reversals), in:
STOC ’95, 1995, pp. 178–189. [7] H. Kaplan, R. Shamir, R.E. Tarjan, Faster and simpler algorithm for sorting signed permutations by reversals, SIAM J. Comput. 29 (3) (2000)
880–892. [8] V. Bafna, P. Pevzner, Genome rearrangements and sorting by reversals, SIAM J. Comput. 25 (2) (1996) 272–289. [9] D. Sankoff, J.H. Nadeau (Eds.), Comparative Genomics: Empirical and Analytical Approaches to Gene Order Dynamics, Map Alignment and
the Evolution of Gene Families, Series in Computational Biology, vol. 1, Kluwer Academic Press, Dordrecht, NL, 2000, pp. 225–241. [10] D. Sankoff, N. El-Mabrouk, Genome rearrangement, in: T. Jiang, Y. Xu, Q. Zhang (Eds.), Current Topics in Computational Molecular Biology,
MIT Press, 1992, pp. 132–155. [11] L. Lovász, M.D. Plummer, Matching Theory, Annals of Discrete Mathematics, vol. 29, North-Holland, Amsterdam, 1986.

