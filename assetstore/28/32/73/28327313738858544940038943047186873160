Theoretical Improvements in Algorithmic Efficiency 
for Network Flow Problems 
JACK EDMONDS 
University of Waterloo, Waterloo, Ontario, Canada 
AND 
RICHARD M. KARP 
University of California, Berkeley, California 
ABSTRACT. This paper presents new algorithms for the maximum flow problem, the Hitchcock 
transportat ion problem, and the general minimum-cost flow problem. Upper bounds on the 
numbers of steps in these algorithms are derived, and are shown to compale favorably with 
upper bounds on the numbers of steps required by earlier algorithms. 
First, the paper states the maximum flow problem, gives the Ford-Fulkerson labeling method 
for its solution, and points out that  an improper choice of flow augmenting paths can lead to 
severe computat ional  difficulties. Then rules of choice that  avoid these difficulties are given. 
We show that ,  if each flow augmentation is made along an augmenting path having a minimum 
number of arcs, then a maximum flow in an n-node network will be obtained after no more than 
~(n a - n) augmentat ions;  and then we show that  if each flow change is chosen to produce a 
maximum increase in the flow value then, provided the capacities are integral, a maximum flow 
will be determined within at most 1 + logM/(M--1) if(t, S) augmentations, wheref*(t, s) is the 
value of the maximum flow and M is the maximum number of arcs across a cut. 
Next a new algorithm is given for the minimum-cost flow problem, in which all shortest-path 
computations are performed on networks with all weights nonnegative. In particular, this 
algorithm solves the n X n assigmnent problem in O(n 3) steps. Following that  we explore a 
"scal ing" technique for solving a minimum-cost flow problem by treat ing asequence of derived 
problems with "scaled down" capacities. It is shown that ,  using this technique, the solution of 
a I i i tchcock transportat ion problem with m sources and n sinks, m ~ n, and maximum flow B, 
requires at most (n + 2) log2 (B/n) flow augmentations. Similar results are also given for the 
general minimum-cost flow problem. 
An abstract stat ing the main results of the present paper was presented at the Calgary 
Internat ional  Conference on Combinatorial  Structures and Their Applications, June 1969. 
In a paper by l)inic (1970) a result closely related to the main result of Section 1.2 is obtained. 
Dinic shows that,  in a network with n nodes and p arcs, a maximum flow can be computed in 
0 (n2p) primitive operations by an algorithm which augments along shortest augmenting paths. 
KEY WOl¢l)S AND PHP~ASES: network flows, transportat ion problem, analysis of algorithms 
CR CATEGOI{.IES: 5.3, 5.4, 8.3 
Copyright © 1972, Association for Computing Machinery, Inc. 
General permission to republish, but not for profit, all or part of this material  is granted, 
provided that  reference is made to this publication, to its date of issue, and to the fact that 
reprint ing privileges were granted by permission of the Association for Computing Machinery. 
Authors' addresses : J. Edmonds, Department of Combinatorics and Optimization, University 
of Waterloo, Waterloo, Ontario, Canada; R. M. Karp, College of Engineering, Operations 
Research Center, University of California, Berkeley, CA 94720; the latter author's research as 
been partial ly supported by the National Science Foundation raider Grant  GP-15473 with the 
University of California. 
Jc~urnal of the Association for Computing Machinery, Vol. 19, No. 2, Apri| 1972. pp. 248-264. 
Theoretical Improvements in Algorithmic E~ciency for Network Flow Problems 249 
1. The Maximum Flow Problem 
1.1. THE LABELING METHOD. A network N is a finiteset {u, v, - • • } called the nodes 
and a subset of the ordered pairs (u, v), u # v, called the arcs. Network N has a 
special return arc (t, s). Node s is called the source in N and node t is called the 
sink in N. The set of all arcs of N, except (t, s), we denote by A. For each (u, v) ~ A 
there is given a number c(u, v) > 0 called the capacity of arc (u, v). 
A nonnegative function f(u, v), ranging over all arcs (u, v) of N, is called a flow 
in N if 
(i) for every (u, v) C A, f(u, v) < c(u, v); and 
(ii) for every node u, 
f(u, v) -- ~ f(v, u) = O, 
v v 
where each sum is over every v for which the summand is defined. 
For each arc (u, v) of N, f(u, v) represents the amount of flow in arc (u, v), and 
also represents the net amount of flow from v to u in the rest of the network 
"N  - (u, v ) . "  
The maximum network flow problem is to find a flow f in N such that f(t, s), the 
net amount of flow in N - (t, s) from s to t, is maximum. 
Let u~, u2, • • • , u ,  be a sequence of distinct nodes such that, for each i = l, 2, 
• .. , p - 1, either (u~, u~+~) or (u~+~, u~) is an arc. Singling out, for each i, one of 
these possibilities, we call the resulting sequence of arcs a path from Ul to Up. Arcs 
(u~, u~+~) that  belong to the path are called forward ares of the path; the other arcs 
of the path are called reverse arcs. 
Relative to any given flow f in N, a (flow) augme~ti~tg path is a path from s to t 
such that : 
Case (a): If  (ui, ui+l) C A and (ui+i, ui) ~ A, then 
~i ~" C(U i ,  Ui+i) - -  f (u i ,  ui+l) > 0; 
Case (b): If  (ui, ui+l) C A and (ui+l, ui) C A, then 
ei = f(ui+l, ui) > 0; 
Case (c): If  (u,., ui+l) ~ A and (ui+l, u,.) C A, then 
~i = e(u i ,  n iT1)  - -  f (u i ,  Ui+1) -~ f(ui+,, u~) > O. 
For a given augmenting path P,  let e = rain e, > 0. Call each arc (ui, u~+~) or 
(u~+~, u~) in P such that  ei = e a bottleneck arc relative to P and the flow f. 
Now alter the flow f as follows I : increase f by e on the return arc (t, s) ; in Case 
(a), increase the flow on arc (ui, Ui+l) by e; in Case (b), decrease the flow on arc 
(ui+~, u~) by e; in Case (c), increase the flow on arc (ui, ui+i) by 
min (e, c(ui, ui+i) - f (u l ,  ui+l)) and decrease the flow on arc (ui+l, ui) by 
max (0, e - c (ui, u~+l) + f(ui ,  ui+l)). I t  is easily checked that the f  ~ thus defined 
is a flow in N. Thus, since f~ (t, s) = f(t, s) + e, the flow f is not maximum. It  can 
1 The method of augmentation presented here differs [in Case (c)] from the method originally 
given by Ford and Fulkerson (cf. [5]). The results of this paper apply, with minor changes, to 
the Ford-Fulkerson method as well. 
Journal of the Association for Computing Maclainery, Vol. 19, No. 2, April 1972 
250 J .  EDMONDS AND R.  M. KARP 
be shown that, conversely, a flow f in N is not maximum only if there is an 
augmenting path with respect o f. 
The labeling method constructs a sequence F = fo, fl, f2, . . .  of flows in N, starting 
with, say, the zero flow, by finding an augmenting path with respect to f if one exists, 
and then augmenting toobtain fk+l. The sequence terminates only when a maximum 
flow has been obtained. 
Assuming that all the capacities c(u, v) are integers, then clearly for any aug- 
menting path P relative to any integer-valued flow f, e is a positive integer. Thus, 
since f0 is integer-valued, all the later flows fk in the sequence F are integer-valued. 
It follows that the sequence terminates after a number of labelings not greater than 
the final value of f (t, s). 
The following example illustrates that this upper bound on the number of label- 
ings can actually occur. 
11 
s t 
V 
Suppose that the arc (u, v) has capacity 1, and the capacity of each of the other arcs 
in A is M, a positive integer. Then the maximum value of f(t, s) is 2M, and 2M 
labelings will be required if the labeling process alternates between selecting 
(s, u)(u, v)(v, t) and (s, v)(v, u)(u, t) as an augmenting path. For, in each case, 
either (u, v) or (v, u) is a bottleneck arc, and e = 1. 
Assuming that all the capacities are mutually commensurable, we can obtain an 
equivalent integer-valued problem by multiplying all the capacities by a large con- 
stant. Thus, in this case also, the sequence F is finite. 
Ford and Fulkerson show by an example that if the capacities are not com- 
mensurable then the sequence F need not terminate, and in fact, may converge to a 
nonmaximum flow. 
Since numerical computation is always, in practice, performed on numbers ex- 
pressed to a finite precision, this nonfiniteness i  not from a practical viewpoint a 
very serious matter. It  does serve as another indication of the tendency of the 
number of augmentations to grow as the precision to which the capacities are ex- 
pressed increases. 
We will show that these theoretical difficulties, which could conceivably be a 
practically serious matter, can be avoided. In particular, by making a certain re- 
finement of the labeling method which is so simple that it is likely to be incorporated 
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972 
Theoretical hnprovements in,Algorithmic E~ciency for Network Flow Problems 251 
innocently into a computer implementation, we get a bound of at most ~ (Q - n) 
terms in the sequence F (regardless of commensurabil ity),  where n is the number of 
nodes. In addition, a second refinement of the labeling method is shown to yield a 
bound on the length of F, applicable only in the case of integer capacities, of 1 
10gM/(M--:) f*(t, S), where f*(t, s) is the value of a maximum flow, and M < n2/2. 
1.2. A REFINEMENT. The labeling method requires as a subroutine a labeling 
process for finding, if one exists, an augmenting path P relative to a given flow f in 
N. This is essentially a method for finding, in a certain network N I having the same 
nodes as N, a directed path from s to t. A directed path from s to t is a path such 
that all arcs are forward arcs. The ordered pair (u, v) is an arc of N I if and only if 
either 
(u,v)  C A and c (u ,v )  - f (u ,v )  > 0 
or 
(v ,u)  ~ A and f (v ,u )  > 0. 
The arcs of any directed path p I  from s to t in N i are in one-one correspondence with 
the arcs of an augmenting path P in N relative to f. The arc of p I  corresponding to a 
bottleneck arc of P is also referred to as a bottleneck arc. 
The labeling process for finding a directed path in N I from s to t is as follows: 
First s gets "labeled." Then at each successive step of the process some labeled but 
"unscanned" node gets scanned. To scan a labeled node u means to label every node 
v not already labeled and such that  the arc (u, v) is in N I. I f  v gets labeled when u is 
scanned, then u is the predecessor f v in the labeling. 
As soon as the sink t gets labeled, then t, the predecessor of t, the predecessor of 
that predecessor, and so on back to s, is the reverse sequence of a directed path in 
N I from s to t. On the other hand, if every labeled node gets scanned without t get- 
ting labeled, then there is evidently no directed path in N I from s to t. Clearly the 
labeling process terminates in one or the other of these two situations. 
The refinement reated here, which gives an upper bound of [ (n 3 -- n) on the 
number of applications of the labeling process before obtaining a maximum flow, 
is the following: In  the labeling process, scan on a "first-labeled first-scanned" 
basis. That  is, before scanning a labeled node u, scan the nodes that got labeled 
before u. 
It can be shown that a directed path in N l from s to t, obtained by this version of 
the labeling process, is one which contains a minimum number of arcs. Thus, the 
upper bound can be stated as follows: 
THEORE~I 1. If, in the labeling method for finding a maximum flow in a network on 
n nodes, each flow augmentation is done along an augmenting path having fewest arcs, 
1 3 then a maximum flow will be obtained after no more than : (n - n) augmentations. 
For present purposes, we will regard the number of arcs in a path as its length. The 
"distance" from a node u to a node v in N I is the minimum length of a directed path 
from u to v in N I, or else ~ if there is no such path. 
Let F = fo, fl, f2, . . .  be any sequence of flows in N such that fk+l is obtained from 
by an augmentation corresponding to a shortest directed path pk in N Ik. Let N k 
Sk  k • • k denote N , and let 5 (u, v) denote the distance from u to v m N . 
LEMMA 1. If  k < m and (u, v) is a bottleneck arc relative to pk and fk, and also rela- 
tive to pm and f f  , then, for some 1 such that k < 1 < m, (v, u) C pZ. 
LEMMA 2. I l k  < l, (u, v) ~ pk and (v, u) C pt, then ~(s, t) > ~k(s, t) + 2. 
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972 
252 J .  EDMONDS AND R. M. KARP 
Given these lemmas, the proof of Theorem 1 is at hand. Let {u, v} be any pair of 
nodes such that (u, v) ~ A or (v, u) ~ A. Let the sequence {ki} consist of all indices 
ki such that either (u, v) or (v, u)  is a bottleneck arc relative to P~ andf  ~. By Lemma 
1, one can find a sequence {l~}, containing {kl} as a subsequence, such that 
or  
(u, v) ~ P*~, j odd and (v, u)  ~ Pt~, j even 
(u, v) ~ P*~, j even and (v, u) ~ Pt~, j odd. 
By Lemma 2, 6 zj+'(s, t) > 6 Zj(s, t) + 2, j = 1, 2, • • • . Thus, ~t *j(s, t) > 2( j  - 1). 
But the length of any directed path in N k is at most n - 1 so that 6 *j (s, t) < n - 1 
for all j. The length of the sequence {/j} is therefore at most ½ (n - 1) + 1 = 
½ (n -+ 1), and thus the number of occurrences of (u, v) or (v, u) as a bottleneck arc 
throughout he entire labeling method is at most ½ (~ + 1). The number of oc- 
currences of bottleneck arcs altogether is therefore bounded by 
n+2 l (n  12 - n3 -n4  
And, since every augmentation determines a bottleneck arc, the number of aug- 
1 3 mentations is also bounded by z (n - n). 
The proof of Lemma 1 employs two simple propositions. 
PROPOSITION 1. I f  (u, v) is a bottleneck arc relative to pk and f~, then (u, v) ~ N k+l. 
PROOF. The augmentation f romf  k to f  k+l is such that, if (u, v) C A thenf  k+l (u, v) 
= c (u, v), and if (v, u) ~ A then fk+l (y, U) = 0; hence, (u, v) ~ N *+1. II 
PROPOSITmN2. I f  (U,V) C N k+lthen (u,v) ~ N kor (v,u) C pk. 
PROOF. Suppose (u, v) C N k+l and (u, v) ~ Nk; then, either fk+1(u, v) ~ fk(u, v) 
orffl +~ (v, u) ~ fk (v, u). In either case, (u, v) or (v, u) must be in pk. But (u, v) ~ pk, 
since (u, v) ~ N*; thus, (v, u) ~ pk. 
We can now prove Lemma 1. By Proposition 1, (u, v) C Nk+I; since (u, v) ~ p,n, 
(u ,v)  C N m. Let 1 + 1 = min{t  I t > /~and (u,v) ~ Nt}.Then (u ,v)  ~ N ~+~, 
(u, v) ~ N~; hence, by Proposition 2, (v, u) ~ P~. This completes the proof of Lemma 
1. II 
The proof of Lemma 2 will make use of the following proposition. 
PROPOSITION" 3. For t~ = O, 1, 2, • • • , and for all u, 
~(s, u) < ~+~(s, u) (1) 
and 
6~ (u, t) < /t ~+~ (u, t). (2) 
PROOF. We prove (1), the proof of (2) being similar. If 6 k+~ (s, u) = ~,  the re- 
sult is evident. Assuming 6k+~(s, u) = h is finite, let s = u0, u~, . . .  , uh = u be 
the node sequence of a shortest directed path from s to u. Then 6 k (s, u0) = 0 and 
we claim that 
6k(s, ui+l) _~ 1 + 6k(s, ui), i = 0 , - " ,  h - 1. (3) 
For, since (ui, u~+~) ~ N ~+1, Proposition 2 tells us that (u,, ui+~) ~ N ~ or (ui+~, 
u~) ~ P~. In the former case, fi~(s, u~+~) < 1 + 6~(s, ui), since the arc (ui, ui+~) 
enables us to get a directed path from s to Ui+l in N ~ having no more than 1 + 
6~(s, u~) arcs. In the latter case, ~i~(s, ui) = 1 + 6~(s, ui+~), so fi~(s, u~+i) = 
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972 
Theoretical Improvements in, Algorithmic Ei~ciency for Network Flow Problems 253 
-1  + ~(s, ul) < 1 -F 5k (s, ui). Summing the inequalities given in (3), 
~k(s,u) <h+g(s ,  u0) = h= g+1(s,u), 
and (1) is proved. II 
To prove Lemma 2 note that, since (u, v) ~ pk, ~k (s, t) = ~k (s, u) + 1 -b (3 k (v, t). 
Also, ~k(s, v) = 1 + ~tk (s, u) and/tk (u, t) = 1 + ~k(v, t). Since (v, u) C pZ, ~tl(s, t) = 
~Z(s, v) ÷ 1 + ~tZ(u, t). But, by Proposition 3, St(s, v) _> ~*(s, v) and 5Z(u, t) _> 
~k(u, t), so that ~l(s, t) > ~ik(s,v) -t- 1 -t- ~k(u,t) = (1 + ~k(s,u)) + 1 -I- (1 + 
~k(v, t)) = 2 + ~t k(s, t). Thus, Lemma 2 is proved, and we are done. I I 
The proof of Theorem 1 can be modified quite simply to supply bounds on the 
numbers of augmentations required in certain other refinements of the Ford- 
Fulkcrson labeling method. Let a (u, v) be a real-valued function defined whenever 
(u, v) C A or (v, u) C A, such that b (u, v) = a(u, v) + a(v, u) > 0. Let theweight 
of a path P in N having the node sequence ul, u2, .." , % be ~_--~ a(ui, Ui+l). 
Consider a variant of the labeling method in which each augmentation is along a 
flow-augmenting path of minimum weight. Then the number of augmentations can- 
not exceed (S ,'~(u.v)c a 1/[b (u, v )] ) -I- I A [, where S is the maximum weight of a path 
from source to sink. Theorem 1 corresponds to the ease where a (u, v) = 1 for all 
pairs (u, v). Another ease, corresponding to the rule: "select a flow-augmenting 
path with as few reverse ares as possible," has a(u, v) = 1 if (v, u) C A, and 
1 3 a(u, v) = 0 otherwise. A bound on the number of iterations in this ease is ~ (n -- n2). 
1.3. A SECOND REFINEMENT. In this section we consider the following refine- 
ment of the labeling method: at each iteration choose a flow-augmenting path 
which gives the largest possible augmentation. 
Let N be a network in which every capacity is an integer. Let M > 1 be a positive 
integer such that, for any partition of the nodes of N into two sets, X and X, with 
s C X and t { 2,  the number of ares with one end in X and the other in 2 is less 
than or equal to M. Let f* (t, s) denote the value of a maximum flow. 
THEORmr 2. If, in the labeling method for finding a maximun flow in N, a net- 
work with all capacities integral, each augmentation is done along an augmenting 
path giving the maximum possible augmentation, then a maximum flow will be 
obtained after no more than 1 -~- lOgM/(M--1) f* (t, S) augmentations. 
Before proving Theorem 2, we show how the rule under consideration can be 
implemented. Suppose we arc seeking a flow-augmenting path in N relative to a 
flow f. Associate with each arc (u, v) C N f a number e (u, v) equal to the value of e 
that would result if (u, v) were a bottleneck arc in a flow-augmenting path relative 
to N and f. Specifically, 
(i) if (u,v) C A and (v,u) ~, A, then e(u,v)  = c(u,v)  - f (u ,v) ,  
(it) if (u,v) ~ A and (v,u) C A, then e(u,v)  = f (u ,v) ,  
(iii) if (u,v) C A and (v,u) ~ A, then e(u,v)  = e(u,v)  - f (u ,v )  q- 
/(v, u). 
Then the labeling method seeks a directed path from s to t in N z in which the 
mallest value of e (u, v) is as large as possible. This is a bottleneck problem of the 
ype studied in [4]. One method of finding such a path is to label s, and then to repeat 
he following step until t is labeled: find an are (u', v') ~ N I such that u' is labeled, 
' is not labeled, and for any are (u, v) from a labeled node to an unlabeled node, 
(u', v') _> e (u, v ). Label v' and record u' as the predecessor f v'. When t is labeled, 
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972 
254 J .  EDMONDS AND R. M. KARP 
tracing the sequence of predecessors back from t gives a maximum-e flow-augmenting 
path. If, at some step, there is no arc from a labeled node to an unlabeled one, then 
no flow-augmenting path exists. 
PROOF OF THEOREM 2. Consider a partition of the nodes of N into two sets, X 
and 2,  such that s E X and t E X. Define 
c(X, 2 )  = ~ c (u ,v ) , f (X ,X)  = ~ f (u ,v)  
uE._" uEx 
vE X vEX 
(u,v)  EA (u,v)  E A 
and 
f (X ,X)  = ~ f (u,v) .  
uE£ 
vEX 
(u ,v )EA  
Then, for any flow f, 
c(X, X)  > f (X ,  X)  -- f (X ,  X)  = f(t, s). 
Suppose the labeling method using maximum augmentations produces the sequence 
of flows f0, fl, . . .  , fk, . . . .  Let e k = f+l  (t, s) - fk (t, s). Consider the augmentation 
fromff to f+~. Let the set X consist of s together with all nodes which can be reached 
from s by a directed path in N k consisting of arcs (u, v) such that e(u, v) > k; 
let X denote the remaining nodes. Then t C 2 and every arc (u, v) in N k such that 
u E Xandv  E 2sat is f iese(u,v)  < e k. 
c(X, 2 )  - [f*(X, 2 )  -- f~(2, X)] 
_< ~kl {(u,v) lu E X ,v  C 2 ,  (u,v) ~ A or (v,u) C A]} 1 _< ekM. 
Now f* (t, s) < c (X, 2 )  and ~ (t, s) = fk (X, 2 )  - fk (2, X), so 
f*(t, s) - fk(t, S) < cAM; i.e. f*(t, s) -- fk(t, s) < [fk+'(t, s) -- fk(t, s)]M. 
Equivalently, 
f*(t, s) -- f~+~(t, s) < [f*(t, s) -- fk(t, s)](1 - -  /~-1) .  
Thus, by induction, 
f*(t, s) -- ff(t, s) < f*(t, s)(1 -- M-l)  k. 
Now, since all the capacities are integers, each flow is integral. Thus, if f is not a 
maximum flow, then 
f*(t ,s)  - f ( t , s )  >_ 1, 
SO 
and 
f*(t, s)(1 -- M-l)  k >_ 1 
k _~ --logl--1/Mf* (t, S) ---- IOgM/(M--1)f* (t, S ), 
SO the total number of augmentations cannot exceed 
1 -t- IOgM/(M--1)f (t, S). 
1 2 Let 6 denote the average capacity of an arc in A. Then f* (t, s) < 6n 2 and M < ~n, 
SO 
iOgM/(M--1) f*(t, S) < logl+2/(~2-2)(n26) = in n26 
In (1 + 2/(n ~ -- 2))" 
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972 
Theoretical Improvements in Algorithmic E~ciency for Network Flow Problems 255 
But 
( 2 )> in ( i+  2 ) 2 1 (2)  2 
In 1--~-n~---- ~ _ ~ >n--~-- ~ ~ . 
Using these estimates we find that the number of augmentations cannot exceed 
2 In n + In 5 n 4 
1 -t- = 1 + - -  (21nn -k ln~) 2(1/n 2 - 1/n 4) 2n 2 - 2 
= n 21nn+½n 21nS- t -O(n  21nn+n 21no) .  
Thus, although the present bound depends on the capacities and requires their 
integrality, it is superior to the bound of Section 1.2 in approximately the range 
0 < g < e ~/4. 
2. The Minimum-Cost Flow Problem 
2.1. A LABELING METHOD. In this section we turn to the problem of finding a 
maximum flow of minimum cost. Given a network N, associate with each arc 
(u, v) E A a nonnegative cost d(u, v) as well as the usual positive capacity c(u, v). 
Let the cost of a flow f be ~(~,,)e ~d(u, v)f(u, v) and let its value be f(t, s). We seek 
flow of minimum cost among those with value f*(t, s). 
Call a flow f extreme if it is of minimum cost among flows with value f(t, s). We 
mention some well-known characterizations of extreme flows. In doing so, we make 
use of the network N s associated with f. We recall that a network, by definition, has 
at most one are from one given node to another. For convenience we also assume that 
(u, v) C A ~ (v, u) ~ A. Obvious devices using "fictitious nodes" can be used to 
enforce this restriction if it does not originally hold. Associate with any arc (u, v) 
of N s a weight ~ (u, v) as follows: 
~d(u, v), (u, v) C A, 
A(u, v) = ~-d(v ,  u), (v, u) E A. 
Define the weight of a subgraph of N s as the sum of the weights of its arcs. Define a 
labeling function as a function from the nodes to the real numbers. 
THEORE~I 3. 2 Let f be a flow. Then the following are equivalent: 
(i) f is extreme, 
(ii) every directed cycle in N s has nonnegative weight, 
(iii) there exists a labeling function 7r such that, for every arc (u, v) of N s, 
~(u) + ~(u, v) - ~r(v) _> 0. 
A restatement of (iii) in terms of the network N is: for (u, v) ~ A, 
~r(u) -- 7r(v) + d(u, v) > 0 ~ f(u, v) = O, 
(4) 
7r(u) -- z'(v) + d(u, v) < 0 ~ f(u, v) = c(u, v). 
If the flow f and the labeling function 7r together satisfy (4), then f and 7r are 
called compatible. 
Another basic result is the following. 
2 The equivalence of (i) and (iii), stated in a somewhat  different form, can be found in [5, 
pp. 114-115]. 
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972 
256 J. EDMONDS AND R. M. KARP 
THEORE:U 4. ([5, p. 121]). I f  f i8 extreme and P is a path of minimum weight in 
N s from 8 to t, then a flow f'  obtained by augmenting along P is extreme. 
For brevity call a path of minimum weight a "shortest path." Theorem 4 sug- 
gests the following method of solving the minimum-cost flow problem: starting with 
an extreme flow f0, compute a sequence of extreme flows J~, fl, . . .  , fk, fk+l, . . .  
obtaining fk+l from fk by augmenting along a shortest path from 8 to t in N sk. A 
shortest path can be determined using the following algorithm. 
ALGORITHM A : Shor tes t -Path  Algor ithm 
Let N fk have the set of arcs A k, and let A(u, v) be the weight of arc (u, v) C A k. 
(1) Set a(s) = 0 and set ~(u) = -k-~, u ~ s. 
(2) Set S = {s}. 
(3) If S = 4~, halt;  otherwise choose u* such that u* E S and or(u*) = minu Es,r(u)- 
(4) For  each v such that  (u*, v) C A k, set 
,r(v) = rain (a(v), a(u* )  A- A(u*, v)). 
If this process decreases a(v), adjoin v to the set S. 
(5) Delete u* from S and go to (3). 
Algorithm A has the following properties: 
(1) Upon its termination, a(u)  gives the weight of a shortest path from s to u; 
(2) If A (u, v) >_ 0 for every arc (u, v), then each vertex accessible from s enters 
the set S exactly once, so that the total amount of computation is proportional to 
the number of ares; 
(3) If no cycle is of negative weight, then each vertex accessible from 8 enters the 
set S at most n - 1 times, so that the total amount of computation has a bound 
proportional to n - 1 times the number of ares; 
(4) If there is a negative-weight cycle accessible from 8, then the algorithm is 
nonterminating. One way to detect his is to keep a subgraph T of tentative shortest 
paths. T contains arc (u, v) if v last entered S during an application of Step (4) with 
$ 
u = u. Any cycle in T has negative weight; if a negative-weight cycle is accessible 
from 8, then such a cycle will occur in T by the time an5' vertex enters S for the nth 
time. 
The discussion of the shortest-path algorithm shows the efficiency to be gained 
in eases when all weights are nonnegative. Too little attention has been paid to this 
essential point in the development of algorithms for minimum-cost flows. We 
present in this section an algorithm designed so that all shortest-path calculations are 
done on networks with all weights nonnegative. 
Let f be a flow and let ~- be a labeling function. Assign each arc (u, v) of N ] a 
weight X(u,v)  = ~r(u) -4- A(u,v)  -- 7r(v). 
Then clearly 
(i) if C is a directed cycle, then 
5(u,~)= ~ a(u,~); 
(u,v) ~ C (u,v) CC 
(ii) if P is a directed path f rom u* to v*, then 
~(u, ~) = ~-(u*) - ~-(~*) + ~ ~(u, ~). 
(u,v) ~P (u,v) EP 
Thus, N s has a cycle of negative weight with respect o the weights A (u, v) if 
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972 
Theoretical Improvements in Algorithmic Efficiency for Network Flow Problems 257 
and only if N I has a cycle of negative weight with respect o the weights A (u, v). 
Also, P is a shortest path from s to t with respect o the weights A (u, v) if and only 
if P is a shortest path from s to t with respect o the weights A (u, v). Consider the 
implications of these facts when f and ~r are compatible. Then A (u, v) > 0, and a 
minimum-weight flow-augmenting path (relative to the weights A(u, v)) can be 
found by a shortest-path calculation using the nonnegative weights A(u, v). 
A variant of the algorithm suggested by Theorem 4 is now apparent which per- 
forms all shortest-path calculations on networks with all weights nonnegative. 
ALGORITHM B: Minimum-Cost Flow Algorithm 
(1) Set f0 equal to the zero flow, and set 7r ° equal to the identically zero labeling function; 
(2) Given fk and 7r k, determine fk+l by augmenting along a minimum-weight path from s to t 
in N/k with respect o the (nonnegative) weights 
ak(u, v) = ~-k(u) + ,~(u, v) - ~-k(v). 
If several min imum-weight  paths exist, choose one with the fewest arcs. 
(3) If ak(u) denotes the weight of a shortest  path  from s to u with respect to the weights 
A k, set lr~+l(u) = ~k(u) + aS(u); take ¢k(u) = 7rk+l(u) = -]-~ if u is inaccessible from s in 
N/k . 
(4) Halt when, for some k, no flow-augmenting path exists with respect o fk 
Some properties of the algorithm are given in the following theorem. 
THEORE~ 5. For each k, fk and 7rE are compatible. For eaeh k and u, 7r k (u ) gives 
the weight of a shortest path from s to u in N Ik with respect o the weights A (u, v) and 
~'~÷' (u ) _> ~'~ (u ). 
We present two bounds on the number of flow augmentations required by the 
minimum-cost flow algorithm. 
THEOREM 6. /f all the capacities are integers, then the computation terminates after 
at most f* (t, s) flow augmentations. 
PROOF. Each flow fk is integral, and each augmentation i creases the flow by a 
positive integer. [r 
THEORE~r 7. Suppose the costs d (u, v) are integers less than or equal to an integer D. 
Then the computation terminates after at most 1 + ~ (n 3 - n ) (n - 1 )D flow augmenta- 
tions. 
PROOF. We show that the overall computation can be regarded as a sequence of 
at most (n - 1)D + 1 phases, each consisting of a maximum flow computation. 
Each phase corresponds to a period during which 7r k (t) remains constant. Suppose 
7r k (t) is constant for k~ < k < k2. Then the flow augmentations involved in passing 
from fk~ to fk: are along directed paths in the subnetwork N'  containing those arcs 
(u, v) inN  Ik' such that ~r k~ (u) + A(u, v) -- 7r ~ (v) = 0. Hence, these augmentations 
Ltre part of a maximum-flow computation i  N'.  The bound of Section 1.2 is appli- 
cable, since the algorithm selects, at each step, a path with fewest arcs among those 
of minimum weight. Hence, the number of augmentations per phase is at most 
(n 3 - n). Now, except at the last step, when t is inaccessible by a flow-augmenting 
9ath and ~rk~) = oc, 7r k (t) is the weight of some path in N from s to t, and hence is 
~n integer between 0 and (n - 1 )D. Thus, noting that 7r k (t) is nondecreasing with 
~, we see that the number of phases, excluding the last step, is at most (n -- 1)D, 
md the theorem follows. [I 
COROLLARY 1. Algorithm B solves any minimum-cost flow problem in a finite nTm- 
)er of steps (even when neither the capacities nor the costs are commensurable). 
Journal of the Association for Computing Machinery, Vol. 19. No. 2, April 1972 
258 J. EDMONDS AND R. M. KARP 
PROOF. The first half of the proof of Theorem 7 is applicable in this case, and 
shows that there is a finite bound on the number of successive flow augmentations 
without an increase in ~r k(t). But, for any k, ~.k (t) is the weight of some directed 
path from s to t in N f~, corresponding to some path without repeated vertices in N. 
Since the number of such paths is finite ~-~ (t) increases only a finite number of times, 
so that the entire process must be finite. I] 
Although it is comforting to know that the minimum-cost flow algorithm ter- 
minates, the bounds on the number of augmentations are most unfavorable. The 
scaling method of the next two sections is a variant of this algorithm in which the 
bound depends logarithmically, rather than linearly, on the capacities. A challeng- 
ing open problem is to emulate the results of Section 1.2 for the maximum-flow prob- 
lem by giving a method for the minimum-cost flow problem having a bound on 
computation which is a polynomial in the number of nodes, and is independent of
both costs and capacities. 
2.2. A SCALING METHOD FOR THE HITCHCOCK TRANSPORTATION PROBLEM. In 
this section and the following one, we present a technique for solving a minimum- 
cost flow problem by treating a sequence of problems with the same cost as the 
given problem, but with "scaled down" capacities which approximate those of the 
given problem to successively more digits of precision. The efficiency of this scaling 
method is based on the following two features: 
(1) the capacities, and hence the flow augmentations, in the approximate prob- 
lems are on a coarser scale than in the original problem; 
(2) the final solution of each approximate problem yields a good initial flow for 
the next approximate problem. 
We prove that the number of computation steps required by the scaling method 
is proportional not to the capacities (as in the method of Section 2.1) but to the 
numbers of digits in the binary representations of the capacities. Roughly speaking, 
the scaling method is related to the original method as binary arithmetic is to 
unary arithmetic (i.e. counting). 
First we consider a special case in which the scaling technique is particularly 
simple. The Hitchcock transportation problem asks for a maximum flow of minimum 
cost through a network of the type shown in Figure 1. 
The costs and capacities are as follows: 
arc (s, si) has cost 0 and capacity al, i = 1, 2, • • • , m; 
arc (t~., t) has cost 0 and capacity bj, j = 1, 2, . . .  , n; 
arc (sl, tj) has cost d~j and capacity % oo, i = 1, 2, • .. , m, j = 1, 2, • • • , n; 
the return arc (t, s) has cost 0 and capacity + ~o. 
It is assumed that ~i'21 al = ~-1  bj. The value of a maximum flow is clearly 
The standard interpretation of this problem is well known. Each vertex s~ cor- 
responds to a "source" at which ai units of a commodity are available; each vertex 
t~. corresponds to a "desffnation" which demands b~. units of the commodity. The 
cost per unit of shipping from s~ to tj is dlj, and a shipping pattern is sought which 
minimizes the cost of meeting the demands at the destinations from the supplies 
at the sources. 
In the following specialization of the criteria for an extreme flow given in eq. 
(4), ui denotes 7r(s~) and vj denotes lr(tj); also, fii denotes f(s~, tj) when i >_ 1 
and j  > 1; foi denotes f (s, si) and fio denotes f(t j ,  t). 
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972 
Theoretical Improvements  in  A lgor i thmic  E giciency for  Network  F low Prob lems 
__ . _____ . .o  ~,  . . . . .  ° ~ t 
259 
FIG,  1 
THEOREM N. 
1, i f  a~d only i f  there exist uo , ul  , • •. ,Um and vo , vl , • • • , v~ such that 
u~-- wj-t-d~j_> 0, i = ~,2, . . - ,m; j  = 1,2, . . - ,n ,  (5a) 
ui -- v; -~- di; > 0 ~L j  = 0, i = 1, 2, . . .  ,m; j  = 1, 2, . . .  ,~t, (5b) 
Uo > ui  ~ foi = 0, (5c) 
Uo < ui  ~f0 i  = a,, (Sd) 
vi > Vo ~f~o = O, (5e) 
vj < Vo ~j~o = b; (5f) 
The f low f is extreme among max imum f lows for  the network of  F igure  
Call a flow f for the Hitchcock problem pseudo-extreme if there exist ui and v; 
satisfying (5a) and (5b). A pseudo-extreme aximum flow is extreme; for a maxi- 
mum flow has f0i = ai, i = 1, 2, . . .  , m andfj0 = b i , j  = 1, . . .  , n. Thus, if (5a) 
and (5b) are satisfied, we may satisfy (5c)-(5f) by setting Uo = mini=l.2.., mU~ 
and w0 = maxj=l.2....,,, v;. For a problem of the Hitchcock type with ~ a~ ~ ~ bj, 
a pseudo-extreme maximum flow is not, in general, extreme. 
Algorithm B can, of course, be used to solve the Hitchcock problem. An alternate 
method is based on the fact that a maximum pseudo-extreme flow is extreme. A 
sequence of pairs (f0, ~.0), (fl, ~.1), " " ,  (fk, ~.k) is computed where, for each k, 
(fk. ~_k) satisfies (Sa) and (Sb), so that fk is pseudo-extreme. The determination 
of (fk+l, ~_k+l) from (fk, ~.k) differs from the corresponding ste~ in the previous 
algorithm in only one respect: if f~i < ai then arc (s, s~) in N j is assigned cost 
(s, s~) = 0, regardless of ~.k similarly ~ (tj, t) = 0 iffj0 < b;. It is easily checked 
that, if (fk, ~.k) satisfies (5a) and (Sb), then so does (f~+~, _k+~) ; thus, fk+~ is pseudo- 
extreme if fk is. If the capacities a~ and bj are integers then an upper bound on the 
number of flow augmentations is ~ la~.  
Now we are prepared to present he scaling method. For any nonnegative integer 
p, define Problem p to have the same nodes, arcs, and costs as the given problem, 
but with the capacities changed as follows: the capacity of (s, s~) is [ai/2 p] and the 
capacity of (re, t) is [bff2v]. 3 Thus, the original problem is Problem 0 and, in general, 
the capacities in Problem p are obtained by deleting the p low-order digits in the 
binary representations of the original capacities. 
3 ,, [x]" means  "greates t  in teger  less than  or  equa l  to  x." 
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972 
260 J .  EDMONDS AND R.  M. KARP 
LEMMA 3. I f  f is a pseudo-extreme flow in Problem p, then 2f is a pseudo-extreme 
flow in Problem p - 1. 
Choose 1 such that every finite capacity has at most 1 digits in its binary expan- 
sion; i.e.a~ < 2 *, i = 1,2, - . - ,m,  andbi < 2 t, j = 1,2, . . . ,n .  Then the scaling 
method computes maximum pseudo-extreme flows successively for Problems l -- 1, 
1 - 2, • • • , 0. If f is the maximum pseudo-extreme flow computed in Problem p, 
and 7r is the associated labeling function, then 2f is taken as the initial pseudo- 
extreme flow in Problem p - l, with rr as its associated labeling function. 
The following theorem bounds the number of flow augmentations in the solution 
of a transportation problem by the scaling method. 
THEOREM 9. The number of flow augmentations in applyi~g the scaling method to 
a transportation problem with integral "supplies" a~, a~, . . .  , am and integral "de- 
mands" bl, b2, • • • , bn is less than or equal to 
(I • = a i  max (m, n) 2 + logs ,na~'~.7, n) " 
PROOF. Let fv* denote the value of a maximum flow in Problem p. The initial 
flow in Problem 1 - 1 is 0 and, for p < 1, the initial flow in Problem p - 1 is 2fp*. 
Recalling that each augmentation gives a positive integral increase in the flow, the 
total number of augmentations is bounded above by 
l--1 l--1 
ft*-i q- ~_, (f*-~ -- '2fp*) = fo* -- Efp*"  (6) 
p=l  p=l  
Now 
fv" = min(~Ia~ 1 ~Ib31)  ,:=, 7 ' ,_57 >_o. j= l  
We can write ai = 2p[ai/2 ~] + ri~,, where 0 _< rip < 2 p - 1. Hence, 
~ai -  ~r ip  ~a l  
~[a~]  i=l i=1 >i=1 
i=x 2P -- '2P 
Similarly, 
i= l  
~bj  
j= l  
2v 
Let B denote the common value of 
[log2 (B/max (m, n))]. Then 
,> ( B 
fp / -  max 0, 2--7 
and 
n.  
~i~,  ai and Ejn=l bj, and let L denote 
- max (m, n ) )  
) fp* >_ -- max (m, n) . 
p=l  p=l  
Journal of tile Association for Computing Machinery, Vol. 19, No. 2, April 1972 
Theoretical Improvements in Algorithmic Efficiency for Network Flow Problems 261 
Applying this inequality to (6), and noting that fo* = B, we find that an upper 
bound on the total number of flow augmentations is 
B/2 L + Lmax (re, n) _< (L + 2) max (re, n). 
This completes the proof, ll 
We remark that this bound on the number of flow augmentations is approxi- 
mately equal to the number of binary digits required to encode the data of the 
transportation problem. Each augmentation requires O(m, n) computation steps, 
so that the number of computation steps in the entire process is bounded by a low- 
degree polynomial in the size of the problem, as measured by the length of the input 
text. In this sense the scaling method is a "good" algorithm. 4 
2.3. A SCALING METHOD FOR THE ~'~INIMUM-CosT FLOW PROBLEM. References  
[6] and [7] give a simple method of converting any minimum-cost flow problem having 
I A I arcs and n nodes into an "equivalent" Hitchcock transportation problem with 
I A [ sources, n destinations, and a maximum flow of ~(~.,)c i C (U, V). By Theorem 9, 
the application of the scaling method to such a derived transportation problem 
requires at most 
(L + 2)[ A I 
flow augmentations where L = log2 (~(u.~.)c(u, v)/[ A I). Thus, the approach of 
converting to an equivalent transportation problem which is solved by the scaling 
method yields a good algorithm for the minimum-cost flow problem. 
In this section, we consider the direct application of the scaling method to the 
minimum-cost flow problem. The general approach is clear. Given a minimum- 
cost flow Problem on a network N with costs d (u, v) and capacities c (u, v), define 
Problem p as a problem identical with the given one except hat the capacity of arc 
(u, v) is given by [e(u, v)/2v]. Choose 1 as the least integer such that 2 l > e(u, v) 
for all (u, v) C A. Then the plan is to solve Problems 1 - 1, 1 - 2, . . .  , 0 succes- 
sively using Algorithm B, taking twice the final flow in Problem p as the initial 
flow in Problem p - 1. There is a major difficulty, however. If.fp* is a minimum-cost 
maximum flow in Problem p, then 2fv* is a flow in Problem p - l, but not, in general, 
an extreme flow. In the case of the transportation problem this difficulty was not 
serious, since it was possible to work with pseudo-extreme flows instead of extreme 
flows. For general minimum-cost flow problems the remedy for this difficulty is 
somewhat more complex. 
We begin by showing that if f is extreme in Problem p, then 2fis "almost extreme" 
in Problem p - 1. Since f is extreme in Problem p, there is a labeling function 7r 
such that 
~-(u) + d(u, v) - ~-(v) > 0 ~ f (u,  v) = 0, (u, v) C A, 
~'(u) + d(u, v) - ~'(v) < 0 ~ f(u, v) = [c(u, v)/2P], (u, v) C A. 
Using the inequalities 
Fe(u, ) 1 Fe( ,v)l 
2 L -~- - J  -< L~T-'- J  -< 2 L2G-- J  + 1, 
4 The concept of a "good a lgor i thm" is discussed in detail in [2]. 
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972 
262 z. EDMONDS AND R. M. KARP 
we have 
~r(u) + d(u, v) -- ~'(v) > 0 ~ 2f(u, v) = O, (7) 
7r(u) + d(u, v) -- ~r(v) < 0 ~ 2f(u, v) < [c(u, v)/2 p-'] < 2f(u, v) + 1. 
But compatibi l i ty of f and ~r in Problem p - 1 requires 
~r(u) + d(u, v) - ~r(v) < 0 ~ 2f(u, v) = [c(u, v)/2P-1]. 
Thus, 2f and ~r fail to be compatible in Problem p - 1 by at most one unit of flow 
on any arc. We give an efficient method of transforming 2f to a flow which has the 
same value and is extreme in Problem p -- 1. The method can be regarded as a 
var iant of the Fulkerson out-of-ki lter algorithm [5] in which the "flow change" 
and "potential  change" phases are combined into a single computat ion.  
We state the method as it applies to an arbitrary integral feasible flow g in Prob- 
lem p -- 1, and an arbitrary labeling function 0. Dcfine el(u, v) = O(u)+ 
d(u, v) -- 0 (v). Define Kg.o (u, v), the kilter number of ~rc (u, v) relative to g and 0, as 
g(u, v), if d(u, v) > 0, 
0, if d (u ,v )  = 0, 
I c(u, ~)~ -~- j  - g(u, v), if d(u, v) < 0. 
Thus, g and 0 are compatible if and only if each arc has kilter number zero. Also, 
relative to 2f and 0, the kilter number of each arc is 0 or 1. 
The following algorithm derives, from an incompatible pair (g, 0), a new pair 
(gt, 0'), in such a way that 
(i) Kg,,o,(U, v) < Ko,o(U, v), (u, v) E A, 
and 
(ii) ~_,(u,~)caKo,,o,(U, v) < ~_,(u,v)caK~,o(u, v) - 1. 
ALGORITHM C: K i l ter  Number  Reduct ion 
(1) Form the augmentat ion  network N °, having A rJ as its set of arcs. For  each arc (u, v) E A g' 
define 
~(u ,  v), if (u, v) E A and g(u, v) < [c(u, v)/2p-ll, 
7~(u,v) = [ -d (u ,v ) ,  if (v ,u)  E A and g(v,u) > O. 
Label each are (u, v) E A g wi th  the weight 
B(u, v) = max (~(u, v), 0). 
(2) Choose an arc (u*, v*) of N g such that  
(a) (u*, v*) E A, a(u, v) < 0 and g(u, v) < [~(u, v)/2P-l], 
or 
(b) (v*,u*)  E A, ~(u,v)  > 0 and g(u, v) > O. 
(3) Let N* = {x [ x = v* or N* has a d i rected path  from v* to x}. Forx  E N*, set 6(x) equal 
to the min imum weight of a d i rected path  from v* to x. For  x (~ N* set 
~(x) = max [0(u) - ~(v, u)]. 
{(v,u)EAOIv~:N*, uEN*} 
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972 
Theoretical Improvements in Algorithmic E~ciency for Network Flow Problems 263 
(4) 
For each node z, let O' (x) = O(x) + 8(x). 
If u* ~ N*, then q' = g. 
If u* C N*, choose a cycle C of N g consisting of (u*, v*) together with a minimum-weight 
path from v* to u*. Obtain g' from g by performing a flow augmentation around the cycle 
C. 
We make the following assertions (omitting proofs):  
(i) For each arc (u, v), Kg,,v (u, v) < Kg,0 (u, v) ; 
(ii) if (u*, v*) C A, 
Ko,,v(u*, v*) _< Ko,e(u*, v*) - 1; 
(iii) if (v*, u*)  C A, 
Ko,.o' (v*, u*) < Ko,e(v*, u*) - 1. 
By iteration of Algorithm C, the pair (2f, ~-) can be converted to an extreme flow 
for Problem p - 1 having the same value as 2f. Since each iteration reduces the 
sum of the kilter numbers by an integer, the number  of iterations will not exceed 
~(~,,)ea K in ,  ((u, v)) .  But,  since K2i., (u, v) C {0, 1}, the number  of iterations is 
bounded by ]A [. 
We are now in a position to give a complete statement of the scaling algorithm. 
ALGORZTHM n: Scaling A lgor i thm for Min imum-Cost  Flows 
(1) Set f = 0 and ~- = 0. Choose ! such that, for all (u, v) E A, c(u, v) < 2 Z. Set p = 1 - 1. 
(2) Solve Problem p by the algorithm of Section 2.1, using f as the initial flow and ~r as the 
initial labeling function. After this step] is a maximum flow of minimum cost in Problem 
p, and ~r is compatible with f in Problem p. 
(3) If p = 0, halt. Otherwise replace p by p - 1 and replace f by 2f. 
(4) Apply Algorithm C repeatedly, starting with the pair (f, ~r), until a compatible pair (g, 8) 
is obtained. Set f = g and ~- = 0. Go to 2. 
The number  of steps required in apply ing this algorithm can easily be bounded. 
The number  of executions of Algorithm C in Step (4) is at most ]A l ( l  - 1). 
The number  of flow augmentat ions (each requiring an application of Algorithm 
A to a network with nonnegative weights) is bounded above by 
1--1 l--1 
fz*-i + ~ * -- = fv-1 2fp* f0* - -  ~fv* .  (8) 
The number of applications of Algorithm A to networks with nonnegative weights 
to verify that a max imum flow has been reached is I. 
To put an upper bound on (8) we establish a lower bound on fp*. Let T be an 
upper bound on the number of arcs in a cut-set separating s from t; i.e. if the nodes 
are partitioned into sets X and X such that s C S and t E X, then the number of 
arcs directed from a node in X to a node in X is less than or equal to T. According to 
the max-flow rain-cut theorem ([5]) 
fv* = min E P(u")l P(u")l 
.~L  2~ J=~7"YL 2p J 
for some part it ion (Y, 1~). Now 
e(u, ")7 > e(u, ,) 
- - -~- -A  -- 2P 1, 
Journal of the Association for Computing Machinery, Vol. 19, No. 2, April 1972 
264 J. EDMONDS AND R. M. KARP 
so 
1 1 , 
fp* >_ ~ ~ c(u, v) -- T _> ~fo  -- T. 
uEY 
vET" 
Subst itut ing this inequal ity in (8) gives, as an upper bound on the number  of flow 
augmentations,  
~-~(1 ,  ) 1 , 
]0-- ~p=l ~fo  -- T =:~fo  + ( l - -  1)T  < 1T. 
The following theorem sums up our conclusions. 
THEOREM 10. Let N be a network with n nodes, I A [ arcs, and at most T arcs in a 
cut-set separating s from t. Let l be the number of binary digits needed to represent the 
largest arc capacity. Then the scaling method solves the minimw~t-cost flow problem 
for N using not more than I A I (l - 1) applications of Algorithm C and not more than 
l -- 1 + lT applications of Algorithm A to networks with ~wnnegative weights. Each 
network considered in the algorithm has n nodes and at most I A [ arcs. 
REFERENCES 
(Note. References [1, 3, 6, 7] are not cited in the text.) 
1. DINIC, E.A. Algorithm for solution of a problem of maximum flow in a network with 
power estimation. Soy. Math. Dokl. 11 (1970), 1277-1280. 
2. EDMONDS, J. Paths, trees and flowers. Canadian J. Math. 17 (1965), 449 467. 
3. EDMONDS, J., AND KARP, R.M.  Theoretical improvements in algorithmic efficiency for 
network flow problems. Combinatorial Structures and Their Applications. Gordon and 
Breach, New York, 1970, pp. 93-96 (abstract presented at Calgary International Conference 
on Combinatorial Structures and Their Applications, June 1969). 
4. EDMONDS, J., AND FULKERSON, D. R. Bottleneck extrema. RAND Corp. Memorandum 
RM-5375-PR (Jan. 1968). 
5. FORD, L. I{., AND FULKERSON, I). R. Flows in Networks. Princeton U. Press, Princeton, 
N.J., 1962. 
6. FULKERSON, D. ll. On the equivalence of the capacity-constrained transshipment prob- 
lem and the Hitchcock problems. RAND Corp. Memorandum RM-2480 (Jan. 1960). 
7. WAGNER, H.M. On a class of capacitated transportation problems. Manag. Sci. 5 (1959), 
304 318. 
RECEIVED SEPTEMBER 1970; REVISED AUGUST 1971 
Journal of the Association for Computing Machinery, Vo|. 19, No. 2, April 1972 
