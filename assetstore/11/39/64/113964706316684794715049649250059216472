Information and Computation 157, 183235 (2000)
Higher Order Unification via Explicit Substitutions
Gilles Dowek
INRIA-Rocquencourt, B.P. 105, 78153 Le Chesnay Cedex, France
E-mail: Gilles.Dowekinria.fr
The re se Hardin
LIP6 and INRIA-Rocquencourt, Universite Paris 6, 4 Place Jussieu, 75252 Paris Cedex 05, France
E-mail: Therese.Hardininria.fr
and
Claude Kirchner
LORIA and INRIA, 615, rue du Jardin Botanique, 54600 Villers-le s-Nancy Cedex, France
E-mail: Claude.Kirchnerloria.fr
Higher order unification is equational unification for ;’-conversion. But
it is not first order equational unification, as substitution has to avoid
capture. Thus, the methods for equational unification (such as narrowing)
built upon grafting (i.e., substitution without renaming) cannot be used
for higher order unification, which needs specific algorithms. Our goal in
this paper is to reduce higher order unification to first order equational
unification in a suitable theory. This is achieved by replacing substitution
by grafting, but this replacement is not straightforward as it raises two
major problems. First, some unification problems have solutions with
grafting but no solution with substitution. Then equational unification
algorithms rest upon the fact that grafting and reduction commute. But
grafting and ;’-reduction do not commute in *-calculus and reducing an
equation may change the set of its solutions. This difficulty comes from
the interaction between the substitutions initiated by ;’-reduction and
the ones initiated by the unification process. Two kinds of variables are
involved: those of ;’-conversion and those of unification. So, we need to
set up a calculus which distinguishes between these two kinds of
variables and such that reduction and grafting commute. For this purpose,
the application of a substitution of a reduction variable to a unification
one must be delayed until this variable is instantiated. Such a separation
and delay are provided by a calculus of explicit substitutions. Unification
in such a calculus can be performed by well-known algorithms such as
narrowing, but we present a specialised algorithm for greater efficiency.
At last we show how to relate unification in *-calculus and in a calculus
with explicit substitutions. Thus, we come up with a new higher order
unification algorithm which eliminates some burdens of the previous
doi:10.1006inco.1999.2837, available online at http:www.idealibrary.com on
algorithms, in particular the functional handling of scopes. Huet’s algo-
rithm can be seen as a specific strategy for our algorithm, since each of
its steps can be decomposed into elementary ones, leading to a more
atomic description of the unification process. Also, solved forms in
*-calculus can easily be computed from solved forms in *_-calculus.
] 2000 Academic Press
Key Words: explicit substitutions; higher order unification; equational
unification.
INTRODUCTION
In the original presentation of higher order logic, ; and ’-conversion were
defined as axioms of the theory [9, 3]. The use of these axioms in a proof searching
method leads to the replacement of a given proposition by any of its ;’-equivalent
forms, which is quite inefficient. This leads to a more suitable presentation of higher
order logic, where ;’-equivalent propositions are identified. Blind enumeration of
equivalent propositions is then avoided, but instead of looking for syntactically
equal instances of two terms, unification has to search for convertible instances of
those terms. In other words, the conversion steps of the early proof searching
methods are integrated within the unification process [2]: this is the so-called
higher order unification or unification in simply typed *-calculus [26].
A similar approach has been applied successfully to many theories of interest
by removing equational axioms like associativity and commutativity from the
theory and integrating them within the unification process, thus leading to the use
of equational unification [43] in the deduction process.
Thus, higher order unification is merely equational unification for ;’. But it is
not first order equational unification: as * is a binding operator, *-calculus is not
a first order algebra and substitution is not first order. Therefore, the classical first
order methods for equational unification, like narrowing for example, cannot be
used and higher order unification still needs specific algorithms. In this paper we
show how higher order unification can be reduced to first order equational unification
in a suitable equational theory.
The main difference between substitution of *-calculus and first order substitution,
here called grafting, is that the former performs renaming to avoid captures. This
complicates higher order unification algorithms a lot. Indeed, consider a problem
where a variable X occurs and % a solution to this problem. The normal form of
the term %X is
%X=* x1 } } } * xn . ( f a1 } } } ap).
The symbol f is called the head symbol of this term and the terms a1 , ..., ap are its
arguments. Of course, the bound variables x1 , ..., xn may occur in these arguments.
As for equational unification, we would like in a first step towards this substitution
to choose the head symbol f and to generate new variables for its arguments leading
to the elementary substitution
X* x1 } } } * xn . ( f Y1 } } } Yp).
184 DOWEK, HARDIN, AND KIRCHNER
But this does not work in *-calculus, as the substitution mechanism would forbid
substituting, for example, x1 for Y1 while x1 may occur in a1 . Thus, elementary sub-
stitutions in higher order unification have the form
X* x1 } } } * xn . ( f (Y1 x1 } } } xn) } } } (Yp x1 } } } xn)).
The information that the variables xj can indeed occur in the arguments of f needs
to be functionally handled explicitly. Using grafting instead of substitution for
unification will allow us to avoid this functional handling of scopes.
However using grafting instead of substitution for unification in *-calculus raises
two major problems. First, some scoping constraints are essential and they would
need to be handled explicitly. For instance, in the unification problem * x .Y
=?;’ * x .x, a term substituted for Y cannot contain x. When the replacement is the
substitution of *-calculus, the bound variable x is renamed if the term substituted
for Y contains the variable x and thus the constraint is automatically satisfied. If
the replacement is grafting, then this constraint must explicitly be recorded, leading
to a side calculus. Second, and more seriously, grafting and ;’-reduction do not
commute, while substitution and reduction do. For instance ((* x .Y ) a) reduces
to Y, although the term ((* x .x) a) obtained by grafting x to Y reduces to a and
not to x. Thus, reducing an equation would change the set of its solutions. This
difficulty comes from the interaction between two different calculi: the ;’-conver-
sion and the application of substitution by the unification algorithm. The difference
is at the variable level rather than at the calculus level: the variables that can be
meaningfully instantiated by unification are never the variables that can be instan-
tiated by ;’-reduction, i.e., the bound variables. Thus, we need to distinguish the
two kinds of variables and to set up a calculus where reduction and unification
grafting do not interfere. In such a calculus, the application of the substitution xa
to the term Y, during the reduction of ((* x .Y) a), must be delayed until the
unification variable Y is instantiated.
In other words, we need to describe at the object level how the application of a
substitution initiated by reduction works. Such an internalisation of the substitution
calculus was already required for describing implementations of *-calculi and has
motivated the development of *_-calculus [1, 11] which is a first order rewriting
system. This calculus has been designed to describe ;’-reduction step by step, the
*-terms being written in de Bruijn notation.
As we want to distinguish two kinds of variables in *-calculus, we cannot directly
use the embedding of the *-calculus in de Bruijn notation into the *_-calculus. To
extend it, we need to express how we translate unification variables. They can either
be coded as de Bruijn indices together with the variables or as meta-indices, i.e., in
a calculus with two kinds of de Bruijn indices or kept as named identifiers. As we
want these unification variables to be the variables of a first order algebra, we
rather keep names.
In *_-calculus grafting and reduction commute, so we can use grafting for
unification, but we still need to handle the scoping constraints initially given in
the problem. In fact, using the expressive power of *_-calculus, these scoping
constraints can be internalised in the expression of the problem. We define a translation
185HIGHER ORDER UNIFICATION
(that we call precooking) of *-calculus into *_-calculus such that a problem a =?;n b
has a solution (substitution) in *-calculus if and only if its translation aF =?*_ bF has
a solution (grafting) in *_. The main idea of the translation is the following: if a
variable X occurs in the problem a =?;’ b, under some *’s, then substituting t for
X in a =?;’ b needs some processing (called lifting) of t to avoid capture. Thus, sub-
stitution in *-calculus contains two steps: first lifting then grafting. As lifting
operators are explicit in *_-calculus, lifting will be incorporated in the unification
problem aF =?*_ bF and thus searching for a substitution solution of the problem
a =?;’ b is reduced to searching for a grafting solution of the problem aF =
?
*_ bF .
As *-calculus is a strict subset of *_-calculus, we need to show that a problem
has solutions in *-calculus if and only if its translation has solutions in *_. In this
way we reduce higher order unification to first order equational unification in *_.
This solution is completely different from a reformulation of Huet’s algorithm [26]
in *_, as such an approach would not reap the benefit of the first order framework,
in particular the use of grafting.
To solve equational unification problems in *_, we can use a classical algorithm
such as narrowing. In fact we will design a more efficient algorithm, for this
particular theory. This algorithm can be understood as a kind of optimised narrowing.
At last we show that in contrast with the reduction of higher order unification
to equational unification in a combinatory language [16], the unification algorithm
for *_ can simulate Huet’s algorithm, since every step of this algorithm can be
simulated by a sequence of steps of our algorithm. We also show that this is not
the most efficient way to use the unification algorithm of *_ as this simulation
includes a lot of steps that functionally code and decode scoping constraints, which
are not needed.
The structure of the paper is as follows: First we introduce the * and *_ calculi
and show in detail how the notions of substitution and grafting interact with
;’-reduction. We then introduce, in Section 2, type information in the calculi and
we make explicit a first order presentation of the typed *_-calculus. In Section 3 we
define a translation called precooking from *-calculus to *_-calculus that reduces
substitution in *-calculus to grafting in *_-calculus. After introducing the standard
notions of equational unification and the appropriate notion of solved forms,
Section 4 is devoted to the description of a rule-based unification procedure for the
typed *_-calculus and to its proof of correctness and completeness. Section 5 then
shows how the previous unification procedure can be applied to solve the problem
of higher order unification thanks to precooking. The paper ends with detailed
examples.
This paper is the full version, including full motivations and proofs, of the
extended abstract which appeared in Ref. [19]. We have chosen to make this version
quite detailed since it is important for the reader to have an explicit description of
all the fundamental choices we have made in the design of the framework.
1. FROM *-CALCULUS TO *_-CALCULUS
In this section we motivate and introduce the calculi used in the paper: *-calculus
with names, *-calculus with de Bruijn indices, and then *_-calculus. The presentation
186 DOWEK, HARDIN, AND KIRCHNER
given here is slightly different from the classical ones, as we emphasise the role of
unification variables and substitution.
In these calculi, the key notion is always the notion of substitution. However, in
these formalisms the word substitution is heavily overloaded. First, we can sub-
stitute a bound variable of the calculus, as in substitutions initiated by ;-reduction.
Then we may substitute a unification variable of a term schema. Also, some
substitutions avoid bound variable capture by renaming or lifting and others such
as first order substitutions do not. So we are in particular insisting in this section
on the differences between substitution and grafting.
1.1. First Order Algebras
First, in order to fix notations, we recall the classical definition of first order sub-
stitution which will be called grafting in this paper. Let T(F, X) be the free
algebra built on a set X of variables (denoted X, Y, ...) and a set F of operators.
The set of variables of a term a is denoted Var(a).
Definition 1.1. A valuation is a function from X to T(F, X). The X-grafting
(usually called first order substitution), extending a valuation % and written % , is the
homomorphism defined by:
1. if X is a variable of X then % (X )=%(X ),
2. if a1 , ..., ak # T(F, X ) and f # F, then % ( f (a1 , ..., ak))= f (% (a1), ..., % (ak)).
The domain of a grafting % is the set of variables that are not trivially mapped
to themselves,
Dom(%)=[X | X # X and %(X ){X ],
and the set of variables introduced by % is called its range, defined by:
Ran(%)= .
X # Dom(%)
Var(%(X )).
The set of all variables involved in % is Var(%)=Dom(%) _ Ran(%).
Notation. Let % be a valuation binding the variables X1 , ..., Xn to the terms
a1 , ..., an ; we write the grafting associated to % : % =[X1 [ a1 , ..., Xn [ an]. As
usual, % is also written % and X-grafting is simply called grafting when there is no
ambiguity.
Example 1.1. Applying %=[X [ f (X, Z)] on the term a= g(b, g(X, X )) results
in the term %(a)= g(b, g( f (X, Z), f (X, Z))).
1.2. *-Calculus with Names
Let V be a set of variables, written x, y, etc. The terms of 4(V ), the *-calculus with
names, are inductively defined by:
a ::=x | (a a) | *x .a.
187HIGHER ORDER UNIFICATION
First, we may try to consider the *-calculus as a first order language, with a binary
infix operator with no name that we denote when needed  for the application
(formally (a b) would be the infix notation for the term in prefix notation (a, b))
and an infinite number of unary operators called abstractors *x . indexed on V.
A term * x .a is intended to represent a function of x, whose body is a. Its
application to an actual parameter b is expected to return the value of a, where
the formal parameter x is replaced by b. So, we need to define this replacement
operation. In a first order setting, the natural notion of replacement is the one of
grafting on the term algebra T[*x . ,, ], V). Using this notion, the replacement
of formal arguments by actuals (the ;-reduction) would be defined by:
(* x .a) b  [x [ b]a.
But this definition of grafting has two severe drawbacks with respect to the intended
semantics of the calculus. First if %=[x [ a] then %(*x .x)=*x .a although
%(*y .y)=*y .y, so the computation can be incorrect. Second, if %=[x [ y] then
%(*y .x)=*y .y although %(*z .x)=*z .y, so there can be a capture.
Thus, during the replacement, bound variables renaming (also called :-conversion)
is needed to ensure the correctness of computations and we must forget about first
order substitutions. So let us recall the classical definition of substitution in
*-calculus [4].
Definition 1.2. Let a # 4(V). The set of free variables of a is written FV(a).
For a valuation % binding the variables x1 , ..., xn to the terms a1 , ..., an , the substitution
extending % and written % =[x1 a1 , ..., xn an] is defined by:
1. % x=%x,
2. % (a b)=(% a % b),
3. % (*y .a)=*z . (% [ yz] a) where z is a fresh variable, i.e., a variable such that
%z=z, z does not occur in a and for every x # FV(a), z  FV(%x).
Renaming bound variables (:-conversion) has to be done before performing
the substitution under a *. This is combined with the substitution of a fresh variable
z for y in order to avoid capture. As the choice of this variable is not unique, this
substitution is actually defined on classes of :-equivalent terms (see, for instance,
[33]).
Definition 1.3. The ;-reduction is the rewriting relation defined by the rule:
(*x .a) b  [xb] a.
The ’-reduction is the rewriting relation defined by the rule:
*x . (a x)  a if x  FV(a).
188 DOWEK, HARDIN, AND KIRCHNER
1.3. Unification Variables
At first glance, a unification problem is given by two terms a and b, and a solution
to such a problem is a substitution making a and b equal. In a given *-term, we can
distinguish several kinds of variables. First, bound variables are not concerned by
unification substitutions, then free variables are separated in two classes: constants
which cannot be substituted during unification and true unification variables which
define the unification problem. We may keep the same syntactical category for
bound variables and constants: both of them cannot be instantiated by unification.
Their only difference is that the latter happen to be not bound by a * and thus
remain unchanged during the ;-reduction process.
There are two possible choices for the status of unification variables: they may
either be mere elements of V or be considered as metavariables, i.e., external to the
;-process. If we take the first choice (see [26]), Definition 1.2 applies directly, but
we need to keep at a metalevel a distinction between constants and true unification
variables during the unification process.
Here we favour the second choice, i.e., we have two syntactical categories, one for
bound variables and constants represented by V and another for unification
variables, called metavariables and represented by X. Although this choice is
not the more economical, it eases the understanding of higher order unification as
equational unification.
Thus *-calculus is defined as an algebra defined on a set X of variables (our
metavariables, written X, Y, ...) and a set of operators containing a set of constants
V (the variables of the calculus of Section 1.2, written x, y, ...), a set of unary
abstractors indexed on V, and the application.
Definition 1.4. 4(V, X), the set of open *-terms, is inductively defined as
a ::=x | X | (a a) | *x .a
where x # V and X # X.
We have now two notions of substitution. The first works on V and is needed
for ;-reduction. The second works on X ; it is used for unification.
The substitution of elements of V (or V-substitution) is defined as above with
the extra clause
%(X )=X if X # X.
Let us turn now to the substitution of metavariables. Is it possible to reduce it
to a X-grafting? With the separation of name spaces, the first drawback of X-grafting
disappears: variables bound by a * are elements of V ; thus they remain unchanged
by an X-substitution. But, the second is still present. If we substitute a variable by
a term containing constants, some of them may be captured by abstractors as, for
instance, in [X [ x](*x .X )=*x .x. So we need to introduce the notion of substitution
with bound variables renaming.
189HIGHER ORDER UNIFICATION
Definition 1.5. Let % be a valuation (i.e., a function from X to 4(V, X)), the
substitution written % is the extension of the valuation such that:
1. % (X )=%(X ),
2. % (x)=x if x # V,
3. % (a b)=(% (a) % (b)),
4. % (*y .a)=*z .% ([ yz] a) where z is a fresh variable.
As usual % is also written %.
Remark. Grafting and reduction do not commute. For instance, consider
a=((*x .X ) y) and %=[X [ x]. Then a ;-reduces to X but %(a)=((*x .x) y) does
not reduce to %(X )=x. In the same way, the term *x . (X x) ’-reduces to X but
%(*x . (X x))=*x . (x x) does not reduce to %(X )=x.
Proposition 1.6. Substitution and reduction commute.
Proof. For ;-reduction we have ((*x .a) b) ; [xb] a and %((*x .a) b)=
(%(*x .a) %b)=(*z .%([xz] a) %b) ; [z%(b)](%([xz] a). So we have to prove the
equality %([xb] a)=[z%(b)](%([xz] a), but this is an application of the substitution
lemma [4] on commutation of substitutions.
For ’-reduction we have *x . (a x)  a and %(*x . (a x))=*z .%([xz](a x))=
*z .%([xz] a z) that reduces to %a as z has no occurrence in %[x [ z] a. K
1.4. *-Calculus in de Bruijn Notation
*-calculus deals with actual names for bound variables. It is well known that
these names are irrelevant both for computation and reasoning. Moreover, we need
to rename these bound variables in order to ensure the correctness of the substitution.
Thus substitution is not really defined on terms but on :-equivalence classes. This
name management may be avoided with another formulation of * -calculus: the
de Bruijn notation [14]. We give here a presentation slightly different from the
original one, as we add metavariables.
The intuitive idea of the de Bruijn notation is simple. To perform correctly the
;-reduction, it suffices to find the occurrences of the formal parameter which has to
be replaced by an actual one. In *-calculus with names, this is indicated by the
identity between the name of the variable at a given occurrence and the name of
the *’s variable of the ;-redex. It may also be indicated by the binding height of an
occurrence, that is, by the number of *’s one has to cross between this occurrence
and its binder.
Definition 1.7. The set 4DB(X) of *-terms in de Bruijn’s notation is defined
inductively as
a ::=n | X | * a | (a a),
where n is an integer greater than or equal to 1 and X # X (some authors use 0 as
the first de Bruijn number, see [10] for example).
190 DOWEK, HARDIN, AND KIRCHNER
Note that we replace bound variables and constants by indices, but we keep the
names for metavariables. This distinction is not done in the original de Bruijn
calculus.
In the original notation of de Bruijn, free variables of a term a are ordered into
a list (x0 } } } xn), called a referential and written R. The cons operation (i.e.,
addition of a name in front of a list) is written as usual by ‘‘ . ’’. Then, a is coded
as a subterm of *x0 } } } *xn .a. Here, only V-variables (i.e., bound variables and
constants, but not unification variables) are recorded in the referential R.
Definition 1.8. Let R be a referential. Let a # 4(V, X) such that all the free
V-variables of a are declared in R. The de Bruijn translation of a, written tr(a, R),
is defined by:
1. tr(x, R)=j, where j is the place number of the first occurrence of x in the
list R,
2. tr(X, R)=X,
3. tr((a b), R)=(tr(a, R) tr(b, R)),
4. tr(* x .a, R)=* (tr(a, x .R)).
So, during the de Bruijn translation, the referential is incremented when crossing
a *. For example, a closed * -term (i.e., without free V-variables) may be translated
in de Bruijn notation, according to an empty referential. Note that this translation
does not correspond to a bijection between V and N: a bound variable may be
represented by different numbers. For example, *x *y . (x(*z . (z x)) y) is written
*(*(2(* 1 3) 1)).
Definition 1.9. The *-height of an occurrence u in a term a is the number of
*’s at prefix occurrences of u. It is written |u|.
Let u be an occurrence of a de Bruijn number p in a given term tr(a, R).
If p|u|, then p is said to be bound in tr(a, R); otherwise it is a free index
of a representing a constant encoded as a V-variable at position p&|u| in the
referential.
In this context, it is natural to define the ;-reduction by
((* a) b)  [1b] a,
where [1b] is the substitution of the index 1 by the term b. So, we need now to
define this substitution which corresponds to the substitution of elements of V.
Suppose that ((* a) b) is expressed in a referential R, then b is also expressed in
R but a is expressed in x .R, where x is a name for the variable bound by the *.
The term a[1b] is expressed in R and is obtained from a by replacing the indices
referring to x in x .R by b. An index n at an occurrence u in a refers to this x if
and only if n=|u|+1. When we substitute such an index by b, this term b is placed
under |u| more *’s and must be correctly updated: indices in b referring to a
variable of the referential R have still to refer to the same variable. Therefore free
indices in b must be incremented by |u|. Also, as a is expressed in x .R and a[1b]
is expressed in R, all the free indices of a which do not refer to the first variable
191HIGHER ORDER UNIFICATION
of x .R must be decremented by 1. We first define the lifting operation that
increments by 1 all the free indices of a term.
Definition 1.10. Let a # 4DB(X). The term a+, called lift of a, is defined by
a+=lf t(a, 0) where lf t(a, i) is inductively defined by:
1. lf t((a1 a2), i)=(lf t(a1 , i) lf t(a2 , i)),
2. lf t(* a, i)= * (lf t(a, i+1)),
3. lf t(X, i)=X,
4. lf t(m, i)=m+1 if m>i,
m if mi.
Lemma 1.11. Let a be a term of 4(V, X) expressed in a referential R. Let v be
any variable of V, not belonging to R. Then, tr(a, R)+=tr(a, v .R).
Proof. It suffices to prove the following equality:
lf t(tr(a, x1 } } } xi .R), i)=tr(a, x1 } } } xi .v } R).
This is done by structural induction on a, for all i and all R. K
We now define the analogous of the V-substitution of 4(V, X). Here this sub-
stitution replaces indices.
Definition 1.12. The substitution by b at the *-height (n&1) in a, written
[nb] a, is defined by induction as follows:
[nb](a1 a2)=([nb] a1 [nb] a2)
[nb] X=X
[nb] * a=* ([n+1b+] a)
[nb] m=m&1 if m>n (m # FV(a))
b if m=n (m bound by the * of the Beta-redex)
m if m<n (m # BV(a)).
Definition 1.13. The ;-reduction is defined by:
((* a) b)  [1b] a.
Example 1.2. The term * x . ((* y . (x y)) x) is written *((*(2 1)) 1) in de Bruijn
notation. It ;-reduces to * x . (x x) when using explicit variable names or to
*([11](2 1))= *(1 1) in de Bruijn notation.
Remark. To substitute a term b for an index n in a term of the form *a, we sub-
stitute the index n+1 in a and we lift the term b. Usually, the lift of the actual
parameter b is done, not after each traversal of an abstractor, but globally, when
the formal parameter is reached. This choice is only a matter of taste.
Remark. The free indices are decremented by 1 by the substitution. Thus, the
same operation takes into account the replacement of 1 by b and the decrement of
192 DOWEK, HARDIN, AND KIRCHNER
all the free indices of a. Indeed [nb] replaces n by b and decrements by 1 all the
free indices that refer to an element of the referential greater than n. So we do not
define a general notion of simultaneous substitution [nb, mc] as the decrementing
effect of such a substitution would be more technical (see [40] and the full papers
[39, 41] for a complete development of this idea). The simultaneous substitution
which can be easily defined is the substitution of an initial segment of the natural
numbers [1a1 , 2a2 , ..., nan]. In this case all the other indices in the term have to
be decremented by n. Note that such a substitution is better represented as a list
a1 , ..., an than as a set of pairs.
We now turn to ’-reduction. This relation is defined, in the classical setting,
by the rule * x . (a x) ’ a, if x is not a free variable of a. Let R be a referential
containing the constants of a. As a is coded by tr(a, R) and * x . (a x) by
tr(*x . (a x), R)=*(tr(a, x } R) 1)=*(tr(a, R)+ 1), we get the following definition
for ’:
Definition 1.14. The ’-reduction in 4DB(X) is defined by the rule:
*(a 1)  b if b # 4DB(X) is such that a=b+.
Proposition 1.15. For a term a in 4DB(X), there exists a term b such that
a=b+ if and only if, for any occurrence u of an index p in a, p=% |u|+1.
Proof. The if part comes from the definition of b+ : lf t(m, i) is never equal to
i+1. For the only if part, it suffices to build, from a, the term b by replacing any
free number n of a by n-1. K
At last we define the X-substitution. As usual the notations % and % are identified
and the substitution %+ is defined by %+=[X1 a+1 , ..., Xn a
+
n ] when %=
[X1 a1 , ..., Xn an].
Definition 1.16. Let % be a valuation from X to 4DB(X); the associated
substitution % is defined by the rules:
1. % (X)=%(X),
2. % (n)=n,
3. % (a1 a2)=(% (a1) % (a2)),
4. % (*a)=*(% +(a)).
The relation between the substitution in *-calculus with names and the substitution
in *-calculus with de Bruijn indices is expressed by the following proposition.
Proposition 1.17. Let a # 4(V, X) and %=[X1a1 , ..., Xn an] be a term and a
substitution of the *-calculus with names. Let %$=[X1 tr(a1 , R), ..., Xn tr(an , R)],
then tr(%(a), R)=%$(tr(a, R)).
Proof. By induction on the structure of a. We only give the nontrivial case
a= * v .b, assuming that % is [Xc].
193HIGHER ORDER UNIFICATION
tr([Xc](* v .b), R)=tr(* w .[Xc][vw] b, R)
=* (tr([Xc][vw]b, w .R))
[Xtr(c, R)] tr(* v .b, R)=[Xtr(c, R)](* (tr(b, v .R)))
= * ([Xtr(c, R)+](tr(b, v .R)))
We have tr(b, v .R)=tr([vw] b, w .R) and, as w is a fresh variable, tr(c, R)+=
tr(c, w .R). So, we can apply the induction hypothesis, which allows the following
conclusion:
[Xtr(c, w .R)](tr([vw]b, w .R))=tr([Xc]([vw]b), w .R). K
1.5. *_-Calculus
The *_-calculi [1, 11] are first order rewriting systems introduced to provide an
explicit treatment of substitutions initiated by ;-reductions. They contain the
*-calculus, written in de Bruijn notation, as a proper subsystem, the ; and ’
reductions being simply the results of a particular strategy application of their rules.
They differ by their treatment of substitution, which leads to slightly different
confluence properties. Here, we shall use the *_-calculus described in [1] and we
try to give an intuitive presentation of it in the following.
Internalising operations as operators. Let us consider an algebra A whose
domain is denoted A and a computable operation F from A to A. For instance, let
us consider the set of natural numbers expressed with the symbols 0, S and the
function F that associates to each natural number its double: F(0)=0, F(S(0))=
S(S(0)), F(S(S(0)))=S(S(S(S(0)))), etc. A smooth way to define this operation is
to extend the term language by adding an operator f internalising the operation F
and rules rewriting expressions containing the symbol f into other expressions that
eventually do not contain the symbol f. For instance,
f (0)  0
f (S(X )))  S(S( f (X ))).
Indeed any computable function can be expressed this way, even using a linear
regular lonesome rule [13].
*-calculus is such an internalisation of the application operation on functional
expressions. Indeed, consider, for instance, the functional expressions e1=*x .x and
e2=0. The application operation is defined in such a way that e1 applied to e2 gives
0. Instead of defining the application operation directly one extends the expression
language such that ((*x .x) 0) is also an expression and set rewrite rules (;-reduction)
such that:
(*x .x) 0  0.
194 DOWEK, HARDIN, AND KIRCHNER
But, *-calculus internalises operations only half-way. Indeed application is
internalised, but substitution and variable renaming (or lifting) are still external
operations. *_-calculus goes one step further by internalising also substitutions and
lifting.
A first try. When the operation [nb] a is internalised as a term a[nb] and the
lifting operation a+ as (a A ), one meets several difficulties. In order to express
the rewrite rules for computing (a A ) one would need to introduce another operator
internalising the operation lf t. Then, the introduction of metavariables makes this
system nonconfluent. Indeed,
((*((*X ) Y )) Z)  ((*X ) Y )[1Z]  X[1Y][1Z],
and
((*((*X ) Y )) Z)  ((*X ) Y )[1Z]  (*X[2Z A ] Y[1Z])
 X[2Z A ][1Y[1Z]].
The term *((*X ) Y ) Z reduces to X[1Y][1Z] and to X[2Z A ][1Y[1Z]],
which are both normal.
Simultaneous substitutions. In order to find a common normal form to these two
terms, we introduce a notion of simultaneous substitution. We shall see that these
two terms reduce to a common normal form X[1Y[1Z], 2Z]. A simultaneous
substitution is nicely represented as a list of terms. Lists are represented as usual
with an operator cons (written ‘‘ . ’’) and an operator for the empty list (written id
as it represents the identity substitution). The substitution a1 .a2 } } } an . id replaces 1
by a1 , ..., n by an and decrements by n all the other ( free) indices in the term.
Then the operator A , which internalises the lifting operator a+, can be seen as
the infinite simultaneous substitution 2.3.4. ... . We also introduce a composition
operator b . Finally, the index n+1 is often written 1[ A b } } } b A ] or 1[ A n]. Note
that A 0 is conventionally equal to id and thus 1[ A 0]=1[ id]=1. For more
details see [1] and [11].
*_-calculus. Terms in this calculus are built as follows:
Definition 1.18. Let X be a set of term metavariables and Y be a set of substitution
metavariables. The set T*_(X, Y) of terms and of explicit substitutions is inductively
defined as
a ::=1 | X | (a a) | *a | a[s]
s ::=Y | id | A | a.s | s b s
with X # X and Y # Y.
One can also see T*_(X, Y) as a first order sorted algebra built on X, the set of
variables of sort term, Y, the set of variables of sort substitution, and the
operators described by:
195HIGHER ORDER UNIFICATION
1 : ( term
() : term term ( term
(* ) : term ( term
[] : term substitution ( term
id : ( substitution
A : ( substitution
 . : term substitution ( substitution
 b  : substitution substitution ( substitution.
Note that since the arrow is a very overloaded symbol, in particular in this paper
(where it is used at least for rewriting and as a type constructor), we prefer to represent
the rank information using the arrow ( . The set of variables of a term a of sort
term is denoted by TVar(a).
General Assumption. Except if explicitly mentioned, we are always assuming
that all the terms considered do not contain any substitution variable.
Notation. The term ((((a a1) a2) } } } ) an) is written as usual (a a1 } } } an).
The *_-calculus is defined as the term rewriting system defined in Fig. 1. The
rewrite rules in *_ can be read as equational axioms and they define an equational
theory whose congruence is denoted =*_ . If we drop the rules Beta and Eta, we
get the rewriting system _, which performs the application of substitutions. The
corresponding equational theory is written =_ .
For ’-reduction it would be natural to have the axiom
a=*(a[ A ] 1).
Unfortunately if we orient this equational axiom as a rewrite rule *(a[ A ] 1)  a,
an infinite set of critical pairs is generated (and provides a nice open problem to the
FIG. 1. *_The *_-term rewriting system.
196 DOWEK, HARDIN, AND KIRCHNER
schematisation community [32, 8]), so we rather express it as the conditional
rewrite rule Eta.
The main properties of *_ are:
1. The term rewriting system *_ is locally confluent on any *_-term, open or
closed [1].
2. *_ is confluent on substitution-closed terms (i.e., on terms without
substitution variable) [44].
3. *_ is not confluent on open terms (i.e., terms with term and substitution
variables) [11].
The patterns of the normal forms of *_-terms of sorts term and substitution
are given by the following results:
Proposition 1.19 [44]. Any *_-term in normal form for *_ is of one of the
following forms:
1. * a where a is in normal form,
2. (a b1 } } } bp), where a and the bi are in normal form and a is either 1, 1[ A n],
X, or X[s] where s is a substitution term in normal form and different from id,
3. a1 } } } ap } A n, where a1 , ..., ap are in normal form and ap {n.
In *-calculus with names (resp. with de Bruijn indices) we have a rule X[ yt]=X
where y is an element of V (resp. a de Bruijn index). This rule is needed because
we have no way to suspend the substitution [ yt] until X is instantiated. In
*_-calculus we can delay the application of this substitution as the term X[s] does
not reduce to X. Note that, in particular, the condition a=_ b[ A ] is stronger than
a=b+ as X=X+ in *-calculus but there exists no term b such that X=_ b[ A ].
The application of a substitution to a metavariable can be suspended until the
metavariable is instantiated. This will be used to code substitution of variables in
X by X-grafting and explicit lifting. Thus a notion of X-substitution in *_-calculus
is not needed.
By definition of rewriting, the *_-reduction relation is compatible with first order
substitution, which is, as already said, called grafting here. So we get the following
proposition.
Proposition 1.20. X-grafting and *_-reduction commute.
2. ADDING TYPING INFORMATION
As said in the Introduction, the right framework for performing unification is
typed *-calculus. So we are now introducing types for the calculi presented above.
2.1. Typed *-Calculus with de Bruijn Indices
Contexts are used to record the types of free variables. In *-calculus with de
Bruijn indices, these contexts are lists of types. For instance, the context
A1 .A2 } } } An .nil associates the type Ai to the index i.
197HIGHER ORDER UNIFICATION
Definition 2.1. The syntax of simply typed *-calculus using de Bruijn indices is
Types A ::=K | A  B
Contexts 1 ::=nil | A .1
Terms a ::=n | X | (a b) | *A .a
with X # X, and the typing rules are:
(var 1) A .1 |&1 : A
(var+)
1 |&n : B
A .1 |&(n+1) : B
(lambda)
A .1 |&b : B
1 |&*A .b : A  B
(app)
1 |&a : A  B 1 |&b : A
1 |&(a b) : B
.
Notation. The length of a context 1 is written |1 |.
In a calculus with metavariables, to each metavariable X we associate a unique
type TX . We assume that for each type T there is an infinite set of variables X such
that TX=T and we add the typing rule
(Metavar) 1 |&X : TX ,
where 1 is any context. This means in particular that the type of variable is
imposed to be independent of the context where it appears.
Remark. Typing and grafting are not compatible. Indeed, consider the context,
1=A . (A  A)  (B  A)  A .nil,
and a variable X of type A, then we have:
1 |&(2 *A .X *B .X ) : A.
The variable X and 1 have the same type A in 1, but when applying the grafting
[X [ 1] we get the term (2 *A .1 *B .1) which is not well typed.
Proposition 2.2. Typing and substitution are compatible; i.e., if X is a variable of
type B and 1 |&a : A and 1 |&b: B then 1 |&[Xb] a : A.
Proof. By induction on the structure of a.
1. If a=X, then A=B.
2. If a=n then [Xb] a=n.
198 DOWEK, HARDIN, AND KIRCHNER
3. If a=(a1 a2), we conclude with the induction hypothesis.
4. If a= *C .a1 then A=C  D and C .1 |&a1 : D. As [Xb] *C .a1= *C .
([Xb+]a1), in order to apply the induction hypothesis we need to know that
C .1 |&X : B, which is true by definition, and that C .1 |&b+ : B. In order to prove
this last fact, i.e., that if 1 |&b : B, then C .1 |&b+ : B, we prove the more general
result:
If Ci } } } C1 .1 |&b : B then Ci } } } C1 .C .1 |&lf t(b, i) : B.
This is done by induction on the structure of b.
(a) If b=X, then lf t(b, i)=X.
(b) If b=n. If n>i then the type of n in Ci } } } C1 .1 is the one of n&i in
1. The type of lf t(n, i)=n+1 is the one of n+1&(i+1) in 1. If ni then the type
of n is Ci&n+1 in both cases.
(c) If b=(b1 b2), we conclude with the induction hypothesis.
(d) b=*D .c then B=D  E and D .Ci } } } C1 .1 |&c : E. By the induction
hypothesis D .Ci } } } C1 .C .1 |&lf t(c, i+1): E, thus Ci } } } C1 .C .1 |&lf t(*D .c, i) : C. K
2.2. Typed *_-Calculus
In *_-calculus, we need to type not only terms, but also substitutions. As
contexts are lists of types, they are used as types for substitutions which are merely
lists of terms. We use the notation s f 1 to express the fact that the substitution
s has type 1 .
Definition 2.3 [12, 1]. The syntax of typed *_-calculus is
Types A ::=K | A  B
Contexts 1 ::=nil | A .1
Terms a ::=1 | X | (a b) | *Aa | a[s]
Substitutions s ::=id | A | a .s | s b s
with X # X. The typing rules are:
(var) A .1 |&1 : A
(lambda)
A .1 |&b : B
1 |&*A b : A  B
(app)
1 |&a : A  B 1 |&b : A
1 |&(a b) : B
(clos)
1 |&s f 1 $ 1 $ |&a : A
1 |&a[s] : A
(id ) 1 |&id f 1
(shift) A .1 |& A f 1
199HIGHER ORDER UNIFICATION
(cons)
1 |&a : A 1 |&s f 1 $
1 |&a .s f A .1 $
(comp)
1 |&s" f 1" 1" |&s$ f 1 $
1 |&s$ b s" f 1 $
.
Remark. Note that a and a[s] have the same type, but in general are in
different contexts. For instance, we have:
nat .nil |&1 : nat
and
nat .nil |& id f nat .nil ;
thus
nat .nil |&1 . id f nat .nat .nil.
As we have also
nat .nat .nil |&2 : nat,
we deduce
nat .nil |&2[1 . id ] : nat.
The reduction rules of typed *_-calculus are simply defined by adding to the
rules in *_ the relevant typing information. Below are the rules from *_ where type
information has been added; the other rules are unchanged:
Beta (*Aa) b)  a[b . id ]
Abs (*A a)[s]  *A(a[1 . (s b A )]).
Note that the typed version of _ has the same properties (termination and
confluence) as the untyped one. One can also clearly type the eta rule. The resulting
term rewriting system is also called *_.
When we consider a calculus with metavariables, we want more than in
*-calculus, as we want that typing and grafting to be compatible. Thus, to each
metavariable X we associate a unique type TX and a unique context 1X . We assume
that for each pair (1, T) there is an infinite set of variables X such that 1X=1 and
TX=T. We add to the previous typing rules the following one, in order to type
metavariables:
(Metavar) 1X |&X : TX .
200 DOWEK, HARDIN, AND KIRCHNER
Proposition 2.4. Grafting and typing are compatible; i.e., if X is a variable and
b be a term such that 1X |&b : TX then for every 2, a, and A such that 2 |&a : A we
have 2 |&[X [ b] a : A and for every 2, s, and 2$ such that 2 |&s f 2$ we have
2 |&[X [ b] s f 2$.
Proof. By a simultaneous induction on the structure of typing derivation of
2 |&a : A and 2 |&s f 2$. K
Associating to every metavariable a type and also a context is a strong require-
ment. For instance, neither the term a=(Y X X[ A ]) nor the term b=(Y *X X )
can be typed in any context. Indeed if, for instance, a were typeable in a context
1 then both X and X[ A ] should be typed in 1. Thus X should be typed both
in 1 and in A .1 which is impossible by the rule above. We exclude such terms on
purpose: in *_-calculus we are more interested in grafting than in substitution.
Grafting the index 2 to X in the first term would give the term (Y 2 3), and thus
the two occurrences of X would refer to different variables of the context.
Proposition 2.5. The typed *_ calculus is:
v confluent [44],
v weakly normalising; see, for example, [38] or [22].
Let us now present the notion of ’-long normal form that is used in the rest of
this work.
Definition 2.6 (’-long normal form). Let a be a *_-term of type A1  } } } 
An  B in the context 1 and in *_-normal form. The ’-long normal form of a, written
a$, is defined by:
1. If a=*C b then a$= *C b$,
2. If a=(k b1 } } } bp) then a$= *A1 } } } *An(k+n c1 } } } cp n$ } } } 1$), where ci is
the ’-long normal form of the normal form of bi [ A n].
3. If a=(X[s] b1 } } } bp) then a$= *A1 } } } *An(X[s$] c1 } } } cp n$ } } } 1$), where
ci is the ’-long normal form of the normal form of bi [ A n] and if s=d1 } } } dq . A k
then s$=e1 } } } eq . A k+n where e i is the ’-long form of d i [ A n].
This definition is well founded as we now prove using an induction based on the
lexicographic ordering on the triple consisting in the number of occurrences of
metavariables the size of the term and the size of its type. The size of a normal term
is defined by:
1. | * a|=1+|a| ,
2. |(n a1 } } } ap)|=1+|a1 |+ } } } +|ap | ,
3. |(X[s] a1 } } } an)|=1+|a1 |+ } } } +|an |.
The size of a type is defined as usual by |A  B|=1+|A|+|B| where the size of
an atomic type is 1.
Lemma 2.7. For any *_-normal term a we have |(a[1 } } } p . A n])|=|a|.
Proof. By induction on the structure of a. K
201HIGHER ORDER UNIFICATION
Lemma 2.8. Definition 2.6 is correct and well founded.
Proof. In case 1, the number of occurrences of metavariables is kept and the
size of the term is strictly decreasing. In case 2, when p{0 the number of meta-
variables is decreasing and the size of the term is strictly decreasing, and when
p=0, the type is strictly decreasing. In case 3, the number of metavariables is
strictly decreasing. K
Definition 2.9. The long normal form of a term is the ’-long form of its ;’-normal
form.
Proposition 2.10. Two terms are ;’-equivalent if and only if they have the same
long normal form.
Remark. Note that in *_-calculus, the reduction of a ’-redex may create a
_-redex. For instance, the term X[* (2 1) . A ] reduces to X[1 . A ] then to X[id ]
and then to X. Thus to compute the long normal form we need to reduce all the
redexes (including the ’ ones) before expanding the term.
Note also that substitutions also could be written in extensional forms by using
a kind of surjective pairing: id could be rewritten in (1 . A ) when type permits. But
we do not make these expansions in this work.
2.3. A First Order Specification of Typed *_-Calculus
In this paper our goal is to use the usual tools of first order equational unification,
such as narrowing. Thus we need to show that the above term rewriting system can
be expressed in a first order many-sorted fashion. This is the purpose of this section.
Let us first determine the sorts we are using. For a given term a of the calculus,
since the type A of this term makes sense only in some context 1, we consider this
context as the first part of the sort of a term, the second part of which is simply
the type itself. A sort for a term is thus a couple which is denoted 1 |&A and a sort
for a substitution is similarly a couple of two contexts denoted 1 |&1 $. This brings
us to the following formal definitions that are given in an ELAN [30]-like syntax.
module SortLangage [BaseType]
sort Type Context TermSort SubstitutionSort;
op
 : BaseType ( Type;
 : Type Type ( Type;
nil : ( Context ;
 }  : Type Context ( Context ;
|& : Context Type ( TermSort ;
|& : Context Context ( SubstitutionSort ;
end of module
We use the elements in TermSort and SubstitutionSort for sorting our
*_-terms. Note that we get a refinement of the unsorted case in the sense that the
two sorts term and substitution are now expanded in all the elements of
TermSort and SubstitutionSort .
202 DOWEK, HARDIN, AND KIRCHNER
We introduce an infinity of new symbols that are the disambiguations of the
operators 1, , * , [], id, A , . , b by the appropriate type and context. We assign
to each variable a sort 1 |&A. Note that this coding is consistent with the fact that,
in *_-calculus, each metavariable is associated to a unique context and type. Then
we give a rank to these symbols. These ranks are rephrasing of the typing rules of
Definition 2.3, but here we simply use the usual rules for typing many-sorted terms
with the assigned ranks.
11A : ( A .1 |&A
()
1
A  B, A : 1 |&A  B 1 |&A ( 1 |&B
(*)1A, B A .1 |&B ( 1 |&A  B
[]
1, 1 $
A : 1 $ |&A 1 |&1 $ ( 1 |&A
id 1 : ( 1 |& 1
A 1A : ( A .1 |&1
.
1, 1 $
A  : 1 |&A 1 |&1 $ ( 1 |&A .1 $
 b
1, 1 $, 1"
 : 1 |&1" 1" |&1 $ ( 1 |&1 $
A sort 1 |&A is naturally interpreted as the set of all the ground terms that have
type A in the context 1. Note that there may be empty sorts; for instance, the sort
A .nil |&B is empty while the sort A .nil |&A is not.
One can also formalise the same first order signature by using a polymorphic
order-sorted signature as in [24], in which case the set of operators remains the
same and becomes overloaded on the appropriate sorts.
Example 2.1. Using these notations, the term (11A  B 1
1
A) is not well formed
since the first argument of the application is of sort A  B .1 |&A  B and the
second one is of sort A .1 |&A which does not match the sort specification of the
application. On the contrary one can check that the term (1A .1A  B 1
1
A [ A
A .1
A  B]) is
well formed.
From this infinite set of symbols one can deduce the respective (infinite) set of
rewrite rules expanding the *_ rewrite rules.
Proposition 2.11. Let a be a well-typed *_-term in a context 1. There is a
unique well-sorted term a$ that is a disambiguation of a.
Proof. By induction on the term structure. K
Proposition 2.12. The sorted reduction system is weakly normalising and confluent.
3. DEALING WITH FREE VARIABLES
Unifying two terms a and b in *-calculus is finding a substitution % such that
%(a)=%(b). The main difference between unification in *-calculus and equational
unification is that equational unification is a search for graftings and unification
203HIGHER ORDER UNIFICATION
in *-calculus is a search for substitutions. Thus, a unifier in *-calculus of the
problem
*X=?;’ *2
is not a term t=%X such that *t=*2, which would be a *_-unifier, but a term
t=%X such that
*(t+)=*2
as (*X)[Xt]=*(t+) and not *t. But, if t does not contain any metavariable,
then t+=_ t[ A ]. Therefore a closed unifier in *-calculus is also a term such
that *(t[ A ])=*2, i.e., a solution of the equational problem *(X[ A ])=?;’ *2. The
translation of the *-term *X to the *_-term *(X[ A ]) is called precooking. This
translation will be used in Section 5 in order to reduce higher order unification to
unification in *_.
3.1. Precooking
Since in *_-calculus metavariables have both a context and a type, when translating
a *-term a in *_ we need to assign a context to each metavariable X of a. We
choose the one of a.
Definition 3.1. Let a # 4DB(X) such that 1 |&a : T. To every variable X of type
U in the term a, we associate the type U and the context 1 in *_-calculus. The
precooking of a from 4DB(X) to T*_(X) is defined by aF=F(a, 0) where F(a, n) is
defined by:
1. F((*Ba), n)=*B(F(a, n+1)),
2. F(k, n)=1[ A k&1],
3. F((a b), n)=F(a, n) F(b, n),
4. F(X, n)=X[ A n].
Proposition 3.2. If 1 |&a : T in 4DB(X), then 1 |&aF : T in *_-calculus.
Proof. We prove the following more general result.
If A1 } } } An .1 |&a : T in *-calculus, if every variable of a is associated to the
context 1, then A1 } } } An .1 |&F(a, n) : T.
This is done by induction on the structure of a, for all n.
1. a=*B .b ; Then T=B  C and B .A1 } } } An .1 |&b : C. So B .A1 } } } An .1 |&
F(b, n+1) : C and A1 } } } An .1 |&F(* b, n)= * (F(b, n+1)) : B  C.
2. a=X; By definition, in *-calculus, 1 |&X : T. By hypothesis, in *_-calculus,
1 |&X : T and A1 } } } An .1 |&X[ A n]=F(X, n) : T.
3. The cases a=n and a=(a1 a2) are easy.
The following proposition relates X-substitution in 4DB(X) and X-grafting in
*_-calculus and justifies the precooking.
204 DOWEK, HARDIN, AND KIRCHNER
Proposition 3.3. Let a, b1 , ..., bp be *-terms in de Bruijn notation. Then:
(a[X1 b1 , ..., Xp bp])F=[X1 [ b1F , ..., Xp [ bpF] aF .
Proof. We prove by induction on the structure of a the more general statement
that for all i :
F(a[X1 b+
i
1 , ..., Xp b
+i
p ], i)=[X1 [ b1F , ..., Xp [ bpF] F(a, i).
The result follows for i=0. The only difficult point is when a is one of the Xj , say
X ; in this case we need
F(b+i, i)=F(X, i)[X [ bF],
i.e.,
F(b+i, i)=bF[ A i].
To prove this, we show by induction on the structure of b that for all i and k:
F(lf ti (b, k), i+k)=F(b, k)[1 } } } k . A i+k].
v If b=m and mk then lf ti (m, k)=m; thus F(lf t i (b, k), i+k)=m and
F(b, k)[1 } } } k . A i+k]=m also.
v If b=m and m>k then lf ti (m, k)=m+i; thus F(lf ti (b, k), i+k)=m+i and
F(b, k)[1 } } } k . A i+k]=m+i also.
v If b=X, we get X[ A i+k] for the two members.
v If b= *c, then lf t(b, k)= * (lf t(c, k+1)), so lf ti (b, k)= * (lf ti (c, k+1)).
Then, F(lf ti (b, k), i+k)= * (F(lf ti (c, k+1), i+k+1)) and F(b, k)[1 } } } k . A i+k]
= * (F(c, k+1)[1 } } } k+1 . A i+k+1]) and we conclude using the induction hypothesis.
v If b=(c d ). By induction.
Proposition 3.4. Let a be a * -term.
1. If a w; b, then aF w
*_ bF .
2. If a w’ b, then aF w
’ bF .
3. If a is ;’-normal then aF is *_-normal.
4. a=;’ b if and only if aF=*_ bF .
Proof. 1. We show that if a w; b, then for every n, F(a, n) w*_ F(b, n) and the
result follows for n=0. This is done by structural induction on a, the only non-
trivial case is a=(*a1) a2 , where we need to show a substitution lemma:
F(a1 , n+1)[F(a2 , n) .id]=F(a1[1a2], n).
205HIGHER ORDER UNIFICATION
We show a more general lemma, for all n and p:
F(a1 , n+1+ p)[1 } } } p } (F(a2 , n) . id ) b A p]=F(a1[p+1a+p2 ], n+ p).
This is done again by structural induction on a1 , for all n and p. All cases are easy
computations but the one a1=p+1, which makes a2 appear. We need to prove:
F(a2 , n)[ A p]=F(a+p2 , n+ p).
This is done by induction on p. As F(a2 , n)[ A p+1]=_ (F(a2 , n)[ A p])[ A ], we get
by induction hypothesis, F(a2 , n)[ A p+1]=F(a+p2 , n+ p)[ A ]. We conclude using
the following equality,
F(b, n)[ A ]=F(b+, n+1),
which is derived from the more general fact:
F(b, n+r)[1 } } } r . A r+1]=F(lf t(b, r), n+r+1).
This follows from an easy induction on b.
2. We have (*(b+ 1))F=*(F(b+, 1) 1); thus we need to show that F(b+, 1)
=bF[ A ]. But we have proved, in the previous proposition, the following more
general result
F(lf ti (b, k), i+k)=F(b, k)[1 } } } k . A i+k].
3. By induction on the structure of a.
4. If a=;’ b then aF=*_ bF by induction on the structure of the proof of the
derivation a=;’ b. Conversely, if aF =*_ bF then let a$ be the normal form of a and
b$ be the normal form of b. The term aF reduces to a$F and bF reduces to b$F . Thus
a$F =*_ b$F . As these terms are normal, we have a$F=b$F . As the precooking translation
is injective we get a$=b$ and thus a=;’ b.
Proposition 3.5. Let a and b be two * -terms. There exists terms N1 , ..., Np such that
a[X1N1 , ..., XpNp]=;’ b[X1 N1 , ..., XpNp] if and only if there exists terms
M1 , ..., Mp in the image of the precooking translation such that [X1 [ M1 , ...,
Xp [ Mp] aF=*_ [X1 [ M1 , ..., Xp [ Mp] bF .
Proof. By Propositions 3.3 and 3.4
3.2. On the Use of Substitution Variables
Since in *_-calculus substitutions are explicit, another way to formulate unification
problems could be to find an explicit substitution _ such that a[_]=*_ b[_] which
means to solve in the algebra T*_(Y) the equation a[Y]= ?*_ b[Y] modulo the
equational theory *_. Surprisingly, such an approach leads also to the formalism
presented in the previous section. Let us detail why.
206 DOWEK, HARDIN, AND KIRCHNER
The term grafted to Y should necessarily be of the form
Y [ a1 } } } ap } A n,
where p is the length of the type of Y, i.e., the number of free variables in a
and b.
Thus we can now see this problem as finding terms a1 , ..., ap such that
a[a1 } } } ap } A n]=*_ b[a1 } } } ap } A n];
i.e., we are looking for a grafting % of term variables, a *_-unifier of:
a[X1 } } } Xp } A n]=?*_ b[X1 } } } Xp } A
n].
Let us now concentrate on one side of the equation, for example the one concerning
a. Let us consider a free number i+k occurring at *-height k.
By *_-reduction of a[X1 } } } Xp } A n] we get
i+k[1 . (1 . ( } } } (X1 } } } Xp } A n) b A ) b A )],
which *_-normalises to Xi [ A k].
We thus exactly get the result of the precooking defined above. This means that
it is equivalent to formalise the problem of unification in *-calculus in the
*_-calculus either by solving the precooked equations in T*_(X) or by solving the
equation a[Y]=?*_ b[Y]. Since the first formulation is more suitable (in particular
it will be anyway the result of the normalisation of the term when using substitution
variables), we choose it in this work.
Note that the previous discussion permits the extension of a unification method
when we have simultaneously term variables and substitution variables. Of course,
this algorithm only makes sense if the typed *_-calculus with substitution variables
is confluent. Recall that the untyped *_-calculus with substitution variables is not,
but the problem is still open for the typed calculus.
4. UNIFICATION IN THE *_-CALCULUS
Now that we have seen how to translate equations on *-terms to equations on
*_-terms, we address the problem of solving such equations on *_-terms modulo
the equational theory *_. The problems we focus on are substitution-ground; i.e.,
they may contain term variables but no substitution variables.
The unification problems we consider in this section are conditional equational
first order unification problems; i.e., we use the fact that typed *_-calculus is a
conditional rewriting system (conditional because of the ’-rule) that is confluent
and weakly normalising and a solution to a unification problem is a grafting that
makes the two terms equal (compare to the usual presentation of unification in
*-calculus where a solution is a substitution).
207HIGHER ORDER UNIFICATION
Methods for conditional equational first order unification are well known. For
instance we could use the first order many-sorted equational theory presented by
the confluent set of rules *_ to perform (conditional) narrowing or better basic
conditional narrowing [27, 28, 35, 47]. But since the system is only weakly normalising
we would need to use techniques from [47] to show completeness. But this will be
highly inefficient since almost all rewrite rules initiate a narrowing derivation on
any *_-term. Thus we choose here to design a specific set of rules to perform
*_-unification.
4.1. Equational Unification
Let us first recall briefly the unification notions we will need in the following. For
details see [29].
Definition 4.1. Let F be a set of function symbols, X be a set of variables, and
A be an F-algebra. A (F, X, A)-unification problem (unification problem for
short) is a first order formula without negation or universal quantifier whose atoms
are T, F and s=?A t, where s and t are terms in T(F, X). We call an equation on
A any (F, X, A)-unification problem s=?A t.
Equational problems will be written as a disjunction of existentially quantified
conjunctions:

j # J
_w j 
i # Ij
si =?A ti .
When |J |=1 the problem is called a system. Variables w in a system written
P=_w i # I si =?A t i are called bound, while the other variables are called free.
Their respective sets are denoted by BVar(P) and Var(P).
Definition 4.2. An A-unifier of an (F, X, A)-unification system,
P=_w 
i # I
si=?A t i ,
is a grafting _ such that:
A<_w 
i # I
_ |X&w (si)=_ |X&w (t i).
A A-unifier of a (F, X, A)-unification problem D=j # J Pj , where all the Pj are
(F, X, A)-unification systems, is a grafting _ such that _ unifies at least one of
the Pj .
We denote by UA(D) the set of unifiers of D. This is abbreviated U(D) when A
is clear from the context. Similarly when clear from the context A-unifiers are
called unifiers and (F, X, A)-unification is called unification.
When the F-algebra considered is the quotient algebra of a set of terms by the
congruence defined by a set of equational axioms E, i.e., A=T(F, X)E, then we
denote =?A by =
?
E .
208 DOWEK, HARDIN, AND KIRCHNER
Definition 4.3. Given an equational problem P, CSUA(P) is a complete set of
unifiers of P for the algebra A if:
(i) CSUA(P)UA(P), (correctness)
(ii) \% # UA(P), __ # CSUA(P) such that _Var(P)A %, (completeness)
(iii) \_ # CSUA(P), Ran(_) & Dom(_)=<. (idempotency)
CSUA(P) is called a complete set of most general unifiers of P in A, and written
CSMGUA(P), if:
(iv) \:, ; # CSMGUA(P), :Var(P)A ; implies :=;, (minimality)
or in other words: any two graftings of CSMGUA(P) are not comparable for the
quasi ordering Var(P)A .
In order to find a complete set of unifiers, we intend to simplify a given unification
problem into simpler ones until one gets in an almost obvious way a description of the
set of unifiers. This simplification is very conveniently described by transformation
rules that are simply first order rewrite rule schemata. For example, considering a given
signature F=[ f, g, a], the transformation rule
Decompose P 7 f (s1 , ..., sn)=? f (t1 , ..., tn)
 P 7 s1=? t1 7 } } } 7 sn=? tn
transforms the unification problem
x=? a 7 f (x, a)=? f ( g( y), z)
into
x=? a 7 x=? g( y) 7 a=? z.
These rules are applied, for any unification problems P and Q, any equation e,
and any term t modulo the usual Boolean simplification rules described in Fig. 2,
where the connectors 6 and 7 are assumed to be associative and commutative
and where F denotes a unification problem without solution (the empty disjunc-
tion) and T a system always true (the empty conjunction). It is well known that this
system of transformations of equational problems preserves the set of unifiers.
This view of solving unification problems has been initiated by [23, 34] and is
fully developed in [29]. We can summarise it as follows. First choose the intended
solved forms that characterise which equational problems actually correspond to
most general unifiers or more generally to the desired simplified form of equational
problems (think of the so-called flexibleflexible equations). Then determine the
transformation rules: for each possible equational problem which is not in solved
form, write transformation rules replacing this set with an equivalent one. Finally
determine the appropriate control: this will determine which application of the
transformation rules is intended in order to reach the solved forms. This approach
corresponds in fact to express as a computational system the solving process [30].
209HIGHER ORDER UNIFICATION
FIG. 2. Simplif, simplification rules for unification problems.
4.2. Transformation Rules for *_-Unification
Let us first specialise the definitions of the previous section to *_-terms:
Definition 4.4. A *_-unification problem P is a unification problem in the
algebra T*_(X) modulo the equational theory presented by *_. An equation of such
a problem is denoted a=?*_ b where a and b are two substitution-closed *_-terms
of the same sort in TermSort. An equation is called trivial when of the form
a=?*_ a. The set of variables of sort term in a unification problem P is denoted
TVar(P). The set of all *_-unifiers of a problem P is denoted U*_(P).
Remark. In a sorted language, we usually have a symbol = and thus an equa-
tion symbol =? for every sort. Thus in our case to each equation is associated in
a canonical way a context and a type.
Before giving a formal description of the algorithm we illustrate its principal
features. Since *_ is a confluent and weakly terminating system, equations can be
normalised. This is done by the rule Normalise presented in the set of transforma-
tion rules Unif given in Fig. 3. Then as a term *a reduces only to terms of the form
*a$ where a reduces to a$, an equation of the form *a=?*_ *b can be simplified to
a=?*_ b. This is done by using the rule Dec-*. In the same way, an equation
(n a1 } } } ap)=?*_ (n b1 } } } bp) can be simplified to a1=
?
*_ b1 , ..., ap=
?
*_ bp by the rule
Dec-App and an equation of the form (n a1 } } } ap)=?*_ (m b1 } } } bq) with n{m can
be simplified to the unsatisfiable problem F by the rule Dec-Fail, as it has no
solution.
As *_ is a weakly terminating system, we can restrict the search to normal ’-long
solutions that are graftings of the form [X [ *a] when the type of X is functional,
and [X [ (n a1 } } } ap)] and [X [ (Z[s] a1 } } } ap)] when the type of X is atomic.
210 DOWEK, HARDIN, AND KIRCHNER
FIG. 3. Unif, the basic rules for unification in *_.
When the type of a variable X is A  B, a step towards the solution [X [ *a]
is done by performing, using the rule Exp-*, the grafting [X [ *Y] where Y is a
new variable of type B. For instance, the problem (X 1)=?*_ 1 where X has type
A  A is transformed by the grafting [X [ *Y] into the problem ((*Y) 1)=?*_ 1
that reduces to Y[1 . id]=?*_ 1 where Y is a variable of type A.
Then, since Y has an atomic type, a normal solution of this last equation can
only be a grafting of the form [Y [ (Z[s] a1 } } } ak)] or [Y [ (n a1 } } } ak)]. A
211HIGHER ORDER UNIFICATION
grafting of the form [Y [ (Z[s] a1 } } } ak)] is obviously not a solution, as the normal
form of the term (Z[s] a1 } } } ak)[1 . id] is not 1. Thus all the solutions are of the
form [Y [ (n a1 } } } ak)]. A step toward such a solution is done by performing the
grafting [Y [ (n H1 } } } Hk)] where H1 , ..., Hk are new variables. In this example n
can only be 1 or 2, as otherwise the head variable of the normal form of
(n H1 } } } Hk)[1 . id] would be n&1 and thus different from 1.
More generally when we have an equation of the form X[a1 } } } ap . A n]=?*_
(m b1 } } } bq) where X has an atomic type, the solutions can only be of the form
[X [ (r c1 } } } ck)] where r # [1, ..., p] _ [m&n+ p]. A step towards this solution
is done by the rule Exp-app, instantiating X by (r H1 } } } Hk).
As usual, when describing unification algorithms by atomic transformation rules,
performing a grafting [X [ a] on a system P is implemented by first adding the
equation X=?*_ a to P and then using the rule Replace to propagate this constraint
on the variable X. This permits a description of the solutions of unification
problems as problems in solved forms and an allowance of the unification rules be
transformation rules preserving the solutions.
The only equations that are not treated by the rules above are of the form:
X[a1 } } } ap . A n]=?*_ Y[a$1 } } } a$p$ . A
n$].
As in *-calculus, such equations, called flexibleflexible, always have solutions.
Let us now formally define the concepts that we have just informally introduced
above.
Definition 4.5. A system P is a *_-solved form if all its metavariables are of
atomic type and it is a conjunction of nontrivial equations of the following forms:
Solved: X=?*_ a where the variable X does not appear anywhere else in P and
a is in long normal form. Such an equation is said to be solved in P, and the
variable X is also said to be solved.
Flexibleflexible: X[a1 } } } ap . A n]=?*_ Y[a$1 } } } a$p$ . A
n$], where X[a1 } } } ap . A n]
and Y[a$1 } } } a$p$ . A n$] are long normal terms and the equation is not solved.
Note that in the definition above some of the n, n$, p, p$ may be zero. Examples
of flexibleflexible equations are X=?*_ Y[X . A ] (i.e., X[id]=
?
*_ Y[X . A ]) or
X[1 . A 2]=?*_ Y[ A
3] which are well sorted in the appropriate context. These last
equations are solved forms but they contain unsolved variables.
Lemma 4.6. Any *_-solved form has *_-unifiers.
Proof. As solved equations define a part of the unifier we only need to solve the
flexible-flexible equations. Consider such an equation
B1 } } } Bn .1 |&ai : Ai B1 } } } Bn .1 |& A n f 1
B1 } } } Bn .1 |&a1 } } } ap . A n f A1 } } } Ap .1 A1 } } } Ap .1 |&X : T
B1 } } } Bn .1 |&X[a1 } } } ap . A n] : T
.
Thus 1X=A1 } } } Ap .1 and 2=B1 } } } Bn .1 for some 1. Thus |1X |=( |2|&n)+ p.
In the same way we get |1Y |=( |2|&n$)+ p$.
212 DOWEK, HARDIN, AND KIRCHNER
Now, for each atomic type T consider a variable ZT of sort nil |&T that does not
occur in P. Let % be the grafting that binds every nonsolved variable X of type T
to the term ZT [ A |1X |].
When we apply this grafting to the flexibleflexible equations we get:
ZT[ A |2|]=ZT[ A |2|].
And thus these equations are satisfied by this grafting; therefore all the equations
of %P are solved.
So, let , be the grafting binding every solved variable Y occurring in an equation
Y=?*_ t of %P to the term t. The grafting , b % is a *_-unifier to P. K
As mentioned before, in the previous definition the sort of Z is empty. We will
see in Section 5 that one can choose more interesting solutions when the problem
comes from the *-calculus.
The transformation rules needed for unification in the typed *_-unification are
described in Fig. 3. Additional unification rules given in Fig. 4 could be added to
the previous ones in order to improve efficiency and to avoid systematic replacement.
Remember that all these unification rules are applied together with the simplifica-
tion rules described in Fig. 2 which are applied eagerly. In order to show that the
Unif rules are correct and complete with respect to *_-unification, we shall now,
following the lines of [29], prove the following results:
v the Unif normal forms of equation systems are solved forms,
v the application of each rule in Unif preserves the set of *_-unifiers,
v for any *_-unifier # of a system S, there exists a solved form representing #.
The following lemmas formally present these different steps and their technical
requisites.
First, let us show that the Unif transformations do not introduce ill-typed terms:
Lemma 4.7. The transformation by the rules in Unif of a well-typed equation
gives rise only to well-typed equations T and F.
Proof. This follows from a rule by rule analysis of the transformation. K
Lemma 4.8. Any solved problem is normalised with respect to Unif. Conversely, if
a system P is a conjunction of equations irreducible by the rules of Unif, then it is
solved.
Proof. It is clear that any solved form is in normal form for Unif. Conversely,
let P be a nonsolved system; let us show that it is reducible by Unif. Since P is not
a solved form, it contains an equation a=?*_ a$ that is neither solved nor flexible
flexible.
The first possibility is to have an equation of the form X=?*_ a, where X appears
somewhere else in P, in which case Replace applies.
If a or a$ are not in long normal form, then we apply the rule Normalise.
213HIGHER ORDER UNIFICATION
The other cases where a and a$ are long normal termswhich allows us to infer
that if a is not a *-abstraction, then it has an atomic typeare summarised in the
following table, using the result of Proposition 1.19 to describe the form of the
terms involved and assuming that b9 and b9 $ both consist in at least one element.
Note that the table is symmetric.
a=?*_ a$ * b (n b9 ) (X[s]b9 ) or
(X b9 )
X[s] X
* b$ Dec-* Ill-typed Ill-typed Ill-typed Ill-typed
(n$ b9 $) Dec-App or Exp-* Exp-App Replace or
Dec-Fail Exp-App
(X$[s$] b9 $) or Exp-* Exp-* Replace or
(X$ b9 $) Exp-*
X$[s$] Flexibleflexible Flexibleflexible
or Replace
X$ Replace
K
Lemma 4.9. Any rule r in *_-Unif is correct, i.e.:
P [
r
P$ O U*_ (P$)U*_(P).
Proof. By easy inspection of the rules. K
Lemma 4.10. Any rule r in *_-Unif is complete, i.e.:
P [
r
P$ O U*_(P)U*_(P$).
Proof. Let us check it for all the rules:
Normalise: clear.
Dec-*: Assume that % is a *_-unifier of (* a=?*_ *b); then *%(a)=*_ *%(b) and
since no rule from *_ could be applied on top of these terms, we necessarily have
%(a)=*_ %(b).
Dec-App: Let % be a *_-unifier of
(n a1 } } } ap)=?*_ (n b1 } } } bp);
then since the system is weakly terminating and confluent on substitution-closed
*_-terms,
%(n a1 } } } ap)=*_{ %(n b1 } } } bp) 
(n %(a1) } } } %(ap))=*_{ (n %(b1) } } } %(bp)) 
\1ip, %(ai)=*_{ %(bi ),
214 DOWEK, HARDIN, AND KIRCHNER
which means that % is *_-unifier of :
P 7\ i=1 } } } p a i =
?
*_ b i+ .
Dec-Fail: The last proof schema shows that if n{m there is no % which is a
*_-unifier of :
P 7 ((n a1 } } } ap)=?*_ (m b1 } } } bq)).
Exp-*: If % is a *_-unifier of P and if X : 1 |&A  B # TVar(P), then %(X )=
a : A  B and we can assume that a is of the form *A a$ with a$ : B. Let us define
%$ such that \X # Dom(%), %$(X )=%(X ), and %$(Y )=a$. Then %$ is a *_-unifier of
P7 X=?*_ *A Y, which shows that % is a *_-unifier of _(Y : A .1 |&B), P7 X=
?
*_ *AY.
Exp-App: Since by hypothesis X[a1 } } } ap . A n]=?*_ (m b1 } } } bq) is unifiable by %,
the unifier should be such that %(X)=(r c1 } } } cs). Thus it verifies:
(r c1 } } } cs)[a$1 } } } a$p . A n] =?*_ (m b$1 } } } b$q) 
(r[a$1 } } } a$p . A n] } } } ) =?*_ (m b$1 } } } b$q) 
(1[ A r&1 b (a$1 } } } a$p . A n)] } } } )=?*_ (m b$1 } } } b$q).
So either rp in which case the equation becomes
(1[a$r } } } a$p . A n] } } } ) =?*_ (m b$1 } } } b$q) 
(a$r c1[a$1 } } } a$p . A n] } } } )=?*_ (m b$1 } } } b$q)
(in this case % is clearly solution of _H1 , ..., Hk , X=?*_ (r H1 } } } Hk)), or r>p in
which case the equation becomes
(1[ A n+(r& p)] } } } )=?*_ (m b$1 } } } b$q),
and it has a solution if and only if n+r& p=m, thus if r=m&n+ p, at the condi-
tion that r>p  m&n+ p>p  mn+1, which gives the condition asserted in
rule Exp-App.
So in all the cases, the grafting % is the solution of:
P 7 X[a1 } } } ap . A n]=?*_ (m b1 } } } bq)
7 
r # Rp _ Ri
_H1 , ..., Hk , X=?*_ (r H1 } } } Hk).
Note that the condition on m and n in fact allows us to cut the search space by
guessing the bindings that will not a priori fail. When rp then this corresponds
to the projection transformation in the higher order unification algorithm. When
rp this corresponds to the imitation transformation.
Replace: The proof works like in the first order case. K
215HIGHER ORDER UNIFICATION
4.3. A Complete Strategy for *_-Unification
It is clear that some strategies in applying the rules of Unif are not terminating.
A typical case is when the problem has no solution, it may not terminate. Another
example is that Exp-* can be applied infinitely many times on a system if no
replacement is done. We are thus proving the completeness of a particular class of
strategies which are built on any fair application of the following rules or group of
rules:
Normalise or Dec-* or Dec-App or Dec-Fail or Replace or
Exp-*R=(Exp-*; Replace) or
Exp-AppR=(Exp-App; Replace).
We call this class of strategies UnifReplace since it applies replacement eagerly after
a Exp-* rule. This principle can be modified, in particular using the merging rule
and an appropriate handling of the variables, in order to get a MartelliMontanari-
like unification algorithm for *_.
These rules are assumed to be applied in a fair way on the problem to be solved,
which means that in one disjunction of the systems, none of the constitutive systems
is left forever without applying transformation rules on it.
In order to present the completeness proof in a more comprehensible way, we
divide a problem P in two parts Q and R containing respectively the nonsolved and
solved equations of P. The idea of the proof is to show that all the above elemen-
tary groups of rules decrease a complexity measure based on the grafting % that we
want to mimic using the unification algorithm. For a solved system R consisting
only of solved equations, we denote by Graft(R) the canonical grafting associated
to R. For example if R=(X=?*_ a) then Graft(R)=[X [ a].
In all this section, we assume % to be a *_-normalised grafting solution of the
unification problem P.
Definition 4.11. For a system of equations P=(Q, R) and a *_-normalised
grafting % solution of P, we define the transformations (Q, R, %) r (Q$, R$, %$) as
follows:
1. (Q, R, %) Normalise (Q$, R$, %), where Q$ and R$ are the normalised forms
of Q and R as defined in Unif.
2. (Q 7 *A a=?*_ *Ab, R, %) 
Dec-* (Q$, R$, %), where:
v Q$=(Q 7 a=?*_ b) and R$=R when a=
?
*_ b is not solved (with respect
to Q 7 R),
v Q$=Q and R$=(R7 a=?*_ b) when a=
?
*_ b is solved.
3. (Q7 (n a1 } } } ap)=?*_ (n b1 } } } bp), R, %) 
Dec-App (Q$, R$, %), where Q$ consists
in Q and the unsolved equations (with respect to Q 7 R) in i=1..p ai=?*_ bi and R$
consists in R and the solved equations (with respect to Q 7 R) in i=1..pai=?*_ bi .
4. (Q 7 X=?*_ b, R, %) 
Replace ([X [ b](Q), R 7 X=?*_ b, %)
216 DOWEK, HARDIN, AND KIRCHNER
5. (Q, R, %)
Exp-*R
([X [ *AY] Q, R 7 X=?*_ *AY, %&[X [ *A a]+[Y [ a])
when %(X )=*A a.
6. (Q 7 X[a1 } } } ap . A n]=?*_ (m b1 } } } bq), R, %)
Exp-AppR
([X [ (r H1 } } } Hk)](Q 7 X[a1 } } } ap . A n]=?*_ (m b1 } } } bq),
R 7 X=?*_ (r H1 } } } Hk),
%&[X [ (r c1 } } } ck)]+[Hi [ ci])
when %(X )=(r c1 } } } ck).
We call this set of rules UStrat.
Lemma 4.12. For a system (Q, R) having for a solution the *_-normalised graft-
ing %, there is no infinite derivation issued from (Q, R, %) using the transformations
of UStrat.
Proof. We use as size of a grafting the sum of the sizes of the terms in its image:
|%|=t # Ran(%) |t|.
Let us first prove that there is no infinite sequence of rule applications involving
Dec-*, Replace, and Normalise. We define the complexity of a system P=(Q, R) to
be {(P)=( |Var(Q)|, [(}i , max( |ai |, |bi | )]ai =?*_ bi # Q), where } i=0 when ai and bi
are both in long normal form and 1 otherwise.
We compare the complexities lexicographically, using the standard ordering on
naturals for the first component and the multiset ordering for the second compo-
nent itself ordered by the lexicographic ordering on naturals (for a definition of
these orderings see [15]).
We check now that each application of one of the rules Dec-*, Replace, and
Normalise decreases the complexity of the system on which it is applied.
Replace decreases always the number of unsolved variables, i.e. |Var(Q)|.
Dec-* never increases }i since normal forms are preserved by decomposition,
and it always decreases the size of the equation to which it is applied.
Normalise may decrease the number of unsolved variables but always decreases
the size of one of the }i .
In order to prove the termination of the application of the whole set of rules, let
us add to the previous complexity measure of a system P a first component consist-
ing in the size of the grafting %: \(P)=(|%|, {(P)).
Since any application of Exp-*R or Exp-AppR makes the size of % strictly
decreasing and all the other transformations do not change it, this proves that the
application of the above transformations is terminating. K
The previous result can be refined in order to prove completeness when dealing
with rules like the merging rule in Fig. 4, by using a more sophisticated complexity
measure including the solving level of an equation. Since the rules in UStrat are
terminating, let us now see how they allow us to build the solutions:
217HIGHER ORDER UNIFICATION
Lemma 4.13. If % is *_-solution of the system Q and if (Q, R, %) r (Q$, R$, %$)
then %$ is a *_-solution of Q$ and :
% b Graft(R)=Var(Q, R)*_ %$ b Graft(R$).
Proof. For all the rules except the Exp-* ones, %=%$ and since the transforma-
tions preserve the solutions, %$ is a *_-solution of Q$. Note that the equality modulo
*_ is introduced by possible normalisation steps.
For the Exp-*R rule, because of the definition of % and of Q$, %$ is *_-solution
of Q$.
Let Z be a variable in Var(Q, R) then:
v if Z=X, in this case % should be such that
%(X )=(% b Graft(R))(X )=%(X )=*A a, and (%$ b Graft(R$))(X )=%$(*AY )=*Aa.
v if Z{X then by definition the two graftings give the same image of Z.
The proof is similar in the case of Exp-AppR. K
Lemma 4.14. Starting from the problem P0=(Q0 , R0) having the *_-normalised
*_-solution %0 and applying the rules defined in UStrat leads to a finite derivation,
(Q0 , R0 , %0)  (Q1 , R1 , %1)  } } }  (Qn , Rn , %n),
such that %0=Var(Pn )*_ %n b Graft(Rn) where %n is a solution of the solved form Qn .
Proof. Due to the definition of R0 , we have %0=%0 b Graft(R0).
Following the previous lemmas, the derivation issued from (Q0 , R0 , %0) should
be of finite length n and we get
%0 b Graft(R0)=Var(P0 )*_ %1 b Graft(R1)=
Var(P1 )
*_ } } }
=Var(Pn )*_ %n b Graft(Rn),
where Qn 7 Rn should be a solved form (otherwise this would not be the end of the
derivation by Lemma 4.8) and Var(P0)$Var(P1)$ } } } $Var(Pn) since the set of
variables of the unification problems (thus excluding the existentially bounded
variables) could only decrease, due to the Normalise rule. K
As mentioned before, we assume that the rules in Unif are applied using the
strategy UnifReplace in a fair way.
Theorem 4.15. The rules in Unif describe a correct and complete *_-unification
procedure in the sense that, given a *_-unification problem P:
v if Unif leads in a finite number of steps to a disjunction of systems such that
one of them is solved, then the problem P is *_-unifiable and a solution to P is the
solution constructed in Lemma 4.6 for a solved constitutive system,
v if P has a unifier % then the strategy UnifReplace leads in a finite number of
steps to a disjunction of systems such that one constitutive system is solved and has
% as a unifier.
218 DOWEK, HARDIN, AND KIRCHNER
FIG. 4. Unif+, more rules for unification.
Proof. By application of the previous results on termination, completeness and
correction. K
Remarks. 1. If the strategy UnifReplace terminates, the problem obtained is a
disjunction of systems that are all in solved form. This disjunction is a description
of a complete set of *_-unifiers of P consisting in the union of the *_-unifiers of all
the solved forms obtained.
2. We have shown how to solve *_-unification problems using the rules in
Unif with the strategy UnifReplace. This can be improved in many ways depending
on the use of such a procedure. In particular the use of the Merging rule, described
in Fig. 4, will give a Martelli and Montanari taste to the resulting algorithm.
3. In order to fail more often (note that the algorithm loops on equations like
X=(1 X )), one can introduce an occur-check rule as described in Fig. 4.
The Occur-Check rule needs to define the usual notion of variables on a strict
rigid path, denoted VarRS(a) and inductively defined on terms as follows:
v X # VarRS(* a) if X # VarR(a),
v X # VarRS(n a1 } } } an) if X # ni=1 VarR(ai),
v X # VarR(a) if X # VarRS(a),
v X # VarR(X[s] a1 } } } an).
For example, X is on a rigid path in (1 (X[Z] Y )), but Y and Z are not.
4. The use of a calculus of explicit substitution like *_, which allows substitu-
tion composition, is fundamental in order to allow a simple expression of the trans-
formation rules like Exp-App. Note also that the weak termination and confluence
on substitution ground terms (thus containing term variables) of the calculus is
crucial in the normalising rule. This allows us in particular to obtain solved forms
that describe the set of open *_-unifiers.
4.4. Comparison with Conditional Narrowing
As mentioned above, we could have used conditional narrowing instead of the
transformations above. The main difference between the two methods is that we are
exploiting our knowledge of the *_ term rewriting system to restrict the search space:
v As our system is normalising, we consider only normalised equations (as in
normalised narrowing).
v We deeply use the fact that * is a constructor, i.e., that a term of the form
*a reduces only to terms on the form *a$ such that a reduces to a$, to simplify equations
219HIGHER ORDER UNIFICATION
of the form *a=?*b to a=
?
*_ b. In the same way, a term of the form (n a1 } } } ap)
whose type is atomic reduces only to terms of the form (n a$1 } } } a$p) where ai reduces
on a$i ; we can simplify equations of the form (n a1 } } } ap)=(n b1 } } } bp) to a1=b1 , ...,
ap=bp and (n a1 } } } ap)=(m b1 } } } bq) with n{m to failure.
v As our system is normalising, we substitute only normal terms to variables.
As the long normal form of a closed term of a functional type is always *a and the
long normal form of a closed term of an atomic type is always (r a1 } } } ak), where
k is the arity of r, we consider only graftings of the form X [ *Y if X has a func-
tional type and X [ (r H1 } } } Hk) if X has an atomic type. When we have an
equation of the form X[a1 } } } ap . A n]=(m b1 } } } bq) where X has an atomic type
and when we take the grafting X [ (r H1 } } } Hk) we know that if r is different from
1, ..., p and m&n+p, then we can anticipate the failure of the grafting X [ (r H1 } } } Hk).
v Finally the flexibleflexible equations always have solutions.
Note that while the existence of solutions to flexibleflexible equations and the
failure anticipation just mentioned are properties of the system we are considering,
the use of normalisation and the simplification of rigid contexts are optimisations
to narrowing of course applicable to other theories.
4.5. Dropping the ’-Rule
Higher order unification algorithms come in two flavours according to the
considered equational theory: ;’-conversion or ;-conversion. The algorithms for
;’-conversion are simpler. Redundancy due to the synthesis of ’-equivalent solu-
tions is avoided and the use of the long normal form permits the determination of
the shape of a term in function of its type (a long normal term of type A  B is
always an abstraction). Nevertheless, algorithms can be designed for ;-conversion
alone. We show here how the algorithm above can be adapted to the theory *_, i.e.,
without using the eta axiom.
v When we have an equation of the form
(X[a1 } } } ap . A n] e1 } } } el)=?*_ (m b1 } } } bq)
we lose completeness if we apply only the rule Exp-* to X as a term of a functional
type need not be an abstraction anymore. We must also apply the rule Exp-App.
Thus the rule Exp-App must be rephrased, removing the condition that X has an
atomic type. Moreover we have to introduce some undeterminism between this rule
and Exp-*, leading to a single rule Exp.
Exp P 7 ((X[a1 } } } ap . A n] e1 } } } el )=?*_ (m b1 } } } bq))

P 7 (X[a1 } } } ap . A n] e1 } } } el )=?*_ (m b1 } } } bq)
7 
r # Rp _ Ri
_H1 , ..., Hk , X=?*_ (r H1 } } } Hk)
6 Q
220 DOWEK, HARDIN, AND KIRCHNER
if X is not solved
where H1 , ..., Hk are variables of the appropriate type not
occurring in P with the contexts 1Hi=1X , Rp is the
subset of [1, ..., p] such that (r H1 } } } Hk) has the
right type, Ri=if mn+1 then [m&n+p] else <
and Q=_Y X=?*_ *Y if X has a functional type
and Q=F otherwise.
v We have a new kind of equations that were forbidden when terms were in
long normal form:
(n a1 } } } ap)=?*_ *b.
These equations obviously have no solutions; thus we add the rule:
Dec-App-* P 7 ((n a1 } } } ap)=?*_ *b)  F.
v Also, a new kind of equations that were forbidden when terms were in long
normal form is:
(X[a1 } } } ap . A n] e1 } } } el)=?*_ *b.
For these equations, we can either instantiate X by a term of the form
(r H1 } } } Hk), r # [1, ..., p], or *Y. Thus we add the rule:
Exp2 P 7 ((X[a1 } } } ap . A n] e1 } } } el )=?*_ *b)

P 7 (X[a1 } } } ap . A n] e1 } } } el )=?*_ *b
7 
r # Rp
_H1 , ..., Hk , X=?*_ (r H1 } } } Hk)
6 _Y X=?*_ *Y
if X is not solved
where H1 , ..., Hk are variables of the appropriate type not
occurring in P with the contexts 1Hi=1X , Rp is
the subset of [1, ..., p] such that (r H1 } } } Hk) has
the right type.
In a similar way as with the eta rule, this extended set of transformation rules can
be proved correct and complete.
5. APPLICATION TO UNIFICATION IN *-CALCULUS
In this section, we prove that the higher order problem a=?;’ b has a solution if
and only if the precooked equational problem aF =?*_ bF has a solution. Moreover,
221HIGHER ORDER UNIFICATION
solutions of the higher order problem are completely described from the equational
solutions.
5.1. Grafting Unification and Substitution Unification
Proposition 5.1. Let a=?;’ b be a unification problem in 4DB(X). If the problem
a=?’ b has a solution, then the problem aF =
?
*_ bF also has a solution.
Proof. By Proposition 3.5, if the problem a=?;’ b has a solution [X1 t1 , ...,
Xn tn] then the grafting [X1 [ t1F , ..., Xn [ tnF] is a solution to the problem
aF =?*_ bF . K
We want now to prove the converse of this proposition, i.e., if the problem
aF=?*_ bF has a solution then the problem a=
?
;’ b also has a solution. To apply
Proposition 3.5, we need to show that if aF =?*_ bF has a solution, then it also has
a solution in the image of the precooking translation. To constructively prove this
statement, we use the completeness of the system Unif, i.e., the fact that if there
exists a solution to aF =?*_ bF , then this problem has a solved form. From this
solved form we build a solution in the image of the precooking translation. One of
the difficulties is the following. If we solve the flexibleflexible equations by the
grafting of Proposition 4.6 then we construct a grafting that is not in the image of
the precooking translation. For instance, consider the context 1=A .nil and the
variables X and Y with type A and context 1. Then for the equation X=?*_ Y
(which is not flexibleflexible in the sense of Definition 4.5 because it is solved, but
allows us to describe the problem), if we take the grafting X [ Z[ A ], Y [ Z[ A ]
we do not get a solution in the image of the precooking translation. In this case,
we must take, of course, X [ Z, Y [ Z. More generally, instead of taking the graft-
ing X [ ZT[ A |1X |] as solution of a flexibleflexible equation, we take the grafting
X [ ZT[ A |1X |&|1 |], where 1 is the context in which the initial problem is typed
and ZT is a metavariable of context 1 and type T. Thus, in order to be able to
apply Proposition 3.5 we must show that if the variable X has an occurrence in a
term of the form X[a1 } } } ap . A n] then we have p|1X |&|1 |. We prove now that
this proposition is an invariant of the system Unif.
Definition 5.2. Let 1 and 2 be two contexts, 1 is an extension of 2 if it has
the form 1=A1 } } } An .2. It is a strict extension if n{0.
For a context 1, a _-normal term a is called 1-stable if, for every variable X
occurring in a subterm of a of the form X[b1 } } } bp . A n], 1X is an extension of 1
and p|1X |&|1 |.
Proposition 5.3. Let 1 be a given context.
1. If a is a 1-stable term well typed in a context A1 } } } Ai .1 and pi, then the
_-normal form of a[1 } } } p . A p+1] is 1-stable.
2. If a is a 1-stable term well typed in a context A1 } } } Ai .1 and if b1 , ..., bp are
1-stable terms and pi, then the _-normal form of a[b1 } } } bp . A n] is 1-stable.
3. If a is a _-normal term well typed in a context A1 } } } Ai .1 and 1-stable, then
any _-normal term a$ obtained by reducing a is 1-stable. Thus, the normal form of
a is 1-stable. The long normal form of a is also 1-stable.
222 DOWEK, HARDIN, AND KIRCHNER
4. If a and b are _-normal terms 1-stable and well typed in the contexts
A1 } } } Ai .1 and B1 } } } Bj .1 then the _-normal form of [X [ b]a is 1-stable.
Proof. 1. By induction on the structure of a.
v If a=*a$ then a[1 } } } p . A p+1]=*(a$[1 .2 } } } p+1 . A p+2]). The term a$
is well typed in B .A1 } } } Ai .1 and is 1-stable, thus, by induction hypothesis
a$[1 .2 } } } p+1 . A p+2] is 1-stable. Therefore a[1 } } } p . A p+1] is 1-stable.
v If a=(a1 a2) or a is a de Bruijn index, the case is easy.
v If a=X[c1 } } } cq . A m] in this case we have q|1X |&|1 |. We get the
term
X[c1 } } } cq . A m][1 } } } p . A p+1];
i.e.,
X[c1[1 } } } p . A p+1] } } } cq[1 } } } p . A p+1] . ( A m b (1 } } } p . A p+1))].
The terms ci are well typed in the context A1 } } } Ai .1 ; thus by the induction
hypothesis, the _-normal forms of the terms
c1[1 } } } p . A p+1], ..., cq[1 } } } p . A p+1];
are 1-stables.
If mp we get
X[c1[1 } } } p . A p+1] } } } cq[1 } } } p . A p+1] . A m+1]
as q|1X |&|1 | and the _-normal forms of the terms c1[1 } } } p . A p+1], ...,
cq[1 } } } p . A p+1] are 1-stables, the _-normal form of a[1 } } } p . A p+1] is 1-stable.
If m<p we get the term
X[c1[1 } } } p . A p+1] } } } cq[1 } } } p . A p+1] .m+1 } } } p . A p+1].
The length of this substitution is r=q+ p&m. The term a=X[c1 } } } cq . A m] is
well typed in the context A1 } } } Ai .1 ; thus |1 |+i=|1X |&q+m. Thus,
r=q+ p&m= p+|1X |&|1 |&i
as pi we have r|1X |&|1 |. Then the _-normal form of a[1 } } } p . A p+1] is
1-stable.
2. By induction on the structure of a.
v If a=*a$ then a[b1 } } } bp . A n]=*a$[1 .b1[ A ] } } } bp[ A ] . A n+1]. The
term a$ is well typed in the context B .A1 } } } Ai .1 and is 1-stable. By the previous
remark, the terms 1, b1[ A ], ..., bp[ A ] are also 1-stable. Thus, by the induction
hypothesis the _-normal form of a$[1 .b1[ A ] } } } bp[ A ] . A n+1] is 1-stable. There-
fore a[b1 } } } bp A n] is 1-stable.
223HIGHER ORDER UNIFICATION
v If a=(a1 a2) or a is a de Bruijn index, the case is easy.
v If a=X[c1 } } } cq . A m] in this case we have q|1X |&|1 |. We get the
term
X[c1 } } } cq . A m][b1 } } } bp . A n];
i.e.,
X[c1[b1 } } } bp . A n] } } } cq[b1 } } } bp . A n] . ( A m b (b1 } } } bp . A n))].
The terms ci are well typed in the context A1 } } } Ai .1 ; thus by the induction hypo-
thesis, the _-normal forms of the terms c1[b1 } } } bp . A p+1], ..., cq[b1 } } } bp . A p+1]
are 1-stables.
If mp we get
X[c1[b1 } } } bp . A n] } } } cq[b1 } } } bp . A n] . A n+m& p].
As q|1X |& |1 | and the _-normal form of c1[b1 } } } bp . A n], ..., cq[b1 } } } bp . A n]
are 1-stable, the term a[b1 } } } bp A n] is 1-stable.
If m<p we get the term
X[c1[b1 } } } bp . A n] } } } cq[b1 } } } bp . A n] .bm+1 } } } bp . A n].
The length of this substitution is r=q+ p&m. The term a=X[c1 } } } cq . A m] is
well typed in the context A1 } } } Ai .1 ; thus |1 |+i=|1X |&q+m. Thus
r=q+ p&m= p+|1X |&|1 |&i
as pi we have r|1X |&|1 |. Therefore the _-normal form of a[b1 } } } bp . A n] is
1-stable.
3. When we reduce a ;-redex (*Ca)b occurring under j abstractions of type
B1 , ..., Bj , the term a is well typed in a context C .B1 } } } BjA1 } } } Ai1. This term
reduces to a[b . id]. Thus, by the previous point the _-normal form of a[b . id] is
1-stable.
When we reduce a ’-redex *C(a 1) occurring under j abstractions of type
B1 , ..., Bj , the term a is well typed in a context C .B1 } } } BjA1 } } } Ai1. This term
reduces to the _-normal form of the term a[Z . id] where Z is a fresh variable of
type C in the context B1 } } } Bj .A1 } } } Aj .1 ; by the previous point the _-normal form
of this term is 1-stable.
When we expand a term a in *(a[ A ] 1), the _-normal form of the term a[ A ]
is 1-stable and thus the term *(a[ A ] 1) is 1-stable.
4. By induction over the structure of a we show that the _-normal form of
[X [ b] a is 1-stable.
224 DOWEK, HARDIN, AND KIRCHNER
v if a=X[a1 } } } ap . A n] then [X [ b]a=b[[X [ b] a1 } } } [X [ b] ap . A n].
By the induction hypothesis, the _-normal forms a$1 , ..., a$p of the terms [X [ b] a1 , ...,
[X [ b] ap are 1-stable.
As the term a=X[a1 } } } ap . A n] is 1-stable, we have p|1X |&|1 |. As X and b
are well typed in the same context we have 1X=B1 } } } Bj .1; thus p j and the
_-normal form of b[a$1 } } } a$p . A n] is 1-stable. Therefore the _-normal form of
[X [ b] a is also 1-stable.
v If a=Y[a1 } } } ap . A n] then [X [ b] a=Y[[X [ b] a1 } } } [X [ b] ap . A n].
By the induction hypothesis, the _-normal forms a$1 , ..., a$p of the terms [X [ b] a1 , ...,
[X [ b] ap are 1-stable. Thus the _-normal form of [X [ b] a is 1-stable.
v if a is a de Bruijn index, an application, or an abstraction, we apply the
induction hypothesis. K
Proposition 5.4 (Invariants). Let a=?;’ b be a unification problem in 4DB(X)
well typed in a context 1. Consider a derivation of aF =?*_ bF in Unif. We have the
following invariants:
v if an equation of the derived problem is well typed in a context 2 then 2 has
the form A1 } } } An1,
v for every variable Y of the derived problem, its context 1Y has the form
B1 } } } Bp .1,
v for every subterm Y[a1 } } } ap . A n] of the derived problem we have
p|1Y |& |1 |.
Proof. By induction on the structure of the derivation, using Proposition 5.3 for
the rules Normalise and Replace.
As an immediate consequence of the previous proposition, all the solved forms
issued from a precooked problem in context 1 are 1-stables.
Proposition 5.5. Let 1 be a context, a a _-normal term, and T a type. If a is
1-stable and every variable X in a is such that 1X=1 then a is in the image of the
precooking translation.
Proof. Every occurrence u of a variable X belongs to a subterm of the form
X[a1 } } } ap . A n]. As a is 1-stable we have p|1X |&|1 |. As 1X=1 we have p=0.
Then as the term X[ A n] is well typed in some context B1 } } } B |u| .1 and the term X is
well typed in 1 we have n=|u|; thus a is in the image of the precooking translation. K
Proposition 5.6. Let a=?*_ b be a unification problem in 4DB(X). From any
solved form of aF=?*_ bF verifying the invariants above, we can construct a solution
to a=?;’ b.
Proof. Call P a solved form of aF =?*_ bF and 1 a context in which the initial
problem is well typed. Let % be the grafting associating to every nonsolved variable
X : 1X |&T of P, the term ZT[ A |1X |&|1 |], where ZT is a fresh variable of sort 1 |&T :
% : X : 1X |&T [ ZT[ A |1X | &|1 |] with Z : 1 |&T.
225HIGHER ORDER UNIFICATION
Since the term ZT[ A |1X |&|1 |] is 1-stable (just apply the definition), by applica-
tion of Proposition 5.3, the problem %(P) is 1-stable. Furthermore, % preserves the
solved variables of the system.
All the nonsolved variables occurring in the *_-normal form of %(P) are the ZT
and these variables are well typed in 1. Such a variable occurs in a subterm
ZT[a1 } } } ap . A n] and we have p|1Z |&|1 | , thus p=0 since 1Z=1 by definition.
The flexibleflexible equations appearing in the *_-normal form of %(P) have
necessarily the form ZT[ A m]=?*_ ZU[ A
n]. By definition of an equation, the terms
ZT[ A m] and ZU[ A n] are well typed with the same type and in the same context,
so we have T=U and m=n. Therefore, the flexibleflexible equations of the normal
form of %(P) relate identical terms. The grafting % is thus a solution of the flexible
flexible equations of the solved form P.
Consider the grafting , that binds every variable X to the term c, where X=?*_ c
is a solved equation of %(P). The grafting , is a solution of %(P), thus , b % is a
solution of P and thus of aF=?*_ bF .
Consider a variable X that occurs in the initial problem aF=?*_ bF and in the
solved form P. Then either no solved equation of the form X=?*_ c occurs in P and
, b %(X) is some ZT or , b %(X) is %(c). In both cases, the term , b %(X ) is 1-stable
(since c is 1-stable as well as %(c)) and every variable Z occurring in this term is
such that 1Z=1.
As the variable X occurs in the problem aF=?*_ bF we have by definition 1X=1.
Then the term , b %(X) is 1-stable and every variable Z occurring in , b %(X ) is such
that 1Z=1 thus by Proposition 5.5, , b %(X ) is in the image of the precooking
translation. Therefore a=?;’ b has a solution. K
Remark. The variables ZT remaining in the solution defined in the last proof
have the sort 1 |&T. Provided that there is a term of every atomic type in 1, this
sort is not empty. This contrasts with the solution built in Lemma 4.6 where the
variables ZT have the sort nil |&T which is empty.
Corollary 5.7. Let a=?;’ b be a unification problem in 4DB(X). If the unifica-
tion problem aF =?*_ bF has a solution then a=
?
;’ b has a solution.
Proof. If the problem aF=?*_ bF has a solution then it has a solved form by the
system Unif. This solved form verifies the invariants above and the problem a=?;’ b
has a solution. K
Theorem 5.8. Let a=?;’ b be a unification problem in 4DB(X). The equational
problem aF =?*_ bF has a solution if and only if the higher order problem a=
?
;’ b has
a solution.
An immediate consequence of the undecidability of higher order unification
[25, 21] and of the last theorem is that equational unification is undecidable in the
theory *_.
5.2. Translating Back Equations
We now show that for any unification problem P, derived from a problem
aF =?*_ bF , we can reconstruct a problem Q in the image of the precooking translation
226 DOWEK, HARDIN, AND KIRCHNER
that has the same solutions as P. Therefore Q may be translated back to *-calculus
into a higher unification problem R. Now, the solutions of P and Q are the
precooking of the solutions of R. This result will be used for two purposes. First,
solved forms of P are translated back to *-calculus, giving a description of the set
of solutions of R as solved forms. Then we will use this translation to simulate the
algorithm of [26].
Definition 5.9. The system Unif is extended with the two following rules:
Anti-Exp-* P  _Y (P 7 X=?*_ (Y[ A ] 1 ))
if X # Var(P) such that 1X=A .1 $X
where Y # X, Y  Var(P) and
TY=A  TX , 1Y=1$X
Anti-Dec-* P 7 a=?*_ b  P 7 *A a=
?
*_ *A b
if a=?*_ b is well-typed in a context 2=A .2$
Proposition 5.10. The system Unif, augmented by these rules, remains sound and
complete.
Proof. Soundness is trivial, completeness of Anti-Dec-* also.
For the completeness of Anti-Exp-*, consider a grafting % solution of the problem
P, take %$Y=*(%X ) and %$Z=%Z if Z{Y then %$ is a solution of P and (denoting
%$(X ) by a)
%$(X=?*_ (Y[ A ] 1))=(a=
?
*_ ((*a)[ A ] 1))=(a=
?
*_ a);
thus %$ is a solution of the system P 7 (X=?*_ (Y[ A ] 1)) and % is a solution to the
system _Y(P 7 (X=?*_ (Y[ A ] 1))). K
For aF=?*_ bF an initial well-typed problem in the context 1, we call Back the
strategy of the Anti-* and Replace rules application consisting in applying the rule
Anti-Exp-* only to variables X such that 1X is a strict extension of 1 and the Anti-
Dec-* only to equations whose context is a strict extension of 1, Replace being
applied eagerly.
Proposition 5.11. Let a=?;’ b be a higher order unification problem and P be an
equational problem derived from aF =?*_ bF by the rules of Unif. When applying the
strategy Back on P, the invariants of Proposition 5.4 are verified.
Proof. The two first invariants are kept as we use only the rules Anti-Exp-* and
Anti-Dec-* on variables and equations whose context is a strict extension of 1. The
third invariant is kept as the subterms X[a1 } } } ap . A n] of the problem obtained by
the rules above are already terms of this form in the initial problem or are X or
Y[ A ] which both verify p=0. K
Proposition 5.12. Let a=?;’ b be a higher order unification problem and P be an
equational problem derived from aF =?*_ bF by using the rules of Unif. The system
resulting of the normalisation with the strategy Back of the system P is the precook-
ing of a problem in *-calculus.
227HIGHER ORDER UNIFICATION
Proof. As asserted by the invariant of the system Unif, every context 1X is an
extension of 1 and every equation is well typed in an extension of 1. Thus we can
apply the rules Anti-Dec-* and Anti-exp-* then Replace to get rid of every variable
whose context is not 1 and every equation whose context is not 1. We obtain a
1-stable problem such that all equations are well typed in the context 1, for every
variable X occurring in the problem, 1X=1. We can conclude by Proposition 5.5
that this problem is the the pre-cooking of a problem in *-calculus. K
We call *-solved form any solved system of equations in *-calculus in the sense
of [46].
Corollary 5.13. Let a=?;’ b a higher order unification problem such that
aF =?*_ bF can be rewritten by the system Unif to a disjunction of systems that has one
of its constitutive systems P solved. Let Q be the system resulting of the normalisation
with the strategy Back of the system P and R=F&1(Q). Then R is a *-solved form
and the solutions of R are solutions of a=?;’ b. If we apply the trivial solution of [46]
to solve the flexibleflexible equations, we get back the solution built in the proof of
Proposition 5.6.
Proof. Let % be a substitution in *-calculus. Applying the previous results, if %
is a solution of R then %F is a solution of RF , %F is a solution of Q, %F is a solution
of P, %F is a solution of aF =?*_ bF , and % is a solution of a=
?
;’ b. K
Theorem 5.14 (Description of the solutions). Let a=?;’ b be a higher order
unification problem such that aF=?;’ bF is well typed in context 1. Any solution % of
a=?;’ b can be obtained as the solution of a system in *-solved form resulting from
the application of the Unif rules followed by normalisation using the Back strategy
and back-cooking.
Proof. Let % be a substitution in *-calculus. By application of the previous
results, % is a solution of R if and only if %F is a solution of RF , if and only if %F
is a solution of Q, if and only if %F is a solution of P, if and only if %F is a solution
of aF =?*_ bF , if and only if % is a solution of a=
?
;’ b. K
This can be depicted in the following way:
a=?;’ b R
F
F &1
aF=?*_ bF ww
Unif P Back Q
where P is one of the solved forms of aF=?*_ bF and R one of the *-solved form of
the initial problem a=?;’ b.
Remark. When using the Occur-Check rule, we can notice that we get an algo-
rithm that restricts to syntactic first order unification when the input problem is a
first order unification problem.
228 DOWEK, HARDIN, AND KIRCHNER
5.3. Relation with Other Unification Algorithms
Huet’s algorithm can be seen as a particular strategy for the system Unif
extended by the two rules above. Indeed, a simplification of an equation consists in
applying Dec-* n times, then Dec-app once, and finally Anti-Dec-* n times to the
equations obtained by Dec-app. For instance, from the equation
* } } } *(k a1 } } } ap)=?*_ * } } } *(k b1 } } } bp),
we get (k a1 } } } ap)=?*_ (k b1 } } } bp) by applying Dec-* n times, then a1=
?
*_ b1 , ...,
an=?*_ bn using Dec-app, then * } } } *a1=
?
*_ * } } } *b1 , ..., * } } } *ap=
?
*_ * } } } *bp by
applying Anti-Dec-* n times to each equation.
In the same way, applying an elementary substitution consists in applying Exp-*
n times, then Exp-app once, and finally applying Anti-Exp-* n times to each new
variable Hi . For instance, if we have a variable X of type T1  } } }  Tn  U, we
get X [ * } } } *Y by applying Exp-* n times, then X [ * } } } *(k H1 } } } Hp) by apply-
ing Exp-app to Y and finally X [ * } } } *(k (K1[ A n] n } } } 1) } } } (Kp[ A n] n } } } 1))
by applying Anti-Exp-* n times to each Hi . This term is the precooking of * } } }
*(k (K1 n } } } 1) } } } (Kp n } } } 1)) which is Huet’s elementary substitution.
When we apply this strategy, the equations we obtain and the graftings we build
are always the precooking of *-equations and *-substitutions.
5.4. Dependence Constraints
In some extension of higher order unification (for instance in unification with
mixed prefix [37]) unification problems come with more scoping constraints than
the ones present in the equations. For instance we may want to restrict the term
substituted to some variable X in such a way that some de Bruijn index of the
context (for instance 2) does not appear in it.
Such problems can be expressed very easily in *_. For instance, we may express
that 2 is forbidden in X just by adding the equation X=?*_ Y[1 . A
2].
6. EXAMPLES
Let us show in detail how the results of Theorem 5.14 could be applied on two
examples.
6.1. A Simple Example
Let us first solve the problem *A y . (X a)=?;’ *A y .a with a : A, X : A  A. This
equation is encoded in de Bruijn terms, using the context 1=A .nil into
*(X 2)=?;’ *2 and then precooked into:
*(X[ A ] 2)=?*_ *2.
229HIGHER ORDER UNIFICATION
Applying the rule Dec-* we get
(X[ A ] 2)=?*_ 2
and then with the rule Exp-*,
_Y((X[ A ] 2)=?*_ 2) 7 (X=
?
*_ *Y),
where 1Y=A .1 and TY=A. The rule Replace is then applied to get
_Y(((*Y )[ A ] 2)=?*_ 2) 7 (X=
?
*_ *Y),
and applying Normalise results in
_Y(Y[2 . A ]=?*_ 2) 7 (X=
?
*_ *Y ).
Applying the rule Exp-app yields
_Y(Y[2 . A ]=?*_ 2) 7 (X=
?
*_ *Y) 7 (Y=1)
6
_Y(Y[2 . A ]=?*_ 2) 7 (X=
?
*_ *Y) 7 (Y=2),
which reduces using the rule Replace into
(1[2 . A ]=?*_ 2) 7 (X=
?
*_ *1) 6 (2[2 . A ]=
?
*_ 2) 7 (X=
?
*_ *2)
that is normalised by rule Normalise into
(X=?*_ *1) 6 (X=
?
*_ *2).
This problem is a conjunction of solved forms, the first gives the solution *x .x and
the second the solution *x .a.
6.2. A More Elaborated Example
We solve now the classical equation
( f (X a))=?;’ (X( f a))
with f : A  A, X : A  A, a : A. This equation is encoded in de Bruijn terms, using
the context 1=A } A  A } nil, into (2(X 1))=?;’ (X(2 1)). Then precooking yields
(2(X 1))=?*_ (X(2 1)), where the variable X has the context 1 and type A  A.
Applying the rules in Unif, we get the following derivations, where the variables
Y, H1 , H2 are existentially quantified:
230 DOWEK, HARDIN, AND KIRCHNER
[(2(X 1))=?*_ (X(2 1)) 
Exp-* {(2(X 1))=
?
*_ (X(2 1))
X=?*_ *Y (Y : A } 1 |&A)
Replace
{(2(*Y 1))=
?
*_ (*Y(2 1))
X=?*_ *Y
Normalise {(2 Y[1 . id])=
?
*_ Y[(2 1) . id]
X=?*_ *Y
Exp-app
{
(2 Y[1 . id])=?*_ Y[(2 1) . id]
Y=?*_ 1
X=?*_ *Y
6{
(2 Y[1 . id])=?*_ Y[(2 1) . id]
Y=?*_ (3 H1) (H1 : 1Y |&A)
X=?*_ *Y
Replace
{
(2 1[1 . id])=?*_ 1[(2 1) . id]
Y=?*_ 1
X=?*_ *1
6{
(2 (3 H1)[1 . id])=?*_ (3 H1)[(2 1) . id]
Y=?*_ (3 H1)
X=?*_ *Y
Normalise
{
(2 1)=?*_ (2 1)
Y=?*_ 1
X=?*_ *1
6{
(2 (2 H1 [1 . id]))=?*_ (2 H1 [(2 1) . id])
Y=?*_ (3 H1)
X=?*_ *(3 H1)
We get a first solved form, X=?*_ * 1, and we continue with the second system:
Dec-app1
{
(2 H1 [1 . id])=?*_ H1 [(2 1) . id]
Y=?*_ (3 H1)
X=?*_ *(3 H1)
Exp-app
{
(2 H1 [1 . id])=?*_ H1 [(2 1) . id]
H1=?*_ 1
Y=?*_ (3 H1)
X=?*_ *(3 H1)
6{
(2 H1 [1 . id])=?*_ H1[(2 1) . id]
H1=?*_ (3 H2) (H2 : 1Y |&A)
Y=?*_ (3 H1)
X=?*_ *(3 H1)
Replace
{
(2 1[1. id])=?*_ 1[(2 1) . id]
H1=?*_ 1
Y=?*_ (3 1)
X=?*_ *(3 1)
6{
(2 (3 H2)[1 . id])=?*_ (3 H2)[(2 1) . id]
H1=?*_ (3 H2)
Y=?*_ (3(3 H2))
X=?*_ *(3(3 H2))
Normalise
{
(2 1)=?*_ (2 1)
H1=?*_ 1
Y=?*_ (3 1)
X=?*_ *(3 1)
6{
(2(2 H2 [1 . id]))=?*_ (1 H2 [(2 1) . id])
H1=?*_ (3 H2)
Y=?*_ (3(3 H2))
X=?*_ *(3(3 H2))
231HIGHER ORDER UNIFICATION
We get another solved form, X=?*_ *(3 1), and a system that obviously will get
rewritten by Unif forever, generating all the (infinitely many) solved forms of this
system.
Now if we consider the two previous solved forms, they are both in the image of
F, and precooking them back to *-terms we get for the first X=?;’ *x .x and for the
second X=?;’ *x . ( f x) which are clearly two solutions of the initial problem.
7. CONCLUSION
It was well known that higher order unification was some kind of equational
unification for the theory ;’. But standard first order equational unification algo-
rithms could not be used for higher order unification, because substitution in higher
order algebras is different from substitution in first order ones (grafting).
We have introduced and used the concepts based on the existence of two different
kinds of variables: reduction and unification variables. By using substitution and
grafting acting on these two kinds of variables, we have enabled the two calculi to
interact explicitly. The precooking transformation has then allowed us to relate in
a precise and faithful way the *- and *_-calculi. Based on these ideas, we have
shown that higher order unification problems could be translated into first order
ones. We came up with a new algorithm for higher order unification based on a
unification algorithm for the equational theory of *_. In our higher order unifica-
tion algorithm, the separation between substitutions initiated by reduction and
substitutions of unification variables permits an avoidance of the functional encod-
ing of scoping constraints which was one of the burdens of previous algorithms. By
using a language with explicit substitutions, our algorithm remains close to the one
of Huet, in particular each of them can be simulated in terms of the other and the
description of solutions are the same in both cases.
The fundamental role of the substitution calculus for unification has also been
addressed in the theory of instantiation of [48] as well as in the unification algebra
framework of [45]. One of the main differences between the present work and these
approaches is that we consider a substitution calculus, entirely devoted to the
evaluation of * -calculus, as part of the framework and thus we design unification
for this recent equational theory.
Another reduction of higher order unification in a first order framework has been
given by [16] using combinatory logic and an extension of narrowing for handling
extensionality. But this reduction inherits the defaults of the translation of *-calculus
on combinatory logic: coming back to *-calculus is rather intricate.
We hope that the new framework we propose that allowed us to understand
higher order unification as first order equational unification will be useful for some
other purposes. In particular, mixing higher order specifications with equational
ones may be done just by extending *_ with new symbols and new equations [42].
This is a way to reduce higher order equational unification to first order [31],
different from [17] which is based on combinatory logic. Also, we have shown in
[20] that the framework could be fruitfully used for studying decidable subproblems
of unification-like patterns [36].
232 DOWEK, HARDIN, AND KIRCHNER
The general concepts and algorithms presented in this paper can be adapted to
any calculus of explicit substitutions provided that it is weakly terminating and
confluent on substitution-closed terms. Nevertheless, determining the potential head
variables in the rule Exp-app in a richer calculus such as that presented in [11]
may be more tricky. With calculi that are only confluent on closed terms, narrow-
ing can simply be used to perform unification [7]. But in the case of such a
calculus, translating back solved forms to *-calculus is rather intricate.
Our work has also to be carried with a precise analysis of the unification algo-
rithm, in order to define strategies as lazy as possible. For example, there is no need
to compute *_-normal forms at every step, and the experimental implementation
[6] of the unification rules which has been realized using the ELAN logical frame-
work [30], indeed uses only head normal forms. A major continuation of this work
is its extension to unification in richer *-calculi, such as the calculi of Barendregt’s
cube [5]. In this case, the functional expression of scoping constraints leads to
technical difficulties [18] that may be simplified using explicit substitutions.
Finally, this work suggests that higher order logic itself should be expressed using
a calculus with explicit substitutions instead of ordinary *-calculus. Then, higher
order resolution is equational resolution in this theory. This program has been
completed in [49, 50].
ACKNOWLEDGMENTS
This work has been supported partly by the French Inter-PRC operation ‘‘Me canisation du raisonne-
ment’’, the Esprit basic research actions Confer and Types and the Esprit working group CCL. We
acknowledge helpful comments from Martin Abadi, Peter Borovansky, Daniel Briaud, Ce sar Mun~ oz,
Alejandro R@ os, and anonymous referees.
Final manuscript received March 1, 1999
REFERENCES
1. Abadi, M., Cardelli, L., Curien, P. L., and Le vy, J. J. (1991), Explicit substitutions, J. Functional
Programming 1, 375416.
2. Andrews, P. B. (1971), Resolution in type theory, J. Symbolic Logic 36, 414432.
3. Andrews, P. B. (1986), ‘‘An Introduction to Mathematical Logic and Type Theory: To Truth
through Proof,’’ Academic Press, New York.
4. Barendregt, H. P. (1984), The lambda-calculus, its syntax and semantics, in ‘‘Studies in Logic and
the Foundation of Mathematics,’’ second ed., Elsevier Science North-Holland, Amsterdam.
5. Barendregt, H. P. (1992), Lambda calculi with types, in ‘‘Handbook of Logic in Computer Science’’
(S. Abramsky, D. Gabbay, and T. Maibaum, Eds.), Clarendon Press, Oxford.
6. Borovansky , P. (1995), Implementation of higher-order unification based on calculus of explicit sub-
stitutions, in ‘‘Proceedings of the SOFSEM’95: Theory and Practice of Informatics’’ (M. Bartos ek,
J. Staudek, and J. Wiedermann, Eds.), Lecture Notes in Computer Science, Vol. 1012, pp. 363368,
Springer-Verlag, Berlin.
7. Briaud, D. (1996), Higher order unification as a typed narrowing, in ‘‘Proceedings of UNIF’96’’
(K. Schulz and S. Kepser, Eds.), CIS-Universita t Mu nchen, pp. 131138. [CIS-Bericht-96-91]
8. Chen, H., Hsiang, J., and Kong, H. C. (1990), On finite representations of infinite sequences of
terms, in ‘‘Proceedings of the 2nd International Workshop on Conditional and Typed Rewriting
233HIGHER ORDER UNIFICATION
Systems’’ (S. Kaplan and M. Okada, Eds.), Lecture Notes in Computer Science, Vol. 516, pp. 100114,
Springer-Verlag, Berlin.
9. Church, A. (1940), A formulation of the simple theory of types, J. Symbolic Logic 5, 5668.
10. Curien, P.-L. (1993), ‘‘Categorical Combinators, Sequential Algorithms and Functional Programming,’’
2nd ed., Birkha user, Basel.
11. Curien, P.-L., Hardin, T., and Le vy, J. J. (1996), Confluence properties of weak and strong calculi
of explicit substitutions, J. Assoc. Comput. Mach. 43, 362397.
12. Curien, P.-L., and Rios, A. (1991), Un re sultat de comple tude pour les substitutions explicites,
C. R. Acad. Sci. Paris 312, 471476.
13. Dauchet, M. (1992), Simulation of Turing machines by a regular rule, Theoret. Comput. Sci. 103,
409420.
14. de Bruijn, N. (1972), Lambda calculus notation with nameless dummies, a tool for automatic
formula manipulation, with application to the ChurchRosser theorem, Indag. Math. 34, 381392.
15. Dershowitz, N., and Jouannaud, J.-P. (1990), Rewrite Systems, in ‘‘Handbook of Theoretical
Computer Science’’ (J. van Leeuwen, Ed.), Chap. 6, pp. 244320, Elsevier Science North-Holland,
Amsterdam.
16. Dougherty, D. J. (1993), Higher-order unification via combinators, Theoret. Comput. Sci. 114,
273298.
17. Dougherty, D. J., and Johann, P. (1995), A combinatory logic approach to higher-order E-unification,
Theoret. Comput. Sci. 139, 207242.
18. Dowek, G. (1993), A complete proof synthesis method for the cube of type systems, J. Logic
Comput. 3, 287315.
19. Dowek, G., Hardin, T., and Kirchner, C. (1995), Higher-order unification via explicit substitutions,
extended abstract, in ‘‘Proceedings of LICS’95, San Diego, June 1995’’ (D. Kozen, Ed.), pp. 366374.
20. Dowek, G., Hardin, T., Kirchner, C., and Pfenning, F. (1996), Unification via explicit substitutions:
The case of higher-order patterns, in ‘‘Proceedings of JICSLP’96, Bonn, September 1996’’ (M. Maher,
Ed.), MIT Press, Cambridge, MA.
21. Goldfarb, D. (1981), The undecidability of the second order unification problem, Theoret. Comput.
Sci. 13, 225230.
22. Goubault-Larrecq, J. (January 1997), ‘‘A Proof of Weak Termination of the Simply-Typed
*_-Calculus,’’ Technical Report 3090, INRIA.
23. Herbrand, J. (1930), Recherches sur la the orie de la de monstration, Travaux Soc. Sci. Lett. Varsovie,
Classe III, 33.
24. Hintermeier, C., Kirchner, C., and Kirchner, H. (1994), Dynamically-typed computations for order-
sorted equational presentationsextended abstract, in ‘‘Proc. 21st International Colloquium on
Automata, Languages, and Programming’’ (S. Abiteboul and E. Shamir, Eds.), Lecture Notes in
Computer Science, Vol. 820, pp. 450461, Springer-Verlag, Berlin.
25. Huet, G. (1973), The undecidability of unification in third order logic, Inform. and Control 22,
257267.
26. Huet, G. (1975), A unification algorithm for typed lambda calculus, Theoret. Comput. Sci. 1,
2757.
27. Hullot, J.-M. (1980), Canonical forms and unification, in ‘‘Proceedings 5th International Conference
on Automated Deduction, Les Arcs, France’’ (W. Bibel and R. Kowalski, Eds.), Lecture Notes in
Computer Science, Vol. 87, pp. 318334, Springer-Verlag, Berlin.
28. Hussmann, H. (1985), Unification in conditional equational theories, in ‘‘Proceedings of the EUROCAL
Conference, Linz, Austria’’ (B. Buchberger, Ed.), Lecture Notes in Computer Science, Vol. 204,
pp. 543553, Springer-Verlag, Berlin.
29. Jouannaud, J.-P., and Kirchner, C. (1991), Solving equations in abstract algebras: a rule-based
survey of unification, in ‘‘Computational Logic. Essays in honor of Alan Robinson’’ (J.-L. Lassez and
G. Plotkin, Eds.), Chap. 8, pp. 257321, The MIT Press, Cambridge, MA.
234 DOWEK, HARDIN, AND KIRCHNER
30. Kirchner, C., Kirchner, H., and Vittek, M. (1995), Designing constraint logic programming
languages using computational systems, in ‘‘Principles and Practice of Constraint Programming’’
(P. Van Hentenryck and V. Saraswat, Eds.), Chap. 8, pp. 131158, The Newport Papers, The MIT
Press, Cambridge, MA.
31. Kirchner, C., and Ringeissen, C. (1997), Higher-order equational unification via explicit substitutions,
in ‘‘Algebraic and Logic Programming ALP-HOA,’’ Lecture Notes in Computer Science, Vol. 1298,
pp. 6175, Springer-Verlag, Berlin.
32. Kirchner, H., and Hermann, M. (1990), Meta-rule synthesis from crossed rewrite systems, in ‘‘Proceedings
2nd International Workshop on Conditional and Typed Rewriting Systems, Montreal’’ (S. Kaplan and
M. Okada, Eds.), Lecture Notes in Computer Science, Vol. 516, pp. 143154, Springer-Verlag, Berlin.
33. Krivine, J.-L. (1993), ‘‘Lambda Calculus, Types and Models,’’ Ellis Horwood, Chichester.
34. Martelli, A., and Montanari, U. (1982), An efficient unification algorithm, ACM Trans. Programming
Languages Systems 4, 258282.
35. Middeldorp, A., and Hamoen, E. (1994), Completeness results for basic narrowing, Appl. Algebra
Eng. Commun. Comput. 5, 213253.
36. Miller, D. (1991), A logic programming language with lambda-abstraction, function variables, and
simple unification, in ‘‘Extensions of Logic Programming: International Workshop, Tu bingen,
Germany, December 1989’’ (P. Schroeder-Heister, Ed.), Lecture Notes in Computer Science,
Vol. 475, pp. 253281, Springer-Verlag, Berlin.
37. Miller, D. (1992), Unification under a mixed prefix, J. Symbolic Comput. 14, 321358.
38. Mun~ oz, C. (1997), A left linear variant of *_, in ‘‘Proceedings 6th International Joint Conference ALP’97-
HOA’97, Southampton, UK,’’ Lecture Notes in Computer Science, Vol. 1298, Springer-Verlag, Berlin.
39. Nadathur, G. (May 1996), ‘‘A Fine-Grained Notation for Lambda Terms and Its Use in Intensional
Operations,’’ Tech. Report TR-96-13, Department of Computer Science, University of Chicago.
40. Nadathur, G., and Wilson, D. S. (1990), A representation of lambda terms suitable for operations on
their intensions, in ‘‘Proceedings of the 1990 ACM Conference on Lisp and Functional Programming,’’
pp. 341348, ACM Press, New York.
41. Nadathur, G., and Wilson, D. S. (January 1997), ‘‘A Notation for Lambda Terms: A Generalization
of Environments,’’ Tech. Report CS-1997-01, Department of Computer Science, Duke University.
42. Pagano, B. (1998), X.R.S.: explicit reduction systems, a first-order calculus for higher-order calculi,
in ‘‘Conference on Automated Deduction’’ (C. Kirchner and H. Kirchner, Eds.), Lecture Notes in
Artificial Intelligence, Vol. 1421, pp. 6680.
43. Plotkin, G. (1972), Building-in equational theories, Mach. Intelligence 7, 7390.
44. R@ os, A. (1993), ‘‘Contributions a l’e tude des *-calculs avec des substitutions explicites,’’ The se de
Doctorat d’Universite , U. Paris VII.
45. Siekmann, J., and Schmidt-Schau?, M. (1988), ‘‘Unification Algebras: an Axiomatic Approach to Uni-
fication, Equation Solving and Constraint Solving,’’ SEKI report SR-88-23, Universita t Kaiserslautern.
46. Snyder, W., and Gallier, J. (1989), Higher order unification revisited: Complete sets of tranformations,
J. Symbolic Comput. 8, 101140. [Special Issue on Unification, Part Two]
47. Werner, A. (1995), Normalizing narrowing for weakly terminating and confluent systems, in
‘‘Proceedings of the first international conference on Principles and Practice of Constraint Programming,
Cassis, France, September 1995’’ (U. Montanari and F. Rossi, Eds.), Lecture Notes in Computer
Science, Vol. 976, pp. 415430, Springer-Verlag, Berlin.
48. Williams, J. G. (1991), ‘‘Instanciation Theory. On the Foundations of Automated Deduction,’’
Lecture Notes in Artificial Intelligence, Vol. 518, Springer-Verlag, Berlin.
49. Dowek, G., Hardin, T., and Kirchner, C. (1998), ‘‘Theorem Proving Module,’’ Rapport de
Recherche 3400, Institut National de Recherche en Informatique et en Automatique.
50. Dowek, G., Hardin, T., and Kirchner, C. (1999), HOLlambdasigma: An intensional first-order
expression of higher-order logic, in ‘‘Rewriting Techniques and Applications’’ (P. Naremdran and M.
Rusinowitch, Eds.), Lecture Notes in Computer Science, Vol. 1631, pp. 317331, Springer-Verlag, Berlin.
235HIGHER ORDER UNIFICATION
