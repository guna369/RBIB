Information and Computation 159, 125150 (2000)
On the Undecidability of Second-Order
Unification1
Jordi Levy
Institut d’Investigacio en Intel } lige ncia Artificial, Consejo Superior de Investigaciones Cient@ ficas,
Campus UAB, 08193 Bellaterra, Barcelona, Spain
E-mail: levyiiia.csic.es
and
Margus Veanes
Microsoft Research, One Microsoft Way, Redmond, Washington 98052
E-mail: margusmicrosoft.com
There is a close relationship between word unification and second-
order unification. This similarity has been exploited, for instance, in order
to prove decidability of monadic second-order unification and decidability
of linear second-order unification when no second-order variable occurs
more than twice. The attempt to prove the second result for (nonlinear)
second-order unification failed and led instead to a natural reduction from
simultaneous rigid E-unification to this second-order unification. This
reduction is the first main result of this paper, and it is the starting point
for proving some novel results about the undecidability of second-order
unification presented in the rest of the paper. We prove that second-order
unification is undecidable in the following three cases: (1) each second-
order variable occurs at most twice and there are only two second-order
variables; (2) there is only one second-order variable and it is unary; (3)
the following conditions (i)(iv) hold for some fixed integer n: (i) the
arguments of all second-order variables are ground terms of size <n, (ii)
the arity of all second-order variables is <n, (iii) the number of occurrences
of second-order variables is 5, (iv) there is either a single second-order
variable or there are two second-order variables and no first-order
variables. ] 2000 Academic Press
doi:10.1006inco.2000.2877, available online at http:www.idealibrary.com on
125 0890-540100 35.00
Copyright  2000 by Academic Press
All rights of reproduction in any form reserved.
1 This work was partially supported by Project MODELOGOS (TIC97-0579-C02-01) funded by the
CICYT, and the ESPRIT Basic Research Action CCL. This paper is based on preliminary results in
(Levy, 1998; Veanes, 1998; Levy and Veanes, 1998). The second author worked at Max-Planck-Institute
of Computer Science, Saarbruecken, Germany, when this paper was submitted.
1. INTRODUCTION
Second-order unification (Pietrzykowski, 1973) and restricted forms thereof have
been studied in a wide range of areas, such as natural language processing (Niehren
et al., 1997) and term rewriting (Comon, 1993), among others. Although Goldfarb
(1981) showed second-order unification to be undecidable in general, Makanin’s
(1977) decidability result of word unification and Schulz’s (1991) extension of it
have been used as key tools in establishing the decidability of some important spe-
cial cases of second-order unification (e.g., Farmer, 1988). In linear second-order
unification, terms in unifiers must have exactly one occurrence of each bound
variable, and in context unification, in addition to this condition, all second-order
variables are unary. The relationship between word unification and context unifica-
tion becomes clear when we codify a word unification problem, such as
H } a } b } G =? G } b } a } H,
where ‘‘ } ’’ denotes string concatenation, as the context unification problem
H( fa( fb(G(c)))) =
? G( fb( fa(H(c)))).
A possible unifier of the word equation maps H to the empty string and G to the
string a, and the corresponding unifier of the context equation maps H to *x .x and
G to *x . fa(x).
We show that second-order unification, in its unrestricted form, is intimately
related to a fundamental decision problem, called simultaneous rigid E-unification
(Gallier et al., 1987), that occurs in automated reasoning in (both classical and
intuitionistic) first-order logic with equality (Degtyarev et al., 1996). Basically, this
relationship relies on a close correspondence between second-order unification
problems on a certain form and ground rewriting. Consider two ground terms s and
t and a system of n ground rules l1  r1 , ..., ln  rn . Then
s *[l1  r1 , ..., ln  rn] t
if and only if this second-order equation is unifiable (let cons and nil be new
symbols):
F(l1 , ..., ln , cons(t, nil)) =
?
cons(s, F(r1 , ..., rn , nil)).
The precise reasons why this relationship holds are explained in detail in Section 3.
Despite many similarities, word unification is decidable (Makanin, 1977),
second-order unification is undecidable (Goldfarb, 1981), simultaneous rigid
E-unification is undecidable (Degtyarev and Voronkov, 1995), and, with the excep-
tion of some special cases (Comon, 1993; Schmidt-Schau?, 1995; Levy, 1996;
Schmidt-Schau? , 1999; Schmidt-Schau? and Schulz, 1998), the question is open for
linear second-order unification and context unification (although these problems
are conjectured to be decidable). Decidability of word unification was an open
126 LEVY AND VEANES
question for a long time and its proof (Makanin, 1977) involves a lot of techni-
calities. However, it is very easy to prove that it is decidable when no variable
occurs more than twice in a problem. The same main ideas were used to prove that
linear second-order unification and context unification are decidable under the
same restriction (Levy, 1996). However, we prove, in Section 4, that this is not the
case for second-order unification, by reduction from simultaneous rigid E-unifica-
tion.
We use properties underlying this reduction and additional ideas that have been
used to prove the undecidability of restricted cases of simultaneous rigid E-unifica-
tion (Plaisted, 1995; Gurevich and Veanes, 1999) and second-order unification
(Farmer, 1991), that second-order unification is undecidable in the following three
cases: (Section 4) each second-order variable occurs at most twice and there are
only two second-order variables; (Section 5) there is only one second-order variable
and it is unary; (Section 6) the following conditions (i)(iv) hold for some fixed
integer n: (i) the arguments of all second-order variables are ground terms of size
<n, (ii) the arity of all second-order variables is <n, (iii) the number of occurren-
ces of second-order variables is 5, (iv) there is either a single second-order
variable or there are two second-order variables and no first-order variables.
2. PRELIMINARY DEFINITIONS
We assume that the reader is familiar with first-order unification problems, typed
*-calculus (e.g., Hindley and Seldin, 1986), and basic notions in term rewriting (e.g.,
Baader and Nipkow, 1998). We briefly go through the necessary definitions.
A type is an expression generated by the grammar { ::=B | {  { | {_{, where B
is a set of base types. An order of a type { is defined as follows: ord({)=1 for
any base type { # B; ord({1_{2)=max(ord({1), ord({2)); and ord({1  {2)=
max(ord({1)+1, ord({2)) for any composed type. A signature is a pair (7, X)
where 7 is a finite set of function symbols and X is a denumerable set of variables.
We use & to denote an arbitrary symbol in a signature. We assume that each func-
tion symbol or variable & of the signature has a type {, denoted by & : {. In general,
the type of a function symbol or a variable is not explicitly given and can be
inferred from the context. If ord({)=n and & : {, then & is of order n. If
& : {1_ } } } _{n  { then & has arity n or is n-ary, denoted arity(&)=n. If the type
of & is a base type then arity(&)=0.
In the remainder of the paper, all variables are either first order
(x, y, z, X, Y, Z, ...), i.e., of order 1, or second order (F, G, ...), i.e., of order 2.
Similarly, all function symbols are either first order (a, b, c, ...), also called constants,
or second order ( f, g, h, ...). For clarity, we use (x, y, z, ...) for bound variables and
(X, Y, Z, ...) for free variables.
In second-order typed *-calculus one can also have function symbols of order
greater than 2, but we will avoid them because they do not play an important role
in the undecidability results. The same restriction is used by Goldfarb (1981). We
also assume that we have a single unique base type o. Furthermore, we only need
terms that are in ;-reduced ’-extended normal form and decurried, i.e., having type
(o_ } } } _o)  o. With these restrictions arity and type uniquely determine each
127SECOND-ORDER UNIFICATION
other, allowing us to just use the notion of arity. Moreover, any term of type o, in
its ;’-normal form, is *-free, i.e., can be written without using lambdas; and, any
other term of type (o_ } } } _o)  o can be written using lambdas only as the most
external constructor. Thus, we define ;’-normal terms (r, l, s, t, u, v, w, ...) to be
expressions of the form
*x1 } } } xm .&(t1 , ..., tn),
call it t, where t1 , ..., tn have type o, i.e., are *-free terms, and & is an n-ary symbol
from the signature. The term t is said to be of arity m. Occasionally, we write
*x .*y . t for *xy . t. A first-order term is a term of type o (a *-free term) that contains
no second-order variables. A term is closed if it contains no free variables. A term
is ground if it contains neither free nor bound variables; i.e., a ground term is a
closed first-order term.
In this paper we only consider signatures with at least one constant. In particular,
this means that the set of ground terms is always nonempty. For most results this
restriction can be relaxed at the expense of having to treat tedious special cases (cf.
Farmer, 1991).
A substitution (_, %, \ } } } ) is a finite mapping from variables to terms
[&i [ ti : 1in], say %, where &i and ti have the same arity. The domain of % is
Dom(%)=[&1 , ..., &n], and the range of % is [t1 , ..., tn]. A substitution is closed
(ground ) if its range is a set of closed (ground) terms. Note that the domain of a
ground substitution is a set of first-order variables. We will only apply substitutions
% to terms of type o, and we will assume that they are previously ;’-normalized.
So, the definition is as follows:
%(&)=&, if &  Dom(%);
%(&)=t, if & [ t # %;
%(&(t1 , ..., tn))=&(%(t1), ..., %(tn)), if &  Dom(%);
%(F(t1 , ..., tn))=\(u), if F [ *x1 . } } } .*xn .u # %;
and \=[xi [ %(ti) : 1in].
For better readability we occasionally use the convention t% for %(t) (or &% for %(&)).
In some cases, we write terms that are not in ;’-normal form. Readers more
familiar with first-order notation may interpret them as a meta-notation of their
corresponding normal form. In particular, given a term t=*z1 } } } zm .u (where
z1 , ..., zm may occur free in u) and terms t1 , ..., tm , the application term t(t1 , ..., tm)
denotes its ;-reduced form u% where %=[zi [ ti : 1im].
2.1. Second-Order Unification
A second-order equation is a pair t =? u of *-free terms. Second-order unification
or SOU is the problem, given a system (finite set) of second-order equations
[t1 =
? u1 , ..., tn =
? un], to decide whether there exists a substitution % such that
128 LEVY AND VEANES
%(ti)=%(ui) for all i. Such a % is said to unify or solve S. We say that a SOU
problem is simple if all arguments of all second-order variables are ground terms.
Pietrzykowski (1973) was the first to describe a complete semi-decision procedure
for second-order unification.
2.2. Simultaneous Rigid Reachability
Rigid reachability is the problem, given a system R of first-order rules l  r and
two first-order terms s and t, whether there exists a ground substitution % such that
s%, t%, and R% are ground and s% rewrites in 0 or more steps via R% into t%, i.e.,
s% *R% t%.
The expression R |&r s  t is called a reachability constraint and R its left-hand
side or rule set. The term ‘‘rigid’’ stems from the fact that for no rule more than one
instance can be used in the rewriting process. Simultaneous rigid reachability is the
problem in which a substitution is sought which simultaneously solves each
member of a system (finite set) of reachability constraints. A special case of
(simultaneous) rigid reachability arises when the left-hand sides are symmetric: con-
taining for each rule l  r also its converse r  l, in which case the rules are written
as equations lrr. In the symmetric case reachability constraints are also called
rigid equations. The symmetric case was introduced by Gallier et al. (1987) as
simultaneous rigid E-unification or SREU. (Symmetric systems arise, for instance,
from orienting a given set of equations in both directions.) It has been shown by
Degtyarev and Voronkov (1995) that SREU is undecidable, whereas the non-
simultaneous case of SREU (with just one rigid equation to solve) is NP-complete
(Gallier et al., 1988). However, rigid reachability is undecidable (Ganzinger et al.,
1998).
3. FROM RIGID REACHABILITY TO SOU
In this section we prove two lemmas that show a close relationship between rigid
reachability and second-order unification. These lemmas are used as basic tools in
the rest of the paper. Some connections between rigid reachability and SOU were
first studied and used by Farmer (1991, Lemma 5.2). Basically, the main idea is
based on a close correspondence between second-order unification problems on a
certain form and ground rewriting. Consider two ground terms s and t and a
system of n ground rules l1  r1 , ..., ln  rn . Then
s *[l1  r1 , ..., ln  rn] t
if and only if this second-order equation is unifiable (let f and c be new symbols):
F(l1 , ..., ln , f (t, c)) =
? f (s, F(r1 , ..., rn , c)).
Any unifier % of this equation maps F to a *-term *x1 } } } xn y .u, where u is a first-
order term over the extended signature that encodes a possible reduction of s to t
in the given rewrite system. To see how this works we consider an example.
129SECOND-ORDER UNIFICATION
Example 1. Consider a rewrite system R consisting of two rules h(a)  a and
g(a)  a. Let s be the term h(g(h(a))) and t be the constant a. Then s rewrites in
R to t as follows:
s h(a)  a h(g(a)) g(a)  a h(a) h(a)  a t.
Consider the equation
F(h(a), g(a), f (t, c)) =? f (s, F(a, a, c)).
A unifier of this equation that encodes the above reduction is illustrated in Fig. 1.
In the following two lemmas, we consider a fixed signature (7, X) , a constant
c  7, and a binary function symbol f  7. Moreover, without loss of generality, we
only consider closed substitutions.
Lemma 1. Let l1 , ..., lm , r1 , ..., rm , s, t be terms over 7 and % a substitution such
that l1%, ..., lm%, t% are ground terms over 7.
Let z denote z1 , ..., zm , l9 % denote l1%, ..., lm%, and r % denote r1%, ..., rm%. The follow-
ing statements are equivalent.
(i) % solves F(l1 , ..., lm , f (t, c)) =
? f (s, F(r1 , ..., rm , c)).
(ii) There exists k0 and closed terms si of arity m over 7 for 1ik, such
that
F%=*z .*zm+1. f (s1(z ), f (s2(z ), ..., f (sk(z ), zm+1) } } } )), (1)
FIG. 1. See the equation in Example 1. The top term is %(F ). The left (right) term is obtained by
applying % to the left (right) side of the equation. The encoded rewrite steps are indicated in gray.
130 LEVY AND VEANES
and, either k=0 and s%=t%, or
s%=s1(l9 %), (2)
si (r %)=si+1(l9 %), for 1i<k, (3)
sk(r %)=t%. (4)
Proof. (i) o (ii) It is easy to check that % satisfying (ii) solves the second-order
equation in (i).
(i) O (ii) Let % satisfying (i) be given. Let F%=tF . So, by (i),
tF (l9 %, f (t%, c))= f (s%, tF (r %, c)). (5)
We say here that a second-order term u is a list if either u=*z .*zm+1 .zm+1 or
u=*z .*zm+1 . f (u1(z , zm+1), u2(z , zm+1)) for some closed terms u1 and u2 , where u2
is a list. The following property:
(*) Let t1 be a closed term of arity m+1, t 2 , t3 be a sequence of m+1
ground terms over 7, t4 , t 5 be a sequence of m+1 ground terms. If
t1(t 2 , f (t3 , c))= f (t4 , t1(t 5 , c))
then t1 is a list.
is proved easily, by induction on the size of t1 , using that t 2 , t3 is a sequence of
ground terms over 7 and that c, f  7. The base case is t1 being *z .*zm+1 .zm+1 .
The induction case is equally straightforward. Alternatively, (*) can be proved
using Pietrzykowski’s procedure, and its completeness, and showing that t1 can
only have the form of a list.
From (*) and (5) follows that tF is a list. Therefore, it has the following form for
some k0 and sequence of closed second-order terms si , 1ik:
tF=*z .*zm+1 . f (s1(z , zm+1), f (s2(z , zm+1), ..., f (sk(z , zm+1), zm+1) } } } )). (6)
If k=0 then (i) implies that s%=t%, and thus (ii) holds.
Assume that k>0. To prove (ii) it remains to be shown that f and c do not occur
in any of the si’s and these si’s do not use their last argument, i.e., if si=*z .*zm+1 .s$i
then zm+1 does not occur in si$ , and that (2)(4) hold.
It follows from (5) and (6) that
f (s1(l9 %, t$), f (s2(l9 %, t$), ... f (t%, c) } } } )=
f (s%, f (s1(r %, c), ... f (sk(r %, c), c) } } } ),
where t$= f (t%, c). Hence, s1(l9 %, t$)=s%, si+1(l9 %, t$)=s i (r %, c) for 1i<k, and
t%=sk(r %, c). It follows by induction on k&i (with k=i being the base case) that
each si has the required from by using that all terms in t%, l9 % are ground terms over
7 and f, c  7. The lemma follows. K
131SECOND-ORDER UNIFICATION
A unifier of a second-order equation of the form in Lemma 1, as well as the
possible rewriting sequences for a term, are not unique as the following example
shows. Moreover, if we read the conditions (2)(4) as ‘‘s% rewrites to t%,’’ then we
have to consider parallel rewriting steps.
Example 2. The equation
F(a, f (g(b, b), c)) =? f (g(a, a), F(b, c))
has infinitely many unifiers. In particular, the three solutions
[F [ *xy . f (g(x, a), f (g(b, x), y))],
[F [ *xy . f (g(a, x), f (g(x, b), y))],
[F [ *xy . f (g(x, x), y)]
correspond to the following three reductions from g(a, a) to g(b, b):
g(a, a)  g(b, a)  g(b, b),
g(a, a)  g(a, b)  g(b, b),
g(a, a) | | g(b, b).
In the third case we write 
| |
to emphasize that this rewriting step is done in parallel
over two disjoint redexes. The way how the first substitution solves the equation is
illustrated by Fig. 2.
We can now state our main lemma that links together rigid reachability and
second-order unification.
Lemma 2. Let R=[li  ri : 1im] be a set of rules over 7 and let s and t be
terms over 7. Statements (i) and (ii) are equivalent for all % such that
FIG. 2. See the equation in Example 2. The top term is %(F ). The left (right) term is obtained by
applying % to the left (right) side of the equation. The arguments of F are shown in gray.
132 LEVY AND VEANES
t%, l1%, ..., lm%, r1%, ..., rm% are ground terms over 7. Let F be a second-order variable
such that F  Dom(%).
(i) % _ [F [ t$] solves F(l1 , ..., lm , f (t, c)) =
? f (s, F(r1 , ..., rm , c)) for some t$.
(ii) s% is a ground term over 7 and % solves R |&r s  t.
Proof. (i) O (ii) Let %$=% _ [F [ t$] satisfying (i) be given. There are two
cases by Lemma 1((i) O (ii)). The first case is that t$=*z .*zm+1 .zm+1 and t%$=s%$,
and thus t%=s%. Hence, (ii) holds trivially. The second case is that there exists a
k1 and closed terms si for 1ik, such that
t$=*z .*zm+1 . f (s1(z ), f (s2(z ), ..., f (sk(z ), zm+1) } } } ))
and s%=s1(l9 %), s i(r %)=si+1(l9 %), for 1i<k, sk(r %)=t%. Clearly, si (l9 %) *R% si (r %)
for 1ik, and thus si (l9 %) *R% si+1(l9 %), for 1i<k. It follows that
s%=s1(l9 %) *R% sk(l9 %) *R% sk(r %)=t%,
as needed.
(ii) O (i) Let % be a substitution satisfying (ii). We have a reduction:
s%=t0 R% t1 R% } } } R% tk&1 R% tk=t%.
If k=0 then let t$=*z .*zm+1 .zm+1 and (i) follows from Lemma 1((ii) O (i)).
Assume that k1 and consider a fixed i, 1ik. The rewrite step ti&1 R ti uses
a rule lj%  rj % for some j, 1 jm, and replaces a certain subterm occurrence of
lj% in ti&1 by rj%. Construct si from t i&1 by replacing that occurrence of lj% by zj .
So si (l9 %)=ti&1 and si (r %)=t i . Given such si for 1ik, obviously (2)(4) are
true. Let
t$=*z .*zm+1 . f (s1(z ), f (s2(z ), ..., f (sk(z ), zm+1) } } } ))
and (i) follows from Lemma 1((ii) O (i)). K
The following example shows why the additional restrictions on the signature are
crucial in Lemma 2.
Example 3. The reachability constraint
[X  b] |&r g(a, d )  g(b, b)
is unsolvable. However, the second-order equation
F(X, f ( g(b, b), c)) =? f ( g(a, d ), F(b, c))
has a solution % such that F%=*z1 .*z2 .z1 and X%= f (g(a, d ), b). Notice that this
substitution violates the restriction that X% is a ground term over [a, b, d, g].
133SECOND-ORDER UNIFICATION
4. FROM SREU TO SOU
We apply the results in the previous section to show that there is a polynomial
time reduction of SREU to SOU. The converse reduction, from SOU to SREU, is
given in (Degtyarev and Voronkov, 1996) and has also polynomial time com-
plexity. We use a restricted form of SREU that is polynomial time equivalent to
SREU and allows us to apply Lemma 2 in a direct manner.
Let R be a system of reachability constraints over 7, and let X be a variable that
occurs in R. A guard for X in R, if one exists, is any reachability constraint
R |&r s  t in R such that R is a set of ground rules, t is a ground term, and X
occurs in s. The system R is called guarded if there is a guard in R for each variable
that occurs in R.
Guarded simultaneous rigid reachability is the restriction of simultaneous rigid
reachability to guarded systems. Guarded SREU is the symmetric form of this
problem. Guardedness is an important and useful notion also in other contexts
(Gurevich and Veanes, 1999). We will use the following fact, making use of a
technique of Degtyarev and Voronkov (1995).
Lemma 3. SREU is polynomial time equivalent to guarded SREU.
Proof. For each variable X in the given system of rigid equations (over 7), add
the rigid equation
[ f (c, ..., c)rc : f # 7] |&r X  c
to the system, where c is a constant in 7. The new system is guarded and is solvable
if and only if the original system is solvable (Degtyarev and Voronkov, 1995). K
The following result constituted a very transparent undecidability proof of
SREU.
Theorem 4 (Degtyarev and Voronkov (1996)). There is a polynomial time
reduction of SOU to SREU.
The converse direction follows from the following theorem and Lemma 3.
Theorem 5. There is a polynomial time reduction of guarded simultaneous rigid
reachability to SOU restricted to equation systems S, where each equation in S has
the form F(l9 , f (t, c)) =? f (s, F(r , c)) with all terms in s, t, l9 , r being first-order and F
occurring only in this equation.
Proof. Let R=[Ri |&r s i  ti : 1in] be a guarded system of reachability
constraints over a signature 7. Let c and f be new function symbols with arities 0
and 2, respectively. For each reachability constraint Ri |&r si  ti , Ri=
[lj  rj : 1 jmi], construct the second-order equation Si ,
Fi (l1 , ..., lmi , f (t, c)) =
? f (s, Fi (r1 , ..., rmi , c)),
where F i is a new second-order variable. Let S=[Si : 1in].
134 LEVY AND VEANES
Consider any substitution % that is undefined for the Fi ’s. We prove that some
extension of % solves S if and only if % solves R.
(O) Assume that %$=% _ [Fi [ t$i : 1in] solves S.
First, we show that, for 1in, Ri % is a set of ground rules over 7 and ti% is
a ground term over 7. Consider a fixed i. Let X be a variable in Ri or t i . Let
Rj |&r s j  tj be a guard for X in R. So Rj and tj are ground and % _ [Fj [ t$j]
solves Sj . It follows from Lemma 2((i) O (ii)) that sj% is a ground term over 7, and
thus, so is X%.
Second, we apply Lemma 2((i) O (ii)) again to all the Si ’s to show that %$ solves R.
(o) By Lemma 2((i) o (ii)) and the fact that all the Fi ’s are distinct. K
The following example illustrates the importance of guardedness. The proof of
Theorem 5 fails already for very simple systems of rigid equations that are not
guarded.
Example 4. Consider the system R=[< |&r X  Y] where X and Y are
variables. Then the corresponding system S of second-order equations has the form
[F( f (X, c))r f (Y, F(c))]. Let %=[F [ *z . f (z, z), X [ c, Y [ f (c, c)]. It is easy to
check that % solves S but it does not solve R.
From Lemma 3 and Theorems 4 and 5 we get the following result.
Corollary 6. The following three problems are polynomial time equivalent:
 SREU,
 SOU,
 SOU restricted to equation systems S, where each equation in S has the
form F(l9 , f (t, c)) =? f (s, F(r , c)) with all terms in s, t, l9 , r being first-order and F
occurring only in this equation.
This shows that already this very restricted form of SOU is undecidable. In con-
trast, the corresponding linear SOU problem is decidable (Levy, 1996). In (1998),
the authors proved that guarded simultaneous rigid reachability is undecidable
already when restricted to systems of at most two reachability constraints. This
result and the proof of Theorem 5 imply the following, even more restrictive,
undecidability result.
Corollary 7. Second-order unification is undecidable under the following
restrictions on equation systems: there are at most two distinct second-order variables;
every second-order variable occurs at most twice and in at most one equation; every
equation contains at most one second-order variable.
One may wonder if this result can be improved, and indeed it can. Ganzinger et
al. (1998) proved recently that rigid reachability is undecidable (already for ground
rules). Using this result, the particular structure of the reachability constraints, and
an analogue of Lemma 2 (Lemma 2 is not directly applicable to those reachability
constraints), they concluded that SOU is undecidable already when there is a single
second-order variable that occurs at most twice.
135SECOND-ORDER UNIFICATION
There is an important difference between the reduction from SREU to SOU on
one hand and the reduction from SOU to SREU on the other hand. In the former
reduction one needs a binary function symbol, whereas the latter reduction shows
that monadic SOU reduces to monadic SREU. The use of the binary function sym-
bol in the former reduction seems to be unavoidable because of the following
reason. Decidability of monadic second-order unification can be proved by reduc-
tion to word equations (Farmer, 1988), whereas monadic SREU is only known to
reduce to a nontrivial extension of word equations (Gurevich and Voronkov, 1997),
and its decidability is an open problem.
5. ONE SECOND-ORDER VARIABLE IS ENOUGH
The principal result of this section is that the number of different second-order
variables in SOU plays a minor role compared to the total number of occurrences
of second-order variables. We present a straightforward reduction of arbitrary
systems of second-order equations to systems of second-order equations using just
one second-order variable and additional first-order variables. The encoding tech-
nique that we use is similar to the techniques used by Farmer (1991). Several impor-
tant properties are preserved by that reduction: maximal arity of variables, number
of occurrences of second-order variables, and simplicity. Let S be a system of
second-order equations. We write occ2(S) for the number of occurrences of second-
order variables in S. We write arity2(S) for the maximal arity of the second-order
variables in S.
An interpolation equation is a second-order equation of the form F(t ) =? s, where
F is a second-order variable, t is a sequence of first-order terms, and s is a first-
order term. The following fact is well known and easy to prove (e.g., Degtyarev and
Voronkov, 1996).
Lemma 8. Let S be a system of second-order equations. There is a system S$ of
interpolation equations such that S$ is solvable if and only if S is solvable. Moreover,
arity2(S)=arity2(S$), occ2(S)=occ2(S$), and if S is simple then so is S$.
We now define a reduction from a system of interpolation equations to a system
of interpolation equations that uses just one second-order variable with arity equal
to the maximal arity of variables in the original system. Let S be a system of inter-
polation equations,
.
1im
[Fi (s ij) =
? t ij : 1 jki],
where [F1 , ..., Fm] are the different second-order variables in S and for each Fi
there are ki interpolation equations. Assume, without loss of generality, that the
arities of the F i ’s are equal. Otherwise, if some Fi has arity less than arity2(S) then
we can increase the arity of Fi to arity2(S) by replacing each occurrence Fi (s ij) by
Fi (s ij , s, ..., s), where s is the last term in the sequence s ij . Clearly, this neither affects
the solvability of S nor the other properties mentioned above.
136 LEVY AND VEANES
Let G be a second-order variable with arity equal to arity2(S), let g be a new m-ary
function symbol, and let S$ denote the system of second-order equations consisting of
.
1im
[G(s ij) =
? g( , ..., 
i&1
, tij ,  , ..., 
m&i
) : 1 jki]
and, unless all elements of some sequence s ij are not variables,2 the equation
G(c, c, ..., c) =? g( ,  , ..., ),
where c is a constant and each occurrence of ‘‘’’ denotes a fresh first-order variable.
By combining Lemma 8 with this reduction we can prove the following result.
Theorem 9. Let S be a system of second-order equations. There is a system of
interpolation equations S$, with at most one second-order variable, such that S$ is
solvable if and only if S is solvable.
Moreover, arity2(S)=arity2(S$), occ2(S)occ2(S$)occ2(S)+1, and if S is
simple then so is S$.
Proof. Assume, without loss of generality, that S consists solely of interpolation
equations. We prove that S is solvable if and only if S$ is solvable. We just consider a
special case. The proof of the general case is analogous. Let S be the following system:
F1(s 1) =
? t1
F2(s 2) =
? t2
F3(s 3) =
? t3 .
Then S$ is the following system:
G(s 1) =
? g(t1 , X12 , X13)
G(s 2) =
? g(X21 , t2 , X23)
G(s 3) =
? g(X31 , X32 , t3)
( G(c ) =? g(X1 , X2 , X3) ).
(O) Assume % solves S. Define %$ as follows. For all first-order variables in
S, %$ agrees with %. For G, %$(G)=*x . g(%(F1(x )), %(F2(x )), %(F3(x ))). For the new
first-order variables [X12 , X13 , X21 , X23 , X31 , X32], let %$(Xij)=%(F j (s i)). For
[X1 , X2 , X3], let %$(Xj)=%(Fj (c )).
Consider the first equation of S$. We have that
%$(G(s 1))=g(%(F1(s 1)), %(F2(s 1)), %(F3(s 1)))
=g(%(t1), %$(X12), %$(X13))
=%$(g(t1 , X12 , X13)).
137SECOND-ORDER UNIFICATION
2 This condition can be weakened.
Hence, %$ solves G(s 1) =
? g(t1 , X12 , X13). The other cases are similar.
(o) Assume that %$ solves S$, we construct a substitution % that solves S.
We have %$(G)=*x . g(u1(x ), u2(x ), u3(x )) for some closed terms u1 , u2 and u3 , or
else, %$ would not solve either an equation in S$ where all arguments of G are non-
variables (note that g does not occur in those arguments), or the optional equation
G(c ) =? g(X1 , X2 , X3).
Define % so that it agrees with %$ on first-order variables in S and %(Fi)=ui for
1i3. By applying %$ to the left-hand side of the first equation of S$ we have
that
%$(G(s 1))=g(u1(%$(s 1)), u2(%$(s 1)), u3(%$(s 1)))
=g(%(F1(s 1)), u2(%$(s 1)), u3(%$(s 1))),
and by applying %$ to the right-hand side of the same equation we have that
%$(g(t1 , X12 , X13))= g(%(t1), %$(X12), %$(X13).
But %$ solves S$, and thus %(F1(s 1))=%(t1). Hence, % solves F1(s 1) =
? t1 . The other
cases are similar. K
The above reduction implies, by using Goldfarb’s (1981) result, the
undecidability of SOU with a single second-order variable. By using the following
theorem, we get a stronger result.
Theorem 10 (Farmer (1991)). Second-order unification is undecidable even when
all second-order variables are unary.
Farmer’s theorem and Theorem 9 imply the following.
Corollary 11. Second-order unification is undecidable already with a single
unary second-order variable.
This result may be sharpened, by using Farmer’s (1991) encoding techniques, to
hold already when the only function symbols in the signature are a constant c and
a binary function symbol f.
6. UNDECIDABILITY OF SOU REVISITED
We present an elementary undecidability proof of SOU by a direct encoding from
the halting problem for Turing machines. The proof by Goldfarb (1981) uses
Hilbert’s tenth problem. The latter problem is proved undecidable by Matiyasevich
(1970), by using sophisticated numbertheoretical methods. We use techniques
from (Plaisted, 1995; Gurevich and Veanes, 1999) and apply them in the context
of SOU, by using the lemmas in Section 3.
We consider a fixed deterministic Turing machine M with initial state q0 , final
state qf , a blank character ?, and an input alphabet that does not include the blank.
The tape of M is infinite in only one direction. By 7M we denote the set of all the
symbols in M, i.e., the states, the input characters, and the blank. All elements of
138 LEVY AND VEANES
7M are assigned arity 0, i.e., are treated as constants. We assume, without loss of
generality, that before acceptance M erases its tape contents, i.e., M is only allowed
to write a blank when it erases the last nonblank symbol on the tape and continues
to erase all the symbols before it, before entering the final state with the empty tape.
An ID of M is any string vqw where vw is a string over the input alphabet of M
and q is a state of M. In particular, the initial ID of M for input string v has the
form q0v, and the final ID is simply the one character string q f . A move of M is any
pair of strings (v, v+) where v is an ID and v+ is the successor of v according to
the transition function of M, if v is non-final. The successor of the final state is the
empty string (=), i.e., q+f ==.
6.1. Main Idea
We construct two second-order equations SMmv(F, G) and S
M
sp(X, F ) from M that
have roughly the following properties: for any substitution % and initial ID q0v0
that is represented by a term t0 ,
1. % solves SMmv(F, G) (for some G%) if and only if F% represents a sequence
of moves of M:
((v1 , v+1 ), (v2 , v
+
2 ), ..., (vk , v
+
k )).
2. % solves SMsp(t0 , F ) if and only if F% represents the shifted pairing of a
sequence (v1 , v2 , ..., vk) of IDs of M, where v1=q0 v0 and vk=qf . (See Fig. 3.)
Consequently, % solves both second-order equations if and only if F% represents (the
shifted pairing of) the valid computation of M with input v0 .
6.2. Encoding Sequences of Moves
We introduce a family of new constants [cab | a, b # 7M] and use them to encode
moves of M in the following manner. Let v=a1a2 } } } am be any ID of M and let
v+=b1 b2 } } } bn be its successor. Note that m&1nm+1. We let (v, v+)
denote the following string:
ca1 b1 ca2b2 } } } cam bm c?bn , if n=m+1;
(v, v+)={ca1b1 ca2b2 } } } can bn cam? , if n=m&1;ca1 b1 ca2b2 } } } cam bn , if n=m.
FIG. 3. Shifted pairing.
139SECOND-ORDER UNIFICATION
We call such a string a move of M or an M-move. Note that (qf , =)=cqf ? .
Intuitively, a blank is added at the end of the shorter of the two strings (in case
they differ in length) and the pair of the resulting strings is encoded character by
character.
We fix two new constants cw and ct and two new binary function symbols fw and
ft . Let 7id and 7mv be the following signatures:
7id=7M _ [cw , fw]
7mv=[cab | a, b # 7M] _ [cw , fw , ct , ft].
A term s is a called a word if either s=cw (the empty word ) or s= fw(c, s$) for
some constant c that is distinct from cw and word s$. Whenever convenient, we
write a word as follows,
fw(a1 , fw(a2 , } } } fw(an , cw) } } } ))=‘a1a2 } } } an’,
and say that the word represents the string. A term t is called a train if either t=ct
(the empty train) or t= ft(s, t$) for some word s and train t$. So trains are simply
representations of string sequences. Conceptually we identify words with strings and
trains with sequences of strings.
A train that represents a sequence of M-moves is called a move-train of M or an
M-move-train.
Example 5. Consider a Turing machine M that in state q, overwrites any sym-
bol by >, moves right, and remains in state q. The following term is a move-train
of M:
ft(‘(q, >q)’, ft(‘(aqaa, a>qa)’, ft(‘(>q, >>q)’, ct))).
Note that two consecutive moves in move-trains need not be related. K
Lemma 12 follows from (Gurevich and Veanes, 1999, Train lemma) and the fact
that the set of all moves of M is a regular set of strings. (See also (Gurevich and
Veanes, 1999, Lemma 18).) It is used together with Lemma 2 to construct the
second-order equation SMmv(F, G) with the desired properties.
Lemma 12. There is a ground rewrite system Rmv over 7mv _ Qmv , where Qmv is
a set of constants disjoint from 7mv , with rules of the form f (a, b)  c and a  b,
where a, b, c are constants, such that, for all ground terms t over 7mv , t is a
move-train of M if and only if t *Rmv ct .
6.3. The Main Reduction
Let Rmv and Qmv be given by Lemma 12, such that 7mv & Qmv=<. Let
m=|7M |2 and let ((a i , bi))1im be a fixed sequence of all the pairs of constants
140 LEVY AND VEANES
from 7M . We will be using the following definitions and shorthand notations
throughout the rest of this section.
v a denotes the sequence a1 , a2 , ..., am of constants.
v b9 denotes the sequence b1 , b2 , ..., bm of constants.
v c denotes the sequence ca1b1 , ca2b2 , ..., cambm of constants.
v z denotes the sequence za1b1 , za2b2 ,..., zambm of distinct variables; we also write
zi for zaibi .
v Let Rmv=[l i  ri : 1i|Rmv |], let l9 mv denote the sequence l1 , ..., l |Rmv | ,
and let r mv denote the sequence r1 , ..., r |Rmv | .
v d is a new constant and g is a new binary function symbol.
For any ground term t, we define the second-order equations SMsp(t, F ) and
SMmv(F, G) as follows:
SMsp(t, F ): F(a , ‘?’, cw , ft(‘?’, ct)) =
? ft(t, F(b9 , cw , ‘?’, ct))
SMmv(F, G): G(l9 mv , g(ct , d )) =
? g(F(c , cw , cw , ct), G(r mv , d )).
Let us briefly recall the intuition behind this construction. Assume that % solves this
system of two equations. First, consider SMmv(F%, G%). It follows from Lemma 12
(with a little help from Lemma 13 below) that %(F(c , cw , cw , ct)) is a ground term
over 7mv representing a sequence of moves of M:
((v1 , v+1 ) , (v2 , v
+
2 ) , ..., (vk , v
+
k ) ).
Second, consider SMsp(t, F%) and Lemma 1. This tells us that F% is a term over the
signature 7id _ [ ft , ct], and thus cannot contain constants from c . Consequently,
without loss of generality, F% has the form *z *x1x2 y . tF , where every occurrence of
cab in %(F(c , cw , cw , ct)) corresponds to zab in tF . Therefore %(F(a , ‘?’, cw , ft(‘?’,
ct))) represents (roughly) the sequence
(v1 , v2 , ..., vk , ?)
and ft(‘ID0’ , %(F(b9 , cw , ‘?’, ct))), where ‘ID0’=t represents (roughly) the sequence
(ID0 , v+1 , v
+
2 , ..., v
+
k ).
But these two sequences must be equal, which implies that (v1 , v2 , ..., vk) is a valid
computation of M.
Example 6. Suppose we have a Turing machine M that accepts the one-charac-
ter sequence a. A valid computation of M can have the form
(q0a, aq1 , q2a, qf).
141SECOND-ORDER UNIFICATION
FIG. 4. A closed term that encodes the valid computation in Example 6.
A solution F% of the second-order system encodes this valid computation of M as
is illustrated in Fig. 4. K
Before proving the main theorem we prove a simple lemma.
Lemma 13. Given a ground term t over 7id and a substitution %, if % solves
[SMsp(t, F ), S
M
mv(F, G)] then F% is a closed term of arity m+3 over [cw , fw , ct , ft].
Proof. Let t and % be given, and assume that % solves [SMsp(t, F ), S
M
mv(F, G)]. It
follows from % solving SMsp(t, F ) and Lemma 1 that F% is a closed term of arity
m+3 over the signature 7id _ [ct , ft]. It follows from % solving SMmv(F, G) and
again Lemma 1 that %(F(c , cw , cw , ct))=s1(l9 mv) for some closed term s1 over
7mv _ Qmv. Hence, %(F(c , cw , cw , ct)) is a ground term over 7mv _ Qmv. So F% is a
closed term of arity m+1 over (7mv _ Qmv) & (7 id _ [ct , ft])=[cw , fw , ct , ft]. K
We can now prove the main theorem. Recall that the initial state of M is q0 .
Theorem 14. For any input string v0 for M, the second-order unification problem
[SMsp(‘q0v0’, F ), S
M
mv(F, G)] is solvable if and only if M accepts v0 .
Proof. Let v0 be given.
(O) Assume that the system [SMsp(‘q0v0’, F ), S
M
mv(F, G)] is solvable, and let %
be a solution. Since % solves SMmv(F, G), it follows from Lemma 2 that
%(F(c , cw , cw , ct)) *Rmv ct ,
and it follows from Lemma 13 that %(F(c , cw , cw , ct)) is a ground term over 7mv.
Hence, by Lemma 12, %(F(c , cw , cw , ct)) is a move-train of M,
%(F(c , cw , cw , ct))= ft(‘(v1 , v+1 ) ’, ... ft(‘(vk , v
+
k ) ’, ct) } } } ), (7)
where each vi is an ID of M and k0. But % solves also SMsp(‘q0v0’, F ); hence, it
follows from Lemma 1 that
%(F )=*z .*x1x2 y . ft(s1(z , x1 , x2), ... ft(sk$(z , x1 , x2), y) } } } ), (8)
142 LEVY AND VEANES
where
‘q0 v0’=s1(a , ‘?’, cw), (9)
si (b9 , cw , ‘?’)=si+1(a , ‘?’, cw), for 1i<k, (10)
sk$(b9 , cw , ‘?’)=‘?’. (11)
The case k$=0, i.e., %(F )=*z .*x1x2 y . y, is not possible because ‘q0v0 ’{‘?’. By
comparing (7) and (8), and using Lemma 13, every si (z , x1 , x2) is a term over
[cw , fw], k=k$ and
si (c , cw , cw)=‘(vi , v+i )’, for 1ik. (12)
Thus si (a , ‘?’, cw) is either ‘vi ’, ‘vi? (or ‘vi??’). Similarly, si (b9 , cw , ‘?’) is either
‘v+i ’ , ‘v
+
i ?’ (or ‘v
+
i ??’). It follows from (9) that q0v0=v1 , it follows from (11)
that vk=qf , and it follows from (10) that v+i =vi+1 for 1i<k. Hence, M accepts
v0 .
(o) Assume that M accepts v0 . We will construct a substitution % that solves
[SMsp(‘q0v0’, F ), S
M
mv(F, G)]. Consider a valid computation of M with input v0 ,
((v1 , v2), (v2 , v3), ..., (vk , vk+1)),
for some k1, where v1=q0v0 , v+i =v i+1 for 1ik, and vk=qf (i.e., vk+1==).
We define F% as in (8) with k$=k, where the si ’s are defined as follows. First, let
i, 1ik, be fixed and assume that
(vi , v+i )=caj1bj1 caj2 bj2 } } } cajnbjn .
Let si be the term
*z . fw(zj1 , fw(zj2 , ... fw(z jn , s$i) } } } )),
where si$ is defined as one of [x1 , x2 , cw] according to the following rules. We write
|v| for the length of a string v. First, suppose that 1<i<k. There are in principle
nine different cases (according to the lengths of the moves that surround the i th
move):
1. |(vi&1 , v+i&1) |<|(vi , v
+
i ) |= |(vi+1 , v
+
i+1) |,
2. |(vi&1 , v+i&1) |=|(vi , v
+
i ) |= |(vi+1 , v
+
i+1) |,
3. |(vi&1 , v+i&1) |>|(vi , v
+
i ) |= |(vi+1 , v
+
i+1) |,
4. |(vi&1 , v+i&1) |<|(vi , v
+
i ) |> |(vi+1 , v
+
i+1) |,
5. |(vi&1 , v+i&1( |=|(vi , v
+
i ) |> |(vi+1 , v
+
i+1) |,
6. |(vi&1 , v+i&1) |>|(vi , v
+
i ) |> |(vi+1 , v
+
i+1) |,
7. |(vi&1 , v+i&1) |<|(vi , v
+
i ) |< |(vi+1 , v
+
i+1) |,
8. |(vi&1 , v+i&1) |=|(vi , v
+
i ) |< |(vi+1 , v
+
i+1) |,
143SECOND-ORDER UNIFICATION
and the case |(vi&1 , v+i&1) |>|(vi , v
+
i ) |<|(vi+1 , v
+
i+1) |, that is (due to the spe-
cial assumptions about M ) not possible.
Let s$i be x1 in cases 3 and 6. Let s$i be x2 in cases 7 and 8. In all the other cases
(i.e., 1, 2, 4, and 5) let s$i be cw . Second, suppose that i=1, we may assume that
the first move has the same length as the second move, and let s$i=cw . Third, sup-
pose that i=k, we may assume that the last move is strictly shorter than the move
before it, and let s$i=x1 . Obviously,
si (c , cw , cw)=‘(vi , vi+1) ’, (1ik).
Let F% be defined as in (8). Then the term %(F(c , cw , cw , ct)) is a move-train of M.
First, it follows from Lemma 12 that
%(F(c , cw , cw , ct)) *Rmv ct .
Second, it follows from Lemma 2 that there exists a substitution % that solves
SMmv(F, G). Finally, one can easily check that the conditions (9), (10), and (11) hold,
by looking at the different cases (corresponding to cases 18) above. For example,
if case 3 holds for i (i.e., s$i=x1), then one of cases 46 holds for i&1 (i.e., s$i&1=cw
or s$i&1=x1), and thus, si (a , ‘?’, cw)=‘vi ?’ and si&1(b9 , cw , ‘?’)=‘vi?’. It follows
from Lemma 1 that % also solves the equation SMsp(‘q0v0’, F ). K
Let us consider a fixed universal Turing machine Mu with input alphabet 7u and
initial state q0 . Any pair (M, v), where M is a TM and v is an input string for M
is encoded effectively as a string over 7u , denoted by (M, v). The details of such
an encoding are not relevant here and can be found, for example, in (Hopcroft and
Ullman, 1979). The universal TM accepts (M, v) if and only if M accepts v.
We get the following two corollaries. Corollary 15 is an easy consequence of
Theorem 14 if the constructions there are based on Mu .
Corollary 15. There is a system S u(X, F, G) of two second-order equations,
[F(t 1) =
? f (X, F(t 2)), G(t 3) =
? g(F(t 4), G(t 5))],
where the t i ’s are sequences of ground terms of depth 2 such that the problem of
determining whether Su(t, F, G) is solvable for a given ground term t is undecidable.
Corollary 16. There is an integer n such that second-order unification is
undecidable for equation systems satisfying conditions (15):
1. (Schubert (1997)) the arguments of all variables are ground terms,
2. the arguments of all variables have depth <n,
3. the arity of all variables is <n,
4. the number of occurrences of second-order variables is 5, and
5. one of the following two cases holds:
(a) there is a single second-order variable, or
(b) there are at most two second-order variables and no first-order variables.
144 LEVY AND VEANES
Proof. Consider a fixed system S u given by Corollary 15. The conditions 14
and 5(b) follow immediately as properties of Su, by choosing n to be large enough.
In order to obtain 14 and 5(a), first translate S u(X ) into a set S$(X ) of interpola-
tion equations:
F(t 1) =
? f (X, Y1)
F(t 2) =
? Y1
F(t 4) =
? Y2
G(t 3) =
? g(Y2 , Y3)
G(t 5) =
? Y3 .
Second, apply the reduction in Theorem 9 to S$(X) to obtain a system S"(X) with
a single second-order variable H (assume, without loss of generality, that F, G, and
H have the same arity) and an additional binary function symbol h:
H(t 1) =
? h( f (X, Y1), )
H(t 2) =
? h(Y1 , )
H(t 4) =
? h(Y2 , )
H(t 3) =
? h( , g(Y2 , Y3))
H(t 5) =
? h( , Y3).
Note that all the t i ’s are sequences of ground terms. It follows from Theorem 9 that,
for all ground terms t, Su(t) is solvable if and only if S"(t) is solvable. Hence, the
undecidability result for 14 and 5(a) follows from Corollary 15 and the structure
of S". K
It is straightforward to show that Corollary 16 remains true even when the
signature includes a single constant and a single function symbol of arity >1, by
using encoding techniques in (Farmer, 1991).
It was observed by Voronkov that, by applying the reduction in (Degtyarev and
Voronkov, 1996) to a system of simple second-order equations, one obtains a
system of reachability constraints with ground left-hand sides. (The converse does
not hold, i.e., the reduction from a system of reachability constraints with ground
left-hand sides, by using Theorem 5, does in general not yield a system of simple
second-order equations.) Thus, by using Schubert’s (1997) result, Degtyarev and
Voronkov’s (1996) reduction implies an elegant proof of Plaisted’s (1995) result.
Corollary 17 (Plaisted (1995)). SREU is undecidable with ground left-hand
sides.
6.4. Related Work
A form of shifted pairing appears already in Hopcroft and Ullman’s (1979) proof
of the undecidability of the intersection emptiness problem of context free
145SECOND-ORDER UNIFICATION
languages. It was more directly used by Plaisted (1995) in the context of SREU and
then in a refined form by Veanes (1996). The train lemma (Gurevich and Veanes,
1999) uses three automata theoretic techniques and connections to term rewriting
(e.g., Dauchet, 1993) and has its roots in (Plaisted, 1995; Veanes, 1996). These two
techniques have been the main tools in proving undecidability results of restricted
forms of SREU (e.g., Gurevich and Veanes, 1999). The proof of Theorem 14 is an
application of these techniques in the context of SOU, by using the relations
between rigid reachability and second-order unification developed in Section 3. In
fact, some relations between rigid reachability and second-order unification were
explicitly used already by Farmer (1991, Lemma 5.2). A closer look at the multi-
plication equations in Goldfarb’s (1981) proof shows that similar properties are
also exploited there.
There is a close relationship between our work and the work of Schubert (1997).
Schubert showed the undecidability of SOU for simple equations. This result was
an important tool in establishing the undecidability of certain types of inference
problems (Schubert, 1997; Schubert, 1998). His undecidability proof is by reduction
from Minsky machines and the construction is quite technical. Although our proof
was developed independently, the resulting set of equations in (Schubert, 1997,
Definition 17) includes two main equations whose shape and purpose have a close
resemblance to those in Theorem 14. A careful analysis of the constructions in
(Schubert, 1997) shows that they also rely upon links between simple equations of
the form in Lemma 2 and ground term rewriting.
Further evidence of the fundamental role of such equations is that solvability of
a single equation of the form in Lemma 2 is already undecidable (Ganzinger et al.,
1998) (also this result uses the shifted pairing technique).
7. CURRENT STATUS OF SECOND-ORDER UNIFICATION AND
SOME OPEN PROBLEMS
We give a (roughly) chronological list of the main results known about second-
order unification, including the main new contributions of this paper. Monadic
below means that all function symbols have arity 1. Recall also that in simple
equations, arguments of second-order variables are required to be ground terms.
1. The undecidability of higher-order unification in general, in fact third-
order unification, was proved (independently) by Huet (1973) and by Lucchesi
(1972).
2. In (1981) Goldfarb showed that second-order unification is undecidable,
by reduction from Hilbert’s tenth problem.
3. In (1979) Zhezherun showed that monadic second-order unification is
decidable. This result is also proved by Farmer (1988), by reduction to word equa-
tions (the decidability of the latter problem is an important result due to Makanin
(1977)).
4. In (1991) Farmer showed that there is an integer n such that second-
order unification is undecidable even if all second-order variables are unary, and
146 LEVY AND VEANES
there are at most n second-order variables, and first-order variables are not allowed
to occur in equations.
5. Some (incomparable) cases of context unification are proved to be
decidable by Comon (1993) and Schmidt-Schau? (1995). Recent developments
toward a more general decidability result are discussed by Schmidt-Schau? and
Schulz (1998).
6. Some cases of linear second-order unification are proved to be decidable
by Levy (1996), in particular when each variable occurs at most twice.
7. Schubert (1997) proves that second-order unification is undecidable for
systems of simple equations.
8. A natural polynomial time reduction from second-order unification to
SREU is given by Degtyarev and Voronkov (1996). A converse direction, from
SREU to second-order unification, is given in Section 4.
9. In Section 5 we show that second-order unification is undecidable already
with a single unary second-order variable.
10. In Section 6 we give a simpler proof of Schubert’s (1997) result and
improve it in several ways. In particular, second-order unification is shown
undecidable in the simple case already with a single second-order variable that is,
moreover, only allowed to occur at most five times.
11. Ganzinger et al. (1998) prove that rigid reachability is undecidable, even
for ground systems of rules. They use this result and an analogue of Lemma 2 to
derive the undecidability of second-order unification with a single second-order
variable that occurs at most twice. Here the occurrences of the second-order
variable may have first-order variables in its arguments.
The above list of results is not exhaustive. Some borders between decidable and
undecidable cases of second-order unification are also pointed out by Prehofer
(1994). In this paper we have not discussed matching problems. It should be noted
however, that the second-order matching problem was proved decidable by Huet
and Lang (1978). This result has been generalized in (Dowek, 1991; Dowek, 1994;
Padovani, 1996) and Comon and Jurski (1997) have shown some computational
complexity results.
Moreover, due to the strong connection between second-order unification and
SREU, several results concerning SREU, in particular its relation to intuitionistic
logic and to several fundamental classical decision problems related to Herbrand’s
theorem, carry over to second-order unification. The most recent survey discussing
such relations is given by (Voronkov, 1998).
The decidability of monadic SREU is currently an open problem, only some spe-
cial cases are known to be decidable (Degtyarev et al., 1996; Gurevich and
Voronkov, 1997; Cortier et al., 1999). In a recent paper Voronkov (1998) discusses
connections of SREU with other problems and presents precise results with respect
to signatures. The decidability of SREU restricted to two rigid equations, even in
the guarded case and with ground left-hand sides, is another intriguing open
problem. The corresponding fragment of simultaneous rigid reachability is
147SECOND-ORDER UNIFICATION
undecidable (Levy and Veanes, 1998). In contrast, decidability of guarded (non-
simultaneous) rigid reachability (i.e., when the rule set and one of the terms are
ground) follows already from Brainerd’s (1969) results.
Levy (1996) proved that linear second-order unification is decidable when no
second-order variable occurs more than twice. In Section 4 we show that, under
this same restriction, second-order unification is undecidable. This establishes a
clear difference between these two apparently similar problems. The decidability of
linear second-order unification and context unification, are both open problems. In
all undecidability proofs of the restricted cases of second-order unification that we
have considered, a common key feature is the unboundedness of the number of
occurrences of bound variables in closed terms in solutions. A recent claim by
Schmidt-Schau? (1999) is that second-order unification is decidable when an upper
bound on the number of occurrences of each bound variable in a closed term in a
solution is fixed.
Final remark. Since Goldfarb (1981) proved the undecidability of second-order
unification, very few decidable and undecidable subclasses of second-order unifica-
tion problems have been found. Here we have characterized decidability for classes
defined in terms of number of second-order variables, number of occurrences per
variable, arity of variables and groundness of their arguments (simplicity of equa-
tions).
Moreover, we have stated and proved a very close relationship between the
simultaneous rigid E-unification problem and the second-order unification problem.
This relationship allows us to translate some decidabilityundecidability results and
proof techniques from one class of problems to the other.
ACKNOWLEDGMENTS
We acknowledge M. Bonet, H. Ganzinger, A. Rubio, S. Vorobyov, M. Villaret, and all the anonymous
referees of this paper for their comments and support. We especially thank R. Nieuwenhuis and
A. Voronkov for suggesting to us the study of the possible relationship between second-order unification
and the simultaneous rigid E-unification problem. We also thank A. Schubert for comments and sugges-
tions that led to considerable improvements of the final manuscript.
Received September 1998
REFERENCES
Baader, F., and Nipkow, T. (1998), ‘‘Term Rewriting and All That,’’ Cambridge University Press,
Cambridge, UK.
Brainerd, W. (1969), Tree generating regular systems, Inform. and Control 14, 217231.
Comon, H. (1993), Completion of rewrite systems with membership constraints, to appear in J. Symbolic
Comput.
Comon, H., and Jurski, Y. (1997), Higher-order matching and tree automata, in ‘‘Proc. Conf. on
Computer Science Logic’’ (M. Nielsen and W. Thomas, Eds.), Lecture Notes in Computer Science,
Vol. 1414, pp. 157176, Springer-Verlag, Berlin.
Cortier, V., Ganzinger, H., Jacquemard, F., and Veanes, M. (1999), Decidable fragments of simultaneous
rigid reachability, in ‘‘26th International Colloquium on Automata, Languages, and Programming,
ICALP’99,’’ Lecture Notes in Computer Science, Springer-Verlag, Berlin.
148 LEVY AND VEANES
Dauchet, M. (1993), Rewriting and tree automata, in ‘‘Term Rewriting (French Spring School of
Theoretical Computer Science, Font Romeux, France’’ (H. Comon and J. P. Jouannaud, Eds.),
Lecture Notes in Computer Science, Vol. 909, pp. 95113, Springer-Verlag, Berlin.
Degtyarev, A., and Voronkov, A. (1995), ‘‘Reduction of Second-Order Unification to Simultaneous Rigid
E-Unification,’’ Technical Report 109, Computer Science Department, Uppsala University, Sweden.
Degtyarev, A., and Voronkov, A. (1996), The undecidability of simultaneous rigid E-unification, Theoret.
Comput. Sci. 166, 291300.
Degtyarev, A., Gurevich, Y., and Voronkov, A. (1996), Herbrand’s theorem and equational reasoning: Pro-
blems and solutions, in ‘‘Bulletin of the European Association for Theoretical Computer Science,’’ Vol. 60.
Degtyarev, A., Matiyasevich, Y., and Voronkov, A. (1996), Simultaneous rigid E-unification and related
algorithmic problems, in ‘‘Eleventh Annual IEEE Symposium on Logic in Computer Science
(LICS’96), New Brunswick, NJ,’’ pp. 494502, IEEE Computer Society Press, Los Alamitos, CA.
Dowek, G. (1991), A second-order pattern matching algorithm for the cube of typed *-calculi, in
‘‘Proceedings of Mathematical Foundations of Computer Science (MFCS ’91), Kazimierz Dolny,
Poland’’ (A. Tarlecki, Ed.), Lecture Notes in Computer Science, Vol. 520, pp. 151160, Springer-
Verlag, Berlin.
Dowek, G. (1994), Third order matching is decidable, Ann. Pure Appl. Logic 69, 135155.
Farmer, W. M. (1988), A unification algorithm for second-order monadic terms, Ann. Pure Appl. Logic
39, 131174.
Farmer, W. M. (1991), Simple second-order languages for which unification is undecidable, Theoret.
Comput. Sci. 87, 173214.
Gallier, J. H., Narendran, P., Plaisted, D., and Snyder, W. (1988), Rigid E-unification is NP-complete,
in ‘‘Proc. IEEE Conf. on Logic in Computer Science, LICS’88,’’ pp. 338346.
Gallier, J. H., Raatz, S., and Snyder, W. (1987), Theorem proving using rigid E-unification: Equational
matings, in ‘‘Proc. IEEE Conf. on Logic in Computer Science, LICS’87,’’ pp. 338346.
Ganzinger, H., Jacquemard, F., and Veanes, M. (1998), Rigid reachability, in ‘‘Advances in Computing
ScienceASIAN’98, 4th Asian Computing Science Conference, Manila, The Philippines, December
1998, Proceedings’’ (J. Hsiang and A. Ohori, Eds.), Lecture Notes in Computer Science, Vol. 1538,
pp. 421, Springer-Verlag, Berlin.
Goldfarb, W. D. (1981), The undecidability of the second-order unification problem, Theoret. Comput.
Sci. 13, 225230.
Gurevich, Y., and Veanes, M. (1999), Logic with equality: Partisan corroboration, and shifted pairing,
Inform. and Comput. 152, 205235.
Gurevich, Y., and Voronkov, A. (1997), Monadic simultaneous rigid E-unification and related problems,
in ‘‘Automata, Languages and Programming, 24th International Colloquium, ICALP’97’’ (P. Degano,
R. Corrieri, and A. Marchetti-Spaccamella, Eds.), Lecture Notes in Computer Science, Vol. 1256,
pp. 154165, Springer-Verlag, Berlin.
Hindley, J., and Seldin, J. (1986), ‘‘Introduction to Combinatorics and *-Calculus,’’ Cambridge University
Press, Cambridge, UK.
Hopcroft, J. E., and Ullman, J. D. (1979), ‘‘Introduction to Automata Theory, Languages and Computa-
tion,’’ AddisonWesley, Reading, MA.
Huet, G. (1973), The undecidability of unification in third-order logic, Inform. and Control 22, 257267.
Huet, G., and Lang, B. (1978), Proving and applying program transformations expressed with second-
order patterns, Acta Inform. 11, 2155.
Levy, J. (1996), Linear second-order unification, in ‘‘7th Int. Conf. on Rewriting Techniques and
Applications, RTA’96, New Jersey,’’ Lecture Notes in Computer Science, Vol. 1103, pp. 332346,
Springer-Verlag, Berlin.
Levy, J. (1998), Decidable and undecidable second-order unification problems, in ‘‘Rewriting Techniques
and Applications’’ (T. Nipkow, Ed.), Lecture Notes in Computer Science, Vol. 1379, pp. 4760,
Springer-Verlag, Berlin.
149SECOND-ORDER UNIFICATION
Levy, J., and Veanes, M. (1998), On unification problems in restricted second-order languages, in
‘‘Annual Conference of the European Association for Computer Science Logic, CSL’98, Brno, Czech
Republic.’’
Lucchesi, C. L. (1972), The undecidability of the unification problem for third-order languages, Techni-
cal Report CSRR 2059, Dept. of Applied Analysis and Computer Science, Univ. of Waterloo.
Makanin, G. S. (1977), The problem of solvability of equations in a free semigroup, Math. USSR
Sbornik 32, 129198.
Matiyasevich, Y. (1970), The diophantiness of recursively enumerable sets (in Russian), Soviet Math.
Dokl., 279282.
Niehren, J., Pinkal, M., and Ruhrberg, P. (1997), On equality up-to constraints over finite trees, context
unification, and one-step rewriting, in ‘‘Proceedings of the 14th International Conference on
Automated Deduction, Townsville, North Queensland, Australia’’ (W. McCune, Ed.), Lecture Notes
in Artificial Intelligence, Vol. 1249, pp. 3448, Springer-Verlag, Berlin.
Padovani, V. (1996), ‘‘Filtrage d’ordre supe rieur,’’ Ph.D. thesis, Universite Paris VII.
Pietrzykowski, T. (1973), A complete mechanization of second-order logic, J. Assoc. Comput. Mach. 20,
333364.
Plaisted, D. A. (1995), ‘‘Special Cases and Substitutes for Rigid E-Unification,’’ Technical Report MPI-I-
95-2-010, Max-Planck-Institut fu r Informatik.
Prehofer, C. (1994), Decidable higher-order unification problems, in ‘‘12th International Conference on
Automated Deduction, Nancy, France’’ (A. Bundy, Ed.), Lecture Notes in Artificial Intelligence,
Vol. 814, pp. 635649, Springer-Verlag, Berlin.
Schmidt-Schau?, M. (1995), ‘‘Unification of Stratified Second-Order Terms,’’ Technical Report 1294,
Johan Wolfgang-Goethe-Universita t, Frankfurt, Germany.
Schmidt-Schau?, M. (1999), ‘‘Decidability of Bounded Second Order Unification,’’ Frank-report-11,
Fachbereich Informatik, Johan Wolfgang-Goethe-Universita t, Frankfurt, Germany.
Schmidt-Schau?, M., and Schulz, K. (1998), Decidability of context unification with two variables, in
‘‘UNIF 98, 12th International Workshop on Unification, Rome, June 29July 1, 1998,’’ in ‘‘Research
Report,’’ SI-988, University of Rome, pp. 7174. A more detailed version appears in CADE’99.
Schubert, A. (1997), Second-order unification and type inference for church-style polymorphism,
Technical Report TR 97-02(239), Institute of Informatics, Warsaw University.
Schubert, A. (1998), Second-order unification and type inference for Church-style polymorphism, in
‘‘Conference Record of POPL’98: The 25TH ACM SIGPLAN-SIGACT Symposium on Principles of
Programming Languages, San Diego,’’ pp. 279288, ACM Press, New York.
Schulz, K. U. (1991), ‘‘Makanin’s Algorithm, Two Improvements and a Generalization,’’ Technical
Report CIS-Bericht-91-39, Centrum fu r Informations und Sprachverarbeitung, Universita t Mu nchen.
Veanes, M. (1996), ‘‘Uniform Representation of Recursively Enumerable Sets with Simultaneous
Rigid E-Unification,’’ UPMAIL Technical Report 126, Uppsala University, Computing Science
Department.
Veanes, M. (1998), The relation between second-order unification and simultaneous rigid E-unification,
in ‘‘Proc. Thirteenth Annual IEEE Symposium on Logic in Computer Science, June 2124, 1998,
Indianapolis, Indiana (LICS’98),’’ pp. 264275, IEEE Computer Society Press, Los Alamitos, CA.
Voronkov, A. (1998), Simultaneous rigid E-unification and other decision problems related to the
Herbrand theorem, Theoret. Comput. Sci., in press.
Zhezherun, A. P. (1979), Decidability of the unification problem for second-order languages with unary
functional symbols, Kibernetika (Kiev) 5, 120125. [Translated as Cybernetics 15, 735741, 1980]
150 LEVY AND VEANES
