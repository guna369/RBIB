Universidade de Brasília
Instituto de Ciências Exatas Departamento de Ciência da Computação
Um estudo sobre vericação formal de sistemas concorrentes
João Paulo Carvalho Colu de Queiroz
Brasília 2012

Universidade de Brasília
Instituto de Ciências Exatas Departamento de Ciência da Computação
Um estudo sobre vericação formal de sistemas concorrentes
João Paulo Carvalho Colu de Queiroz
Monograa apresentada como requisito parcial para conclusão do Mestrado em Computação
Orientador Prof. Dr. Flávio Leonardo Cavalcanti de Moura
Brasília 2012

Universidade de Brasília  UnB Instituto de Ciências Exatas Departamento de Ciência da Computação Mestrado em Computação
Coordenadora: Prof. Dr. Mylene Christine Queiroz de Farias
Banca examinadora composta por: Prof. Dr. Flávio Leonardo Cavalcanti de Moura (Orientador)  CIC/UnB Prof. Dr. Daniel Lima Ventura  INF/UFG Prof. Dr. Mauricio Ayala Rincón  CIC/UnB
CIP  Catalogação Internacional na Publicação
Queiroz, João Paulo Carvalho Colu de. Um estudo sobre vericação formal de sistemas concorrentes / João Paulo Carvalho Colu de Queiroz. Brasília : UnB, 2012. 73 p. : il. ; 29,5 cm.
Tese (Mestrado)  Universidade de Brasília, Brasília, 2012. 1. Vericação Formal, 2. Lógica de Hoare, 3. Coq, 4. Linguagens Imperativas, 5. Java, 6. JML, 7. Krakatoa CDU 004.4
Endereço: Universidade de Brasília Campus Universitário Darcy Ribeiro  Asa Norte CEP 70910-900 BrasíliaDF  Brasil

Universidade de Brasília
Instituto de Ciências Exatas Departamento de Ciência da Computação
Um estudo sobre vericação formal de sistemas concorrentes

João Paulo Carvalho Colu de Queiroz

Monograa apresentada como requisito parcial para conclusão do Mestrado em Computação

Prof. Dr. Flávio Leonardo Cavalcanti de Moura (Orientador) CIC/UnB

Prof. Dr. Daniel Lima Ventura Prof. Dr. Mauricio Ayala Rincón

INF/UFG

CIC/UnB

Prof. Dr. Mylene Christine Queiroz de Farias Coordenadora do Mestrado em Computação

Brasília, 14 de junho de 2012

Abstract
This work presents a study of methodologies to formally verify applications developed with imperative languages, specially with the Java language. The theoretical formalisms shown include Hoare Logic, which is used to sketch properties on imperative languages, and JML constructions (based on Hoare Logic), which is a specication language used to specify the expected behavior from Java programs. The tools shown are the Krakatoa system, used to convert JML specications into proof obligations, and the Coq interactive proof environment, used to verify proof obligations. Finally, this paper presents a case study that employs the theoretical and practical proposed framework.
Keywords: Formal Verication, Hoare Logic, Coq, Imperative Languages, Java, JML,
Krakatoa
iv

Resumo
Este trabalho apresenta um estudo de metodologias para vericação formal de aplicativos desenvolvidos em linguagens imperativas, em especial, na linguagem Java. Os formalismos teóricos mostrados incluem a Lógica de Hoare, usada para representar propriedades de aplicações imperativas, e construções da linguagem de especicação JML (baseada na Lógica de Hoare), usada para especicar o comportamento esperado de aplicações codicadas em Java. As ferramentas mostradas são o sistema Krakatoa, usado para converter especicações JML em obrigações de prova, e o ambiente interativo de provas Coq, usado para vericar obrigações de prova. Finalmente, exibe-se um estudo de caso que utiliza o ferramental teórico e prático proposto.
Palavras-chave: Vericação Formal, Lógica de Hoare, Coq, Linguagens Imperativas,
Java, JML, Krakatoa
v

Sumário

Lista de Figuras

viii

Lista de Tabelas

ix

1 Introdução

1

2 Fundamentação Teórica

2.1 Lógica de Hoare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.1.1 O sistema dedutivo de Hoare . . . . . . . . . . . . . . . . . . . . . .

2.2 A linguagem JML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

software2.3 O

Krakatoa . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4 O ambiente de provas Coq . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4.1 Expressões, fórmulas lógicas e novas constantes . . . . . . . . . . .

2.4.2 Proposições e provas . . . . . . . . . . . . . . . . . . . . . . . . . .

3
3 3 5 7 8 8 9

3 Estudo de Caso

11

3.1 Vida Ambiente-Assistida . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

3.1.1 Conexão com os fundamentos teóricos pesquisados . . . . . . . . . . 12

3.1.2 Agente de Emergência . . . . . . . . . . . . . . . . . . . . . . . . . 12

3.1.3 Componentes não vericados . . . . . . . . . . . . . . . . . . . . . . 13

3.2 Especicações JML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

3.2.1 3.2.2

Classe principal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
Classe Agent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

3.2.3 Classes usadas para enleiramento de emergências . . . . . . . . . . 17

3.2.4 Classes usadas para geração de novo comportamento . . . . . . . . 19

3.2.5 Classes usadas para sinalizar emergências . . . . . . . . . . . . . . . 20

3.2.6 Classes herdadas pelos comportamentos . . . . . . . . . . . . . . . 21

vi

3.2.7 Classe estados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

3.2.8 Outras classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

3.3 Obrigações de provas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

3.3.1 Objetivos de prova principais . . . . . . . . . . . . . . . . . . . . . 25

3.3.2 Objetivos triviais . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

3.3.3 Objetivos não provados . . . . . . . . . . . . . . . . . . . . . . . . . 36
Feedback3.4 do uso das ferramentas . . . . . . . . . . . . . . . . . . . . . . . . 36 3.4.1 Workspace Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36

3.4.2 3.4.3

Programação genérica . . . . . . . . . . . . . . . . . . . . . . . . . 38
Model elds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

3.4.4 Classes internas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

3.4.5 Teorias e construções adicionais . . . . . . . . . . . . . . . . . . . . 41

3.4.6 Provador automático Yices . . . . . . . . . . . . . . . . . . . . . . . 43

3.4.7 Objetivos de prova de outros arquivos . . . . . . . . . . . . . . . . . 43

4 Conclusão

47

4.1 Trabalhos futuros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

Referências

49

A Códigos Anotados

52

A.1 MonitorAcuteEmergencyBehaviour.java . . . . . . . . . . . . . . . . . . 52

A.2 Agent.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

A.3 Queue_Emergency.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

A.4 ThreadedBehaviourFactory.java . . . . . . . . . . . . . . . . . . . . . . 56

A.5 ThreadedBehaviourWrapper.java . . . . . . . . . . . . . . . . . . . . . . 57

A.6 HashMap.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

A.7 Behaviour.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58

A.8 estados.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

I Trechos da axiomatização Java memory heap

60

vii

Lista de Figuras
2.1 Esquema de geração de condições de vericação; adaptado de [18]. . . . . . 8
3.1 Tela do why3ide com obrigações de prova geradas pelo Krakatoa . . . . . . 24
viii

Lista de Tabelas
2.1 Provadores suportados por Why3 . . . . . . . . . . . . . . . . . . . . . . . 7 3.1 Objetivos de prova principais . . . . . . . . . . . . . . . . . . . . . . . . . 26 3.2 Objetivos de prova triviais . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 3.3 Objetivos de prova triviais (cont.) . . . . . . . . . . . . . . . . . . . . . . . 46 3.4 Objetivos de prova não provados . . . . . . . . . . . . . . . . . . . . . . . . 46
3.5 Objetivos de prova exclusivos da classe estados . . . . . . . . . . . . . . . 46
ix

Capítulo 1 Introdução

A necessidade de vericação da correção de um determinado algoritmo apresenta-se ao longo de toda a história do cálculo: após a criação de um procedimento computacional, o desenvolvedor ou os usuários interessam-se em saber se o produto atende aos requisitos originais.

Os métodos de vericação formal têm recentemente sido empregados pela indústria e

obtido sucesso em diferentes níveis de utilização: compiladores [31], sistemas operacionais

smart cards[25], controle de tráfego aéreo [9, 30],

[34]. Esta utilização crescente gera uma

demanda por prossionais aptos a aplicá-los [24].

Este trabalho apresenta ferramentas teóricas e computacionais que apoiem ações de vericação formal, em especial, de linguagens de uso comercial, tais como Java e C; além de um estudo de caso em linguagem Java. O trabalho está dividido em dois capítulos principais que apresentam respectivamente aspectos teóricos e a experiência com o estudo de caso.

No Capítulo 2, apresentam-se:

 a Lógica de Hoare (Seção 2.1), usada para especicar formalmente aplicações desen-
volvidas com linguagens de programação imperativa, em especial, linguagens que admitem efeitos colaterais encontrados, por exemplo, em operações de atribuição;
 a linguagem de especicação JML (Seção 2.2), a qual baseia-se na Lógica de Hoare,
e que foi usada para especicar as propriedades esperadas do estudo de caso Java;
 o sistema Krakatoa (Seção 2.3), que possibilitou converter especicações JML e
código Java em obrigações de prova;
 o ambiente interativo de provas Coq (Seção 2.4), que foi usado para vericar as
obrigações de prova geradas pelo Krakatoa.

No Capítulo 3, exibe-se o caso prático em que foi empregado esse ferramental: vericação de parte de um sistema multiagente codicado em linguagem Java, o qual atua no domínio de aplicações de Vida Ambiente-Assistida (VAA), intentando criar um ambiente doméstico que monitore a saúde pessoal dos assistidos. Criaram-se então anotações JML

1

diretamente no código-fonte Java dessa aplicação VAA, gerando as obrigações de prova através do sistema Krakatoa. As obrigações de prova geradas foram analisadas no Coq.
Este trabalho espera contribuir como um exemplo real do uso das ferramentas; além de discutir alguns pontos de atenção (Seção 3.4) quanto ao seu uso, através da experiência adquirida durante a vericação do sistema VAA. Esses pontos, por vezes, requereram uma adequação na estratégia de anotação ou de prova. Em particular, exibe-se:
 o assistente de prova Coq (Seção 2.4) sendo usado como plataforma de convergência
de objetivos de prova gerados;
 o uso de provadores automáticos para diminuir a intervenção manual em obrigações
de prova triviais;
 documentação formal em JML das partes das APIs (Application Programming In-
terfaces) usadas pelo sistema VAA. Pressupõe-se do leitor deste texto conhecimento das construções básicas da linguagem Java, uma vez que apenas algumas nuanças dessa linguagem são aqui realçadas. Pressupõe-se também experiência com algum provador interativo, pois o provador Coq é aqui brevemente apresentado.
2

Capítulo 2 Fundamentação Teórica

2.1 Lógica de Hoare

Uma linguagem de programação imperativa caracteriza-se por conter sequências de comandos que podem modicar o estado de execução do programa, ou seja, admite co-
mandos com efeitos colaterais 1[35], tal como uma atribuição, onde a operação {x := 1} xmodica o estado de memória na região que acomoda o valor da variável . Triplas de
Hoare permitem especicar programas com essa característica, possibilitando expressar pré-condições e pós-condições [24, p. 224], como será mostrado na seção seguinte (Seção 2.1.1).
Floyd [19] propôs uma técnica de modelagem de aplicações imperativas através de uxogramas (grafos dirigidos) e a geração de condições de vericação ao longo do uxograma. Inuenciado por esse trabalho, Hoare [22] apresentou um sistema dedutivo composto de axiomas e regras de inferência. Dijkstra75 [14] criou um cálculo para a Lógica de Hoare, posteriormente denominado de Cálculo da Pré-condição mais Fraca 2. Esses trabalhos referem-se a um subconjunto de instruções presente em todas as linguagens imperativas, conquanto não tratam de uma linguagem de programação especíca.
O sistema dedutivo proposto por Hoare é usado como fundamento de diversas linguagens de especicação para linguagens imperativas, tais como as linguagens JML e ACSL, descritas na Seção 2.2.

2.1.1 O sistema dedutivo de Hoare
O sistema dedutivo de Hoare é baseado na noção de triplas de Hoare usada para
φ Pestabelecer a conexão entre uma pré-condição , um algoritmo e uma pós-condição (descrição de resultado) ψ:

φ {P } ψ 1Tradução do termo original, em inglês: side-eects statements. 2Weakest Precondition Calculus

(2.1)

3

φEsta notação deve ser interpretada como se a asserção for verdadeira antes do início P ψdo programa , então a asserção será verdadeira quando esse programa terminar.
xA operação de atribuição de uma variável (por exemplo, := f ) é representada por
um axioma:
Axioma 1. ψ0 {x := f} ψ onde x é um identicador de variável; f é uma expressão, eventualmente contendo x; e ψ0 é obtido a partir de ψ substituindo-se todas as ocorrências de x por f.

Este axioma, formulado originalmente em [22], foi apresentado de forma mais geral em [8]:
Axioma 2. φ {x := f} ψ ≡ φ ⇒ ψ[x := f ]

onde, a substituição ψ[x := f ] denota uma expressão que é igual a ψ, exceto pelo fato de que todas as aparições de x em ψ são substituídas por f .

et seq.Villamizar [8, p. 66

] descreveu sua formulação do axioma da atribuição da

seguinte forma:

Em vez de explicar a atribuição pela forma em que se executa, pode-se entendê-
la em termos de substituição textual ou sintática. A ideia chave envolve raciocinar
para trás; das pós-condições para as pré-condições.
[. . . ] como, após a atribuição, x recebe o valor que tinha a expressão f antes da atribuição, este axioma expressa que, para que ψ aplique-se a x após a atribuição, esta asserção (ψ) deveria valer para f (ψ aplicada a f ) antes da atribuição. Portanto, a pré-condição φ deve implicar ψ[x := f ].
[. . . ] Aplicando o axioma da atribuição ao caso particular φ ≡ ψ[x := f ] obtemos ψ[x := f ] {x := f} ψ. Armamos que ψ[x := f ] é a pré-condição mais fraca 3 (weakest precondition) para que a execução de {x := f} termine com ψ verdadeiro.

Nota-se que a partir desse axioma mais geral, pode-se obter o axioma original:

ψ[x := f ] {x := f } ψ

(2.2)

Um programa imperativo consiste de uma sequência de comandos que são escritos um após o outro. Na linguagem imperativa denida por Hoare, comandos são encadeados
usando-se um ponto-e-vírgula: (P1; P2; . . . ; Pn). O conjunto de regras de inferência a seguir
permite expressar operações de linguagens imperativas, como por exemplo o encadeamento de programas (Regra de Inferência 1) ou consequências (Regra de Inferência 2 e Regra de Inferência 3):
Regra de Inferência 1. Se φ{P1}ψ1 e ψ1{P2}ψ então φ{(P1; P2)}ψ
Regra de Inferência 2. Se φ{P}ψ e ψ → χ então φ{P}χ
Regra de Inferência 3. Se φ{P}ψ e χ → φ então χ{P}ψ
3um predicado ψ diz-se mais fraco que outro φ, se φ ⇒ ψ vale.

4

Dentre outras construções de linguagens imperativas, é importante a capacidade de

Pexpressar iterações, ou seja, executar uma porção de programa ( ) repetidamente até

βuma determinada condição ( ) tornar-se falsa, sendo que, ao longo de toda a execução,

invarianteφo predicado (conhecido como

) é verdadeiro. Assim, pode-se caracterizar o

programa while β do P por:

Regra de Inferência 4. Se φ ∧ β{P }φ então φ{while β do P }¬β ∧ φ

2.2 A linguagem JML

As linguagens ACSL e JML são linguagens de especicação de propriedades inspiradas no formalismo de Hoare. Com essas linguagens, pode-se anotar aplicações escritas respectivamente em linguagem C e Java. Além de serem baseadas na mesma lógica, elas possuem um cerne de construções comum, uma vez que ACSL (ANSI/ISO C Specication Language) é uma adaptação (para a linguagem C) de JML (Java Modeling Language).

As especicações (ou anotações) são feitas usando pré-condições, pós-condições e in-

variantes. Essas anotações são feitas no próprio código-fonte, dentro de comentários, e

softwareportanto sua introdução nesses arquivos não afeta o comportamento do

gerado.

As anotações utilizam uma formatação especial: /*@ anotação */ ou //@ anotação.

Somente algumas poucas construções comuns são aqui apresentadas.

Consideremos o exemplo abaixo de uma função maximo() usando ponteiros (codicada
em linguagem C):

/*@ @ requires \valid(x) && \valid(y) && \valid(res); @ ensures *res >= *x && *res >= *y; @ ensures *res == *x || *res == *y; @ ensures \result == *res; @ ensures *x == \old(*x) && *y == \old(*y); @*/
int maximo(int *x, int *y, int *res) {
if (*x > *y) *res = *x;
else *res = *y;

return *res; }

A especicação da função está escrita imediatamente acima da declaração da fun-

ção. Neste exemplo, o contrato (especicação) contém pré-condições (cláusula requires)

quanto à validade dos ponteiros usados e pós-condições (cláusulas ensures) que garantam

*resa correção da informação em

e do retorno da função (ambas retornam o máximo),

5

*x *yalém de assegurar que e não venham a ser modicadas. Para tanto, usaram-se as
seguintes construções:
 \valid() gerará condição de vericação para a certicação de que o ponteiro pa-
rametrizado tenha sido previamente alocado (válido); o que equivale a testar se o
conteúdo é diferente de null, por exemplo, p é válido se p != null, caso contrário p será inválido;  \result denota o resultado de uma função (retorno de um procedimento);  old()\ indica o valor inicial de um parâmetro, ou seja, o valor originalmente recebido
pela função;
 >= ==os operadores aritméticos e têm o signicado usual; && || e correspondem respectivamente aos operadores lógicos conjunção e disjunção;  duas cláusulas ensures estão relacionadas através de uma conjunção, ou seja, todas
as asserções constantes nas cláusulas do exemplo devem ser válidas ao término da execução da função.
Essas linguagens de especicação são essencialmente baseadas em lógica de primeira ordem, assim como outras linguagens de especicação comportamental frequentemente usadas, tal como Z [39]. Não obstante, as linguagens de especicação aqui estudadas suportam também:
 recursividade: o fornecimento de medidas para vericação da terminação de funções
recursivas, inclusive no caso mais geral de recursividade mútua; para tanto deve-se
fornecer a expressão de decrescimento através da cláusula decreases;  predicados indutivos, construções como inductive P(x1, ... ,xn) { case c1
: p1; ... case ck : pk; }  tipos polimórcos (EXPERIMENTAL), por exemplo, pode-se considerar a declara-
ção //@ type list <A>;  construções de ordem superior (EXPERIMENTAL), através de termos como \lambda
T1 x1, ... , Tn xn ; t, que equivaleria ao λ-termo tipado λx1 : T1, ..., xn : Tn.t.
No estudo de caso apresentado (Capítulo 3), estas construções não foram empregadas, pois, com exceção dos tipos polimórcos, a modelagem da aplicação Java vericada não as requereu: as partes vericadas não possuem métodos recursivos, tratamento de casos ou, por exemplo, métodos que recebam métodos como argumento (ordem superior). Quanto à denição de tipos polimórcos, algumas restrições foram encontradas nesse recurso experimental impedindo a denição de novos tipos (Seção 3.4.5).
Referências para as linguagens de especicação ACSL e JML podem ser encontradas respectivamente em [3] e [27].
6

2.3 O software Krakatoa

O Krakatoa [26] é uma plataforma de análise estática de código-fonte escrito em linguagem Java, voltado para as ações de inferência lógica. Aceita especicações expressas em JML. O Frama-C [20] é sistema análogo voltado para a vericação de programas escritos em linguagem C e anotados com ACSL.

As ferramentas analisam o código e as especicações de comportamento fornecidas,

validam-nos quanto a erros sintáticos e os convertem para uma linguagem comum, que

software in-será entrada para o

intermediário Why [38]. Esta aplicação age como uma

terface para o Krakatoa (e o Frama-c) e os provadores, facilitando o acoplamento de

novos ambientes de prova (automáticos ou manuais), bem como de novos tradutores de

linguagens imperativas e linguagens de especicação. Atualmente são suportadas as refe-

ridas traduções de Java/JML e C/ACSL. A relação dos provadores suportados pode ser

encontrada na Tabela 2.1.

Interativos Automáticos

Coq PVS (em progresso)

Alt-Ergo CVC3
E-prover Gappa
Simplify SPASS Vampire
veriT Yices
Z3

Tabela 2.1: Provadores suportados por Why3

As condições de vericação serão então traduzidas para a linguagem especíca de um dado provador de escolha do usuário, e que seja suportada pela plataforma Why. Em seguida o provador é invocado pelo sistema.

Como será visto no caso trabalhado (Capítulo 3), mesmo que o foco de uma ação

de vericação seja o uso de um determinado provador interativo, o uso de provadores

automáticos mecaniza a prova de um grande volume de obrigações triviais, de forma que

o provador interativo pode ser utilizado somente para as obrigações não-triviais. Um

esquema geral do processo de tradução das especicações ACSL/JML para os ambientes

de prova (automáticos ou interativos), passando pelo Why, pode ser visto na Figura 2.1.

softwaresManuais de operação destes

podem ser encontradas em [33], [13] e [7].

softwaresTodos os

descritos nesta seção são de código aberto, licenciados sob a GNU

LGPL v2. Há versões disponíveis para Linux, Mac OS X e Windows, contudo não há

homologações para versões especícas desses sistemas operacionais.

7

Figura 2.1: Esquema de geração de condições de vericação; adaptado de [18].
2.4 O ambiente de provas Coq

O assistente de prova Coq [12] é um sistema que permite expressar especicações, desenvolver programas ou realizar provas matemáticas baseadas em uma lógica de or-
λdem superior (Cálculo de Construções Indutivas, formalismo derivado do Cálculo- com
tipos). Adicionalmente, este ambiente pode ser usado como estrutura lógica para que alguém forneça axiomas para novas lógicas e realizar provas nesses novos sistemas. Por exemplo, pode ser usado para implementar lógicas modais, temporais ou pode ser usado para raciocinar sobre programas imperativos [10].

softwaresAssim como os

da Seção 2.3, Coq é licenciado sob a GNU LGPL v2 e

encontra-se disponível para Linux, Mac OS X e Windows.

A seguir, são brevemente apresentados alguns dos recursos e características do Coq introduzidos por [5]. Para uma discusão ampla da ferramenta e do formalismo subjacente, pode-se consultar [6].

2.4.1 Expressões, fórmulas lógicas e novas constantes

A notação A : B é usada para indicar que a expressão A tem como tipo a expressão B.

Entre essas expressões, algumas podem ser interpretadas, por exemplo, como proposições
(têm tipo Prop), outras como números naturais (têm tipo nat) e outras como elementos de

estruturas de dados mais complexas. Fórmulas lógicas complexas podem ser construídas

combinando proposições com conectivos lógicos ou outras expressões. Pode-se também

funconstruir uma nova função com a palavra-chave

λ, a qual substitui o símbolo do

CheckλCálculo- . Para conferir se uma fórmula é bem-formada, usa-se o comando

, por

exemplo:

Check (fun x:nat => x = 3). fun x : nat => x = 3 : nat -> Prop
Check (forall x:nat, x < 3 \/ (exists y:nat, x = y + 3)).

8

forall x : nat, x < 3 \/ (exists y : nat, x = y + 3) : Prop

Check (let f := fun x => (x * 3, x) in f 3). let f := fun x : nat => (x * 3, x) in f 3 : nat * nat

letA intuição do comando

é a de substituição, por exemplo:

let

x

:=

y

in

té

t xequivalente ao termo , exceto pelo fato de que as ocorrências de serão substituídas pelo

termo y.

2.4.2 Proposições e provas

O sistema Coq baseia-se no isomorsmo de Curry-Howard [23]: tipos correspondem a
proposições, e provas a termos. Assim, a notação A : B denota que o termo A é do tipo B ou ainda que A é uma prova da fórmula lógica B.
Um teorema que prova uma implicação A ⇒ B pode ser interpretado como um termo
em que seu tipo expressa uma função (tipo funcional), a qual recebe um argumento do
A Btipo produzindo um retorno do tipo . Esse tipo funcional é expresso em Coq pela notação A -> B. Assim, uma função f desse tipo (denotada por f : A -> B) pode ser aplicada a um termo t do tipo A (denotado por t : A), o que permitiria deduzir B, pois o retorno da aplicação de f a t seria desse tipo, ou seja, f t : B. Essa dinâmica
corresponde à regra de inferência modus ponens.

A construção de provas dessa forma, ou seja, apresentando manualmente termos que

possuam determinado tipo, torna-se inviável para tipos (proposições) não-triviais. A abor-

dagem usualmente empregada envolve o uso de táticas: programas que, em determinados

casos, permitem a construção automática de trechos de provas. A seguir, usa-se a conhe-

cida propriedade sobre números naturais ∀n ∈ N, 2 ∗

n i=0

i

=

n

∗

(n

+

1)

para

ilustrar

uma prova em Coq usando táticas:

Fixpoint somar_ate_n (n:nat) : nat := match n with | 0 => 0 | S n' => S n' + somar_ate_n n' end.

(* Carregar aritmética básica de Peano *) Require Import Arith.

Theorem somar_ate_n_prop: forall n:nat, 2*(somar_ate_n n) = n*(S n).
Proof. intro n. induction n.

(* Base de indução *) simpl.

9

reflexivity.

Qed.

(* Passo indutivo *) simpl. ring_simplify. rewrite IHn. ring.

scriptApresenta-se a intuição das táticas apresentadas no

acima, conforme descrito

por Filliâtre et al. [17]:

 intro: introduz antecedentes de implicações e parâmetros de forall;

 induction: inicia uma prova por indução;

 simpl: simplica um termo usando computação, por exemplo, aplicada em um 1objetivo do tipo + 1 2produzirá um objetivo do tipo ;

 reflexivity: tsoluciona objetivos que tenha a forma = u, vericando se t é conuversível em , caso em que soluciona o objetivo com sucesso;

ring : soluciona equações contendo expressões polinomiais da estrutura algébrica
anel (ou semi-anel);

 ring_simplify: opera em objetivos simultaneamente como ring e simpl, ou seja,

ringatual como

normalizando (simplicando) os objetivos;

 rewrite termo: reescreve o objetivo de acordo com uma igualdade fornecida; então o parâmetro termo deve ter uma igualdade em seu tipo; exemplo, rewrite t, onde t : x = 5 x 5, substitui as ocorrências de no objetivo por .

Observe ainda que a prova do teorema exemplo somar_ate_n_prop (acima) pode ser
vista ainda em uma estrutura de árvore, representando os dois subobjetivos da prova por indução:
intro n
induction n

(* Base indutiva *) (* Passo indutivo *)

simpl reflexivity

simpl ring_simplify
rewrite IHn ring

10

Capítulo 3 Estudo de Caso

3.1 Vida Ambiente-Assistida

Vida Ambiente-Assistida (VAA) é um domínio de soluções de monitoramento que tenciona a criação de um ambiente doméstico inteligente. As soluções que compõem esse
domínio usualmente envolvem dispositivos de hardware e software, além de um conjunto
de serviços integrados que provejam assistência a pessoas. Por exemplo, em um ambiente em que viva uma pessoa idosa ou com alguma necessidade especial, sensores podem captar a ocorrência de atividades anormais, como uma queda, e enviar um alerta para uma central de atendimento a incidentes.

Inserido nesse contexto, o EMERGE [16] é um projeto que visa detectar situações de

emergência, propondo o uso de sensores embutidos na residência da pessoa assistida para

a captura de diversos dados do ambiente. Estes dados devem ser processados por um

softwaresistema de

que identique situações de emergência, tratando-as adequadamente.

O EMERGE propõe uma especicação da arquitetura e dos requisitos desse sistema,

envolvendo a combinação de sistemas multiagentes, porém não implementa de fato o

sistema.

O projeto apresentado em [36] implementa a parte do sistema responsável pelo enca-

minhamento das situações de emergência. Para a análise e desenho dos agentes, foi usada

a metodologia GAIA [36, p. 59] e, para sua implementação, a linguagem Java. Para

livenessesboçar determinadas propriedades de

1, isto é, propriedades que devem ser cum-

pridas caso algum evento especíco aconteça, empregou-se um método semiformal2 que

documentou o comportamento esperado (comportamento de intenção) do sistema. Além disso, para expressar o conteúdo das mensagens usou-se um padrão3 que dene mensagens

a partir da combinação de termos e predicados.

1Também denominadas de responsabilidades de sobrevivência. 2Pertencente à metodologia GAIA de desenvolvimento de sistemas multiagentes. 3FIPA ACL

11

3.1.1 Conexão com os fundamentos teóricos pesquisados

A linguagem Java, usada pelo sistema, compatibiliza-se com os fundamentos dispostos

pela Lógica de Hoare (Seção 2.1) e, dessa forma, usando a linguagem JML (Seção 2.2),

especica-se o comportamento esperado para o código Java a partir de tais predicados.

softwareCom o

Krakatoa (Seção 2.3), as obrigações de prova para as Triplas de Hoare (es-

pecicação de pré-condições e pós-condições em JML, juntamente com o código Java) são

descarregadas para o ambiente de provas Coq (Seção 2.4). Os lemas triviais são provados

SMT proverscom o auxílio de algum vericador automático (CVC3, Ergo,

), apenas para

efeito de mecanização de provas, uma vez que todos os lemas provados automaticamente

também podem ser provados de forma interativa (manual).

3.1.2 Agente de Emergência
etOs comportamentos selecionados para vericação foram extraídos de [36, p. 98 seq.]. A seleção ocorreu mediante entrevista com o autor, tendo este, por juízo próprio,
considerado essa seleção como a parte mais crítica do sistema. Cabe salientar que, de 109 arquivos .java, apenas três referem-se ao Agente de Emergência, que implementa o papel Assistente de Emergência.
As classes Java que compõem esse assistente são:

 RequestConfirmationBehaviour;  MonitorLongTermDeviationBehaviour;  MonitorAcuteEmergencyBehaviour.

workspaceEssas classes (arquivos) encontram-se na seguinte subpasta do

do projeto:

EmergencyAgentBundle/src/br/unb/cic/aal/behaviour
livenessEsses comportamentos foram implementados tomando como base expressões do agente. A responsabilidade de sobrevivência que o EmergencyAgent (agente de emer-
gência) deve atender está especicada conforme abaixo:
(I nvocarDetectarAlarme|I nvocarDetectarE mergencia)ω .P edirConf irmacao.[InvocarEnviarDadosDispatcher.EnviarN otif icacao] || (InvocarDetectarDesvios)ω.InvocarEnviarDadosSSM .EnviarN otif icacao

livenessAs regras de formação de expressões

(como a expressão acima) estão detalha-

das em [36, p. 62 et seq.].

Além disso, o autor do sistema separou porções dessa expressão para cada comporta-
livenessmento (classe/arquivo .java) do agente. Relacionam-se abaixo as subexpressões que cada comportamento/classe do agente EmergencyAgent deve atender:

12

 MonitorAcuteEmergencyBehaviour: (I nvocarDetectarAlarme|I nvocarDetectarE mergencia)ω
 RequestConfirmationBehaviour:
P edirConf irmacao.[InvocarEnviarDadosDispatcher.EnviarN otif icacao]
 MonitorLongTermDeviationBehaviour: (InvocarDetectarDesvios)ω.InvocarEnviarDadosSSM .EnviarN otif icacao
Destes três comportamentos, o comportamento MonitorAcuteEmergencyBehaviour
é o responsável pela detecção de emergências agudas, tendo sido o foco das ações de vericação.
Para fazer a vericação do comportamento MonitorAcuteEmergencyBehaviour isola-
damente, foram realizadas anotações JML referentes à semântica de intenção dos agentes (solicitações à camada JADE) e a consecução das respectivas obrigações de prova no ambiente Coq. Ao todo, 19 classes necessitaram de algum tipo de anotação para que
MonitorAcuteEmergencyBehaviour tivesse seu comportamento especicado, como será
mostrado na seção seguinte (Seção 3.2):
Agent.java Behaviour.java ConcurrentLinkedQueue_Emergency.java ConcurrentLinkedQueue.java CyclicBehaviour.java DataStore.java DetectEmergencyService.java Emergency.java estados.java HashMap.java MonitorAcuteEmergencyBehaviour.java Observable.java Observer.java Queue_Emergency.java Queue.java RequestConfirmationBehaviour.java SimpleBehaviour.java ThreadedBehaviourFactory.java ThreadedBehaviourWrapper.java
3.1.3 Componentes não vericados
fra-As classes de comportamento fazem uso de JADE (Java Agent DEvelopment), mework que fornece funcionalidades de middleware para agentes. Assim a aplicação em
estudo não tratou de detalhes físicos concernentes ao estabelecimento de canais de comunicação; tais funcionalidades foram delegadas pela aplicação à camada JADE.
13

Dessa forma, no que tange à vericação formal do sistema, cona-se na implementa-

frameworksção dos

usados pelo sistema, apenas especicando-se o seu comportamento

conforme sua documentação ocial. Para que se possa garantir o funcionamento correto

dessas ferramentas, estas devem ser objeto de ação de vericação especíca, o que não faz

parte do escopo do presente estudo.

3.2 Especicações JML
O processo de execução das anotações deu-se em duas etapas:
1. anotação da classe principal (MonitorAcuteEmergencyBehaviour) do comporta-
mento do agente;
2. anotação de classes periféricas à classe principal (apenas código usado por essa classe).
Para cada classe, sempre usou-se o mesmo método para criação das anotações: analisou-se o comportamento de intenção documentado [36, 4, 1] e criou-se especicações JML que dele representassem uma abstração lógica. O código-fonte das classes Java com suas respectivas anotações JML pode ser encontrado em
https://lambda.cic.unb.br/svn/mestrado/jp/vida-assistida/codigo-anotado.
3.2.1 Classe principal
A classe MonitorAcuteEmergencyBehaviour, pertencente ao EmergencyAgent, res-
ponsabiliza-se por monitorar eventos de emergência. No caso de ocorrência de um destes
eventos, deve requisitar a outro agente (ElderlyAgent) que realize a ação de conrmar ou não a emergência junto à pessoa assistida. Esta interação do EmergencyAgent com o ElderlyAgent é representada pela inclusão de RequestConfirmationBehaviour na lista de comportamentos que o agente EmergencyAgent pode ter (executar).
A classe MonitorAcuteEmergencyBehaviour foi codicada sendo derivada da classe CyclicBehaviour, classe da API JADE [4], e tendo implementado a interface Observer,
classe da API Java SDK [1]. Essa classe possui três métodos:
 onStart(): esse método é executado na inicialização do comportamento; é execu-
tado apenas uma vez, o que ocorre imediatamente antes da primeira chamada ao
método action() do comportamento;  action(): para classes derivadas de CyclicBehaviour (que é o caso da classe
MonitorAcuteEmergencyBehaviour), este método é executado continuamente, de
forma cíclica;
 update(): classes que implementam a interface Observer são noticadas da ocorrência de eventos externos por meio do método update(). Mais informações sobre
esse mecanismo de noticação podem ser obtidas na Seção 3.2.5.
14

Por m, é requisito do agente que as conrmações de emergência ocorram de forma assíncrona, ou seja, deve haver um enleiramento de noticações e conrmações de emergência, não bastando modelar de forma booleana essas informações (emergência sinalizada ou não), mas sim quanticadas (rastrear a quantidade de emergências sinalizadas).
Anotações
Para armazenar a informação da quantidade de emergências detectadas, foi criada
a classe estados, não usada pelo código, mas tão somente pelas anotações (vide Seção 3.2.7), contendo o atributo qtde_emergencias.
O recebimento das noticações das emergências, atividade delegada ao update(), é anotado em função do tipo (cláusula instanceof) de seu parâmetro arg e deve expressar a possibilidade de atualizar estados.qtde_emergencias:
/*@ @ assigns estados.qtde_emergencias; @ behavior enfileirar_emergencia: @ assumes arg instanceof Emergency; @ ensures estados.qtde_emergencias == \old(estados.qtde_emergencias) @ + 1; @ behavior nao_enfileirar_emergencia: @ assumes ! (arg instanceof Emergency); @ ensures estados.qtde_emergencias == \old(estados.qtde_emergencias); @*/
public void update(Observable o, Object arg) { ... }
Nesta anotação, nota-se a especicação de dois possíveis comportamentos (uxos) para
este método: enfileirar_emergencia e nao_enfileirar_emergencia. Esses compor-
tamentos do método ocorrem, respectivamente, de acordo com o tipo de seu parâmetro
arg ser Emergency ou não, o que é representado na cláusula assumes (pré-condição). A cláusula ensures especica o comportamento do enleiramento de mais uma emergência,
se for o caso.
Detectadas as emergências através do método update(), a inclusão de um novo objeto do tipo RequestConfirmationBehaviour na lista de comportamentos que o agente EmergencyAgent deve possuir é modelada pelo vetor lógico (somente existente nas anotações) lista_behaviours e seu controle de tamanho qt_behaviours (vide Seção 3.2.2). Essa responsabilidade é delegada ao método action():
/*@ @ requires threadFactory != null; @ assigns estados.qtde_emergencias; @ behavior emergencia:
15

@ assumes estados.qtde_emergencias >= 1; @ ensures @ estados.qtde_emergencias == \old(estados.qtde_emergencias) - 1 @ && myAgent.qt_behaviours == \old(myAgent.qt_behaviours) + 1 @ && myAgent.lista_behaviours[\old(myAgent.qt_behaviours)] @ instanceof ThreadedBehaviourWrapper @ && ((ThreadedBehaviourWrapper) @ myAgent.lista_behaviours[\old(myAgent.qt_behaviours)]) @ .myBehaviour instanceof RequestConfirmationBehaviour; @ behavior nenhuma_emergencia: @ assumes estados.qtde_emergencias == 0; @ ensures estados.qtde_emergencias == 0; @*/ public void action() { ... }
Nota-se que é pré-condição para a execução do método action() que o atributo threadFactory esteja inicializado (threadFactory != null), o que será assegurado pelo método onStart(). A possibilidade de atribuição de estados.qtde_emergencias é especicada na cláusula assigns do contrato. São especicados também dois uxos de execução para o método, emergencia e nenhuma_emergencia, respectivamente sob as pré-condições de haver alguma emergência enleirada (estados.qtde_emergencias >= 1) ou não (estados.qtde_emergencias == 0).
Finalmente o método onStart(), responsável pela inicialização do comportamento, deve fazer a alocação do objeto threadFactory:
/*@ @ ensures threadFactory != null; @*/
public void onStart() {
A anotação completa da classe MonitorAcuteEmergencyBehaviour pode ser encon-
trada no Apêndice A.1.

3.2.2 Classe Agent

et seq.A classe Agent, componente da API JADE [4, p. 10

], é uma classe base co-

mum a todo agente que venha a ser denido pelo usuário. No projeto vericado, as classes
EmergencyAgent e ElderlyAgent derivam de Agent e representam os dois principais agentes participantes do sistema. Esses agentes são instanciados e registrados em StartAgent,

componente dos pacotes de carga (inicialização) do sistema, fora de objetivo de vericação
(não foram alvo de vericação). MonitorAcuteEmergencyBehaviour é o comportamento vericado, que por sua vez é registrado para execução por EmergencyAgent em tais pa-

cotes de carga, sendo o fato de sua execução admitida.

16

Não obstante, MonitorAcuteEmergencyBehaviour precisa interagir com o agente que o hospeda (EmergencyAgent) para indicar a necessidade de execução de um novo com-
portamento, quando da detecção de uma nova emergência. Isso é possível através de
objeto que MonitorAcuteEmergencyBehaviour possui internamente (myAgent), e do uso do método addBehaviour() da classe Agent. O objeto myAgent é acessado através de
herança (vide Seção 3.2.6).

Anotações

Para representar a lista de comportamentos do agente, modelou-se um vetor, fazendo

model eldsuso do recurso JML

[28, p. 11]. Cabe salientar que essa construção existe

apenas nas anotações, não fazendo parte do código de fato:

//@ model integer qt_behaviours = 0; //@ model Behaviour [] lista_behaviours;

O vetor de comportamentos lista_behaviours, do tipo Behaviour [] (ou seja, comporta elementos do tipo Behaviour), é usado para hospedar (na camada lógica) a informação de cada novo comportamento lançado; a variável qt_behaviours, para contabilizar esse vetor. O método addBehaviour() é então especicado de forma a representar a
adição de um elemento a esse vetor:

/*@ @ requires b instanceof ThreadedBehaviourWrapper; @ ensures qt_behaviours == \old(qt_behaviours) + 1 && @ lista_behaviours[\old(qt_behaviours)] == b; @*/
public void addBehaviour(Behaviour b);

O sistema tem como requisito o lançamento de um novo comportamento com execução
paralela. De acordo com a documentação de JADE, esse efeito é obtido com o uso de
comportamentos encapsulados por um objeto do tipo ThreadedBehaviourWrapper (Seção 3.2.4) e, portanto, é um pré-requisito (cláusula requires) que o comportamento seja
desse tipo.

A classe sob estudo apenas lança comportamentos, mas não os remove do contexto,
portanto o método removeBehaviour() não foi anotado. Busca-se vericar que os novos
comportamentos tenham sido corretamente iniciados apenas.

AgentA anotação completa da classe

pode ser encontrada no Apêndice A.2.

3.2.3 Classes usadas para enleiramento de emergências
A classe ConcurrentLinkedQueue e a interface Queue, componentes da API Java
SDK [1], são usadas pelo sistema para enleiramento de emergências, por sua vez re-
presentadas pela classe Emergency. Os trechos de código em vericação apenas usam
17

informações (providas pelos métodos da API) referentes ao fato do enleiramento e, portanto, as emergências são apenas quanticadas (vide Seção 3.4.3).
Essas classes usam programação genérica (vide Seção 3.4.2) e, portanto, foram adap-
tadas para trabalhar exclusivamente com emergências (classe Emergency), resultando nas classes ConcurrentLinkedQueue_Emergency e Queue_Emergency.

Anotações

O código cliente faz uso dos métodos responsáveis por incluir e remover emergências
da la, respectivamente os métodos add() e poll() da interface Queue_Emergency.
O método add() meramente adiciona uma emergência ao contexto:

/*@ @ assigns estados.qtde_emergencias; @ ensures estados.qtde_emergencias == \old(estados.qtde_emergencias) + 1; @*/
boolean add(Emergency e);

add()O código cliente despreza o retorno de

, assim o retorno do método (que é do

tipo boolean) não foi especicado.

poll()O método

, porém, conforme documentação [1], além de retirar uma emergência

nulldo contexto, caso a la esteja vazia, retorna

(indicador de objeto não alocado); caso

contrário, algo diferente de null:

/*@ @ assigns estados.qtde_emergencias; @ behavior fila_com_conteudo: @ assumes estados.qtde_emergencias >= 1; @ ensures \result != null && @ estados.qtde_emergencias == \old(estados.qtde_emergencias) @ - 1; @ behavior fila_vazia: @ assumes estados.qtde_emergencias == 0; @ ensures \result == null && @ estados.qtde_emergencias == \old(estados.qtde_emergencias); @*/
Emergency poll();

Esses dois aspectos do método estão especicados nas anotações acima respectivamente
como fila_com_conteudo e fila_vazia.
A anotação completa da interface Queue_Emergency encontra-se no Apêndice A.3.

18

3.2.4 Classes usadas para geração de novo comportamento

ThreadedBehaviourFactory é a classe pertencente à API JADE [4, p. 29 et seq.]

threadusada para executar comportamentos JADE em uma

Java dedicada. Qualquer

tipo de comportamento JADE (Seção 3.2.6) pode ser executado em uma linha de execução
paralela (threaded ) através da classe ThreadedBehaviourFactory.

Para operacionalizar a nova linha de execução, o programador deve alocar um novo

objeto do tipo ThreadedBehaviourFactory e passar como parâmetro para seu método

wrap() o comportamento JADE que se deseja executar paralelamente. O método wrap()

então criará e retornará um novo objeto do tipo ThreadedBehaviourWrapper. Ao adicio-

Agentnar esse novo objeto à lista de comportamentos executados por um agente (classe

),

através de seu método addBehaviour(), o framework JADE perceberá o tipo especial do

comportamento (ThreadedBehaviourWrapper) e dedicará uma thread a ele.

Para troca de mensagens entre comportamentos, é usado o objeto myStore, acessado

através de herança (vide Seção 3.2.6). Este objeto é do tipo DataStore, classe derivada

de HashMap, componente da API Java SDK [1], que provê um par de métodos (put()

e get()) para salvar e recuperar as informações armazenadas no objeto myStore. As

hash hashinformações são acessadas através de um índice (

). Assim o

foi modelado como

um vetor, acessado a partir do índice mediante mapeamento entre o índice e uma posição

do vetor.

Anotações

Para usar o método wrap() de ThreadedBehaviourFactory, é necessário (pré-condição) que o objeto do tipo Behaviour que esteja sendo passado como parâmetro tenha sido alocado previamente (seja diferente de null):

/*@ @ requires b != null; @ ensures \result instanceof ThreadedBehaviourWrapper @ && \result != null @ && ((ThreadedBehaviourWrapper)\result).myBehaviour == b; @*/
public Behaviour wrap(Behaviour b);

wrap()Caso essa pré-condição seja satisfeita, o comportamento esperado do médoto

é

que ele aloque um novo comportamento em um objeto do tipo ThreadedBehaviourWrapper

e que seu atributo interno myBehaviour aponte para o comportamento fornecido através

bdo parâmetro .

Na API original JADE [4, p. 29], ThreadedBehaviourWrapper é uma classe interna à classe ThreadedBehaviourFactory, porém, foi criada uma classe exclusiva para acomodá-
la (vide Seção 3.4.4), que teve seu construtor anotado como uma mera atribuição ao
atributo interno myBehaviour:

//@ ensures myBehaviour == b;

19

private ThreadedBehaviourWrapper(Behaviour b);

Para os métodos put() e get() de HashMap, poder-se-ia conectar as anotações JML

et al.com alguma implementação lógica genérica, tal como fez Dross

[15] para o provador

container mapCoq (especicação de

do tipo

). Obstando-se a esta abordagem, uma limita-

ção encontrada no Krakatoa (vide Seção 3.4.5) obrigou o uso de uma especicação restrita

ao projeto (não genérica, conforme a referida seção), estabelecendo correspondência entre
hasho usado pelo agente e um índice xo:

//@ model Object [] vetor;

/*@ @ ensures key == RequestConfirmationBehaviour.EVENT_KEY @ ==> vetor[0] == value; @*/
public Object put(Object key, Object value);

/*@ @ ensures key == RequestConfirmationBehaviour.EVENT_KEY @ ==> \result == vetor[0]; @*/
public Object get(Object key);

hashA cada novo

necessário, nessa abordagem, deve-se estender as pós-condições,

incluindo nova tradução entre índice (parâmetro key) e posição de vetor.

A anotação completa da classe ThreadedBehaviourFactory, bem como das classes ThreadedBehaviourWrapper e HashMap pode ser encontrada nos Apêndices A.4, A.5 e
A.6.

3.2.5 Classes usadas para sinalizar emergências
A API Java SDK [1] possui duas classes para implementação de mecanismo de noti-
cação de eventos: Observable e Observer.
Observer é uma interface que deve ser implementada por classes que desejam
ser informadas sobre modicações em objetos observáveis (de tipo, ou seja, da classe
Observable). Além disso, classes que implementem essa interface devem também implementar o método update(), que será executado sempre que objetos observados sofrerem
alterações.
No sistema, emergências são objetos observáveis e têm seu mecanismo de observa-
ção codicado dentro da classe DetectEmergencyServiceImpl, derivada de Observable. DetectEmergencyServiceImpl tem seus procedimentos de instanciação e registro realizados pela classe StartService. Ambas as classes, componentes dos pacotes de carga do sistema, estão fora do objetivo de vericação. MonitorAcuteEmergencyBehaviour é registrado como um observador de emergências por DetectEmergencyServiceImpl. Esse

20

processo de catalogação de componentes é então admitido, o que implica que as classes do sistema responsáveis por essas inicialização não foram vericadas, não sendo possível armar que tal carga do sistema foi feita corretamente.
MonitorAcuteEmergencyBehaviour, comportamento vericado, por sua vez implementa a interface Observer, o que requer anotações referentes ao método update() de Observer.
Anotações
Uma vez que o mecanismo de armazenamento da informação da quantidade de emer-
gências detectadas envolveu a criação de uma classe dedicada (estados), não usada pelo
código, mas tão somente pelas anotações (vide Seção 3.4.3), as anotações referentes ao
método update() concentraram-se na própria classe MonitorAcuteEmergencyBehaviour (Seção 3.2.1). A interface Observer e a classe Observable não tiveram anotações adici-
onais signicantes.
3.2.6 Classes herdadas pelos comportamentos
Os comportamentos de usuário, tal como MonitorAcuteEmergencyBehaviour, são
construídos através da derivação de alguma das classes de comportamento disponíveis na API JADE. Esses comportamentos básicos, por sua vez, derivam da classe abstrata
Behaviour [4, p. 23]. O sistema possui comportamentos derivados das classes JADE CyclicBehaviour e
Behaviour. A propriedade de herança da orientação a objetos, a qual Java está subordinado, garante que métodos e atributos declarados dentro da classe básica Behaviour e que estejam com sua cláusula de visibilidade marcadas como public ou protected estejam
acessíveis às classes derivadas, ou seja, aos comportamentos de usuário.
Dos atributos derivados de Behaviour, o sistema manipula direta ou indiretamente (via métodos) os objetos internos myAgent e myStore. Este último é declarado com visibilidade private e, portanto, para ser acessado pelos comportamentos de usuário, necessita de métodos getter and setter : getDataStore() e setDataStore(). Por ser atributo protegido, myAgent pode ser acessado diretamente pelas classes derivadas de Behaviour.
ThreadedBehaviourWrapper também é derivada de Behaviour, e é usada no processo
de geração de novos comportamentos paralelos (Seção 3.2.4).
Anotações
Um dos construtores de Behaviour armazena a informação do agente instanciador do
comportamento:
/*@ @ requires a != null;
21

@ ensures myAgent == a; @*/ public Behaviour(Agent a);
aÉ pré-condição que a informação do agente seja válida ( != null). O método getDataStore(), deve então retornar o atributo myStore, atributo do tipo DataStore, alocado para troca de informações durante a geração de novo comportamento
(Seção 3.2.4):
//@ ensures \result == myStore && myStore != null; public DataStore getDataStore();
Caso o atributo myStore não contenha nenhum objeto, seu conteúdo será null, o
que indicará que ainda não foi alocado e salvo um objeto nesse atributo. Se for esse o
caso, getDataStore() deve alocar e salvar um objeto do tipo DataStore nesse atribuito. O fato de que o objeto retornado por getDataStore() sempre será válido está expresso na pós-condição myStore != null, no lado direito da conjunção da cláusula ensures, e
deve-se a essa propriedade do método de alocar um novo objeto quando, antes da execução
do método, myStore não for válido. setDataStore() não possui essa responsabilidade de alocação, bastando apenas a
atribuição do objeto parametrizado a myStore.
/*@ @ requires ds != null; @ ensures myStore == ds; @*/
public void setDataStore(DataStore ds);
ds dsSua única pré-condição é que o parâmetro recebido ( ) seja válido ( != null). A anotação completa da classe base Behaviour encontra-se no Apêndice A.7.

3.2.7 Classe estados

O mecanismo de armazenamento da informação da quantidade de emergências neces-
sitou (vide Seção 3.4.3) da criação de uma classe dedicada exclusivamente à acomodação
de um contador de emergências (atributo qtde_emergencias).

Essa classe (estados) não é usada pelo código-fonte do projeto em vericação, porém

é usada pelas anotações para representar o acúmulo ou consumo de emergências. Esta

alternativa não impactou a formalização realizada, pois a classe foi usada em substituição

model eldsao recurso

(Seções 3.2.2 e 3.4.3) meramente para acomodar variáveis e suas

consequentes mudanças de estados.

defaultAlém do atributo, a classe possui um construtor

para garantir a correta inici-

alização do atributo com valor zero.

22

Anotações
O construtor precisa de uma anotação para expressar o fato da inicialização:
/*@ @ assigns qtde_emergencias; @ ensures qtde_emergencias == 0; @*/
estados() {
Além do construtor, a classe possui uma invariante que expressa que o atributo, apesar de inteiro, nunca será negativo.
//@ invariant qtde_positiva: qtde_emergencias >= 0;
Essa invariante é inclusa pelo ambiente de geração de obrigações de prova (Krakatoa) automaticamente como pós-condição partícipe de cada teorema que envolva manipulação desse atributo (Seção 3.3).
A versão completa da classe estados foi inserida no Apêndice A.8.
3.2.8 Outras classes
As classes RequestConfirmationBehaviour e DetectEmergencyService são manipuladas apenas basicamente pela classe principal MonitorAcuteEmergencyBehaviour. Ne-
nhum de seus métodos é acessado de forma que interra no funcionamento da aplicação 4. Seus atributos são apenas lidos.
Anotações
Assim nenhuma anotação signicativa foi feita para essas classes.

3.3 Obrigações de provas

softwareCom o código-fonte Java anotado (Seção 3.2), executou-se o

Krakatoa (Se-

ção 2.3) para a classe principal:

krakatoa MonitorAcuteEmergencyBehaviour.java

Com a execução acima, o Krakatoa descarregou então 71 obrigações de prova a serem
provadas. O software invoca automaticamente a interface gráca (why3ide) do aplicativo
Why (Seção 2.3), a qual centraliza as obrigações de prova geradas (Figura 3.1).
4DetectEmergencyService tem o método register() invocado por onStart(), ou seja, durante o
processo de inicialização, admitido, conforme explanado nas Seções 3.2.2 e 3.2.5.
23

Figura 3.1: Tela do why3ide com obrigações de prova geradas pelo Krakatoa

Na barra lateral esquerda, aparecem, dentre outros itens, os provadores instalados (interativos e automáticos) e transformações possíveis para objetivos. À medida que se clica em itens do painel central (obrigações de prova), os dois painéis mais à direita são atualizados: o inferior (direito), com o código-fonte anotado e um realce (amarelo) no trecho da anotação referente ao objetivo de prova; o superior (direito), com o teorema a ser provado, codicado em linguagem Why.

Seleciona-se então um provador no painel esquerdo e o Why transformará o teorema

para a linguagem de entrada especíca do provador, por exemplo, para a linguagem

do provador interativo Coq (Seção 2.4). Além disso, nessa operação, o Why invoca o

provador escolhido fornecendo como entrada o arquivo traduzido, abrindo o ambiente de

prova interativo, se for o caso. Caso seja selecionado um provador automático, a tradução

front-ende disparo serão transparentes, ou seja, não será exibido

do provador, por padrão.

Nesta seção, algumas obrigações de prova serão analisadas, sempre na linguagem do provador interativo Coq (Seção 2.4). Será usado o acrônimo OP, em vez da expressão obrigação de prova.

Os arquivos Coq contendo as respectivas OPs são precedidos de preâmbulo contendo

axiomatização referente ao modelo de memória de programas Java, modelagem descrita

et seq. scriptspor Marché [32, p. 12

]. Essa axiomatização será suprimida dos

apresentados

nesta seção, contudo pode ser encontrada no Anexo I.

24

3.3.1 Objetivos de prova principais
Das 71 OPs geradas, 19 apresentaram teoremas não triviais. A Tabela 3.1 exibe um sumário do estado de prova de 16 desses objetivos, onde:
 a primeira coluna corresponde ao número da prova, para referência neste texto;  a segunda coluna contém o nome da OP, gerada pelo Why;  as colunas subsequentes referem-se ao estado da prova em cada provador, podendo
apresentar uma das seguintes informações:
 tempo de vericação de uma prova, caso a coluna possua informação numérica;  falha na tentativa de prova, caso a coluna possua coloração rosa;  objetivo não tentado, caso a coluna possua coloração roxa.
Nota-se que o provador automático CVC3 provou praticamente todos os objetivos, com exceção do objetivo #11, que não foi provado por nenhum provador automático testado. Para esse objetivo de prova, foi necessária a construção de uma prova interativa, com o auxílio do Coq.
Comentam-se a seguir algumas dessas 16 OPs.

OPs #02 a #09

Estes objetivos referem-se às anotações do método action() da classe principal (Se-

behaviorção 3.2.1). Naquela anotação, haviam sido especicadas duas seções

em JML:

emergencia e nenhuma_emergencia. Como pode-se ver na Tabela 3.1, essas OPs referem-

se às anotações da seção emergencia.

Em verdade, as ferramentas produziram apenas um OP: Method action, Behavior

`emergencia'. Não obstante, a interface gráca do Why permite a aplicação da trans-

Splitformação

, que basicamente busca conjunções na implicação nal do teorema a

ser provado, divindo o teorema em tantos outros teoremas quantas forem as conjunções

integrantes.

Pela Tabela 3.1 e Figura 3.1, percebe-se então que aplicou-se uma vez a transfor-
mação à OP original, produzindo dois novos teoremas (nomeados ambos de normal postcondition) e, em cada um desses novos teoremas, aplicou-se novamente a trans-
formação o que produziu dois conjuntos de quatro novos teoremas, dessa vez, numerados pela ferramenta.
Method action, Behavior `emergencia', a OP produzida originalmente pela fer-
ramenta, não pôde ser provada diretamente por nenhum provador automático. Após as transformações, o provador CVC3 provou os oito teoremas.
tacticalPara a prova no Coq, a transformação tem pouco efeito, pois um simples uso do  repeat split; intros gera os oito subgoals correspondentes às OPs transformadas.
O único efeito prático foi a geração de oito arquivos Coq separados, cada um para sua respectiva OP.

25

CVC3 Coq Eprover Spass

# Proof obligations

01 Method action, default behavior

0.22 1.51

Method action, Behavior `emergencia'

normal postcondition

02 1

0.18 1.44

03 2

0.17 1.69

04 3

0.17 1.74

05 4

0.18 1.73

normal postcondition

06 1

0.14 1.76

07 2

5.11 1.83

08 3

5.34 1.98

09 4

5.23 1.70

10 Method action, Behavior `nenhuma_emergencia' 0.15 2.08

11 normal postcondition

1.63

12 Method onStart, Safety

0.11

13 Method update, default behavior

0.11

14 Method update, Behavior `enleirar_emergencia' 0.12 1.49

15 normal postcondition

0.11 1.51

16 downcast

0.09 1.54

Tabela 3.1: Objetivos de prova principais

OP #06

introsA OP #06, após a aplicação da tática

(introdução das implicações e quanti-

cadores universais), apresenta o seguinte formato:

Theorem WP_parameter_..._action_ensures_emergencia :
... ... (SUPRIMIDO) ... 1 subgoal this_8 : pointer usObject estados_qtde_emergencias1 : int32 usMonitorAcuteEmergencyBehaviour_threadFactory1 : memory usObject
(pointer usObject) usObject_alloc_table1 : alloc_table usObject H : 1 <= integer_of_int32 estados_qtde_emergencias1 /\
valid_struct_Object this_8 0 0 usObject_alloc_table1 /\ usNon_null_Object
(select usMonitorAcuteEmergencyBehaviour_threadFactory1 this_8)

26

usObject_alloc_table1 estados_qtde_emergencias2 : int32 result : pointer usObject H0 : (integer_of_int32 estados_qtde_emergencias1 = 0 ->
result = (null:pointer usObject) /\ integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1) /\ (1 <= integer_of_int32 estados_qtde_emergencias1 -> usNon_null_Object result usObject_alloc_table1 /\ integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1 - 1) result1 : bool H1 : result1 = true /\ offset_max usObject_alloc_table1 result = 0 \/ result1 <> true /\ result = (null:pointer usObject) H2 : result1 <> true ______________________________________(1/1) integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1 - 1
Essa OP origina-se de uma das proposições integrantes da cláusula ensures (póscondição) do referido método action():
estados.qtde_emergencias == \old(estados.qtde_emergencias) - 1

Nota-se que os diversos estados das variáveis são traduzidos para o Coq como diferentes variáveis, numeradas de acordo com o uxo do código imperativo. Em especial:
 \old(estados.qtde_emergencias) (conteúdo da variável imediatamente antes da chamada ao método) foi traduzido como estados_qtde_emergencias1;
 estados.qtde_emergencias (conteúdo da variável imediatamente após o encerramento do método), como estados_qtde_emergencias2.

Além disso, o contexto (premissas) de prova foi produzido tendo como base um cálculo da pré-condição mais fraca (Seção 2.1) implementado pela ferramentas. Para tanto, a ferramenta considerou:
 o código-fonte Java do método (Apêndice A.1);  as anotações JML feitas para cada uma das dependências funcionais desse código
imperativo (em especial, Queue_Emergency.poll());  além das pré-condições JML especicadas para o próprio método action().

Após examinar o contexto, nota-se que manipulações simples envolvendo as conjunções

scriptcontidas nas hipóteses H0 e H conduzem à prova do teorema. O

Coq de construção

da prova reete essas observações:

27

Proof. intros. elim H0; clear H0; intros. elim H3; clear H3; intros. assumption.
elim H; clear H; intros. assumption. Qed.
OP #07
A OP #07, após a aplicação da tática intros:
Theorem WP_parameter__MonitorAcuteEmergencyBehaviour_action_ensures_emergencia :
... ... (SUPRIMIDO) ... 1 subgoal this_8 : pointer usObject estados_qtde_emergencias1 : int32 usMonitorAcuteEmergencyBehaviour_threadFactory1 : memory usObject
(pointer usObject) usBehaviour_myAgent1 : memory usObject (pointer usObject) usAgent_qt_behaviours1 : memory usObject Z usObject_alloc_table1 : alloc_table usObject H : 1 <= integer_of_int32 estados_qtde_emergencias1 /\
valid_struct_Object this_8 0 0 usObject_alloc_table1 /\ usNon_null_Object
(select usMonitorAcuteEmergencyBehaviour_threadFactory1 this_8) usObject_alloc_table1 estados_qtde_emergencias2 : int32 result : pointer usObject H0 : (integer_of_int32 estados_qtde_emergencias1 = 0 -> result = (null:pointer usObject) /\ integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1) /\ (1 <= integer_of_int32 estados_qtde_emergencias1 -> usNon_null_Object result usObject_alloc_table1 /\ integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1 - 1) result1 : bool H1 : result1 = true /\ offset_max usObject_alloc_table1 result = 0 \/ result1 <> true /\ result = (null:pointer usObject) H2 : result1 <> true
28

______________________________________(1/1) select usAgent_qt_behaviours1 (select usBehaviour_myAgent1 this_8) = select usAgent_qt_behaviours1 (select usBehaviour_myAgent1 this_8) + 1
A OP advém de outra parte da pós-condição do método action():
myAgent.qt_behaviours == \old(myAgent.qt_behaviours) + 1

Dessa vez, a variável deve ser acessada através de um atributo interno (myAgent) à

classe Behaviour. Esse atributo é alocado dinamicamente, portanto o acesso às variáveis

selectenvolvidas não é mais direto, mas sim representado pelo uso da função

, pertencente

à axiomatização citada (Anexo I).

Porém, nota-se que H0 é proveniente da extração das anotações do método poll() 5

if(Apêndice A.3). Além disso, H1 representa as possibilidades do comando

constante

do corpo de action():

public void action() { Emergency emergency = emergencies.poll(); if (emergency != null) {
... ...
} }

Note que result1 (em H1) é booleano que equivale exatamente à expressão emergency != null. Por H2, percebe-se que essa OP corresponde à extração de comportamento em que o if falha: result1 <> true, ou result1 = false, ou emergency = null.
Além disso, em H0, result representa exatamente o retorno do método poll() que, no código acima, é armazenado em emergency.
Por outro lado, percebe-se pelas anotações de action() que a seção behavior emergencia tem como pré-condição (cláusula assumes) que estados.qtde_emergencias >= 1, o resultado de poll() deveria conduzir a emergency != null.
De fato, em H0, a asserção usNon_null_Object result usObject_alloc_table1
ratica a contradição no contexto, ou seja, um uxo imperativo que não ocorre nessas
condições de estado das variáveis envolvidas.

Voltando a atenção novamente para o objetivo, constata-se que seria impossível cons-

truir uma prova direta, pois implicaria no seguinte teorema ser provado (note o formato

do objetivo do teorema):

forall x:Z, x = x + 1

scriptO Coq de construção da prova trabalha em busca de recompor no ambiente do
provador essas contradições, fechando a OP:
5poll() é método usado no corpo do método action()

29

Proof. intros. elim H1; clear H1; intros. elim H1; clear H1; intros. contradiction.
elim H1; clear H1; intros. elim H0; clear H0; intros. elim H4; clear H4; intros.
unfold usNon_null_Object in H4. rewrite H3 in H4. generalize null_pointer; intros. elim (H6 usObject usObject_alloc_table1); clear H6; intros. generalize
(Zle_trans 0 (offset_max usObject_alloc_table1 null) (- (2)) H4 H7); intros. info auto with zarith.
elim H; clear H; intros. assumption. Qed.

OP #10

À OP #10, assim como a todas as outras OPs, não é aplicada nenhuma transformação

SplitWhy (tal como a transformação

mencionada anteriormente). Essa OP é denomi-

nada pela ferramenta Method action, Behavior `nenhuma_emergencia', pois refere-se

às anotações do método action(), behavior (seção da anotação JML) nenhuma_emergencia.

Após a aplicação da tática intros e repeat split; intros, o teorema apresenta dois
subobjetivos, dos quais reproduz-se apenas parte do contexto do primeiro subobjetivo:

Theorem WP_parameter__..._action_ensures_nenhuma_emergencia :
... ... (SUPRIMIDO) ... 2 subgoals ... ... (SUPRIMIDO) ... H : integer_of_int32 estados_qtde_emergencias1 = 0 /\
valid_struct_Object this_8 0 0 usObject_alloc_table1 /\ usNon_null_Object
(select usMonitorAcuteEmergencyBehaviour_threadFactory1 this_8) usObject_alloc_table1

30

estados_qtde_emergencias2 : int32 result : pointer usObject H0 : (integer_of_int32 estados_qtde_emergencias1 = 0 ->
result = (null:pointer usObject) /\ integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1) /\ (1 <= integer_of_int32 estados_qtde_emergencias1 -> usNon_null_Object result usObject_alloc_table1 /\ integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1 - 1) result1 : bool H1 : result1 = true /\ offset_max usObject_alloc_table1 result = 0 \/ result1 <> true /\ result = (null:pointer usObject) H2 : result1 = true ... ... (SUPRIMIDO) ... H5 : usRequestConfirmationBehaviour_EVENT_KEY = usRequestConfirmationBehaviour_EVENT_KEY -> select usObjectM_ObjectP1 (shift (select usHashMap_vetor1 result3) 0) = result ... ... (SUPRIMIDO) ... ______________________________________(1/2) integer_of_int32 estados_qtde_emergencias2 = 0

______________________________________(2/2) integer_of_int32 estados_qtde_emergencias2 = 0

A OP provém do único predicado constante da pós-condição dessa seção de anotação

do método:

estados.qtde_emergencias == 0

ifOs dois subobjetivos referem-se aos uxos possíveis do comando constante do corpo de action(): o primeiro subobjetivo, por H2 (result1 = true), indica o caso then; e o segundo subobjetivo possui hipótese que indica (result1 <> true) o caso else.

Nos dois casos, não há a necessidade de recorrer a axiomas ou lemas do prelúdio

script(teoria carregada dentro do

pelas ferramentas). O aproveitamento de simples fatos

(hipóteses) do contexto, como H e H0, permite a prova dos subobjetivos, o que pode ser
visto no script de construção da prova:

Proof. intros. repeat split; intros.

31

elim H; clear H; intros. elim H0; clear H0; intros. elim H0; clear H0; intros.
rewrite H10. assumption.
assumption.
elim H; clear H; intros. elim H0; clear H0; intros. elim H0; clear H0; intros.
rewrite H5. assumption.
assumption. Qed.
OP #11
A OP #11 não pôde ser fechada por nenhum provador automático, tendo sido mandatória a construção de uma prova interativa, no caso, com o Coq.
Esta OP foi denominada pela ferramenta normal postcondition, nome padrão, uma vez que refere-se ao método onStart(), o qual não foi especicado com as cláusulas behavior, dessa forma, não possuindo uma seção nomeada na anotação.
Após a aplicação da tática intuition, o teorema apresenta um único objetivo:
Theorem WP_parameter__MonitorAcuteEmergencyBehaviour_onStart_ensures_default :
... ... (SUPRIMIDO) ... 1 subgoal this_16 : pointer usObject usMonitorAcuteEmergencyBehaviour_threadFactory1 : memory usObject
(pointer usObject) usObject_alloc_table1 : alloc_table usObject H : valid_struct_Object this_16 0 0 usObject_alloc_table1 usObject_tag_table1 : tag_table usObject usObject_alloc_table2 : alloc_table usObject result : pointer usObject H1 : strict_valid_struct_Object result 0 (1 - 1) usObject_alloc_table2 H0 : alloc_extends usObject_alloc_table1 usObject_alloc_table2 H2 : alloc_fresh usObject_alloc_table1 result 1 H4 : instanceof usObject_tag_table1 result usThreadedBehaviourFactory_tag usMonitorAcuteEmergencyBehaviour_threadFactory2 : memory usObject
32

(pointer usObject) H3 : usMonitorAcuteEmergencyBehaviour_threadFactory2 =
store usMonitorAcuteEmergencyBehaviour_threadFactory1 this_16 result ______________________________________(1/1) usNon_null_Object
(select usMonitorAcuteEmergencyBehaviour_threadFactory2 this_16) usObject_alloc_table2
Esse objetivo concerne à única pós-condição do método onStart():
ensures threadFactory != null

Para a consecução da prova, é importante notar um dos fatos inclusos pela axiomatização a cerca de armazenamento e recuperação de informação dinâmica (ponteiros):

Axiom select_store_eq : forall (t:Type) (v:Type), forall (m:(memory t v)), forall (p1:(pointer t)), forall (p2:(pointer t)), forall (a:v), (p1 = p2) -> ((select (store m p1 a) p2) = a).

p1 p2Esse axioma deve assim ser interpretado: se dois ponteiros e são iguais, então,

caso seja armazenado (store) algum valor a dentro da região de memória m na posição p1

selecte, posteriormente, caso seja recuperado (

) o valor armazenado nesta mesma região

m p2 p1de memória na posição (igual a , por hipótese), o valor recuperado será o próprio

avalor , armazenado inicialmente.

Além disso, observa-se que H3 representa modicação do estado de threadFactory
(variável presente no código-fonte imperativo). Percebendo-se que esse armazenamento
ocorre na mesma posição (this_16) em que o objetivo recupera a informação, pode-se
rescrever H3 no objetivo e aplicar o teorema, simplicando-o para:

usNon_null_Object result usObject_alloc_table2

Para a prova deste objetivo, tem-se que expandir (unfold em Coq) as denições de strict_valid_struct_Object (veja hipótese H1) e usNon_null_Object (objetivo),
também constantes da axiomatização.
Por m, a aplicação do axioma select_store_eq gerou um segundo subobjetivo, o
qual exige que se mostre que as posições envolvidas (ponteiros) são iguais, ou seja, que
this_16 = this_16, resolvido de maneira trivial.
scriptO de construção da prova reete essas observações:
Proof. intuition. subst usMonitorAcuteEmergencyBehaviour_threadFactory2. simpl in H1. rewrite select_store_eq. unfold strict_valid_struct_Object in H1.

33

unfold usNon_null_Object. elim H1; clear H1; intros. rewrite H3. auto with zarith.
trivial. Qed.

OP #16

As ferramentas envolvidas também geram OPs referentes à segurança dos métodos.

downcastUma delas (OP #16) refere-se à segurança da operação Java denominada

.

downcastA operação de

é descrita formalmente por Pierce [37, p. 215] como um

ascription, ou seja, uma conversão entre tipos relacionados dentro de uma hierarquia de

subtipos 6. Pierce atenta ainda para o fato de que os downcasts, em oposição aos upcasts,

representam a conversão de um tipo para um subtipo seu, o que não necessariamente

sucede e, por isso, em seu formalismo (assim como em Java), não são vericados estaticamente, necessitando uma vericação de tipos em tempo de execução 7.

A OP #16, de fato nomeada downcast pela ferramenta, após aplicação da tática intros, apresenta-se como abaixo:

Theorem WP_parameter__MonitorAcuteEmergencyBehaviour_update_safety :
... ... (SUPRIMIDO) ... 1 subgoal this_4 : pointer usObject o_0 : pointer usObject arg_0 : pointer usObject usObject_tag_table1 : tag_table usObject usObject_alloc_table1 : alloc_table usObject H : left_valid_struct_Object arg_0 0 usObject_alloc_table1 /\
left_valid_struct_Object o_0 0 usObject_alloc_table1 /\ valid_struct_Object this_4 0 0 usObject_alloc_table1 result : bool H0 :result = true /\ instanceof usObject_tag_table1 arg_0 usEmergency_tag \/ result <> true /\ ~instanceof usObject_tag_table1 arg_0 usEmergency_tag

herança6Em Java, esta hieraquia refere-se ao relacionamento de

(derivação) entre as classes, onde

pelo menos duas classes são partícipes: superclasse e subclasse, respectivamente, tipo e subtipo.

Java Virtual Machine7Em Java, essa vericação em tempo de execução é feita pela JVM (

). Analoga-

downcasts evaluationmente, no formalismo de Pierce, os

são tratados por regras de

(análise dinâmica),

não sendo, dessa forma, tratados pelas regras de tipagem (análise estática).

34

H1 : result = true ______________________________________(1/1) instanceof usObject_tag_table1 arg_0 usEmergency_tag

Esse objetivo, como outros objetivos gerados automaticamente pela ferramenta e rotu-

safetylados com suxo

, não se refere a uma anotação, mas sim à vericação da segurança

do downcast (ascribe) feito dentro do método update():

public void update(Observable o, Object arg) { if (arg instanceof Emergency) { emergencies.add((Emergency) arg); }
}

No caso, a conversão sendo vericada é (Emergency) arg, ou seja, a conversão do argumento arg do tipo Object (superclasse) para o tipo Emergency (subclasse).

A prova desse objetivo decorre do fato de a conversão estar corretamente protegida

if argdentro do comando que, justamente, testa, antes de executar a conversão, se

é de

fato um objeto (instância) da classe Emergency.

Além disso, a prova trabalha no sentido de aproveitar a informação extraída do co-

if ifmando

(hipótese H0) e da premissa de que o teste ocorre quando o

sucede (caso

then, reexo na hipótese H1).

scriptAssim, o

de construção da prova elimina a disjunção de H0 gerando os dois ca-

sos do if: no caso then, o fato virá do contexto; no caso else, haverá uma contradição

no contexto.

Proof. intros. elim H0; clear H0; intros. elim H0; clear H0; intros. assumption.
elim H0; clear H0; intros. contradiction. Qed.

3.3.2 Objetivos triviais
Ainda, do total de 71 obrigações de prova, 52 eram objetivos triviais, tais como simples tautologias. Para esses objetivos, empregou-se exclusivamente provadores automáticos; no caso, o CVC3.

35

Esses objetivos encontram-se sumarizados nas Tabelas 3.2 e 3.3. Nestas e nas próximas

tabelas, onde se lê CC, entenda-se como Constructor of class, ou seja, objetivos de

defaultprova gerados para construtores

das classes envolvidas.

3.3.3 Objetivos não provados

Três OPs, relacionadas na Tabela 3.4, não foram provadas.

As OPs #01 e #02 foram geradas indevidamente pelas ferramentas devido ao problema descrito na Seção 3.4.7.

A terceira OP refere-se à segurança do método action(). Como explanado na Se-

ção 3.2.1, onStart() e action() são métodos abstratos denidos na classe Behavi-

our, da qual todos os comportamentos de usuário derivam, inclusive a classe principal

(MonitorAcuteEmergencyBehaviour). Pelo fato de serem abstratos, a implementação

Behaviourdesses métodos ca a cargo das classes que derivam de

.

Além disso, o framework

Jade responsabiliza-se por disparar em tempo de execução o método onStart() antes

que qualquer chamada ao método action() ocorra.

A OP #03 carece justamente de que seja expressado esse fato que ocorre em tempo

de execução, de forma que a informação esteja disponível em tempo de prova: todo novo

Behaviourobjeto derivado de

instanciado terá seu método de alocação invocado antes de

seu método de ação.

JML permite que os contratos contenham anotações referentes a execução de métodos [28, p. 6] [11, p. 5], porém o Krakatoa usa uma versão modicada de JML 8 que não
permite expressar chamadas a construtores ou métodos [33, p. 23] [32, p. 11].

Uma alternativa para contornar a ausência do construto que expresse encadeamento entre métodos ainda não havia sido encontrada pelo autor deste estudo no momento da confecção desta dissertação.

3.4 Feedback do uso das ferramentas

Durante a construção das especicações JML (Seção 3.2) e das obrigações de provas (Seção 3.3), algumas questões surgiram como pontos de atenção ou, até mesmo, levando a alguma adequação na estratégia de anotação ou prova. Documentam-se aqui estas questões.

3.4.1 Workspace Java
Projetos Java com um grande número de classes/arquivos fazem uso de uma hierarquia de pastas, dividindo o projeto em agrupamentos de acordo com a modelagem de progra-
8A versão de JML usada pelo Krakatoa, por vezes, é denominada em sua documentação de KML.

36

mação empregada. Essa estrutura de pastas, com seus respectivos arquivos, é denominada
workspace pelas ferramentas de desenvolvimento Java.

O sistema objeto do estudo de caso do presente trabalho não é diferente: além dos 109

workspacearquivos .java, há 61 diretórios no

somente para acomodar o código-fonte.

Workspaces Java, além de serem usados pelos programadores como estrutura orga-

nizacional de projeto, também evitam colisão entre nomes de diferentes versões de uma

mesma classe 9. No caso em estudo, apesar de as classes selecionadas para especicação

workspacenão terem mais de uma versão, diversas outras classes do

possuem coincidência

de nomes 10.

Assim, a primeira tentativa de vericação das propriedades especicadas manteve os arquivos em sua estrutura original. Obstando-se a essa alternativa, encontrou-se um mau
funcionamento no processamento das diretivas package e import 11, presentes, como era
de se esperar, no código-fonte do projeto.
O sistema possui duas classes interdependentes: Behaviour e Agent. Assim, uma
importa a outra.

Apesar de essa ser uma construção válida em Java, o Krakatoa entra em um ciclo innito ao tentar processar essa dependência. Em verdade, um simples caso de teste como o abaixo reproduz essa situação:

1. crie os diretórios p1 e p2;
2. dentro do diretório p1, crie o arquivo Classe1.java com o seguinte conteúdo:
package p1; import p2.Classe2; public class Classe1 {}
3. dentro do diretório p2, crie o arquivo Classe2.java com o seguinte conteúdo:
package p2; import p1.Classe1; public class Classe2 {}
4. execute, por exemplo, krakatoa p1/Classe1.java;
5. interrompa a execução (innita) e inspecione o arquivo de log (krakatoa.log):
9Essas diferentes versões de uma mesma classe não se referem a diferentes estágios do processo de
desenvolvimento de uma classe, mas sim a diferentes visões de uma mesma classe dentro do projeto, ou seja, diferentes colocações funcionais, o que se considera uma forma de polimorsmo.
10No sistema estudado, apesar de haver 109 arquivos .java, há somente 79 nomes de arquivos .java,
caso descontem-se as repetições de nomes. GetNameBean.java e GreetingAction.java são exemplos de
coincidências de nomes de classes.
11As diretivas package e import são usadas para sinalizar ao compilador Java (javac), respectivamente,
onde os arquivos das classes serão encontrados e quais as dependências interclasses [2].

37

... ... ... adding java file Classe1 (fullname ./p1/Classe1.java) importing package java.lang importing p2.Classe2 importing package java.lang importing p1.Classe1 importing package java.lang importing p2.Classe2 importing package java.lang importing p1.Classe1 importing package java.lang importing p2.Classe2 importing package java.lang importing p1.Classe1 importing package java.lang importing p2.Classe2 ... ... ...

O contorno usado para continuar a ação de vericação foi desativar as diretrizes
package e import no código-fonte (envolvendo-as com comentários) e manter todos
os arquivos do projeto (usados na vericação) em um único diretório. Como não houve
colisão entre os nomes das classes envolvidas, a estratégia sucedeu.

3.4.2 Programação genérica

genericsUma das construções suportadas pela linguagem Java é denominada

ou pro-

gramação genérica [2]. Basicamente a construção permite que, na denição de uma

classe, seja incluído um parâmetro que represente um tipo. A intenção é que seja possí-
vel declarar uma classe como Classe<T>, em que T é um parâmetro que será usado no

corpo da classe onde normalmente são inseridos tipos; posteriormente, instanciações como
Classe<bool> c ou Classe<int> c, possibilitarão que Classe comporte-se exatamente Tcomo declarada, a menos das respectivas substituições, nesses exemplos, == bool ou T == int.

et seq.Este tipo de comportamento polimórco é formalizado por Pierce [37, p. 361

],

que o denomina polimorsmo paramétrico. A formalização ali apresentada tenciona

a inclusão de universal types, resultando em um sistema tradicionalmente denominado

System F.

O caso em estudo faz uso da interface Queue e da classe ConcurrentLinkedQueue, declarados respectivamente como Queue<E> e ConcurrentLinkedQueue<E>. Assim, fazem
uso da programação genérica Java.

38

Por outro lado, Krakatoa não suporta programação genérica Java [32, p. 16].
A solução dada para criar um ambiente de anotação para estas classes sem interferir em
seu comportamento foi a de operar o polimorsmo manualmente, ou seja, criar arquivos
Ecom o código original replicado, substituindo manualmente o parâmetro pelos tipos de
fato usados no código. Para cada tipo usado, ter-se-ia que criar um arquivo, porém a
classe principal selecionada para vericação instancia-os apenas com o tipo Emergency.
Dessa forma, Queue_Emergency e ConcurrentLinkedQueue_Emergency foram criadas, Eonde cada ocorrência do parâmetro , constante dos arquivos originais, foi substituída pelo tipo (classe) Emergency.

3.4.3 Model elds

Por vezes, o processo de anotação requer a modelagem de alguma estrutura de da-

model eldsdos especíca. JML provê um mecanismo de anotação denominado

, o qual

possibilita criar variáveis existentes apenas no escopo das anotações, de forma que esses

et seq.campos não podem ser acessados pelo código Java [28, p. 11

].

Esse mecanismo pode ser usado para prover abstrações do estado concreto de um objeto, onde cada abstração pode denotar diferentes aspectos de um mesmo objeto [11, p. 10].

Esse tipo de construção foi usado em dois pontos das anotações:

 para a classe Agent, quando foi usada para modelar um vetor de comportamentos
e manter atualizada a informação sobre o tamanho do vetor:

//@ model integer qt_behaviours = 0; //@ model Behaviour [] lista_behaviours;

 para a classe HashMap, onde foi empregada para especicar um vetor que acomoda objetos de qualquer tipo (classe Object 12):

//@ model Object [] vetor;

model eldsTentou-se também usar

para abstrair uma la de dados, intentando cons-

truir uma anotação genérica para a interface Queue_Emergency, como as anotações em

Agent e HashMap. Porém, ao tentar gerar as obrigações de prova, a ferramenta apresentou

um mau funcionamento:

File "java/java_typing.ml", line 1109, characters 8-8: Fatal error: exception Assert_failure("java/java_typing.ml", 1109, 8)

Esse erro refere-se a uma exceção inserida dentro do código-fonte do Krakatoa/Why,
especicamente no arquivo java_typing.ml, conforme excerto do código original (escrito
em Objective Caml) abaixo:

Object12Em Java, a classe

é a superclasse de todas as classes [2]. Pierce formalizou essa noção através

Topda constante

como o elemento máximo da relação de subtipo [37, p. 185].

39

1093 and type_term_field_access t loc id =

1094 match t.java_term_type with

1095 | JTYclass(_,c) ->

...

... (SUPRIMIDO)

...

1108 | JTYinterface _ii ->

1109

assert false (* TODO *)

1110 | JTYarray _ ->

...

... (SUPRIMIDO)

...

1120 | JTYnull | JTYbase _ | JTYlogic _ ->

Analisando a linha mencionada (1109), constata-se que faz parte do mecanismo do

eldsKrakatoa de tipagem de termos Java durante acesso a campos (

). Além disso, a

referida linha é executada quando o termo Java for do tipo interface e, de fato, há uma

asserção gerando uma falha com um comentário 13 indicando que esse trecho ainda não

foi totalmente desenvolvido.

Abaixo o conteúdo do arquivo C.java que, após executado com krakatoa C.java,
reproduz o problema:

interface I { /*@ model int a; @*/ }

public class C implements I { }

model eldsEntão, como o recurso (

) não se encontrava disponível para uso com

interfaces, além de não se intentar fazer manipulações do código-fonte original que

mudassem seu comportamento, optou-se por criar uma nova classe, a qual serviu mera-

mente para acomodar variáveis de estado a serem usadas nas anotações, portanto não

sendo referenciada pelo sistema em vericação.

Dessarte simulou-se a funcionalidade model elds para interfaces através da classe estados (Seção 3.2.7).

3.4.4 Classes internas

A linguagem Java permite a denição de uma classe dentro de outra, contrução de-
nominada de classe interna (ou classe aninhada). Esse recurso é usado para agrupar logicamente classes em um único arquivo, aumentando o encapsulamento 14 [2]. Declara-
ções desse tipo ocorrem com estruturas análogas à que segue:

TODO13O comentário em questão é

comumente usado por programadores de língua inglesa para indicar

um afazer, isto é, algo ainda a ser programado.
14Encapsulamento, conceito existente em linguagens orientadas a objeto, refere-se a ocultar os estados

internos (variáveis) de objetos (instâncias de classes) e requerer que toda a interação com esses objetos

seja realizada através de métodos, que, por sua vez, farão a devida atualização desses estados [2].

40

class ClasseExterna { ... class ClasseInterna { ... }
}
O sistema faz uso da classe ThreadedBehaviourFactory, integrante da API JADE,
para geração de novos comportamentos (Seção 3.2.4). Essa classe dene também a classe
interna ThreadedBehaviourWrapper.
Realizadas as anotações no código original (ThreadedBehaviourFactory.java), execu-
tou-se o Krakatoa para gerar as obrigações de prova, porém a ferramenta não reconheceu a declaração da classe interna:
File "./ThreadedBehaviourFactory.java", line 95, characters 39-63: typing error: unknown identifier ThreadedBehaviourWrapper
Sendo a classe interna necessária às anotações (Seção 3.2.4), contornou-se a situação
movendo-a para um arquivo dedicado (ThreadedBehaviourWrapper.java), tornando-a
uma classe convencional, suscetível então à validação sintática do Krakatoa.

3.4.5 Teorias e construções adicionais

A especicação original de JML prevê determinadas extensões para que seja possível

especicar tipos de dados abstratos em anotações. A cláusula represents, que permite

model eldscriar funções envolvendo

15 (Seção 3.4.3), e a possibilidade de usar métodos

em anotações vão ao encontro desse objetivo [11, p. 10].

Em Krakatoa, tais recursos foram preteridos em lugar da possibilidade de declarar no-

vos predicados e funções lógicas. O guia de referência da ferramenta [33, p. 30] cita a pos-

sibilidade dessas e outras extensões de modelagem avançada, porém não as documenta.

Informações sobre esse dialeto da linguagem de especicação do Krakatoa encontram-se

esparsas em apresentações e artigos. Marché [32, p. 11] expõe a sintaxe desses recursos
e acrescenta a possibilidade de usar predicados indutivos e Algebraic Data Types (blocos

axiomáticos onde são declarados nomes de tipos e seus axiomas). Giorgetti [21, p. 3]

theoryreapresenta essa sintaxe e adiciona a possibilidade de denir teorias (cláusula

),

bloco lógico podendo apresentar todas as outras extensões (tipos, predicados, funções e

axiomas).

O sistema sob análise formal faz uso de funcionalidades das APIs JADE e Java que
proveêm para a aplicação estruturas de dados comumente encontradas em APIs (las,
hash maps etc.). Com a intenção de construir anotações genéricas o suciente para serem
reaproveitadas em outras ações de vericação, característica importante para o trabalho,
abstracttentou-se usar as extensões axiomáticas do Krakatoa, nos moldes de um ADT ( data type) de Pierce [37, p. 390 et seq.].
15Tais funções são denominadas model methods.

41

Ao tentar reproduzir exemplos examinados, alguns problemas impediram sua continuidade, sempre de natureza sintática.

et al.O exemplo de Giorgetti

[21] de denição de uma teoria rejeita a cláusula

theory:

/*@ theory Th { @ type new_type; @ logic new_type func1; @ logic integer func2(new_type v, integer k); @ axiom axiom_name: axiom_body; @} @*/

File "Theory.java", line 1, characters 4-10: syntax error (parse error in annotation)

O exemplo de Marché [32] de axiomatização de listas de inteiros não aceita a denição
de um novo tipo (ilist):
/*@ axiomatic IntLists { @ type ilist; @ ilist nil(); @ ilist cons(integer n, ilist l); @ ilist append(ilist l1, ilist l2); @ axiom append_nil: @ \forall ilist l; @ append(nil(),l) == l; @ axiom append_cons: @ \forall integer n; @ \forall ilist l1 l2; @ append(cons(n,l1),l2) == @ cons(n,append(l1,l2)); @} @*/
File "IntLists.java", line 3, characters 6-11: syntax error (parse error in annotation)

Alguns outros exemplos mais simples (encontrados em apresentações) também apresentaram problemas, como abaixo:
/*@ logic integer max(integer x, integer y); @ axiom max_is_ge : @ \forall integer x y; max(x,y) >= x && max(x,y) >= y; @ axiom max_is_some : @ \forall integer x y; max(x,y) == x || max(x,y) == y;

42

@/
File "Logic.java", line 1, characters 45-46: syntax error (parse error in annotation)

De fato, algumas construções simples sucedem, como funções lógicas denidas (não

hash mapaxiomatizadas), contudo foram insucientes para axiomatizar uma la ou um

:

//@ logic integer id(integer x) = x;

Parsing OK. Typing OK.

hashNo caso da classe HashMap, especicou-se uma lista de conversão xa entre o

e

índice do vetor abstrato (Seção 3.2.4).

3.4.6 Provador automático Yices
Inicialmente o provador automático Yices foi também instalado e usado. Entretanto, assim que algumas obrigações de prova começaram a ser descarregadas, percebeu-se que esse provador sempre fechava todas as obrigações, até mesmo quando referiam-se a anotações ainda incipientes.
Após enviar um teste isolado à lista de discussões da ferramenta, recebeu-se resposta de um dos pesquisadores envolvidos na criação da plataforma Why conrmando que havera sido detectado um mau funcionamento no processo de geração de obrigações de prova especicamente para o provador Yices.
Estando a correção disponível somente em uma versão de desenvolvimento da ferramenta e tendo sido instalados outros provadores automáticos (CVC3, Eprover e Spass), optou-se por desabilitar o Yices do ambiente.

3.4.7 Objetivos de prova de outros arquivos

Na Seção 3.3.3, mencionaram-se duas OPs (#01 e #02) que não puderam ser provadas.
Analisando os objetivos gerados, nota-se que são obrigações produzidas para demonstrar
a correção dos construtores das classes estados e ThreadedBehaviourWrapper.

A prova para esses objetivos depende de informação adicional que a ferramenta deveria ter gerado. Em verdade, como a vericação é focada na classe principal, esses objetivos não deveriam ter sido gerados pela ferramenta.

Reproduziu-se então a situação em caso de teste isolado, noticando-a na lista de

discussões da ferramenta. De fato, o comportamento esperado seria que quando você

F.javaexecutar Krakatoa passando como argumento um arquivo

, então as OPs para os

F.javaconstrutores e métodos de classes em

deveriam ser apresentados e somente esses,

não de outros arquivos.

43

Finalmente, apenas para raticar que essas OPs somente não puderam ser fechadas devido a uma operação indesejada da ferramenta, executou-se o Krakatoa para a classe
estados. Foram geradas duas OPs, uma delas sendo a OP gerada inesperadamente na
vericação da classe principal; ambas foram provadas, conforme Tabela 3.5.
44

CVC3 Coq Eprover Spass

Proof obligations
CC Agent, default behavior CC Agent, Safety CC Behaviour, default behavior CC Behaviour, Safety CC ConcurrentLinkedQueue_Emergency, default behavior CC ConcurrentLinkedQueue_Emergency, Safety CC CyclicBehaviour, default behavior CC CyclicBehaviour, Safety CC DataStore, default behavior CC DataStore, default behavior CC DataStore, Safety CC DataStore, Safety CC Emergency, default behavior CC Emergency, Safety CC HashMap, default behavior CC HashMap, Safety CC MonitorAcuteEmergencyBehaviour, default behavior CC MonitorAcuteEmergencyBehaviour, Safety CC Object, default behavior CC Object, Safety CC RequestConrmationBehaviour, default behavior CC RequestConrmationBehaviour, Safety CC SimpleBehaviour, default behavior CC SimpleBehaviour, Safety CC String, default behavior CC String, Safety CC String, default behavior CC String, Safety CC String, default behavior CC String, Safety CC String, default behavior CC String, default behavior CC String, default behavior CC String, Safety CC String, default behavior CC String, default behavior

0.08 0.09 0.10 0.09 0.09 0.09 0.09 0.08 0.09 0.12 0.12 0.11 0.11 0.09 0.10 0.11 0.10 0.09 0.09 0.11 0.10 0.11 0.10 0.09 0.09 0.09 0.09 0.10 0.09 0.09 0.09 0.10 0.08 0.08 0.11 0.09

Tabela 3.2: Objetivos de prova triviais

45

CVC3 Coq Eprover Spass

Proof obligations
CC String, Safety CC String, Safety CC String, Safety CC String, Safety CC String, default behavior CC String, default behavior CC String, Safety CC String, Safety CC String, default behavior CC String, default behavior CC String, Safety CC String, Safety CC ThreadedBehaviourFactory, default behavior CC ThreadedBehaviourFactory, Safety CC ThreadedBehaviourWrapper, Safety CC estados, Safety

0.11 0.08 0.08 0.08 0.09 0.08 0.09 0.10 0.10 0.09 0.12 0.10 0.10 0.08 0.08 0.08

Tabela 3.3: Objetivos de prova triviais (cont.)

CVC3 Coq Eprover Spass

# Proof obligations
01 normal postcondition 02 normal postcondition 03 Method action, Safety

? ?

Tabela 3.4: Objetivos de prova não provados

CVC3 Coq

Proof obligations

normal postcondition

1.35

CC estados, Safety 0.06

Tabela 3.5: Objetivos de prova exclusivos da classe estados

46

Capítulo 4 Conclusão

Este trabalho apresentou métodos formais que podem ser empregados para análise formal de aplicações imperativas não exclusivamente acadêmicas. No caso trabalhado, devido à dependência de diversas bibliotecas, estabeleceu-se uma disciplina de vericação a anotação. O comportamento esperado foi sempre modelado em duas etapas, partindo da especicação do código alvo (classe principal) e culminando com a anotação de classes usadas (bibliotecas de classes), onde apenas o código necessário para esboçar o comportamento do código alvo foi modelado. A cada classe, analisou-se o comportamento de intenção documentado para posteriormente criar as especicações JML correspondentes.

Observou-se que a formalização e vericação de código comercial produzido em massa é um desao de tamanho análogo à própria construção da aplicação. Não obstante, percebeu-se que a vericação de propriedades especícas de partes críticas de sistemas de interesse é um objetivo tangível e, de fato, já perseguido por algumas iniciativas na indústria.

Dois fatores demonstraram contribuir sobremaneira neste processo: a tradução automatizada de código imperativo para uma axiomatização apropriada e o uso de provadores automáticos para eliminar a maioria das obrigações de prova.

Apesar de a Lógica de Hoare ser um formalismo que originalmente captura as constru-

ções básicas de linguagens imperativas, linguagens de programação comerciais como Java

possuem diversas nuanças e extensões que, por si só, carecem de uma formalização semân-

tica. Assim, devido ao uso de determinadas funcionalidades disponíveis nessas linguagens,

a própria compreensão integral do código produzido é um desao. Nesse cenário, de forma

ad hocmanual, realizar a tradução

do código-fonte para a linguagem de especicação de

provadores como Coq e PVS é uma tarefa que pode limitar o uso em grande escala das

soluções envolvidas, por envolver trabalho repetitivo e suscetível a erros. A abordagem

de tradução mecanizada possibilita a concentração de esforços na compreensão dos aspec-

tos semânticos envolvidos, bem como de sua representação apropriada em ambientes de

prova.

Por outro lado, mesmo trechos reduzidos de código geram um número elevado de obrigações a serem provadas. No caso estudado, apenas dois objetivos de prova tiveram como

47

sine qua noncondição

o uso de provadores interativos. Assim, a maioria das obrigações

pôde ser provada também de forma mecanizada.

Quanto à linguagem de especicação de propriedades, todas as construções apresentadas são de primeira ordem, o que limita a expressividade das aplicações. Apesar disso, no caso apresentado, foi possível cobrir parte importante de uma aplicação comercial, apenas com construções de primeira ordem. Adicionalmente a linguagem de especicação apresentada (JML) tem evoluído para suportar construções de ordem superior, porém de forma ainda experimental.

4.1 Trabalhos futuros

frameworksAmbientes de programação voltados ao acoplamento de

, presentes em

linguagens orientadas a objeto (como Java), levam a uma profusão de APIs que estendem

o núcleo básico das linguagens. Documentar formalmente todo esse código é um desao,

mas que simplica vericações subsequentes de aplicações clientes dessas bibliotecas, uma

vez que o comportamento das bibliotecas já estaria especicado. Para tanto, contudo,

é necessário que construções que viabilizem a especicação de tipos de dados abstratos

funcionem de forma adequada nessas ferramentas.

Apesar de a maioria das obrigações ter sido provada por provadores automáticos, a necessidade de usar provadores interativos mostra que a identicação de padrões estruturais nas provas poderia ser revertida para a criação de novas táticas, por exemplo, para o Coq. A experiência com as obrigações de prova demonstradas em Coq mostra que há recorrências no processo de criação do termo de prova. Assim, podem ser desenvolvidas táticas de prova especializadas na axiomatização produzida pelas ferramentas, aumentando o grau de automatização do processo de vericação.

Para o uso comercial do Krakatoa é importante que sua documentação seja consolidada, uma vez que encontra-se esparsa em artigos e apresentações. Este é um trabalho futuro que pode ser realizado de forma gradual e todo incremento na documentação diminuirá o tempo de aprendizagem de novos vericadores.

Finalmente, o problema detectado com o provador automático Yices (Seção 3.4.6)

mostrou que há uma lacuna a ser preenchida no projeto do Why: o processo de tradução

das anotações JML e código imperativo para os diversos provadores não está formalmente

softwaredenido. Assim, o

envolvido, apesar de ter suas entradas e saídas bem denidas,

poderia ter formalizada, por exemplo, a conservatividade do processo de tradução. O tra-

balho de denição formal de JML em Coq de Lehner [29], apesar de não estar diretamente

relacionado com as ferramentas, criou um ambiente para discussão formal sobre a semân-

tica de JML, o qual pode ser usado como ponto de partida para denir formalmente pelo

menos o processo (realizado pelo Krakatoa) de tradução das especicações JML (apostas

nos códigos-fontes) para a linguagem de entrada do Why.

48

Referências
[1] Oracle and/or its aliates. Java Platform, Standard Edition 6, API Specication, 2011. 14, 17, 18, 19, 20
[2] Oracle and/or its aliates. The Java Tutorials, 2012. 37, 38, 39, 40
[3] Patrick Baudin, Pascal Cuoq, Jean-Christophe Filliâtre, Claude Marché, Benjamin
Monate, Yannick Moy, and Virgile Prevosto. ACSL: ANSI/ISO C Specication Language. CEA LIST and INRIA Saclay, 2009. 6
[4] Fabio Bellifemine, Giovanni Caire, Tiziana Trucco, and Giovanni Rimassa. JADE Programmer's Guide, April 2010. 14, 16, 19, 21
[5] Yves Bertot. Coq in a hurry. ACM Computing Research Repository (CoRR), abs /
cs / 0603118, 2006. 8
[6] Yves Bertot and Pierre Castéran. Interactive Theorem Proving and Program Development, Coq'Art: the Calculus of Inductive Constructions. Springer-Verlag, 2004.
8
[7] François Bobot, Jean-Christophe Filliâtre, Claude Marché, and Andrei Paskevich.
The Why3 platform. LRI, CNRS & Univ. Paris-Sud & INRIA Saclay, version 0.64 edition, February 2011. http://why3.lri.fr/. 7 [8] Jaime Alejandro Bohórquez Villamizar. Diseño Efectivo de Programas Correctos.
Escuela Colombiana de Ingeniería, Bogotá, D.C., agosto 2005. Tercera Edición Preliminar. 4
[9] Sylvie Boldo and Thi Minh Tuyen Nguyen. Hardware-independent proofs of nume-
rical programs. In César Muñoz, editor, Second NASA Formal Methods Symposium (NFM 2010), volume NASA/CP-2010-216215, pages 1423, Washington D.C. United
States, 04 2010. NASA. Hisseo project, funded by Digiteo. 1
[10] Sylvain Boulmé. A tutorial on reecting in Coq the generation of Hoare proof obli-
gations, 2009. http://coq.inria.fr/distrib/v8.2/contribs/HoareTut.html. 8
[11] Patrice Chalin, Joseph R. Kiniry, Gary T. Leavens, and Erik Poll. Beyond asserti-
Formalons: Advanced specication and verication with JML and ESC/Java2. In Methods for Components and Objects (FMCO) 2005, Revised Lectures, volume 4111 LNCSof , pages 342363. SV, 2006. 36, 39, 41
49

[12] The Coq proof assistant, 2009. Versão: 8.2pl1, URL: http://coq.inria.fr/. 8
Frama-C User[13] Loïc Correnson, Pascal Cuoq, Armand Puccetti, and Julien Signoles. Manual, Beryllium release. CEA LIST, Software Reliability Laboratory, Saclay, 2009.
7

[14] Edsger W. Dijkstra. Guarded commands, nondeterminacy and formal derivation of
programs. Commun. ACM, 18(8):453457, 1975. 3

[15] Claire Dross, Jean-Christophe Filliâtre, and Yannick Moy. Correct Code Containing
Containers. In 5th International Conference on Tests & Proofs (TAP'11), Zurich,
June 2011. 20
[16] EMERGE, 2009. URL: http://www.emerge-project.eu/. 11

[17] Jean-Christophe Filliâtre, Hugo Herbelin, Bruno Barras, Samuel Boutin, Cristina Cornes, Judicael Courant, Chetan Murthy, Catherine Parent, Christine PaulinMohring, Amokrane Saibi, and Benjamin Werner. The coq proof assistant reference manual. Technical report, INRIA and IST Types working group, 2009. Versão: 8.2. 10

[18] Jean Christophe Filliâtre and Claude Marché. The Why/Krakatoa/Caduceus plat-
form for deductive program verication. In Proceedings of the 19th international conference on Computer Aided verication, CAV'07, pages 173177, Berlin, Heidel-
berg, 2007. Springer-Verlag. viii, 8
[19] Robert W. Floyd. Assigning meanings to programs. In Proceedings of the American Mathematical Society Symposia in Applied Mathematics, volume 19, pages 1932,
1967. 3
http:[20] Frama-C Software Analyzers, 2009. Versão: Beryllium-20090902+dev, URL: //frama-c.cea.fr/. 7

[21] Alain Giorgetti, Claude Marché, Elena Tushkanova, and Olga Kouchnarenko. Spe-

cifying generic java programs: two case studies. In Claus Brabrand and Pierre-

LDTAEtienne Moreau, editors,

, page 8. ACM, 2010. 41, 42

[22] Charles Antony Richard Hoare. An axiomatic basis for computer programming.
Communications of the ACM, 12(10):576580,583, 1969. 3, 4

[23] William A. Howard. The formulas-as-types notion of construction. In J. P. Seldin
and J. R. Hindley, editors, To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus, and Formalism, pages 479490. Academic Press, 1980. 9
[24] Michael R. A. Huth and Mark D. Ryan. Logic in Computer Science: Modelling and Reasoning about Systems. Cambridge University Press, Cambridge, England, 2000.
1, 3

50

[25] Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andronick, David Cock, Philip Derrin, Dhammika Elkaduwe, Kai Engelhardt, Rafal Kolanski, Michael Norrish, Thomas Sewell, Harvey Tuch, and Simon Winwood. seL4: Formal verication of
an OS kernel. In Proceedings of the 22nd ACM Symposium on Operating Systems Principles, pages 207220, Big Sky, MT, USA, Oct 2009. ACM. 1
http:[26] The Krakatoa verication tool for Java programs, 2009. Versão: 2.18, URL: //krakatoa.lri.fr/. 7
[27] Gary T. Leavens, Albert L. Baker, and Clyde Ruby. Preliminary design of JML: a
behavioral interface specication language for Java. SIGSOFT Softw. Eng. Notes,
31:138, May 2006. 6
[28] Gary T. Leavens and Yoonsik Cheon. Design by contract with jml, 2006. 17, 36, 39
[29] Hermann Lehner. A Formal Denition of JML in Coq and its Application to Runtime Assertion Checking. PhD thesis, ETH Zurich, Switzerland, 2011. 48
[30] Leonard Lensink, César Muñoz, and Alwyn Goodloe. From veried models to veriable code. Technical Memorandum NASA/TM-2009-215943, NASA, Langley Research Center, Hampton VA 23681-2199, USA, June 2009. 1
[31] Xavier Leroy. A formally veried compiler back-end. Journal of Automated Reasoning, 43:363446, December 2009. 1
[32] Claude Marché. The Krakatoa tool for deductive verication of Java programs. Winter School on Object-Oriented Verication, Viinistu, Estonia, January 2009.
http://krakatoa.lri.fr/ws/. 24, 36, 39, 41, 42 [33] Claude Marché. Krakatoa: Tutorial and Reference Manual. INRIA Team-Project,
2010. 7, 36, 41
[34] Claude Marché, Christine Paulin-Mohring, and Xavier Urbain. The Krakatoa tool for certication of Java/JavaCard programs annotated in JML. 2003. 1
[35] Michael Marcotty and Henry F. Ledgard. Programming language landscape: syntax, semantics, and implementation. SRA School Group, USA, 1986. 3
[36] Vinicius Uriel Cardoso Nunes. Orquestração de serviços por meio de agentes de soft-
ware no domínio de vida ambiente-assistida. URL: http://monografias.cic.unb. br/dspace/bitstream/123456789/225/1/monografia.pdf, Dezembro 2009. Mo-
nograa de conclusão de bacharelado em Ciência da Computação, Universidade de Brasília. 11, 12, 14
[37] Benjamin C. Pierce. Types and Programming Languages. MIT Press, 2002. 34, 38,
39, 41
[38] The Why verication tool, 2009. Versão: 2.23, URL: http://why.lri.fr/. 7
[39] Z specication language, 2009. URL: http://www.zuser.org/. 6
51

Apêndice A Códigos Anotados

À exceção do arquivo MonitorAcuteEmergencyBehaviour.java, o qual é aqui trans-

ipsis litteriscrito

, apenas os métodos efetivamente anotados constam deste excerto.

A.1 MonitorAcuteEmergencyBehaviour.java
/*KML package br.unb.cic.aal.behaviour;
import jade.core.behaviours.CyclicBehaviour;
import jade.core.behaviours.ThreadedBehaviourFactory;
import java.util.Observable; import java.util.Observer; import java.util.Queue; import java.util.concurrent.ConcurrentLinkedQueue; import java.util.Queue_Emergency; import java.util.concurrent.ConcurrentLinkedQueue_Emergency;
import org.osgi.framework.ServiceReference;
import br.unb.cic.aal.agent.AALAgent; import br.unb.cic.aal.ontology.Emergency; import br.unb.cic.aal.service.emergency.detection.DetectEmergencyService; KML*/
public class MonitorAcuteEmergencyBehaviour extends CyclicBehaviour implements Observer {
/** *
52

*/ private static final long serialVersionUID =
3951408798663833348L;
/*KML private Queue<Emergency> emergencies = new ConcurrentLinkedQueue<Emergency>();
KML*/ private Queue_Emergency emergencies = new ConcurrentLinkedQueue_Emergency(); private DetectEmergencyService detectEmergency = null; private ThreadedBehaviourFactory threadFactory = null;
//KML @Override /*@ @ ensures threadFactory != null; @*/ public void onStart() { threadFactory = new ThreadedBehaviourFactory();
/*KML ServiceReference reference = null; reference = ((AALAgent) myAgent).getBundleContext() .getServiceReference( DetectEmergencyService.class.getName());
detectEmergency = (DetectEmergencyService)((AALAgent) myAgent) .getBundleContext().getService(reference);
detectEmergency.register(this); KML*/
}
//KML @SuppressWarnings("unchecked") //KML @Override
/*@ @ requires threadFactory != null; @ assigns estados.qtde_emergencias; @ behavior emergencia: @ assumes estados.qtde_emergencias >= 1; @ ensures @ estados.qtde_emergencias == @ \old(estados.qtde_emergencias) - 1 @ && myAgent.qt_behaviours == @ \old(myAgent.qt_behaviours) + 1 @ && myAgent.lista_behaviours[\old(myAgent.qt_behaviours)]
53

@ instanceof ThreadedBehaviourWrapper @ && ((ThreadedBehaviourWrapper) @ myAgent.lista_behaviours[\old(myAgent.qt_behaviours)]) @ .myBehaviour instanceof RequestConfirmationBehaviour; @ behavior nenhuma_emergencia: @ assumes estados.qtde_emergencias == 0; @ ensures estados.qtde_emergencias == 0; @*/ public void action() {
Emergency emergency = emergencies.poll(); if (emergency != null) {
RequestConfirmationBehaviour requestConfirmation = new RequestConfirmationBehaviour();
requestConfirmation.getDataStore() .put(RequestConfirmationBehaviour.EVENT_KEY, emergency);
myAgent.addBehaviour( threadFactory.wrap(requestConfirmation)); //Starts a threaded behaviour
} }
//KML @Override /*@ @ assigns estados.qtde_emergencias; @ behavior enfileirar_emergencia: @ assumes arg instanceof Emergency; @ ensures estados.qtde_emergencias == @ \old(estados.qtde_emergencias) + 1; @ behavior nao_enfileirar_emergencia: @ assumes ! (arg instanceof Emergency); @ ensures estados.qtde_emergencias == @ \old(estados.qtde_emergencias); @*/ public void update(Observable o, Object arg) { if (arg instanceof Emergency) { emergencies.add((Emergency) arg); } }
}
A.2 Agent.java
/*KML package jade.core;
54

import jade.core.behaviours.Behaviour; KML*/
public class Agent {
/** Default constructor. */ public Agent();
//@ model integer qt_behaviours = 0; //@ model Behaviour [] lista_behaviours;
/*@ @ requires b instanceof ThreadedBehaviourWrapper; @ ensures qt_behaviours == \old(qt_behaviours) + 1 && @ lista_behaviours[\old(qt_behaviours)] == b; @*/
public void addBehaviour(Behaviour b);
// public void removeBehaviour(Behaviour b);
}
A.3 Queue_Emergency.java
/*KML package java.util;
import br.unb.cic.aal.ontology.Emergency; KML*/
public interface Queue_Emergency /*KML extends Collection<E> KML*/ {
/*@ @ assigns estados.qtde_emergencias; @ ensures estados.qtde_emergencias == @ \old(estados.qtde_emergencias) + 1; @*/
boolean add(Emergency e);
// Emergency remove();
/*@
55

@ assigns estados.qtde_emergencias; @ behavior fila_com_conteudo: @ assumes estados.qtde_emergencias >= 1; @ ensures \result != null && @ estados.qtde_emergencias == @ \old(estados.qtde_emergencias) - 1; @ behavior fila_vazia: @ assumes estados.qtde_emergencias == 0; @ ensures \result == null && @ estados.qtde_emergencias == @ \old(estados.qtde_emergencias); @*/ Emergency poll();
// Emergency peek(); }
A.4 ThreadedBehaviourFactory.java
/*KML package jade.core.behaviours;
//#MIDP_EXCLUDE_FILE
import jade.core.Agent; import jade.core.NotFoundException; import jade.util.Logger;
import java.lang.reflect.Method; import java.util.Vector; import java.util.Enumeration;
KML*/
public class ThreadedBehaviourFactory { /*@ @ requires b != null; @ ensures \result instanceof ThreadedBehaviourWrapper @ && \result != null @ && ((ThreadedBehaviourWrapper)\result) @ .myBehaviour == b; @*/ public Behaviour wrap(Behaviour b) ; /*KML { return new ThreadedBehaviourWrapper(b); } KML*/
}
56

A.5 ThreadedBehaviourWrapper.java
/** * Inner class ThreadedBehaviourWrapper * This class is declared public for debugging purpose only */
public class ThreadedBehaviourWrapper extends Behaviour /*KML implements Runnable KML*/ {
private Behaviour myBehaviour;
//@ ensures myBehaviour == b; private ThreadedBehaviourWrapper(Behaviour b);
} // END of inner class ThreadedBehaviourWrapper
A.6 HashMap.java
/*KML package jade.util.leap;
import java.io.IOException; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.util.Hashtable; import java.util.Enumeration; KML*/
/** The LEAP (environment-dependent) version of the &qote;java.util.HashMap&qote; class. This class appears to be exactly the same in J2SE, PJAVA and MIDP. The internal implementation is different in the three cases however.
@author Nicolas Lhuillier @version 1.0, 29/09/00
@see java.util.HashMap */
public class HashMap /*KML implements Map, Serializable KML*/ { //@ model Object [] vetor;
/*@
57

@ ensures key == RequestConfirmationBehaviour.EVENT_KEY ==> @ vetor[0] == value; @*/ public Object put(Object key, Object value);
/*@ @ ensures key == RequestConfirmationBehaviour.EVENT_KEY ==> @ \result == vetor[0]; @*/
public Object get(Object key); }
A.7 Behaviour.java
/*KML package jade.core.behaviours;
import jade.util.leap.Serializable;
import jade.core.behaviours.DataStore; KML*/
public abstract class Behaviour /*KML implements Serializable KML*/ { // void setParent(CompositeBehaviour cb);
// void setWrappedParent(CompositeBehaviour cb);
// protected CompositeBehaviour getParent();
// public Behaviour(){this.onStart();}
/*@ @ requires a != null; @ ensures myAgent == a; @*/
public Behaviour(Agent a);
public abstract void action();
public void onStart();
//@ ensures \result == myStore && myStore != null; public DataStore getDataStore();
/*@
58

@ requires ds != null; @ ensures myStore == ds; @*/ public void setDataStore(DataStore ds); protected Agent myAgent; private DataStore myStore; }
A.8 estados.java
public class estados { public static int qtde_emergencias; //@ invariant qtde_positiva: qtde_emergencias >= 0; /*@ @ assigns qtde_emergencias; @ ensures qtde_emergencias == 0; @*/ estados() { qtde_emergencias = 0; }
}
59

Anexo I
Trechos da axiomatização Java memory heap
Reproduzem-se aqui alguns poucos trechos da axiomatização descarregada pelo Why para os arquivos de prova do Coq.
(* This file is generated by Why3's Coq driver *) (* Beware! Only edit allowed sections below *)
... ... (SUPRIMIDO) ...
Definition valid (t:Type)(a:(alloc_table t)) (p:(pointer t)): Prop := ((offset_min a p) <= 0%Z)%Z /\ (0%Z <= (offset_max a p))%Z.
Implicit Arguments valid.
... ... (SUPRIMIDO) ...
Axiom address_injective : forall (t:Type), forall (p:(pointer t)), forall (q:(pointer t)), (p = q) <-> ((address p) = (address q)).
Axiom address_shift_lt : forall (t:Type), forall (p:(pointer t)), forall (i:Z), forall (j:Z), ((address (shift p i)) < (address (shift p j)))%Z <-> (i < j)%Z.
Axiom address_shift_le : forall (t:Type), forall (p:(pointer t)), forall (i:Z), forall (j:Z), ((address (shift p i)) <= (address (shift p j)))%Z <-> (i <= j)%Z.
Axiom shift_zero : forall (t:Type), forall (p:(pointer t)), ((shift p
60

0%Z) = p).
Axiom shift_shift : forall (t:Type), forall (p:(pointer t)), forall (i:Z), forall (j:Z), ((shift (shift p i) j) = (shift p (i + j)%Z)).
Axiom offset_max_shift : forall (t:Type), forall (a:(alloc_table t)), forall (p:(pointer t)), forall (i:Z), ((offset_max a (shift p i)) = ((offset_max a p) - i)%Z).
Axiom offset_min_shift : forall (t:Type), forall (a:(alloc_table t)), forall (p:(pointer t)), forall (i:Z), ((offset_min a (shift p i)) = ((offset_min a p) - i)%Z).
Axiom neq_shift : forall (t:Type), forall (p:(pointer t)), forall (i:Z), forall (j:Z), (~ (i = j)) -> ~ ((shift p i) = (shift p j)).
Axiom null_not_valid : forall (t:Type), forall (a:(alloc_table t)), ~ (valid a (null:(pointer t))).
Axiom null_pointer : forall (t:Type), forall (a:(alloc_table t)), (0%Z <= (offset_min a (null:(pointer t))))%Z /\ ((offset_max a (null:(pointer t))) <= (-2%Z)%Z)%Z.
... ... (SUPRIMIDO) ...
Parameter memory : forall (t:Type) (v:Type), Type.
Parameter select: forall (t:Type) (v:Type), (memory t v) -> (pointer t) -> v.
Implicit Arguments select.
Parameter store: forall (t:Type) (v:Type), (memory t v) -> (pointer t) -> v -> (memory t v).
Implicit Arguments store.
Axiom select_store_eq : forall (t:Type) (v:Type), forall (m:(memory t v)), forall (p1:(pointer t)), forall (p2:(pointer t)), forall (a:v), (p1 = p2) -> ((select (store m p1 a) p2) = a).
Axiom select_store_neq : forall (t:Type) (v:Type), forall (m:(memory t v)), forall (p1:(pointer t)), forall (p2:(pointer t)), forall (a:v), (~ (p1 = p2)) -> ((select (store m p1 a) p2) = (select m p2)).
61

... ... (SUPRIMIDO) ...
Definition not_assigns (t:Type) (v:Type)(a:(alloc_table t)) (m1:(memory t v)) (m2:(memory t v)) (l:(pset t)): Prop := forall (p:(pointer t)), ((valid a p) /\ ~ (in_pset p l)) -> ((select m2 p) = (select m1 p)).
Implicit Arguments not_assigns.
Axiom not_assigns_refl : forall (t:Type) (v:Type), forall (a:(alloc_table t)), forall (m:(memory t v)), forall (l:(pset t)), (not_assigns a m m l).
Axiom not_assigns_trans : forall (t:Type) (v:Type), forall (a:(alloc_table t)), forall (m1:(memory t v)), forall (m2:(memory t v)), forall (m3:(memory t v)), forall (l:(pset t)), (not_assigns a m1 m2 l) -> ((not_assigns a m2 m3 l) -> (not_assigns a m1 m3 l)).
... ... (SUPRIMIDO) ...
Axiom subtag_parent : forall (t:Type), forall (t1:(tag_id t)), forall (t2:(tag_id t)), forall (t3:(tag_id t)), (subtag t1 t2) -> ((parenttag t2 t3) -> (subtag t1 t3)).
Definition instanceof (t:Type)(a:(tag_table t)) (p:(pointer t)) (t1:(tag_id t)): Prop := (subtag (typeof a p) t1).
Implicit Arguments instanceof.
Parameter downcast: forall (t:Type), (tag_table t) -> (pointer t) -> (tag_id t) -> (pointer t).
Implicit Arguments downcast.
Axiom downcast_instanceof : forall (t:Type), forall (a:(tag_table t)), forall (p:(pointer t)), forall (s:(tag_id t)), (instanceof a p s) -> ((downcast a p s) = p).
... ... (SUPRIMIDO) ...
Parameter alloc_extends: forall (t:Type), (alloc_table t) -> (alloc_table t) -> Prop.
Implicit Arguments alloc_extends.
62

Definition alloc_fresh (t:Type)(a:(alloc_table t)) (p:(pointer t)) (n:Z): Prop := forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> ~ (valid a (shift p i)).
Implicit Arguments alloc_fresh.
Axiom alloc_extends_offset_min : forall (t:Type), forall (a1:(alloc_table t)), forall (a2:(alloc_table t)), (alloc_extends a1 a2) -> forall (p:(pointer t)), (valid a1 p) -> ((offset_min a1 p) = (offset_min a2 p)).
Axiom alloc_extends_offset_max : forall (t:Type), forall (a1:(alloc_table t)), forall (a2:(alloc_table t)), (alloc_extends a1 a2) -> forall (p:(pointer t)), (valid a1 p) -> ((offset_max a1 p) = (offset_max a2 p)).
... ... (SUPRIMIDO) ...
Axiom usMonitorAcuteEmergencyBehaviour_parenttag_CyclicBehaviour : (parenttag usMonitorAcuteEmergencyBehaviour_tag usCyclicBehaviour_tag).
Definition usNon_null_BehaviourM(x_4:(pointer usObject)) (usObject_alloc_table:(alloc_table usObject)): Prop := ((-1%Z)%Z <= (offset_max usObject_alloc_table x_4))%Z.
Definition usNon_null_Object(x_5:(pointer usObject)) (usObject_alloc_table:(alloc_table usObject)): Prop := (0%Z <= (offset_max usObject_alloc_table x_5))%Z.
Definition usNon_null_ObjectM(x_0:(pointer usObject)) (usObject_alloc_table:(alloc_table usObject)): Prop := ((-1%Z)%Z <= (offset_max usObject_alloc_table x_0))%Z.
Definition usNon_null_StringM(x_3:(pointer usObject)) (usObject_alloc_table:(alloc_table usObject)): Prop := ((-1%Z)%Z <= (offset_max usObject_alloc_table x_3))%Z.
Definition usNon_null_byteM(x_1:(pointer usObject)) (usObject_alloc_table:(alloc_table usObject)): Prop := ((-1%Z)%Z <= (offset_max usObject_alloc_table x_1))%Z.
Definition usNon_null_charM(x_2:(pointer usObject)) (usObject_alloc_table:(alloc_table usObject)): Prop :=
63

((-1%Z)%Z <= (offset_max usObject_alloc_table x_2))%Z. ... ... (SUPRIMIDO) ... (* YOU MAY EDIT THE CONTEXT BELOW *)
64

