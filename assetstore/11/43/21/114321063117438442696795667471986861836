Universidade de Bras√≠lia
Instituto de Ci√™ncias Exatas Departamento de Ci√™ncia da Computa√ß√£o
Um estudo sobre verica√ß√£o formal de sistemas concorrentes
Jo√£o Paulo Carvalho Colu de Queiroz
Bras√≠lia 2012

Universidade de Bras√≠lia
Instituto de Ci√™ncias Exatas Departamento de Ci√™ncia da Computa√ß√£o
Um estudo sobre verica√ß√£o formal de sistemas concorrentes
Jo√£o Paulo Carvalho Colu de Queiroz
Monograa apresentada como requisito parcial para conclus√£o do Mestrado em Computa√ß√£o
Orientador Prof. Dr. Fl√°vio Leonardo Cavalcanti de Moura
Bras√≠lia 2012

Universidade de Bras√≠lia  UnB Instituto de Ci√™ncias Exatas Departamento de Ci√™ncia da Computa√ß√£o Mestrado em Computa√ß√£o
Coordenadora: Prof. Dr. Mylene Christine Queiroz de Farias
Banca examinadora composta por: Prof. Dr. Fl√°vio Leonardo Cavalcanti de Moura (Orientador)  CIC/UnB Prof. Dr. Daniel Lima Ventura  INF/UFG Prof. Dr. Mauricio Ayala Rinc√≥n  CIC/UnB
CIP  Cataloga√ß√£o Internacional na Publica√ß√£o
Queiroz, Jo√£o Paulo Carvalho Colu de. Um estudo sobre verica√ß√£o formal de sistemas concorrentes / Jo√£o Paulo Carvalho Colu de Queiroz. Bras√≠lia : UnB, 2012. 73 p. : il. ; 29,5 cm.
Tese (Mestrado)  Universidade de Bras√≠lia, Bras√≠lia, 2012. 1. Verica√ß√£o Formal, 2. L√≥gica de Hoare, 3. Coq, 4. Linguagens Imperativas, 5. Java, 6. JML, 7. Krakatoa CDU 004.4
Endere√ßo: Universidade de Bras√≠lia Campus Universit√°rio Darcy Ribeiro  Asa Norte CEP 70910-900 Bras√≠liaDF  Brasil

Universidade de Bras√≠lia
Instituto de Ci√™ncias Exatas Departamento de Ci√™ncia da Computa√ß√£o
Um estudo sobre verica√ß√£o formal de sistemas concorrentes

Jo√£o Paulo Carvalho Colu de Queiroz

Monograa apresentada como requisito parcial para conclus√£o do Mestrado em Computa√ß√£o

Prof. Dr. Fl√°vio Leonardo Cavalcanti de Moura (Orientador) CIC/UnB

Prof. Dr. Daniel Lima Ventura Prof. Dr. Mauricio Ayala Rinc√≥n

INF/UFG

CIC/UnB

Prof. Dr. Mylene Christine Queiroz de Farias Coordenadora do Mestrado em Computa√ß√£o

Bras√≠lia, 14 de junho de 2012

Abstract
This work presents a study of methodologies to formally verify applications developed with imperative languages, specially with the Java language. The theoretical formalisms shown include Hoare Logic, which is used to sketch properties on imperative languages, and JML constructions (based on Hoare Logic), which is a specication language used to specify the expected behavior from Java programs. The tools shown are the Krakatoa system, used to convert JML specications into proof obligations, and the Coq interactive proof environment, used to verify proof obligations. Finally, this paper presents a case study that employs the theoretical and practical proposed framework.
Keywords: Formal Verication, Hoare Logic, Coq, Imperative Languages, Java, JML,
Krakatoa
iv

Resumo
Este trabalho apresenta um estudo de metodologias para verica√ß√£o formal de aplicativos desenvolvidos em linguagens imperativas, em especial, na linguagem Java. Os formalismos te√≥ricos mostrados incluem a L√≥gica de Hoare, usada para representar propriedades de aplica√ß√µes imperativas, e constru√ß√µes da linguagem de especica√ß√£o JML (baseada na L√≥gica de Hoare), usada para especicar o comportamento esperado de aplica√ß√µes codicadas em Java. As ferramentas mostradas s√£o o sistema Krakatoa, usado para converter especica√ß√µes JML em obriga√ß√µes de prova, e o ambiente interativo de provas Coq, usado para vericar obriga√ß√µes de prova. Finalmente, exibe-se um estudo de caso que utiliza o ferramental te√≥rico e pr√°tico proposto.
Palavras-chave: Verica√ß√£o Formal, L√≥gica de Hoare, Coq, Linguagens Imperativas,
Java, JML, Krakatoa
v

Sum√°rio

Lista de Figuras

viii

Lista de Tabelas

ix

1 Introdu√ß√£o

1

2 Fundamenta√ß√£o Te√≥rica

2.1 L√≥gica de Hoare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.1.1 O sistema dedutivo de Hoare . . . . . . . . . . . . . . . . . . . . . .

2.2 A linguagem JML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

software2.3 O

Krakatoa . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4 O ambiente de provas Coq . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4.1 Express√µes, f√≥rmulas l√≥gicas e novas constantes . . . . . . . . . . .

2.4.2 Proposi√ß√µes e provas . . . . . . . . . . . . . . . . . . . . . . . . . .

3
3 3 5 7 8 8 9

3 Estudo de Caso

11

3.1 Vida Ambiente-Assistida . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

3.1.1 Conex√£o com os fundamentos te√≥ricos pesquisados . . . . . . . . . . 12

3.1.2 Agente de Emerg√™ncia . . . . . . . . . . . . . . . . . . . . . . . . . 12

3.1.3 Componentes n√£o vericados . . . . . . . . . . . . . . . . . . . . . . 13

3.2 Especica√ß√µes JML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

3.2.1 3.2.2

Classe principal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
Classe Agent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

3.2.3 Classes usadas para enleiramento de emerg√™ncias . . . . . . . . . . 17

3.2.4 Classes usadas para gera√ß√£o de novo comportamento . . . . . . . . 19

3.2.5 Classes usadas para sinalizar emerg√™ncias . . . . . . . . . . . . . . . 20

3.2.6 Classes herdadas pelos comportamentos . . . . . . . . . . . . . . . 21

vi

3.2.7 Classe estados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

3.2.8 Outras classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

3.3 Obriga√ß√µes de provas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

3.3.1 Objetivos de prova principais . . . . . . . . . . . . . . . . . . . . . 25

3.3.2 Objetivos triviais . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

3.3.3 Objetivos n√£o provados . . . . . . . . . . . . . . . . . . . . . . . . . 36
Feedback3.4 do uso das ferramentas . . . . . . . . . . . . . . . . . . . . . . . . 36 3.4.1 Workspace Java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36

3.4.2 3.4.3

Programa√ß√£o gen√©rica . . . . . . . . . . . . . . . . . . . . . . . . . 38
Model elds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

3.4.4 Classes internas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

3.4.5 Teorias e constru√ß√µes adicionais . . . . . . . . . . . . . . . . . . . . 41

3.4.6 Provador autom√°tico Yices . . . . . . . . . . . . . . . . . . . . . . . 43

3.4.7 Objetivos de prova de outros arquivos . . . . . . . . . . . . . . . . . 43

4 Conclus√£o

47

4.1 Trabalhos futuros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

Refer√™ncias

49

A C√≥digos Anotados

52

A.1 MonitorAcuteEmergencyBehaviour.java . . . . . . . . . . . . . . . . . . 52

A.2 Agent.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

A.3 Queue_Emergency.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

A.4 ThreadedBehaviourFactory.java . . . . . . . . . . . . . . . . . . . . . . 56

A.5 ThreadedBehaviourWrapper.java . . . . . . . . . . . . . . . . . . . . . . 57

A.6 HashMap.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

A.7 Behaviour.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58

A.8 estados.java . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

I Trechos da axiomatiza√ß√£o Java memory heap

60

vii

Lista de Figuras
2.1 Esquema de gera√ß√£o de condi√ß√µes de verica√ß√£o; adaptado de [18]. . . . . . 8
3.1 Tela do why3ide com obriga√ß√µes de prova geradas pelo Krakatoa . . . . . . 24
viii

Lista de Tabelas
2.1 Provadores suportados por Why3 . . . . . . . . . . . . . . . . . . . . . . . 7 3.1 Objetivos de prova principais . . . . . . . . . . . . . . . . . . . . . . . . . 26 3.2 Objetivos de prova triviais . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 3.3 Objetivos de prova triviais (cont.) . . . . . . . . . . . . . . . . . . . . . . . 46 3.4 Objetivos de prova n√£o provados . . . . . . . . . . . . . . . . . . . . . . . . 46
3.5 Objetivos de prova exclusivos da classe estados . . . . . . . . . . . . . . . 46
ix

Cap√≠tulo 1 Introdu√ß√£o

A necessidade de verica√ß√£o da corre√ß√£o de um determinado algoritmo apresenta-se ao longo de toda a hist√≥ria do c√°lculo: ap√≥s a cria√ß√£o de um procedimento computacional, o desenvolvedor ou os usu√°rios interessam-se em saber se o produto atende aos requisitos originais.

Os m√©todos de verica√ß√£o formal t√™m recentemente sido empregados pela ind√∫stria e

obtido sucesso em diferentes n√≠veis de utiliza√ß√£o: compiladores [31], sistemas operacionais

smart cards[25], controle de tr√°fego a√©reo [9, 30],

[34]. Esta utiliza√ß√£o crescente gera uma

demanda por prossionais aptos a aplic√°-los [24].

Este trabalho apresenta ferramentas te√≥ricas e computacionais que apoiem a√ß√µes de verica√ß√£o formal, em especial, de linguagens de uso comercial, tais como Java e C; al√©m de um estudo de caso em linguagem Java. O trabalho est√° dividido em dois cap√≠tulos principais que apresentam respectivamente aspectos te√≥ricos e a experi√™ncia com o estudo de caso.

No Cap√≠tulo 2, apresentam-se:

¬à a L√≥gica de Hoare (Se√ß√£o 2.1), usada para especicar formalmente aplica√ß√µes desen-
volvidas com linguagens de programa√ß√£o imperativa, em especial, linguagens que admitem efeitos colaterais encontrados, por exemplo, em opera√ß√µes de atribui√ß√£o;
¬à a linguagem de especica√ß√£o JML (Se√ß√£o 2.2), a qual baseia-se na L√≥gica de Hoare,
e que foi usada para especicar as propriedades esperadas do estudo de caso Java;
¬à o sistema Krakatoa (Se√ß√£o 2.3), que possibilitou converter especica√ß√µes JML e
c√≥digo Java em obriga√ß√µes de prova;
¬à o ambiente interativo de provas Coq (Se√ß√£o 2.4), que foi usado para vericar as
obriga√ß√µes de prova geradas pelo Krakatoa.

No Cap√≠tulo 3, exibe-se o caso pr√°tico em que foi empregado esse ferramental: verica√ß√£o de parte de um sistema multiagente codicado em linguagem Java, o qual atua no dom√≠nio de aplica√ß√µes de Vida Ambiente-Assistida (VAA), intentando criar um ambiente dom√©stico que monitore a sa√∫de pessoal dos assistidos. Criaram-se ent√£o anota√ß√µes JML

1

diretamente no c√≥digo-fonte Java dessa aplica√ß√£o VAA, gerando as obriga√ß√µes de prova atrav√©s do sistema Krakatoa. As obriga√ß√µes de prova geradas foram analisadas no Coq.
Este trabalho espera contribuir como um exemplo real do uso das ferramentas; al√©m de discutir alguns pontos de aten√ß√£o (Se√ß√£o 3.4) quanto ao seu uso, atrav√©s da experi√™ncia adquirida durante a verica√ß√£o do sistema VAA. Esses pontos, por vezes, requereram uma adequa√ß√£o na estrat√©gia de anota√ß√£o ou de prova. Em particular, exibe-se:
¬à o assistente de prova Coq (Se√ß√£o 2.4) sendo usado como plataforma de converg√™ncia
de objetivos de prova gerados;
¬à o uso de provadores autom√°ticos para diminuir a interven√ß√£o manual em obriga√ß√µes
de prova triviais;
¬à documenta√ß√£o formal em JML das partes das APIs (Application Programming In-
terfaces) usadas pelo sistema VAA. Pressup√µe-se do leitor deste texto conhecimento das constru√ß√µes b√°sicas da linguagem Java, uma vez que apenas algumas nuan√ßas dessa linguagem s√£o aqui real√ßadas. Pressup√µe-se tamb√©m experi√™ncia com algum provador interativo, pois o provador Coq √© aqui brevemente apresentado.
2

Cap√≠tulo 2 Fundamenta√ß√£o Te√≥rica

2.1 L√≥gica de Hoare

Uma linguagem de programa√ß√£o imperativa caracteriza-se por conter sequ√™ncias de comandos que podem modicar o estado de execu√ß√£o do programa, ou seja, admite co-
mandos com efeitos colaterais 1[35], tal como uma atribui√ß√£o, onde a opera√ß√£o {x := 1} xmodica o estado de mem√≥ria na regi√£o que acomoda o valor da vari√°vel . Triplas de
Hoare permitem especicar programas com essa caracter√≠stica, possibilitando expressar pr√©-condi√ß√µes e p√≥s-condi√ß√µes [24, p. 224], como ser√° mostrado na se√ß√£o seguinte (Se√ß√£o 2.1.1).
Floyd [19] prop√¥s uma t√©cnica de modelagem de aplica√ß√µes imperativas atrav√©s de uxogramas (grafos dirigidos) e a gera√ß√£o de condi√ß√µes de verica√ß√£o ao longo do uxograma. Inuenciado por esse trabalho, Hoare [22] apresentou um sistema dedutivo composto de axiomas e regras de infer√™ncia. Dijkstra75 [14] criou um c√°lculo para a L√≥gica de Hoare, posteriormente denominado de C√°lculo da Pr√©-condi√ß√£o mais Fraca 2. Esses trabalhos referem-se a um subconjunto de instru√ß√µes presente em todas as linguagens imperativas, conquanto n√£o tratam de uma linguagem de programa√ß√£o espec√≠ca.
O sistema dedutivo proposto por Hoare √© usado como fundamento de diversas linguagens de especica√ß√£o para linguagens imperativas, tais como as linguagens JML e ACSL, descritas na Se√ß√£o 2.2.

2.1.1 O sistema dedutivo de Hoare
O sistema dedutivo de Hoare √© baseado na no√ß√£o de triplas de Hoare usada para
œÜ Pestabelecer a conex√£o entre uma pr√©-condi√ß√£o , um algoritmo e uma p√≥s-condi√ß√£o (descri√ß√£o de resultado) œà:

œÜ {P } œà 1Tradu√ß√£o do termo original, em ingl√™s: side-eects statements. 2Weakest Precondition Calculus

(2.1)

3

œÜEsta nota√ß√£o deve ser interpretada como se a asser√ß√£o for verdadeira antes do in√≠cio P œàdo programa , ent√£o a asser√ß√£o ser√° verdadeira quando esse programa terminar.
xA opera√ß√£o de atribui√ß√£o de uma vari√°vel (por exemplo, := f ) √© representada por
um axioma:
Axioma 1. œà0 {x := f} œà onde x √© um identicador de vari√°vel; f √© uma express√£o, eventualmente contendo x; e œà0 √© obtido a partir de œà substituindo-se todas as ocorr√™ncias de x por f.

Este axioma, formulado originalmente em [22], foi apresentado de forma mais geral em [8]:
Axioma 2. œÜ {x := f} œà ‚â° œÜ ‚áí œà[x := f ]

onde, a substitui√ß√£o œà[x := f ] denota uma express√£o que √© igual a œà, exceto pelo fato de que todas as apari√ß√µes de x em œà s√£o substitu√≠das por f .

et seq.Villamizar [8, p. 66

] descreveu sua formula√ß√£o do axioma da atribui√ß√£o da

seguinte forma:

Em vez de explicar a atribui√ß√£o pela forma em que se executa, pode-se entend√™-
la em termos de substitui√ß√£o textual ou sint√°tica. A ideia chave envolve raciocinar
para tr√°s; das p√≥s-condi√ß√µes para as pr√©-condi√ß√µes.
[. . . ] como, ap√≥s a atribui√ß√£o, x recebe o valor que tinha a express√£o f antes da atribui√ß√£o, este axioma expressa que, para que œà aplique-se a x ap√≥s a atribui√ß√£o, esta asser√ß√£o (œà) deveria valer para f (œà aplicada a f ) antes da atribui√ß√£o. Portanto, a pr√©-condi√ß√£o œÜ deve implicar œà[x := f ].
[. . . ] Aplicando o axioma da atribui√ß√£o ao caso particular œÜ ‚â° œà[x := f ] obtemos œà[x := f ] {x := f} œà. Armamos que œà[x := f ] √© a pr√©-condi√ß√£o mais fraca 3 (weakest precondition) para que a execu√ß√£o de {x := f} termine com œà verdadeiro.

Nota-se que a partir desse axioma mais geral, pode-se obter o axioma original:

œà[x := f ] {x := f } œà

(2.2)

Um programa imperativo consiste de uma sequ√™ncia de comandos que s√£o escritos um ap√≥s o outro. Na linguagem imperativa denida por Hoare, comandos s√£o encadeados
usando-se um ponto-e-v√≠rgula: (P1; P2; . . . ; Pn). O conjunto de regras de infer√™ncia a seguir
permite expressar opera√ß√µes de linguagens imperativas, como por exemplo o encadeamento de programas (Regra de Infer√™ncia 1) ou consequ√™ncias (Regra de Infer√™ncia 2 e Regra de Infer√™ncia 3):
Regra de Infer√™ncia 1. Se œÜ{P1}œà1 e œà1{P2}œà ent√£o œÜ{(P1; P2)}œà
Regra de Infer√™ncia 2. Se œÜ{P}œà e œà ‚Üí œá ent√£o œÜ{P}œá
Regra de Infer√™ncia 3. Se œÜ{P}œà e œá ‚Üí œÜ ent√£o œá{P}œà
3um predicado œà diz-se mais fraco que outro œÜ, se œÜ ‚áí œà vale.

4

Dentre outras constru√ß√µes de linguagens imperativas, √© importante a capacidade de

Pexpressar itera√ß√µes, ou seja, executar uma por√ß√£o de programa ( ) repetidamente at√©

Œ≤uma determinada condi√ß√£o ( ) tornar-se falsa, sendo que, ao longo de toda a execu√ß√£o,

invarianteœÜo predicado (conhecido como

) √© verdadeiro. Assim, pode-se caracterizar o

programa while Œ≤ do P por:

Regra de Infer√™ncia 4. Se œÜ ‚àß Œ≤{P }œÜ ent√£o œÜ{while Œ≤ do P }¬¨Œ≤ ‚àß œÜ

2.2 A linguagem JML

As linguagens ACSL e JML s√£o linguagens de especica√ß√£o de propriedades inspiradas no formalismo de Hoare. Com essas linguagens, pode-se anotar aplica√ß√µes escritas respectivamente em linguagem C e Java. Al√©m de serem baseadas na mesma l√≥gica, elas possuem um cerne de constru√ß√µes comum, uma vez que ACSL (ANSI/ISO C Specication Language) √© uma adapta√ß√£o (para a linguagem C) de JML (Java Modeling Language).

As especica√ß√µes (ou anota√ß√µes) s√£o feitas usando pr√©-condi√ß√µes, p√≥s-condi√ß√µes e in-

variantes. Essas anota√ß√µes s√£o feitas no pr√≥prio c√≥digo-fonte, dentro de coment√°rios, e

softwareportanto sua introdu√ß√£o nesses arquivos n√£o afeta o comportamento do

gerado.

As anota√ß√µes utilizam uma formata√ß√£o especial: /*@ anota√ß√£o */ ou //@ anota√ß√£o.

Somente algumas poucas constru√ß√µes comuns s√£o aqui apresentadas.

Consideremos o exemplo abaixo de uma fun√ß√£o maximo() usando ponteiros (codicada
em linguagem C):

/*@ @ requires \valid(x) && \valid(y) && \valid(res); @ ensures *res >= *x && *res >= *y; @ ensures *res == *x || *res == *y; @ ensures \result == *res; @ ensures *x == \old(*x) && *y == \old(*y); @*/
int maximo(int *x, int *y, int *res) {
if (*x > *y) *res = *x;
else *res = *y;

return *res; }

A especica√ß√£o da fun√ß√£o est√° escrita imediatamente acima da declara√ß√£o da fun-

√ß√£o. Neste exemplo, o contrato (especica√ß√£o) cont√©m pr√©-condi√ß√µes (cl√°usula requires)

quanto √† validade dos ponteiros usados e p√≥s-condi√ß√µes (cl√°usulas ensures) que garantam

*resa corre√ß√£o da informa√ß√£o em

e do retorno da fun√ß√£o (ambas retornam o m√°ximo),

5

*x *yal√©m de assegurar que e n√£o venham a ser modicadas. Para tanto, usaram-se as
seguintes constru√ß√µes:
¬à \valid() gerar√° condi√ß√£o de verica√ß√£o para a certica√ß√£o de que o ponteiro pa-
rametrizado tenha sido previamente alocado (v√°lido); o que equivale a testar se o
conte√∫do √© diferente de null, por exemplo, p √© v√°lido se p != null, caso contr√°rio p ser√° inv√°lido; ¬à \result denota o resultado de uma fun√ß√£o (retorno de um procedimento); ¬à old()\ indica o valor inicial de um par√¢metro, ou seja, o valor originalmente recebido
pela fun√ß√£o;
¬à >= ==os operadores aritm√©ticos e t√™m o signicado usual; && ||¬à e correspondem respectivamente aos operadores l√≥gicos conjun√ß√£o e disjun√ß√£o; ¬à duas cl√°usulas ensures est√£o relacionadas atrav√©s de uma conjun√ß√£o, ou seja, todas
as asser√ß√µes constantes nas cl√°usulas do exemplo devem ser v√°lidas ao t√©rmino da execu√ß√£o da fun√ß√£o.
Essas linguagens de especica√ß√£o s√£o essencialmente baseadas em l√≥gica de primeira ordem, assim como outras linguagens de especica√ß√£o comportamental frequentemente usadas, tal como Z [39]. N√£o obstante, as linguagens de especica√ß√£o aqui estudadas suportam tamb√©m:
¬à recursividade: o fornecimento de medidas para verica√ß√£o da termina√ß√£o de fun√ß√µes
recursivas, inclusive no caso mais geral de recursividade m√∫tua; para tanto deve-se
fornecer a express√£o de decrescimento atrav√©s da cl√°usula decreases; ¬à predicados indutivos, constru√ß√µes como inductive P(x1, ... ,xn) { case c1
: p1; ... case ck : pk; } ¬à tipos polim√≥rcos (EXPERIMENTAL), por exemplo, pode-se considerar a declara-
√ß√£o //@ type list <A>; ¬à constru√ß√µes de ordem superior (EXPERIMENTAL), atrav√©s de termos como \lambda
T1 x1, ... , Tn xn ; t, que equivaleria ao Œª-termo tipado Œªx1 : T1, ..., xn : Tn.t.
No estudo de caso apresentado (Cap√≠tulo 3), estas constru√ß√µes n√£o foram empregadas, pois, com exce√ß√£o dos tipos polim√≥rcos, a modelagem da aplica√ß√£o Java vericada n√£o as requereu: as partes vericadas n√£o possuem m√©todos recursivos, tratamento de casos ou, por exemplo, m√©todos que recebam m√©todos como argumento (ordem superior). Quanto √† deni√ß√£o de tipos polim√≥rcos, algumas restri√ß√µes foram encontradas nesse recurso experimental impedindo a deni√ß√£o de novos tipos (Se√ß√£o 3.4.5).
Refer√™ncias para as linguagens de especica√ß√£o ACSL e JML podem ser encontradas respectivamente em [3] e [27].
6

2.3 O software Krakatoa

O Krakatoa [26] √© uma plataforma de an√°lise est√°tica de c√≥digo-fonte escrito em linguagem Java, voltado para as a√ß√µes de infer√™ncia l√≥gica. Aceita especica√ß√µes expressas em JML. O Frama-C [20] √© sistema an√°logo voltado para a verica√ß√£o de programas escritos em linguagem C e anotados com ACSL.

As ferramentas analisam o c√≥digo e as especica√ß√µes de comportamento fornecidas,

validam-nos quanto a erros sint√°ticos e os convertem para uma linguagem comum, que

software in-ser√° entrada para o

intermedi√°rio Why [38]. Esta aplica√ß√£o age como uma

terface para o Krakatoa (e o Frama-c) e os provadores, facilitando o acoplamento de

novos ambientes de prova (autom√°ticos ou manuais), bem como de novos tradutores de

linguagens imperativas e linguagens de especica√ß√£o. Atualmente s√£o suportadas as refe-

ridas tradu√ß√µes de Java/JML e C/ACSL. A rela√ß√£o dos provadores suportados pode ser

encontrada na Tabela 2.1.

Interativos Autom√°ticos

Coq PVS (em progresso)

Alt-Ergo CVC3
E-prover Gappa
Simplify SPASS Vampire
veriT Yices
Z3

Tabela 2.1: Provadores suportados por Why3

As condi√ß√µes de verica√ß√£o ser√£o ent√£o traduzidas para a linguagem espec√≠ca de um dado provador de escolha do usu√°rio, e que seja suportada pela plataforma Why. Em seguida o provador √© invocado pelo sistema.

Como ser√° visto no caso trabalhado (Cap√≠tulo 3), mesmo que o foco de uma a√ß√£o

de verica√ß√£o seja o uso de um determinado provador interativo, o uso de provadores

autom√°ticos mecaniza a prova de um grande volume de obriga√ß√µes triviais, de forma que

o provador interativo pode ser utilizado somente para as obriga√ß√µes n√£o-triviais. Um

esquema geral do processo de tradu√ß√£o das especica√ß√µes ACSL/JML para os ambientes

de prova (autom√°ticos ou interativos), passando pelo Why, pode ser visto na Figura 2.1.

softwaresManuais de opera√ß√£o destes

podem ser encontradas em [33], [13] e [7].

softwaresTodos os

descritos nesta se√ß√£o s√£o de c√≥digo aberto, licenciados sob a GNU

LGPL v2. H√° vers√µes dispon√≠veis para Linux, Mac OS X e Windows, contudo n√£o h√°

homologa√ß√µes para vers√µes espec√≠cas desses sistemas operacionais.

7

Figura 2.1: Esquema de gera√ß√£o de condi√ß√µes de verica√ß√£o; adaptado de [18].
2.4 O ambiente de provas Coq

O assistente de prova Coq [12] √© um sistema que permite expressar especica√ß√µes, desenvolver programas ou realizar provas matem√°ticas baseadas em uma l√≥gica de or-
Œªdem superior (C√°lculo de Constru√ß√µes Indutivas, formalismo derivado do C√°lculo- com
tipos). Adicionalmente, este ambiente pode ser usado como estrutura l√≥gica para que algu√©m forne√ßa axiomas para novas l√≥gicas e realizar provas nesses novos sistemas. Por exemplo, pode ser usado para implementar l√≥gicas modais, temporais ou pode ser usado para raciocinar sobre programas imperativos [10].

softwaresAssim como os

da Se√ß√£o 2.3, Coq √© licenciado sob a GNU LGPL v2 e

encontra-se dispon√≠vel para Linux, Mac OS X e Windows.

A seguir, s√£o brevemente apresentados alguns dos recursos e caracter√≠sticas do Coq introduzidos por [5]. Para uma discus√£o ampla da ferramenta e do formalismo subjacente, pode-se consultar [6].

2.4.1 Express√µes, f√≥rmulas l√≥gicas e novas constantes

A nota√ß√£o A : B √© usada para indicar que a express√£o A tem como tipo a express√£o B.

Entre essas express√µes, algumas podem ser interpretadas, por exemplo, como proposi√ß√µes
(t√™m tipo Prop), outras como n√∫meros naturais (t√™m tipo nat) e outras como elementos de

estruturas de dados mais complexas. F√≥rmulas l√≥gicas complexas podem ser constru√≠das

combinando proposi√ß√µes com conectivos l√≥gicos ou outras express√µes. Pode-se tamb√©m

funconstruir uma nova fun√ß√£o com a palavra-chave

Œª, a qual substitui o s√≠mbolo do

CheckŒªC√°lculo- . Para conferir se uma f√≥rmula √© bem-formada, usa-se o comando

, por

exemplo:

Check (fun x:nat => x = 3). fun x : nat => x = 3 : nat -> Prop
Check (forall x:nat, x < 3 \/ (exists y:nat, x = y + 3)).

8

forall x : nat, x < 3 \/ (exists y : nat, x = y + 3) : Prop

Check (let f := fun x => (x * 3, x) in f 3). let f := fun x : nat => (x * 3, x) in f 3 : nat * nat

letA intui√ß√£o do comando

√© a de substitui√ß√£o, por exemplo:

let

x

:=

y

in

t√©

t xequivalente ao termo , exceto pelo fato de que as ocorr√™ncias de ser√£o substitu√≠das pelo

termo y.

2.4.2 Proposi√ß√µes e provas

O sistema Coq baseia-se no isomorsmo de Curry-Howard [23]: tipos correspondem a
proposi√ß√µes, e provas a termos. Assim, a nota√ß√£o A : B denota que o termo A √© do tipo B ou ainda que A √© uma prova da f√≥rmula l√≥gica B.
Um teorema que prova uma implica√ß√£o A ‚áí B pode ser interpretado como um termo
em que seu tipo expressa uma fun√ß√£o (tipo funcional), a qual recebe um argumento do
A Btipo produzindo um retorno do tipo . Esse tipo funcional √© expresso em Coq pela nota√ß√£o A -> B. Assim, uma fun√ß√£o f desse tipo (denotada por f : A -> B) pode ser aplicada a um termo t do tipo A (denotado por t : A), o que permitiria deduzir B, pois o retorno da aplica√ß√£o de f a t seria desse tipo, ou seja, f t : B. Essa din√¢mica
corresponde √† regra de infer√™ncia modus ponens.

A constru√ß√£o de provas dessa forma, ou seja, apresentando manualmente termos que

possuam determinado tipo, torna-se invi√°vel para tipos (proposi√ß√µes) n√£o-triviais. A abor-

dagem usualmente empregada envolve o uso de t√°ticas: programas que, em determinados

casos, permitem a constru√ß√£o autom√°tica de trechos de provas. A seguir, usa-se a conhe-

cida propriedade sobre n√∫meros naturais ‚àÄn ‚àà N, 2 ‚àó

n i=0

i

=

n

‚àó

(n

+

1)

para

ilustrar

uma prova em Coq usando t√°ticas:

Fixpoint somar_ate_n (n:nat) : nat := match n with | 0 => 0 | S n' => S n' + somar_ate_n n' end.

(* Carregar aritm√©tica b√°sica de Peano *) Require Import Arith.

Theorem somar_ate_n_prop: forall n:nat, 2*(somar_ate_n n) = n*(S n).
Proof. intro n. induction n.

(* Base de indu√ß√£o *) simpl.

9

reflexivity.

Qed.

(* Passo indutivo *) simpl. ring_simplify. rewrite IHn. ring.

scriptApresenta-se a intui√ß√£o das t√°ticas apresentadas no

acima, conforme descrito

por Filli√¢tre et al. [17]:

¬à intro: introduz antecedentes de implica√ß√µes e par√¢metros de forall;

¬à induction: inicia uma prova por indu√ß√£o;

¬à simpl: simplica um termo usando computa√ß√£o, por exemplo, aplicada em um 1objetivo do tipo + 1 2produzir√° um objetivo do tipo ;

¬à reflexivity: tsoluciona objetivos que tenha a forma = u, vericando se t √© conuvers√≠vel em , caso em que soluciona o objetivo com sucesso;

ring¬à : soluciona equa√ß√µes contendo express√µes polinomiais da estrutura alg√©brica
anel (ou semi-anel);

¬à ring_simplify: opera em objetivos simultaneamente como ring e simpl, ou seja,

ringatual como

normalizando (simplicando) os objetivos;

¬à rewrite termo: reescreve o objetivo de acordo com uma igualdade fornecida; ent√£o o par√¢metro termo deve ter uma igualdade em seu tipo; exemplo, rewrite t, onde t : x = 5 x 5, substitui as ocorr√™ncias de no objetivo por .

Observe ainda que a prova do teorema exemplo somar_ate_n_prop (acima) pode ser
vista ainda em uma estrutura de √°rvore, representando os dois subobjetivos da prova por indu√ß√£o:
intro n
induction n

(* Base indutiva *) (* Passo indutivo *)

simpl reflexivity

simpl ring_simplify
rewrite IHn ring

10

Cap√≠tulo 3 Estudo de Caso

3.1 Vida Ambiente-Assistida

Vida Ambiente-Assistida (VAA) √© um dom√≠nio de solu√ß√µes de monitoramento que tenciona a cria√ß√£o de um ambiente dom√©stico inteligente. As solu√ß√µes que comp√µem esse
dom√≠nio usualmente envolvem dispositivos de hardware e software, al√©m de um conjunto
de servi√ßos integrados que provejam assist√™ncia a pessoas. Por exemplo, em um ambiente em que viva uma pessoa idosa ou com alguma necessidade especial, sensores podem captar a ocorr√™ncia de atividades anormais, como uma queda, e enviar um alerta para uma central de atendimento a incidentes.

Inserido nesse contexto, o EMERGE [16] √© um projeto que visa detectar situa√ß√µes de

emerg√™ncia, propondo o uso de sensores embutidos na resid√™ncia da pessoa assistida para

a captura de diversos dados do ambiente. Estes dados devem ser processados por um

softwaresistema de

que identique situa√ß√µes de emerg√™ncia, tratando-as adequadamente.

O EMERGE prop√µe uma especica√ß√£o da arquitetura e dos requisitos desse sistema,

envolvendo a combina√ß√£o de sistemas multiagentes, por√©m n√£o implementa de fato o

sistema.

O projeto apresentado em [36] implementa a parte do sistema respons√°vel pelo enca-

minhamento das situa√ß√µes de emerg√™ncia. Para a an√°lise e desenho dos agentes, foi usada

a metodologia GAIA [36, p. 59] e, para sua implementa√ß√£o, a linguagem Java. Para

livenessesbo√ßar determinadas propriedades de

1, isto √©, propriedades que devem ser cum-

pridas caso algum evento espec√≠co aconte√ßa, empregou-se um m√©todo semiformal2 que

documentou o comportamento esperado (comportamento de inten√ß√£o) do sistema. Al√©m disso, para expressar o conte√∫do das mensagens usou-se um padr√£o3 que dene mensagens

a partir da combina√ß√£o de termos e predicados.

1Tamb√©m denominadas de responsabilidades de sobreviv√™ncia. 2Pertencente √† metodologia GAIA de desenvolvimento de sistemas multiagentes. 3FIPA ACL

11

3.1.1 Conex√£o com os fundamentos te√≥ricos pesquisados

A linguagem Java, usada pelo sistema, compatibiliza-se com os fundamentos dispostos

pela L√≥gica de Hoare (Se√ß√£o 2.1) e, dessa forma, usando a linguagem JML (Se√ß√£o 2.2),

especica-se o comportamento esperado para o c√≥digo Java a partir de tais predicados.

softwareCom o

Krakatoa (Se√ß√£o 2.3), as obriga√ß√µes de prova para as Triplas de Hoare (es-

pecica√ß√£o de pr√©-condi√ß√µes e p√≥s-condi√ß√µes em JML, juntamente com o c√≥digo Java) s√£o

descarregadas para o ambiente de provas Coq (Se√ß√£o 2.4). Os lemas triviais s√£o provados

SMT proverscom o aux√≠lio de algum vericador autom√°tico (CVC3, Ergo,

), apenas para

efeito de mecaniza√ß√£o de provas, uma vez que todos os lemas provados automaticamente

tamb√©m podem ser provados de forma interativa (manual).

3.1.2 Agente de Emerg√™ncia
etOs comportamentos selecionados para verica√ß√£o foram extra√≠dos de [36, p. 98 seq.]. A sele√ß√£o ocorreu mediante entrevista com o autor, tendo este, por ju√≠zo pr√≥prio,
considerado essa sele√ß√£o como a parte mais cr√≠tica do sistema. Cabe salientar que, de 109 arquivos .java, apenas tr√™s referem-se ao Agente de Emerg√™ncia, que implementa o papel Assistente de Emerg√™ncia.
As classes Java que comp√µem esse assistente s√£o:

¬à RequestConfirmationBehaviour; ¬à MonitorLongTermDeviationBehaviour; ¬à MonitorAcuteEmergencyBehaviour.

workspaceEssas classes (arquivos) encontram-se na seguinte subpasta do

do projeto:

EmergencyAgentBundle/src/br/unb/cic/aal/behaviour
livenessEsses comportamentos foram implementados tomando como base express√µes do agente. A responsabilidade de sobreviv√™ncia que o EmergencyAgent (agente de emer-
g√™ncia) deve atender est√° especicada conforme abaixo:
(I nvocarDetectarAlarme|I nvocarDetectarE mergencia)œâ .P edirConf irmacao.[InvocarEnviarDadosDispatcher.EnviarN otif icacao] || (InvocarDetectarDesvios)œâ.InvocarEnviarDadosSSM .EnviarN otif icacao

livenessAs regras de forma√ß√£o de express√µes

(como a express√£o acima) est√£o detalha-

das em [36, p. 62 et seq.].

Al√©m disso, o autor do sistema separou por√ß√µes dessa express√£o para cada comporta-
livenessmento (classe/arquivo .java) do agente. Relacionam-se abaixo as subexpress√µes que cada comportamento/classe do agente EmergencyAgent deve atender:

12

¬à MonitorAcuteEmergencyBehaviour: (I nvocarDetectarAlarme|I nvocarDetectarE mergencia)œâ
¬à RequestConfirmationBehaviour:
P edirConf irmacao.[InvocarEnviarDadosDispatcher.EnviarN otif icacao]
¬à MonitorLongTermDeviationBehaviour: (InvocarDetectarDesvios)œâ.InvocarEnviarDadosSSM .EnviarN otif icacao
Destes tr√™s comportamentos, o comportamento MonitorAcuteEmergencyBehaviour
√© o respons√°vel pela detec√ß√£o de emerg√™ncias agudas, tendo sido o foco das a√ß√µes de verica√ß√£o.
Para fazer a verica√ß√£o do comportamento MonitorAcuteEmergencyBehaviour isola-
damente, foram realizadas anota√ß√µes JML referentes √† sem√¢ntica de inten√ß√£o dos agentes (solicita√ß√µes √† camada JADE) e a consecu√ß√£o das respectivas obriga√ß√µes de prova no ambiente Coq. Ao todo, 19 classes necessitaram de algum tipo de anota√ß√£o para que
MonitorAcuteEmergencyBehaviour tivesse seu comportamento especicado, como ser√°
mostrado na se√ß√£o seguinte (Se√ß√£o 3.2):
Agent.java Behaviour.java ConcurrentLinkedQueue_Emergency.java ConcurrentLinkedQueue.java CyclicBehaviour.java DataStore.java DetectEmergencyService.java Emergency.java estados.java HashMap.java MonitorAcuteEmergencyBehaviour.java Observable.java Observer.java Queue_Emergency.java Queue.java RequestConfirmationBehaviour.java SimpleBehaviour.java ThreadedBehaviourFactory.java ThreadedBehaviourWrapper.java
3.1.3 Componentes n√£o vericados
fra-As classes de comportamento fazem uso de JADE (Java Agent DEvelopment), mework que fornece funcionalidades de middleware para agentes. Assim a aplica√ß√£o em
estudo n√£o tratou de detalhes f√≠sicos concernentes ao estabelecimento de canais de comunica√ß√£o; tais funcionalidades foram delegadas pela aplica√ß√£o √† camada JADE.
13

Dessa forma, no que tange √† verica√ß√£o formal do sistema, cona-se na implementa-

frameworks√ß√£o dos

usados pelo sistema, apenas especicando-se o seu comportamento

conforme sua documenta√ß√£o ocial. Para que se possa garantir o funcionamento correto

dessas ferramentas, estas devem ser objeto de a√ß√£o de verica√ß√£o espec√≠ca, o que n√£o faz

parte do escopo do presente estudo.

3.2 Especica√ß√µes JML
O processo de execu√ß√£o das anota√ß√µes deu-se em duas etapas:
1. anota√ß√£o da classe principal (MonitorAcuteEmergencyBehaviour) do comporta-
mento do agente;
2. anota√ß√£o de classes perif√©ricas √† classe principal (apenas c√≥digo usado por essa classe).
Para cada classe, sempre usou-se o mesmo m√©todo para cria√ß√£o das anota√ß√µes: analisou-se o comportamento de inten√ß√£o documentado [36, 4, 1] e criou-se especica√ß√µes JML que dele representassem uma abstra√ß√£o l√≥gica. O c√≥digo-fonte das classes Java com suas respectivas anota√ß√µes JML pode ser encontrado em
https://lambda.cic.unb.br/svn/mestrado/jp/vida-assistida/codigo-anotado.
3.2.1 Classe principal
A classe MonitorAcuteEmergencyBehaviour, pertencente ao EmergencyAgent, res-
ponsabiliza-se por monitorar eventos de emerg√™ncia. No caso de ocorr√™ncia de um destes
eventos, deve requisitar a outro agente (ElderlyAgent) que realize a a√ß√£o de conrmar ou n√£o a emerg√™ncia junto √† pessoa assistida. Esta intera√ß√£o do EmergencyAgent com o ElderlyAgent √© representada pela inclus√£o de RequestConfirmationBehaviour na lista de comportamentos que o agente EmergencyAgent pode ter (executar).
A classe MonitorAcuteEmergencyBehaviour foi codicada sendo derivada da classe CyclicBehaviour, classe da API JADE [4], e tendo implementado a interface Observer,
classe da API Java SDK [1]. Essa classe possui tr√™s m√©todos:
¬à onStart(): esse m√©todo √© executado na inicializa√ß√£o do comportamento; √© execu-
tado apenas uma vez, o que ocorre imediatamente antes da primeira chamada ao
m√©todo action() do comportamento; ¬à action(): para classes derivadas de CyclicBehaviour (que √© o caso da classe
MonitorAcuteEmergencyBehaviour), este m√©todo √© executado continuamente, de
forma c√≠clica;
¬à update(): classes que implementam a interface Observer s√£o noticadas da ocorr√™ncia de eventos externos por meio do m√©todo update(). Mais informa√ß√µes sobre
esse mecanismo de notica√ß√£o podem ser obtidas na Se√ß√£o 3.2.5.
14

Por m, √© requisito do agente que as conrma√ß√µes de emerg√™ncia ocorram de forma ass√≠ncrona, ou seja, deve haver um enleiramento de notica√ß√µes e conrma√ß√µes de emerg√™ncia, n√£o bastando modelar de forma booleana essas informa√ß√µes (emerg√™ncia sinalizada ou n√£o), mas sim quanticadas (rastrear a quantidade de emerg√™ncias sinalizadas).
Anota√ß√µes
Para armazenar a informa√ß√£o da quantidade de emerg√™ncias detectadas, foi criada
a classe estados, n√£o usada pelo c√≥digo, mas t√£o somente pelas anota√ß√µes (vide Se√ß√£o 3.2.7), contendo o atributo qtde_emergencias.
O recebimento das notica√ß√µes das emerg√™ncias, atividade delegada ao update(), √© anotado em fun√ß√£o do tipo (cl√°usula instanceof) de seu par√¢metro arg e deve expressar a possibilidade de atualizar estados.qtde_emergencias:
/*@ @ assigns estados.qtde_emergencias; @ behavior enfileirar_emergencia: @ assumes arg instanceof Emergency; @ ensures estados.qtde_emergencias == \old(estados.qtde_emergencias) @ + 1; @ behavior nao_enfileirar_emergencia: @ assumes ! (arg instanceof Emergency); @ ensures estados.qtde_emergencias == \old(estados.qtde_emergencias); @*/
public void update(Observable o, Object arg) { ... }
Nesta anota√ß√£o, nota-se a especica√ß√£o de dois poss√≠veis comportamentos (uxos) para
este m√©todo: enfileirar_emergencia e nao_enfileirar_emergencia. Esses compor-
tamentos do m√©todo ocorrem, respectivamente, de acordo com o tipo de seu par√¢metro
arg ser Emergency ou n√£o, o que √© representado na cl√°usula assumes (pr√©-condi√ß√£o). A cl√°usula ensures especica o comportamento do enleiramento de mais uma emerg√™ncia,
se for o caso.
Detectadas as emerg√™ncias atrav√©s do m√©todo update(), a inclus√£o de um novo objeto do tipo RequestConfirmationBehaviour na lista de comportamentos que o agente EmergencyAgent deve possuir √© modelada pelo vetor l√≥gico (somente existente nas anota√ß√µes) lista_behaviours e seu controle de tamanho qt_behaviours (vide Se√ß√£o 3.2.2). Essa responsabilidade √© delegada ao m√©todo action():
/*@ @ requires threadFactory != null; @ assigns estados.qtde_emergencias; @ behavior emergencia:
15

@ assumes estados.qtde_emergencias >= 1; @ ensures @ estados.qtde_emergencias == \old(estados.qtde_emergencias) - 1 @ && myAgent.qt_behaviours == \old(myAgent.qt_behaviours) + 1 @ && myAgent.lista_behaviours[\old(myAgent.qt_behaviours)] @ instanceof ThreadedBehaviourWrapper @ && ((ThreadedBehaviourWrapper) @ myAgent.lista_behaviours[\old(myAgent.qt_behaviours)]) @ .myBehaviour instanceof RequestConfirmationBehaviour; @ behavior nenhuma_emergencia: @ assumes estados.qtde_emergencias == 0; @ ensures estados.qtde_emergencias == 0; @*/ public void action() { ... }
Nota-se que √© pr√©-condi√ß√£o para a execu√ß√£o do m√©todo action() que o atributo threadFactory esteja inicializado (threadFactory != null), o que ser√° assegurado pelo m√©todo onStart(). A possibilidade de atribui√ß√£o de estados.qtde_emergencias √© especicada na cl√°usula assigns do contrato. S√£o especicados tamb√©m dois uxos de execu√ß√£o para o m√©todo, emergencia e nenhuma_emergencia, respectivamente sob as pr√©-condi√ß√µes de haver alguma emerg√™ncia enleirada (estados.qtde_emergencias >= 1) ou n√£o (estados.qtde_emergencias == 0).
Finalmente o m√©todo onStart(), respons√°vel pela inicializa√ß√£o do comportamento, deve fazer a aloca√ß√£o do objeto threadFactory:
/*@ @ ensures threadFactory != null; @*/
public void onStart() {
A anota√ß√£o completa da classe MonitorAcuteEmergencyBehaviour pode ser encon-
trada no Ap√™ndice A.1.

3.2.2 Classe Agent

et seq.A classe Agent, componente da API JADE [4, p. 10

], √© uma classe base co-

mum a todo agente que venha a ser denido pelo usu√°rio. No projeto vericado, as classes
EmergencyAgent e ElderlyAgent derivam de Agent e representam os dois principais agentes participantes do sistema. Esses agentes s√£o instanciados e registrados em StartAgent,

componente dos pacotes de carga (inicializa√ß√£o) do sistema, fora de objetivo de verica√ß√£o
(n√£o foram alvo de verica√ß√£o). MonitorAcuteEmergencyBehaviour √© o comportamento vericado, que por sua vez √© registrado para execu√ß√£o por EmergencyAgent em tais pa-

cotes de carga, sendo o fato de sua execu√ß√£o admitida.

16

N√£o obstante, MonitorAcuteEmergencyBehaviour precisa interagir com o agente que o hospeda (EmergencyAgent) para indicar a necessidade de execu√ß√£o de um novo com-
portamento, quando da detec√ß√£o de uma nova emerg√™ncia. Isso √© poss√≠vel atrav√©s de
objeto que MonitorAcuteEmergencyBehaviour possui internamente (myAgent), e do uso do m√©todo addBehaviour() da classe Agent. O objeto myAgent √© acessado atrav√©s de
heran√ßa (vide Se√ß√£o 3.2.6).

Anota√ß√µes

Para representar a lista de comportamentos do agente, modelou-se um vetor, fazendo

model eldsuso do recurso JML

[28, p. 11]. Cabe salientar que essa constru√ß√£o existe

apenas nas anota√ß√µes, n√£o fazendo parte do c√≥digo de fato:

//@ model integer qt_behaviours = 0; //@ model Behaviour [] lista_behaviours;

O vetor de comportamentos lista_behaviours, do tipo Behaviour [] (ou seja, comporta elementos do tipo Behaviour), √© usado para hospedar (na camada l√≥gica) a informa√ß√£o de cada novo comportamento lan√ßado; a vari√°vel qt_behaviours, para contabilizar esse vetor. O m√©todo addBehaviour() √© ent√£o especicado de forma a representar a
adi√ß√£o de um elemento a esse vetor:

/*@ @ requires b instanceof ThreadedBehaviourWrapper; @ ensures qt_behaviours == \old(qt_behaviours) + 1 && @ lista_behaviours[\old(qt_behaviours)] == b; @*/
public void addBehaviour(Behaviour b);

O sistema tem como requisito o lan√ßamento de um novo comportamento com execu√ß√£o
paralela. De acordo com a documenta√ß√£o de JADE, esse efeito √© obtido com o uso de
comportamentos encapsulados por um objeto do tipo ThreadedBehaviourWrapper (Se√ß√£o 3.2.4) e, portanto, √© um pr√©-requisito (cl√°usula requires) que o comportamento seja
desse tipo.

A classe sob estudo apenas lan√ßa comportamentos, mas n√£o os remove do contexto,
portanto o m√©todo removeBehaviour() n√£o foi anotado. Busca-se vericar que os novos
comportamentos tenham sido corretamente iniciados apenas.

AgentA anota√ß√£o completa da classe

pode ser encontrada no Ap√™ndice A.2.

3.2.3 Classes usadas para enleiramento de emerg√™ncias
A classe ConcurrentLinkedQueue e a interface Queue, componentes da API Java
SDK [1], s√£o usadas pelo sistema para enleiramento de emerg√™ncias, por sua vez re-
presentadas pela classe Emergency. Os trechos de c√≥digo em verica√ß√£o apenas usam
17

informa√ß√µes (providas pelos m√©todos da API) referentes ao fato do enleiramento e, portanto, as emerg√™ncias s√£o apenas quanticadas (vide Se√ß√£o 3.4.3).
Essas classes usam programa√ß√£o gen√©rica (vide Se√ß√£o 3.4.2) e, portanto, foram adap-
tadas para trabalhar exclusivamente com emerg√™ncias (classe Emergency), resultando nas classes ConcurrentLinkedQueue_Emergency e Queue_Emergency.

Anota√ß√µes

O c√≥digo cliente faz uso dos m√©todos respons√°veis por incluir e remover emerg√™ncias
da la, respectivamente os m√©todos add() e poll() da interface Queue_Emergency.
O m√©todo add() meramente adiciona uma emerg√™ncia ao contexto:

/*@ @ assigns estados.qtde_emergencias; @ ensures estados.qtde_emergencias == \old(estados.qtde_emergencias) + 1; @*/
boolean add(Emergency e);

add()O c√≥digo cliente despreza o retorno de

, assim o retorno do m√©todo (que √© do

tipo boolean) n√£o foi especicado.

poll()O m√©todo

, por√©m, conforme documenta√ß√£o [1], al√©m de retirar uma emerg√™ncia

nulldo contexto, caso a la esteja vazia, retorna

(indicador de objeto n√£o alocado); caso

contr√°rio, algo diferente de null:

/*@ @ assigns estados.qtde_emergencias; @ behavior fila_com_conteudo: @ assumes estados.qtde_emergencias >= 1; @ ensures \result != null && @ estados.qtde_emergencias == \old(estados.qtde_emergencias) @ - 1; @ behavior fila_vazia: @ assumes estados.qtde_emergencias == 0; @ ensures \result == null && @ estados.qtde_emergencias == \old(estados.qtde_emergencias); @*/
Emergency poll();

Esses dois aspectos do m√©todo est√£o especicados nas anota√ß√µes acima respectivamente
como fila_com_conteudo e fila_vazia.
A anota√ß√£o completa da interface Queue_Emergency encontra-se no Ap√™ndice A.3.

18

3.2.4 Classes usadas para gera√ß√£o de novo comportamento

ThreadedBehaviourFactory √© a classe pertencente √† API JADE [4, p. 29 et seq.]

threadusada para executar comportamentos JADE em uma

Java dedicada. Qualquer

tipo de comportamento JADE (Se√ß√£o 3.2.6) pode ser executado em uma linha de execu√ß√£o
paralela (threaded ) atrav√©s da classe ThreadedBehaviourFactory.

Para operacionalizar a nova linha de execu√ß√£o, o programador deve alocar um novo

objeto do tipo ThreadedBehaviourFactory e passar como par√¢metro para seu m√©todo

wrap() o comportamento JADE que se deseja executar paralelamente. O m√©todo wrap()

ent√£o criar√° e retornar√° um novo objeto do tipo ThreadedBehaviourWrapper. Ao adicio-

Agentnar esse novo objeto √† lista de comportamentos executados por um agente (classe

),

atrav√©s de seu m√©todo addBehaviour(), o framework JADE perceber√° o tipo especial do

comportamento (ThreadedBehaviourWrapper) e dedicar√° uma thread a ele.

Para troca de mensagens entre comportamentos, √© usado o objeto myStore, acessado

atrav√©s de heran√ßa (vide Se√ß√£o 3.2.6). Este objeto √© do tipo DataStore, classe derivada

de HashMap, componente da API Java SDK [1], que prov√™ um par de m√©todos (put()

e get()) para salvar e recuperar as informa√ß√µes armazenadas no objeto myStore. As

hash hashinforma√ß√µes s√£o acessadas atrav√©s de um √≠ndice (

). Assim o

foi modelado como

um vetor, acessado a partir do √≠ndice mediante mapeamento entre o √≠ndice e uma posi√ß√£o

do vetor.

Anota√ß√µes

Para usar o m√©todo wrap() de ThreadedBehaviourFactory, √© necess√°rio (pr√©-condi√ß√£o) que o objeto do tipo Behaviour que esteja sendo passado como par√¢metro tenha sido alocado previamente (seja diferente de null):

/*@ @ requires b != null; @ ensures \result instanceof ThreadedBehaviourWrapper @ && \result != null @ && ((ThreadedBehaviourWrapper)\result).myBehaviour == b; @*/
public Behaviour wrap(Behaviour b);

wrap()Caso essa pr√©-condi√ß√£o seja satisfeita, o comportamento esperado do m√©doto

√©

que ele aloque um novo comportamento em um objeto do tipo ThreadedBehaviourWrapper

e que seu atributo interno myBehaviour aponte para o comportamento fornecido atrav√©s

bdo par√¢metro .

Na API original JADE [4, p. 29], ThreadedBehaviourWrapper √© uma classe interna √† classe ThreadedBehaviourFactory, por√©m, foi criada uma classe exclusiva para acomod√°-
la (vide Se√ß√£o 3.4.4), que teve seu construtor anotado como uma mera atribui√ß√£o ao
atributo interno myBehaviour:

//@ ensures myBehaviour == b;

19

private ThreadedBehaviourWrapper(Behaviour b);

Para os m√©todos put() e get() de HashMap, poder-se-ia conectar as anota√ß√µes JML

et al.com alguma implementa√ß√£o l√≥gica gen√©rica, tal como fez Dross

[15] para o provador

container mapCoq (especica√ß√£o de

do tipo

). Obstando-se a esta abordagem, uma limita-

√ß√£o encontrada no Krakatoa (vide Se√ß√£o 3.4.5) obrigou o uso de uma especica√ß√£o restrita

ao projeto (n√£o gen√©rica, conforme a referida se√ß√£o), estabelecendo correspond√™ncia entre
hasho usado pelo agente e um √≠ndice xo:

//@ model Object [] vetor;

/*@ @ ensures key == RequestConfirmationBehaviour.EVENT_KEY @ ==> vetor[0] == value; @*/
public Object put(Object key, Object value);

/*@ @ ensures key == RequestConfirmationBehaviour.EVENT_KEY @ ==> \result == vetor[0]; @*/
public Object get(Object key);

hashA cada novo

necess√°rio, nessa abordagem, deve-se estender as p√≥s-condi√ß√µes,

incluindo nova tradu√ß√£o entre √≠ndice (par√¢metro key) e posi√ß√£o de vetor.

A anota√ß√£o completa da classe ThreadedBehaviourFactory, bem como das classes ThreadedBehaviourWrapper e HashMap pode ser encontrada nos Ap√™ndices A.4, A.5 e
A.6.

3.2.5 Classes usadas para sinalizar emerg√™ncias
A API Java SDK [1] possui duas classes para implementa√ß√£o de mecanismo de noti-
ca√ß√£o de eventos: Observable e Observer.
Observer √© uma interface que deve ser implementada por classes que desejam
ser informadas sobre modica√ß√µes em objetos observ√°veis (de tipo, ou seja, da classe
Observable). Al√©m disso, classes que implementem essa interface devem tamb√©m implementar o m√©todo update(), que ser√° executado sempre que objetos observados sofrerem
altera√ß√µes.
No sistema, emerg√™ncias s√£o objetos observ√°veis e t√™m seu mecanismo de observa-
√ß√£o codicado dentro da classe DetectEmergencyServiceImpl, derivada de Observable. DetectEmergencyServiceImpl tem seus procedimentos de instancia√ß√£o e registro realizados pela classe StartService. Ambas as classes, componentes dos pacotes de carga do sistema, est√£o fora do objetivo de verica√ß√£o. MonitorAcuteEmergencyBehaviour √© registrado como um observador de emerg√™ncias por DetectEmergencyServiceImpl. Esse

20

processo de cataloga√ß√£o de componentes √© ent√£o admitido, o que implica que as classes do sistema respons√°veis por essas inicializa√ß√£o n√£o foram vericadas, n√£o sendo poss√≠vel armar que tal carga do sistema foi feita corretamente.
MonitorAcuteEmergencyBehaviour, comportamento vericado, por sua vez implementa a interface Observer, o que requer anota√ß√µes referentes ao m√©todo update() de Observer.
Anota√ß√µes
Uma vez que o mecanismo de armazenamento da informa√ß√£o da quantidade de emer-
g√™ncias detectadas envolveu a cria√ß√£o de uma classe dedicada (estados), n√£o usada pelo
c√≥digo, mas t√£o somente pelas anota√ß√µes (vide Se√ß√£o 3.4.3), as anota√ß√µes referentes ao
m√©todo update() concentraram-se na pr√≥pria classe MonitorAcuteEmergencyBehaviour (Se√ß√£o 3.2.1). A interface Observer e a classe Observable n√£o tiveram anota√ß√µes adici-
onais signicantes.
3.2.6 Classes herdadas pelos comportamentos
Os comportamentos de usu√°rio, tal como MonitorAcuteEmergencyBehaviour, s√£o
constru√≠dos atrav√©s da deriva√ß√£o de alguma das classes de comportamento dispon√≠veis na API JADE. Esses comportamentos b√°sicos, por sua vez, derivam da classe abstrata
Behaviour [4, p. 23]. O sistema possui comportamentos derivados das classes JADE CyclicBehaviour e
Behaviour. A propriedade de heran√ßa da orienta√ß√£o a objetos, a qual Java est√° subordinado, garante que m√©todos e atributos declarados dentro da classe b√°sica Behaviour e que estejam com sua cl√°usula de visibilidade marcadas como public ou protected estejam
acess√≠veis √†s classes derivadas, ou seja, aos comportamentos de usu√°rio.
Dos atributos derivados de Behaviour, o sistema manipula direta ou indiretamente (via m√©todos) os objetos internos myAgent e myStore. Este √∫ltimo √© declarado com visibilidade private e, portanto, para ser acessado pelos comportamentos de usu√°rio, necessita de m√©todos getter and setter : getDataStore() e setDataStore(). Por ser atributo protegido, myAgent pode ser acessado diretamente pelas classes derivadas de Behaviour.
ThreadedBehaviourWrapper tamb√©m √© derivada de Behaviour, e √© usada no processo
de gera√ß√£o de novos comportamentos paralelos (Se√ß√£o 3.2.4).
Anota√ß√µes
Um dos construtores de Behaviour armazena a informa√ß√£o do agente instanciador do
comportamento:
/*@ @ requires a != null;
21

@ ensures myAgent == a; @*/ public Behaviour(Agent a);
a√â pr√©-condi√ß√£o que a informa√ß√£o do agente seja v√°lida ( != null). O m√©todo getDataStore(), deve ent√£o retornar o atributo myStore, atributo do tipo DataStore, alocado para troca de informa√ß√µes durante a gera√ß√£o de novo comportamento
(Se√ß√£o 3.2.4):
//@ ensures \result == myStore && myStore != null; public DataStore getDataStore();
Caso o atributo myStore n√£o contenha nenhum objeto, seu conte√∫do ser√° null, o
que indicar√° que ainda n√£o foi alocado e salvo um objeto nesse atributo. Se for esse o
caso, getDataStore() deve alocar e salvar um objeto do tipo DataStore nesse atribuito. O fato de que o objeto retornado por getDataStore() sempre ser√° v√°lido est√° expresso na p√≥s-condi√ß√£o myStore != null, no lado direito da conjun√ß√£o da cl√°usula ensures, e
deve-se a essa propriedade do m√©todo de alocar um novo objeto quando, antes da execu√ß√£o
do m√©todo, myStore n√£o for v√°lido. setDataStore() n√£o possui essa responsabilidade de aloca√ß√£o, bastando apenas a
atribui√ß√£o do objeto parametrizado a myStore.
/*@ @ requires ds != null; @ ensures myStore == ds; @*/
public void setDataStore(DataStore ds);
ds dsSua √∫nica pr√©-condi√ß√£o √© que o par√¢metro recebido ( ) seja v√°lido ( != null). A anota√ß√£o completa da classe base Behaviour encontra-se no Ap√™ndice A.7.

3.2.7 Classe estados

O mecanismo de armazenamento da informa√ß√£o da quantidade de emerg√™ncias neces-
sitou (vide Se√ß√£o 3.4.3) da cria√ß√£o de uma classe dedicada exclusivamente √† acomoda√ß√£o
de um contador de emerg√™ncias (atributo qtde_emergencias).

Essa classe (estados) n√£o √© usada pelo c√≥digo-fonte do projeto em verica√ß√£o, por√©m

√© usada pelas anota√ß√µes para representar o ac√∫mulo ou consumo de emerg√™ncias. Esta

alternativa n√£o impactou a formaliza√ß√£o realizada, pois a classe foi usada em substitui√ß√£o

model eldsao recurso

(Se√ß√µes 3.2.2 e 3.4.3) meramente para acomodar vari√°veis e suas

consequentes mudan√ßas de estados.

defaultAl√©m do atributo, a classe possui um construtor

para garantir a correta inici-

aliza√ß√£o do atributo com valor zero.

22

Anota√ß√µes
O construtor precisa de uma anota√ß√£o para expressar o fato da inicializa√ß√£o:
/*@ @ assigns qtde_emergencias; @ ensures qtde_emergencias == 0; @*/
estados() {
Al√©m do construtor, a classe possui uma invariante que expressa que o atributo, apesar de inteiro, nunca ser√° negativo.
//@ invariant qtde_positiva: qtde_emergencias >= 0;
Essa invariante √© inclusa pelo ambiente de gera√ß√£o de obriga√ß√µes de prova (Krakatoa) automaticamente como p√≥s-condi√ß√£o part√≠cipe de cada teorema que envolva manipula√ß√£o desse atributo (Se√ß√£o 3.3).
A vers√£o completa da classe estados foi inserida no Ap√™ndice A.8.
3.2.8 Outras classes
As classes RequestConfirmationBehaviour e DetectEmergencyService s√£o manipuladas apenas basicamente pela classe principal MonitorAcuteEmergencyBehaviour. Ne-
nhum de seus m√©todos √© acessado de forma que interra no funcionamento da aplica√ß√£o 4. Seus atributos s√£o apenas lidos.
Anota√ß√µes
Assim nenhuma anota√ß√£o signicativa foi feita para essas classes.

3.3 Obriga√ß√µes de provas

softwareCom o c√≥digo-fonte Java anotado (Se√ß√£o 3.2), executou-se o

Krakatoa (Se-

√ß√£o 2.3) para a classe principal:

krakatoa MonitorAcuteEmergencyBehaviour.java

Com a execu√ß√£o acima, o Krakatoa descarregou ent√£o 71 obriga√ß√µes de prova a serem
provadas. O software invoca automaticamente a interface gr√°ca (why3ide) do aplicativo
Why (Se√ß√£o 2.3), a qual centraliza as obriga√ß√µes de prova geradas (Figura 3.1).
4DetectEmergencyService tem o m√©todo register() invocado por onStart(), ou seja, durante o
processo de inicializa√ß√£o, admitido, conforme explanado nas Se√ß√µes 3.2.2 e 3.2.5.
23

Figura 3.1: Tela do why3ide com obriga√ß√µes de prova geradas pelo Krakatoa

Na barra lateral esquerda, aparecem, dentre outros itens, os provadores instalados (interativos e autom√°ticos) e transforma√ß√µes poss√≠veis para objetivos. √Ä medida que se clica em itens do painel central (obriga√ß√µes de prova), os dois pain√©is mais √† direita s√£o atualizados: o inferior (direito), com o c√≥digo-fonte anotado e um realce (amarelo) no trecho da anota√ß√£o referente ao objetivo de prova; o superior (direito), com o teorema a ser provado, codicado em linguagem Why.

Seleciona-se ent√£o um provador no painel esquerdo e o Why transformar√° o teorema

para a linguagem de entrada espec√≠ca do provador, por exemplo, para a linguagem

do provador interativo Coq (Se√ß√£o 2.4). Al√©m disso, nessa opera√ß√£o, o Why invoca o

provador escolhido fornecendo como entrada o arquivo traduzido, abrindo o ambiente de

prova interativo, se for o caso. Caso seja selecionado um provador autom√°tico, a tradu√ß√£o

front-ende disparo ser√£o transparentes, ou seja, n√£o ser√° exibido

do provador, por padr√£o.

Nesta se√ß√£o, algumas obriga√ß√µes de prova ser√£o analisadas, sempre na linguagem do provador interativo Coq (Se√ß√£o 2.4). Ser√° usado o acr√¥nimo OP, em vez da express√£o obriga√ß√£o de prova.

Os arquivos Coq contendo as respectivas OPs s√£o precedidos de pre√¢mbulo contendo

axiomatiza√ß√£o referente ao modelo de mem√≥ria de programas Java, modelagem descrita

et seq. scriptspor March√© [32, p. 12

]. Essa axiomatiza√ß√£o ser√° suprimida dos

apresentados

nesta se√ß√£o, contudo pode ser encontrada no Anexo I.

24

3.3.1 Objetivos de prova principais
Das 71 OPs geradas, 19 apresentaram teoremas n√£o triviais. A Tabela 3.1 exibe um sum√°rio do estado de prova de 16 desses objetivos, onde:
¬à a primeira coluna corresponde ao n√∫mero da prova, para refer√™ncia neste texto; ¬à a segunda coluna cont√©m o nome da OP, gerada pelo Why; ¬à as colunas subsequentes referem-se ao estado da prova em cada provador, podendo
apresentar uma das seguintes informa√ß√µes:
 tempo de verica√ß√£o de uma prova, caso a coluna possua informa√ß√£o num√©rica;  falha na tentativa de prova, caso a coluna possua colora√ß√£o rosa;  objetivo n√£o tentado, caso a coluna possua colora√ß√£o roxa.
Nota-se que o provador autom√°tico CVC3 provou praticamente todos os objetivos, com exce√ß√£o do objetivo #11, que n√£o foi provado por nenhum provador autom√°tico testado. Para esse objetivo de prova, foi necess√°ria a constru√ß√£o de uma prova interativa, com o aux√≠lio do Coq.
Comentam-se a seguir algumas dessas 16 OPs.

OPs #02 a #09

Estes objetivos referem-se √†s anota√ß√µes do m√©todo action() da classe principal (Se-

behavior√ß√£o 3.2.1). Naquela anota√ß√£o, haviam sido especicadas duas se√ß√µes

em JML:

emergencia e nenhuma_emergencia. Como pode-se ver na Tabela 3.1, essas OPs referem-

se √†s anota√ß√µes da se√ß√£o emergencia.

Em verdade, as ferramentas produziram apenas um OP: Method action, Behavior

`emergencia'. N√£o obstante, a interface gr√°ca do Why permite a aplica√ß√£o da trans-

Splitforma√ß√£o

, que basicamente busca conjun√ß√µes na implica√ß√£o nal do teorema a

ser provado, divindo o teorema em tantos outros teoremas quantas forem as conjun√ß√µes

integrantes.

Pela Tabela 3.1 e Figura 3.1, percebe-se ent√£o que aplicou-se uma vez a transfor-
ma√ß√£o √† OP original, produzindo dois novos teoremas (nomeados ambos de normal postcondition) e, em cada um desses novos teoremas, aplicou-se novamente a trans-
forma√ß√£o o que produziu dois conjuntos de quatro novos teoremas, dessa vez, numerados pela ferramenta.
Method action, Behavior `emergencia', a OP produzida originalmente pela fer-
ramenta, n√£o p√¥de ser provada diretamente por nenhum provador autom√°tico. Ap√≥s as transforma√ß√µes, o provador CVC3 provou os oito teoremas.
tacticalPara a prova no Coq, a transforma√ß√£o tem pouco efeito, pois um simples uso do  repeat split; intros gera os oito subgoals correspondentes √†s OPs transformadas.
O √∫nico efeito pr√°tico foi a gera√ß√£o de oito arquivos Coq separados, cada um para sua respectiva OP.

25

CVC3 Coq Eprover Spass

# Proof obligations

01 Method action, default behavior

0.22 1.51

Method action, Behavior `emergencia'

normal postcondition

02 1

0.18 1.44

03 2

0.17 1.69

04 3

0.17 1.74

05 4

0.18 1.73

normal postcondition

06 1

0.14 1.76

07 2

5.11 1.83

08 3

5.34 1.98

09 4

5.23 1.70

10 Method action, Behavior `nenhuma_emergencia' 0.15 2.08

11 normal postcondition

1.63

12 Method onStart, Safety

0.11

13 Method update, default behavior

0.11

14 Method update, Behavior `enleirar_emergencia' 0.12 1.49

15 normal postcondition

0.11 1.51

16 downcast

0.09 1.54

Tabela 3.1: Objetivos de prova principais

OP #06

introsA OP #06, ap√≥s a aplica√ß√£o da t√°tica

(introdu√ß√£o das implica√ß√µes e quanti-

cadores universais), apresenta o seguinte formato:

Theorem WP_parameter_..._action_ensures_emergencia :
... ... (SUPRIMIDO) ... 1 subgoal this_8 : pointer usObject estados_qtde_emergencias1 : int32 usMonitorAcuteEmergencyBehaviour_threadFactory1 : memory usObject
(pointer usObject) usObject_alloc_table1 : alloc_table usObject H : 1 <= integer_of_int32 estados_qtde_emergencias1 /\
valid_struct_Object this_8 0 0 usObject_alloc_table1 /\ usNon_null_Object
(select usMonitorAcuteEmergencyBehaviour_threadFactory1 this_8)

26

usObject_alloc_table1 estados_qtde_emergencias2 : int32 result : pointer usObject H0 : (integer_of_int32 estados_qtde_emergencias1 = 0 ->
result = (null:pointer usObject) /\ integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1) /\ (1 <= integer_of_int32 estados_qtde_emergencias1 -> usNon_null_Object result usObject_alloc_table1 /\ integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1 - 1) result1 : bool H1 : result1 = true /\ offset_max usObject_alloc_table1 result = 0 \/ result1 <> true /\ result = (null:pointer usObject) H2 : result1 <> true ______________________________________(1/1) integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1 - 1
Essa OP origina-se de uma das proposi√ß√µes integrantes da cl√°usula ensures (p√≥scondi√ß√£o) do referido m√©todo action():
estados.qtde_emergencias == \old(estados.qtde_emergencias) - 1

Nota-se que os diversos estados das vari√°veis s√£o traduzidos para o Coq como diferentes vari√°veis, numeradas de acordo com o uxo do c√≥digo imperativo. Em especial:
¬à \old(estados.qtde_emergencias) (conte√∫do da vari√°vel imediatamente antes da chamada ao m√©todo) foi traduzido como estados_qtde_emergencias1;
¬à estados.qtde_emergencias (conte√∫do da vari√°vel imediatamente ap√≥s o encerramento do m√©todo), como estados_qtde_emergencias2.

Al√©m disso, o contexto (premissas) de prova foi produzido tendo como base um c√°lculo da pr√©-condi√ß√£o mais fraca (Se√ß√£o 2.1) implementado pela ferramentas. Para tanto, a ferramenta considerou:
¬à o c√≥digo-fonte Java do m√©todo (Ap√™ndice A.1); ¬à as anota√ß√µes JML feitas para cada uma das depend√™ncias funcionais desse c√≥digo
imperativo (em especial, Queue_Emergency.poll()); ¬à al√©m das pr√©-condi√ß√µes JML especicadas para o pr√≥prio m√©todo action().

Ap√≥s examinar o contexto, nota-se que manipula√ß√µes simples envolvendo as conjun√ß√µes

scriptcontidas nas hip√≥teses H0 e H conduzem √† prova do teorema. O

Coq de constru√ß√£o

da prova reete essas observa√ß√µes:

27

Proof. intros. elim H0; clear H0; intros. elim H3; clear H3; intros. assumption.
elim H; clear H; intros. assumption. Qed.
OP #07
A OP #07, ap√≥s a aplica√ß√£o da t√°tica intros:
Theorem WP_parameter__MonitorAcuteEmergencyBehaviour_action_ensures_emergencia :
... ... (SUPRIMIDO) ... 1 subgoal this_8 : pointer usObject estados_qtde_emergencias1 : int32 usMonitorAcuteEmergencyBehaviour_threadFactory1 : memory usObject
(pointer usObject) usBehaviour_myAgent1 : memory usObject (pointer usObject) usAgent_qt_behaviours1 : memory usObject Z usObject_alloc_table1 : alloc_table usObject H : 1 <= integer_of_int32 estados_qtde_emergencias1 /\
valid_struct_Object this_8 0 0 usObject_alloc_table1 /\ usNon_null_Object
(select usMonitorAcuteEmergencyBehaviour_threadFactory1 this_8) usObject_alloc_table1 estados_qtde_emergencias2 : int32 result : pointer usObject H0 : (integer_of_int32 estados_qtde_emergencias1 = 0 -> result = (null:pointer usObject) /\ integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1) /\ (1 <= integer_of_int32 estados_qtde_emergencias1 -> usNon_null_Object result usObject_alloc_table1 /\ integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1 - 1) result1 : bool H1 : result1 = true /\ offset_max usObject_alloc_table1 result = 0 \/ result1 <> true /\ result = (null:pointer usObject) H2 : result1 <> true
28

______________________________________(1/1) select usAgent_qt_behaviours1 (select usBehaviour_myAgent1 this_8) = select usAgent_qt_behaviours1 (select usBehaviour_myAgent1 this_8) + 1
A OP adv√©m de outra parte da p√≥s-condi√ß√£o do m√©todo action():
myAgent.qt_behaviours == \old(myAgent.qt_behaviours) + 1

Dessa vez, a vari√°vel deve ser acessada atrav√©s de um atributo interno (myAgent) √†

classe Behaviour. Esse atributo √© alocado dinamicamente, portanto o acesso √†s vari√°veis

selectenvolvidas n√£o √© mais direto, mas sim representado pelo uso da fun√ß√£o

, pertencente

√† axiomatiza√ß√£o citada (Anexo I).

Por√©m, nota-se que H0 √© proveniente da extra√ß√£o das anota√ß√µes do m√©todo poll() 5

if(Ap√™ndice A.3). Al√©m disso, H1 representa as possibilidades do comando

constante

do corpo de action():

public void action() { Emergency emergency = emergencies.poll(); if (emergency != null) {
... ...
} }

Note que result1 (em H1) √© booleano que equivale exatamente √† express√£o emergency != null. Por H2, percebe-se que essa OP corresponde √† extra√ß√£o de comportamento em que o if falha: result1 <> true, ou result1 = false, ou emergency = null.
Al√©m disso, em H0, result representa exatamente o retorno do m√©todo poll() que, no c√≥digo acima, √© armazenado em emergency.
Por outro lado, percebe-se pelas anota√ß√µes de action() que a se√ß√£o behavior emergencia tem como pr√©-condi√ß√£o (cl√°usula assumes) que estados.qtde_emergencias >= 1, o resultado de poll() deveria conduzir a emergency != null.
De fato, em H0, a asser√ß√£o usNon_null_Object result usObject_alloc_table1
ratica a contradi√ß√£o no contexto, ou seja, um uxo imperativo que n√£o ocorre nessas
condi√ß√µes de estado das vari√°veis envolvidas.

Voltando a aten√ß√£o novamente para o objetivo, constata-se que seria imposs√≠vel cons-

truir uma prova direta, pois implicaria no seguinte teorema ser provado (note o formato

do objetivo do teorema):

forall x:Z, x = x + 1

scriptO Coq de constru√ß√£o da prova trabalha em busca de recompor no ambiente do
provador essas contradi√ß√µes, fechando a OP:
5poll() √© m√©todo usado no corpo do m√©todo action()

29

Proof. intros. elim H1; clear H1; intros. elim H1; clear H1; intros. contradiction.
elim H1; clear H1; intros. elim H0; clear H0; intros. elim H4; clear H4; intros.
unfold usNon_null_Object in H4. rewrite H3 in H4. generalize null_pointer; intros. elim (H6 usObject usObject_alloc_table1); clear H6; intros. generalize
(Zle_trans 0 (offset_max usObject_alloc_table1 null) (- (2)) H4 H7); intros. info auto with zarith.
elim H; clear H; intros. assumption. Qed.

OP #10

√Ä OP #10, assim como a todas as outras OPs, n√£o √© aplicada nenhuma transforma√ß√£o

SplitWhy (tal como a transforma√ß√£o

mencionada anteriormente). Essa OP √© denomi-

nada pela ferramenta Method action, Behavior `nenhuma_emergencia', pois refere-se

√†s anota√ß√µes do m√©todo action(), behavior (se√ß√£o da anota√ß√£o JML) nenhuma_emergencia.

Ap√≥s a aplica√ß√£o da t√°tica intros e repeat split; intros, o teorema apresenta dois
subobjetivos, dos quais reproduz-se apenas parte do contexto do primeiro subobjetivo:

Theorem WP_parameter__..._action_ensures_nenhuma_emergencia :
... ... (SUPRIMIDO) ... 2 subgoals ... ... (SUPRIMIDO) ... H : integer_of_int32 estados_qtde_emergencias1 = 0 /\
valid_struct_Object this_8 0 0 usObject_alloc_table1 /\ usNon_null_Object
(select usMonitorAcuteEmergencyBehaviour_threadFactory1 this_8) usObject_alloc_table1

30

estados_qtde_emergencias2 : int32 result : pointer usObject H0 : (integer_of_int32 estados_qtde_emergencias1 = 0 ->
result = (null:pointer usObject) /\ integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1) /\ (1 <= integer_of_int32 estados_qtde_emergencias1 -> usNon_null_Object result usObject_alloc_table1 /\ integer_of_int32 estados_qtde_emergencias2 = integer_of_int32 estados_qtde_emergencias1 - 1) result1 : bool H1 : result1 = true /\ offset_max usObject_alloc_table1 result = 0 \/ result1 <> true /\ result = (null:pointer usObject) H2 : result1 = true ... ... (SUPRIMIDO) ... H5 : usRequestConfirmationBehaviour_EVENT_KEY = usRequestConfirmationBehaviour_EVENT_KEY -> select usObjectM_ObjectP1 (shift (select usHashMap_vetor1 result3) 0) = result ... ... (SUPRIMIDO) ... ______________________________________(1/2) integer_of_int32 estados_qtde_emergencias2 = 0

______________________________________(2/2) integer_of_int32 estados_qtde_emergencias2 = 0

A OP prov√©m do √∫nico predicado constante da p√≥s-condi√ß√£o dessa se√ß√£o de anota√ß√£o

do m√©todo:

estados.qtde_emergencias == 0

ifOs dois subobjetivos referem-se aos uxos poss√≠veis do comando constante do corpo de action(): o primeiro subobjetivo, por H2 (result1 = true), indica o caso then; e o segundo subobjetivo possui hip√≥tese que indica (result1 <> true) o caso else.

Nos dois casos, n√£o h√° a necessidade de recorrer a axiomas ou lemas do prel√∫dio

script(teoria carregada dentro do

pelas ferramentas). O aproveitamento de simples fatos

(hip√≥teses) do contexto, como H e H0, permite a prova dos subobjetivos, o que pode ser
visto no script de constru√ß√£o da prova:

Proof. intros. repeat split; intros.

31

elim H; clear H; intros. elim H0; clear H0; intros. elim H0; clear H0; intros.
rewrite H10. assumption.
assumption.
elim H; clear H; intros. elim H0; clear H0; intros. elim H0; clear H0; intros.
rewrite H5. assumption.
assumption. Qed.
OP #11
A OP #11 n√£o p√¥de ser fechada por nenhum provador autom√°tico, tendo sido mandat√≥ria a constru√ß√£o de uma prova interativa, no caso, com o Coq.
Esta OP foi denominada pela ferramenta normal postcondition, nome padr√£o, uma vez que refere-se ao m√©todo onStart(), o qual n√£o foi especicado com as cl√°usulas behavior, dessa forma, n√£o possuindo uma se√ß√£o nomeada na anota√ß√£o.
Ap√≥s a aplica√ß√£o da t√°tica intuition, o teorema apresenta um √∫nico objetivo:
Theorem WP_parameter__MonitorAcuteEmergencyBehaviour_onStart_ensures_default :
... ... (SUPRIMIDO) ... 1 subgoal this_16 : pointer usObject usMonitorAcuteEmergencyBehaviour_threadFactory1 : memory usObject
(pointer usObject) usObject_alloc_table1 : alloc_table usObject H : valid_struct_Object this_16 0 0 usObject_alloc_table1 usObject_tag_table1 : tag_table usObject usObject_alloc_table2 : alloc_table usObject result : pointer usObject H1 : strict_valid_struct_Object result 0 (1 - 1) usObject_alloc_table2 H0 : alloc_extends usObject_alloc_table1 usObject_alloc_table2 H2 : alloc_fresh usObject_alloc_table1 result 1 H4 : instanceof usObject_tag_table1 result usThreadedBehaviourFactory_tag usMonitorAcuteEmergencyBehaviour_threadFactory2 : memory usObject
32

(pointer usObject) H3 : usMonitorAcuteEmergencyBehaviour_threadFactory2 =
store usMonitorAcuteEmergencyBehaviour_threadFactory1 this_16 result ______________________________________(1/1) usNon_null_Object
(select usMonitorAcuteEmergencyBehaviour_threadFactory2 this_16) usObject_alloc_table2
Esse objetivo concerne √† √∫nica p√≥s-condi√ß√£o do m√©todo onStart():
ensures threadFactory != null

Para a consecu√ß√£o da prova, √© importante notar um dos fatos inclusos pela axiomatiza√ß√£o a cerca de armazenamento e recupera√ß√£o de informa√ß√£o din√¢mica (ponteiros):

Axiom select_store_eq : forall (t:Type) (v:Type), forall (m:(memory t v)), forall (p1:(pointer t)), forall (p2:(pointer t)), forall (a:v), (p1 = p2) -> ((select (store m p1 a) p2) = a).

p1 p2Esse axioma deve assim ser interpretado: se dois ponteiros e s√£o iguais, ent√£o,

caso seja armazenado (store) algum valor a dentro da regi√£o de mem√≥ria m na posi√ß√£o p1

selecte, posteriormente, caso seja recuperado (

) o valor armazenado nesta mesma regi√£o

m p2 p1de mem√≥ria na posi√ß√£o (igual a , por hip√≥tese), o valor recuperado ser√° o pr√≥prio

avalor , armazenado inicialmente.

Al√©m disso, observa-se que H3 representa modica√ß√£o do estado de threadFactory
(vari√°vel presente no c√≥digo-fonte imperativo). Percebendo-se que esse armazenamento
ocorre na mesma posi√ß√£o (this_16) em que o objetivo recupera a informa√ß√£o, pode-se
rescrever H3 no objetivo e aplicar o teorema, simplicando-o para:

usNon_null_Object result usObject_alloc_table2

Para a prova deste objetivo, tem-se que expandir (unfold em Coq) as deni√ß√µes de strict_valid_struct_Object (veja hip√≥tese H1) e usNon_null_Object (objetivo),
tamb√©m constantes da axiomatiza√ß√£o.
Por m, a aplica√ß√£o do axioma select_store_eq gerou um segundo subobjetivo, o
qual exige que se mostre que as posi√ß√µes envolvidas (ponteiros) s√£o iguais, ou seja, que
this_16 = this_16, resolvido de maneira trivial.
scriptO de constru√ß√£o da prova reete essas observa√ß√µes:
Proof. intuition. subst usMonitorAcuteEmergencyBehaviour_threadFactory2. simpl in H1. rewrite select_store_eq. unfold strict_valid_struct_Object in H1.

33

unfold usNon_null_Object. elim H1; clear H1; intros. rewrite H3. auto with zarith.
trivial. Qed.

OP #16

As ferramentas envolvidas tamb√©m geram OPs referentes √† seguran√ßa dos m√©todos.

downcastUma delas (OP #16) refere-se √† seguran√ßa da opera√ß√£o Java denominada

.

downcastA opera√ß√£o de

√© descrita formalmente por Pierce [37, p. 215] como um

ascription, ou seja, uma convers√£o entre tipos relacionados dentro de uma hierarquia de

subtipos 6. Pierce atenta ainda para o fato de que os downcasts, em oposi√ß√£o aos upcasts,

representam a convers√£o de um tipo para um subtipo seu, o que n√£o necessariamente

sucede e, por isso, em seu formalismo (assim como em Java), n√£o s√£o vericados estaticamente, necessitando uma verica√ß√£o de tipos em tempo de execu√ß√£o 7.

A OP #16, de fato nomeada downcast pela ferramenta, ap√≥s aplica√ß√£o da t√°tica intros, apresenta-se como abaixo:

Theorem WP_parameter__MonitorAcuteEmergencyBehaviour_update_safety :
... ... (SUPRIMIDO) ... 1 subgoal this_4 : pointer usObject o_0 : pointer usObject arg_0 : pointer usObject usObject_tag_table1 : tag_table usObject usObject_alloc_table1 : alloc_table usObject H : left_valid_struct_Object arg_0 0 usObject_alloc_table1 /\
left_valid_struct_Object o_0 0 usObject_alloc_table1 /\ valid_struct_Object this_4 0 0 usObject_alloc_table1 result : bool H0 :result = true /\ instanceof usObject_tag_table1 arg_0 usEmergency_tag \/ result <> true /\ ~instanceof usObject_tag_table1 arg_0 usEmergency_tag

heran√ßa6Em Java, esta hieraquia refere-se ao relacionamento de

(deriva√ß√£o) entre as classes, onde

pelo menos duas classes s√£o part√≠cipes: superclasse e subclasse, respectivamente, tipo e subtipo.

Java Virtual Machine7Em Java, essa verica√ß√£o em tempo de execu√ß√£o √© feita pela JVM (

). Analoga-

downcasts evaluationmente, no formalismo de Pierce, os

s√£o tratados por regras de

(an√°lise din√¢mica),

n√£o sendo, dessa forma, tratados pelas regras de tipagem (an√°lise est√°tica).

34

H1 : result = true ______________________________________(1/1) instanceof usObject_tag_table1 arg_0 usEmergency_tag

Esse objetivo, como outros objetivos gerados automaticamente pela ferramenta e rotu-

safetylados com suxo

, n√£o se refere a uma anota√ß√£o, mas sim √† verica√ß√£o da seguran√ßa

do downcast (ascribe) feito dentro do m√©todo update():

public void update(Observable o, Object arg) { if (arg instanceof Emergency) { emergencies.add((Emergency) arg); }
}

No caso, a convers√£o sendo vericada √© (Emergency) arg, ou seja, a convers√£o do argumento arg do tipo Object (superclasse) para o tipo Emergency (subclasse).

A prova desse objetivo decorre do fato de a convers√£o estar corretamente protegida

if argdentro do comando que, justamente, testa, antes de executar a convers√£o, se

√© de

fato um objeto (inst√¢ncia) da classe Emergency.

Al√©m disso, a prova trabalha no sentido de aproveitar a informa√ß√£o extra√≠da do co-

if ifmando

(hip√≥tese H0) e da premissa de que o teste ocorre quando o

sucede (caso

then, reexo na hip√≥tese H1).

scriptAssim, o

de constru√ß√£o da prova elimina a disjun√ß√£o de H0 gerando os dois ca-

sos do if: no caso then, o fato vir√° do contexto; no caso else, haver√° uma contradi√ß√£o

no contexto.

Proof. intros. elim H0; clear H0; intros. elim H0; clear H0; intros. assumption.
elim H0; clear H0; intros. contradiction. Qed.

3.3.2 Objetivos triviais
Ainda, do total de 71 obriga√ß√µes de prova, 52 eram objetivos triviais, tais como simples tautologias. Para esses objetivos, empregou-se exclusivamente provadores autom√°ticos; no caso, o CVC3.

35

Esses objetivos encontram-se sumarizados nas Tabelas 3.2 e 3.3. Nestas e nas pr√≥ximas

tabelas, onde se l√™ CC, entenda-se como Constructor of class, ou seja, objetivos de

defaultprova gerados para construtores

das classes envolvidas.

3.3.3 Objetivos n√£o provados

Tr√™s OPs, relacionadas na Tabela 3.4, n√£o foram provadas.

As OPs #01 e #02 foram geradas indevidamente pelas ferramentas devido ao problema descrito na Se√ß√£o 3.4.7.

A terceira OP refere-se √† seguran√ßa do m√©todo action(). Como explanado na Se-

√ß√£o 3.2.1, onStart() e action() s√£o m√©todos abstratos denidos na classe Behavi-

our, da qual todos os comportamentos de usu√°rio derivam, inclusive a classe principal

(MonitorAcuteEmergencyBehaviour). Pelo fato de serem abstratos, a implementa√ß√£o

Behaviourdesses m√©todos ca a cargo das classes que derivam de

.

Al√©m disso, o framework

Jade responsabiliza-se por disparar em tempo de execu√ß√£o o m√©todo onStart() antes

que qualquer chamada ao m√©todo action() ocorra.

A OP #03 carece justamente de que seja expressado esse fato que ocorre em tempo

de execu√ß√£o, de forma que a informa√ß√£o esteja dispon√≠vel em tempo de prova: todo novo

Behaviourobjeto derivado de

instanciado ter√° seu m√©todo de aloca√ß√£o invocado antes de

seu m√©todo de a√ß√£o.

JML permite que os contratos contenham anota√ß√µes referentes a execu√ß√£o de m√©todos [28, p. 6] [11, p. 5], por√©m o Krakatoa usa uma vers√£o modicada de JML 8 que n√£o
permite expressar chamadas a construtores ou m√©todos [33, p. 23] [32, p. 11].

Uma alternativa para contornar a aus√™ncia do construto que expresse encadeamento entre m√©todos ainda n√£o havia sido encontrada pelo autor deste estudo no momento da confec√ß√£o desta disserta√ß√£o.

3.4 Feedback do uso das ferramentas

Durante a constru√ß√£o das especica√ß√µes JML (Se√ß√£o 3.2) e das obriga√ß√µes de provas (Se√ß√£o 3.3), algumas quest√µes surgiram como pontos de aten√ß√£o ou, at√© mesmo, levando a alguma adequa√ß√£o na estrat√©gia de anota√ß√£o ou prova. Documentam-se aqui estas quest√µes.

3.4.1 Workspace Java
Projetos Java com um grande n√∫mero de classes/arquivos fazem uso de uma hierarquia de pastas, dividindo o projeto em agrupamentos de acordo com a modelagem de progra-
8A vers√£o de JML usada pelo Krakatoa, por vezes, √© denominada em sua documenta√ß√£o de KML.

36

ma√ß√£o empregada. Essa estrutura de pastas, com seus respectivos arquivos, √© denominada
workspace pelas ferramentas de desenvolvimento Java.

O sistema objeto do estudo de caso do presente trabalho n√£o √© diferente: al√©m dos 109

workspacearquivos .java, h√° 61 diret√≥rios no

somente para acomodar o c√≥digo-fonte.

Workspaces Java, al√©m de serem usados pelos programadores como estrutura orga-

nizacional de projeto, tamb√©m evitam colis√£o entre nomes de diferentes vers√µes de uma

mesma classe 9. No caso em estudo, apesar de as classes selecionadas para especica√ß√£o

workspacen√£o terem mais de uma vers√£o, diversas outras classes do

possuem coincid√™ncia

de nomes 10.

Assim, a primeira tentativa de verica√ß√£o das propriedades especicadas manteve os arquivos em sua estrutura original. Obstando-se a essa alternativa, encontrou-se um mau
funcionamento no processamento das diretivas package e import 11, presentes, como era
de se esperar, no c√≥digo-fonte do projeto.
O sistema possui duas classes interdependentes: Behaviour e Agent. Assim, uma
importa a outra.

Apesar de essa ser uma constru√ß√£o v√°lida em Java, o Krakatoa entra em um ciclo innito ao tentar processar essa depend√™ncia. Em verdade, um simples caso de teste como o abaixo reproduz essa situa√ß√£o:

1. crie os diret√≥rios p1 e p2;
2. dentro do diret√≥rio p1, crie o arquivo Classe1.java com o seguinte conte√∫do:
package p1; import p2.Classe2; public class Classe1 {}
3. dentro do diret√≥rio p2, crie o arquivo Classe2.java com o seguinte conte√∫do:
package p2; import p1.Classe1; public class Classe2 {}
4. execute, por exemplo, krakatoa p1/Classe1.java;
5. interrompa a execu√ß√£o (innita) e inspecione o arquivo de log (krakatoa.log):
9Essas diferentes vers√µes de uma mesma classe n√£o se referem a diferentes est√°gios do processo de
desenvolvimento de uma classe, mas sim a diferentes vis√µes de uma mesma classe dentro do projeto, ou seja, diferentes coloca√ß√µes funcionais, o que se considera uma forma de polimorsmo.
10No sistema estudado, apesar de haver 109 arquivos .java, h√° somente 79 nomes de arquivos .java,
caso descontem-se as repeti√ß√µes de nomes. GetNameBean.java e GreetingAction.java s√£o exemplos de
coincid√™ncias de nomes de classes.
11As diretivas package e import s√£o usadas para sinalizar ao compilador Java (javac), respectivamente,
onde os arquivos das classes ser√£o encontrados e quais as depend√™ncias interclasses [2].

37

... ... ... adding java file Classe1 (fullname ./p1/Classe1.java) importing package java.lang importing p2.Classe2 importing package java.lang importing p1.Classe1 importing package java.lang importing p2.Classe2 importing package java.lang importing p1.Classe1 importing package java.lang importing p2.Classe2 importing package java.lang importing p1.Classe1 importing package java.lang importing p2.Classe2 ... ... ...

O contorno usado para continuar a a√ß√£o de verica√ß√£o foi desativar as diretrizes
package e import no c√≥digo-fonte (envolvendo-as com coment√°rios) e manter todos
os arquivos do projeto (usados na verica√ß√£o) em um √∫nico diret√≥rio. Como n√£o houve
colis√£o entre os nomes das classes envolvidas, a estrat√©gia sucedeu.

3.4.2 Programa√ß√£o gen√©rica

genericsUma das constru√ß√µes suportadas pela linguagem Java √© denominada

ou pro-

grama√ß√£o gen√©rica [2]. Basicamente a constru√ß√£o permite que, na deni√ß√£o de uma

classe, seja inclu√≠do um par√¢metro que represente um tipo. A inten√ß√£o √© que seja poss√≠-
vel declarar uma classe como Classe<T>, em que T √© um par√¢metro que ser√° usado no

corpo da classe onde normalmente s√£o inseridos tipos; posteriormente, instancia√ß√µes como
Classe<bool> c ou Classe<int> c, possibilitar√£o que Classe comporte-se exatamente Tcomo declarada, a menos das respectivas substitui√ß√µes, nesses exemplos, == bool ou T == int.

et seq.Este tipo de comportamento polim√≥rco √© formalizado por Pierce [37, p. 361

],

que o denomina polimorsmo param√©trico. A formaliza√ß√£o ali apresentada tenciona

a inclus√£o de universal types, resultando em um sistema tradicionalmente denominado

System F.

O caso em estudo faz uso da interface Queue e da classe ConcurrentLinkedQueue, declarados respectivamente como Queue<E> e ConcurrentLinkedQueue<E>. Assim, fazem
uso da programa√ß√£o gen√©rica Java.

38

Por outro lado, Krakatoa n√£o suporta programa√ß√£o gen√©rica Java [32, p. 16].
A solu√ß√£o dada para criar um ambiente de anota√ß√£o para estas classes sem interferir em
seu comportamento foi a de operar o polimorsmo manualmente, ou seja, criar arquivos
Ecom o c√≥digo original replicado, substituindo manualmente o par√¢metro pelos tipos de
fato usados no c√≥digo. Para cada tipo usado, ter-se-ia que criar um arquivo, por√©m a
classe principal selecionada para verica√ß√£o instancia-os apenas com o tipo Emergency.
Dessa forma, Queue_Emergency e ConcurrentLinkedQueue_Emergency foram criadas, Eonde cada ocorr√™ncia do par√¢metro , constante dos arquivos originais, foi substitu√≠da pelo tipo (classe) Emergency.

3.4.3 Model elds

Por vezes, o processo de anota√ß√£o requer a modelagem de alguma estrutura de da-

model eldsdos espec√≠ca. JML prov√™ um mecanismo de anota√ß√£o denominado

, o qual

possibilita criar vari√°veis existentes apenas no escopo das anota√ß√µes, de forma que esses

et seq.campos n√£o podem ser acessados pelo c√≥digo Java [28, p. 11

].

Esse mecanismo pode ser usado para prover abstra√ß√µes do estado concreto de um objeto, onde cada abstra√ß√£o pode denotar diferentes aspectos de um mesmo objeto [11, p. 10].

Esse tipo de constru√ß√£o foi usado em dois pontos das anota√ß√µes:

¬à para a classe Agent, quando foi usada para modelar um vetor de comportamentos
e manter atualizada a informa√ß√£o sobre o tamanho do vetor:

//@ model integer qt_behaviours = 0; //@ model Behaviour [] lista_behaviours;

¬à para a classe HashMap, onde foi empregada para especicar um vetor que acomoda objetos de qualquer tipo (classe Object 12):

//@ model Object [] vetor;

model eldsTentou-se tamb√©m usar

para abstrair uma la de dados, intentando cons-

truir uma anota√ß√£o gen√©rica para a interface Queue_Emergency, como as anota√ß√µes em

Agent e HashMap. Por√©m, ao tentar gerar as obriga√ß√µes de prova, a ferramenta apresentou

um mau funcionamento:

File "java/java_typing.ml", line 1109, characters 8-8: Fatal error: exception Assert_failure("java/java_typing.ml", 1109, 8)

Esse erro refere-se a uma exce√ß√£o inserida dentro do c√≥digo-fonte do Krakatoa/Why,
especicamente no arquivo java_typing.ml, conforme excerto do c√≥digo original (escrito
em Objective Caml) abaixo:

Object12Em Java, a classe

√© a superclasse de todas as classes [2]. Pierce formalizou essa no√ß√£o atrav√©s

Topda constante

como o elemento m√°ximo da rela√ß√£o de subtipo [37, p. 185].

39

1093 and type_term_field_access t loc id =

1094 match t.java_term_type with

1095 | JTYclass(_,c) ->

...

... (SUPRIMIDO)

...

1108 | JTYinterface _ii ->

1109

assert false (* TODO *)

1110 | JTYarray _ ->

...

... (SUPRIMIDO)

...

1120 | JTYnull | JTYbase _ | JTYlogic _ ->

Analisando a linha mencionada (1109), constata-se que faz parte do mecanismo do

eldsKrakatoa de tipagem de termos Java durante acesso a campos (

). Al√©m disso, a

referida linha √© executada quando o termo Java for do tipo interface e, de fato, h√° uma

asser√ß√£o gerando uma falha com um coment√°rio 13 indicando que esse trecho ainda n√£o

foi totalmente desenvolvido.

Abaixo o conte√∫do do arquivo C.java que, ap√≥s executado com krakatoa C.java,
reproduz o problema:

interface I { /*@ model int a; @*/ }

public class C implements I { }

model eldsEnt√£o, como o recurso (

) n√£o se encontrava dispon√≠vel para uso com

interfaces, al√©m de n√£o se intentar fazer manipula√ß√µes do c√≥digo-fonte original que

mudassem seu comportamento, optou-se por criar uma nova classe, a qual serviu mera-

mente para acomodar vari√°veis de estado a serem usadas nas anota√ß√µes, portanto n√£o

sendo referenciada pelo sistema em verica√ß√£o.

Dessarte simulou-se a funcionalidade model elds para interfaces atrav√©s da classe estados (Se√ß√£o 3.2.7).

3.4.4 Classes internas

A linguagem Java permite a deni√ß√£o de uma classe dentro de outra, contru√ß√£o de-
nominada de classe interna (ou classe aninhada). Esse recurso √© usado para agrupar logicamente classes em um √∫nico arquivo, aumentando o encapsulamento 14 [2]. Declara-
√ß√µes desse tipo ocorrem com estruturas an√°logas √† que segue:

TODO13O coment√°rio em quest√£o √©

comumente usado por programadores de l√≠ngua inglesa para indicar

um afazer, isto √©, algo ainda a ser programado.
14Encapsulamento, conceito existente em linguagens orientadas a objeto, refere-se a ocultar os estados

internos (vari√°veis) de objetos (inst√¢ncias de classes) e requerer que toda a intera√ß√£o com esses objetos

seja realizada atrav√©s de m√©todos, que, por sua vez, far√£o a devida atualiza√ß√£o desses estados [2].

40

class ClasseExterna { ... class ClasseInterna { ... }
}
O sistema faz uso da classe ThreadedBehaviourFactory, integrante da API JADE,
para gera√ß√£o de novos comportamentos (Se√ß√£o 3.2.4). Essa classe dene tamb√©m a classe
interna ThreadedBehaviourWrapper.
Realizadas as anota√ß√µes no c√≥digo original (ThreadedBehaviourFactory.java), execu-
tou-se o Krakatoa para gerar as obriga√ß√µes de prova, por√©m a ferramenta n√£o reconheceu a declara√ß√£o da classe interna:
File "./ThreadedBehaviourFactory.java", line 95, characters 39-63: typing error: unknown identifier ThreadedBehaviourWrapper
Sendo a classe interna necess√°ria √†s anota√ß√µes (Se√ß√£o 3.2.4), contornou-se a situa√ß√£o
movendo-a para um arquivo dedicado (ThreadedBehaviourWrapper.java), tornando-a
uma classe convencional, suscet√≠vel ent√£o √† valida√ß√£o sint√°tica do Krakatoa.

3.4.5 Teorias e constru√ß√µes adicionais

A especica√ß√£o original de JML prev√™ determinadas extens√µes para que seja poss√≠vel

especicar tipos de dados abstratos em anota√ß√µes. A cl√°usula represents, que permite

model eldscriar fun√ß√µes envolvendo

15 (Se√ß√£o 3.4.3), e a possibilidade de usar m√©todos

em anota√ß√µes v√£o ao encontro desse objetivo [11, p. 10].

Em Krakatoa, tais recursos foram preteridos em lugar da possibilidade de declarar no-

vos predicados e fun√ß√µes l√≥gicas. O guia de refer√™ncia da ferramenta [33, p. 30] cita a pos-

sibilidade dessas e outras extens√µes de modelagem avan√ßada, por√©m n√£o as documenta.

Informa√ß√µes sobre esse dialeto da linguagem de especica√ß√£o do Krakatoa encontram-se

esparsas em apresenta√ß√µes e artigos. March√© [32, p. 11] exp√µe a sintaxe desses recursos
e acrescenta a possibilidade de usar predicados indutivos e Algebraic Data Types (blocos

axiom√°ticos onde s√£o declarados nomes de tipos e seus axiomas). Giorgetti [21, p. 3]

theoryreapresenta essa sintaxe e adiciona a possibilidade de denir teorias (cl√°usula

),

bloco l√≥gico podendo apresentar todas as outras extens√µes (tipos, predicados, fun√ß√µes e

axiomas).

O sistema sob an√°lise formal faz uso de funcionalidades das APIs JADE e Java que
prove√™m para a aplica√ß√£o estruturas de dados comumente encontradas em APIs (las,
hash maps etc.). Com a inten√ß√£o de construir anota√ß√µes gen√©ricas o suciente para serem
reaproveitadas em outras a√ß√µes de verica√ß√£o, caracter√≠stica importante para o trabalho,
abstracttentou-se usar as extens√µes axiom√°ticas do Krakatoa, nos moldes de um ADT ( data type) de Pierce [37, p. 390 et seq.].
15Tais fun√ß√µes s√£o denominadas model methods.

41

Ao tentar reproduzir exemplos examinados, alguns problemas impediram sua continuidade, sempre de natureza sint√°tica.

et al.O exemplo de Giorgetti

[21] de deni√ß√£o de uma teoria rejeita a cl√°usula

theory:

/*@ theory Th { @ type new_type; @ logic new_type func1; @ logic integer func2(new_type v, integer k); @ axiom axiom_name: axiom_body; @} @*/

File "Theory.java", line 1, characters 4-10: syntax error (parse error in annotation)

O exemplo de March√© [32] de axiomatiza√ß√£o de listas de inteiros n√£o aceita a deni√ß√£o
de um novo tipo (ilist):
/*@ axiomatic IntLists { @ type ilist; @ ilist nil(); @ ilist cons(integer n, ilist l); @ ilist append(ilist l1, ilist l2); @ axiom append_nil: @ \forall ilist l; @ append(nil(),l) == l; @ axiom append_cons: @ \forall integer n; @ \forall ilist l1 l2; @ append(cons(n,l1),l2) == @ cons(n,append(l1,l2)); @} @*/
File "IntLists.java", line 3, characters 6-11: syntax error (parse error in annotation)

Alguns outros exemplos mais simples (encontrados em apresenta√ß√µes) tamb√©m apresentaram problemas, como abaixo:
/*@ logic integer max(integer x, integer y); @ axiom max_is_ge : @ \forall integer x y; max(x,y) >= x && max(x,y) >= y; @ axiom max_is_some : @ \forall integer x y; max(x,y) == x || max(x,y) == y;

42

@/
File "Logic.java", line 1, characters 45-46: syntax error (parse error in annotation)

De fato, algumas constru√ß√µes simples sucedem, como fun√ß√µes l√≥gicas denidas (n√£o

hash mapaxiomatizadas), contudo foram insucientes para axiomatizar uma la ou um

:

//@ logic integer id(integer x) = x;

Parsing OK. Typing OK.

hashNo caso da classe HashMap, especicou-se uma lista de convers√£o xa entre o

e

√≠ndice do vetor abstrato (Se√ß√£o 3.2.4).

3.4.6 Provador autom√°tico Yices
Inicialmente o provador autom√°tico Yices foi tamb√©m instalado e usado. Entretanto, assim que algumas obriga√ß√µes de prova come√ßaram a ser descarregadas, percebeu-se que esse provador sempre fechava todas as obriga√ß√µes, at√© mesmo quando referiam-se a anota√ß√µes ainda incipientes.
Ap√≥s enviar um teste isolado √† lista de discuss√µes da ferramenta, recebeu-se resposta de um dos pesquisadores envolvidos na cria√ß√£o da plataforma Why conrmando que havera sido detectado um mau funcionamento no processo de gera√ß√£o de obriga√ß√µes de prova especicamente para o provador Yices.
Estando a corre√ß√£o dispon√≠vel somente em uma vers√£o de desenvolvimento da ferramenta e tendo sido instalados outros provadores autom√°ticos (CVC3, Eprover e Spass), optou-se por desabilitar o Yices do ambiente.

3.4.7 Objetivos de prova de outros arquivos

Na Se√ß√£o 3.3.3, mencionaram-se duas OPs (#01 e #02) que n√£o puderam ser provadas.
Analisando os objetivos gerados, nota-se que s√£o obriga√ß√µes produzidas para demonstrar
a corre√ß√£o dos construtores das classes estados e ThreadedBehaviourWrapper.

A prova para esses objetivos depende de informa√ß√£o adicional que a ferramenta deveria ter gerado. Em verdade, como a verica√ß√£o √© focada na classe principal, esses objetivos n√£o deveriam ter sido gerados pela ferramenta.

Reproduziu-se ent√£o a situa√ß√£o em caso de teste isolado, noticando-a na lista de

discuss√µes da ferramenta. De fato, o comportamento esperado seria que quando voc√™

F.javaexecutar Krakatoa passando como argumento um arquivo

, ent√£o as OPs para os

F.javaconstrutores e m√©todos de classes em

deveriam ser apresentados e somente esses,

n√£o de outros arquivos.

43

Finalmente, apenas para raticar que essas OPs somente n√£o puderam ser fechadas devido a uma opera√ß√£o indesejada da ferramenta, executou-se o Krakatoa para a classe
estados. Foram geradas duas OPs, uma delas sendo a OP gerada inesperadamente na
verica√ß√£o da classe principal; ambas foram provadas, conforme Tabela 3.5.
44

CVC3 Coq Eprover Spass

Proof obligations
CC Agent, default behavior CC Agent, Safety CC Behaviour, default behavior CC Behaviour, Safety CC ConcurrentLinkedQueue_Emergency, default behavior CC ConcurrentLinkedQueue_Emergency, Safety CC CyclicBehaviour, default behavior CC CyclicBehaviour, Safety CC DataStore, default behavior CC DataStore, default behavior CC DataStore, Safety CC DataStore, Safety CC Emergency, default behavior CC Emergency, Safety CC HashMap, default behavior CC HashMap, Safety CC MonitorAcuteEmergencyBehaviour, default behavior CC MonitorAcuteEmergencyBehaviour, Safety CC Object, default behavior CC Object, Safety CC RequestConrmationBehaviour, default behavior CC RequestConrmationBehaviour, Safety CC SimpleBehaviour, default behavior CC SimpleBehaviour, Safety CC String, default behavior CC String, Safety CC String, default behavior CC String, Safety CC String, default behavior CC String, Safety CC String, default behavior CC String, default behavior CC String, default behavior CC String, Safety CC String, default behavior CC String, default behavior

0.08 0.09 0.10 0.09 0.09 0.09 0.09 0.08 0.09 0.12 0.12 0.11 0.11 0.09 0.10 0.11 0.10 0.09 0.09 0.11 0.10 0.11 0.10 0.09 0.09 0.09 0.09 0.10 0.09 0.09 0.09 0.10 0.08 0.08 0.11 0.09

Tabela 3.2: Objetivos de prova triviais

45

CVC3 Coq Eprover Spass

Proof obligations
CC String, Safety CC String, Safety CC String, Safety CC String, Safety CC String, default behavior CC String, default behavior CC String, Safety CC String, Safety CC String, default behavior CC String, default behavior CC String, Safety CC String, Safety CC ThreadedBehaviourFactory, default behavior CC ThreadedBehaviourFactory, Safety CC ThreadedBehaviourWrapper, Safety CC estados, Safety

0.11 0.08 0.08 0.08 0.09 0.08 0.09 0.10 0.10 0.09 0.12 0.10 0.10 0.08 0.08 0.08

Tabela 3.3: Objetivos de prova triviais (cont.)

CVC3 Coq Eprover Spass

# Proof obligations
01 normal postcondition 02 normal postcondition 03 Method action, Safety

? ?

Tabela 3.4: Objetivos de prova n√£o provados

CVC3 Coq

Proof obligations

normal postcondition

1.35

CC estados, Safety 0.06

Tabela 3.5: Objetivos de prova exclusivos da classe estados

46

Cap√≠tulo 4 Conclus√£o

Este trabalho apresentou m√©todos formais que podem ser empregados para an√°lise formal de aplica√ß√µes imperativas n√£o exclusivamente acad√™micas. No caso trabalhado, devido √† depend√™ncia de diversas bibliotecas, estabeleceu-se uma disciplina de verica√ß√£o a anota√ß√£o. O comportamento esperado foi sempre modelado em duas etapas, partindo da especica√ß√£o do c√≥digo alvo (classe principal) e culminando com a anota√ß√£o de classes usadas (bibliotecas de classes), onde apenas o c√≥digo necess√°rio para esbo√ßar o comportamento do c√≥digo alvo foi modelado. A cada classe, analisou-se o comportamento de inten√ß√£o documentado para posteriormente criar as especica√ß√µes JML correspondentes.

Observou-se que a formaliza√ß√£o e verica√ß√£o de c√≥digo comercial produzido em massa √© um desao de tamanho an√°logo √† pr√≥pria constru√ß√£o da aplica√ß√£o. N√£o obstante, percebeu-se que a verica√ß√£o de propriedades espec√≠cas de partes cr√≠ticas de sistemas de interesse √© um objetivo tang√≠vel e, de fato, j√° perseguido por algumas iniciativas na ind√∫stria.

Dois fatores demonstraram contribuir sobremaneira neste processo: a tradu√ß√£o automatizada de c√≥digo imperativo para uma axiomatiza√ß√£o apropriada e o uso de provadores autom√°ticos para eliminar a maioria das obriga√ß√µes de prova.

Apesar de a L√≥gica de Hoare ser um formalismo que originalmente captura as constru-

√ß√µes b√°sicas de linguagens imperativas, linguagens de programa√ß√£o comerciais como Java

possuem diversas nuan√ßas e extens√µes que, por si s√≥, carecem de uma formaliza√ß√£o sem√¢n-

tica. Assim, devido ao uso de determinadas funcionalidades dispon√≠veis nessas linguagens,

a pr√≥pria compreens√£o integral do c√≥digo produzido √© um desao. Nesse cen√°rio, de forma

ad hocmanual, realizar a tradu√ß√£o

do c√≥digo-fonte para a linguagem de especica√ß√£o de

provadores como Coq e PVS √© uma tarefa que pode limitar o uso em grande escala das

solu√ß√µes envolvidas, por envolver trabalho repetitivo e suscet√≠vel a erros. A abordagem

de tradu√ß√£o mecanizada possibilita a concentra√ß√£o de esfor√ßos na compreens√£o dos aspec-

tos sem√¢nticos envolvidos, bem como de sua representa√ß√£o apropriada em ambientes de

prova.

Por outro lado, mesmo trechos reduzidos de c√≥digo geram um n√∫mero elevado de obriga√ß√µes a serem provadas. No caso estudado, apenas dois objetivos de prova tiveram como

47

sine qua noncondi√ß√£o

o uso de provadores interativos. Assim, a maioria das obriga√ß√µes

p√¥de ser provada tamb√©m de forma mecanizada.

Quanto √† linguagem de especica√ß√£o de propriedades, todas as constru√ß√µes apresentadas s√£o de primeira ordem, o que limita a expressividade das aplica√ß√µes. Apesar disso, no caso apresentado, foi poss√≠vel cobrir parte importante de uma aplica√ß√£o comercial, apenas com constru√ß√µes de primeira ordem. Adicionalmente a linguagem de especica√ß√£o apresentada (JML) tem evolu√≠do para suportar constru√ß√µes de ordem superior, por√©m de forma ainda experimental.

4.1 Trabalhos futuros

frameworksAmbientes de programa√ß√£o voltados ao acoplamento de

, presentes em

linguagens orientadas a objeto (como Java), levam a uma profus√£o de APIs que estendem

o n√∫cleo b√°sico das linguagens. Documentar formalmente todo esse c√≥digo √© um desao,

mas que simplica verica√ß√µes subsequentes de aplica√ß√µes clientes dessas bibliotecas, uma

vez que o comportamento das bibliotecas j√° estaria especicado. Para tanto, contudo,

√© necess√°rio que constru√ß√µes que viabilizem a especica√ß√£o de tipos de dados abstratos

funcionem de forma adequada nessas ferramentas.

Apesar de a maioria das obriga√ß√µes ter sido provada por provadores autom√°ticos, a necessidade de usar provadores interativos mostra que a identica√ß√£o de padr√µes estruturais nas provas poderia ser revertida para a cria√ß√£o de novas t√°ticas, por exemplo, para o Coq. A experi√™ncia com as obriga√ß√µes de prova demonstradas em Coq mostra que h√° recorr√™ncias no processo de cria√ß√£o do termo de prova. Assim, podem ser desenvolvidas t√°ticas de prova especializadas na axiomatiza√ß√£o produzida pelas ferramentas, aumentando o grau de automatiza√ß√£o do processo de verica√ß√£o.

Para o uso comercial do Krakatoa √© importante que sua documenta√ß√£o seja consolidada, uma vez que encontra-se esparsa em artigos e apresenta√ß√µes. Este √© um trabalho futuro que pode ser realizado de forma gradual e todo incremento na documenta√ß√£o diminuir√° o tempo de aprendizagem de novos vericadores.

Finalmente, o problema detectado com o provador autom√°tico Yices (Se√ß√£o 3.4.6)

mostrou que h√° uma lacuna a ser preenchida no projeto do Why: o processo de tradu√ß√£o

das anota√ß√µes JML e c√≥digo imperativo para os diversos provadores n√£o est√° formalmente

softwaredenido. Assim, o

envolvido, apesar de ter suas entradas e sa√≠das bem denidas,

poderia ter formalizada, por exemplo, a conservatividade do processo de tradu√ß√£o. O tra-

balho de deni√ß√£o formal de JML em Coq de Lehner [29], apesar de n√£o estar diretamente

relacionado com as ferramentas, criou um ambiente para discuss√£o formal sobre a sem√¢n-

tica de JML, o qual pode ser usado como ponto de partida para denir formalmente pelo

menos o processo (realizado pelo Krakatoa) de tradu√ß√£o das especica√ß√µes JML (apostas

nos c√≥digos-fontes) para a linguagem de entrada do Why.

48

Refer√™ncias
[1] Oracle and/or its aliates. Java Platform, Standard Edition 6, API Specication, 2011. 14, 17, 18, 19, 20
[2] Oracle and/or its aliates. The Java Tutorials, 2012. 37, 38, 39, 40
[3] Patrick Baudin, Pascal Cuoq, Jean-Christophe Filli√¢tre, Claude March√©, Benjamin
Monate, Yannick Moy, and Virgile Prevosto. ACSL: ANSI/ISO C Specication Language. CEA LIST and INRIA Saclay, 2009. 6
[4] Fabio Bellifemine, Giovanni Caire, Tiziana Trucco, and Giovanni Rimassa. JADE Programmer's Guide, April 2010. 14, 16, 19, 21
[5] Yves Bertot. Coq in a hurry. ACM Computing Research Repository (CoRR), abs /
cs / 0603118, 2006. 8
[6] Yves Bertot and Pierre Cast√©ran. Interactive Theorem Proving and Program Development, Coq'Art: the Calculus of Inductive Constructions. Springer-Verlag, 2004.
8
[7] Fran√ßois Bobot, Jean-Christophe Filli√¢tre, Claude March√©, and Andrei Paskevich.
The Why3 platform. LRI, CNRS & Univ. Paris-Sud & INRIA Saclay, version 0.64 edition, February 2011. http://why3.lri.fr/. 7 [8] Jaime Alejandro Boh√≥rquez Villamizar. Dise√±o Efectivo de Programas Correctos.
Escuela Colombiana de Ingenier√≠a, Bogot√°, D.C., agosto 2005. Tercera Edici√≥n Preliminar. 4
[9] Sylvie Boldo and Thi Minh Tuyen Nguyen. Hardware-independent proofs of nume-
rical programs. In C√©sar Mu√±oz, editor, Second NASA Formal Methods Symposium (NFM 2010), volume NASA/CP-2010-216215, pages 1423, Washington D.C. United
States, 04 2010. NASA. Hisseo project, funded by Digiteo. 1
[10] Sylvain Boulm√©. A tutorial on reecting in Coq the generation of Hoare proof obli-
gations, 2009. http://coq.inria.fr/distrib/v8.2/contribs/HoareTut.html. 8
[11] Patrice Chalin, Joseph R. Kiniry, Gary T. Leavens, and Erik Poll. Beyond asserti-
Formalons: Advanced specication and verication with JML and ESC/Java2. In Methods for Components and Objects (FMCO) 2005, Revised Lectures, volume 4111 LNCSof , pages 342363. SV, 2006. 36, 39, 41
49

[12] The Coq proof assistant, 2009. Vers√£o: 8.2pl1, URL: http://coq.inria.fr/. 8
Frama-C User[13] Lo√Øc Correnson, Pascal Cuoq, Armand Puccetti, and Julien Signoles. Manual, Beryllium release. CEA LIST, Software Reliability Laboratory, Saclay, 2009.
7

[14] Edsger W. Dijkstra. Guarded commands, nondeterminacy and formal derivation of
programs. Commun. ACM, 18(8):453457, 1975. 3

[15] Claire Dross, Jean-Christophe Filli√¢tre, and Yannick Moy. Correct Code Containing
Containers. In 5th International Conference on Tests & Proofs (TAP'11), Zurich,
June 2011. 20
[16] EMERGE, 2009. URL: http://www.emerge-project.eu/. 11

[17] Jean-Christophe Filli√¢tre, Hugo Herbelin, Bruno Barras, Samuel Boutin, Cristina Cornes, Judicael Courant, Chetan Murthy, Catherine Parent, Christine PaulinMohring, Amokrane Saibi, and Benjamin Werner. The coq proof assistant reference manual. Technical report, INRIA and IST Types working group, 2009. Vers√£o: 8.2. 10

[18] Jean Christophe Filli√¢tre and Claude March√©. The Why/Krakatoa/Caduceus plat-
form for deductive program verication. In Proceedings of the 19th international conference on Computer Aided verication, CAV'07, pages 173177, Berlin, Heidel-
berg, 2007. Springer-Verlag. viii, 8
[19] Robert W. Floyd. Assigning meanings to programs. In Proceedings of the American Mathematical Society Symposia in Applied Mathematics, volume 19, pages 1932,
1967. 3
http:[20] Frama-C Software Analyzers, 2009. Vers√£o: Beryllium-20090902+dev, URL: //frama-c.cea.fr/. 7

[21] Alain Giorgetti, Claude March√©, Elena Tushkanova, and Olga Kouchnarenko. Spe-

cifying generic java programs: two case studies. In Claus Brabrand and Pierre-

LDTAEtienne Moreau, editors,

, page 8. ACM, 2010. 41, 42

[22] Charles Antony Richard Hoare. An axiomatic basis for computer programming.
Communications of the ACM, 12(10):576580,583, 1969. 3, 4

[23] William A. Howard. The formulas-as-types notion of construction. In J. P. Seldin
and J. R. Hindley, editors, To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus, and Formalism, pages 479490. Academic Press, 1980. 9
[24] Michael R. A. Huth and Mark D. Ryan. Logic in Computer Science: Modelling and Reasoning about Systems. Cambridge University Press, Cambridge, England, 2000.
1, 3

50

[25] Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andronick, David Cock, Philip Derrin, Dhammika Elkaduwe, Kai Engelhardt, Rafal Kolanski, Michael Norrish, Thomas Sewell, Harvey Tuch, and Simon Winwood. seL4: Formal verication of
an OS kernel. In Proceedings of the 22nd ACM Symposium on Operating Systems Principles, pages 207220, Big Sky, MT, USA, Oct 2009. ACM. 1
http:[26] The Krakatoa verication tool for Java programs, 2009. Vers√£o: 2.18, URL: //krakatoa.lri.fr/. 7
[27] Gary T. Leavens, Albert L. Baker, and Clyde Ruby. Preliminary design of JML: a
behavioral interface specication language for Java. SIGSOFT Softw. Eng. Notes,
31:138, May 2006. 6
[28] Gary T. Leavens and Yoonsik Cheon. Design by contract with jml, 2006. 17, 36, 39
[29] Hermann Lehner. A Formal Denition of JML in Coq and its Application to Runtime Assertion Checking. PhD thesis, ETH Zurich, Switzerland, 2011. 48
[30] Leonard Lensink, C√©sar Mu√±oz, and Alwyn Goodloe. From veried models to veriable code. Technical Memorandum NASA/TM-2009-215943, NASA, Langley Research Center, Hampton VA 23681-2199, USA, June 2009. 1
[31] Xavier Leroy. A formally veried compiler back-end. Journal of Automated Reasoning, 43:363446, December 2009. 1
[32] Claude March√©. The Krakatoa tool for deductive verication of Java programs. Winter School on Object-Oriented Verication, Viinistu, Estonia, January 2009.
http://krakatoa.lri.fr/ws/. 24, 36, 39, 41, 42 [33] Claude March√©. Krakatoa: Tutorial and Reference Manual. INRIA Team-Project,
2010. 7, 36, 41
[34] Claude March√©, Christine Paulin-Mohring, and Xavier Urbain. The Krakatoa tool for certication of Java/JavaCard programs annotated in JML. 2003. 1
[35] Michael Marcotty and Henry F. Ledgard. Programming language landscape: syntax, semantics, and implementation. SRA School Group, USA, 1986. 3
[36] Vinicius Uriel Cardoso Nunes. Orquestra√ß√£o de servi√ßos por meio de agentes de soft-
ware no dom√≠nio de vida ambiente-assistida. URL: http://monografias.cic.unb. br/dspace/bitstream/123456789/225/1/monografia.pdf, Dezembro 2009. Mo-
nograa de conclus√£o de bacharelado em Ci√™ncia da Computa√ß√£o, Universidade de Bras√≠lia. 11, 12, 14
[37] Benjamin C. Pierce. Types and Programming Languages. MIT Press, 2002. 34, 38,
39, 41
[38] The Why verication tool, 2009. Vers√£o: 2.23, URL: http://why.lri.fr/. 7
[39] Z specication language, 2009. URL: http://www.zuser.org/. 6
51

Ap√™ndice A C√≥digos Anotados

√Ä exce√ß√£o do arquivo MonitorAcuteEmergencyBehaviour.java, o qual √© aqui trans-

ipsis litteriscrito

, apenas os m√©todos efetivamente anotados constam deste excerto.

A.1 MonitorAcuteEmergencyBehaviour.java
/*KML package br.unb.cic.aal.behaviour;
import jade.core.behaviours.CyclicBehaviour;
import jade.core.behaviours.ThreadedBehaviourFactory;
import java.util.Observable; import java.util.Observer; import java.util.Queue; import java.util.concurrent.ConcurrentLinkedQueue; import java.util.Queue_Emergency; import java.util.concurrent.ConcurrentLinkedQueue_Emergency;
import org.osgi.framework.ServiceReference;
import br.unb.cic.aal.agent.AALAgent; import br.unb.cic.aal.ontology.Emergency; import br.unb.cic.aal.service.emergency.detection.DetectEmergencyService; KML*/
public class MonitorAcuteEmergencyBehaviour extends CyclicBehaviour implements Observer {
/** *
52

*/ private static final long serialVersionUID =
3951408798663833348L;
/*KML private Queue<Emergency> emergencies = new ConcurrentLinkedQueue<Emergency>();
KML*/ private Queue_Emergency emergencies = new ConcurrentLinkedQueue_Emergency(); private DetectEmergencyService detectEmergency = null; private ThreadedBehaviourFactory threadFactory = null;
//KML @Override /*@ @ ensures threadFactory != null; @*/ public void onStart() { threadFactory = new ThreadedBehaviourFactory();
/*KML ServiceReference reference = null; reference = ((AALAgent) myAgent).getBundleContext() .getServiceReference( DetectEmergencyService.class.getName());
detectEmergency = (DetectEmergencyService)((AALAgent) myAgent) .getBundleContext().getService(reference);
detectEmergency.register(this); KML*/
}
//KML @SuppressWarnings("unchecked") //KML @Override
/*@ @ requires threadFactory != null; @ assigns estados.qtde_emergencias; @ behavior emergencia: @ assumes estados.qtde_emergencias >= 1; @ ensures @ estados.qtde_emergencias == @ \old(estados.qtde_emergencias) - 1 @ && myAgent.qt_behaviours == @ \old(myAgent.qt_behaviours) + 1 @ && myAgent.lista_behaviours[\old(myAgent.qt_behaviours)]
53

@ instanceof ThreadedBehaviourWrapper @ && ((ThreadedBehaviourWrapper) @ myAgent.lista_behaviours[\old(myAgent.qt_behaviours)]) @ .myBehaviour instanceof RequestConfirmationBehaviour; @ behavior nenhuma_emergencia: @ assumes estados.qtde_emergencias == 0; @ ensures estados.qtde_emergencias == 0; @*/ public void action() {
Emergency emergency = emergencies.poll(); if (emergency != null) {
RequestConfirmationBehaviour requestConfirmation = new RequestConfirmationBehaviour();
requestConfirmation.getDataStore() .put(RequestConfirmationBehaviour.EVENT_KEY, emergency);
myAgent.addBehaviour( threadFactory.wrap(requestConfirmation)); //Starts a threaded behaviour
} }
//KML @Override /*@ @ assigns estados.qtde_emergencias; @ behavior enfileirar_emergencia: @ assumes arg instanceof Emergency; @ ensures estados.qtde_emergencias == @ \old(estados.qtde_emergencias) + 1; @ behavior nao_enfileirar_emergencia: @ assumes ! (arg instanceof Emergency); @ ensures estados.qtde_emergencias == @ \old(estados.qtde_emergencias); @*/ public void update(Observable o, Object arg) { if (arg instanceof Emergency) { emergencies.add((Emergency) arg); } }
}
A.2 Agent.java
/*KML package jade.core;
54

import jade.core.behaviours.Behaviour; KML*/
public class Agent {
/** Default constructor. */ public Agent();
//@ model integer qt_behaviours = 0; //@ model Behaviour [] lista_behaviours;
/*@ @ requires b instanceof ThreadedBehaviourWrapper; @ ensures qt_behaviours == \old(qt_behaviours) + 1 && @ lista_behaviours[\old(qt_behaviours)] == b; @*/
public void addBehaviour(Behaviour b);
// public void removeBehaviour(Behaviour b);
}
A.3 Queue_Emergency.java
/*KML package java.util;
import br.unb.cic.aal.ontology.Emergency; KML*/
public interface Queue_Emergency /*KML extends Collection<E> KML*/ {
/*@ @ assigns estados.qtde_emergencias; @ ensures estados.qtde_emergencias == @ \old(estados.qtde_emergencias) + 1; @*/
boolean add(Emergency e);
// Emergency remove();
/*@
55

@ assigns estados.qtde_emergencias; @ behavior fila_com_conteudo: @ assumes estados.qtde_emergencias >= 1; @ ensures \result != null && @ estados.qtde_emergencias == @ \old(estados.qtde_emergencias) - 1; @ behavior fila_vazia: @ assumes estados.qtde_emergencias == 0; @ ensures \result == null && @ estados.qtde_emergencias == @ \old(estados.qtde_emergencias); @*/ Emergency poll();
// Emergency peek(); }
A.4 ThreadedBehaviourFactory.java
/*KML package jade.core.behaviours;
//#MIDP_EXCLUDE_FILE
import jade.core.Agent; import jade.core.NotFoundException; import jade.util.Logger;
import java.lang.reflect.Method; import java.util.Vector; import java.util.Enumeration;
KML*/
public class ThreadedBehaviourFactory { /*@ @ requires b != null; @ ensures \result instanceof ThreadedBehaviourWrapper @ && \result != null @ && ((ThreadedBehaviourWrapper)\result) @ .myBehaviour == b; @*/ public Behaviour wrap(Behaviour b) ; /*KML { return new ThreadedBehaviourWrapper(b); } KML*/
}
56

A.5 ThreadedBehaviourWrapper.java
/** * Inner class ThreadedBehaviourWrapper * This class is declared public for debugging purpose only */
public class ThreadedBehaviourWrapper extends Behaviour /*KML implements Runnable KML*/ {
private Behaviour myBehaviour;
//@ ensures myBehaviour == b; private ThreadedBehaviourWrapper(Behaviour b);
} // END of inner class ThreadedBehaviourWrapper
A.6 HashMap.java
/*KML package jade.util.leap;
import java.io.IOException; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.util.Hashtable; import java.util.Enumeration; KML*/
/** The LEAP (environment-dependent) version of the &qote;java.util.HashMap&qote; class. This class appears to be exactly the same in J2SE, PJAVA and MIDP. The internal implementation is different in the three cases however.
@author Nicolas Lhuillier @version 1.0, 29/09/00
@see java.util.HashMap */
public class HashMap /*KML implements Map, Serializable KML*/ { //@ model Object [] vetor;
/*@
57

@ ensures key == RequestConfirmationBehaviour.EVENT_KEY ==> @ vetor[0] == value; @*/ public Object put(Object key, Object value);
/*@ @ ensures key == RequestConfirmationBehaviour.EVENT_KEY ==> @ \result == vetor[0]; @*/
public Object get(Object key); }
A.7 Behaviour.java
/*KML package jade.core.behaviours;
import jade.util.leap.Serializable;
import jade.core.behaviours.DataStore; KML*/
public abstract class Behaviour /*KML implements Serializable KML*/ { // void setParent(CompositeBehaviour cb);
// void setWrappedParent(CompositeBehaviour cb);
// protected CompositeBehaviour getParent();
// public Behaviour(){this.onStart();}
/*@ @ requires a != null; @ ensures myAgent == a; @*/
public Behaviour(Agent a);
public abstract void action();
public void onStart();
//@ ensures \result == myStore && myStore != null; public DataStore getDataStore();
/*@
58

@ requires ds != null; @ ensures myStore == ds; @*/ public void setDataStore(DataStore ds); protected Agent myAgent; private DataStore myStore; }
A.8 estados.java
public class estados { public static int qtde_emergencias; //@ invariant qtde_positiva: qtde_emergencias >= 0; /*@ @ assigns qtde_emergencias; @ ensures qtde_emergencias == 0; @*/ estados() { qtde_emergencias = 0; }
}
59

Anexo I
Trechos da axiomatiza√ß√£o Java memory heap
Reproduzem-se aqui alguns poucos trechos da axiomatiza√ß√£o descarregada pelo Why para os arquivos de prova do Coq.
(* This file is generated by Why3's Coq driver *) (* Beware! Only edit allowed sections below *)
... ... (SUPRIMIDO) ...
Definition valid (t:Type)(a:(alloc_table t)) (p:(pointer t)): Prop := ((offset_min a p) <= 0%Z)%Z /\ (0%Z <= (offset_max a p))%Z.
Implicit Arguments valid.
... ... (SUPRIMIDO) ...
Axiom address_injective : forall (t:Type), forall (p:(pointer t)), forall (q:(pointer t)), (p = q) <-> ((address p) = (address q)).
Axiom address_shift_lt : forall (t:Type), forall (p:(pointer t)), forall (i:Z), forall (j:Z), ((address (shift p i)) < (address (shift p j)))%Z <-> (i < j)%Z.
Axiom address_shift_le : forall (t:Type), forall (p:(pointer t)), forall (i:Z), forall (j:Z), ((address (shift p i)) <= (address (shift p j)))%Z <-> (i <= j)%Z.
Axiom shift_zero : forall (t:Type), forall (p:(pointer t)), ((shift p
60

0%Z) = p).
Axiom shift_shift : forall (t:Type), forall (p:(pointer t)), forall (i:Z), forall (j:Z), ((shift (shift p i) j) = (shift p (i + j)%Z)).
Axiom offset_max_shift : forall (t:Type), forall (a:(alloc_table t)), forall (p:(pointer t)), forall (i:Z), ((offset_max a (shift p i)) = ((offset_max a p) - i)%Z).
Axiom offset_min_shift : forall (t:Type), forall (a:(alloc_table t)), forall (p:(pointer t)), forall (i:Z), ((offset_min a (shift p i)) = ((offset_min a p) - i)%Z).
Axiom neq_shift : forall (t:Type), forall (p:(pointer t)), forall (i:Z), forall (j:Z), (~ (i = j)) -> ~ ((shift p i) = (shift p j)).
Axiom null_not_valid : forall (t:Type), forall (a:(alloc_table t)), ~ (valid a (null:(pointer t))).
Axiom null_pointer : forall (t:Type), forall (a:(alloc_table t)), (0%Z <= (offset_min a (null:(pointer t))))%Z /\ ((offset_max a (null:(pointer t))) <= (-2%Z)%Z)%Z.
... ... (SUPRIMIDO) ...
Parameter memory : forall (t:Type) (v:Type), Type.
Parameter select: forall (t:Type) (v:Type), (memory t v) -> (pointer t) -> v.
Implicit Arguments select.
Parameter store: forall (t:Type) (v:Type), (memory t v) -> (pointer t) -> v -> (memory t v).
Implicit Arguments store.
Axiom select_store_eq : forall (t:Type) (v:Type), forall (m:(memory t v)), forall (p1:(pointer t)), forall (p2:(pointer t)), forall (a:v), (p1 = p2) -> ((select (store m p1 a) p2) = a).
Axiom select_store_neq : forall (t:Type) (v:Type), forall (m:(memory t v)), forall (p1:(pointer t)), forall (p2:(pointer t)), forall (a:v), (~ (p1 = p2)) -> ((select (store m p1 a) p2) = (select m p2)).
61

... ... (SUPRIMIDO) ...
Definition not_assigns (t:Type) (v:Type)(a:(alloc_table t)) (m1:(memory t v)) (m2:(memory t v)) (l:(pset t)): Prop := forall (p:(pointer t)), ((valid a p) /\ ~ (in_pset p l)) -> ((select m2 p) = (select m1 p)).
Implicit Arguments not_assigns.
Axiom not_assigns_refl : forall (t:Type) (v:Type), forall (a:(alloc_table t)), forall (m:(memory t v)), forall (l:(pset t)), (not_assigns a m m l).
Axiom not_assigns_trans : forall (t:Type) (v:Type), forall (a:(alloc_table t)), forall (m1:(memory t v)), forall (m2:(memory t v)), forall (m3:(memory t v)), forall (l:(pset t)), (not_assigns a m1 m2 l) -> ((not_assigns a m2 m3 l) -> (not_assigns a m1 m3 l)).
... ... (SUPRIMIDO) ...
Axiom subtag_parent : forall (t:Type), forall (t1:(tag_id t)), forall (t2:(tag_id t)), forall (t3:(tag_id t)), (subtag t1 t2) -> ((parenttag t2 t3) -> (subtag t1 t3)).
Definition instanceof (t:Type)(a:(tag_table t)) (p:(pointer t)) (t1:(tag_id t)): Prop := (subtag (typeof a p) t1).
Implicit Arguments instanceof.
Parameter downcast: forall (t:Type), (tag_table t) -> (pointer t) -> (tag_id t) -> (pointer t).
Implicit Arguments downcast.
Axiom downcast_instanceof : forall (t:Type), forall (a:(tag_table t)), forall (p:(pointer t)), forall (s:(tag_id t)), (instanceof a p s) -> ((downcast a p s) = p).
... ... (SUPRIMIDO) ...
Parameter alloc_extends: forall (t:Type), (alloc_table t) -> (alloc_table t) -> Prop.
Implicit Arguments alloc_extends.
62

Definition alloc_fresh (t:Type)(a:(alloc_table t)) (p:(pointer t)) (n:Z): Prop := forall (i:Z), ((0%Z <= i)%Z /\ (i < n)%Z) -> ~ (valid a (shift p i)).
Implicit Arguments alloc_fresh.
Axiom alloc_extends_offset_min : forall (t:Type), forall (a1:(alloc_table t)), forall (a2:(alloc_table t)), (alloc_extends a1 a2) -> forall (p:(pointer t)), (valid a1 p) -> ((offset_min a1 p) = (offset_min a2 p)).
Axiom alloc_extends_offset_max : forall (t:Type), forall (a1:(alloc_table t)), forall (a2:(alloc_table t)), (alloc_extends a1 a2) -> forall (p:(pointer t)), (valid a1 p) -> ((offset_max a1 p) = (offset_max a2 p)).
... ... (SUPRIMIDO) ...
Axiom usMonitorAcuteEmergencyBehaviour_parenttag_CyclicBehaviour : (parenttag usMonitorAcuteEmergencyBehaviour_tag usCyclicBehaviour_tag).
Definition usNon_null_BehaviourM(x_4:(pointer usObject)) (usObject_alloc_table:(alloc_table usObject)): Prop := ((-1%Z)%Z <= (offset_max usObject_alloc_table x_4))%Z.
Definition usNon_null_Object(x_5:(pointer usObject)) (usObject_alloc_table:(alloc_table usObject)): Prop := (0%Z <= (offset_max usObject_alloc_table x_5))%Z.
Definition usNon_null_ObjectM(x_0:(pointer usObject)) (usObject_alloc_table:(alloc_table usObject)): Prop := ((-1%Z)%Z <= (offset_max usObject_alloc_table x_0))%Z.
Definition usNon_null_StringM(x_3:(pointer usObject)) (usObject_alloc_table:(alloc_table usObject)): Prop := ((-1%Z)%Z <= (offset_max usObject_alloc_table x_3))%Z.
Definition usNon_null_byteM(x_1:(pointer usObject)) (usObject_alloc_table:(alloc_table usObject)): Prop := ((-1%Z)%Z <= (offset_max usObject_alloc_table x_1))%Z.
Definition usNon_null_charM(x_2:(pointer usObject)) (usObject_alloc_table:(alloc_table usObject)): Prop :=
63

((-1%Z)%Z <= (offset_max usObject_alloc_table x_2))%Z. ... ... (SUPRIMIDO) ... (* YOU MAY EDIT THE CONTEXT BELOW *)
64

