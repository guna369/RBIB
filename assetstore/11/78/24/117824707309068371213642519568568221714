LINEAR PATTERN MATCHING ALGORITHMS
Peter Weiner
*The Rand Corporation, Santa Monica, California
Abstract
In 1970, Knuth, Pratt, and Morris [1] showed how to do basic pattern matching
in linear time. Related problems, such as those discussed in [4], have pre-
viously been solved by efficient but sub-optimal algorithms. In this paper, we
introduce an interesting data structure called a bi-tree. A linear time algo-
rithm "for obtaining a compacted version of a bi-tree associated with a given
string is presented. With this construction as the basic tool, we indicate how
to solve several pattern matching problems, including some from [4], in linear
time.
I. Introduction
In 1970, Knuth, Morris, and Pratt [1-2] showed how to
match a given pattern into another given string in time
proportional to the sum of the lengths of the pattern
and string. Their algorithm was derived from a result
of Cook [3] that the 2-way deterministic pushdown lan-
guages are recognizable on a random access machine in
time O(n). Since 1970, attention has been given to
several related problems in pattern matching [4-6], but
the algorithms developed in these investigations us-
ually run in time which is slightly worse than linear,
for example O(n log n). It is of considerable interest
to either establish that there exists a non-linear
lower bound on the run time of all algorithms which
solve a given pattern matching problem, or to exhibit
an algorithm whose run time is of O(n).
In the following sections, we introduce an inter-
esting data structure, called a bi-tree, and show how
an efficient calculation of a bi-tree can be applied to
the linear-time (and linear-space) solution of several
pattern matching problems.
II. Strings, Trees, and Bi-Trees
In this paper, both patterns and strings are finite
length, fully specified sequences of symbols over a
finite alphabet [ = {al ,a2 , ... ,at }. Such a pattern of
length m will be denoted as
P = P (1) P (2) ... P (m ),
where P(i), an element of [, is the i th symbol in the
sequence, and is said to be located in the i th position.
To represent the substring of characters which begins
at position i of P and ends at position j, we write
P (i: j). That is, when i ~ j, P (i: j ) = P (i) ... P (j ),
and P(i:j) = A, the null string, for i > j.
Let [* denote the set of all finite length strings
over [. Tw~ strings WI and w2 in [* may be combined by
the operation of concatenation to form a new string
W = WI w2 . The reverse of a string P = A (1) ... A (m)
is the s t r ing pr = A (m) ... A (1 ).
The length of a string or pattern, denoted by 19(w)
for W E [*, is the number of symbols in the sequence.
For example, 19(P(i:j» = j-i+l if i ~ j and is 0 if
i > j.
Informally, a bi-tree over [ can be thought of as
two related t-ary trees sharing a common node set.
*This work was partially supported by grants from
the Alfred P. Sloan Foundation and the Exxon Education
Foundation. P. Weiner was at Yale University when this
work was done.
Before giving a formal definition of a bi-tree, we re-
view basic definitions and terminology concerning t-ary
trees. (See Knuth [7] for further details.)
A t-ary tpee T over [ = {al, ... ,a
t
} is a set of
nodes N which is either empty or consists of a poot,
nO E N, and t ordered, disjoint t-arY trees.
Clearly, every node ni E N is the root of some
t-ary tree T i which itself consists of n1 and t ordered,
iiidisjoint t-ary trees, say Tl , T2 , Tt • We call theitree Tj a sub-tpee of T ; also, .all sub-trees of Tj are
considered to be sub-trees of T1 • It is natural to
associate with a tree T a successor function
S: NX[ ~ (N-{nO}) U {NIL}
defined for al~ ni E Nand a j E L by
n
i
, the root of T~ if T~ is non-empty
s(ni'Oj) = {NIL if T~ is empty.
It is easily seen that this function completely deter-
mines a t-ary tree and we write T = (N, nO'S).
If n' = S(n,a), we say that nand n' are connected
by a bpanah from n to n f which has a label of o. wet
call n' a son of n, and n the father of n'. The degree
of a node n is the number of sons of that node, that is,
the number of distinct a for which S(n,a) ~ NIL. A node
of degree 0 is a leaf of the tree.
It is useful to extend the domain of S from Nx[
to (N U {NIL}) x [* (and extend the range to include
nO) by the inductive definition
(Sl) S(NIL,w) NIL for all w E [*
(S2) S(n,A) = n for all n E N
(S3) S(n,u.xJ) = S(S(n,w),a) for all n EN, w E L*,
and a E L:.
Not every S: Nx[ ~ (N-{nO}) U {NIL} is the successor
function of a t-ary tree. But a necessary and suffi-
cient condition for S to be a successor function of
some (unique, if it exists) t-ary tree can be expressed
in terms of the extended S. Namely, that there exists
exactly one choice of w such that S(nO'w} n for every
n E N. \~en there exists a T such that T = (N,nO'S),
we say that S is legiti~ate.
We may also associate with T a father function
F: N ~ N defined by F(nO) = nO and for n' E N-{nO}'
F (n ') = n ¢) S (n , a) = n' for s orne a E [.
Let FO(n) :: n for all n EN. It may be shown that the
k-fold composition of F, Fk , for positive k and n # nO'
satisfies Fk(n) # n, and that for any n there exists a'
klease value of k such that F (n) = nO. This value is
called the level of the node. Any n' = Fk(n) for pos-
itive k is said to be an ancestor of n. (The root nO
is an ancestor of all other nodes in the tree.)
There is another important function which may be
associated with a t-ary tree T over the alphabet L.
This function W: N ~ L* associates a string of symbols
from L with each node of T, and is defined recursively
by
(WI) W(nO) = A
(W2) Wen) = W(n')eo ~ n = S(n',o).
It is not hard to show that (WI) and (W2) com-
pletely specify a well-defined function, and moreover
that the sequence of branches which connect the root
to any other node n in T are labelled with the ele-
ments of Wen). (The label of the branch from nO is
the leftmost element of Wen), etc.) It is also pos-
sible to show that the length of Wen) equals the level
of node n. Indeed, an inductive argument can be made
to establish the useful assertion that for all n E N
and W E l:*,
say that the bi-tree B is an s-extension (p-extension)
of its p-tree (s-tree). When appropriate to prevent
confusion, we use terms such as p-branch to indicate a
branch of the p-tree, etc.; also, the function F (F)P s
is the father function of the tree T (T). However,p s
if a term or function is written without an s or p
identifier, we mean to refer to the p-tree concept.
Remark:
It follows from the definition of a bi-tree that
thif a node is at the j level of the p-tree it must also
be at the jth level of the s-tree, and vice-versa. Ac-
tually, the p-tree and s-tree are anti-isomorphic im-
ages of one another in the sense of £4].
The definition of a bi-tree does not in itself
insure that there exist any bi-trees at all; however,
an example of a bi-tree is shown in Figure 1, which
establishes that the definition is non-vacuous.
A useful relationship between the extended func-
tions Sand S of a bi-tree is provided in the follow-p s
ing lemma.
Lemma 1:
Let B (N,nO'S ,8 ) be a bi-tree over l:. Thenp s
for all n E Nand w E l:*,
w = Wen) ~ n 5(no'w) (1)
as well as the identity
n = Flg(W(n»(n) for all n EN.o
Proof:
Consider the string w = W (n). Since (N,nO'Sp)
is a t-ary tree, p
We also have, from the definition of a bi-tree, that
Similarly, since (N,nO,8s ) is a t-ary tree,
QED
n = Sp(nO'w) ~ w = Wp(n)
~ wr = W (n)
s
r~ n = Ss (nO' w ).
It follows that
W (n) = [W (n)]r.p s
w = W (n) ~ npNote also that when S is not legitimate the func-
tion W defined recursively in terms of S by (WI) and
(W2) is not well defined. Thus, (N,nO'S) is a t-ary
tree if and only if W is well defined. We call the
function W the walk function associated with T.
The association of a node n with the string w =
Wen) is an important one. In order to be able to asso-
ciate w with n directly we adopt the following nota-
t~onal convention. If n' is a"node ~n N, w~ write ..
w = Wen'). Similarly, write w = Wen) for n E N, w'
W(~') for ~, E N, etc.
Definition:
A bi-tree B = (N,no'S ,S ) over the alphabetp s
L = {Ol' .•. 'at} is a set of nodes N with a designated
root nO E N, together with the functions
and
such that
(Bl) T (N,nO'Sp) is a t-ary tree,p
(B2) T (N,nO'Ss) is a t-ary tree, ands
(B3) W (n) = [W (n)]r for all n E N,
P s
If Tis a given t-ary tree~ there mayor may not
exist a bi-tree which is either an s-extension or p-
extension of T. (Of course, the symmetry of the defi-
nition implies that if T has an s-extension B then it
also has a p-extension B', and vice-versa.)
Theorem 1:
A given t-ary tree T = (N,nO'S) is the p-tree
associated with some bi-tree B is and only if all
n EN, 0 E I, and w E L*,
Pl'oof:
Suppose that T is the p-tree associated with the
where W (W) is the walk function associated with thep s
tree T (T), and [W (n)]r is the reverse of W (n).p s s s
We call the tree Tp the p-tree associated with B,
and the tree T the s-tree associated with B. We also
s
n = S (nO ,ow) ~ there exists an' E N
such that n' S(nO'w). (2 )
(3)
bi-tree B • (N,nO'Sp'Ss)' so that T • (N,nO'Sp). It
follows from Lemma 1 that if n - sp(nO'ow) then
n • 5s(nO,Wra). Consider the node n' • Fs(n) •
ss(nO,wr ). Lemma 1 also implies that n' - 5p (nO'W).
and (2) is established.
Now assume that (2) holds. Let Wdenote the walk
function of T, and define B • (N,nO'S ,S ) by S - SP s P
and for all n E Nand 0 in L,
S (n,a) - S (nO'OW (n)).s p p
We must establish that (BI) , (B2), and (B3) hold
for B. Certainly, T - (N,nO'S ) is a t-ary tree. Top p
show that T
s
= (N,nO,5s ) is a t-ary tree, and to es-
tablish (B3) , we prove by induction that the function
W defined inductively in terms of S by (WI) and (W2)
s s
above is well defined and satisfies
(B3) [W (n)]r = W (n) for all n EN.
s P
The induction is on the length of W (n). If Zg(W (n»
p r P
= 0, then n = nO' and from (WI) we have [Ws(nO)] =
A • W (nb). Also, since the range of S does not in-p s
elude nO' the value of Ws(nO) is well defined by (WI)
and (W2).
The inductive hypothesis is that if n' is any node
with Zg(W (n'» = k, then (B3) holds for this node,p
and that the value of W obtained from (3), (WI) and
. s
(W2) is well defined. Let n be a node such that
W (n) = aw, where Zg(w) • k. From (1) we have thatp
n = Sp(no'ow) , so (2) implies that there exists a
(unique!) n' E N such that n' = Sp(nO'w). Using (1)
once more, we obtain w = W (n'). Thus, from (3),p
5 (n' ,a) = 5 (no,aw) = n. The inductive hypothesis
s p
·allows that Ws(n') is well defined, and since (W2) de-
fines Ws(n) in terms of Ws(n') we can see that Ws(n)
is also well defined. The inductive hypothesis also
establishes that W (n') = [W (n,)]r • wr • Finally, we
S p r r
may deduce that Ws(n) = Ws(n')a = w a = (ow) =
[W (n)]r. This completes the induction and the proof.p
QED
We now relate the concept of a bi-tree to that of
a string. First, however, consider the basic problem
of finding a match 'of a given pattern P of length 1
with another string S of length £', where 1 t ~ 1. That
is, find positions i and j within 8 such that P =
8(i:j) = 8(i) 8(i+l) .•• 8{j). Clearly, if P does
r .
match some substring of 8, then P - P (1) •.• P (1), the
reverse of P, a1so matches a substring of 8 r • This ob-
servation implies that every technique which solves a
pattern matching problem working from left to right has
a dual procedure which works from right to left. In
what follows, we adopt a left to right viewpoint, re-
ferring only briefly to dual concepts as appropriate.
With this understanding, we henceforth assume (for
purely technical reasons) that every string 8 E L* ends
in a symbol which does not occur elsewhere in 8. Also,
when we refer to the substring located at position i of
8, we mean that 8 (i) is the leftmos t symbol of the
substring.
3
Definition:
The prefix-tree associated with string 8 over
L • {OI, ••• ,Ot} is a t-ary tree Tp = (N,nO'Sp) with
exactly Zg(S) leaves such that there is a bijective
pointer function J from the set of leaves of T to thep
set of positions within 8 such that if j - J(n) then
W (n) is the minimal length unique substring of 8p
whose leftmost symbol is located at position j of S.
That is, W (n) = S (j:k) occurs only once in Sandp
S (j :k-i) occurs at least twice in 8. We call I (j) •
S(j:k) the prefix identifier associated with position j.
(The concept of suffix tree may be similarly de-
fined for strings with left endmarkers.)
The assumption that S has a unique endmarker on
the right insures that every position of S has a pre-
fix identifier. This implies that there is exactly one
prefix-tree associated with a given 8. Moreover, if n
is any node of the prefix-tree of 8, then W (n) is a .p
substring of S. Indeed, the substring W (n) occurs atp
every position J(n') of 8 such that n' is a leaf of the
sub-tree whose root is n. Consequently, the minima1ity
condition concerning W (n) implies that the index ofp
any father of a leaf is greater than one, and that
every leaf node has a brother.
Figure 2 shows the prefix-tree associated with
the string S = 011010 ~.
As may be surmised from our choice of terminology,
the prefix-tree associated with any string 8 has an
s-extension.
Theorem 2:
For every string 8 over L, there exists a bi-tree
of S, BP = (N,nO'Sp'Ss) such that (N,nO'Sp) is the pre-
fix-tree associated with S.
Proof:
Consider the prefix tree T = (N,nO'S ) asso-p p
ciated with 8. We first show that if node n EN is
equal to S(nO'ow) for some a E L, w E L*, then there
exists a node n' = sp(nO'w) in N. The assumption that
n - S (nO'ow) implies that W (n) = ow, so aw must be ap p
substring of S. Moreover, either ow occurs at least
twice in 8, or aw is a prefix identifier of S. If ow
occurs more than once, so must w; if aw is a prefix
identifier, then either w is a prefix identifier or w
occurs more than once, since every prefix of w must
occur more than once. In either case, there is a node
n' with W (n') = wand S (nO'w) = n'. Theorem 1 canp p
now be directly invoked to complete the proof.
QED
From the proof of Theorem 1, recall that the s-
tree T = (N,nO'S ) of BP is defined by (3). We call
s s
the bi-tree BP the prefix hi-tree associated with S.
(It is also true that there exists a suffix hi-tree
associated with every string S with a left endmarker.)
As will be shown in Section IV, linear-time and
linear-space algorithms for certain pattern matching
problems can be derived assuming that an appropriate
prefix-tree is pre-calculated. We have been unable to
find efficient methods for directly obtaining a prefix-
tree. But as we show in the next section, efficient
methods exist for calculating the prefix bi-tree whose
p-tree is the desired prefix-tree; more important, a
linear-time, linear-space algorithm for obtaining a
compacted prefix bi-tree will be exhibited.
III. Computation of Prefix Bi-Trees and Compacted
Prefix Bi-Trees
It is well to consider first a direct method for ob-
taining the prefix-tree associated with a given string
S of length m.
Our direct method is an iteration of an algorithm
to compute the prefix-tree Ti of the suffix substring
S1 :II: S(i:m) assuming that the prefix-tree T1+l of the
suffix substring 8 i +l • 8 (i+1:m) is known. The follow-
ing lennna provides' the theory which both motivates the
algorithm and which can be used to prove its correct-
ness. Its usefulness in this regard is based on the
observation that the prefix-treeT of a string 8 is
completely determined by the set I - {I (j )11 ~ j ~ m}
of prefix identifiers.
Lemma. 2:
Let I i +l = {Ii +1 (j)Ii <j ~ m} be the set of pre-
fix identifiers of 8 i +l = 8 (i+1:m) and let Ii be the
set of prefix identifiers of 8 i • Define wto be the
longest prefix of 8 i which is also a prefix of some
element of I i +l . If @~ I i +1 (jO) for some jo' th~n
Ii (j) = 1i +1 (j) when i < j ~ m and l i (i) =
w8(i+lg(w). Otherwise, if w- I i +1 (jO)' then Ii(j)·=
I i +l (j) when i < j :§ m and j " jo' Ii(jO) =W =
8(jO:jO+lg(w)-1) and Ii (i) = S(i:i+Zg(w)-l), where W
is the shortest prefix of 8. which does not equal a
prefix of Si. Jo
Proof:
Suppose first that wis not an element of I i +l ,
and consider the prefix of 8 i given by wS(i+Zg(w).
This string is the shortest prefix of Si which is not
a prefix of any element of I i+l ; conversely, no ele-
mentof I i +l is a prefix of this string. Thus the
prefix identifiers of Siare given by Ii(j) = Ii+1(j)
for i < j :§ m and Ii (i) = CD 8 (i+Zg(w) ).
Now suppose that w= I i +l (jO). Surely, wis' not
a prefix of any other member of I i +1 , nor can any mem-
ber of I i +1 other than Ii+l(jO) be a prefix of w. This
insures that for i < j ~ m and j ~, jo' Ii (j) = 1i +1 (j).
Ii(jO) and Ii(i) must each be stri'ngs which are of
length one greater than the length of their Largest
common prefix, say w. Thus, Ii (jO) = W= w8 (jO+Zg(w»
;=; S (jo :jO+Zg(W)-l) and Ii (i) = WS (i+Zg(W) ) =
S(i:i+hg(W)-l). Clearly, wis the shortest prefix of
Sj which does not equal a prefix of 8 i •
QED
The two cases described in the proof of Lemma 2
have interesting analogies in the tree Ti +l • In'the
first case Ii is an internal node and Ti may be formed
by addin~ the leaf ni (with J(ni ) = i) to Ti +l by con-
necting it to Ii with a branch labelled 8 (i+lg(w) ). In
the second case, n is the leaf with J(n) = joe Here,
n must be replaced by a two-leaf stilitree rooted at n.
The node ~ is the leaf with J(~) = jO.The other 1e~f
of the subtree, ni , has J(ni ) = i. These two nodes,
4
as well as any other nodes in the subtree between the
root n and the two leaves must also be added to Ti +1
to form Ti • In the first case, we say that Ti is ob-
ta~ned from Ti +l by a type 1 construction; in the sec-
ond case, by a type 2 construction. ltis also useful
to distinguish three subcasesof a type 2 construction:
2a)Ii -= Ii is, the father ,of fi, .2b) n is the father of
n (the father of n), and 2c) Ii is an ancestor (but not
the father) of n.
Figure 3 illustrates these cases and our nota-
tional conventions.
In all cases, the calculation of Ti from Ti +l
suggested by the Lenuna first locates the,node n. Algo-
rithm D, below, implements this calculation by walking
Ti +l from the root nO by traversing the branches which
are labelled with symbols from the'prefix of Si.
We assume that at the beginning of the algorithm
Ti +l is available as a set of nodes Ni+land a func-
tion S defined for Ni +1 x L:. The construction of Ti
forms N1 by adding nodes to Ni+1• (When a new node is
added, we assume that all unspecified values of, S,
etc., are initialized to NIL.) It is also convenient
to associate with each node n a label J which is the
n
position in 8 1+1 of the (rightmost, if riot unique) sub-
string w= Wen). (Note that I
n
is consistent with the
pointer function J(n) in that if n is a leaf,
I
n
= J (n).)
Algorithm D (Direct construction of Tifrom T i +l )
DI. [Initialize] Set 11 +- nO andk+ O.
D2. [Find Ii] If S(Ii ,S (i+k») = NIL go to D3; other-
wise, setn+ S(n,S(i+k»), increment k, and re-
peat step D2. (When D3 is entered, W= W(ii).)
D3. [Is Ii a leaf?] Set Ii + Ii. IfS(n,S(Jn+k» ~ NIL
go to D6. (This is the case., that Wis not a· pre-
fix identifier of Ti+1 .)
D4. [Move leaf]' Add node fi and connect to Ii by set~
ting Sen ,5(Jii+k» + n. Label the leaf by settingJA + J ..•
n n -
DS. [Compare symbols of 8] If S (i+k) equals S (I
n
+k)
set Ii + fi, increment:· k, and go t9 D4.
D6. [Add ni to tree] Add node ni and connect to Ii by
setting S (n ,8 (i+k») + n i • Label the leaf by set-
ting J" + i. Stop. (At this point ~ is the
n i
father of n i .)
The prefix-tree of Scan be obtained by success-
ively deriving the prefix-trees of B .,8 1, ••• ,S2'm ro-
Sl • 8. Figure 4 shows several steps in atypical
calculation.
Note that at E;!ach iteration as many as O(Zg(8i ))
steps may be required. There are miterations, and it
may easily be' shown that the total number of steps can
be, of 0(m2). What's worse, it may be seen that this
algorithm ieat bestO(mlog m).
We now turn to the problem of finding the prefix
bi-tree Bi corresponding to Si given the prefix bi-
tree Bi+l. Our method is based on a' relationship be-
tween I i +1 (i+l) and Ii(i) which is described in the
following lenuna.
Lemma 3:
Suppose that the symbol 8 (i) occurs wi thin the
string 8 i +l , and let w' be the longest prefix of
Ii+l(i+l) which occurs at some position other than
i+l, say jO+l, such that 8 (jO) = 8 (i). Then
Ii (i) = 8(i)ji'8(i+Zg(w')+1).
Proof:
Since Ii+l(i+l) is a prefix identifier of 8 i +l ,
it can occur only once in 8i +1 and clearly
8 (i )Ii +l (i+l) also occurs exactly once in 8 i • Thus
Ii (i) is of the form 8 (i~:i, where wi is a prefix of
I i +l (i+l). Since we have assumed that 8(i) occurs
within 8 i +l , Zg(w~) ~ 1, and we can write w~ =
w'8(i+Zg(w')+1) and be sure that w' occurs at least
twicet in 8 i+1 , This implies that w' is the lon~est
prefix'of I i +l (1+1) which occurs at some position other
than i+l, say jO+l, such that 8(0) = 8(i). We have
just established that Ii (i) 8 (i)w~ =
8 (i YJ' 8 (i+Zg(w' )+1).
QED
In those situations where 8(i) does not occur
within 8 i +l , it is trivial to show that Ii(i) = 8(i).
We now wish to draw out some important relation-
ships between the strings defined in the preceding
lemmas and proofs.
In the proof of Lemma 2, we have used n to repre-
sent the father node of ni , where Wi = Ii(i) = Wp(ni )
in Bi. It follows from Lemma 3 that w= 8 (i 'jJ'" where
w' is the longest prefix of wi +l = I i +1 (i+1) which
occurs elsewhere in 8 i+l with 8 (i) to its left. This
relationship implies that 0 and 0' are related by
o = S (n' ,8 (i» in the prefixbi-tree B~. Similarly,
s 1
if fi' = S(Ii' ,a), where a = 8 (jo+Zg (w' )+1), it may be
seen that fi = Ss (fi' ,8 (i » • Indeed, all ances tors 0 f
fi except for nO are s-sons of ancestors of fi' with
branches labelled by 8 (i ). In particular, the node Ii'
which is the closest ancestor of 0' having a non-NIL
s-son labelled 8 (i) in Bi+l plays an important role in
forming B~, since all ancestors of fi' which are de-
1
scendants of n' will be s-fathers of nodes in B~ that
1
do not exist in Bi+l. Note that the situation n' = 0'
corresponds to the condition w # I i +l (jO)' and ni is
Ph' BP (Ththe only node in Bi w ich is not 1n i+l. is re-
quires a type 1 construction.) Also, when n' is an
ancestor of fi', a sub-tree with leaves ni and fi must
be added to Bi+l to obtain Bi. (This requires a type
2 construction.) This sub-tree is rooted at node n
and Wen) = w= I i +l (jO). In all cases, n i =
S (n! ,8(i», where n! = Sen' ,a) for a = 8(i+lg(w')+1).
s 1 1
Figure 5 illustrates the notation by showing part of
p p
the prefix bi-trees Bi+l and Bi .
t By convention, we assume that the empty string,
A, occurs at every position of 8 i +l .
5
Lemma 3 and the relationships just described sug-
gest that each node of the prefix bi-tre~hBi+1 be
labelled with a t-long vector Ln. The j component
L
n
(j), 1 ~ j ~ t, is set equal to NIL if the substring
ajw(n) does not occur within 8 i +l ; if ajW(n) does occur
within 8 i +1 , then Ln(j) is the (rightmost, if not unique)
position of 8 i +l such that ajW(n) is a prefix of
8 L (j)-l. Note that I n is now simply the largest non-
n
NIL component of L
n
, unless I
n
= i+l. Note also that
if position jo is contained in the vector L
n
, then some
p-leaf of the p-sub-tree rooted at n corresponds to the
prefix identifier located at position joe
Algorithm B, below, calculates a labelled Bi from
a labelled Bi+l. It begins by walking from node ni +l
towards the root until the node n' is reached. This
node is identified by the fact that it is the first
node reached with a non-NIL L
n
, (j), where 8 (i) = aj •
The node below n' on the path from ni +l i.s the node ni
and ni will eventually be installed as the s-son under
a j of ni and as a p-son of n. Also, if node n is not
already present (as determined by examining the s-
branch ofn' labelled 8 (i» a sub-tree rooted at n is
p b P IV hadded to Bi +l to 0 tain Bi • The node n, which is t e
nearest ancestor of n already in Bi+l' is located by
walking from ii' towards the root until a node n' is
reached with a non-NIL s-branch labelled 8(i). The
node Ii is the s-son of Ii' just found. It should now
be clear that ~he primary role of the s-tree is to de-
termine efficiently whether a node required in Bi is
already present in Bi+l.
All of the functions and labels used in Algorithm
D are also used in Algorithm B. In addition, we use
the vector label L
n
as discussed, as well as the p-
father function F, the s-successor function Ss' and a
label LG
n
which gives the value of 19(W(n».
Algorithm B (Efficient construction of Bi from Bi+l)
Bl. [Initialize] Set n' ~ ni +l and set j to the index
of 8 (i). (W(ni +l ) = I i +l (i+l) and 8 (i) = aj.)
H2. [Check label) If Lii,(j) = NIL go to step B3;
otherwise go to step B4. (When B4 is entered,
W' = W(n').)
B3. (Label and walk] Set Ln,(j) ~ i+l and n~ ~ u'.
If ni # nO' set ii' ~ F(ni) and go to step B2;
otherwise set Ii ~ nO and go to step B7.
B4. [Find n'] Set n ~ S(n' ,8 (Lii' (j )+LGii , » •
BS. (Is fi in Bi+l?) If Ss(n' ,aj) ~ NIL, set
ii ~ S (n' ,a.) and go to step B7. (This is the
s J
case when wis not a prefix identifier of 8 i +1 .)
B6. [Add n and ancestors] If S (F(n'),o.) = NIL, use
s J
an implicit pushdown stack to save fi' and repeat
this step recursively with n' equal to F(n').
(When this point is reached, S (F(n'),o.) ~ NIL.)
S J
Set n ~ S (F(n'),O.) add node n by setting
s J
S(n,8(Jil+LGri » +n, F(n) + ii, and Ss(n',Oj) +n.
Label n by setting I n + I n, LGn + LGn ,+l, and
Li1 (k) + Lri(k) for 1 ~ k ~ t.
B7. [Add ni ] Add node ni by setting S(n ,8 (i+LGn»
+ ni , F(ni ) + n, and Ss(ni'Oj) + n i • Label ni
by setting J + i, LG + LG ,+1, and
n i n i n i
L (k) + NIL for 1 ~ k ~ t. Stop.
n i
As with our direct method, the prefix bi-tree of
S, BP , can be obtained by successively calculating
B~,B~_l'··· ,Bi = BP. We now show that the total num-
ber of operations in this process is O(k), where k is
the number of nodes in BP • Notice that every time
Algorithm B is executed, a constant number of oper-
ations is performed, except in stepsB2, B3, and B6,
which may be repeated several times. However, every
time these steps are executed, labels are added to the
tree, and these labels are never modified. It follows,
since there are only O(k) possible labels, that the
total number of operations is also of O(k). Unfor-
tunately, Figure 6 shows a string whose prefix-tree has
2O(n ) nodes. Thus, while we have certainly described
an efficient method for finding prefix bi-trees, this
is not directly useful in obtaining linear pattern
matching algorithms.
In order to overcome the difficulties associated
with the large number of nodes possible in a prefix-
tree, we introduce a structure called a compacted
prefix-tree.
Definition:
Let T = (N,nO'S) be the prefix-tree associated
with string S. The compacted prefix-tree of 8 isa
structure TC = (Nc,notSc)~ where NC ~ N is specified
by
the degree of n in T is at least two, Dr
n E NC ~ the degree of F(n) in T is at least two.
For every n' E NC and 0 such that S (n' ,0) :;. NIL, let
w' = ow" be the shortest substring such that 5 (n' ,awn)
= n tl E NC. We define SC, a function from NC x E to
(NC-{nO}) U {NIL} by
SC(n',a) {NIL if S(n',a) NIL
= S(n' ,aw") otherwise.
Observe that every internal (non-leaf) node in NC
with degree one has as its only son a node of degree
two or more. It is easy to show that every t-ary tree
with k leaves that does not contain any internal nodes
of degree one has at most k-l internal nodes (see [7],
pages 399-404). From this fact, it follows that the
number of nodes in a compacted prefix-tree associated
with a string of length m cannot exceed 2 (m-l)+m =
3m-2. Thus, size considerations alone do not rule out
the possibility of a linear algorithm to compute TC •
But as with non-compacted prefix-trees~ we find it use-
ful to compute instead a related compacted prefix
bi-tree.
Definition:
Let BP = (N,nO'S ,S ) be the prefix bi-tree asso-p s
6
ciated with string 8. The compacted prefix hi-tree of
p (Nc c c c8 is a structure C ~ ,nO'S ,5 ), where T . =
c c s c(N ,nO'S ) is the compacted prefix-tree of Sand S , a
p c c s
function from N x 2": to '. (N -{nO}) U {NIL} U {*} is de-
fined, for all n' E NC and a in E, by
NIL if 8
s
(n',0) = NIL
{Ss(n' ,a) if S9(n' ,a) E NC
* otherwise.
In order to derive a useful characterization of
those non-NIL s-branches of BP which also occur in CP,
we present the following lemma.
Lemma 4:
Let n # nO be a node of BP = (N,nO,Sp,8s ) with de-
gree d
n
(in Tp ) and let n' = Fs(n) have degree dn ,.
Then dn , ~ dn --
Proof:
If n is a leaf of T ,d = 0 and surely d , ~ d •p n n - n
Consider, then, a son of n, say n = 8 (n,a), and let
A p
fi' = Fs(n) with n = Ss(n 1 ,0). From the definition of a
bi-tree, it follows that w = Wen) = aw', where
w' = W(n'). But W(n) = aw'&, so Wen') = w'8. It
follows that S(n',a) = u'. Thus, for every son of n
there exists a son of n', and the lemma is established.
QED
Our desired characterization of SC can now be es-
tablished. s
Theorem 3:
Let cP = (Nc,nO'Sc,sc) be the compacted prefix bi-p s
tree of the string 8. If n :;. nO is a node of CP , then
there exists a node n 1 E NC and a 0 E L such that
SC(n' a) = n.
s '
Proof:
Let BP = (N,nO'S ,S ) be the prefix bi-tree of S,P s
and let n' = Fs(n). If d
n
~ 2, then d
n
, ~ 2. Let
n = F(n) and n' = Fs(n) = Fs(n) = F(n'). If dn ~ 2
then d- 1 ~ 2. But n is a node in NC and either d- ~ 2n - n -
or dn ~ 2. It follows that node n' = Fs(n) is also a
node in Ne . Clearly, there also exists a a E E such
that SC(n',o) = n.
s
QED
What we have just shown is that every n 1 no in NC
has both a p-father and an s-father. A consequence of
this fact is that TC = (NC,nO'Sc) is also a t-ary tree
s s
when both NIL and * values of SC are taken to be
pointers to empty sub-trees. s
The difference between NIL values of SC and *
s
values of SC is important to our algorithm for calcu-
s
lating Cp . This procedure differs from Algorithm B in
two important respects. First, when a type 2c construc-
tion is required, the father of ni and fi, n, is connecte~
C2.
C3.
C5.
Cl.
for 1 ~ k ~ t. Stop.
Remark:
Several of the steps in Algorithm C could well be
combined into a parametized procedure.
To obtain the compacted prefix bi-tree cP for a
string S of length m, successively obtain CP,CP 1' ... '
m m-
Ci = CPo The run time of this procedure is of Oem),
but in order to demonstrate this, we need to develop a
few new ideas; step Cll of Algorithm C may be executed
several times, and no labels are added, so the analysis
used for Algorithm B does not apply.
Let ci = (N~,nO'S;,s~) be the compacted prefix bi-
tree of 8 i with node ni having W(n i ) = Ii(i). Define
the Height of node n in Ci, hi(n) to be the number of
distinct ancestors of n in ci. We wish to show that
the number of steps executed in Algorithm C in con-
structing C~ from C~+l is of 0(0,), where 0. =
1 1 1 1
hi+l(ni+l)-hi(ni)+l. (The constant insures that
0i ~ 0.) First, observe that Theorem 3 insures that
every ancestor of ni except for nO has an s-father in
ci+l which is an ancestor of ni +l . This implies that
hi(ni ) :§ hi+l(ni)+l.
Next, observe that all steps in Algorithm Care
executed exactly once, except possibly steps C2, C3,
C7, and CII. Steps C2 and C3 are executed
hi+l(ni+l)-hi+l(n') times. In the case of a type 1 con-
struction which requires insertion, step Cll is exe-
cuted hi +l (n')-hi+l(ni) times; in the case of a type 2b
or 2c construction, step C7 is executed hi+l(n')-hi +l (n')
times. Thus the total number of C2, C3, C7, and CII
steps in the case of a type I construction without in-
sertion or a type 2a construction is h.+l(n.+l)-h (n')-
1 1 i+l '
for the case of a type I construction with insertion the
total number is hi+l(ni+l)-hi+l (ni), and when a type 2b
or type 2c construction is required, hi+l(ni+l)-hi+l (n').
But hi(ni ) ~hi+l(n)+3, where n is ii', n', or nf. Thus,
in all cases the total number of steps in Algorithm C is
of order hi+l(ni+l)-hi(ni)+l.
To prove that cP can be found in time O(m) , observe
t m- l .Li=l 0i = m+hm(nm)-hl(n l )· Slnce hi(ni ) ~ m-i+l,
t m- lLi=l 0i is ~f Oem).
C14. [Add nil Add node ni by setting SC Cn ,8(i+LGii »)
+- ni , FCCni ) +- n, and s~(n~'Oj) +- ni . Label ni by
setting J ~ i, LG +- LG ,+1, and L (k) +- NIL
ni ni ni ni
C13. (Insert ~, if required] If SC(n',o.) ~ *, go to
s J
step C14. Otherwise, set n ~ sC (n f ,8 (J +LG »)s n f n f
and insert n between n f and ns by setting
SC (n f ,8 (J +LG » +- n, F
C(n) +- n f ,n f n f
SC(ii,8(J +LG +1») +- ii , FC(n ) +- ii, and
n f n f s s
SC(n' ,OJ) ~ n. Label ii by setting J .. ~ I
n
'
s n f
LG
n
+- LG
n
,+1, and L.. (k) +- L (k) for 1 ~ k ~ t.
n n f[Initialize] Set n' ~ ni +l and set j to the in-
dex of 8(i). (W(ni +l ) = I i +l (i+l) and
8 (i) = a,.)
J
[Check label] If Ln,(j) = NIL go to step C3;
otherwise go to step C4. (When C4 is entered,
w' = W(n').)
[Label and walk] Set L
n
, (j) ~ i+1 and ni +- ii' .
If n~ :; nO' set ii' +- FC(ni) and go to step C2.
Otherwise, set ii +- nO and go to step C14.
[Find il'] Set il' +- SC (n' ,8 (1.. , (j )+LG.. , »).
n n
[Is il in B~+l?] . If SC(6',o.) :; NIL, go to step
1 s J
ClO. (This is the case when Wis not a prefix
identifier of 8i +1.)
[Is .. i cP ? ] If Sc ( .. , )..J. NILn n i+l' s n ,OJ T ,go to step
C9; otherwise, set n' +- FC(n').
[Find 0] If S~(o' ,OJ) :; NIL, set n +- s~(n' ,OJ)
and go to step C8; otherwise, set s~(n' ,OJ) +- *,
0' +- FC(n'), and repeat step C7.
[Add Ii] Add node n by setting SC(n,8(J_+LG_»)
n n
+- ii, FC(ii) +- n, and s~(n"Oj) +- Ii. Label ii by
setting J ii +- I n, LGn ~ LGnt+l, and Ln(k) +- Lo(k)
for I :§ k :§ t. (Note that LGii ~ LGn+I.)
[Add 6] Add node 6 by setting SC (n ,8 (J ..+LG.. »)
n n
+- 6, FC(6) +- n, and S~(n' ,OJ) +- n. Label 6 by
setting J
u
+- J ii , LG6 +- LGn,+I, and Lu(k) +- Ln(k)
for I :§ k :§ t. Go to step C14 •
[Is insertion needed?] If S~(6' ,OJ) :; * and
SC(n',O.) :; * go to step C14; otherwise, set
s J
nf+-n'.
CII. [Find father] If s~(nf'Oj):; *, set nf +-
s~(nf'Oj) and go to step C12. Else, set nf +-
FC(nf ) and repeat step Cll. (This step must
terminate, by Lemma 3!)
C12. [Insert 0, if required] If s~(n"Oj) ~ *, go to
c
step C13. Otherwise, set n +- S (nf ,8 (J +LG »)s n f n f
and insert n between n f and ns by setting
SC(nf ,8(J +LG ») +- n, FC(n) +- nf ,n f n f
Sc (n ,8 (J +LG +I ») +- n , Fc (n ) +- 6, and
n f n f s s
SC(6',o.) +- 6. Label n by setting JA +- J ,
s J n n f
LGA +- LGA,+l, and LA(k) +- L (k) for 1 ~ k ~ t.
n n n n f
CIa.
C9.
C6.
C7.
C4.
CB.
directly to n. Second, when a type 1 construction is
required, but either n or n is not already present, an
insertion is made between two nodes in the tree.
As before, let C~ be the compacted prefix bi-tree
1
of 8 i . Algorithm C computes Ci from Ci+l. (Note that
LG
n
gives the length of the walk 19(W(n) in the non-
compacted prefix bi-tree.)
Algorithm C (Construction of Ci from ci+l)
7
IV. Applications
In this section, we indicate how to use compacted
prefix-trees to solve various pattern matching prob-
lems in linear time.
Problem 1: (Basic Pattern Matching Problem)
Given a string S of length ~l' and pattern P of
length £2' find all positions i of S such that
P = S (i : i +£2 -1 ).
Solution:
Append a right end marker to S and construct TCp
'using Algorithm C. Determine whether any prefix of P
is a prefix of some prefix identifier of S, or vice
versa by walking from the root of r C following branchesp
labelled with symbols from P. If, at some stage of the
walk, a node n is reached at level LG
n
and labelled
with J , check the value of SC(n,P(l+LG »). If this
n n
value is NIL and if n is not a leaf, then P does not
match S anywhere. If n is a leaf, then P can pos-
sibly match S at only one position, namely I
n
• To see
whether the match is valid, check for identity of
P (l+LG
n
+k) and 8 (J
o
+LG
n
+k) for k = 0, ..• '£2-LGn-1.
(If In+~2-l ~ £1' no match exists.) Next, consider
the case SC(n,P(l+LG ») = n'. If LG , = LGn+l, simply
n n
continue the walk. On the other hand, if LG
n
, = LGn+q,
and q > 1, then it is necessary to compare P(l+LGn+k)
and S(Jn+LGn+k) for k = 1, ... ,q-l. Lack of equality
for any k indicates no match; equality for all k allows
the walk to be continued. Finally, consider the case
where a LG
n
= £Z. In this event, each leaf in the
sub-tree rooted at n is labelled with the position of
a match within 8. A simple tree walk of this sub-
tree finds these positions.
Problem 2: (Pattern match of several patterns
with one string)
Given a string S of length £' and patterns
Pl,PZ, ... ,Pq of lengths i 1 '£2' ••• '£q' find all matches
of each pattern in 8.
Solution:
Simply walk each pattern individually through r C
, p
as in the solution to Problem 1. Note that the total
effort is of O(£'+£l+••• £q). Note also that the
Knuth-Pratt-Morris technique does not fare as well for
this problem, since every symbol of 8 is examined i'
times. However, Karp [8] has extended their technique
and has developed an alternate linear time solution to
Problem 2.
Problem J: (Internal Matching)
Given a string 8 of length £, find for each posi-
tion i in 8 another position P(i) in 8 such that the
longest common prefix of 8 i and Sp(i) of length M(i)
is no shorter than the longest common prefix of 8 i and8 ., j =1 i and j ~ P(i) .
J
Solution:
Append an endmarker to 8 and construct TC • Lo-p
cate (in constant time) the leaf n labeled I
n
i. If
n f is a brother of n, then P(i) = I
n
, and the maximal
match is of length M(i) = LGn-l.
Problem 4: (External Matching)
Given two strings Sand S, of lengths £ and £,
find for every position i in S the position P(i) and
length M(i) of the longest match S(i:i+M(i)-l) =
S(P(i) :P(i)+H(i)-l).
Solution:
Fonn the string S = S:S ~ where ":" is a distinct
separatDr symbol, and construct the compacted prefix-
tree TC of S. We proceed as in the solution to prob-p
lem 3, except some care must be taken not to find
matches entirely within S. Assume that M(j) and P(j)
have been obtained for i+l ~ j ~ I. To obtain M(i)
and P(i), walk from the leaf 0 labelled with J
n
= i
towards the root until a node n f is found with I
n
, > i.
(From the definition of J, I
n
, ~ J
n
when n' is an
ancestor of n.) If I
n
, > T, then P(i) = I
n
, and
M(i) = LG
n
,; otherwise~ P(i) = P(J
n
,) and M(i) M(J
n
,).
Note that the total number of steRs in finding P(i)
and M(i) for I ~ i ~ I" is of 0 (r+~) since each node in
TC is examined at most two times. This construction ofp
the match function M and the position function P has
direct application to the File Transmission Problem, as
discussed in [9]. Note also that Problems 1 and 2 can
be solved with variants of this solution.
We leave it to the reader to work out the variants
of our methods required to solve Problems 1 and 2 of
[4] for strings.
Discussion:
The techniques of this paper do not appear power-
ful enough to solve directly some interesting related
pattern matching problems. For example, .when "don' t-
.care" elements are introduced, the best known results
[5] suggest that an n log n algorithm may be possible,
but none has yet been found. Also, the "sub-sequence"
problem, mentioned in [6], has, at present, only an
n
2
solution.
Acknowledgments
This work was stimulated by extensive discussion with
Robert W. Tuttle of Yale. Discussion with Albert R.
Meyer, Michael J. Fischer, and Vaughan R. Pratt, all of
MIT, helped develop the exposition. Also, a careful
reading of the manuscript by Andrew H. Sherman of Yale
led to several changes and improvements.
References
1. Morris, James H., and Vaughan R. Pratt, "A linear
pattern-matching algorithm," TR-40, Computing
Center, University of California at Berkeley, 1970.
2. Knuth, Donald E., and Vaughan R. Pratt, "Automata
theory can be useful," unpublished manuscript.
3. Cook, S. A., "Linear time simulation of deter-
ministic two-way pushdown automata," Proceedings of
IFIP Congress 71 (PA-2), North-Holland Publishing
Co., The Netherlands, 1971, 174-179.
4. Karp, Richard M., Raymond E. Miller, and Arnold L.
Rosenberg, "Rapid identification of repeated pat-
terns in strings, trees and arrays," Fourth Sym-
posium on Theory of Computing, May 1972, 125-136.
5. Paterson, M. S., "String-matching and other pro-
ducts," presented at a congress sponsored by the
Istituto per Ie Applicazioni del Calcolo del
8
Consiglio Nazionale delle Richerche, Rome, Italy.
1973, 14 pages.
6. Wagner, Robert A., and Michael J. Fischer, "'The
string to string correction problem," unpublished
manuscript, 13 pages.
7. Knuth, Donald E., The Art of Computer Programming,
Volume 1, Fundamental Algorithms, Addison-Wesley,
Reading, Massachusetts, 1968, 305-422.
8. Karp, Richard M., personal communication.
9. Weiner, Peter, and Robert W. Tuttle, "'The file
transmission problem," to be presented at the
National Computer Conference, New York City, June
1973. Yale Computer Science Research Report #16.
"0
n8
"5
s-branches shown as dotted line
L={O, I}
N={no, ••. , ns }
Figure 1. A bi-tree with 9 nodes.
S=8(1) ... s(7)
= Ol1010t-
6
o
o
5
Figure 2. Prefix-tree of S.
9
Type 1 construction.
(0)
n =n
A
n
n = n
Type 20 construction.
(b)
"
"'.Ah
2b constructi on .
(c)
Figure 3.
Type 2c construction.
(d)
5
o
6
o
7 4
8=8<1> ••• 8<7>
= 100100
o
1-
7 4
o
A5
4
Figure 4.
10
"n
3 "
2 ,0
o
nl
o
o
S :::S<.n •• , 5 <.\7)
~ O' " 0 4 ,.4 \-"
A\\ Ss blanches shown
\ clotted \i nes) are
\obe\\ed with S<'i) •
......
........
..........
---
-------~...,.,..
figure 50. Some branches hOl'll ~ i +' ·
n \.t'
-'n
11
