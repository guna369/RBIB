Mechanizing Veri cation of Arithmetic Circuits: SRT Division ?

Deepak Kapur1 and M. Subramaniam2??

1 Computer Science Department, State University of New York, Albany, NY 12222

2

Functional

Veri

cation

kapur@cs.albany.edu Group, Silicon Graphics Inc.,

Mountain

View,

CA

94040

subu@mti.sgi.com

Abstract. The use of a rewrite-based theorem prover for verifying
properties of arithmetic circuits is discussed. A prover such as Rewrite Rule Laboratory (RRL) can be used e ectively for establishing numbertheoretic properties of adders, multipliers and dividers. Since veri cation of adders and multipliers has been discussed elsewhere in earlier papers, the focus in this paper is on a divider circuit. An SRT division circuit similar to the one used in the Intel Pentium processor is mechanically veri ed using RRL. The number-theoretic correctness of the division circuit is established from its equational speci cation. The proof is generated automatically, and follows easily using the inference procedures for contextual rewriting and a decision procedure for the quanti er-free theory of numbers (Presburger arithmetic) already implemented in RRL. Additional enhancements to rewrite-based provers such as RRL that would further facilitate verifying properties of circuits with structure similar to that of the SRT division circuit are discussed.

1 Introduction

There has been considerable interest recently in using automated reasoning techniques to aid in enhancing con dence in hardware designs. A number of researchers have been exploring the use of BDD based software, model checkers, theorem provers and veri cation systems for verifying properties of arithmetic circuits, cache-coherence protocols, di erent kinds of processors including pipeline, scalable processors, as well as a commercial processor. Papers on these attempts have appeared in recent conferences such as CAV and FMCAD.
Intrigued by these attempts and results, we decided to try our theorem prover Rewrite Rule Laboratory (RRL) 11] for hardware veri cation, with the main objective of exploring circuits and their properties that can be veri ed automatically in a push-button mode. We have also been interested in identifying extensions and enhancements to RRL which would make it better suited for this application. In 8] and 7], we discussed how RRL had been used for verifying ripple-carry, carry-lookahead and carry-save adders, as well as a family of multipliers including Wallace-tree and Dadda multipliers.
? Partially supported by the National Science Foundation Grant no. CCR-9712366. ?? This work was done while the author was at State University of New York, Albany.

Our experience in using RRL has been very encouraging. RRL can be used effectively, essentially in the push-button style, for proving number-theoretic properties of these circuits without having to require xing their widths. Parametric circuits can be veri ed; descriptions common to a family of related circuits can be given and reasoned about. Proofs of components can be reused while attempting proofs of larger circuits; as an example, while reasoning about multipliers, adders used in them can be treated as black-boxes insofar as they satisfy their speci cations.
In this paper, we discuss how RRL can be used for reasoning about SRT division circuits. After reading 2] and 18], we rst suspected that considerable user interaction with and guidance to RRL may be needed to verify the main properties of the circuit. The reported use of Mathematica and Maple in 2, 4] for reasoning about inequalities and real numbers, as well as the use of dependent types, table data structure, and other higher order features in 18] initially discouraged us from attempting a mechanical veri cation of the division circuit using RRL. We subsequently discovered to our pleasant surprise that the proof reported in 2] could be easily found using RRL without any user guidance; a brief sketch of that proof is given in 5]. In fact, the mechanization of that proof was the easiest to do in RRL in contrast to the proofs of adders and multipliers in 8, 7]. We have recently found a much simpler and easier proof of the SRT division circuit by explicitly representing the quotient selection table. (It is widely believed that the bug in the Intel Pentium processor was in the quotient selection table.) In this paper, we discuss this new proof. Later, we contrast this proof with our earlier proof attempt as well as proofs in 2, 18].
Four major features seemed to have contributed to RRL being e ective in mechanization attempts for hardware veri cation.
1. Fast contextual rewriting and reasoning about equality 23]. 2. Decision procedures for numbers and freely constructed recursive data struc-
tures such as lists and sequences, and most importantly, their e ective integration with contextual rewriting 6]. 3. Cover set method for mechanization of proofs by induction 24], and its integration with contextual rewriting and decision procedures. 4. Intermediate lemma speculation heuristics. In the next section, SRT division algorithm and circuit are informally explained, with a special focus on radix 4 SRT circuit. The interaction between the appropriate choice of radix, redundancy in quotient digits, quotient selection and remainder computations is brie y reviewed. The third section is a brief overview of the theorem prover RRL. Section 4 is an equational formalization of SRT division circuit description in RRL. Section 5 is a brief sketch of how the proof of the two invariant properties of the circuit was done using RRL. Section 6 is a discussion of related work, and our experience in using RRL for SRT division circuit. Section 7 concludes with some remarks on possible enhancements to RRL to make it better suited for verifying circuits using preprogrammed read-only-memory (rom).

2 SRT Division Algorithm and Circuit

The basic principles underlying the SRT division algorithm are reviewed. SRT division algorithm proposed by Sweeney, Robertson 17] and Tocher 19] has been frequently used in commercial microprocessors due to its e ciency and ease of hardware implementation 20, 22]. Several expositions of the design of hardware divider circuits based on this algorithm appear in the literature 20, 15, 16, 3].
The SRT algorithm takes as input, two normalized fractions, the dividend and the positive divisor, and outputs the quotient and the remainder. The focus in this paper is on this part of the division circuit as in 4, 2, 18]. It is assumed that a normalization circuit for handling signs and exponents is correct.
Much like the paper and pencil grade school division method, the SRT division algorithm is iterative, in which the quotient is computed digit by digit by repeatedly subtracting the multiples of the divisor from the dividend. In each iteration, the algorithm selects a quotient digit, multiplies it with the divisor, and the result is subtracted from the partial remainder computed so far. The result of the subtraction is the partial remainder for the next step. The partial remainder is initialized to be the dividend divided by r. The algorithm terminates once all the quotient digits have been computed. The algorithm can be formalized in terms of the following recurrences.

:= := 00 0P dividend=r; Q

;

Pj+1 := r Pj

qj+1

= 0divisor; f or j

;

;n

:= + = 0 1Qj+1

r Qj

+1qj ; f or j

; ;n

;

1;

w0qrjhisiesrrPtaehjdePi<xqj uudiosisvetdtiieshnfoeotrr,pdrfaieogrprittriaaealsltlerjinte,temiQrnaagjtiininosduntemhrje,baneqtruissto.httTehiehenbenteaugalmitingtbnnheimenrgeobnfeotgdfoiingftnihtthiesneigjnp-otathfhrtteiihatqeelurrioatetetmiireoaanntiti,n,odaanennrjdds,

and the multiples of the divisor being subtracted is achieved by left shifting the

partial correct

remainder positional

at each step placement of

(i.e., the

qbuyotmieunlttipdliygiintgisPsjimwiiltahrltyheenrsaudriexd

r). by

The left

shifting at each

the partial quotient. And, the invariant step, the highest multiple of the divisor

0 less

tPhaj n<thdeivpisaorrtiaelnrseumreasinthdaetr

is subtracted.

SRT dividers used in practice incorporate several performance enhancing techniques while realizing the above recurrence. An important issue in implementing such an algorithm in hardware is the selection of correct quotient digit at each step. A brute force strategy of enumerating the multiples of the divisor until the subtraction leads to a number that is less than the divisor could be prohibitively expensive. The SRT dividers instead use quotient digit selection functions in the form of look-up tables for guessing a quotient digit at each step of division based on the partial remainder and the divisor.

Two other major aspects resulting in the increased performance of SRT dividers are the choice of the radix in representing the quotient, and the choice

of a signed digit representation for the quotient digits. The former reduces the number of iterations required to get the quotient, and the latter reduces the time taken in each iteration by speeding up the partial remainder computation. In 20], tradeo s between speed, radix choice, redundancy of quotient digits, are discussed.
2.1 Choosing Quotient Radix
In an SRT divider using the radix 2, each iteration produces one quotient bit, and n iterations are required to produce a quotient of n bit accuracy. The number of iterations can be reduced by choosing a higher radix. For example, choosing the radix to be 4, only n=2 iterations are needed; at each step, two quotient bits can be generated. The choice of a higher radix, however, entails larger time in each iteration since the selection of the quotient digit and the generation of divisor multiples become more complicated. Typically, radix 4 is used in practice, since it seems to provide a reasonable trade-o between the number of iterations and the time spent in each iteration 20]. Multiplication by quotient digits 0, 1, 2, and 3, can be performed by shifting and adding/subtracting. The SRT divider speci ed and veri ed in this paper, uses the radix 4.
2.2 Redundant Quotient Digit Representation
SRT dividers reduce the latency of each iteration by using a redundant signeddigit representation for the quotient digits. Typically, the digit values of a quotient represented with a radix r can range from 0 through r 1. In contrast, in a redundant signed-digit representation, the digit values of a quotient with radix r are a consecutive set of integers a; a] where a is at least dr=2e. Depending upon a, this allows for some redundancy. For example, a redundant signed-bit representation for quotient with radix 4 would be the quotient digit set f 2; 1; 0; 1; 2g; this is in contrast to 4 quotient digits commonly used for radix 4: f0; 1; 2; 3g. The value of a quotient with signed digits is interpreted by subtracting the binary weights of the negative digits from the non-negative ones. Due to the redundancy in the representation, more than one quotient can map onto the same number. For example, the quotients 10( 2) and 1( 1)2 in radix 4 both have the value 1 42 2 1 = 14 = 1 42 (1 4) + 2.
An advantage of using the above quotient digit set is that divisor multiples are generated simply by shifting. This is in contrast to the unsigned quotient digit set representation for radix 4 for which it is necessary to implement a shift followed by an add/subtract to generate 3 times the divisor.
More importantly, redundancy among quotient digits allows the quotient digits to be selected based on only a few signi cant bits of the partial remainder and the divisor. This reduces the complexity of the quotient selection table, as well as allows the multiplication and the subtraction stage of an iteration to be overlapped with the quotient selection stage of a successive iteration. The radix 4 SRT divider in this paper uses the redundant signed-digit representation
2; 2].

16/3 5 14/3 13/3 4 11/3 10/3 Shifted Partial 3 8/3 Remainder 7/3
2 5/3 4/3 1 2/3 1/3 0
8/8

8/3D

qj = 2
qj = (1, 2)
qj = 1 qj = (0, 1) qj = 0
12/8 Divisor

5/3D 4/3D
2/3D 1/3D 15/8

Fig. 1. P-D Plot for Radix 4

2.3 Quotient Selection Function
The SRT division algorithm with redundant signed-digit quotient representation allows quotient digits selected to be inexact within certain bounds; the partial remainder generated in a step could be negative. The bound on the successive partial remainders using a redundant signed-digit representation a; a] for radix r is
D a=(r 1) Pj D a=(r 1); where D is the divisor. By substituting the recurrence for the successive partial remainders, the range of shifted partial remainders that allow a quotient digit k to be chosen is:
(k a=(r 1)) D; (k + a=(r 1)) D]:
The correlation between the shifted partial remainder range P and divisor D in the SRT division algorithms is diagrammatically plotted as a P-D plot. The shifted partial remainder and the divisor form the axes of the plot which illustrates the shifted partial remainder ranges in which a quotient digit can be selected, without violating the bounds on the next partial remainder. The P-D plot for a radix 4 quotient with redundant digit set 2; 2] is given in Figure 1. As the reader would notice, when the partial remainder is in the range 5=3D; 8=3D], the quotient digit 2 is selected. The shaded regions represent quotient digits overlaps where more than one quotient digits selection is feasible. So if the partial remainder is in the range 4=3D; 5=3D], either 2 or 1 can be used.

parrem Divisorg7g6g1111111111110000000000005000011111111000000001111g1111000011110000111100004001100110011001100110011.........................g0101010101010101010101013g2g1 1{{{{{---A--0011222{{{{{{22211.000 1{{{{{---B--0011C222{{{{{22211.001 1{{{{------D001112222{{{{222211.010 1{{{----B--D001112222{{{{222211.f011.1f2f1{{{-------000E11C2222{{{32222111.f1400 1{{--------000011122222{{22222111.101 1{-----B---000011122222{{22222111.110 1{---------0000111122222{222221111.111
Table 1. Quotient Digit Selection Table
For selecting an appropriate quotient digit, it is not necessary to know the exact value of the shifted partial remainder P or the divisor D. It su ces to know the region in which the ratio P=D lies in Figure 1. Due to the overlap between the lower bound for the P=D ratio for quotient digit k and the upper bound for the quotient digit k 1, P=D ratio can be approximated in choosing quotient digits. For instance, a radix 4 SRT divider with the partial remainders and divisor of width n, n > 8, it su ces to consider partial remainders up to 7 bits of accuracy and a divisor up to 4 bits of accuracy 20].
The quotient selection table implementing the P-D plot for radix 4 is reproduced above from 20]. Rows are indexed by the shifted truncated partial remainder g7g6g5g4:g3g2g1; columns are indexed by the truncated divisor f1:f2f3f4; table entries are the quotient digits. The table is compressed by considering only row indices up to 5 bits since only a few entries in the table depend upon the 2 least signi cant bits g2g1 of the shifted partial remainder. For those cases, the table entries are symbolic values A; B; C; D; E, de ned as: A = (2 g2 g1); B = (2 g2); C = 1 + g2; D = 1 + g2; E = g2: These entries as well as other aspects of the selection table are further discussed in subsection 4.1, where we show how the table is input to RRL. The - entries in the table are for the cases of the shifted truncated partial remainder and truncated divisor pairs which are not supposed to arise during the computations.
2.4 Divider Circuit
A radix 4 SRT divider circuit using the signed digit representation 2; 2] is given in Figure 2. The registers divisor, remainder in the circuit hold the value of the divisor and the successive partial remainders respectively. The register

rout1 (8 bits)

GALU AB

A+B A - B -1

rout

A+B

A-B

DALU A

B

<<2 <<2

rin1

(8 bits)

REMAINDER

md1 (8 bits)

4rout1

d1 (3 bits)

md

QUO LOGIC

MUX

qsign ( 1 bit) q
qdigit( 2 bits)

0 d

<<1

Divisor

QPOS

QNEG

AB A-B

Fig. 2. SRT Division Circuit using Radix 4
q holds the selected quotient digit along with its sign; the registers QPOS and QNEG hold the positive and negative quotient digits of the quotient. A multiplexor MUX is used to generate the correct multiple of the divisor based on the selected quotient digit by appropriately shifting the divisor. The hardware component QUO LOGIC stands for the quotient selection table, and it is typically implemented using an array of preprogrammed read-only-memory. The hardware component DALU is a full width ALU that computes the partial remainder at each iteration. The component GALU (the guess ALU 20]) is an 8-bit ALU that computes the approximate 8-bit partial remainder to be used for quotient selection. The components << 2 perform left shift by 4.
The circuit is initialized by loading dividend/4 (by right shifting the dividend by 2 bits) and the divisor into the remainder and divisor registers. The quotient is initialized to be zero by setting the registers QPOS and QNEG to be zero. The quotient digit register q is initialized by the appropriate alignment of the dividend and the divisor. At each iteration, the correct multiple of the quotient digit and the divisor is output by MUX. This output and the partial remainder in the remainder register is input to DALU to compute the next partial remainder. An 8 bit estimate of the partial remainder in the remainder register and an 8 bit estimate of the output of the MUX are input to the GALU.

GALU computes an 8 bit estimate of the next partial remainder which is left shifted by 4, and then, used with the truncated divisor (d1), to index into QUO LOGIC to select the quotient digit for the next iteration. Note that GALU and the quotient digit selection are done in parallel with the full width DALU so that the correct quotient digit value is already available in the register q at the beginning of each iteration. This relationship between the inputs and output of DALU and GALU is captured using the predicate GALU desc(rout, rin, md, rin1, md1, qsign, rout1) in section 5.2 where the correctness of the circuit is discussed. The circuit is formalized in Section 4.
3 A Brief Overview of RRL
Rewrite Rule Laboratory (RRL) 11] is di erent in its design philosophy from most proof checkers such as PVS, IMP, HOL, Isabelle, NUPRL, LP, in the sense it attempts to perform most inferences automatically without user guidance. Many proofs in RRL can be generated automatically; RRL can be used in such cases as a push-button theorem prover. In fact, that is how we typically use RRL for nding proofs, starting without having any clue about how a proof can be done manually. When a proof attempt fails and a proof cannot be found automatically, the transcript is looked at, which may reveal a variety of things. The conjecture may have to be modi ed, a de nition may have be to xed, or perhaps, an intermediate lemma needs to be hypothesized. RRL supports some heuristics for automatically generating intermediate lemmas based on formulas generated during a proof attempt. Lemmas which cannot be generated automatically by RRL must be provided by the user. This is where RRL needs guidance from the user. Below, we brie y discuss main features of RRL found useful for hardware veri cation.
The speci cation language supported in RRL is equational, with support for de ning abstract data types using constructors. Circuits and their behavioral speci cations are given as equations and conditional equations. De nitions are distinguished from properties (lemmas) using := for de nitions and == for properties to stand for the equality symbol. The correctness of circuit descriptions is established by proving various properties about these descriptions, and showing that they meet the behavioral speci cations.
After transforming de nitions into terminating rewrite rules, RRL attempts to prove a conjecture by normalizing its two sides using contextual rewriting 23] and the decision procedures for discharging any hypotheses, if any, and checking whether the normal forms of the two sides of the conjecture are identical. If it succeeds, then the proof is said to have been obtained using equational reasoning and decision procedures. Otherwise, a proof by induction is attempted using the cover set method of generating induction schemes 24].
RRL has built-in heuristics for 1. orienting equations into terminating rewrite rules,

2. identifying the next rewrite rule to apply for simpli cation, and for that, determining the instantiation of the free variables, and discharging conditions, if any, of the rewrite rule,
3. invoking decision procedures for numbers (quanti er-free Presburger arithmetic), bits, data types with free constructors, and propositional logic,
4. selecting the next inference rule, 5. automatic case analyses, 6. choosing induction schemes based on the de nitions of function symbols
appearing in a conjecture and interaction among these de nitions, 7. generating intermediate lemmas needed, as well as 8. automatic backtracking when a proof attempt fails. The user is thus relieved of the task of having to determine the sequence in which rewrite rules should be applied, when decision procedures should be invoked, how rewrite rules should be instantiated, when induction is performed, as well as what variables and induction scheme to be used for induction.
The cover set method generates induction schemes based on well-founded orderings used to establish termination of function de nitions. Based on an induction scheme, the conjecture is split into subgoals to be proved in order to prove the original conjecture. Each subgoal is then tried just like the original conjecture. If a proof attempt based on a particular induction scheme does not lead to a counter-example, but also does not succeed, RRL automatically backtracks to pick another induction scheme.
While attempting to nd proofs, RRL automatically attempts to generate new intermediate lemmas needed to nd a proof of a conjecture. Currently, RRL implements a simple heuristic for generalizing conjectures by abstracting to new variables, common subexpressions appearing in a conjecture and satisfying certain criteria. New intermediate lemma speculation heuristics have been investigated in 9, 10], and will be implemented, as we consider the intermediate lemma speculation research to be the most critical for automating proofs by induction.
4 Formalizing SRT Division in RRL
The SRT divider in Figure 2 is equationally speci ed in RRL. We rst discuss how quotient selection table is axiomatized. The recurrence relations for partial remainder and quotients are axiomatized using the quotient digit.
4.1 Formalizing Quotient Selection Table
The quotient selection table can be input essentially as is into RRL. As discussed earlier, even though the partial remainder is truncated to be 7 bits, only 5 bits are used to index the rows of the table. Every entry in the table is, thus, for four remainder estimates. In some cases, the table entry depends upon the

two least signi cant bits in the estimate. For showing that dependency, the symbolic entries A; B; C; D; E are used in the table, and their values depend upon the value of these bits. The table is input to RRL by de ning the function nextqdigit below, such that given a row and column indices, it gives the entry in the table. Instead of using fractional numbers for indices, it is more convenient and faster for the prover to use their scaled integer versions as indices to the table. So all row and column indices are scaled up by 8. (Scaling up e ectively leads to using number representations of bit vectors of the shifted truncated partial remainder estimate and the truncated divisor estimate by dropping the decimal point.)
Since the table is big, we give only a partial speci cation of one of the rows, the eighth row, to illustrate how it is input into RRL. The eighth row is indexed by -5/2 (ignoring the two least signi cant bits), and is scaled up by multiplying by 8, to - 20 (2's complement representation is used in the table for row indices); the columns are indexed by 8/8 to 15/8, and they are also scaled up by multiplying by 8. The function m below stands for the minus operation.

nextqdigit(m(20), 8) := m(2), nextqdigit(m(20), 10) := m(2), nextqdigit(m(20), 12) := m(1), nextqdigit(m(20), 14) := m(1),

nextqdigit(m(20), 9) := m(2), nextqdigit(m(20), 11) := m(2), nextqdigit(m(20), 13) := m(1), nextqdigit(m(20), 15) := m(1).

The eighth row corresponds to four shifted truncated remainder estimates:

f 5=2; 19=16; 9=8; 17=16g depending upon the values of g2g1. It includes

B when the column index is 1:011, where B = (2 g2). For all other col-

umn indices, the entries do not depend upon g2g1. So for all other column

in2d0ic;es,19n;ext18qdoirgit17is. value is -2 if the rst

the same irrespective of whether the rst argument is

If the second argument is

argument of nextqdigit 20 or 19, since in that

is 11, then its case g2 is 0; if

the rst argument is 18 or 17, then nextqdigit is -1. Below, we give the

speci cation for those cases when the second argument is 11.

nextqdigit(m(19), 11) := m(2), nextqdigit(m(18), 11) := m(1), nextqdigit(m(17), 11) := m(1).
Other rows in the table lead to similar speci cations, with each row de ning 32 entries. Inaccessible table entries (represented as - in the above table) are represented as a large negative or a large positive integer depending upon the top or the bottom of the table, respectively. The speci cation de nes nextqdigit on 768 pairs of indices.
In our rst proof attempt of the above SRT circuit as sketched in 5], we followed an approach similar to the one taken in 2] for specifying the quotient selection table. The table in that proof is not explicitly represented but is rather abstracted as a predicate de ned using six boundary values denoting the endpoints of the partial remainder ranges for the choice of the ve quotient digits
2; 2]. For example, the quotient digit 2 is chosen whenever the partial remainder is in the range b1; b2). The boundary value b1 is the minimum value of

the shifted truncated partial remainder estimate for which the selected quotient digit is 2. b1 is explicitly enumerated for every truncated divisor value. Similarly, other boundary values are speci ed. RRL was successful in obtaining a proof similar to the one reported in 2]. That proof has fewer cases but reasoning about each case is complex and more tedious, taking more cpu time, in contrast to the proof discussed later which has more cases but each case can be easily proved. We will contrast that proof based on such an intensional formalization of the quotient selection table after we have discussed the proofs of invariants in the next section using the above explicit, extensional representation of tables.

4.2 Formalizing Partial Remainder and Quotient Computations

The recurrence relations for partial remainders and quotients discussed above

rceasnpebcetiveqeluya.3tiTonhaelliynpauxtisomforatniezexdtqausottwaoref:utnhcetiqounostineenxttcpoamrpruetmedansdo

,nextquot far, as well

as the scaled truncated partial remainder and the scaled truncated divisor, to

be used for indexing the quotient selection table for selecting the quotient digit.

The digit

nfreowmqtuhoetipernetviiosugsoqtuboytieenitthbearseadddoinngthoersisgunbtorfatchteinsgeltehcteedseqleucotetidenqtudoitgiietn.4t

nextquot(quotient,truncp,truncd) := 4 * quotient + nextqdigit(truncp,truncd).
The function nextparrem for computing the partial remainder is similarly de ned. Its inputs are: the partial remainder computed at the previous iteration, the scaled truncated previous partial remainder, the divisor, and the scaled truncated divisor.

nextparrem(parrem,truncp,divisor,truncd) := 4 * parrem - nextqdigit(truncp, truncd) * divisor.

5 A Correctness Proof of SRT Division in RRL

The correctness of the SRT divider circuit is established by proving two in-

variants about the circuit. It is assumed that the divider circuit is initialized

appropriately with dividend/4 as the initial partial remainder, and with the

initial quotient being zero.

3 4

nextparrem and nextquot were called, In the circuit, addition/subtraction in

respectively, nrout and nquot in 5]. GALU and DALU are selected based

on

the

sign of the quotient digit. The functions nextquot and nextparrem could have easily

been speci ed as adding or subtracting based on the sign of the quotient digit, exactly

mimicing such selection in the circuit; in fact, that is how nextquot, nextparrem

were speci ed in our rst proof attempt 5]. The proofs using such speci cations

can be found by RRL just as easily except that there are more subcases. The above

formalization is more compact with the quotient sign not made explicit but instead

being part of the quotient digit. DALU computation|addition or subtraction{ gets

abstracted, leading to fewer subcases.

5.1 Invariant relating Partial Remainder and Quotient to Dividend
The rst invariant is to show that in every iteration, the dividend is equal to the the addition of the partial remainder computed so far and the divisor multiplied by the quotient computed so far. However, as discussed in section 2, to mechanically align the partial remainder with the multiple of the divisor, in each step the partial remainder is left shifted; similarly, the quotient is also left shifted to align the quotient digit. The quotient and the partial remainder at step i are thus scaled up from their actual values by 4i. The relationship between the dividend, the partial remainder and divisor is:
4i 1 dividend = Qi divisor + Pi: The above property can be veri ed by rst showing that it initially holds (i = 0), which is indeed the case assuming that the partial remainder and quotient are properly initialized. For other steps, it follows from the following invariant relating partial remainders and quotients in successive iterations.
Qi+1 divisor + Pi+1 = (Qi divisor + Pi) 4 :
This is input to RRL as:
nextparrem(parrem,truncp,divisor,truncd) + nextquot(quotient, truncp,truncd)*divisor == 4*(parrem+(quotient*divisor)).
This property is automatically established in RRL by contextual rewriting and the decision procedure for linear arithmetic.
5.2 Partial Remainders Never Go Out of Bounds
The second invariant is the more interesting one. It establishes that the division circuit would converge to a correct quotient, and would not over ow. As discussed in section 2, to ensure this for a radix 4 SRT divider with a redundant quotient digit representation 2; 2], it is necessary that the successive partial remainders be bounded as:
2=3 divisor Pi 2=3 divisor: Since the partial remainder computation in every iteration is dependent on the quotient digit selected, this invariant also establishes the correctness of the quotient selection table based on the shifted truncated partial remainder and the truncated divisor.
The second invariant is speci ed to RRL as follows:
m(2) * divisor <= 3 * nextparrem(parrem,truncp,divisor,truncd) and 3 * nextparrem(parrem,truncp,divisor,truncd) <= 2 * divisor if m(2) * divisor <= 3 * parrem and 3 * parrem <= 2 * divisor and truncd <= 8*divisor and 8 * divisor < truncd + 1 and truncp = 32*rout1 and GALU_desc(parrem, rin, qd*divisor, rin1, md1, qsign, rout1),

where
GALU_desc(rout, rin, md, rin1, md1, qsign, rout1) == (rin1 <= rin) and (64 * rin < 64 * rin1 + 1) and (md1 <= md) and (64 * md < 64 * md1 + 1) and cond(qsign=0, rout1 = rin1+md1, 64*rout1 = 64*rin1-64*md1-1) and cond(qsign=0, rout = rin + md, rout = rin - md).
The invariant states that if 1. the partial remainder is within the bounds in the previous iteration, 2. truncd is the scaled up version of the truncation of the divisor up to 3 bits
after the decimal point, 3. truncp is the scaled up version of the shifted output rout1 (multiplication
by 4) of GALU, then the partial remainder in the next iteration is also within the bounds.
The predicate GALU desc describes the 8 bit GALU unit which approximates the DALU computation. Given a partial remainder and a quotient digit multiplied with the divisor, DALU computes the next partial remainder by subtraction (or addition depending upon the sign of the quotient digit). GALU performs the same computation as the full ALU unit DALU. However, GALU unit operates on the truncated versions of the inputs to DALU, and is much faster. The quotient digits are selected using the GALU output, and this allows the quotient digit selection for the next iteration to be done in parallel with the fully precise DALU computation.
The rst two conjuncts in the formula describing the GALU circuit assert that the truncated partial remainder approximates the corresponding partial remainder up to 6 bits. The second two conjuncts deal with a similar assertion for its second input, the truncated divisor multiplied by the quotient digit. The dersstcrcibonesditthioenbaelheaxvpiroerssoifonDAdeLsUcr.i5bes the behavior of GALU and the second one
The second invariant is automatically proved by RRL by case analysis on the quotient selection table entries. Subcases are generated from the cover set of .nextqdigit There are 768 subcases corresponding to each shifted truncated partial remainder and truncated divisor estimates. In some subcases, further case analysis is done on qsign being 0 or 1. This analysis is repeated by RRL for the upper bound and the lower bound. Each of these cases is proved very easily by using rewriting and the linear arithmetic decision procedure with RRL using a total CPU time of 58 seconds on a Sun Sparc 5 with 64MB of memory. This is despite the fact that RRL currently uses a unary representation of numbers, thus leading to very large expressions which must be rewritten. A slight modi cation leading to representing numbers e ciently, is likely to reduce the total proof time by at least an order of magnitude, if not two orders of magnitude.
5 The built-in primitive cond in RRL is used for constructing conditional expressions. It is used by the prover for generating case analysis.

For those pairs of truncated estimates used as indices to select a quotient digit in the range 2; 2], the property that the partial remainder in the next iteration remains within the bounds, follows from the property that the partial remainder in the previous iteration is within the bounds. For truncated estimates corresponding to the table entry -, hypotheses in the above invariant become inconsistent because of the constraint that the partial remainder in the previous iteration was within the bounds.
We also show that no pair of indices other than those in Table 1 need to be considered. Only the speci ed column indices can occur since the divisor is normalized and positive, and we have assumed that the truncated divisor correctly approximates the divisor up to 3 bits. The completeness of the row indices is established in RRL by the following property which is easily proved by RRL by rewriting and the linear arithmetic.
not(truncp < m(48)) and not(47 < truncp) if m(2) * divisor <= 3 * parrem and 3 * parrem <= 2 * divisor and 8 <= truncd and truncd <= 15 and m(2) <= qd and qd <= 2 and truncd <= 8*divisor and 8*divisor < truncd+1 and truncp = 32*rout1 and GALU_desc(parrem, rin, qd * divisor, rin1, md1, qsign, rout1).
A major noticeable di erence between this proof and our earlier proof reported in 5] (as well as the proof in 2]) is that the second invariant is proved directly without using any assumptions. In contrast, the second invariant relied on two assumptions in our earlier proof, much like the proof in 2], These assumptions|the output of GALU is the truncation of the output of DALU, and the output of GALU along with the truncated divisor select proper quotient digits from the quotient selection table| rst had to be manually identi ed, and then proved separately, thus making the proof interactive. In the above proof, these properties are automatically derived, and appropriately used to establish the second key invariant.
Additionally, the new proof establishes the completeness of the indices of the table in 20]. This in contrast to our earlier proof (and the proof in 2]) where the rows in the table of 20] implicitly extend in both directions with the out-of-bounds values.
5.3 Detecting Errors in Quotient Digit Selection Table
Despite our careful transcription of the table from 20], two errors were made in the table speci cation that was input into RRL. We discuss below how these bugs were detected using RRL since this could be illustrative of nding possible bugs in a quotient selection table.
Both errors in the transcription of the quotient selection table were detected while attempting a proof of the second invariant. Since every quotient selection table entry gives rise to an intermediate subgoal of the second invariant, RRL is unable to prove the subgoal corresponding to the erroneous entry. It also

explicitly displays the table index values from which the corresponding subgoal was generated. Using this, it is straightforward to determine the table indices associated with a failing subgoal.
The rst error was in the table entry indexed by (1111:0; 1:000). This was erroneously assigned a value of 2 instead of 1. With this entry, RRL established that the partial remainder would violate its upper bound as explained below.
Based on the table entry, ,rout1 = -1/4 ,truncp = -8 truncd = 8 and nextqdigit(m(8), 8) = -2. Let divisor = 1 and parrem = .-6/25 Under these values, the conjuncts m(2) * divisor <= 3 * parrem and 3 * parrem <= 2 * divisor in the hypothesis of the second invariant reduce to true. The conjuncts truncd <= and8*divisor 8 * divisor < truncd + 1 also reduce to true. Finally, the predicate GALU desc is true implying that GALU approximates the partial remainder correctly up to 5 bits. However, the next partial remainder computed violates the upper bounds since, 4*-(6/25) + 2*1 is greater than .2/3
The second error was in the table entry indexed by (0100:0; 1:111). The entry was erroneously assigned the out of bounds value (we used 10 for that) instead of 2. For this entry, using a similar analysis as above, RRL established that the partial remainder would violate its lower bound.

6 Comparison with Related Work

Given that we have now discussed our proof, this section compares it with the

related work. simpler than

We believe that the other formalizations

above of the

formalization as well related circuit in the

alisteprraotoufrae.r6e

much

Verkest et al 21] discussed a proof of a nonrestoring division algorithm using Boyer and Moore's prover. Lesser and O'Leary 12] discussed a circuit of subtractive radix-2 square root using the NuPRL system. Square root and division circuits are considered to be related to each other 20]. But circuits veri ed in 21, 12] are not based on the SRT method.

Since Intel's Pentium bug was reported in the media, there has been a lot of interest in automated veri cation of the SRT divider circuits 18, 2, 4, 13]. Bryant 1] discussed how BDDs can be used to perform a limited analysis of some of the invariants of the SRT circuit. As reported in 18], Bryant had to construct a checker-circuit much larger than the veri ed circuit to capture the speci cation of the veri ed circuit.

As reported in 2], German and Clarke 4] formalized Taylor's description of SRT division circuit 20] as a set of algebraic relations on the real numbers. According to them, most of the hardware for the SRT algorithm could be described using linear inequalities. They used Maple, a computer algebra system, to prove properties of the SRT circuit by reasoning about linear inequalities using its Simplex algorithm package.

6 We are however also guilty of not making the proof even simpler by using fractions instead of integers.

This formalization was subsequently improved in 2] by Clarke, German and Zhao using the language of Analytica, a theorem prover built on top of Mathematica, another commercially available computer algebra system. To quote the authors, \Analytica is the rst theorem prover to use symbolic computation techniques in a major way. ... Compared to Analytica, most theorem provers require signi cant user interaction. The main problem is the large amount of domain knowledge that is required for even the simplest proofs. Our theorem prover, on the other hand, is able to exploit the mathematical knowledge that is built into the symbolic computation and is highly automatic."
A correctness proof of SRT divider circuit was then done using Analytica. The main feature of the proof was an abstraction of the quotient selection table using the six boundary value predicates as discussed in subsection 4.1. This abstraction had to be manually provided by Clarke et al. The proof of invariants using this intensional representation of quotient selection table involves reasoning about inequalities, which can become quite tedious and involved. Perhaps, that is why Clarke et al had to use Analytica - using Mathematica algorithms for symbolic manipulation and inequality reasoning, and the Analytica subpart built on Mathematica for logical reasoning. Even though it is claimed in 2] that the proof is \fully automatic" (p. 111 in 2]), the proof (especially, the proof of the second invariant regarding the boundedness of partial remainders) had to be decomposed manually and the two assumptions had to be discharged manually.
Our rst proof attempt discussed in 5] was essentially an exercise to determine how much of the Analytica proof 2] could be done automatically by RRL without having to use any symbolic computation algorithms of computer algebra systems. We mimiced the proof in 2] but making data dependency of various circuit components explicit on di erent data paths, as well as by identifying different assumptions made in the proof reported in 2]. Much to our surprise, once we succeeded in translating the Analytica speci cation to RRL's equational language (which by the way, was the most nontrivial part of this proof), RRL was able to nd proofs of all the formulas (the rst invariant and the second invariant with the assumptions, as well as discharging of assumptions) automatically, without any interaction. The main inference method used was that of contextual rewriting integrated with the linear arithmetic procedure in RRL. No additional mechanism was found necessary. No extensions had to be made to RRL. Further, the entire proof (including the proof of the second invariant involved over 96 cases) could be done in less than 15 minutes on a Sparc 5 Sun workstation.7 No timing information is given in 2] for their proof using Analytica.
A brief comparison of the above proof with the proof reported in 5] based on representing the table using boundary value predicates is discussed:
1. The axiomatization using explicit table representation is much simpler, and it does away with an aspect of the speci cation development where human guidance is used for abstracting table entries as predicates.
7 We would also like to point out that RRL is an old piece of software written in Common Lisp.

2. Since the abstract representation of the quotient selection table using boundary value predicates in 5, 2] just considers the minimum and maximum values of a partial remainder for every quotient digit, thus losing information on other relations among entries, it is possible to certify erroneous tables correct. For instance, the rst error in the table discussed above could be detected using the explicit representation of the table, but would be undetected using the boundary value predicate formulation.8
3. Even though the above proof has nearly 800 subcases, the proof of each subcase is much easier and a lot quicker to obtain as a subformula typically involves numeric constants that can be easily simpli ed and reasoned about. This is in contrast to the proof in 5] from the speci cation of the table using boundary value predicates which has 96 subcases. Each subcase in that proof involves a formula with variables with linear constraints, and the reasoning is not as simple and easy.
4. The above proof of the second invariant is direct without making any assumptions. In our earlier proof (as in the proof in 2]), two assumptions had to be made, which were subsequently established.
5. The new proof takes less than 1 minute even with more subcases, in contrast to the earlier proof which took around 15 minutes using the same version of the prover on the same machine. The proof reported in 18] using the PVS system is more general than the
above proof as well as the proofs in 2, 5]. Its structure is essentially based on an earlier proof of Clarke and German 4]. First, a general theory of SRT division for arbitrary radix r and arbitrary redundant quotient digit range a; a] is developed. Constraints on a quotient digit selection table are identi ed in terms of r; a and other parameters. This theory is then instantiated for the radix 4 SRT division circuit. The constraints on the table are also instantiated on a speci c quotient digit selection table. The speci cation and the proof are organized manually using sophisticated mechanisms of the PVS language which supports higher-order logic, dependent types, overloading, module facility, a special data type table 18]. The speci cation is developed with considerable human ingenuity, and the resulting proof is manually driven, even though parts of the proof can be done automatically using previously developed PVS tactics. As reported in 18], the correctness proof of the table implementation itself took 3 hours of cpu time, with the whole proof taking much longer even with user's help.
Miner and Leathrum's work 13] is a generalization of the proof in 18]; it formalized a subset of IEEE oating point standard, and uses it to do the proof for oating point arithmetic thus providing a formal link relating the SRT division algorithm, among other things, to the IEEE standard subject to IEEE compliant rounding. This proof uses even more sophisticated features of the PVS system, and is highly interactive.
8 It may, however, be possible to avoid such errors if additional constraints such as monotonicity of entries in every row in the table are also included in its speci cation along with the boundary value predicates.

Moore et al 14] reported a proof of correctness of the kernel of a microcoded oating point division algorithm implemented in AMD's 5K86 processor. The algorithm is de ned in terms of oating point addition and multiplication. The proof is done using ACL2, a descendant of Boyer and Moore's prover. No claim is made about making the proof automatic, but rather the main emphasis is on formalizing the IEEE oating point arithmetic, compliant rounding, proving a library of relevant and useful properties of oating point arithmetic, and using it to verify the division algorithm based on Newton-Raphson's method.
7 Concluding Remarks and Future Enhancements to RRL
We have discussed a proof of correctness of the SRT division algorithm using a rewrite-based theorem prover RRL. It is believed that the algorithm similar to the one discussed above was implemented in the Intel Pentium chip, which was found to be buggy. The bug is suspected to be as either the wrong entries in the quotient digit selection table or that certain portions of the table considered inaccessible could be accessed during the division computation. The salient features of the above proof are that 1. the formalization is much simpler than the ones reported in 2, 18], 2. the quotient digit selection table is explicitly speci ed, in contrast to the
speci cation of the table in 2] in terms of boundary value predicates, an abstraction that a human designer would have to perform, 3. the proof of the second key invariant about the circuit is simpler, making fewer assumptions than in the proof reported in 2], 4. the proof nding takes much less resources in contrast to other proofs (58 seconds of cpu time on a Sparc5 Sun with 64MB of memory), and 5. possible bugs in the quotient digit selection table can be easily identi ed. From our work on using RRL for mechanizing veri cation of arithmetic circuits, a number of lessons can be drawn about possible enhancements to rewritebased provers such as RRL in order to make them better suited for the application of hardware veri cation. Perhaps the most critical feature of a prover for this application is that it should be able to perform simpli cation (rewriting) using conditional rewrite rules very e ciently and fast. Secondly, a prover should also be able to do automatic case analyses quickly. An important research problem is to develop heuristics for e cient case analysis that minimizes duplication of e ort by recognizing a common subset of assumptions su cient to establish many related subcases. Thirdly, for proofs of parameterized and generic circuits with subcircuits specied by constraints on their input/output behavior, a theorem prover should be able to perform proofs by induction. A related issue is that of automatic generation/speculation of intermediate lemmas, as often behavioral speci cations cannot be directly proved from circuit speci cations. We have brie y discussed these issues in 5] Mechanizing veri cation of the SRT division circuit highlights additional issues related to representing and reasoning about data structures found useful

in describing such circuits. The above proof involves reasoning about numeric constants while dealing with truncated partial remainders, truncated divisors as well as bounds on the partial remainder. A prover should be able to e ciently represent, display and reason about numeric constants. RRL does not provide good support for explicitly representing and manipulating numeric constants. Numbers are represented in unary notation using 0, successor and predecessor. In order to specify the SRT divider, the numeric constants have to be specied by the user as abbreviations de ned in terms of these constructors. This imposes an unnecessary burden on the user for having to specify such trivial details. Further, in proofs generated by RRL, these abbreviations are expanded as their unary representations, leading to unnecessary large formulas. Rewriting such formulas is considerably slower. Intermediate formulas with such large term structures also make the mechanical proofs hard to read and understand. A better representation for numbers and reasoning support for rational number will be helpful in formalization oating point arithmetic and proving properties about oating point circuits. Such enhancements to RRL will help in veri cation of hardware implementations of sophisticated graphics and media processing algorithms 26, 25] which have widespread use.
Many circuits including SRT divider rely on preprogrammed read-onlymemory, for implementing tables for fast computation using look-ups. A direct encoding of a table data structure, the support for reasoning about it, as well as e cient handling of various entries in the table leading to large case analysis will help. Speci cations of such circuits are error-prone because of too many cases to be considered as well as large tables involving many numeric values. When a theorem prover detects a bug, it would be helpful for a theorem prover to trace the bug to the speci cation, particularly identifying the subcase and/or entry in the table. Identifying multiple bugs in a single run would enhance the designer's productivity in developing such speci cations.
References
1. R.E. Bryant, Bit-level Analysis of an SRT Divider Circuit. Tech. Rep. CMU-CS95-140, Carnegie Mellon University, April 1995.
2. E.M. Clarke, S.M. German and X. Zhao, \Verifying the SRT division algorithm using theorem proving techniques," Proc. Computer Aided Veri cation, 8th Intl. Conf. - CAV'96, New Brunswick, July/August 1996, Springer LNCS 1102 (eds. Alur and Henzinger), 111-122.
3. M.D. Ercegovac and T. Lang, Division and Square Root: Digit Recurrence Algorithms and Implementations. Kluwer, 1994.
4. S. German, Towards Automatic Veri cation of Arithmetic Hardware. Lecture Notes, 1995.
5. D. Kapur, \Rewriting, decision procedures and lemma speculation for automated hardware veri cation," Proc. 10th Intl. Conf. Theorem Proving in Higher Order Logics, LNCS 1275 (eds. Gunter and Felty), Murray Hill, NJ, Aug 1997, 171-182.
6. D. Kapur and X. Nie, \Reasoning about numbers in Tecton," Proc. 8th Intl. Symp. Methodologies for Intelligent Systems, (ISMIS'94), Charlotte, North Carolina, October 1994, 57-70.

7. D. Kapur and M. Subramaniam, \Mechanically verifying a family of multiplier circuits," Proc. Computer Aided Veri cation, 8th Intl. Conf. - CAV'96, New Brunswick, July/August 1996, Springer LNCS 1102 (eds. Alur and Henzinger), 1996, 135-146.
8. D. Kapur and M. Subramaniam, \Mechanical veri cation of adder circuits using powerlists," Dept. of Computer Science Tech. Report, SUNY Albany, November 1995. Accepted for publication in J. of Formal Methods in System Design.
9. D. Kapur and M. Subramaniam, \Lemma discovery in automating induction," Proc. Intl. Conf. on Automated Deduction, CADE-13, LNAI 1104 (eds. McRobbie and Slaney), New Jersey, July 1996.
10. D. Kapur and M. Subramaniam, \Intermediate lemma generation from circuit descriptions," under preparation, State University of New York, Albany, NY, October 1997.
11. D. Kapur, and H. Zhang, \An overview of Rewrite Rule Laboratory (RRL)," J. of Computer and Mathematics with Applications, 29, 2, 1995, 91-114.
12. M. Leeser and J.O'Leary, \Veri cation of a subtractive radix-2 square root algorithm and implementation," Proc. ICCD'95, IEEE Computer Society Press, 1995, 526-531.
13. P.S. Miner and J.F. Leathrum Jr., \Veri cation of IEEE compliant subtractive division algorithm," Proc. FMCAD'96, Palo Alto, CA, 1996.
14. J Moore, T. Lynch and M. Kaufmann, A Mechanically Checked Proof of the Correctness of the AMD5K86 Floating Point Division Algorithm. CL Inc. Technical Report, March 1996.
15. S.F. Obermann and M.J. Flynn, An Analysis of Division Algorithms and Implementations. Technical Report CSL-TR-95-675, Stanford University, July 1995.
16. A.R. Omondi, Computer Arithmetic Systems: Algorithms, Architecture and Implementations, Prentice Hall 1994.
17. J.E. Robertson, \A new class of digital division methods," IRE Transactions on Electronic Computers, 1958, 218-222.
18. H. Ruess, N. Shankar and M.K. Srivas, \Modular veri cation of SRT division," Proc. Computer Aided Veri cation, 8th Intl. Conf. - CAV'96, New Brunswick, July/August 1996, Springer LNCS 1102 (eds. Alur and Henzinger), 123-134.
19. K.D. Tocher, \Techniques of multiplication and division for automatic binary computers," Quarterly Journal of Mechanics and Applied Mathematics, 11(3), 1958.
20. G.S. Taylor, \Compatible hardware for division and square root," Proc. 5th IEEE Symp. on Computer Architecture, May 1981.
21. D. Verkest, L. Claesen, and H. De Man, \A proof of the nonrestoring division algorithm and its implementation on an ALU," J. Formal Methods in System Design, 4, Jan. 1994, 5-31.
22. T.E. Williams and M. Horowitz, \A 160nS 54-bit CMOS division implementation using self-timing and symmetrically overlapped SRT stages," Proc. 10th IEEE Symp. on Computer Arithmetic, 1991.
23. H. Zhang, \Implementing contextual rewriting," Proc. 3rd Intl. Workshop on Conditional Term Rewriting Systems, Springer LNCS 656 (eds. Remy and Rusinowitch), 1992, 363-377.
24. H. Zhang, D. Kapur, and M.S. Krishnamoorthy, \A mechanizable induction principle for equational speci cations," Proc. 9th Intl. Conf. Automated Deduction (CADE), Springer LNCS 310, (eds. Lusk and Overbeek), Chicago, 1988, 250-265.
25. Proc. of Eighth Symp. of HOT Chips, IEEE Computer Society, California, 1996. 26. Proc. of Ninth Symp. of HOT Chips, IEEE Computer Society, California, 1997.

