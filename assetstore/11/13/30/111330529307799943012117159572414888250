Dependent Types for Nominal Terms with Atom Substitutions
Elliot Fairweather1, Maribel Fernández1, Nora Szasz2, and Alvaro Tasistro2
1 King’s College London, UK 2 Universidad ORT Uruguay, Uruguay
Abstract Nominal terms are an extended ﬁrst-order language for specifying and verifying properties of syntax with binding. Founded upon the semantics of nominal sets, the success of nominal terms with regard to systems of equational reasoning is already well established. This work ﬁrst extends the untyped language of nominal terms with a notion of non-capturing atom substitution for object-level names and then proposes a dependent type system for this extended language. Both these contributions are intended to serve as a prelude to a future nominal logical framework based upon nominal equational reasoning and thus an extended example is given to demonstrate that this system is capable of encoding various other formal systems of interest.
1998 ACM Subject Classiﬁcation F.4.1 Mathematical Logic, lambda calculus and related systems, D.3.3 Language Constructs and Features, data types and structures, frameworks
Keywords and phrases –-equivalence, nominal term, substitution, dependent type
Digital Object Identiﬁer 10.4230/LIPIcs.TLCA.2015.180
1 Introduction
There exist many formal systems described by a syntax that makes use of name binding constructs. Nominal terms [35, 15, 14], are, by now, a well-established approach to the speciﬁcation and veriﬁcation of properties of such languages and systems. Based upon the name abstraction semantics of nominal sets [23], nominal terms use the properties of permutations of object-level names or ‘atoms’ to provide an explicit formalisation for both the use of side conditions on names and for the axiomatisation of alpha-equivalence between object-level terms. Following the development of e cient algorithms for matching [4] and uniﬁcation [5, 25], nominal terms have been applied in rewriting [15, 16, 12] and unoriented equational reasoning [22, 10].
In these works, the capture-avoiding substitution used in many systems of interest has, thus far, needed to be encoded by explicit rewrite rules or axioms for the syntax in question. The ﬁrst contribution of the present work addresses this issue by extending the language of nominal terms with a notion of capture-avoiding atom substitution at the object-level. Deﬁnitions of freshness, alpha-equivalence and matching together with informal proofs of decidability are provided for the new syntax.
The second contribution of this paper is the deﬁnition of a proposed dependent type system for the extended language. The language of the type system presented in this paper is user-deﬁned; users deﬁne an interdependent signature of type- and term-constructors of interest and give their type declarations. It is the responsibility of the user to maintain the adequacy of their encoding and thus to declare types in accordance with the system to be
© Elliot Fairweather, Maribel Fernández, Nora Szasz, and Alvaro Tasistro; licensed under Creative Commons License CC-BY 13th International Conference on Typed Lambda Calculi and Applications (TLCA’15). Editor: Thorsten Altenkirch; pp. 180–195
Leibniz International Proceedings in Informatics Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

E. Fairweather, M. Fernández, N. Szasz, and A. Tasistro

181

formalised. In keeping with earlier work on nominal equational reasoning and in contrast with previous work on nominal type theories [8, 9, 32], the system given here remains ‘lambda-free’.
Both these contributions are presented as foundations for the future development of a logical framework based upon nominal equational reasoning. A logical framework is a formal system that provides the facility to deﬁne a number of other formal systems, such as programming languages, mathematical structures and logics, by abstraction of their common features [24, 2, 27, 30, 29]. Many logical frameworks are developed as a type system; the minimum expressive power desirable of such a type system is that types be allowed to depend upon terms.
The type system presented here is one of such expressive power and to demonstrate this an extended example is given in the form of a speciﬁcation for ﬁrst-order logic for which adequacy is proven. Equality axioms are not yet considered in this prototype ‘framework’ but in the future it is expected that the system be expanded to include a user-deﬁned nominal equational theory, speciﬁed as a set of equality axioms or rewriting rules in the style of [20, 15, 16].

2 Syntax
Consider countably inﬁnite, pairwise disjoint sets of atoms, a, b, c, . . . œ A, variables, X, Y, Z, . . . œ X, term-formers, f, g, . . . œ F, and type-formers, C, CÕ, . . . œ C. The syntax of permutations, ﬁ, atom substitutions, Ë, pseudo-terms, s, t, and pseudo-types, ‡, · , is deﬁned by mutual induction and generated by the grammar in Deﬁnition 1.
I Deﬁnition 1 (Syntax).
ﬁ ::= id | ﬁ ú (a b) s, t ::= a | [a : ‡] t | f t | (t1, . . . , tn) | Ë--ﬁ · X Ë ::= id | [a ‘æ t] ú Ë ‡, · ::= [a : ‡] · | C t | (·1 ◊ . . . ◊ ·n)
A permutation is a bijection on the set of atoms, A, represented as a list of swappings, such that ﬁ(a) ”= a for ﬁnitely many atoms, a œ A. ﬁ(a) is easily computed using swappings (we omit the inductive deﬁnition). An atom substitution is a mapping from atoms to pseudo-terms, equal to the identity mapping but for ﬁnitely many arguments. This mapping is represented as a list of pairs, Ë, of the form, [ai ‘æ ti] such that the atoms, ai, are pairwise distinct. This list is interpreted as a set of simultaneous bindings and not as a sequence, and thus the value of an atom substitution is determined directly from the syntactic representation. The ﬁnal id and ‘list cons’ operators in the syntax for both permutations and atom substitutions are commonly omitted. Atom substitutions act upon pseudo-terms and pseudo-types by instantiating atoms and are ‘capture-avoiding’. Atom substitutions suspend upon variables and are applied after a suspended permutation.
The constructions for pseudo-terms are called respectively atom terms, abstractions, function applications, tuples (where n Ø 0) and moderated variables and those for pseudo-types, abstraction types, constructed types and product types (n Ø 0). Abbreviate f () as f, and C () as C. Let M, N, . . . range over elements of the union of the set of pseudo-terms and set of pseudo-types. There is only one kind of well-formed types: type.

TLCA’15

182 Dependent Types for Nominal Terms with Atom Substitutions

I Deﬁnition 2 (Permutation Action).

ﬁ · id , id
ﬁ · a , ﬁ(a) ﬁ · [a : ‡] t , [ﬁ(a) : ﬁ · ‡] (ﬁ · t)
ﬁ · f t , f (ﬁ · t) ﬁ · (t1, . . . , tn) , (ﬁ · t1, . . . , ﬁ · tn)

ﬁ · ([a ‘æ t] ú Ë) , [ﬁ(a) ‘æ ﬁ · t] ú (ﬁ · Ë) ﬁ · (Ë--ﬁÕ · X) , ﬁ · Ë--(ﬁ @ ﬁÕ) · X ﬁ · [a : ‡] · , [ﬁ · a : ﬁ · ‡] (ﬁ · · ) ﬁ · C t , C (ﬁ · t)
ﬁ · (·1 ◊ . . . ◊ ·n) , (ﬁ · ·1 ◊ . . . ◊ ﬁ · ·n)

Call a # M a freshness constraint. Let , Ò, range over sets of freshness constraints
of the form a # X; call such sets freshness contexts. Write „ a # M when a derivation exists using the rules given in Deﬁnition 3 below; in rule (atm)# we assume a ”= b.

I Deﬁnition 3 (Freshness Relation).

(atm)# „a#b

img#(

,

a, Ë--ﬁ · „a#

X) Ë--ﬁ

·

aœ X

dom(Ë)

(var

:

aa)#

img#( , a, Ë--ﬁ · X) a ”œ dom(Ë) ﬁ-1(a) # X œ „ a # Ë--ﬁ · X

(var : ab)#

„a#· (abs : aa)#
„ a # [a : · ] s

„a#s „a#· (abs : ab)#
„ a # [b : · ] s

„ a # s1 . . . „ a # sn (tpl)# „ a # (s1, . . . , sn)

„a#s (app)#
„a#fs

„ a # ‡ (abt : aa)# „ a # [a : ‡] ·

„a#·

„ a # ‡ (abt : ab)#

„ a # [b : ‡] ·

„ a # ·1 . . . „ a # ·n (prd)# „ a # (·1 ◊ . . . ◊ ·n)

„ a # t (cns)# „ a # Ct

The main di erences with respect to the freshness relation for nominal terms are the

introduction of new rules for types, (abt : aa)#, (abt : ab)#, (prd)# and (cns)#, and the rules

for moderated variables, (var : aa)# and (var : ab)#, atom substitutions as well as suspended permutations.

wThhiechnottaakteioinn,toimagc#c(oun, tas,uËsp--ﬁen·dXed),

in these rules, deﬁnes the conditions necessary for freshness with regard to the suspended

atom substitution and is an abbreviation of the following ﬁnite set of hypotheses.

)!

"! „ a # Ë(ﬁ(b)) ‚ b # X œ

" |

b

œ

A,

* ﬁ(b) œ dom(Ë)

This ensures that the substitution will not introduce the atom a when it is applied to an instance of X. However this disjunction of conditions results in the possibility of multiple derivations i „ a # t for a given freshness constraint a # t. If one considers the suspended atom substitution, Ë, to be id, the conditions upon Ë are satisﬁed vacuously and the two rules clearly reduce to that for nominal terms.
Call M ¥– N an alpha-equality constraint and write „ M ¥– N when a derivation exists using the rules given in Deﬁnition 4 below. Note that because alpha-equivalence is deﬁned using freshness, again multiple possible derivations may exist for a given constraint.

E. Fairweather, M. Fernández, N. Szasz, and A. Tasistro

183

I Deﬁnition 4 (Alpha-equivalence Relation).

(atm)– „ a ¥– a

’a

œ

d„s(ËË11----ﬁﬁ11

, ·

Ë2 X

--¥ﬁ–2)Ë. 2a--ﬁ#2

Xœ ·X

(var)–

„ s1 ¥– t1 . . . „ sn ¥– tn (tpl)– „ (s1, . . . , sn) ¥– (t1, . . . , tn)

„ ‡ ¥– · „ s ¥– t (abs : aa)– „ [a : ‡] s ¥– [a : · ] t

„ s ¥– t (app)– „ f s ¥– f t

„ ‡ ¥– · „ a # t „ s ¥– (a b) · t (abs : ab)– „ [a : ‡] s ¥– [b : · ] t

„ ‡1 ¥– ·1 . . . „ ‡n ¥– ·n

(prd)–

„ (‡1 ◊ . . . ◊ ‡n) ¥– (·1 ◊ . . . ◊ ·n)

„ ‡1 ¥– ·1 „ ‡2 ¥– ·2 (abt : aa)– „ [a : ‡1] ‡2 ¥– [a : ·1] ·2

„ s ¥– t (cns)– „ C s ¥– C t

„ ‡1 ¥– ·1 „ a # ·2 „ ‡2 ¥– (a b) · ·2 (abt : ab)– „ [a : ‡1] ‡2 ¥– [b : ·1] ·2

This presentation of alpha-equivalence is deﬁned by induction on the size of the pair,
(M, N ), and is both syntax-directed and decidable when considered as a recursive predicate.
It is a generalisation of the notion of alpha-equivalence on nominal terms. The only case that is not straightforward is again that of a moderated variable, (var)–.
Here it is important to remember that both permutations and atom substitutions are ﬁnite
mtahnaedpspËyi2nn--tﬁgas2x,aownfdrtithtteheanmtdotsdh(eeËr1ai--mtﬁea1d,gveËa2or--ifaﬁab2)lse,u.issTpahelnusods,eﬁdtnhiaettedoimasnadgsruembesamtyietnbutetisodenetﬁionsfegtdwivaoesns{uaassp|eaËn1ssu(ioﬁbn1-(sta,er)Ëm)1”¥--ﬁo–1f Ë2(ﬁ2(a)), a œ A}, which although recursive, is of decreasing size. The reﬂexivity, symmetry and transitivity of the alpha-equivalence relation have been proved by adapting the proofs
given in [15], themselves simpliﬁed from those in [35].
The action of an atom substitution, Ë, upon a pseudo-term or pseudo-type, M , written,
M Ë, is deﬁned by induction in the presence of a freshness context, , in Deﬁnition 5. For the
sake of clarity of presentation this freshness context is not explicitly written throughout the deﬁnition. Let Ë≠a denote the atom substitution Ë restricted to the domain, dom(Ë) \ {a}. The composition of two atom substitutions, written Ë1 ¶Ë2, is deﬁned as the atom substitution equivalent to applying Ë1 followed by Ë2. The syntactic construction of such a composition built from two substitutions represented as sets of bindings can be deﬁned by adapting the
algorithm described in [3, 2.1]. Note that this operation itself uses the action of an atom
substitution upon pseudo-term and so must be deﬁned simultaneously with Deﬁnition 5 and
is also parameterised by the freshness context, .

I Deﬁnition 5 (Action of Atom Substitution).

(ËÕ--ﬁ · X) Ë , (ËÕ ¶ Ë)--ﬁ · X

a Ë , Ë(a); a œ dom(Ë)

a Ë , a; a ”œ dom(Ë)

([a : ‡] s) Ë , [c : ‡ Ë] ((a c) · s) Ë≠c; „ c # s, c # img(Ë)

(f s) Ë , f (s Ë) (t1, . . . , tn) Ë , (t1 Ë, . . . , tn Ë)

([a : ‡] · ) Ë , [c : ‡ Ë] ((a c) · · ) Ë≠c; „ c # ·, c # img(Ë) (C s) Ë , C (s Ë) (·1 ◊ . . . ◊ ·n) Ë , (·1 Ë ◊ . . . ◊ ·n Ë)
The capture-avoidance of unabstracted atoms is ensured by the fact that when an atom substitution acts upon an abstraction or abstraction type, a suitable alpha-equivalent representative is ﬁrst chosen with respect to the freshness context, . In practice, this

TLCA’15

184 Dependent Types for Nominal Terms with Atom Substitutions

presentation will result in the creation of freshness constraints for atoms, newly-generated with respect to the system as a whole, and is similar to the approach taken in [16]. A suitable ‘even fresher’ atom always exists, and it is one’s right to add constraints for that atom to the freshness context, a fact which is taken advantage of below in Deﬁnition 9. Any implementation of this deﬁnition as a recursive function must accommodate a suitable mechanism for the generation of such names; this is most easily achieved by the threading of global state throughout the function or by the use of a global choice function that returns the next available name. Atom substitutions work uniformly on alpha-equivalence classes of pseudo-terms and pseudo-types.
I Deﬁnition 6 (Variable Substitutions). A variable substitution is a mapping from variables to pseudo-terms, equal to the identity mapping but for ﬁnitely many arguments, and written as a set of bindings [X1 ‘æ s1] . . . [Xn ‘æ sn], such that the variables, X1, . . . , Xn, are pairwise distinct.
The action of variable substitutions upon atom substitutions, pseudo-terms and pseudotypes is given in Deﬁnition 7. A variable substitution, ◊, acts upon an atom substitution, Ë, by instantiating the variables occurring in the pseudo-terms of the image of Ë, and is written Ë ◊. Note that the instantiation of a variable requires the application of an atom substitution to a pseudo-term and thus the action of variable substitutions is also parameterised by a freshness context, which again is left implicit in the deﬁnition below.
I Deﬁnition 7 (Variable Substitution Action).
id ◊ , id ([a ‘æ t] ú Ë) ◊ , [a ‘æ t ◊] ú (Ë ◊)

(Ë--ﬁ

a◊ · X)◊

, ,

a (ﬁ · ◊(X)) (Ë ◊);

X

œ dom(◊)

([a : ‡] t) ◊ , [a : ‡ ◊] (t ◊) (f t) ◊ , f (t ◊)

(Ë--ﬁ · X) ◊ , (Ë ◊)--ﬁ · X; X ”œ dom(◊) (t1, . . . , tn) ◊ , (t1 ◊, . . . , tn ◊)

([a : ‡] · ) ◊ , [a : ‡ ◊] (· ◊) (C t) ◊ , C (t ◊) (·1 ◊ . . . ◊ ·n) ◊ , (·1 ◊ ◊ . . . ◊ ·n ◊)

The type system introduced in Section 3 requires a formalisation of matching to check

that term-formers and type-formers are used in a way that is consistent with their respective

type declarations. The concepts of constraint problems and matching are now therefore

extended to nominal terms with atom substitutions.

Let C range over freshness and alpha-equality constraints; a constraint problem, C,

is an arbitrary set of such constraints. Extend the above notations for the derivability of

constraints element-wise to constraint problems; thus, write „ {C1, . . . , Cn} for „ C1, . . . , „ Cn. Substitution action extends naturally to constraints and constraint problems.

)

I Deﬁn*ition 8 (Matching Ni, . . . , a corr)esponding and is written . . . , aj #

Problem). Given a constraint probltem, C, . . . , aj

matching problem Qj , . . . , Mi ?¥– Ni,

is ..

d*eﬁned ..

if

(

i vars(Mi))ﬂ

(#tiQvaj,rs.(.N. ,iM)) i=¥?–

A solution to such a problem, if one exists, is atpair, ( , ◊), of a freshness context, , and a variable substitution, ◊, such that dom(◊) ™ vars(Mi) and „ C ◊.

Informally, this says that a matching problem is a constraint problem in which one adds the restriction that the variables in the left-hand sides of alpha-equality constraints are disjoint from the variables in the right-hand sides and that only variables in the left-hand

E. Fairweather, M. Fernández, N. Szasz, and A. Tasistro

185

sides of equality constraints may be instantiated. There may be several i such that i „ C ◊.

As in the case of nominal terms, one can deﬁne an ordering between solutions ( i, ◊) and

deﬁne a most general solution as a least element in the ordering. However, unlike nominal

matching, here there is no unique most general solution.

The situation is similar for logical frameworks based on the lambda calculus. The solution

there is to restrict the form of matching problems. Inspired by LF, [30], the type system in

Sanecytivoanri3abisled, eXsigœnevdarsso(tt)h, attheonneido--nﬁly· Xneeisdsa

to match against a pattern term, t, such that for sub-term of t. Thus, the value of X is uniquely

determined. Note that a solution may only instantiate variables in the pattern and so if an

atom substitution occurs in the matched term then it can be treated as a constant sub-term.

Using this assumption, if a matching problem has a solution, there is a unique most general

one. that then

wTthhhaeetnacalognvosartrirtiaahibmnltetisosupcboo-tmsetrppmuont,eeËdi--tﬁui·nsXtsili,maofifltaetrrhettohpeathtctaoetnrsnutsrieasdibntteoifnocgrhmethcaketcoahlcpecdhuarar-geeanqiucneisvtoa,fleitfnhËceei,isde--nxﬁoct·epXidt

sub-term in the pattern has been solved and a unique variable substitution generated.

In addition, it is also important to note that due to the action of atom substitutions

suspended upon variables, the freshness context of a solution may contain constraints for

atoms, a ”œ atms(C).

I Deﬁnition 9 (Pattern Matching Problem). A pattern matching problem, consists of two pseudo-terms-in-context or two pseudo-types-in-context, Ò „ M and „ N , to be matched, where vars(Ò „ M ) ﬂ vars( „ N ) = ? and is written (Ò „ M ) ?¥– ( „ N ).
A solution to such a problem, if one exists, is a variable substitution, ◊, such that (ÒÕ, ◊)
is a solution to the matching problem Ò ﬁ {M ?¥– N } and there exists a freshness context # (of which each constraint, a # X, is such that a ”œ atms(M ) ﬁ atms(N ) ﬁ atms(Ò)), such
that ﬁ # „ ÒÕ.

A newly-freshened variant of a term, t, is a term, written tN, in which all the atoms and variables have been replaced by newly generated atoms and variables with respect to those occurring in t (and maybe other elements of syntax, always speciﬁed.)
Closed terms were introduced in [15] and shown there to be decidable by an algorithm using newly-freshened variants and nominal matching. Intuitively, a closed term has no unabstracted atoms and all occurrences of a variable must appear under the same abstracted atoms. Here, closedness can be checked in a similar way using the matching algorithm mentioned above.

3 Type System
This section starts by introducing the syntax of environments, declarations and judgements used in this type system. The validity of environments (Deﬁnition 11), validity of sets of declarations (Deﬁnition 10), and derivability of typing judgements (Deﬁnition 13), are then deﬁned by mutual induction.
A type association is a pair of a variable, X, and a type, ‡, written (X : ‡) or an atom and a type, written (a : ‡). A pseudo-environment, , is an ordered list of type associations. A pseudo-environment may contain at most one type association for each variable and atom. Here, let on (a : · ), denote the result of appending (a : · ) to the end of the list that represents the pseudo-environment, (similarly for a variable association) and let this notation be extended element-wise to lists of associations. The association available for a given atom, a, in is denoted by a. If there is no type association for a in then a is

TLCA’15

186 Dependent Types for Nominal Terms with Atom Substitutions

undeﬁned, written ‹ (similarly for a variable.) The domain of , denoted dom( ), and image of , denoted img( ), are deﬁned as usual: dom( ) = {a œ A | a ”= ‹} ﬁ {X œ X | X ”= ‹} and img( ) = {· | ÷a, a = · } ﬁ {· | ÷X, X = · }. It is important to note that type
associations for variables are never appended by the typing rules, however the rules for

abstractions and abstraction types do append type associations for atoms.

A pseudo-declaration,

„ f t : È‡ Òæ · Í or

„ C t : È‡ Òæ typeÍ, states

the type associations and freshness constraints that a term must satisfy in order that an

application or constructed type built from that term be well-formed. Thus, informally, this

says that if under the type associations in , and the freshness constraints in , t has type ‡

then f t has type · , or similarly that C t is of the kind type. In practice, users need not give

complete declarations; it is su cient to write

„ f t : · or

„ C t : type and the

system will infer the complete declaration by computing the type of t.

Pseudo-declarations are given for a term-former or type-former together with an argument

term in order to allow the use of atoms of that argument in the type of the application or

constructed type; for example, see the declarations for alli and alle in Section 5.

A pseudo-judgement,

„ t : · or

„ · : type, speciﬁes that under a given

environment, set of declarations and freshness context, either a term has a particular type or

a type is well-formed.

A valid set of declarations, , written validD( ), is deﬁned inductively as follows.

I Deﬁnition 10 (Valid Set of Declarations).

The empty set of declarations, ?, is valid; validD(?).

If validD( ),

„ f t : È‡ Òæ · Í is a valid declaration under the following conditions.

„ t : ‡, where vars(‡) ™ vars(t) ﬁ vars(· )

„ · : type, where · is not an abstraction type

„ {t, for any

‡, · } is variable,

closed X œ vars(t)

ﬁ

vars(· ),

then

the

sub-term,

id--ﬁ

·

X,

occurs

in

either

t

or · .

Then, provided that there is no declaration in for the term-former, f, it holds that

validD( ﬁ {

„ f t : È‡ Òæ · Í}).

If validD( ), then

„ C t : È‡ Òæ typeÍ is a valid declaration under the following

conditions.

„ t : ‡, where vars(‡) ™ vars(t)

„ {t, for any

‡} is closed variable, X œ

vars(t)

then

the

sub-term,

id--ﬁ

·

X,

occurs

in

t

Then, provided that there is no declaration in for the type-former, C, validD( ﬁ {

„ C t : È‡ Òæ typeÍ}).

Assuming a freshness context, , and a valid set of declarations, , a valid environment, written validE( , , ), is deﬁned as follows.

I Deﬁnition 11 (Valid Environments).

The empty list of type associations, ≠, is a valid environment; validE(≠, , ).

If validE( , , ), then validE( on (a : · ), , ﬁ Õ), for any Õ that does not mention

atoms in dom( ), provided that a ”œ dom( ),

„ · : type.

If validE( , , ), then validE( on (X : · ), , ﬁ Õ), for any Õ that does not mention

atoms in dom( ), provided that X ”œ dom( ), for any atom, a, such that „ a # X then

„ a # ·, a # img( ), and

„ · : type.

E. Fairweather, M. Fernández, N. Szasz, and A. Tasistro

187

Informally, the ﬁnal condition upon variable associations says that in a valid environment,
if an atom cannot occur unabstracted in an instance of a variable, X, then it cannot occur
unabstracted in the typing of that variable either.
Typing judgements are derived inductively using the rules given in Deﬁnition 13. The declarations provided by the user are required in the rules for term-formers, (app)· , and type-formers, (cns)· . Declarations are matched to pseudo-terms and pseudo-types using
pattern matching and therefore each time an application or constructed type is typed a
newly-freshened variant of the declaration for that term-former or type-former is generated; we write Ò „ f s : È‡ Òæ ﬂÍ œ N (similarly for a constructed type) to emphasise the fact that such a newly-freshened variant of a declaration is being used. In the rule for a variable, (var)· , a predicate, typV is used.

I Deﬁnition 12. Let |X , for X œ dom( including the pair (X : · ). Write typV( ,

), ,

be ,

tËh--eﬁ,lisXt )ofifatshsoecfioaltloiownisnginconudiptitoonsbhuotldn.ot

for any atom a œ dom( |X ), either for any variable Y œ dom( |X ),

„

a„#Ë--Xﬁ

or ·Y

:

(ﬁ

·

„ Ë(ﬁ(a)) : (ﬁ · Y)Ë

a) Ë

„ (ﬁ · X ) Ë : type

This deﬁnition indicates that for any atom, a, that can occur unabstracted in an instance

of the variable, X, then Ë(ﬁ(a)) must be typeable with a type compatible with the type of a.

Similarly, variables that have a type compatible

may with

bËe--ﬁu.sed

in

the

typing

of

X

(i.e.,

that

occur

in

before X) also

In the rule (abs)· , the atom b is not in the set of atoms occurring in the judgement,

„ [a : ‡] t : [a : ‡] · and the freshness context, #, is such that # „ b # t, b # ‡, b # · .

Similarly in (abt)· , b is not in the set of atoms occurring in

„ [a : ‡] · : type and #,

is such that # „ b # ‡, b # · .

In the rule (app)· , sol(◊) means that the variable substitution, ◊, is a most general solution

to the pattern matching problem (Ò „ (C s ◊ ﬂ)) ?¥– ( ﬁ # „ (C t ◊ · )), where # is

a freshness context such that atms(s) ﬁ atms(ﬂ) # vars(t) ﬁ vars(· ) and C, is an arbitrary

type-constructor used so that the argument term and application type may both be included

within the same pattern matching problem. Similarly in (cns)· , ◊ is a most general solution

to (Ò „ s) ?¥– ( ﬁ # „ t) where # is atms(s) # vars(t).

I Deﬁnition 13 (Typing rules).

validE( ,

,

)

(ﬁ ·

X

)

Ë=· „ Ë--ﬁ

·

typV( X: ·

,

,

, Ë--ﬁ, X) (var)·

validE( , , ) a = · (atm)· „ a: ·

on (b : ‡)

ﬁ # „ (a b) · t : (a b) · · (abs)· „ [a : ‡] t : [a : ‡] ·

validE( , , ) (tpl : 0)· „ () : ()

„ t1 : ·1 . . .

„ tn : ·n (tpl : n)·

„ (t1, . . . , tn) : (·1 ◊ . . . ◊ ·n)

„ t: ‡◊

„ · : type (app)· !

„ f t: ·

" Ò „ f s : È‡ Òæ ﬂÍ œ N, sol(◊)

on (b : ‡)

ﬁ # „ (a b) · · : type (abt)· „ [a : ‡] · : type

validE( , , ) (prd : 0)· „ () : type

„ ·1 : type . . .

„ ·n : type (prd : n)·

„ (·1 ◊ . . . ◊ ·n) : type

TLCA’15

188 Dependent Types for Nominal Terms with Atom Substitutions

„ t : ‡ ◊ (cns)· ! „ C t : type

" Ò „ C s : È‡ Òæ typeÍ œ N, sol(◊)

„ t: ·

„ ‡ ¥– · (–)·

„ t: ‡

Note that in the rules, (atm)· , (var)· , (tpl : 0)· and (prd : 0)· , the validity of the

environment is needed as and also, that in the rule,

a(vparre)m· i,stehbeescuasupseentshioene,nËv--iﬁro, nmmuesntt,be

, is not applied

assumed to be to the type,

valid X.

4 Meta-theory

The type system presented works uniformly on –-equivalence classes of terms and types (see Theorem 18 below.) In order to prove this property, some standard properties (weakening, strengthening and validity of typing environments) are ﬁrst stated. The section is concluded with the substitution theorems.

I Theorem 14 (Type Strengthening). 1. If

ﬁ Õ „ t : · (resp.

ﬁ Õ „ · : type)

and Õ mentions atoms that are not in dom( ) then

„ t : · (resp.

„

· : type).

2. If on (a1 : ‡1) . . . (an : ‡n)

„ t : · (resp. on (a1 : ‡1) . . . (an : ‡n)

„ · : type)

and „ ai # t, · (1 Æ i Æ n) then

„ t : · (resp.

„ · : type).

Proof. Both parts are proved by induction on the type derivation.

J

I Theorem 15 (Type Weakening).

1. If

„ t : · (resp.

„ · : type), then Õ

· : type), for any Õ, Õ such that Õ = on 1, Õ ´

2. If on (a1 : ‡1) on (a2 : ‡2) on Õ

„ t : · (resp.

„ · : type), then on (a2 : ‡2) on (a1 : ‡1) on Õ

(a1 : ‡1) on Õ

„ · : type provided „ a1 # ‡2.

Õ „ t : · (resp. Õ

Õ„

and validE( Õ, , Õ).

on (a1 : ‡1) on (a2 : ‡2) on Õ

„ t : · (resp. on (a2 : ‡2) on

Proof. By simultaneous induction on the type derivation.

J

I Theorem 16 (Validity of Typing Environments). For any given validD( ): If „ t : · then validE( , , ) and „ · : type.
If „ · : type then validE( , , ).

Proof. Both parts are proved by induction on the type derivation, using weakening (in the

case where the last rule used was (atm)· ) and strengthening in the cases where the last rule

used is an abstraction rule (for types or terms).

J

I Lemma 17. If „ ds(Ë1--ﬁ1, Ë2--ﬁ2) # X then For any M (pseudo-term or pseudo-type), if
(ﬁ1 · M ) Ë1 ¥– (ﬁ2 · M ) Ë2.

„„dsd(sË(1Ë--1ﬁ--1ﬁ,1

,Ë2Ë--2ﬁ--2ﬁ)2#)

X. #M

,

then

„

Proof. The ﬁrst part is a consequence of the deﬁnition of valid environment. The second

part is proved by induction on the deﬁnition of ¥–.

J

I Theorem 18 (Unicity of Types). If then „ ·1 ¥– ·2.

„ t : ·1 and

„ tÕ : ·2, where „ t ¥– tÕ,

Proof. 1. If

„ t : ·1 and

„ t : ·2, then „ ·1 ¥– ·2.

E. Fairweather, M. Fernández, N. Szasz, and A. Tasistro

189

2. If

„ t : · , „ t ¥– tÕ, „ ¥– Õ then Õ

„ tÕ : · , where „ ¥– Õ

indicates that for each mapping (a : ‡) (resp. (X : ‡)) in , Õ contains a mapping (a : ‡Õ)

(resp. (X : ‡Õ)) such that „ ‡ ¥– ‡Õ. Similarly for types: if

„ · : type,

„ · ¥– · Õ, „ ¥– Õ then Õ

„ · Õ : type.

The ﬁrst part is proved by induction on the type derivation for

„ t : ·1. The

only case that is not straightforward is the case in which the derivation concludes using

the rule (app)· . In this case, the unicity of the type is a consequence of the fact that

declarations do not overlap (that is, there is a unique declaration that matches the term

considered) and matching problems have unique most general solutions under the assumptions

for declarations.

The Lemma

second part is proved by induction 17 is needed to derive typV( Õ, ,

on ,

tËhÕe--ﬁtyÕ,pXe d).erivation.

In

the

case

of

a

variable, J

I Theorem 19 (Preservation of Types by Atom Substitution). If

’X

„ · : type) œ dom( ),

and
Õ

ﬁ,

Ë, Õ„

ËÕ,--ﬁ

Õ are such that: · X : (ﬁ · X ) Ë

’a œ dom( ), either „ a # t or Õ

Õ „ Ë(ﬁ(a)) : (ﬁ · a) Ë

then Õ

Õ „ (ﬁ · t) Ë : (ﬁ · · ) Ë (resp. Õ

Õ „ (ﬁ · · ) Ë : type)

„ t : · (resp.

Proof. By induction on the type derivation. In the case where the last rule applied is (app)·

or (cns)· , one relies on the fact that declarations are closed (that is, there are no unabstracted

atoms.) The cases of abstraction rules (for terms or types) follow by induction, since atom

substitutions are capture-avoiding.

J

I Theorem 20 (Preservation of Types by Variable Substitution). If

„ t : · (resp.

„ · : type) and ◊ is a variable substitution such that:

’X œ dom( ), Õ

Õ „ ◊(X) : X ◊ and Õ „ ◊

’a œ dom( ), either „ a # t or Õ

Õ „ a: a ◊

then Õ

Õ „ t ◊ : · ◊ (resp. Õ

Õ „ · ◊ : type)

Proof. By induction on the type derivation. In the case where the term is of the form ◊--ﬁ · X

and the last rule applied is (var)· Theorem 19 for atom substitutions is used.

J

5 Extended Example
First-order logic is a proto-typical system with binding. We consider the language of Arithmetic, and start the speciﬁcation by deﬁning type-formers for natural numbers, propositions and proofs, and term-formers to build numbers, 0 (zero) and s (successor) and propositions, bot (‹), imp (∆) and all (’).
≠ ? „ N : type ≠ ? „ Prop : type P : Prop ? „ Proof P : type
≠ ? „ 0: N X: N ? „ sX: N ≠ ? „ bot : Prop P1 : Prop, P2 : Prop ? „ imp (P1, P2) : Prop P : Prop ? „ all [x : N] P : Prop

TLCA’15

190 Dependent Types for Nominal Terms with Atom Substitutions
Now, deﬁne declarations for the predicates used to build proofs; the introduction and elimination of imp and all, impi, impe, alli and alle and the elimination of bot, bote.
P1 : Prop, P2 : Prop, Q : Proof P2 x # P1, x # P2 „ impi [x : Proof P1] Q : Proof imp (P1, P2)
P1 : Prop, P2 : Prop, Q : Proof imp (P1, P2), Q1 : Proof P1 ? „ impe (Q, Q1) : Proof P2
P : Prop, Q : Proof bot ? „ bote (P, Q) : Proof P
P : Prop, Q : [x : N] Proof P ? „ alli Q : Proof all [x : N] P
P : Prop, Q : Proof all [x : N] P, N : N x # N „ alle (Q, N ) : Proof [x ‘æ N ] · P
Note that in the declaration for bote one must use variables, P and Q, as arguments because of the restriction that all variables in the type of bote should occur in its arguments or in its types. Notice also that in the declaration for alli above, the variable, Q, of type [x : N] Proof P , is used, in other words, n is not unabstracted, as expected. The full declaration, which can be inferred is P : Prop, Q : [x : N] Proof P ? „ alli Q : È[x : N] Proof P Òæ Proof all ([x : N] P )Í. When this declaration is used to type terms built with alli, pattern matching is used to obtain the values of P and Q.
An induction principle over the natural numbers could be deﬁned as follows.
P : Prop, Q0 : Proof [x ‘æ 0] · P, Q1 : [n : N] [p : Proof [x ‘æ n] · P ] Proof [x ‘æ s n] · P n # P „ ind (Q0, Q1) : Proof all [x : N] P
An encoding of a system in a logical framework is adequate if it faithfully reﬂects the properties of the encoded system. For instance, in the case of an encoding of ﬁrst-order logic, one needs to show that the terms used in the dependent type system represent ﬁrst-order terms, that formulae and proofs correspond to their standardly acknowledged notions, and that only provable propositions have a proof in the system. The goal is to prove that there is a bijection between proofs in ﬁrst-order logic and the corresponding terms in this system. A formal speciﬁcation of ﬁrst-order logic terms, formulae and proofs is given and then it is shown that these are encoded by terms of the correct type and that encoded terms represent only well-formed terms, formulae and proofs. The theorems and proofs presented here follow closely those given in [24] to prove the adequacy of LF but are much simpler due to the fact that here lambda calculus —-reduction is not involved and therefore all terms are of canonical form.
The following grammars deﬁne the syntax of the sets of terms (Trm) and formulae (Frm) of ﬁrst-order logic.
I Deﬁnition 21 (First-order Logic Terms and Formulae).
T, TÕ ::= 0 | s(T) | x F, FÕ ::= ‹ | F æ FÕ | ’x. F
Let fvars(T) and fvars(F) denote respectively the set of free variables in the term, T, and the formula, F. Extend this notation element-wise to sets of formulae.

E. Fairweather, M. Fernández, N. Szasz, and A. Tasistro

191

A translation function JTK is deﬁned by induction on T, from Trm to terms in the system using the term-formers, 0 and s, for which, see Section 5. Note that the free variables of T are encoded as unabstracted atoms in JTK. A corresponding translation function is deﬁned over the elements of Frm.

J0K = 0

J‹K

= bot

Js(T)K = s JTK JF1 æ F2K = imp (JF1K, JF2K)

JxK = x J’x. FK = all [x : N] JFK

Using the declarations given above, it can now be proved both that translated terms and formulae are typeable terms of the system and that typeable encoded terms correspond exactly to well-formed ﬁrst-order logic terms and formulae.

I Theorem 22. For any term, T œ Trm, such that fvars(T) = x1, . . . , xn and freshness

context, , if x1 : N, . . . , xn : N

„ JTK : N.

Similarly for any F œ Frm, such that fvars(F) = x1, . . . , xn, and freshness context, ,

x1 : N, . . . , xn : N

„ JFK : Prop,

Proof. By structural induction on the syntax of elements of Trm and Frm.

J

I Theorem 23. If

„ t : N is a derivable typing judgement and the environment, ,

contains only type associations for unabstracted atoms of the form (a : N), then t © JTK for

some term T œ Trm.

Similarly, if

„ t : Prop is a derivable typing judgement and the environment, ,

contains only type associations for unabstracted atoms of the form (a : N), then t © JFK for

some formula F œ Frm.

Proof. By induction on typing judgement derivations. The only applicable cases are when

the ﬁrst step of the derivation is by one of the rules, (atm), (app) or (–).

J

In order to show the adequacy of the encoding of proofs of ﬁrst-order formulae, ﬁrst, a natural deduction presentation is given for ﬁrst-order logic, inspired by the one used in [24] to prove the adequacy of the encoding in LF.
Let judgements have the form E „V P : F, indicating that there is a proof P of the formula F, using the list of hypotheses, E, and the set of free variables, V, where (fvars(E) ™ V). The introduction rules for implication and universal quantiﬁcation are shown below.

E, (vF1 : F1) „V P : F2 E „V æi (P \ vF1 ) : F1 æ F2

E „Vﬁ{x} P : F E „V ’i(x. P) : ’x. F

Here, vF1 is the variable name of a proof of F1, the notation (P \ vF1 ) denotes the proof P where vF1 is discharged, and in the rule for ’i, the condition fvars(E) ™ V on judgements implies that x is not used in E.
A natural deduction judgement, J, of the form E „V P : F is translated to a typing judgement of the system, JJK, as follows.

JE „V P : FK = JVK on JEK JPKvars(JJK) „ JPK : Proof JFK
Here, if V is {x1, . . . , xn} then JVK = x1 : N, . . . , xn : N and JEK contains vFi : Proof JFiK for each (vFi : Fi) in . The translation function from proofs to terms, JPK, is deﬁned inductively; two cases are given.

J’i(x. P)K = alli [x : N] JPK Jæi (P \ vF1 )K = impi [vF1 : Proof JF1K] JPK

TLCA’15

192 Dependent Types for Nominal Terms with Atom Substitutions

A second translation function from a proof, P, to a freshness context, parameterised by a set of variables, X , and written JPKX is also required; again two cases are given.

J’i(x. P)KX = JP KX Jæi (P \ vF1 )KX = {vF1 # X | X œ X } ﬁ JP KX

One can now prove the following property relating natural deduction proofs in ﬁrst-order logic and their encoding in the system presented here.

I Theorem 24. If E „V P : F is a derivable judgement, J, of natural deduction then JVK on JEK JPKvars(JJK) „ JPK : Proof JFK is a derivable typing judgement.

Proof. By induction on the syntax of the proof, P. In the case where P is of the form

æi (PÕ \ vF1 ) of these, the use of the rule (–) follows from the fact that JPKvars(JJK) „ vF1 #

JF1K, vF1 # JF2K.

J

Finally, in order to complete the adequacy proof, it is shown that only provable ﬁrst-order formulae are encoded by terms of type Proof t.

I Theorem 25. If

„ s : Proof t where the environment, , contains only type

associations for atoms either of the form (a : N ) or (vF1 : Proof ti) where ti © JFiK is an

encoding of some formula Fi, then s © JPK where P is a proof by natural deduction of some

formula F such that t © JFK.

Proof. By induction on typing judgement derivations. In the derivation for impi, „ vF1 # t1, vF1 # t2, vF1 # impi [vF1 : Proof t1] sÕ and so vF1 cannot be a free variable of P or F. J

6 Related Work
Nominal sets have been used to give semantics to systems based on nominal abstract syntax (see, for instance, [31, 18, 7, 11]) and proof theories for nominal logic have also been considered [19, 6]). Atom substitutions and their properties have been deﬁned as systems of equational rules in [17, 21, 15]. Nominal equational theories have been investigated in [22, 10, 15] amongst others, and type systems for nominal terms and equational theories, using rank-1 polymorphic types, are deﬁned in [14, 13, 12]. However, although proofs play an important role in all of these works, none of these systems deal explicitly with proof terms, and do not yield directly a nominal type theory. Nominal type theory has been investigated by Schöpp and Stark [34], using categorical models of nominal logic. The nominal dependent type theories developed following this approach are very expressive, but it is not clear whether their computational properties make them suitable for use in a logical framework. Nominal type theory as a basis for logical frameworks has been investigated by Cheney [8, 9], as extensions of a typed ⁄-calculus with names, name-abstraction and concretion operators, and name-abstraction types. A system combining ⁄-calculus and nominal features is also investigated by Pitts [32] to deﬁne a nominal version of Gödel’s System T. A key di culty encountered when following the approach of combining ⁄-calculus and nominal syntax is the interaction between name abstraction and functional abstraction (see [8] for a detailed discussion.) Westbrook [36] extends the Calculus of Inductive Constructions with a nameabstraction construct in the style of [8].
One of the best known examples of logical frameworks is LF [24], based on a typed ⁄-calculus with dependent types. The system presented here has similar expressive power, however there is no primitive notion of functional abstraction, instead there are term- and type- constructors in the user-deﬁned signature. Other di erences with LF include the

E. Fairweather, M. Fernández, N. Szasz, and A. Tasistro

193

distinction between atoms (which can be abstracted or unabstracted), variables (which cannot be abstracted but can be instantiated, with non-capture-avoiding substitutions), and the use of name swappings (or more generally, permutations), to axiomatise –-equivalence.
Compared with previous approaches to the deﬁnition of ⁄-free logical frameworks [26, 1, 33], abstraction is a ﬁrst-class ingredient in the syntax presented here and can be used in arguments for term- or type-constructors (as in [26, 1, 33]), or on its own (unlike [26, 1]) although user-deﬁned constructors of abstraction type are not allowed. Also, as in [26, 1, 33], instantiation is a primitive notion in the system; it is used instead of the application operation used in ⁄-calculus based logical frameworks. However the approach here does not rely on explicit lists of arities and ÷-long normal forms as in [26, 1]. The triggering of suspended atom substitutions by instantiating variables is similar to the hereditary substitution mechanism of DMBEL [33].
There may exist similarities between the work here and that of ‘contextual modal type theory’ [28], and the dependent type system of this paper may beneﬁt from a study of the handling of type environments and substitutions therein.
7 Conclusions and Future Work
This paper has presented a dependent type system for nominal terms with atom substitutions. A deﬁnition of matching over this syntax have been given together with an algorithm for solving such problems. This algorithm has been implemented but the complexity of problems has not been analysed; this is left for future work. A set of axioms and rules was then deﬁned for determining the typeability of pseudo-terms and pseudo-types in this system in the presence of user-deﬁned declarations for term-formers and type-formers. An extended example for ﬁrst-order logic was presented and its adequacy proven. The type system itself has not been implemented. In its present form, the inclusion of the rule (–)· means that the inference of derivations is not completely syntax-directed. This property, that derivable typing judgements hold for alpha-equivalent classes of types, may be derivable and if so should help in the development of a type inference algorithm for the system. Further beneﬁts may also be gained from the inclusion of some of the more sophisticated ideas used for other type systems considered in [12]. Although we have not included computation rules in our language, dynamic features, such as reduction in the ⁄-calculus, or proof normalisation for a logic, may be represented using relations between terms. However, a more direct deﬁnition using equality axioms, such as in [26], would be easier to use. An extension of the logical framework to include a user-deﬁned nominal equational theory, speciﬁed as a set of equality axioms or rewriting rules, also remains as future work.
References
1 Robin Adams. Lambda-free logical frameworks. CoRR, abs/0804.1879, 2008. 2 Stuart F. Allen, Robert L. Constable, Richard Eaton, Christoph Kreitz, and Lori Lorigo.
The Nuprl open logical environment. In Automated Deduction – CADE-17, 2000. 3 Franz Baader and Wayne Snyder. Uniﬁcation theory. In Handbook of Automated Reasoning.
Elsevier, 2001. 4 Christophe Calvès and Maribel Fernández. Matching and alpha-equivalence check for nom-
inal terms. Journal of Computer System Sciences, 76, 2010. 5 Christophe Calvès and Maribel Fernández. The ﬁrst-order nominal link. In Logic-Based
Program Synthesis and Transformation – 20th International Symposium, LOPSTR 2010,

TLCA’15

194 Dependent Types for Nominal Terms with Atom Substitutions
Hagenberg, Austria, July 23-25, 2010, Revised Selected Papers, volume 6564 of Lecture Notes in Computer Science, pages 234–248. Springer, 2011. 6 James Cheney. A simpler proof theory for nominal logic. In FoSSaCS, 2005. 7 James Cheney. Completeness and Herbrand theorems for nominal logic. Journal of Symbolic Logic, 71, 2006. 8 James Cheney. A simple nominal type theory. Electronic Notes in Theoretical Computer Science, 228, 2009. 9 James Cheney. A dependent nominal type theory. Logical Methods in Computer Science, 8, 2012. 10 Ranald A. Clouston. Equational Logic for Names and Binding. PhD thesis, University of Cambridge, 2010. 11 Roy L. Crole and Frank Nebel. Nominal lambda calculus: An internal language for fmcartesian closed categories. Electr. Notes Theor. Comput. Sci., 298:93–117, 2013. 12 Elliot Fairweather. Type Systems for Nominal Terms. PhD thesis, King’s College London, 2014. 13 Elliot Fairweather, Maribel Fernández, and Murdoch J. Gabbay. Principal types for nominal theories. In Proceedings of the 18th International Symposium on Fundamentals of Computation Theory (FCT 2011), 2011. 14 Maribel Fernández and Murdoch J. Gabbay. Curry-style types for nominal terms. In Types for Proofs and Programs (TYPES’06). Springer, 2007. 15 Maribel Fernández and Murdoch J. Gabbay. Nominal rewriting. Information and Computation, 205, 2007. 16 Maribel Fernández and Murdoch J. Gabbay. Closed nominal rewriting and e ciently computable nominal algebra equality. In Proceedings of the 5th International Workshop on Logical Frameworks and Meta-Languages (LFMTP 2010), 2010. 17 Murdoch J. Gabbay. A study of substitution, using nominal techniques and FraenkelMostowski sets. Theoretical Computer Science, 410, 2009. 18 Murdoch J. Gabbay. Two-level nominal sets and semantic nominal terms: an extension of nominal set theory for handling meta-variables. Mathematical Structures in Computer Science, 21, 2011. 19 Murdoch J. Gabbay and James Cheney. A sequent calculus for nominal logic. In Proceedings of the 19th IEEE Symposium on Logic in Computer Science (LICS 2004), 2004. 20 Murdoch J. Gabbay and Aad Mathijssen. Nominal algebra. In 18th Nordic Workshop on Programming Theory, 2006. 21 Murdoch J. Gabbay and Aad Mathijssen. Capture-avoiding substitution as a nominal algebra. Formal Aspects of Computing, 20, 2008. 22 Murdoch J. Gabbay and Aad Mathijssen. Nominal universal algebra: Equational logic with names and binding. Journal of Logic and Computation, 19, 2009. 23 Murdoch J. Gabbay and Andrew M. Pitts. A new approach to abstract syntax involving binders. In Proceedings of the 14th Annual Symposium on Logic in Computer Science (LICS 1999), pages 214–224. IEEE Computer Society Press, July 1999. 24 Robert Harper, Furio Honsell, and Gordon Plotkin. A framework for deﬁning logics. In Proceedings of the 2nd IEEE Symposium on Logic in Computer Science (LICS 1987). IEEE Computer Society Press, 1987. 25 Jordi Levy and Mateu Villaret. An e cient nominal uniﬁcation algorithm. In Proceedings of the 21st International Conference on Rewriting Techniques and Applications (RTA 2010), 2010. 26 Zhaohui Luo. PAL+: a lambda-free logical framework. Journal of Functional Programming, 13, 2003.

E. Fairweather, M. Fernández, N. Szasz, and A. Tasistro

195

27 Lena Magnusson and Bengt Nordström. The ALF proof editor and its proof engine. In Types for Proofs and Programs, (TYPES’93), 1994.
28 Aleksandar Nanevski, Frank Pfenning, and Brigitte Pientka. Contextual modal type theory. ACM Transactions on Computational Logic, 9, 2008.
29 Bengt Nordström, Kent Petersson, and Jan Smith. Programming in Martin-Löf’s Type Theory. Oxford University Press, 1990.
30 Frank Pfenning and Carsten Schürmann. System description: Twelf – a meta-logical framework for deductive systems. In Automated Deduction – CADE-16, 1999.
31 Andrew M. Pitts. Nominal logic: A ﬁrst order theory of names and binding. In Proceedings of the 4th International Symposium on Theoretical Aspects of Computer Software (STACS 2001), 2001.
32 Andrew M. Pitts. Nominal system T. In Proceedings of the 37th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL 2010), 2010.
33 Gordon Plotkin. An algebraic framework for logics and type theories, 2006. Talk given at LFMTP’06.
34 Ulrich Schöpp and Ian Stark. A Dependent Type Theory with Names and Binding. In CSL, 2004.
35 Christian Urban, Andrew M. Pitts, and Murdoch J. Gabbay. Nominal uniﬁcation. Theoretical Computer Science, 323, 2004.
36 Edwin Westbrook. Higher-order Encodings with Constructors. PhD thesis, Washington University in St. Louis, 2008.

TLCA’15

