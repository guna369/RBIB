A Theory of Software Product Line Reﬁnement
Paulo Borba, Leopoldo Teixeira and Rohit Gheyi
Informatics Center – Federal University of Pernambuco Department of Computing Systems – Federal University of Campina Grande
{phmb,lmt}@cin.ufpe.br -- rohit@dsc.ufcg.edu.br
Abstract. To safely derive and evolve a software product line, it is important to have a notion of product line refactoring and its underlying reﬁnement notion, which assures behavior preservation. In this paper we present a general theory of product line reﬁnement by extending a previous formalization with explicit interfaces between our theory and the diﬀerent languages that can be used to create product line artifacts. More important, we establish product line reﬁnement properties that justify stepwise and compositional product line development and evolution.
1 Introduction
A software product line is a set of related software products that are generated from reusable assets. Products are related in the sense that they share common functionality. Assets correspond to components, classes, property ﬁles, and other artifacts that are composed in diﬀerent ways to specify or build the diﬀerent products. This kind of reuse targeted at a speciﬁc set of products can bring signiﬁcant productivity and time to market improvements [PBvdL05,vdLSR07].
To obtain these beneﬁts with reduced upfront investment, previous work [Kru02,CN01,AJC+05] proposes to minimize the initial product line (domain) analysis and development process by bootstraping existing related products into a product line. In this context it is important to rely on a notion of product line refactoring [Bor09], which provides guidance and safety for deriving a product line from existing products, and also for evolving a product line by simply improving its design or by adding new products while preserving existing ones. Product line refactoring goes beyond program refactoring notions [Opd92,Fow99,BSCC04,CB05] by considering both sets of reusable assets that not necessarily correspond to valid programs, and extra artifacts, such as feature models [KCH+90,CE00], which are necessary for automatically generating products from assets.
Instead of focusing on the stronger notion of refactoring, in this paper we focus on the underlying notion of product line reﬁnement, which

2 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi
also captures behavior preservation but abstracts quality improvement. This allows us to develop a formal theory of product line reﬁnement, extending the previous formalization [Bor09] with explicit assumptions about the diﬀerent languages that can be used to create product line artifacts. More important, we establish product line reﬁnement properties that justify safe stepwise and compositional product line development and evolution. Our theory is encoded in the Prototype Veriﬁcation System (PVS) [ORS92], which provides mechanized support for formal speciﬁcation and veriﬁcation. All properties are proved using the PVS prover.
This text is organized as follows. Section 2 introduces basic concepts and notation for feature models and other extra product line artifacts [CE00,BB09]. Several assumptions and axioms explicitly establish the interfaces between our theory and particular languages used to describe a product line. Deﬁnitions and lemmas are introduced to formalize auxiliary concepts and properties. Following that, in Sec. 3, we discuss and formalize our notion of product line reﬁnement. We also derive basic properties that justify stepwise product line development and evolution. Next, Sec. 4 presents the product line reﬁnement compositionality results and their proofs. We discuss related work in Sec. 5 and conclude with Sec. 6. Finally, Appendix A contains proofs omitted in the main text.
2 Product lines concepts
In the product line approach formalized in this paper, automatic generation of products from assets is enabled by Feature Models and Conﬁguration Knowledge (CK) [CE00]. A feature model speciﬁes common and variant features among products, and is used for describing and selecting products based on the features they support. A CK relates features and assets, specifying which assets implement possible feature combinations. Hence a CK can be used to actually build a product given chosen features for that product. We now explain in more detail these two kinds of artifacts and related concepts, using examples from the Mobile Media product line [FCS+08], which contains applications – such as the one illustrated in Fig. 1 – that manipulate photo, music, and video on mobile devices.
2.1 Feature models
A feature model is essentially represented as a tree, containing features and information about how they are related. Features basically abstract

A Theory of Software Product Line Reﬁnement

3

Fig. 1. Mobile Media screenshots

groups of associated requirements, both functional and non-functional. In the particular feature model notation illustrated here, relationships between a parent feature and its child features (subfeatures) indicate whether the subfeatures are optional (present in some products but not in others, represented by an unﬁlled circle), mandatory (present in all products, represented by a ﬁlled circle), or (every product has at least one of them, represented by a ﬁlled triangular shape), or alternative (every product has exactly one of them, represented by an unﬁlled triangular shape). For example, Fig. 2 depicts a simpliﬁed Mobile Media feature model, where Sorting is optional, Media is mandatory, Photo and Music are or-features, and the two illustrated screen sizes are alternative.

Mobile Media

Media

Management

Screen Size

Photo Music Send Photo Sorting 128x149 240x320 Send Photo Photo

Fig. 2. Mobile Media simpliﬁed feature model

Besides these relationships, feature models may contain propositional logic formulas about features. Feature names are used as atoms to indicate that a feature should be selected. So negation of a feature indicates that

4 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi
it should not be selected. For instance, the formula just below the tree in Fig. 2 states that feature Photo must be present in some product whenever feature Send Photo is selected. So
{Photo, Send Photo, 240x320},
together with the mandatory features, which hereafter we omit for brevity, is a valid feature selection (product conﬁguration), but
{Music, Send Photo, 240x320}
is not. Likewise {Music, Photo, 240x320} is a valid conﬁguration, but
{Music, Photo, 240x320, 128x149}
is not because it breaks the Screen Size alternative constraint. In summary, a valid conﬁguration is one that satisﬁes all feature model constraints, speciﬁed both graphically and through formulas.
The set of all valid conﬁgurations often represents the semantics of a feature model. However, as diﬀerent feature model notations might express constraints and conﬁgurations in diﬀerent ways, our product line reﬁnement theory abstracts the details and just assumes a generic function [[ ]] for obtaining the semantics of a feature model as a set of conﬁgurations.
Assumption 1 Feature model semantics F eatureM odel : T Y P E Conf iguration : T Y P E [[ ]] : F eatureM odel → set[Conf iguration]
We use simpliﬁed PVS notation for introducing the mentioned function and related types. In PVS, TYPE declares an uninterpreted type that imposes no assumptions on implementations of the speciﬁcation.
As shall be clear latter, these concepts are all we require about feature models. With them, we can deﬁne our product line reﬁnement notion and derive its properties. So our theory applies for any feature model notation whose semantics can be expressed as a set of conﬁgurations. This is the case of the feature model notation illustrated in this section and others, which have been formalized elsewhere [GMB08,AGM+06,CHE05,Bat05,SHTB07].
Given a notion of feature model semantics, it is useful to deﬁne a notion of feature model equivalence to reason about feature models. Two feature models are equivalent iﬀ they have the same semantics.

A Theory of Software Product Line Reﬁnement

5

Deﬁnition 1 Feature model equivalence Feature models F and F are equivalent, denoted F ∼= F , whenever [[F ]] = [[F ]].
Again, this is quite similar to the PVS speciﬁcation, which deﬁnes the equivalence as a function with the following type:
∼= : F eatureM odel, F eatureM odel → bool
Hereafter we omit such typing details, and overload symbols, but the types can be easily inferred from the context.
We now establish the equivalence properties for the just introduced function.
Theorem 1 Feature model equivalence – reﬂexivity ∀F : F eatureM odel · F ∼= F
Proof: Follows directly from Deﬁnition 1 and the reﬂexivity of the equality of conﬁguration sets.

Theorem 2 Feature model equivalence – symmetry ∀F, F : F eatureM odel · F ∼= F ⇒ F ∼= F
Proof: Follows directly from Deﬁnition 1 and the symmetry of the equality of conﬁguration sets.

Theorem 3 Feature model equivalence – transitivity ∀F, F , F : F eatureM odel · F ∼= F ∧ F ∼= F ⇒ F ∼= F
Proof: Follows directly from Deﬁnition 1 and the transitivity of the equality of conﬁguration sets.
These properties justify safe stepwise evolution of feature models, as illustrated in previous work [AGM+06].

2.2 Assets and products
Besides a precise notion of feature model semantics, for deﬁning product line reﬁnement we assume means of comparing assets and products with respect to behavior preservation. We distinguish arbitrary asset sets (set[Asset]) from well-formed asset sets (P roduct), which correspond to valid products in the underlying languages used to describe assets. We assume the wf function speciﬁes well-formedness, and denotes both asset and product reﬁnement.

6 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi
Assumption 2 Asset and product reﬁnement Asset : T Y P E : Asset, Asset → bool wf : set[Asset] → bool P roduct : T Y P E = (wf ) : P roduct, P roduct → bool
We use the PVS notation for deﬁning the Product type as the set of all asset sets that satisfy the wf predicate.
Our product line reﬁnement theory applies for any asset language with these notions as long as they satisfy the following properties. Both asset and product reﬁnement must be pre-orders.
Axiom 1 Asset reﬁnement reﬂexivity ∀a : Asset · a a
Axiom 2 Asset reﬁnement transitivity ∀a, b, c : Asset · a b ∧ b c ⇒ a c
Axiom 3 Product reﬁnement reﬂexivity ∀p : P roduct · p p
Axiom 4 Product reﬁnement transitivity ∀p, q, r : P roduct · p q ∧ q r ⇒ p r
These are usually properties of any reﬁnement notion because they are essential to support stepwise reﬁnement and development. This is, for example, the case of existing reﬁnement notions for object-oriented programming and modeling [BSCC04,GMB05,MGB08].
Finally, asset reﬁnement must be compositional in the sense that reﬁning an asset that is part of a valid product yields a reﬁned valid product.
Axiom 5 Asset reﬁnement compositionality ∀a, a : Asset · ∀s : set[Asset]· a a ∧ wf (a ∪ s) ⇒ wf (a ∪ s) ∧ a ∪ s a ∪ s

A Theory of Software Product Line Reﬁnement

7

We use ∪ both to denote set union and insertion of an element to a set. Such a compositionality property is essential to guarantee independent
development of assets in a product line, and is supported, for example, by existing class reﬁnement notions [SB04]. In that context, a product is a main command with a set of class declarations that coherently resolves all references to class and method names. In general, we do not have to limit ourselves to code assets, and consider any kind of asset that supports the concepts and properties discussed in this section.

2.3 Conﬁguration knowledge

As discussed in Sec. 2.1, features are groups of requirements, so they must be related to the assets that realize them. This is speciﬁed by the conﬁguration knowledge (CK), which can be expressed in many ways, including as a relation from feature expressions (propositional formulas having feature names as atoms) to sets of asset names [BB09]. For example, showing the relation in tabular form, the following CK

Mobile Media Photo Music
Photo ∨ Music Photo ∧ Music

MM.java, ... Photo.java, ... Music.java, ... Common.aj, ... AppMenu.aj, ...

establishes that if the Photo and Music features are both selected then the AppMenu asset, among others omitted in the ﬁfth row, should be part of the ﬁnal product. Essentially, this product line uses the AppMenu aspect as a variability implementation mechanism [GA01,AJC+05] that has the eﬀect of presenting the left screenshot in Fig. 1. For usability issues, this screen should not be presented by products that have only one of the Media features, so the need for the ﬁfth row in the simpliﬁed Mobile Media CK. Similarly, some assets are shared by the Photo and Music implementations, so we write the fourth row to avoid repeating the asset names on the second and third rows.
Given a valid product conﬁguration, the evaluation of a CK yields the names of the assets needed to build the corresponding product. In our example, the conﬁguration {Photo, 240x320}1 leads to
{MM.java, . . . , Photo.java, . . . , Commom.aj, . . . }.
1 Remember we omit mandatory features for brevity.

8 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi
This gives the basic intuition for the semantics of a CK. It is a function that maps product conﬁgurations into ﬁnite sets (represented by fset) of asset names. So our product line reﬁnement theory relies on a CK semantic function [[ ]] as follows.
Assumption 3 CK semantics CK : TY PE AssetN ame : T Y P E [[ ]] : CK → Conf iguration → f set[AssetN ame]
For the CK notation illustrated in this section, the semantics of a given CK K, represented as [[K]], could be deﬁned in the following way: for a conﬁguration c, an asset name n is in the set [[K]]c iﬀ there is a row in K that contains n and its expression evaluates to true according to c. But we do not give further details because our aim is to establish a product line reﬁnement theory that is independent of CK notation, as long as this notation’s semantics can be expressed as a function that maps conﬁgurations into ﬁnite sets of assets names.
Similarly to what we have done for feature models, we deﬁne a notion of CK equivalence based on the notion of CK semantics. This is useful to reason about CK. Two CK speciﬁcations are equivalent iﬀ they have the same semantics.
Deﬁnition 2 Conﬁguration knowledge equivalence Conﬁguration knowledge K is equivalent to K , denoted K ∼= K , whenever [[K]] = [[K ]].
We now establish the equivalence properties for the just introduced relation.
Theorem 4 Conﬁguration knowledge equivalence – reﬂexivity ∀K : CK · K ∼= K
Proof: Follows directly from Deﬁnition 2 and the reﬂexivity of the equality of functions.
Theorem 5 Conﬁguration knowledge equivalence – symmetry ∀K, K : CK · K ∼= K ⇒ K ∼= K
Proof: Follows directly from Deﬁnition 2 and the symmetry of the equality of functions.

A Theory of Software Product Line Reﬁnement

9

Theorem 6 Conﬁguration knowledge equivalence – transitivity ∀K, K , K : CK · K ∼= K ∧ K ∼= K ⇒ K ∼= K

Proof: Follows directly from Deﬁnition 2 and the transitivity of the equality of functions.

2.4 Asset mapping
Although the CK illustrated in the previous section refers only to code assets, in general we could also refer to requirements documents, design models, test cases, image ﬁles, XML ﬁles, and so on. For simplicity, we focus on code assets as they are equivalent to other kinds of asset for our purposes. The important issue here is not the nature of asset contents, but how the assets are compared and referred to in the CK.
We cover asset comparison in Sec. 2.2. For dealing with asset references, each product line keeps a mapping such as the following
class Main { {Main 1 → ...new StartUp(...);...
}
class Main { Main 2 → ...new OnDemand(...);...
}
class Common { Common.java → ...
} ... }
from asset names used in a CK to actual assets. So, besides a feature model and a CK, a product line contains an asset mapping, which basically corresponds to an environment of asset declarations. This allows conﬂicting assets in a product line, like assets that implement alternative features, such as both Main classes in the illustrated asset mapping.
Formally, we specify asset mappings in PVS as follows.

10 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi
Deﬁnition 3 Asset mapping Let r be a ﬁnite set of name-asset pairs (r : f set[AssetN ame, Asset]).
mapping(r) : bool = ∀n : AssetN ame · ∀a, b : Asset· (n, a) ∈ r ∧ (n, b) ∈ r ⇒ a = b
AssetM apping : T Y P E = (mapping)
Since there is not much to abstract from this notion of asset mapping, it is actually deﬁned as part of our theory. Diﬀerently from the concepts of feature model, CK, and their semantics, the asset mapping concept is not a parameter to our theory.
We also deﬁne auxiliary functions that are used to deﬁne product line reﬁnement. The second one is mapping application over a set. In the following, consider that m : AssetM apping and s : f set[AssetN ame].
Deﬁnition 4 Auxiliary asset mapping functions
dom(m) : set[AssetN ame] = {n : AssetN ame | ∃a : Asset · (n, a) ∈ m}
m s : set[Asset] = {a : Asset | ∃n ∈ s · (n, a) ∈ m}
We use the notation ∃n ∈ s·p(n) as an abbreviation for the PVS notation ∃n : AssetN ame · n ∈ s ∧ p(n).
To derive product line reﬁnement properties, we establish several properties of the introduced auxiliary functions. The proofs appear in Appendix A.
Lemma 1 Distributed mapping over union For asset mapping A, asset a, and ﬁnite sets of asset names S and S , if
a∈A S∪S
then
a∈A S ∨a∈A S

A Theory of Software Product Line Reﬁnement

11

Lemma 2 Distributed mapping over singleton For asset mapping A, asset name an and ﬁnite set of asset names S, if
an ∈ dom(A)
then
∃a : Asset · (an, a) ∈ A ∧ A an ∪ S = a ∪ A S

Remember we use ∪ both for set union and insertion of an element to a set. Lemma 3 Asset mapping domain membership For asset mapping A, asset name an and asset a, if
(an, a) ∈ A
then
an ∈ dom(A)

Lemma 4 Distributed mapping over set of non domain elements For asset mapping A and ﬁnite set of asset names S, if
¬∃n ∈ S · n ∈ dom(A)
then
A S = {}
For reasoning about asset mappings, we deﬁne a notion of asset mapping reﬁnement. Asset mapping equivalence could also be deﬁned, but we choose the weaker reﬁnement notion since it gives us more ﬂexibility when evolving asset mappings independently of other product line elements such as feature models and CK. As shall be clear latter, we can rely on reﬁnement for asset mappings but not for the other elements; that is why, in previous sections, we deﬁne equivalences for them. For asset mapping reﬁnement, exactly the same names should be mapped, not necessarily to the same assets, but to assets that reﬁne the original ones.

12 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi

Deﬁnition 5 Asset mapping reﬁnement For asset mappings A and A , the ﬁrst is reﬁned by the second, denoted

AA

whenever

dom(A) = dom(A ) ∧ ∀n ∈ dom(A)·
∃a, a : Asset · (n, a) ∈ A ∧ (n, a ) ∈ A ∧ a

a

We use ∀n ∈ dom(A) · p(n) to abbreviate the PVS notation
∀n : AssetN ame · n ∈ dom(A) ⇒ p(n)
Note also that a a in the deﬁnition refers to asset reﬁnement, not to program reﬁnement.
We now prove that asset mapping reﬁnement is a pre-order.
Theorem 7 Asset mapping reﬁnement reﬂexivity

∀A : AssetM apping · A A
Proof: For an arbitrary asset mapping A, from Deﬁnition 5 we have to prove that

dom(A) = dom(A) ∧ ∀n ∈ dom(A)·
∃a, a : Asset · (n, a) ∈ A ∧ (n, a ) ∈ A ∧ a

a

The ﬁrst part of the conjunction follows from equality reﬂexivity. For an arbitrary n ∈ dom(A), we are left to prove

∃a, a : Asset · (n, a) ∈ A ∧ (n, a ) ∈ A ∧ a a

(1)

From Deﬁnition 4, as n ∈ dom(A), we have that

n ∈ {n : AssetN ame | ∃a : Asset · (n, a) ∈ A}

By set comprehension and membership, we have that

∃a : Asset · (n, a) ∈ A

Let a1 be such a. Then we have (n, a1) ∈ A. From this and Axiom 1, we easily obtain 1 taking a and a as a1.

A Theory of Software Product Line Reﬁnement

13

Theorem 8 Asset mapping reﬁnement transitivity

∀A, A , A : AssetM apping · A A ∧ A A ⇒ A A
Proof: For arbitrary asset mappings A, A , and A , assume that A and A A . From Deﬁnition 5 we have to prove that

A

dom(A) = dom(A ) ∧ ∀n ∈ dom(A)·
∃a, a : Asset · (n, a) ∈ A ∧ (n, a ) ∈ A ∧ a

a

The ﬁrst part of the conjunction follows from our assumptions, Deﬁnition 5, and equality transitivity. For an arbitrary n ∈ dom(A), we are left to prove

∃a, a : Asset · (n, a) ∈ A ∧ (n, a ) ∈ A ∧ a a

(2)

But from our assumptions and Deﬁnition 5 we have that n ∈ dom(A ) and therefore
(n, a) ∈ A ∧ (n, a ) ∈ A ∧ a a (n, a ) ∈ A ∧ (n, a ) ∈ A ∧ a a

for some a, a , a : Asset. We then have the a and a necessary to obtain 2 directly from this and the transitivity of asset reﬁnement (Axiom 2).

To establish the compositionality results, we rely on an important property of asset mapping reﬁnement: if A A then products formed by using A assets are reﬁned by products formed by corresponding A assets.

Lemma 5 Asset mapping compositionality For asset mapping A and A , if
AA
then ∀ans : f set[AssetN ame] · ∀as : f set[Asset]· wf (as ∪ A ans ) ⇒ wf (as ∪ A ans ) ∧ as ∪ A ans as ∪ A ans

14 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi
2.5 Product lines
We can now provide a precise deﬁnition for product lines. In particular, a product line consists of a feature model, a CK, and an asset mapping that jointly generate products, that is, valid asset sets in their target languages.
Deﬁnition 6 Product line For a feature model F , an asset mapping A, and a conﬁguration knowledge K, we say that tuple
(F, A, K)
is a product line when, for all c ∈ [[F ]],
wf (A [[K]]c )
We omit the PVS notation for introducing the P roductLine type, but it roughly corresponds to the one we use in this deﬁnition.
The well-formedness constraint in the deﬁnition is necessary because missing an entry on a CK might lead to asset sets that are missing some parts and thus are not valid products. Similarly, a mistake when writing a CK or asset mapping entry might yield an invalid asset set due to conﬂicting assets, like two aspects that are used as variability mechanism [GA01,AJC+05] and introduce methods with the same signature in the same class. Here we demand product line elements to be coherent as explained.
Given the importance of the well-formedness property in this definition, we establish compositionality properties related to the wellformedness function wf . First we have that feature model equivalence is compositional with respect to wf .
Lemma 6 Feature model equivalence compositionality over wf For feature models F and F , asset mapping A, and conﬁguration knowledge K, if
F ∼= F ∧ ∀c ∈ [[F ]] · wf (A [[K]]c )
then
∀c ∈ [[F ]] · wf (A [[K]]c )

A Theory of Software Product Line Reﬁnement

15

Similarly, for CK we have the following. Lemma 7 CK equivalence compositionality over wf For feature model F , asset mapping A, and conﬁguration knowledge K and K , if
K ∼= K ∧ ∀c ∈ [[F ]] · wf (A [[K]]c )
then
∀c ∈ [[F ]] · wf (A [[K ]]c )

Finally, for asset mappings we have that reﬁnement is compositional with respect to wf .
Lemma 8 Asset mapping reﬁnement compositionality over wf For feature model F , asset mapping A and A and conﬁguration knowledge K, if
A A ∧ ∀c ∈ [[F ]] · wf (A [[K]]c )
then
∀c ∈ [[F ]] · wf (A [[K]]c )

3 Product line reﬁnement
Now that we better understand what a product line is, we can introduce a notion of product line reﬁnement that provides guidance and safety for deriving a product line from existing products, and also for evolving a product line by simply improving its design or by adding new products while preserving existing ones.
Similar to program and model reﬁnement [BSCC04,GMB05], product line reﬁnement preserves behavior. However, it goes beyond source code and other kinds of reusable assets, and considers transformations to feature models and CK as well. This is illustrated by Fig. 3, where we reﬁne the simpliﬁed Mobile Media product line by renaming the feature Music.

16 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi

Media

Mobile Media Management

Screen Size

Photo Music Send Photo Sorting 128x149 240x320

Send Photo Photo

Mobile Media Photo Music
Photo ∨ Music Photo ∧ Music

MM.java, ... Photo.java, ... Music.java, ... Common.aj, ... AppMenu.aj, ...

Photo.java

Music.java

Mobile Media

Media

Management

Screen Size

✔ Photo Audio Send Photo Sorting 128x149 240x320

Send Photo Photo

Mobile Media Photo
✔ Audio ✔ Photo ∨ Audio ✔ Photo ∧ Audio

MM.java, ... Photo.java, ... ✔ Audio.java, ... Common.aj, ... AppMenu.aj, ...

Photo.java ✔

✔Audio.java

Fig. 3. Product line renaming reﬁnement

As indicated by check marks, this renaming requires changing the feature model, CK, and asset mapping; due to a class name change, we must apply a global renaming, so the main method and other classes beyond Music.java are changed too.
The notion of behavior preservation should be also lifted from assets to product lines. In a product line reﬁnement, the resulting product line should be able to generate products that behaviorally match the original product line products. So users of an original product cannot observe behavior diﬀerences when using the corresponding product of the new product line. With the renaming reﬁnement, for example, we have only improved the product line design: the resulting product line generates a set of products exactly equivalent to the original set. But it should not be always like that. We consider that the better product line might generate more products than the original one. As long as it generates enough products to match the original product line, users have no reason to complain. For instance, by adding the optional Copy feature (see Fig. 4), we reﬁne our example product line. The new product line generates twice as many products as the original one, but what matters is that half of them – the ones that do not have feature Copy – behave exactly as the original products. This ensures that the transformation is safe; we extended the product line without impacting existing users.
3.1 Formalization
We formalize these ideas in terms of product reﬁnement (see Assumption 2). Basically, each program generated by the original product line must be reﬁned by some program of the new, improved, product line.

A Theory of Software Product Line Reﬁnement

17

Media

Mobile Media Management

Screen Size

Photo Music Send Photo Sorting 128x149 240x320

Send Photo Photo

Mobile Media Photo Music
Photo ∨ Music Photo ∧ Music

MM.java, ... Photo.java, ... Music.java, ... Common.aj, ... AppMenu.aj, ...

Photo.java

AppMenu.aj

Mobile Media

Media

Management

Screen Size

✔ Photo Music Send Photo Sorting Copy 128x149 240x320

Send Photo Photo

Mobile Media Photo Music
Photo ∨ Music Photo ∧ Music ✔ Copy ✔ Copy ∧ Photo

MM.java, ... Photo.java, ... Music.java, ... Common.aj, ... AppMenu.aj, ... Copy.java, ... CopyPhoto.aj, ...

Photo.jaCvoapyPhot✔o.aj AppMenu.aj

Fig. 4. Adding an optional feature reﬁnement

Deﬁnition 7 Product line reﬁnement For product lines (F, A, K) and (F , A , K ), the ﬁrst is reﬁned by the second, denoted
(F, A, K) (F , A , K )
whenever
∀c ∈ [[F ]] · ∃c ∈ [[F ]] · A [[K]]c A [[K ]]c

Remember that, for a conﬁguration c, a conﬁguration knowledge K, and an asset mapping A related to a given product line, A [[K]]c is a wellformed set of assets. So A [[K]]c A [[K ]]c refers to the product reﬁnement notion discussed in Sec. 2.2.
3.2 Examples and considerations
To explore the deﬁnition just introduced, let us analyze a few concrete product line transformation scenarios.
Feature names do not matter First let us see how the deﬁnitions applies to the transformation depicted by Fig. 3. The feature models diﬀer only by the name of a single feature. So they generate the same set of conﬁgurations, modulo renaming. For instance, for the source (left) product line conﬁguration {Music, 240x320} we have the target (right) product line conﬁguration {Audio, 240x320}. As the CKs have the same structure, evaluating them with these conﬁgurations yield

18 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi
{Commmon.aj, Music.java, . . . }
and
{Commmon.aj, Audio.java, . . . }.
The resulting sets of asset names diﬀer at most by a single element: Audio.java replacing Music.java. Finally, when applying these sets of names to both asset mappings, we obtain the same assets modulo global renaming, which is a well known reﬁnement for closed programs. This is precisely what, by Deﬁnition 7, we need for assuring that the source product line is reﬁned by the target product line.
This example shows that our reﬁnement deﬁnition focus on the product line themselves, that is, the sets of products that can be generated. Contrasting with our previous notion of feature model refactoring [AGM+06], feature names do not matter. So users will not notice they are using products from the new product line, although developers might have to change their feature nomenclature when specifying product conﬁgurations. Not caring about feature names is essential for supporting useful reﬁnements such as the just illustrated feature renaming and others that we discuss later.
Safety for existing users only To further explore the deﬁnitions, let us consider now the transformation shown in Fig. 4. The target feature model has an extra optional feature. So it generates all conﬁgurations of the source feature model plus extensions of these conﬁgurations with feature Copy. For example, it generates both {Music, 240x320} and {Music, 240x320, Copy}. For checking reﬁnement, we focus only on the common conﬁgurations to both feature models – conﬁgurations without Copy. As the target CK is an extension of the source CK for dealing with cases when Copy is selected, evaluating the target CK with any conﬁguration without Copy yields the same asset names yielded by the source CK with the same conﬁguration. In this restricted name domain, both asset mappings are equal, since the target mapping is an extension of the ﬁrst for names such as CopyPhoto.java, which appears only when Copy is selected. Therefore, the resulting assets produced by each product line are the same, trivially implying program reﬁnement and then product line reﬁnement.
By focusing on the common conﬁgurations to both feature models, we check nothing about the new products oﬀered by the new product line. In fact, they might even not operate at all. Our reﬁnement notion

A Theory of Software Product Line Reﬁnement

19

assures only that users of existing products will not be disappointed by the corresponding products generated by the new product line. We give no guarantee to users of the new products, like the ones with Copy functionalities in our example. So reﬁnements are safe transformations only in the sense that we can change a product line without impacting existing users.

Non reﬁnements As discussed, the transformation depicted in Fig. 3 is a reﬁnement. Classes and aspects are transformed by a global renaming, which preserves behavior for closed programs. But suppose that, besides renaming, we change the AppMenu.aj2 aspect so that, instead of the menu on the left screenshot in Fig. 1, we have a menu with “Photos” and “Audio” options. The input-output behavior of new and original products would then not match, and users would observe the diﬀerence. So we would not be able to prove program reﬁnement, nor product line reﬁnement, consequently.
Despite not being a reﬁnement, this menu change is an useful product line improvement, and should be carried on. The intention, however, is to change behavior, so developers will not be able to rely on the beneﬁts of checking reﬁnement. The beneﬁts of checking for reﬁnement only apply when the intention of the transformation is to improve product line conﬁgurability or internal structure, without changing observable behavior.

3.3 Basic properties To support stepwise product line development and evolution, we now establish that product line reﬁnement is a pre-order. Theorem 9 Product line reﬁnement reﬂexivity
∀l : P roductLine · l l Proof: Let l = (F, A, K) be an arbitrary product line. By Deﬁnition 7, we have to prove that
∀c ∈ [[F ]] · ∃c ∈ [[F ]] · A [[K]]c A [[K]]c
For an arbitrary c ∈ [[F ]], just let c be c and the proof follows from product reﬁnement reﬂexivity (Axiom 3).
2 See Sec. 2.3 for understanding the role this aspect plays.

20 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi
Theorem 10 Product line reﬁnement transitivity

∀l1, l2, l3 : P roductLine · l1 l2 ∧ l2 l3 ⇒ l1 l3
Proof: Let l1 = (F1, A1, K1), l2 = (F2, A2, K2), l3 = (F3, A3, K3) be arbitrary product lines. Assume that l1 l2 ∧ l2 l3. By Deﬁnition 7, this amounts to

∀c1 ∈ [[F1]] ∧ ∃c2 ∈ [[F2]] · A1 [[K1]]c1 A2 [[K2]]c2

(3)

and

∀c2 ∈ [[F2]] · ∃c3 ∈ [[F3]] · A2 [[K2]]c2 A3 [[K3]]c3

(4)

We then have to prove that

∀c1 ∈ [[F1]] · ∃c3 ∈ [[F3]] · A1 [[K1]]c1 A3 [[K3]]c3 For an arbitrary c1 ∈ [[F1]], we have to prove that
∃c3 ∈ [[F3]] · A1 [[K1]]c1 A3 [[K3]]c3

(5)

Properly instantiating c1 in 3, we have ∃c2 ∈ [[F2]] · A1 [[K1]]c1 A2 [[K2]]c2

Let c2 be such c2. Properly instantiating c2 in 4, we have ∃c3 ∈ [[F3]] · A2 [[K2]]c2 A3 [[K3]]c3
Let c3 be such c3. Then we have A1 [[K1]]c1 A2 [[K2]]c2 ∧ A2 [[K2]]c2 A3 [[K3]]c3
By product reﬁnement transitivity (Axiom 4), we have

A1 [[K1]]c1 A3 [[K3]]c3 This gives us the c3 in 5 that completes our proof.

A Theory of Software Product Line Reﬁnement

21

4 Product line reﬁnement compositionality
The product line reﬁnement notion allows one to reason about a product line as a whole, considering its three elements (artifacts): feature model, CK, and asset mapping. However, for independent development of product line artifacts, we must support separate and compositional reasoning for each product line artifact. This allows us to evolve product line artifacts independently. We ﬁrst consider feature models. Replacing a feature model by an equivalent one leads to a reﬁned product line.
Theorem 11 Feature model equivalence compositionality For product lines (F, A, K) and (F , A, K), if
F ∼= F
then
(F, A, K) (F , A, K)
Proof: For arbitrary F , F , A, K, assume that F ∼= F . By Deﬁnition 7, we have to prove that
∀c ∈ [[F ]] · ∃c ∈ [[F ]] · A [[K]]c A [[K]]c
From our assumption and Deﬁnition 1, this is equivalent to
∀c ∈ [[F ]] · ∃c ∈ [[F ]] · A [[K]]c A [[K]]c
For an arbitrary c ∈ [[F ]], just let c be c and the proof follows from product reﬁnement reﬂexivity (Axiom 4).
We require feature model equivalence because feature model reﬁnement, which requires [[F ]] ⊆ [[F ]] instead of [[F ]] = [[F ]], is not enough for ensuring that separate modiﬁcations to a feature model imply reﬁnement for the product line. In fact, reﬁnement allows the new feature model to have extra conﬁgurations that might not generate valid products; the associated feature model reﬁnement transformation would not lead to a valid product line. For example, consider that the extra conﬁgurations result from eliminating an alternative constraint between two features, so that they become optional. The assets that implement these features might well be incompatible, generating an invalid program when both features are selected. Reﬁnement of the whole product line, in this case, would also demand changes to the assets and CK.
We can also independently evolve a CK. For similar reasons, we require CK equivalence as well.

22 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi
Theorem 12 CK equivalence compositionality For product lines (F, A, K) and (F, A, K ), if
K ∼= K
then
(F, A, K) (F, A, K )
Proof: The proof is similar to that of Theorem 11, using Deﬁnition 2 instead of Deﬁnition 1.
Note that the reverse does not hold because the asset names generated by K and K might diﬀer for assets that have no impact on product behavior,3 or for assets that have equivalent behavior but are named diﬀerently in the product lines. For similar reasons, the reverse does not hold for Theorem 11.
For asset mappings, we can rely only on reﬁnement. Separately reﬁning an asset mapping implies reﬁnement for the product line as a whole.

Theorem 13 Asset mapping reﬁnement compositionality For product lines (F, A, K) and (F, A , K), if

AA

then

(F, A, K) (F, A , K)

Proof: For arbitrary F , A, A , and K, assume that A A . By Deﬁnition 7, we have to prove that

∀c ∈ [[F ]] · ∃c ∈ [[F ]] · A [[K]]c A [[K]]c

For an arbitrary c ∈ [[F ]], if we prove

A [[K]]c A [[K]]c

(6)

then c is the necessary c we need to complete the proof. By Lemma 5 and our assumption, we have that

∀ans : f set[AssetN ame] · ∀as : f set[Asset]· wf (as ∪ A ans )
⇒ wf (as ∪ A ans ) ∧ as ∪ A ans as ∪ A ans

(7)

3 Obviously an anomaly, but still possible.

A Theory of Software Product Line Reﬁnement

23

By properly instantiating ans with [[K]]c and as with {} in 7, from set union properties we obtain

wf (A [[K]]c ) ⇒ wf (A [[K]]c ) ∧ A [[K]]c A [[K]]c

(8)

From Deﬁnition 6, we have that wf (A [[K]]c ) for all c ∈ [[F ]]. Therefore, from this and 8 we obtain

wf (A [[K]]c ) ∧ A [[K]]c A [[K]]c

concluding the proof (see 6).

Finally, we have the full compositionality theorem, which justiﬁes completely independent development of product line artifacts.
Theorem 14 Full compositionality For product lines (F, A, K) and (F , A , K ), if
F ∼= F ∧ A A ∧ K ∼= K

then

(F, A, K) (F , A , K )
Proof: First assume that F ∼= F , A A , and K ∼= K . By Lemma 6, the fact that (F, A, K) is a product line, and Deﬁnition 6, we have that (F , A, K) is a product line. Then, using Theorem 11, we have

(F, A, K) (F , A, K)

(9)

Similarly, from our assumptions, deductions, and Lemma 7 we have that (F , A, K ) is a product line. Using Theorem 12, we have

(F , A, K) (F , A, K )

(10)

Again, from our assumptions, deductions, and Lemma 8, we have that (F , A , K ) is a product line. Using Theorem 13, we have

(F , A, K ) (F , A , K )

(11)

The proof then follows from 9, 10, 11, and product line reﬁnement transitivity (Theorem 10).

24 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi
5 Related work
The notion of product line reﬁnement discussed here ﬁrst appeared in a product line refactoring tutorial [Bor09]. Besides talking about product line and population refactoring, this tutorial illustrates diﬀerent kinds of refactoring transformation templates that can be useful for deriving and evolving product lines. In this paper we extend the initial formalization of the tutorial making clear the interface between our theory and languages used to describe product line artifacts. We also derive a number of properties that were not explored in the tutorial. We encode the theory in the PVS speciﬁcation language and prove all properties with the PVS prover.
Our notion of product line reﬁnement goes beyond refactoring of feature models [AGM+06,GMB08], considering also other artifacts like conﬁguration knowledge and assets, both in isolation and in an integrated way. In particular, the reﬁnement notion explored here is independent of the language used to describe feature models. The cited formalization of feature models [AGM+06,GMB08], and others [SHTB07], could, however, be used to instantiate our theory for dealing with speciﬁc feature model notation and semantics. Similarly, our theory is independent of product reﬁnement notions. A program reﬁnement notion, like the one for a sequential subset of Java [SB04,BSCC04], could be used to instantiate our general theory.
Early work [CDCvdH03] on product line refactoring focus on Product Line Architectures (PLAs) described in terms of high-level components and connectors. This work presents metrics for diagnosing structural problems in a PLA, and introduces a set of architectural refactorings that can be used to resolve these problems. Besides being speciﬁc to architectural assets, this work does not deal with other product line artifacts such as feature models and conﬁguration knowledge. There is also no notion of behavior preservation for product lines, as captured here by our notion of product line reﬁnement.
Several approaches [KMPY05,TBD06,LBL06,KAB07] focus on refactoring a product into a product line, not exploring product line evolution in general, as we do here. First, Kolb et al. [KMPY05] discuss a case study in refactoring legacy code components into a product line implementation. They deﬁne a systematic process for refactoring products with the aim of obtaining product lines assets. There is no discussion about feature models and conﬁguration knowledge. Moreover, behavior preservation and conﬁgurability of the resulting product lines are only checked by testing. Similarly, Kastner et al. [KAB07] focus only on transforming

A Theory of Software Product Line Reﬁnement

25

code assets, implicitly relying on reﬁnement notions for aspect-oriented programs [CB05]. As discussed here and elsewhere [Bor09] these are not adequate for justifying product line reﬁnement and refactoring. Trujillo et al. [TBD06] go beyond code assets, but do not explicitly consider transformations to feature model and conﬁguration knowledge. They also do not consider behavior preservation; they indeed use the term “reﬁnement”, but in the quite diﬀerent sense of overriding or adding extra behavior to assets.
Liu et al. [LBL06] also focus on the process of decomposing a legacy application into features, but go further than the previously cited approaches by proposing a refactoring theory that explains how a feature can be automatically associated to a base asset (a code module, for instance) and related derivative assets, which contain feature declarations appropriate for diﬀerent product conﬁgurations. Contrasting with our theory, this theory does not consider feature model transformations and assumes an implicit notion of conﬁguration knowledge based on the idea of derivatives. So it does not consider explicit conﬁguration knowledge transformations as we do here. Their work is, however, complementary to ours since we abstract from speciﬁc asset transformation techniques such as the one supported by their theory. By proving that their technique can be mapped to our notion of asset reﬁnement, both theories could be used together.
The theory we present in this paper aims to formalize concepts and processes from tools [LBL06,CBS+07,ACN+08] and practical experience [ACV+05,AJC+05,KMPY05,AGM+06,TBD06,KAB07] on product line refactoring. A more rigorous evaluation of the proposed theory is, however, left as future work.

6 Conclusions
In this paper we present a general theory of product line reﬁnement, formalizing reﬁnement and equivalence notions for product lines and its artifacts: feature model, conﬁguration knowledge, and asset mapping. More important, we establish a number of properties that justify stepwise and compositional product line development and evolution. The presented theory is largely independent of the languages used to describe feature model, conﬁguration knowledge, and reusable assets. We make this explicit through assumptions and axioms about basic concepts related to these languages.

26 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi
By instantiating this theory with proper notations and semantic formalizations for feature models and the other product line artifacts, we can directly use the reﬁnement and equivalence notions, and the associated properties, to guide and improve safety of the product line derivation and evolution processes. Such an instantiation also allows one to formally prove soundness of product line refactoring transformation templates [Bor09] expressed in those notations. As the transformation templates precisely specify the transformation mechanics and preconditions, their soundness is specially useful for correctly implementing the transformations and avoiding typical problems with current program refactoring tools [ST09]. In fact, soundness could help to avoid even subtler problems that can appear with product line refactoring tools.
Acknowledgements
We would like to thank colleagues of the Software Productivity Group for helping to signiﬁcantly improve this work. M´arcio Ribeiro provided support with the Mobile Media example. Rodrigo Bonif´acio played a fundamental role developing the conﬁguration knowledge approach used here. Vander Alves and Tiago Massoni carried on the initial ideas about feature model and product line refactoring. Fernando Castor, Carlos Pontual, S´ergio Soares, Rodrigo, and M´arcio provided excellent feedback on early versions of part of the material presented here. We would also like to acknowledge current ﬁnancial support from CNPq, FACEPE, and CAPES projects, and early support from FINEP and Meantime mobile creations.
A Extra proofs
In this appendix we present the proofs we omitted in the main text. The PVS speciﬁcation of the whole theory, and proof ﬁles for all lemmas and theorems are available at http://twiki.cin.ufpe.br/twiki/bin/ view/SPG/TheorySPLRefinement.
Lemma 1 Distributed mapping over union For asset mapping A, asset a, and ﬁnite sets of asset names S and S , if
a∈A S∪S
then
a∈A S ∨a∈A S

A Theory of Software Product Line Reﬁnement

27

Proof: For arbitrary A, a, S , and S , assume a ∈ A S ∪ S . From this and Deﬁnition 4 (A ) we have
a ∈ {a : Asset | ∃n ∈ S ∪ S · (n, a) ∈ m} From set union and membership properties, we have
a ∈ {a : Asset | ∃n ∈ S · (n, a) ∈ m ∨ ∃n ∈ S · (n, a) ∈ m} From set comprehension properties, we have a ∈ {a : Asset | ∃n ∈ S · (n, a) ∈ m} ∪ {a : Asset | ∃n ∈ S · (n, a) ∈ m} By applying twice Deﬁnition 4 (A ), we derive
a∈A S ∪A S The proof follows from the above and set membership properties.

Lemma 2 Distributed mapping over singleton For asset mapping A, asset name an, and ﬁnite set of asset names S, if

an ∈ dom(A)

then

∃a : Asset · (an, a) ∈ A ∧ A an ∪ S = a ∪ A S

Proof: For arbitrary A, an, and S, assume an ∈ dom(A). From this, Deﬁnition 4 (dom), and set comprehension and membership properties, we have

∃a : Asset · (an, a) ∈ A

(12)

Let a1 be such a. By Deﬁnition 4 (A ), we have A an ∪ S = {a : Asset | ∃n ∈ an ∪ S · (n, a) ∈ A}

Again, by set membership and comprehension properties, we have

A an ∪ S = {a : Asset | ∃n ∈ {an} · (n, a) ∈ A}
∪ {a : Asset | ∃n ∈ S · (n, a) ∈ A}

By Deﬁnition 4 (A ), our assumption that A is an asset mapping, and set membership and comprehension properties, we have

A {an} ∪ S = a1 ∪ A S

From this and remembering that 12 was instantiated with a1, a1 provides the a we need to conclude the proof.

28 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi
Lemma 3 Asset mapping domain membership For asset mapping A, asset name an, and asset a, if
(an, a) ∈ A then
an ∈ dom(A) Proof: For arbitrary A, an, and a, assume (an, a) ∈ A. By Deﬁnition 4 (dom), we have to prove that
∃x : Asset | (an, x) ∈ A Let x be a, and this concludes the proof.
Lemma 4 Distributed mapping over set of non domain elements For asset mapping A and ﬁnite set of asset names S, if
¬∃n ∈ S · n ∈ dom(A) then
A S = {} Proof: For arbitrary A and S, assume ¬∃n ∈ S · n ∈ dom(A). By Deﬁnition 4 (A ), we have to prove that
{a : Asset | ∃n ∈ S · (n, a) ∈ A} = {} By Lemma 3, we then have to prove that
{a : Asset | ∃n ∈ S · n ∈ dom(A) ∧ (n, a) ∈ A} = {} The proof follows from the above, our assumption, and set comprehension properties.
Lemma 5 Asset mapping compositionality For asset mapping A and A , if
AA

A Theory of Software Product Line Reﬁnement

29

then ∀ans : f set[AssetN ame] · ∀as : f set[Asset]· wf (as ∪ A ans ) ⇒ wf (as ∪ A ans ) ∧ as ∪ A ans as ∪ A ans

Proof: For arbitrary A and A , assume A A . From Deﬁnition 5, we have

dom(A) = dom(A )

∧ ∀n ∈ dom(A)·

(13)

∃a, a : Asset · (n, a) ∈ A ∧ (n, a ) ∈ A ∧ a a

By induction on the cardinality of ans, assume the induction hypothesis

∀ans : f set[AssetN ame]· card(ans ) < card(ans)
⇒ ∀as : f set[Asset]· wf (as ∪ A ans )
⇒ wf (as ∪ A ans ) ∧ as ∪ A ans

as ∪ A ans

(14)

and we have to prove

∀as : f set[Asset]· wf (as ∪ A ans )
⇒ wf (as ∪ A ans ) ∧ as ∪ A ans

as ∪ A ans

(15)

By case analysis, now consider that ¬(∃an ∈ ans · an ∈ dom(A)). By Lemma 4, we have that A ans = {}. Similarly, given that dom(A) = dom(A ) (see 13), we also have that A ans = {}. So, by set union properties, we are left to prove that

∀as : f set[Asset] · wf (as) ⇒ wf (as) ∧ as as

The proof trivially follows from Axiom 3 and propositional calculus. Let’s now consider the case ∃an ∈ ans · an ∈ dom(A). By basic set
properties, we have that ans = an ∪ ans for some asset name an ∈ dom(A) and set ans such that an ∈ ans . Then, from 15, we are left to prove that

∀as : f set[Asset]· wf (as ∪ A an ∪ ans )
⇒ wf (as ∪ A an ∪ ans ) ∧ as ∪ A an ∪ ans as ∪ A an ∪ ans

30 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi

By Lemma 2, given that an ∈ dom(A) and consequently an ∈ dom(A ), we have that A an ∪ ans = a∪A ans and A an ∪ ans = a ∪A ans for some assets a and a . From 13, we also have that a a . By equational reasoning, we then have to prove that

∀as : f set[Asset]· wf (as ∪ a ∪ A ans )
⇒ wf (as ∪ a ∪ A ans ) ∧ as ∪ a ∪ A ans as ∪ a ∪ A ans

For an arbitrary as, assume wf (as ∪ a ∪ A ans ) and then we have to prove that

wf (as ∪ a ∪ A ans ) ∧ as ∪ a ∪ A ans as ∪ a ∪ A ans

(16)

By the induction hypothesis (see 14), instantiating ans with the ans just introduced, note that we will have card(ans ) < card(ans) and, therefore

∀as : f set[Asset]· wf (as ∪ A ans )
⇒ wf (as ∪ A ans ) ∧ as ∪ A ans

as ∪ A ans

From this, instantiating as as as ∪ a, and remembering that we have already assumed wf (as ∪ a ∪ A ans ), we have

wf (as ∪ A ans ) ∧ as ∪ A ans as ∪ A ans

Now, given that a a , from the compositionality axiom (Axiom 5) and the above we have that
wf (()as ∪ a ∪ A ans ) ∧ as ∪ a ∪ A ans as ∪ a ∪ A ans

The proof then follows from 16, the above, and Axiom 4.

Lemma 6 Feature model equivalence compositionality over wf For feature models F and F , asset mapping A, and conﬁguration knowledge K, if
F ∼= F ∧ ∀c ∈ [[F ]] · wf (A [[K]]c )

A Theory of Software Product Line Reﬁnement
then ∀c ∈ [[F ]] · wf (A [[K]]c )
Proof: For arbitrary F , F , A, and K, assume F ∼= F ∧ ∀c ∈ [[F ]] · wf (A [[K]]c )
By Deﬁnition 1, what we have to prove is equivalent to ∀c ∈ [[F ]] · wf (A [[K]]c )
which corresponds to our assumption.

31

Lemma 7 CK equivalence compositionality over wf For feature model F , asset mapping A, and conﬁguration knowledge K and K , if
K ∼= K ∧ ∀c ∈ [[F ]] · wf (A [[K]]c )
then
∀c ∈ [[F ]] · wf (A [[K ]]c )
Proof: Similar to proof of Lemma 6, using Deﬁnition 2 instead.

Lemma 8 Asset mapping reﬁnement compositionality over wf For feature model F , asset mappings A and A , and conﬁguration knowledge K, if

A A ∧ ∀c ∈ [[F ]] · wf (A [[K]]c )

then

∀c ∈ [[F ]] · wf (A [[K]]c )

Proof: For arbitrary F , A, A , and K, assume

A A ∧ ∀c ∈ [[F ]] · wf (A [[K]]c )

(17)

For an arbitrary c ∈ [[F ]], we then have to prove that

wf (A [[K]]c )

(18)

32 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi

By properly instantiating the assumption (17) with the just introduced c, we have

wf (A [[K]]c )

(19)

From Lemma 5 and the assumption (17), we have

∀ans : f set[AssetN ame] · ∀as : f set[Asset]· wf (as ∪ A ans )
⇒ wf (as ∪ A ans )∧ as ∪ A ans as ∪ A ans

Instantiating ans with [[K]]c, as with {}, and by set union properties, we have
wf (A [[K]]c ) ⇒ wf (A [[K]]c ) ∧ A [[K]]c A [[K]]c

The proof (see 18) then follows from the above and 19.

References

ACN+08.
ACV+05.
AGM+06. AJC+05. Bat05. BB09.

Vander Alves, Fernando Calheiros, Vilmar Nepomuceno, Andrea Menezes, S´ergio Soares, and Paulo Borba. FLiP: Managing software product line extraction and reaction with aspects. In 12th International Software Product Line Conference, page 354. IEEE Computer Society, 2008. Vander Alves, Ivan Cardim, Heitor Vital, Pedro Sampaio, Alexandre Damasceno, Paulo Borba, and Geber Ramalho. Comparative analysis of porting strategies in J2ME games. In 21st IEEE International Conference on Software Maintenance, pages 123–132. IEEE Computer Society, 2005. Vander Alves, Rohit Gheyi, Tiago Massoni, Uir´a Kulesza, Paulo Borba, and Carlos Lucena. Refactoring product lines. In 5th International Conference on Generative Programming and Component Engineering, pages 201–210. ACM, 2006. Vander Alves, Pedro Matos Jr., Leonardo Cole, Paulo Borba, and Geber Ramalho. Extracting and evolving mobile games product lines. In 9th International Software Product Line Conference, volume 3714 of LNCS, pages 70–81. Springer-Verlag, 2005. Don Batory. Feature models, grammars, and propositional formulas. In 9th International Software Product Lines Conference, volume 3714 of LNCS, pages 7–20. Springer-Verlag, 2005. Rodrigo Bonifa´cio and Paulo Borba. Modeling scenario variability as crosscutting mechanisms. In 8th International Conference on AspectOriented Software Development, pages 125–136. ACM, 2009.

A Theory of Software Product Line Reﬁnement

33

Bor09.

Paulo Borba. An introduction to software product line refactoring. In

3rd Summer School on Generative and Transformational Techniques in

Software Engineering (to appear), 2009.

BSCC04. Paulo Borba, Augusto Sampaio, Ana Cavalcanti, and Ma´rcio Corn´elio.

Algebraic reasoning for object-oriented programming. Science of Com-

puter Programming, 52:53–100, 2004.

CB05.

Leonardo Cole and Paulo Borba. Deriving refactorings for AspectJ. In

4th International Conference on Aspect-Oriented Software Development,

CBS+07.

pages 123–134. ACM, 2005. Fernando Calheiros, Paulo Borba, S´ergio Soares, Vilmar Nepomuceno,

and Vander Alves. Product line variability refactoring tool. In 1st Work-

shop on Refactoring Tools, pages 33–34, July 2007.

CDCvdH03. Matt Critchlow, Kevin Dodd, Jessica Chou, and Andr´e van der Hoek.

Refactoring product line architectures. In 1st International Workshop on

Refactoring: Achievements, Challenges, and Eﬀects, pages 23–26, 2003.

CE00.

Krysztof Czarnecki and Ulrich Eisenecker. Generative programming:

methods, tools, and applications. Addison-Wesley, 2000.

CHE05. Krzysztof Czarnecki, Simon Helsen, and Ulrich Eisenecker. Formalizing

cardinality-based feature models and their specialization. Software Pro-

cess: Improvement and Practice, 10(1):7–29, 2005.

CN01.

Paul Clements and Linda Northrop. Software Product Lines: Practices

FCS+08.

and Patterns. Addison-Wesley, 2001. Eduardo Figueiredo, N´elio Cacho, Claudio Sant’Anna, Ma´rio Monteiro,

Uira´ Kulesza, Alessandro Garcia, S´ergio Soares, Fabiano Ferrari, Safoora

Khan, Fernando Filho, and Francisco Dantas. Evolving software product

lines with aspects: an empirical study on design stability. In 30th In-

ternational Conference on Software Engineering, pages 261–270. ACM,

2008.

Fow99.

Martin Fowler. Refactoring: Improving the Design of Existing Code.

Addison-Wesley, 1999.

GA01.

Cristina Gacek and Michalis Anastasopoulos. Implementing product line

variabilities. SIGSOFT Software Engineering Notes, 26(3):109–117, 2001.

GMB05. Rohit Gheyi, Tiago Massoni, and Paulo Borba. An abstract equivalence

notion for object models. Electronic Notes in Theoretical Computer Sci-

ence, 130:3–21, 2005.

GMB08. Rohit Gheyi, Tiago Massoni, and Paulo Borba. Algebraic laws for feature

models. Journal of Universal Computer Science, 14(21):3573–3591, 2008.

KAB07. Christian Kastner, Sven Apel, and Don Batory. A case study implement-

ing features using AspectJ. In 11th International Software Product Line

Conference, pages 223–232. IEEE Computer Society, 2007. KCH+90. Kyo Kang, Sholom Cohen, James Hess, William Novak, and A. Spencer

Peterson. Feature-oriented domain analysis (FODA) feasibility study.

Technical Report CMU/SEI-90-TR-21, Software Engineering Institute,

Carnegie Mellon University, 1990.

KMPY05. Ronny Kolb, Dirk Muthig, Thomas Patzke, and Kazuyuki Yamauchi.

A case study in refactoring a legacy component for reuse in a product

line. In 21st International Conference on Software Maintenance, pages

369–378. IEEE Computer Society, 2005.

Kru02.

Charles Krueger. Easing the transition to software mass customization.

In 4th International Workshop on Software Product-Family Engineering,

volume 2290 of LNCS, pages 282–293. Springer-Verlag, 2002.

34 Paulo Borba, Leopoldo Teixeira and Rohit Gheyi

LBL06. MGB08.
Opd92. ORS92. PBvdL05. SB04. SHTB07. ST09.
TBD06.
vdLSR07.

Jia Liu, Don Batory, and Christian Lengauer. Feature oriented refactoring of legacy applications. In 28th International Conference on Software Engineering, pages 112–121. ACM, 2006. Tiago Massoni, Rohit Gheyi, and Paulo Borba. Formal model-driven program refactoring. In 11th International Conference on Fundamental Approaches to Software Engineering, volume 4961 of LNCS, pages 362– 376. Springer-Verlag, 2008. William Opdyke. Refactoring Object-Oriented Frameworks. PhD thesis, University of Illinois at Urbana-Champaign, 1992. Sam Owre, John Rushby, and Natarajan Shankar. Pvs: A prototype veriﬁcation system. In 11th International Conference on Automated Deduction, pages 748–752. Springer-Verlag, 1992. Klaus Pohl, Gu¨nter Bo¨ckle, and Frank van der Linden. Software Product Line Engineering: Foundations, Principles and Techniques. Springer, 2005. Augusto Sampaio and Paulo Borba. Transformation laws for sequential object-oriented programming. In Reﬁnement Techniques in Software Engineering, volume 3167 of LNCS, pages 18–63. Springer, 2004. Pierre-Yves Schobbens, Patrick Heymans, Jean-Christophe Trigaux, and Yves Bontemps. Generic semantics of feature diagrams. Computer Networks, 51(2):456–479, 2007. Friedrich Steimann and Andreas Thies. From public to private to absent: Refactoring Java programs under constrained accessibility. In 23rd European Conference on Object-Oriented Programming, volume 5653 of LNCS, pages 419–443. Springer, 2009. Salvador Trujillo, Don Batory, and Oscar Diaz. Feature refactoring a multi-representation program into a product line. In 5th International Conference on Generative Programming and Component Engineering, pages 191–200. ACM, 2006. Frank van der Linden, Klaus Schmid, and Eelco Rommes. Software Product Lines in Action: the Best Industrial Practice in Product Line Engineering. Springer, 2007.

