arXiv:1001.3604v1 [cs.SE] 20 Jan 2010

Type-Safe Feature-Oriented Product Lines
Sven Apel†, Christian Kästner‡, Armin Größlinger†, and Christian Lengauer†
† Department of Informatics and Mathematics, University of Passau {apel,groesslinger,lengauer}@uni-passau.de ‡ School of Computer Science, University of Magdeburg kaestner@iti.cs.uni-magdeburg.de
Technical Report, Number MIP-0909 Department of Informatics and Mathematics
University of Passau, Germany June 2009

Type-Safe Feature-Oriented Product Lines
Sven Apel†, Christian Kästner‡, Armin Größlinger†, and Christian Lengauer†
† Department of Informatics and Mathematics, University of Passau {apel,groesslinger,lengauer}@uni-passau.de ‡ School of Computer Science, University of Magdeburg kaestner@iti.cs.uni-magdeburg.de
Abstract. A feature-oriented product line is a family of programs that share a common set of features. A feature implements a stakeholder’s requirement, represents a design decision and conﬁguration option and, when added to a program, involves the introduction of new structures, such as classes and methods, and the reﬁnement of existing ones, such as extending methods. With feature-oriented decomposition, programs can be generated, solely on the basis of a user’s selection of features, by the composition of the corresponding feature code. A key challenge of feature-oriented product line engineering is how to guarantee the correctness of an entire feature-oriented product line, i.e., of all of the member programs generated from different combinations of features. As the number of valid feature combinations grows progressively with the number of features, it is not feasible to check all individual programs. The only feasible approach is to have a type system check the entire code base of the feature-oriented product line. We have developed such a type system on the basis of a formal model of a feature-oriented Java-like language. We demonstrate that the type system ensures that every valid program of a feature-oriented product line is well-typed and that the type system is complete.
1 Introduction
Feature-oriented programming (FOP) aims at the modularization of programs in terms of features [55,13]. A feature implements a stakeholder’s requirement and is typically an increment in program functionality [55,13]. Contemporary feature-oriented programming languages and tools such as AHEAD [13], Xak [2], CaesarJ [48], Classbox/J [14], FeatureHouse [9], and FeatureC++ [10] provide a variety of mechanisms that support the speciﬁcation, modularization, and composition of features. A key idea is that a feature is implemented by a distinct code unit, called a feature module. When added to a base program, it introduces new structures, such as classes and methods, and reﬁnes existing ones, such as extending methods [43,11]. A program that is decomposed into features is called henceforth a feature-oriented program.1
1 Typically, feature-oriented decomposition is orthogonal to class-based or functional decomposition [63,49,61]. A multitude of modularization and composition mechanisms [17,26,24,45,46,56,65] have been developed in order to allow programmers to decompose a program along multiple dimensions [63]. Feature-oriented languages and tools provide a signiﬁcant subset of these mechanisms [11].

Beside the decomposition of programs into features, the concept of a feature is useful for distinguishing different, related programs thus forming a software product line [35,21]. Typically, programs of a common domain share a set of features but also differ in other features. For example, suppose an email client for mobile devices that supports the protocols IMAP and POP3 and another client that supports POP3, MIME, and SSL encryption. With a decomposition of the two programs into the features IMAP, POP3, MIME, and SSL, both programs can share the code of the feature POP3. Since mobile devices have only limited resources, unnecessary features should be removed.
With feature-oriented decomposition, programs can be generated solely on the basis of a user’s selection of features by the composition of the corresponding feature modules. Of course, not all combinations of features are legal and result in correct programs [12]. A feature model describes which features can be composed in which combinations, i.e., which programs are valid [35,21]. It consists of an (ordered) set of features and a set of constraints on feature combinations [21,12]. For example, our email client may have different rendering engines for HTML text, e.g., the Mozilla engine or the Safari engine, but only one at a time. A set of feature modules along wit a feature model is called a feature-oriented product line [12].
An important question is how the correctness of feature-oriented programs, in particular, and product lines, in general, can be guaranteed. A ﬁrst problem is that contemporary feature-oriented languages and tools usually involve a code generation step during composition in which the code is transformed into a lower-level representation. In previous work, we have addressed this problem by modeling feature-oriented mechanisms directly in the formal syntax and semantics of a core language, called Feature Featherweight Java (FFJ). The type system of FFJ ensures that the composition of feature modules is type-safe [8].
In this paper, we address a second problem: How can the correctness of an entire feature-oriented product line be guaranteed? A naive approach would be to type-check all valid programs of a product line using a type checker like the one of FFJ [8]. However, this approach does not scale; already for 34 implemented optional features, a variant can be generated for every person on the planet. Noticing this problem, Czarnecki and Pietroszek [22] and Thaker et al. [64] suggested the development of a type system that checks the entire code base of the feature-oriented product line, instead of all individual feature-oriented programs. In this scenario, a type checker must analyze all feature modules of a product line on the basis of the feature model. We will show that, with this information, the type checker can ensure that every valid program variant that can be generated is type-safe. Speciﬁcally, we make the following contributions:
– We provide a condensed version of FFJ, which is in many respects more elegant and concise than its predecessor [8].
– We develop a formal type system that uses information about features and constraints on feature combinations in order to type-check a product line without generating every program.
– We prove correctness by proving that every program generated from a well-formed product line is well-formed, as long as the feature selection satisﬁes the constraints of the product line. Furthermore, we prove completeness by proving that the well-
2

typedness of all programs of a product line guarantees that the product line is welltyped as a whole. – We offer an implementation of FFJ, including the proposed type system, which can be downloaded for evaluation and for experiments with further feature-oriented language and typing mechanisms.
Or work differs in many respects from previous and related work (see Section 5 for a comprehensive discussion). Most notably, Thaker et al. have implemented a type system for feature-oriented product lines and conducted several case studies [64]. We take their work further with a formalization and a correctness and completeness proof.
Furthermore, our work differs in many respects from previous work on modeling and type-checking feature-oriented and related programming mechanisms. Most notably, we model the feature-related mechanisms directly in FFJ’s syntax and semantics, without any transformation to a lower-level representation, and we stay very close to the syntax of contemporary feature-oriented languages and tools (see Section 5). We begin with a brief introduction to FFJ.
2 Feature-Oriented Programs in FFJ
In this section, we introduce the language FFJ. Originally, FFJ was designed for featureoriented programs [8,7]. We extend FFJ in Section 3 to support feature-oriented product lines, i.e., to support the representation of multiple alternative program variants at a time.
2.1 An Overview of FFJ
FFJ is a lightweight feature-oriented language that has been inspired by Featherweight Java (FJ) [32]. As with FJ, we have aimed at minimality in the design of FFJ. FFJ provides basic constructs like classes, ﬁelds, methods, and inheritance and only a few new constructs capturing the core mechanisms of feature-oriented programming. But, so far, FFJ’s type system has not supported the development of feature-oriented product lines. That is, the feature modules written in FFJ are interpreted as a single program. We will change this in Section 3.
An FFJ program consists of a set of classes and reﬁnements. A reﬁnement extends a class that has been introduced previously. Each class and reﬁnement is associated with a feature. We say that a feature introduces a class or applies a reﬁnement to a class. Technically, the mapping between classes/reﬁnements and the features they belong to can be established in different ways, e.g., by extending the language with modules representing features [48,14,23] or by grouping classes and reﬁnements that belong to a feature in packages or directories [13,10].
Like in FJ, each class declares a superclass, which may be the class Object. Reﬁnements are deﬁned using the keyword reﬁnes. The semantics of a reﬁnement applied to a class is that the reﬁnement’s members are added to and merged with the member of the reﬁned class. This way, a reﬁnement can add new ﬁelds and methods to the class and override existing methods (declared by overrides).
3

On the left side in Figure 1, we show an excerpt of the code of a basic email client, called EMAILCLIENT, (top) and a feature, called SSL, (bottom) in FFJ. The feature SSL adds the class SSL (Lines 7–10) to the email client’s code base and reﬁnes the class Trans in order to encrypt outgoing messages (Lines 11–15). To this effect, the reﬁnement of Trans adds a new ﬁeld key (Line 12) and overrides the method send of class Trans (Lines 13-15).

Feature EMAILCLIENT
1 class Msg extends Object { 2 String serialize() { ... } 3} 4 class Trans extends Object { 5 Bool send(Msg m) { ... } 6}
Feature SSL
7 class SSL extends Object { 8 Trans trans; 9 Bool send(Msg m) { ... } 10 } 11 reﬁnes class Trans { 12 Key key; 13 overrides Bool send(Msg m) { 14 return new SSL(this).send(m); 15 } 16 }

EmailClient
Object Trans
Msg

SSL
Trans SSL

refines inherits class refinement refinement chain feature

Fig. 1. A feature-oriented email client supporting SSL encryption.

Typically, a programmer applies multiple reﬁnements to a class by composing a sequence of features. This is called a reﬁnement chain. A reﬁnement that is applied immediately before another reﬁnement in the chain is called its predecessor. The order of the reﬁnements in a reﬁnement chain is determined by their composition order. On the right side in Figure 1, we depict the reﬁnement and inheritance relationships of our email example.
Fields are unique within the scope of a class and its inheritance hierarchy and reﬁnement chain. That is, a reﬁnement or subclass is not allowed to add a ﬁeld that has already been deﬁned in a predecessor in the reﬁnement chain or in a superclass. For example, a further reﬁnement of Trans would not be allowed to add a ﬁeld key, since key has been introduced by a reﬁnement of feature SSL already. With methods, this is different. A reﬁnement or subclass may add new methods (overloading is prohibited) and override existing methods. In order to distinguish the two cases, FFJ expects the programmer to declare whether a method overrides an existing method (using the modiﬁer overrides). For example, the reﬁnement of Trans in feature SSL overrides the method send introduced by feature MAIL; for subclasses, this is similar.
The distinction between method introduction and overriding allows the type system to check (1) whether an introduced method inadvertently replaces or occludes an existing method with the same name and (2) whether, for every overriding method, there is a proper method to be overridden. Apart from the modiﬁer overrides, a method in FFJ is similar to a method in FJ. That is, a method body is an expression (preﬁxed with
4

return) and not a sequence of statements. This is due to the functional nature of FFJ and FJ. Furthermore, overloading of methods (introducing methods with equal names and different argument types) is not allowed in FFJ (and FJ).
As shown in Figure 1, reﬁnement chains grow from left to right and inheritance hierarchies from top to bottom. When looking up a method body, FFJ traverses the combined inheritance and reﬁnement hierarchy of an object and selects the right-most and bottom-most body of a method declaration or method reﬁnement that is compatible. This kind of lookup is necessary since we model features directly in FFJ, instead of generating and evaluating FJ code [40]. First, the FFJ calculus looks for a method declaration in the reﬁnement chain of the object’s class, starting with the last reﬁnement back to the class declaration itself. The ﬁrst body of a matching method declaration is returned. If the method is not found in the class’ reﬁnement chain or in its own declaration, the methods in the superclass (and then the superclass’ superclass, etc.) are searched, each again from the most speciﬁc reﬁnement of the class declaration itself. The ﬁeld lookup works similarly, except that the entire inheritance and reﬁnement hierarchy is searched and the ﬁelds are accumulated in a list. In Figure 2, we illustrate the processes of method body and ﬁeld lookup schematically.

Object

Class1

Ref(n,1)

Ref(n,p−1)

Ref(n,p)

Classn−1

Ref(n−1,1)

Ref(n−1,k−1)

Ref(n−1,k)

Classn

Ref(n,1)

Ref(n,m−1)

Ref(n,m)

Fig. 2. Order of method body and ﬁeld lookup in FFJ.

2.2 Syntax of FFJ
Before we go into detail, let us explain some notational conventions. We abbreviate lists in the obvious ways:
– C is shorthand for C1, . . . , Cn – C f is shorthand for C1 f1, . . . , Cn fn – C f; is shorthand for C1 f1; . . . ; Cn fn; – t : C is shorthand for t1 : C1, . . . , tn : Cn – C <: D is shorthand for C1 <: D1 . . . Cn <: Dn – ...
Note that, depending on the context, blanks, commas, or semicolons separate the elements of a list. The context will make clear which separator is meant. The symbol •
5

denotes the empty list and lists of ﬁeld declarations, method declarations, and parameter names must not contain duplicates. We use the metavariables A–E for class names, f–h for ﬁeld names, and m for method names. Feature names are denoted by Greek letters.
In Figure 3, we depict the syntax of FFJ in extended Backus-Naur-Form. An FFJ program consists of a set of class and reﬁnement declarations. A class declaration L declares a class with the name C that inherits from a superclass D and consists of a list C f; of ﬁelds and a list M of method declarations.2 A reﬁnement declaration R consists of a list C f; of ﬁelds and a list M of method declarations.

L ::= class declarations: class C extends D { C f; M }

R ::=

reﬁnement declarations:

reﬁnes class C { C f; M }

M ::=

method declarations:

[overrides] C m(C x) { return t; }

t ::= terms: x variable t.f ﬁeld access t.m(t) method invocation new C(t) object creation (C) t cast
v ::= values: new C(v) object creation

Fig. 3. Syntax of FFJ in extended BNF.

A method m expects a list C x of arguments and declares a body that returns only a single expression t of type C. Using the modiﬁer overrides, a method declares that it intends to override another method with the same name and signature. Where we want to distinguish methods that override others and methods that do not override others, we call the former method introductions and the latter method reﬁnements
Finally, there are ﬁve forms of terms: the variable, ﬁeld access, method invocation, object creation, and type cast, which are taken from FJ without change. The only values are object creations whose arguments are values as well.
2.3 FFJ’s Class Table
Declarations of classes and reﬁnements can be looked up via a class table CT. The compiler ﬁlls the class table during the parser pass. In contrast to FJ, class and reﬁnement declarations are identiﬁed not only by their names but, additionally, by the names of the enclosing features. For example, in order to retrieve the declaration of class Trans, introduced by feature MAIL, in our example of Figure 1, we write CT(MAIL.Trans); in order to retrieve the reﬁnement of class Trans applied by feature SSL, we write CT(SSL.Trans). We call Φ.C the qualiﬁed type of class C in feature Φ. In FFJ, class and reﬁnement declarations are unique with respect to their qualiﬁed types. This property is ensured because of the following sanity conditions: a feature is not allowed
2 The concept of a class constructor is unnecessary in FFJ and FJ [54]. Its omittance simpliﬁes the syntax, semantics, and type rules signiﬁcantly without loss of generality.
6

– to introduce a class or reﬁnement twice inside a single feature module and – to reﬁne a class that the feature has just introduced.
These are common sanity conditions in feature-oriented languages and tools [13,10,9]. As for FJ, we impose further sanity conditions on the class table and the inheritance
relation:
– CT (Φ.C) = class C. . . or reﬁnes class C. . . for every qualiﬁed type Φ.C ∈ dom(CT ); Feature Base plays the same role for features as Object plays for classes; it is a symbol denoting the empty feature at which lookups terminate.
– Base.Object ∈/ dom(CT ); – for every class name C appearing anywhere in CT , we have Φ.C ∈ dom(CT ) for
at least one feature Φ; and – the inheritance relation contains no cycles (incl. self-cycles).

2.4 Reﬁnement in FFJ
Information about the reﬁnement chain of a class can be retrieved using the reﬁnement table RT . The compiler ﬁlls the reﬁnement table during the parser pass. RT (C) yields a list of all features that either introduce or reﬁne class C. The leftmost element of the result list is the feature that introduces the class C and, then, from left to right, the features are listed that reﬁne class C in the order of their composition. In our example of Figure 1, RT (Trans) yields the list EMAILCLIENT, SSL. There is only a single sanity condition for the reﬁnement table:
– RT (C) = Φ for every type C ∈ dom(CT ), with Φ being the features that introduce and reﬁne class C.
In Figure 4, we show two functions for the navigation of the reﬁnement chain that rely on RT . Function last returns, for a class name C, a qualiﬁed type Ψn.C, in which Ψn refers to the feature that applies the ﬁnal reﬁnement to class C; if a class is not reﬁned at all, Ψn refers to the feature that introduces class C. Function pred returns, for a qualiﬁed type Φ.C, another qualiﬁed type Ψn.C, in which Ψn refers to the feature that introduces or reﬁnes class C and that is the immediate predecessor of Φ in the reﬁnement chain; if there is no predecessor, Base.Object is returned.

Navigating along the reﬁnement chain

RT (C) = Ψ last(C) = Ψn.C

RT (C) = Ψ, Φ, Ω Ψ = • pred(Φ.C) = Ψn.C

RT (C) = Φ, Ω pred(Φ.C) = Base.Object

Fig. 4. Reﬁnement in FFJ.

7

2.5 Subtyping in FFJ
In Figure 5, we show the subtype relation of FFJ. The subtype relation <: is deﬁned by one rule each for reﬂexivity and transitivity and one rule for relating the type of a class to the type of its immediate superclass. It is not necessary to deﬁne subtyping over qualiﬁed types because only classes (not reﬁnements) declare superclasses and there is only a single declaration per class.

Subtyping C <: C

C <: D D <: E C <: E

C <: D
CT(Φ.C) = class C extends D { . . . } C <: D

Fig. 5. Subtyping in FFJ.

2.6 Auxiliary Deﬁnitions of FFJ
In Figure 6, we show the auxiliary deﬁnitions of FFJ. Function ﬁelds searches the reﬁnement chain from right to left and accumulates the ﬁelds into a list (using the comma as concatenation operator). If there is no further predecessor in the reﬁnement chain, i.e., we have reached a class declaration, then the reﬁnement chain of the superclass is searched (see Figure 2). If Base.Object is reached, the empty list is returned (denoted by •).
Function mbody looks up the most speciﬁc and most reﬁned body of a method m. A body consists of the formal parameters x of a method and the actual term t representing the content. The search is like in ﬁelds. First, the reﬁnement chain is searched from right to left and, then, the superclasses’ reﬁnement chains are searched, as illustrated in Figure 2. Note that [overrides] means that a given method declaration may (or may not) have the modiﬁer. This way, we are able to deﬁne uniform rules for method introduction and method reﬁnement. Function mtype yields the signature B → B0 of a declaration of method m. The lookup is like in mbody.
Predicate introduce is used to check whether a class has been introduced by multiple features and whether a ﬁeld or method has been introduced multiple times in a class. Precisely, it states, in the case of classes, whether C has not been introduced by any feature other than Φ and whether a method m or a ﬁeld f has not been introduced by Φ.C or in any of its predecessors or superclasses. To evaluate it, we check, in the case of classes, whether CT (Ψ.C) yields a class declaration or not, for any feature Ψ different from Φ, in the case of methods, whether mtype yields a signature or not and, in the case of ﬁelds, whether f is deﬁned in the list of ﬁelds returned by ﬁelds.
Predicate reﬁne states whether, for a given reﬁnement, a proper class has been declared previously in the reﬁnement chain. The predicate override states whether a method m has been introduced before in some predecessor of Φ.C and whether the previous declaration of m has the given signature.
8

Field lookup

ﬁelds(Φ.C) = C f

ﬁelds(Base.Object) = •

CT (Φ.C) = class C extends D { C f; M } CT (Φ.C) = reﬁnes class C { C f; M }

ﬁelds(Φ.C) = ﬁelds(last(D)), C f

ﬁelds(Φ.C) = ﬁelds(pred(Φ.C)), C f

Method body lookup

mbody(m, Φ.C) = (x, t)

[overrides] B m(B x) { return t; } ∈ M CT (Φ.C) = class C extends D { C f; M }
mbody(m, Φ.C) = (x, t)

m is not deﬁned in M CT (Φ.C) = class C extends D { C f; M }
mbody(m, Φ.C) = mbody(m, last(D))

[overrides] B m(B x) { return t; } ∈ M CT (Φ.C) = reﬁnes class C { C f; M }
mbody(m, Φ.C) = (x, t)

m is not deﬁned in M CT (Φ.C) = reﬁnes class C { C f; M } mbody(m, Φ.C) = mbody(m, pred(Φ.C))

Method type lookup
B0 m(B x) { return t; } ∈ M CT (Φ.C) = class C extends D { C f; M }
mtype(m, Φ.C) = B → B0
B0 m(B x) { return t; } ∈ M CT (Φ.C) = reﬁnes class C { C f; M }
mtype(m, Φ.C) = B → B0

mtype(m, Φ.C) = C → C
m is not deﬁned in M CT (Φ.C) = class C extends D { C f; M }
mtype(m, Φ.C) = mtype(m, last(D))
m is not deﬁned in M CT (Φ.C) = reﬁnes class C { C f; M } mtype(m, Φ.C) = mtype(m, pred(Φ.C))

Valid class introduction
Ψ : (CT (Ψ.C) = class C . . . ∧ Φ = Ψ) introduce (Φ.C)

introduce (Φ.C)

Valid ﬁeld introduction

ﬁelds(Φ.C) = E h f ∈/ h introduce(f, Φ.C)

introduce(f, Φ.C)

Valid method introduction

(m, Φ.C) ∈/ dom(mtype) introduce(m, Φ.C)

introduce(m, Φ.C)

Valid class reﬁnement
RT (C) = Ψ, Φ, Ω CT (Ψ1.C) = class C . . . reﬁne (Φ.C)

reﬁne (Φ.C)

Valid method overriding

override(m, Φ.C, C → C0)

mtype(m, Φ.C) = B → B0 C = B
override(m, Φ.C, C → C0) 9

C0 = B0

Fig. 6. Auxiliary deﬁnitions of FFJ.

2.7 Evaluation of FFJ Programs
Each FFJ program consists of a class table and a term.3 The term is evaluated using the evaluation rules shown in Figure 7. The evaluation terminates when a value, i.e., a term of the form new C(v), is reached. Note that we use a direct semantics of class reﬁnement [40]. That is, the ﬁeld and method lookup mechanisms incorporate all reﬁnements when a class is searched for ﬁelds and methods. An alternative, which is discussed in Section 5, would be a ﬂattening semantics, i.e., to merge a class in a preprocessing step with all of its reﬁnements into a single declaration.

ﬁelds(last(C)) = C f (new C(v)).fi −→ vi

(E-PROJNEW)

mbody(m, last(C)) = (x, t0) (new C(v)).m(u) −→ [x → u, this → new C(v)] t0

(E-INVKNEW)

C <: D (D)(new C(v)) −→ new C(v)

(E-CASTNEW)

t0 −→ t0 t0.f −→ t0.f
t0 −→ t0 t0.m(t) −→ t0.m(t)
ti −→ ti v0.m(v, ti, t) −→ v0.m(v, ti, t)
ti −→ ti new C(v, ti, t) −→ new C(v, ti, t)
t0 −→ t0 (C)t0.f −→ (C)t0.f

(E-FIELD) (E-INVKRECV) (E-INVKARG)
(E-NEWARG) (E-CAST)

Fig. 7. Evaluation of FFJ programs.

Using the subtype relation <: and the auxiliary functions ﬁelds and mbody, the evaluation of FFJ is fairly simple. The ﬁrst three rules are most interesting (the remaining rules are just congruence rules). Rule E-PROJNEW describes the projection of a ﬁeld from an instantiated class. A projected ﬁeld fi evaluates to a value vi that has been passed as argument to the instantiation. Function ﬁelds is used to look up the ﬁelds of the given class. It receives last(C) as argument since we want to search the entire reﬁnement chain of class C from right to left (cf. Figure 2).
Rule E-PROJINVK evaluates a method invocation by replacing the invocation with the method’s body. The formal parameters of the method are substituted in the body for
3 The reﬁnement table is not relevant for evaluation.
10

the arguments of the invocation; the value on which the method is invoked is substituted for this. The function mbody is called with the last reﬁnement of the class C in order to search the reﬁnement chain from right to left and return the most speciﬁc method body (cf. Figure 2).
Rule E-CASTNEW evaluates an upcast by simply removing the cast. Of course, the premise must be that the cast is really an upcast and not a downcast or an incorrect cast.
2.8 Type Checking FFJ Programs
The type relation of FFJ consists of the type rules for terms and the well-formedness rules for classes, reﬁnements, and methods, shown in Figures 8 and 9.

Term typing

x:C ∈ Γ Γ x:C

Γ t:C (T-VAR)

Γ t0 : C0 ﬁelds(last(C0)) = C f Γ t0.fi : Ci

(T-FIELD)

Γ t0 : C0

Γ t : C mtype(m, last(C0)) = D → C Γ t0.m(t) : C

C <: D (T-INVK)

Γ t:C

ﬁelds(last(C)) = D f Γ new C(t) : C

C <: D

(T-NEW)

Γ t0 : D D <: C Γ (C)t0 : C

Γ t0 : D C <: D C = D Γ (C)t0 : C

Γ t0 : D

C <: D D <: C Γ (C)t0 : C

stupid warning

(T-UCAST) (T-DCAST) (T-SCAST)

Fig. 8. Term typing in FFJ.

Term Typing Rules. A term typing judgment is a triple consisting of a typing context Γ, a term t, and a type C (see Figure 8).
Rule T-VAR checks whether a free variable is contained in the typing context. Rule T-FIELD checks whether a ﬁeld access t0.f is well-typed. Speciﬁcally, it checks whether f is declared in the type of t0 and whether the type f equals the type of the entire term. Rule T-INVK checks whether a method invocation t0.m(t) is well-typed. To this end, it checks whether the arguments t of the invocation are subtypes of the types of the
11

Method typing

M OK Φ.C

x : B, this : C t0 : E0 E0 <: B0 CT (Φ.C) = class C extends D { C f; M } introduce(m, last(D))

B0 m(B x) { return t0; } OK Φ.C

x : B, this : C t0 : E0 CT (Φ.C) = class C extends D { C f; M }

E0 <: B0 override(m, last(D), B → B0)

overrides B0 m(B x) { return t0; } OK Φ.C

x : B, this : C t0 : E0 E0 <: B0 CT (Φ.C) = reﬁnes class C { C f; M } introduce(m, pred(Φ.C))
B0 m(B x) { return t0; } OK Φ.C

x : B, this : C t0 : E0 E0 <: B0 CT (Φ.C) = reﬁnes class C { C f; M } override(m, pred(Φ.C), B → B0)
overrides B0 m(B x) { return t0; } OK Φ.C

Class typing

L OK Φ

∀ f ∈ f : introduce(f, last(D)) introduce(Φ.C) M OK Φ.C class C extends D { C f; M } OK Φ

Reﬁnement typing ∀ f ∈ f : introduce(f, pred(Φ.C)) reﬁne(Φ.C) reﬁnes class C { C f; M } OK Φ

R OK Φ M OK Φ.C

Fig. 9. Well-formedness rules of FFJ.

12

formal parameters of m and whether the return type of m equals the type of the entire term. Rule T-NEW checks whether an object creation new C(t) is well-typed in that it checks whether the arguments t of the instantiation of C are subtypes of the types D of the ﬁelds of C and whether C equals the type of the entire term. The rules T-UCAST, T-DCAST, and T-SCAST check whether casts are well-typed. In each rule, it is checked whether the type C the term t0 is cast to is a subtype, supertype, or unrelated type of the type of t0 and whether C equals the type of the entire term.4
Well-Formedness Rules. In Figure 9, we show FFJ’s well-formedness rules of classes, reﬁnements, and methods.
The typing judgments of classes and reﬁnements are binary relations between a class or reﬁnement declaration and a feature, written L OK Φ and R OK Φ. The rule of classes checks whether all methods are well-formed in the context of the class’ qualiﬁed type. Moreover, it checks whether none of the ﬁelds of the class declaration is introduced multiple times in the combined inheritance and reﬁnement hierarchy and whether there is no feature other than Φ that introduces a class C (using introduce). The well-formedness rule of reﬁnements is analogous, except that the rule checks whether a corresponding class has been introduced before (using reﬁne).
The typing judgment of methods is a binary relation between a method declaration and the qualiﬁed type that declares the method, written M OK Φ.C. There are four different rules for methods (from top to bottom in Figure 9)
1. that do not override another method and that are declared by classes, 2. that override another method and that are declared by classes, 3. that do not override another method and that are declared by reﬁnements, 4. that override another method and that are declared by reﬁnements.
All four rules check whether the type E0 of the method body is a subtype of the declared return type B0 of the method declaration. For methods that are being introduced, it is checked whether no method with an identical name has been introduced in a superclass (Rule 1) or in a predecessor in the reﬁnement chain (Rule 3). For methods that override other methods, it is checked whether a method with identical name and signature exists in the superclass (Rule 2) or in a predecessor in the reﬁnement chain (Rule 4).
Well-Typed FFJ Programs. Finally, an FFJ program, consisting of a term, a class table, and a reﬁnement table, is well-typed if
– the term is well-typed (checked using FFJ’s term typing rules), – all classes and reﬁnements stored in the class table are well-typed (checked using
FFJ’s well-formedness rules), and – the class and reﬁnement tables are well-formed (ensured by the corresponding san-
ity conditions).
4 Rule T-SCAST is needed only for the small step semantics of FFJ (and FJ) in order to be able to formulate and prove the type preservation property. FFJ (and FJ) programs whose type derivation contains this rule (i.e., the premise stupid warning appears in the derivation) are not further considered (cf. [32]).
13

Type Soundness of FFJ. The type system of FFJ is sound. We can prove this using the standard theorems of preservation and progress [66]:
THEOREM 2.1 (Preservation) If Γ t : C and t −→ t , then Γ t : C for some C <: C.
THEOREM 2.2 (Progress) Suppose t is a well-typed term.
1. If t includes new C0(t).fi as a subterm, then ﬁelds(last(C0)) = C f for some C and f.
2. If t includes new C0(t).m(u) as a subterm, then mbody(m, last(C0)) = (x, t0) and |x| = |u| for some x and t0.
We provide the proofs of the two theorems in Appendix A.
3 Feature-Oriented Product Lines in FFJPL
In this section, our goal is to deﬁne a type system for feature-oriented product lines – a type system that checks whether all valid combinations of features yield well-typed programs. In this scenario, the features in question may be optional or mutually exclusive so that different combinations are possible that form different feature-oriented programs. Since there may be plenty of valid combinations, type checking all of them individually is usually not feasible.
In order to provide a type system for feature-oriented product lines, we need information about which combinations of features are valid, i.e., which features are mandatory, optional, or mutually exclusive, and we need to adapt the subtype and type rules of FFJ to check that there are no combinations/variants that lead to ill-typed terms. The type system guarantees that every program derived from a well-typed product line is a well-typed FFJ program. FFJ together with the type system for checking featureoriented product lines is henceforth called FFJPL.
3.1 An Overview of Feature-Oriented Product Lines
A feature-oriented product line is made up of a set of feature modules and a feature model. The feature modules contains the features’ implementation and the feature model describes how the feature modules can be combined. In contrast to the featureoriented programs of Section 2, typically, some features are optional and some are mutually exclusive (Also other relations such as disjunction, negation, and implication are possible [12]; they are broken down to mandatory, optional, and mutually exclusive features, as we will explain.). Generally, in a derivation step, a user selects a valid subset of features from which, subsequently, a feature-oriented program is derived. In our case, derivation means assembling the corresponding feature modules for a given set of features. In Figure 10, we illustrate the process of program derivation.
Typically, a wide variety of programs can be derived from a product line [21,19]. The challenge is to deﬁne a type system that guarantees, on the basis of the feature modules and the feature model, that all valid programs are well-typed. Once a program is derived from such a product line, we can be sure that it is well-typed and we can evaluate it using the standard evaluation rules of FFJ (see Section 2.7).
14

feature−oriented product line
feature modules
A B C
D E F

A BC

AB
BE F
D EF
...

... ...

feature model

derivation
user’s feature selection

feature−oriented programs
program program
AA BB ED
E
program program
AA BB CC ED
E
...

Fig. 10. The process of deriving programs from a product line.

3.2 Managing Variability – Feature Models
The aim of developing a product line is to manage the variability of a set of programs developed for a particular domain and to facilitate the reuse of feature implementations among the programs of the domain. A feature model captures the variability by (explicitly or implicitly) deﬁning an ordered set of all features of a product line and their legal feature combinations. A well-deﬁned feature order is essential for ﬁeld and method lookup (see Section 3.6).
Different approaches to product line engineering use different representations of feature models to deﬁne legal feature combinations. The simplest approach is to enumerate all legal feature combinations. In practice, commonly different ﬂavors of tree structures are used, sometimes in combination with additional propositional constraints, to deﬁne legal combinations [21,12], as illustrated in Figure 10.
For our purpose, the actual representation of legal feature combinations is not relevant. In FFJPL, we use the feature model only to check whether feature and/or speciﬁc program elements are present in certain circumstances. A design decision of FFJPL is to abstract from the concrete representation of the underlying feature model and rather to provide an interface to the feature model. This has to beneﬁts: (1) we do not need to struggle with all the details of the formalization of feature models, which is well understood by researchers [12,22,64,23] and outside the scope of this paper, and (2) we are able to support different kinds of feature model representations, e.g., a tree structures, grammars, or propositional formulas [12]. The interface to the feature model is simply a set of functions and predicates that we use to ask questions like “may (or may not) feature A be present together with feature B” or “is program element m present in every variant in which also feature A is present”, i.e., “is program element m always reachable from feature A”.
3.3 Challenges of Type Checking
Let us explain the challenges of type checking by extending our email example, as shown in Figure 11. Suppose our basic email client is reﬁned to process incoming text messages (feature TEXT, Lines 1–8). Optionally, it is enabled to process HTML
15

messages, using either Mozilla’s rendering engine (feature MOZILLA, Lines 9–12) or Safari’s rendering engine (feature SAFARI, Lines 13–16). To this end, the features MOZILLA and SAFARI override the method render of class Display (Line 11 and 15) in order to invoke the respective rendering engines (ﬁeld renderer, Lines 10 and 14) instead of the text printing function (Line 7).

1 reﬁnes class Trans { 2 Unit receive(Msg msg) { 3 return /∗ do something... ∗/ new Display().render(msg); 4} 5} 6 class Display { 7 Unit render(Msg msg) { /∗ display message in text format ∗/ } 8}
9 reﬁnes class Display { 10 MozillaRenderer renderer; 11 overrides Unit render(Msg m) { /∗ render HTML message using the Mozilla engine ∗/ } 12 }
13 reﬁnes class Display { 14 SafariRenderer renderer; 15 overrides Unit render(Msg m) { /∗ render HTML message using the Safari engine ∗/ } 16 }

Feature TEXT
Feature MOZILLA Feature SAFARI

Fig. 11. A feature-oriented email client using Mozilla’s and Safari’s rendering engines.

The ﬁrst thing to observe is that the features MOZILLA and SAFARI rely on class Display and its method render introduced by feature TEXT. In order to guarantee that every derived program is well-formed, the type system checks whether Display and render are always reachable from the features MOZILLA and SAFARI, i.e., whether, in every program variant that contains MOZILLA and SAFARI, also feature TEXT is present.
The second thing to observe is that the features MOZILLA and SAFARI both add a ﬁeld renderer to Display (Lines 10 and 14), both of which have different types. In FFJ, a program with both feature modules would not be a well-typed program because the ﬁeld renderer is introduced twice. However, Figure 11 is not intended to represent a single feature-oriented program but a feature-oriented product line; the features MOZILLA and SAFARI are mutually exclusive, as deﬁned in the product line’s feature model (stated earlier), and the type system has to take this fact into account.
Let us summarize the key challenges of type checking product lines:
– A global class table contains classes and reﬁnements of all features of a product line, even if some features are optional or mutually exclusive so that they are present only in some derived programs. That is, a single class can be introduced by multiple features as long as the features are mutually exclusive. This is also the case for multiple introductions of methods and ﬁelds, which may even have different types.
16

– The presence of types, ﬁelds, and methods depends on the presence of the features that introduce them. A reference from the elements of a feature to a type, a ﬁeld projection, or a method invocation is valid if the referenced element is always reachable from the referring feature, i.e., in every variant that contains the referring feature.
– Like references, an extension of a program element, such as a class or method reﬁnement, is valid only if the extended program element is always reachable from the feature that applies the reﬁnement.
– Reﬁnements of classes and methods do not necessarily form linear reﬁnement chains. There may be alternative reﬁnements of a single class or method that exclude one another, as explained below.
3.4 Collecting Information on Feature Modules
For type checking, the FFJPL compiler collects various information on the feature modules of the product line. Before the actual type checking is performed, the compiler ﬁlls three tables with information: the class table (CT ), the introduction table (IT ), and the reﬁnement table (RT ).
The class table CT of FFJPL is like the one of FFJ and has to satisfy the same sanity conditions except that (1) there may be multiple declarations of a class (or ﬁeld or method), as long as they are deﬁned in are mutually exclusive features, and (2) there may be cycles in the inheritance hierarchy, but no cycles for each set of classes which are reachable from any given feature.
The introduction table IT maps a type to a list Φ of (mutually exclusive) features that introduce the type. The features returned by IT are listed in the order prescribed by the feature model. In our example of Figure 11, a call of IT (Display) would return a list consisting only of the single feature TEXT. Likewise, the introduction table maps ﬁeld and method names, in combination with their declaring classes, to features. For example, a call of IT (Display.renderer) would return the list MOZILLA, SAFARI. The sanity conditions for the introduction table are straightforward:
– IT (C) = Φ for every type C ∈ dom(CT ), with Φ being the features that introduce class C.
– IT (C.f) = Φ for every ﬁeld f contained in some class C ∈ dom(CT ), with Φ being the features that introduce ﬁeld f.
– IT (C.m) = Φ for every method m contained in some class C ∈ dom(CT ), with Φ being the features that introduce method m.
Much like in FFJ, in FFJPL there is a reﬁnement table RT . A call of RT (C) yields a list of all features that either introduce or reﬁne class C, which is different from the introduction table that returns only the features that introduce class C. As with IT , the features returned by RT are listed in the order prescribed by the feature model. The sanity condition for FFJPL’s reﬁnement table is identical to the one of FFJ, namely:
– RT (C) = Φ for every type C ∈ dom(CT ), with Φ being the features that introduce and reﬁne class C.
17

3.5 Feature Model Interface
As said before, in FFJPL, we abstract from the concrete representation of the feature model and deﬁne instead an interface consisting of proper functions and predicates. There are two kinds of questions we want to ask about the feature model, which we explain next.
First, we would like to know which features are never present together, which features are sometimes present together, and which features are always present together. To this end, we deﬁne two predicates, never and sometimes, and a function always. Predicate never (Ω, Φ) indicates that feature Φ is never reachable in the context Ω, i.e., there is no valid program variant in which the features Ω and feature Φ are present together. Predicate sometimes(Ω, Φ) indicates that feature Φ is sometimes present when the features Ω are present, i.e., there are variants in which the features Ω and feature Φ are present together and there are variants in which they are not present together. Function always(Ω, Φ) is used to evaluate whether feature Φ is always present in the context Ω (either alone or within a group of alternative features). There are three cases: if feature Φ is always present in the context, always returns the feature again (always(Ω, Φ) = Φ); if feature Φ is not always present, but would be together with a certain group of mutually exclusive features Ψ (i.e., one of the group is always present), always returns all features of this group (always(Ω, Φ) = Φ, Ψ). If a feature is not present at all, neither alone nor together with other mutually exclusive features, always returns the empty list (always(Ω, Φ) = •). The above predicates and function provide all information we need to know about the features’ relationships. They are used especially for ﬁeld and method lookup.
Second, we would like to know whether a speciﬁc program element is always present when a given set of features is present. This is necessary to ensure that references to program elements are always valid (i.e., not dangling). We need two sources of information for that. First, we need to know all features that introduce the program element in question (determined using the introduction table) and, second, we need to know which combinations of features are legal (determined using the feature model). For the ﬁeld renderer of our example, the introduction table would yield the features MOZILLA and SAFARI and, from the feature model, it follows that MOZILLA and SAFARI are mutually exclusive, i.e., never (MOZILLA, SAFARI). But it can happen that none of the two features is present, which can invalidate a reference to the ﬁeld. The type system needs to know about this situation.
To this end, we introduce a predicate validref that expresses that a program element is always reachable from a set of features. For example, validref (Ω, C) holds if type C is always reachable from the context Ω, validref (Ω, C.f) holds if ﬁeld f of class C is always reachable from the context Ω, and validref (Ω, C.m) holds if method m of class C is always reachable from the context Ω. Applying validref to a list of program elements means that the conjunction of the predicates for every list element is taken. Finally, when we write validref (Ω, C) Ψ, we mean that program element C is always reachable from a context Ω in a subset Ψ of features of the product line.
In our prototype, we have implemented the above functions and predicates using a SAT solver that reasons about propositional formulas representing constraints on legal
18

feature combinations (see Section 4), as proposed by Batory [12] and Czarnecki and Pietroszek [22].

3.6 Reﬁnement in FFJPL
In Figure 12, we show the functions last and pred for the navigation along the reﬁnement chain. The two functions are identical to the ones of FFJ (cf. Figure 4). However, in FFJPL, there may be alternative declarations of a class and, in the reﬁnement chain, reﬁnement declarations may even precede class declarations, as long as the declaring features are mutually exclusive. Let us illustrate reﬁnement in FFJPL by means of the example shown in Figure 13. Class C is introduced in the features Φ1 and Φ3. Feature Φ2 reﬁnes class C introduced by feature Φ1 and feature Φ4 reﬁnes class C introduced by feature Φ3. Feature Φ1 and Φ2 are never present when feature Φ3 or Φ4 are present and vice versa. A call of RT (C) would return the list Φ1, . . . , Φ4, a call of last(C) would return the qualiﬁed type Φ4.C, and a call of pred (Φ4.C) would return the qualiﬁed type Φ3.C and so on.

Navigating along the reﬁnement chain

RT (C) = Ψ last(C) = Ψn.C

RT (C) = Ψ, Φ, Ω Ψ = • pred(Φ.C) = Ψn.C

RT (C) = Φ, Ω pred(Φ.C) = Base.Object

Fig. 12. Reﬁnement in FFJPL.

CCCC
Φ1 Φ2 Φ3 Φ4
mutually exclusive
Fig. 13. Multiple alternative reﬁnements.
3.7 Subtyping in FFJPL The subtype relation is more complicated in FFJPL than in FFJ. The reason is that a class may have multiple declarations in different features, each declaring possibly different superclasses, as illustrated in Figure 14. That is, when checking whether a class is a subtype of another class, we need to check whether the subtype relation holds in all alternative inheritance paths that may be reached from a given context. For example, FooBar is a subtype of BarFoo because BarFoo is a superclass of FooBar in every
19

program variant (since always(Φ1, Φ2) = Φ2, Φ3); but FooBar is not a subtype of Foo and Bar because, in both cases, a program variant exists in which FooBar is not a
(indirect) subclass of the class in question.

Φ2 Foo
A a; A m(D d);

Bar
B b; B m(B b);

BarFoo
D d;

BarFoo
D d;

FooBar
E e;

Φ1

Φ3
Φ2 and Φ3 are mutually exclusive and one of them is always present together with Φ1

Fig. 14. Multiple inheritance chains in the presence of alternative features.

In Figure 15, we show the subtype relation of FFJPL. The subtype relation C <: E Ω is read as follows: in the context Ω, type C is a subtype of type E, i.e., type C is a subtype of type E in every variant in which also the features Ω are present. The ﬁrst rule in Figure 15 covers reﬂexivity and terminates the recursion over the inheritance hierarchy. The second rule states that class C is a subtype of class E if at least one declaration of C is always present (tested with validref ) and if every of C’s declarations that may be present together with Ω (tested with sometimes) declares some type D as its supertype and D is a subtype of E in the context Ω. That is, E must be a direct or indirect supertype of D in all variants in which the features Ω are present. Additionally, supertype D must be always reachable from the context (Ω, Ψ). When traversing the inheritance hierarchy, in each step, the context is extended by the feature that introduces the current class in question, e.g., Ω is extended with Ψ.
Interestingly, the second rule subsumes the two FFJ rules for transitivity and direct superclass declaration because some declarations of C may declare E directly as its superclass and some declarations may declare another superclass D that is, in turn, a subtype of E, and the rule must be applicable to both cases simultaneously.

Subtyping

C <: C Ω

C <: E Ω

validref (Ω, C)

∀ Ψ ∈ IT (C) : sometimes(Ω, Ψ) ⇒

CT(Ψ.C) = class C extends D { . . . } validref ((Ω, Ψ), D) D <: E Ω, Ψ

C <: E Ω

Fig. 15. Subtyping in FFJPL.

20

Applied to our example of Figure 14, we have FooBar <: FooBar Φ1 because of the reﬂexivity rule. We also have FooBar <: BarFoo Φ1 because FooBar is reachable from feature Φ1 and every feature that introduces FooBar, namely Φ1, contains a corresponding class declaration that declares BarFoo as FooBar’s superclass, and BarFoo is always reachable from Φ1. However, we have FooBar <: Foo Φ1 and FooBar <: Bar Φ1 because FooBar’s immediate superclass BarFoo is not always a subtype of Foo respectively of Bar.
3.8 Auxiliary Deﬁnitions of FFJPL
Extending FFJ toward FFJPL makes it necessary to add and modify some auxiliary functions. The most complex changes concern the ﬁeld and method lookup mechanisms.
Field Lookup. The auxiliary function ﬁelds collects the ﬁelds of a class including the ﬁelds of its superclasses and reﬁnements. Since alternative class or reﬁnement declarations may introduce alternative ﬁelds (or the same ﬁeld with identical or alternative types), ﬁelds may return different ﬁelds for different feature selections. Since we want to type-check all valid variants, ﬁeld returns multiple ﬁeld lists (i.e., a list of lists) that cover all possible feature selections. Each inner list contains ﬁeld declarations collected in an alternative path of the combined inheritance and reﬁnement hierarchy.
For legibility, we separate the inner lists using the delimiter ‘◦’. For example, looking up the ﬁelds of class FooBar in the context of feature Φ1 (Figure 14) yields the list A a, D d, E e ◦ B b, D d, E e because the features Φ2 and Φ3 are mutually exclusive and one of them is present in each variant in which also Φ1 is present. For readability, we use the metavariables F and G when referring to inner ﬁeld lists. We abbreviate a list of lists of ﬁelds F1 ◦ . . . ◦ Fn by F . Analogously, F is shorthand for F11 ◦ . . . ◦ Fn1 ◦ . . . ◦ F1m ◦ . . . ◦ Fnm.
Function ﬁelds receives a qualiﬁed type Φ.C and a context of selected features Ω. If we want all possible ﬁeld lists, the context is empty. If we want only ﬁeld lists for a subset of feature selections, e.g., only the ﬁelds that can be referenced from a term in a speciﬁc feature module, we can use the context to specify one or more features of which we know that they must be selected.
The basic idea of FFJPL’s ﬁeld lookup is to traverse the combined inheritance and reﬁnement hierarchy much like in FFJ. There are four situations that are handled differently:
1. The ﬁeld lookup returns the empty list when it reaches Base.Object. 2. The ﬁeld lookup ignores all ﬁelds that are introduced by features that are never
present in a given context. 3. The ﬁeld lookup collects all ﬁelds that are introduced by features that are always
present in a given context. References to these ﬁelds are always valid. 4. The ﬁeld lookup collects all ﬁelds that are introduced by features that may be
present in a given context but that are not always present. In this case, a special
21

marker @ is added to the ﬁelds in question because we cannot guarantee that a reference to this ﬁeld is safe in the given context.5 It is up to the type system to decide, based on the marker, whether this situation may provoke an error (e.g., the type system ignores the marker when looking for duplicate ﬁelds but reports an error when type checking object creations). 5. A special situation occurs when the ﬁeld lookup identiﬁes a group of alternative features. In such a group each feature is optional and excludes every other feature of the group and at least one feature of the group is always present in a given context. Once the ﬁeld lookup identiﬁes a group of alternative features, we split the result list, each list containing the ﬁelds of a feature of the group and the ﬁelds of the original list.

Field lookup

ﬁelds(Ω, Φ.C) = C f

ﬁelds(Ω, Φ.Object) = •

(FL-1)

never (Ω, Φ) ﬁelds(Ω, Φ.C) = ﬁelds(Ω, pred (Φ.C))

(FL-2)

sometimes(Ω, Φ) always(Ω, Φ) = Φ CT (Φ.C) = class C extends D { C f; M }
ﬁelds(Ω, Φ.C) = append (ﬁelds(Ω, last(D)), C f)

(FL-3.1)

sometimes(Ω, Φ) always(Ω, Φ) = Φ CT (Φ.C) = reﬁnes class C { C f; M }
ﬁelds(Ω, Φ.C) = append (ﬁelds(Ω, pred (Φ.C)), C f)

(FL-3.2)

sometimes(Ω, Φ) always(Ω, Φ) = • CT (Φ.C) = class C extends D { C f; M }
ﬁelds(Ω, Φ.C) = append (ﬁelds(Ω, last(D)), C f@)

(FL-4.1)

sometimes(Ω, Φ) always(Ω, Φ) = • CT (Φ.C) = reﬁnes class C { C f; M }
ﬁelds(Ω, Φ.C) = append (ﬁelds(Ω, pred (Φ.C)), C f@)

(FL-4.2)

sometimes(Ω, Φ) always(Ω, Φ) = Ψ (FL-5)
ﬁelds(Ω, Φ.C) = ﬁelds((Ω, Ψ1), Φ.C) ◦ . . . ◦ ﬁelds((Ω, Ψn), Φ.C)

Fig. 16. Field lookup in FFJPL.

In order to distinguish the different cases, we use the predicates and functions deﬁned in Section 3.5 (especially never , sometimes, and always). The deﬁnition of func5 Note that the marker @ is generated during type checking, so we do not include it in the syntax
of FFJ.
22

tion ﬁelds, shown in Figure 16, follows the intuition described above: Once Base.Object is reached, the recursion terminates (FL-1). When a feature is never reachable in the given context, ﬁelds ignores this feature and resumes with the previous one (FL-2). When a feature is mandatory (i.e., always present in a given context), the ﬁelds in question are added to each alternative result list, which were created in Rule FL-5 (FL-3.1 and FL-3.2).6 When a feature is optional, the ﬁelds in question, annotated with the marker @, are added to each alternative result list (FL-4.1 and FL-4.2). When a feature is part of an alternative group of features, we cannot immediately decide how to proceed. We split the result list in multiple lists (by means of multiple recursive invocations of ﬁelds), in which we add one of the alternative features to each context passed to an invocation of ﬁelds (FL-5).

Method type lookup

mtype(Ω, m, Φ.C) = B → B0

mtype(Ω, m, Base.Object) = •

(ML-1)

B0 m(B x) { . . . } ∈ M sometimes(Ω, Φ) CT (Φ.C) = class C extends D { C f; M }
(ML-2) mtype(Ω, m, Φ.C) = mtype(Ω, m, pred (Φ.C)), mtype(Ω, m, last(D)), B → B0

B0 m(B x) { . . . } ∈ M sometimes(Ω, Φ) CT (Φ.C) = reﬁnes class C { C f; M }
mtype(Ω, m, Φ.C) = mtype(Ω, m, pred (Φ.C)), B → B0

(ML-3)

(m is not deﬁned in M ∨ never (Ω, Φ)) CT (Φ.C) = class C extends D { C f; M }
mtype(Ω, m, Φ.C) = mtype(Ω, m, pred (Φ.C)), mtype(Ω, m, last(D))

(ML-4)

(m is not deﬁned in M ∨ never (Ω, Φ)) CT (Φ.C) = reﬁnes class C { C f; M }
mtype(Ω, m, Φ.C) = mtype(Ω, m, pred (Φ.C))

(ML-5)

Fig. 17. Method Lookup in FFJPL.

Method Type Lookup. Like in ﬁeld lookup, in method lookup, we have to take alternative deﬁnitions of methods into account. But the lookup mechanism is simpler than in ﬁelds because the order of signatures found in the combined inheritance and reﬁnement hierarchy is irrelevant for type checking. Hence, function mtype yields a simple list B → B0 of signatures for a given method name m. For example, calling mtype(Φ1, m, Φ1.C) in the context of Figure 14 yields the list D → A, B → B.
6 Function append adds to each inner list of a list of ﬁeld lists a given ﬁeld. Its implementation is straightforward and omitted for brevity.
23

In Figure 17, we show the deﬁnition of function mtype. For Base.Object, the empty list is returned (ML-1). If a class that is sometimes reachable introduces a method in question (ML-2), its signature is added to the result list and all possible predecessors in the reﬁnement chain (using pred ) and all possible subclasses are searched (using last). Likewise, if a reﬁnement that is sometimes reachable introduces a method with the name searched (ML-3), its signature is added to the result list and all possible predecessors in the reﬁnement chain are searched (using pred ). If a class or reﬁnement does not declare a corresponding method (ML-4 and ML-5) or the a class is never reachable, the search proceeds with the possible superclasses or predecessors.
The current deﬁnition of function mtype returns possibly many duplicate signatures. A straightforward optimization would be to remove duplicates before using the result list, which we omitted for simplicity.

Valid class introduction

introduce(Ω, Φ.C)

Ψ : CT (Ψ.C) = class C extends D { C f; M } Ψ = Φ sometimes(Ω, Ψ) introduce(Ω, Φ.C)

Valid ﬁeld introduction

introduce(Ω, f, Φ.C)

∀ E h ∈ ﬁelds(Ω, Φ.C) : f ∈/ h introduce(Ω, f, Φ.C)

Valid method introduction

introduce(Ω, m, Φ.C)

mtype(Ω, m, Φ.C) = • introduce(Ω, m, Φ.C)

Valid class reﬁnement

reﬁne(Ω, Φ.C)

RT (C) = Ψ, Φ, Π validref (Ω, C) Ψ reﬁne(Ω, Φ.C)

Valid method overriding override(Ω, m, Φ.C, C → C0)
RT (C) = Ψ, Φ, Π validref (Ω, C.m) Ψ, Φ ∀ B → B0 ∈ mtype(Ω, m, Φ.C) : C = B ∧ C0 = B0
override(Ω, m, Φ.C, C → C0)

Fig. 18. Valid introduction, reﬁnement, and overriding in FFJPL.

24

Valid Introduction, Reﬁnement, and Overriding. In Figure 18, we show predicates for checking the validity of introduction, reﬁnement, and overriding in FFJPL. Predicate introduce indicates whether a class with the qualiﬁed type Φ.C has not been introduced by any other feature Ψ that may be present in the context Ω. Likewise, introduce holds if a method m or a ﬁeld f has not been introduced by a qualiﬁed type Φ.C (including possible predecessors and superclasses) that may be present in the given context Ω. To this end, it checks either whether mtype yields the empty list or whether f is not contained in every inner list returned by ﬁelds.
For a given reﬁnement, predicate reﬁne indicates whether a proper class, which is always reachable in the given context, has been declared previously in the reﬁnement chain. We write validref (Ω, C) Ψ in order to state that a declaration of class C has been introduced in the set Ψ of features, which is only a subset of the features of the product line, namely the features that precede the feature that introduces class C. Predicate override indicates whether a declaration of method m has been introduced (and is always reachable) in some feature introduced by before the feature that reﬁnes m and whether every possible declaration of m in any predecessor of a Φ.C has the same signature.
3.9 Type Relation of FFJPL
The type relation of FFJPL consists of type rules for terms and well-formedness rules for classes, reﬁnements, and methods, shown in Figure 19 and Figure 20.
Term Typing Rules. A term typing judgment in FFJPL is a quadruple, consisting of a typing context Γ, a term t, a list of types C, and a feature Φ that contains the term (see Figure 19). A term can have multiple types in a product line because there may be multiple declarations of classes, ﬁelds, and methods. The list C contains all possible types a term can have.
Rule T-VARPL is standard and does not refer to the feature model. It yields a list consisting only of the type of the variable in question.
Rule T-FIELDPL checks whether a ﬁeld access t0.f is well-typed in every possible variant in which also Φ is present. Based on the possible types E of the term t0 the ﬁeld f is accessed from, the rule checks whether f is always reachable from Φ (using validref ). Note that this is a key mechanism of FFJPL’s type system. It ensures that a ﬁeld, being accessed, is deﬁnitely present in every valid program variant in which the ﬁeld access occurs – without generating all these variants. Furthermore, all possible ﬁelds of all possible types E are assembled in a nested list F, C f, G in which C f denotes a declaration of the ﬁeld f; the call of ﬁelds(Φ, last(E)) is shorthand for ﬁelds(Φ, last(E1)) . . . ﬁelds(Φ, last(En)), in which the individual result lists are concatenated. Finally, the list of all possible types C11, . . . , Cn1, . . . , C1m, . . . , Cnm of ﬁeld f becomes the list of types of the overall ﬁeld access. Note that the result list may contain duplicates, which could be eliminated for optimization purposes.
Rule T-INVKPL checks whether a method invocation t0.m(t) is well-typed in every possible variant in which also Φ is present. Based on the possible types E of the term t0 the method m is invoked on, the rule checks whether m is always reachable from Φ
25

Term typing

x:C∈Γ Γ x:C Φ

∀ E ∈ E : validref (Φ, E.f) Γ t0 : E Φ ﬁelds(Φ, last(E)) = F , C f, G Γ t0.f : C11, . . . , Cn1, . . . , C1m, . . . , Cnm Φ

Γ t:C Φ (T-VARPL)
(T-FIELDPL)

∀ E ∈ E : validref (Φ, E.m) ∀ C ∈ C, ∀ D ∈ D ∈ D : C <: D Φ Γ t0 : E Φ Γ t : C Φ mtype(Φ, m, last(E)) = D → B
(T-INVKPL) Γ t0.m(t) : B11, . . . , Bn1, . . . , B1m, . . . , Bnm Φ

validref (Φ, C) ∀ D g ∈ F , ∀ C ∈ C : C <: D Φ Γ t : C Φ ﬁelds(Φ, last(C)) = F @ ∈/ F
Γ new C(t) : C Φ

(T-NEWPL)

Γ t0 : E Φ

validref (Φ, C) ∀ E ∈ E : (E <: C Φ ∨ C <: E
Γ (C)t0 : C Φ

Φ)

(T-UDCASTPL)

validref (Φ, C) stupid warning Γ t0 : E Φ ∃ E ∈ E : (C <: E Φ ∧ E <: C Φ)
Γ (C)t0 : C Φ

(T-SCASTPL)

Fig. 19. Term typing in FFJPL.

26

Method typing

M OK

x : B, this : C t0 : E Φ ∀ E ∈ E : E <: B0 validref (Φ, B) introduce(Φ, m, last(D)) CT (Φ.C) = class C extends D { C f; M }

Φ

B0 m(B x) { return t0; } OK Φ.C

Φ.C

x : B, this : C t0 : E Φ ∀ E ∈ E : E <: B0 Φ validref (Φ, B) override(Φ, m, last(D), B → B0) CT (Φ.C) = class C extends D { C f; M }
overrides B0 m(B x) { return t0; } OK Φ.C

x : B, this : C t0 : E Φ ∀ E ∈ E : E <: B0 Φ validref (Φ, B) introduce(Φ, m, pred (Φ.C)) CT (Φ.C) = reﬁnes class C { C f; M }
B0 m(B x) { return t0; } OK Φ.C

x : B, this : C t0 : E Φ ∀ E ∈ E : E <: B0 Φ validref (Φ, B) override(Φ, m, pred (Φ.C), B → B0)
CT (Φ.C) = reﬁnes class C { C f; M }
overrides B0 m(B x) { return t0; } OK Φ.C

Class typing
validref (Φ, D) validref (Φ, C) ∀ f ∈ f : introduce(Φ, f, last(D)) introduce(Φ, Φ.C)
class C extends D { C f; M } OK Φ

L OK Φ M OK Φ.C

Reﬁnement typing
validref (Φ, C) ∀ f ∈ f : introduce(Φ, f, pred (Φ.C)) reﬁne(Φ, Φ.C)
reﬁnes class C { C f; M } OK Φ

R OK Φ M OK Φ.C

Fig. 20. Well-formedness rules of FFJPL.

27

(using validref ). As with ﬁeld access, this check is essential. It ensures that in generated programs only methods are invoked that are also present. Furthermore, all possible
signatures of m of all possible types E are assembled in the nested list D → B and it is checked that all possible lists C of argument types of the method invocation are subtypes of all possible lists D of parameter types of the method (this implies that the lengths of the two lists must be equal). A method invocation has multiple types assembled in a list that contains all result types of method m determined by mtype. As with ﬁeld access, duplicates should be eliminated for optimization purposes.
Rule T-NEWPL checks whether an object creation new C(t) is well-typed in every possible variant in which also Φ is present. Speciﬁcally, it checks whether there is a declaration of class C always reachable from Φ. Furthermore, all possible ﬁeld combinations of C are assembled in the nested list F, and it is checked whether all possible combinations of argument types passed to the object creation are subtypes of the types of all possible ﬁeld combinations (this implies that the number of arguments types must equal the number of ﬁeld types). The ﬁelds of the result list must not be annotated with the marker @ since optional ﬁelds may not be present in every variant and references may become invalid (see ﬁeld lookup).7 An object creation has only a single type C.
Rules T-UDCASTPL and T-SCASTPL check whether casts are well-typed in every possible variant in which also Φ is present. This is done by checking whether the type C the term t0 is cast to is always reachable from Φ and whether this type is a subtype, supertype, or unrelated type of all possible types E the term t0 can have. We have only a single rule T-UDCASTPL for up- and downcasts because the list E of possible types may contain super- and subtypes of C simultaneously. If there is a type in the list which leads to a stupid case, we ﬂag a stupid warning. A cast yields a list containing only a single type C.
Well-Formedness Rules. In Figure 20, we show the well-formedness rules of classes, reﬁnements, and methods.
Like in FFJ, the typing judgment of classes and reﬁnements is a binary relation between a class or reﬁnement declaration and a feature. The rule of classes checks whether all methods are well-formed in the context of the class’ qualiﬁed type. Moreover, it checks whether the class declaration is unique in the scope of the enclosing feature Φ, i.e., whether no other feature, that may be present together with feature Φ, introduces a class with an identical name (using introduce). Furthermore, it checks whether the superclass and all ﬁeld types are always reachable from Φ (using validref ). Finally, it checks whether none of the ﬁelds of the class declaration have been introduced before (using introduce). The well-formedness rule of reﬁnements is analogous, except that the rule checks that there is at least one class declaration reachable that is reﬁned and that has been introduced before the reﬁnement (using reﬁne).
The typing judgment of methods is a binary relation between a method declaration and the qualiﬁed type that declares the method. Like in FFJ, there are four different rules for methods (from top to bottom in Figure 20)
1. that do not override another method and that are declared by classes,
7 The treatment of @ is semiformal but simpliﬁes the rule.
28

2. that override another method and that are declared by classes, 3. that do not override another method and that are declared by reﬁnements, 4. that override another method and that are declared by reﬁnements.
All four rules check whether all possible types E of the method body are subtypes of the declared return type B0 of the method and whether the argument types B are always reachable from the enclosing feature Φ (using validref ).
For methods that are introduced, it is checked, using introduce, whether no method with identical name has been introduced in any possible superclass (Rule 1) or in any possible predecessor in the reﬁnement chain (Rule 3). For methods that override other methods, it is checked, using override, whether a method with identical name and signature exists in any possible superclass (Rule 2) or in any possible predecessor in the reﬁnement chain (Rule 4).
Well-Typed FFJPL Product Lines. An FFJPL product line, consisting of a term, a class table, an introduction table, and a reﬁnement table, is well-typed if
– the term is well-typed (checked using FFJPL’s term typing rules), – all classes and reﬁnements stored in the class table are well-formed (checked using
FFJPL’s well-formedness rules), and – the class, introduction, and reﬁnement tables are well-formed (ensured by the cor-
responding sanity conditions).
3.10 Type Safety of FFJPL
Type checking in FFJPL is based on information contained in the class table, introduction table, reﬁnement table, and feature model. The ﬁrst three are ﬁlled by the compiler that has parsed the code base of the product line. The feature model is supplied directly by the user (or tool). The compiler determines which class and reﬁnement declarations belong to which features. The classes and reﬁnements of the class table are checked using their well-formedness rules which, in turn, use the well-formedness rules for methods and the term typing rules for method bodies. Several rules use the introduction and reﬁnement tables in order to map types, ﬁelds, and methods to features and the feature model to navigate along reﬁnement chains and to check the presence of program elements.
What does type safety mean in the context of a product line? The product line itself is never evaluated; rather, different programs are derived that are then evaluated. Hence, the property we are interested in is that all programs that can be derived from a welltyped product line are in turn well-typed. Furthermore, we would like to be sure that all FFJPL product lines, from which only well-typed FFJ programs can be derived, are well-typed. We formulate the two properties as the two theorems Correctness of FFJPL and Completeness of FFJPL.
29

Correctness

THEOREM 3.1 (Correctness of FFJPL) Given a well-typed FFJPL product line pl (including with a well-typed term t, well-formed class, introduction, and reﬁnement tables CT , IT , and RT , and a feature model FM ), every program that can be derived with a valid feature selection fs is a well-typed FFJ program (cf. Figure 10).

pl = (t, CT , IT , RT , FM ) pl is well-typed fs is valid in FM derive(pl , fs) is well-typed

Function derive collects the feature modules from a product line according to a user’s selection fs, i.e., non-selected feature modules are removed from the derived program. After this derivation step, the class table contains only classes and reﬁnements stemming from the selected feature modules. We deﬁne a valid feature selection to be a list of features whose combination does not contradict the constraints implied by the feature model.
The proof idea is to show that the type derivation tree of an FFJPL product line is a superimposition of multiple so-called type derivation slices. As usual, the type derivation proceeds from the root (i.e., an initial type rule that checks the term and all classes and reﬁnements of the class table) to the leaves (type rules that do not have a premise) of the type derivation tree. Each time a term has multiple types, e.g., a method has different alternative return types, which is caused by multiple mutually exclusive method declarations, the type derivation splits into multiple branches. With branch we refer only to positions in which the type derivation tree is split into multiple subtrees in order to type check multiple mutually exclusive term deﬁnitions. Each subtree from the root of the type derivation tree along the branches toward a leaf is a type derivation slice. Each slice corresponds to the type derivation of a feature-oriented program.
Let us illustrate the concept of a type derivation slice by a simpliﬁed example. Suppose the application of an arbitrary type rule to a term t somewhere in the type derivation. Term t has multiple types C due to different alternative deﬁnitions of t’s subterms. For simplicity, we assume here that t has only a single subterm t0, like in the case of a ﬁeld access (t = t0.f), in which the overall term t has multiple types depending on t0’s and f’s types; the rule can be easily extended to multiple subterms by adding a predicate per subterm. The type rule ensures the well-typedness of all possible variants of t on the basis of the variants of t’s subterm t0. Furthermore, the type rule checks whether a predicate predicate (e.g., C <: D) holds for each variant of the subterm with its possible types E, written predicate(t0 : Ei). The possible types C of the overall term follow in some way from the possible types E of its subterm. Predicate validref is used to check whether all referenced elements and types are present in all valid variants, including different combinations of optional features. For the general case, this can be written as follows:

predicate(t0 : E1)

predicate(t0 : E2) . . . t0 : E always(. . .)
Γ t:C Φ

predicate(t0 : En) (T-*PL)

The different uses of predicate in the premise of an FFJPL type rule correspond to the branches in the type derivation that denote alternative deﬁnitions of subterms.

30

Hence, the premise of the FFJPL type rule is the conjunction of the different premises that cover the different alternative deﬁnitions of the subterms of a term.
The proof strategy is as follows. Assuming that the FFJPL type system ensures that each slice is a valid FFJ type derivation (see Lemma B.1 in Appendix B.1) and that each valid feature selection corresponds to a single slice (since alternative features have been removed; see Lemma B.2 in Appendix B.1), each feature-oriented program that corresponds to a valid feature selection is guaranteed to be well-typed. Note that multiple valid feature selections may correspond to the same slice because of the presence of optional features. It follows that, for every valid feature selection, we derive a wellformed FFJ program – since its type derivation is valid – whose evaluation satisﬁes the properties of progress and preservation (see Appendix A). In Appendix B, we describe the proof of Theorem 3.1 in more detail.
Completeness
THEOREM 3.2 (Completeness of FFJPL) Given an FFJPL product line pl (including a well-typed term t, well-formed class, introduction, and reﬁnement tables CT , IT , and RT , and a feature model FM ), and given that all valid feature selections fs yield well-typed FFJ programs, according to Theorem 3.1, pl is a well-typed product line according to the rules of FFJPL.
pl = (t, CT , IT , RT , FM ) ∀ fs : (fs is valid in FM ⇒ derive(pl , fs) is well-typed) pl is well-typed
The proof idea is to examine three basic cases and to generalize subsequently: (1) pl has only mandatory features; (2) pl has only mandatory features except a single optional feature; (3) pl has only mandatory features except two mutually exclusive features. All other cases can be formulated as combinations of these three basic cases. To this end, we divide the possible relations between features into three disjoint sets: (1) a feature is reachable from another feature in all variants, (2) a feature is reachable from another feature in some, but not in all, variants, (3) two features are mutually exclusive. From these three possible relations, we can prove the three basic cases in isolation and, subsequently, construct a general case that can be phrased as a combination of the three basic cases. The description of the general case and the reduction ﬁnish the proof of Theorem 3.2. In Appendix B, we describe the proof of Theorem 3.2 in detail.
4 Implementation & Discussion
We have implemented FFJ and FFJPL in Haskell, including the program evaluation and type checking of product lines. The FFJPL compiler expects a set of feature modules and a feature model both of which, together, represent the product line. A feature module is represented by a directory. The ﬁles found inside a feature module’s directory are assigned to / belong to the enclosing feature. The FFJPL compiler stores this information for type checking. Each ﬁle may contain multiple classes and class reﬁnements. In Figure 21, we show a snapshot of our test environment, which is based on Eclipse
31

and a Haskell plugin8. We use Eclipse to interpret or compile our FFJ and FFJPL type systems and interpreters. Speciﬁcally, the ﬁgure shows the directory structure of our email system. The ﬁle EmailClient.features contains the user’s feature selection and the feature model of the product line.
Fig. 21. Snapshot of the test environment of the Haskell implementation.
The feature model of a product line is represented by a propositional formula, following the approach of Batory [12] and Czarnecki and Pietroszek [22]. Propositional formulas are an effective way of representing the relationships between features (e.g., of specifying which feature implies the presence and absence of other features and of machine checking whether a feature selection is valid). For example, we have implemented predicate sometimes as follows:
sometimes(FM , Ω, Ψ) = satisﬁable(FM ∧ Ω1 ∧ . . . ∧ Ωn ∧ Ψ) The feature model is an propositional formula; feature are variables; and satisﬁable is a satisﬁability solver. Likewise, we have implemented predicate always on the basis of logical reasoning on propositional formulas:
always(FM , Ω, Ψ) = ¬(satisﬁable(¬(FM ⇒ ((Ω1 ∧ . . . ∧ Ωn) ⇒ Ψ)))) For a more detailed explanation of how propositional formulas relate to feature models and feature selections, we refer the interest to the work of Batory [12].
In Figure 22, we show the textual speciﬁcation of the feature model of our email system, which can be passed directly to the FFJPL compiler. 8 http://eclipsefp.sourceforge.net/haskell/
32

1 features: 2 EmailClient IMAP POP3 MIME SSL Text Mozilla Safari 3 4 model: 5 EmailClient implies (IMAP or POP3); 6 IMAP implies EmailClient; 7 POP3 implies EmailClient; 8 MIME implies EmailClient; 9 SSL implies EmailClient; 10 Text implies (IMAP or POP3); 11 Mozilla implies (IMAP or POP3); 12 Safari implies (IMAP or POP3); 13 Mozilla implies (not Safari); 14 Safari implies (not Mozilla);
Fig. 22. Feature model of an email client product line.
The ﬁrst section (features:) of the ﬁle representing the feature model deﬁnes an ordered set of names of the features of the product line and the second section (model:) deﬁnes constraints on the features’ presence in the derived programs. In our example, each email client supports either the protocols IMAP, POP3, or both. Furthermore, every feature requires the presence of the base feature EMAILCLIENT. Feature TEXT requires either the presence of IMAP or POP3 or both – the same for MOZILLA and SAFARI. Finally, feature MOZILLA requires the absence of feature SAFARI and vice versa.
On the basis of the feature modules and the feature model, FFJPL’s type system checks the entire product line and identiﬁes valid program variants that still contain type errors. A SAT solver is used to check whether elements are never, sometimes, or always reachable. If an error is found, the product line is rejected as ill-formed. If not, a feature-oriented program guaranteed to be well-formed can derived on the basis of a user’s feature selection. This program can be evaluated using the standard evaluation rules of FFJ, which we have also implemented in Haskell.
In contrast to previous work on type checking feature-oriented product lines [64,23], our type system provides detailed error messages. This is possible due to the ﬁnegrained checks at the level of individual term typing and well-formedness rules. For example, if a ﬁeld access succeeds only in some program variants, this fact can be reported to the user and the error message can point to the erroneous ﬁeld access. Previously proposed type systems compose all code of all features of a product line and extract a single propositional formula, which is checked for satisﬁability. If the formula is not satisﬁable (i.e., a type error has occurred), it is not possible to identify the location that has caused the error (at least not without further information). See Section 5, for a detailed discussion of related approaches.
We made several tests and experiments with our Haskell implementation. However, real-world tests were not feasible because of two reasons. First, in previous work it has been already demonstrated that feature-oriented product lines require proper type systems and that type checking entire real-world product lines is feasible and useful [64]. Second, like FJ, FFJ is a core language into which all Java programs can be compiled and which, by its relative simplicity, is suited for the formal deﬁnition and proof of language properties – in our case, a type system and its correctness and completeness.
33

But, a core language is never suited for the development of real-world programs. This is why our examples and test programs are of similar size and complexity as the FJ examples of Pierce [54]. Type checking our test programs required acceptable amounts of time (in the order of magnitude of milliseconds per product line). We do not claim to be able to handle full-sized feature-oriented product lines by hand-coding them in FFJPL. Rather, this would require an expansion of the type system to full Java (including support for features as provided by AHEAD [13] or FeatureHouse [9]) – an enticing goal, but one for the future (especially, as Java’s informal language speciﬁcation [28] has 688 pages). Our work lays a foundation for implementing type systems in that it provides evidence that core feature-oriented mechanisms are type sound and type systems of feature-oriented product lines can be implemented correctly and completely.
Still, we would like to make some predictions on the scalability of our approach. The novelty of our type system is that it incorporates alternative features and, consequently, alternative deﬁnitions of classes, ﬁelds, and methods. This leads to a type derivation tree with possibly multiple branches denoting alternative term types. Hence, performing a type derivation of product line with many alternative features may consume a signiﬁcant amount of computation time and memory. It seems that this overhead is the price for allowing alternative implementation of program parts.
Nevertheless, our approach minimizes the overhead caused by alternative features compared to the naive approach. In the naive approach, all possible programs are derived and type checked subsequently. In our approach, we type check the entire code base of the product line and branch the type derivation only at terms that really have multiple, alternative types, and not at the level of entire program variants, as done in the naive approach. Our experience with feature-oriented product lines shows that, usually, there are not many alternative features in a product line, but mostly optional features [42,3,64,37,59,11,9,5,6,57,60]. For example, in the Berkeley DB product line (JE edition; 80 000 lines of code) there are 99 feature modules, but only two pairs of them alternative [9,37]; in the Graph Product Line there are 26 feature modules, of which only three pairs are alternative [42,9]. A further observation is that most alternative features that we encountered do not alter types. That is, there are multiple deﬁnitions of ﬁelds and methods but with equal types. For example, GPL and Berkeley DB contain alternative deﬁnitions of a few methods but only with identical signatures. Type checking these product lines with our approach, the type derivation would have almost no branches. In the naive approach, still many program variants exist due to optional features. Hence, our approach is preferable. For example, in a product line with n features and c ∗ n variants (with c being a constant), in our approach, the type system would have to check n feature modules (with some few branches in the type derivation and solving few simple SAT problems; see below) and, in the naive approach, the type system would have to check, at least, 2 ∗ n feature modules but, commonly, 2 ∗ n ∗ m with m < n. For product lines with a higher degree of variability, e.g., with n2 or even 2n variants the beneﬁt of our approach becomes even more signiﬁcant. We believe that this beneﬁt can make a difference in real world product line engineering.
A further point is that almost all typing and well-formedness rules contain calls to the built-in SAT solver. This results in possibly many invocations of the SAT solver at type checking time. Determining the satisﬁability of a propositional formula is in
34

general an N P-complete problem. However, it has been shown that the structures of propositional formulas occurring in software product lines are simple enough to scale satisﬁability solving to thousands of features [47]. Furthermore, in our experiments, we have observed that many calls to the SAT solver are redundant, which is easy to see when thinking about type checking feature-oriented product lines where the presence of single types or members is checked in many type rules. We have implemented a caching mechanism to decrease the number of calls to the SAT solver to a minimum.
Finally, the implementation in Haskell helped us a lot with the evaluation of the correctness of our type rules. It can serve other researchers to reproduce and evaluate our work and to experiment with further (feature-oriented) language mechanisms. The implementations of FFJ and FFJPL, along with test programs, can be downloaded from the Web.9
5 Related Work
We divide our discussions of related work into two parts: the implementation, formal models, and type systems (1) of feature-oriented programs and (2) of feature oriented product lines.
5.1 Feature-Oriented Programs
FFJ has been inspired by several feature-oriented languages and tools, most notably AHEAD/Jak [13], FeatureC++ [10], FeatureHouse [9], and Prehofer’s feature-oriented Java extension [55]. Their key aim is to separate the implementation of software artifacts, e.g., classes and methods, from the deﬁnition of features. That is, classes and reﬁnements are not annotated or declared to belong to a feature. There is no statement in the program text that deﬁnes explicitly a connection between code and features. Instead, the mapping of software artifacts to features is established via so-called containment hierarchies, which are basically directories containing software artifacts. The advantage of this approach is that a feature’s implementation can include, beside classes in the form of Java ﬁles, also other supporting documents, e.g., documentation in the form of HTML ﬁles, grammar speciﬁcations in the form of JavaCC ﬁles, or build scripts and deployment descriptors in the form of XML ﬁles [13]. To this end, feature composition merges not only classes with their reﬁnements but also other artifacts, such as HTML or XML ﬁles, with their respective reﬁnements [2,9].
Another class of programming languages that provide mechanisms for the deﬁnition and extension of classes and class hierarchies includes, e.g., ContextL [29], Scala [52], and Classbox/J [14]. The difference to feature-oriented languages is that they provide explicit language constructs for aggregating the classes that belong to a feature, e.g., family classes, classboxes, or layers. This implies that non-code software artifacts cannot be included in a feature [11]. However, FFJ still models a subset of these languages, in particular, class reﬁnement.
Similarly, related work on a formalization of the key concepts underlying featureoriented programming has not disassociated the concept of a feature from the level of
9 http://www.fosd.de/ffj
35

code. Especially, calculi for mixins [26,16,1,34], traits [41], family polymorphism and virtual classes [33,25,30,18], path-dependent types [52,51], open classes [20], dependent classes [27], and nested inheritance [50] either support only the reﬁnement of single classes or expect the classes that form a semantically coherent unit (i.e., that belong to a feature) to be located in a physical module that is deﬁned in the host programming language. For example, a virtual class is by deﬁnition an inner class of the enclosing object, and a classbox is a package that aggregates a set of related classes. Thus, FFJ differs from previous approaches in that it relies on contextual information that has been collected by the compiler, e.g., the features’ composition order or the mapping of code to features.
A different line of research aims at the language-independent reasoning about features [13,44,9,39]. The calculus gDeep is most closely related to FFJ since it provides a type system for feature-oriented languages that is language-independent [4]. The idea is that the recursive process of merging software artifacts, when composing hierarchically structured features, is very similar for different host languages, e.g., for Java, C#, and XML. The calculus describes formally how feature composition is performed and what type constraints have to be satisﬁed. In contrast, FFJ does not aspire to be languageindependent, although the key concepts can certainly be used with different languages. The advantage of FFJ is that its type system can be used to check whether terms of the host language (Java or FJ) violate the principles of feature orientation, e.g., whether methods refer to classes that have been added by other features. Due to its language independence, gDeep does not have enough information to perform such checks.
5.2 Feature-Oriented Product Lines
Our work on type checking feature-oriented product lines was motivated by the work of Thaker et al. [64]. They suggested the development of a type system for featureoriented product lines that does not check all individual programs but the individual feature implementations. They have implemented an (incomplete) type system and, in a number of case studies on real product lines, they found numerous hidden errors using their type rules. Nevertheless, the implementation of their type system is ad-hoc in the sense that it is described only informally, and they do not provide a correctness and completeness proof. Our type system has been inspired by their work and we were able to provide a formalization and a proof of type safety.
In a parallel line of work, Delaware et al. have developed a formal model of a feature-oriented language, called Lightweight Feature Java (LFJ), and a type system for feature-oriented product lines [23]. Their work was also inﬂuenced by the practical work of Thaker et al. So, it is not surprising that it is closest to ours. However, there are numerous differences. First, their formal model of a feature-oriented language is based on Lightweight Java (LJ) [62] and not on Featherweight Java (FJ). While LJ is more expressive, it is also more complex. We decided for the simpler variant FJ, omitting, e.g., constructors and mutable state. Second, Delaware et al. do not model featureoriented mechanisms, such as class or method reﬁnements, directly in the semantics and type rules of the language. Instead, they introduce a transformation step in which LFJ code is “compiled down” to LJ code, i.e., they ﬂatten reﬁnement chains to single classes. Proceeding likewise, we would have to generate ﬁrst an FJ program from an
36

FFJ product line and type check the FJ program (that consists of some or all possible features of the product line) subsequently. We refrained from such a transformation step in order to model the semantics of feature-oriented mechanisms directly in terms of dedicated ﬁeld and method lookup mechanisms as well as special well-formed rules for method and class reﬁnements.
Lagorio et al. have shown that a ﬂattening semantics and a direct semantics are equivalent [40]. An advantage of a “direct” semantics is that it allows a type checking and error reporting at a ﬁner grain. In LFJ, all feature modules are composed and a single propositional formula is generated and tested for satisﬁability; if the formula is not satisﬁable, it is difﬁcult to identify precisely the point of failure. In FFJPL, the individual type rules consult the feature model and can point directly to the point of failure.
A further advantage of our approach is that it leaves open when feature composition is performed. Currently, feature composition is modeled in FFJ/FFJPL as a static process done before compilation but, with our approach, it becomes possible to model dynamic feature composition at run time [58,53] by making the class and feature tables and the feature model dynamic, i.e., allowing them to change during a computation. With LFJ this is not possible. Hutchins has shown that feature composition can be performed by an interpreter and partial evaluation can be used to pre-evaluate the parts of a composition that are static [31]. However, Delaware et al. have developed a machinechecked model of their type system formalized with the theorem prover Coq [15]. Our proof is hand-written, but we have a Haskell implementation of the FFJ and FFJPL calculi that we have tested thoroughly.
Even previously to the work of Thaker et al., Czarnecki et al. presented an automatic veriﬁcation procedure for ensuring that no ill-structured UML model template instances will be generated from a valid feature selection [22]. That is, they type check product lines that consist not of Java programs but of UML models. They use OCL (object constraint language) constraints to express and implement a type system for model composition. In this sense, their aim is very similar to that of FFJPL, but limited to model artifacts – although they have proposed to generalize their work to programming languages.
Kästner et al. have implemented a tool, called CIDE, that allows a developer to decompose a software system into features via annotations [38]. In contrast to other feature-oriented languages and tools, the link between code and features is established via annotations. If a user selects a set of features, all code that is annotated with features (using background colors) that are not present in the selection is removed. Kästner et al. have developed a formal calculus and a set of type rules that ensure that only welltyped programs can be generated from a valid feature selection [36]. For example, if a method declaration is removed, the remaining code must not contain calls to this method. CIDE’s type rules are related to the type rules of FFJPL but, so far, mutually exclusive features are not supported in CIDE. In some sense, FFJPL and CIDE represent two sides of the same coin: the former aims at the composition of feature modules, the latter at the annotation of feature-related code.
37

6 Conclusion
A feature-oriented product line imposes severe challenges on type checking. The naive approach of checking all individual programs of a product line is not feasible because of the combinatorial explosion of program variants. Hence, the only practical option is to check the entire code base of a product line, including all features, and, based on the information of which feature combinations are valid, to ensure that it is not possible to derive a valid program variant that contains type errors.
We have developed such a type system based on a formal model of a featureoriented Java-like language, called Feature Featherweight Java (FFJ). A distinguishing property of our work is that we have modeled the semantics and type rules for core feature-oriented mechanisms directly, without compiling feature-oriented code down to a lower-level representation such as object-oriented Java code. The direct semantics allows us to reason about core feature-oriented mechanisms in terms of themselves and not of generated lower-level code. A further advantage is the ﬁne-grained error reporting and that the time of feature composition may vary between compile time and run time.
We have demonstrated and proved that, based on a valid feature selection, our type system ensures that every program of a feature-oriented product line is well-formed and that our type system is complete. Our implementation of FFJ, including the type system for product lines, indicates the feasibility of our approach and can serve as a testbed for experimenting with further feature-oriented mechanisms.
Acknowledgment
This work is being funded in part by the German Research Foundation (DFG), project number AP 206/2-1.
References
1. D. Ancona, G. Lagorio, and E. Zucca. Jam—Designing a Java Extension with Mixins. ACM Transactions on Programming Languages and Systems (TOPLAS), 25(5):641–712, 2003.
2. F. Anfurrutia, O. Díaz, and S. Trujillo. On Reﬁning XML Artifacts. In Proceedings of the International Conference on Web Engineering (ICWE), volume 4607 of LNCS, pages 473– 478. Springer-Verlag, 2007.
3. S. Apel and K. Böhm. Towards the Development of Ubiquitous Middleware Product Lines. In Software Engineering and Middleware, volume 3437 of LNCS, pages 137–153. SpringerVerlag, 2004.
4. S. Apel and D. Hutchins. An Overview of the gDeep Calculus. Technical Report MIP-0712, Department of Informatics and Mathematics, University of Passau, 2007.
5. S. Apel, F. Janda, S. Trujillo, and C. Kästner. Model Superimposition in Software Product Lines. In Proceedings of the International Conference on Model Transformation (ICMT), volume 5563 of LNCS, pages 4–19. Springer-Verlag, 2009.
6. S. Apel, C. Kästner, A. Größlinger, and C. Lengauer. Feature (De)composition in Functional Programming. In Proceedings of the International Conference on Software Composition (SC), volume 5634 of LNCS, pages 9–26. Springer-Verlag, 2009.
38

7. S. Apel, C. Kästner, and C. Lengauer. An Overview of Feature Featherweight Java. Technical Report MIP-0802, Department of Informatics and Mathematics, University of Passau, 2008.
8. S. Apel, C. Kästner, and C. Lengauer. Feature Featherweight Java: A Calculus for FeatureOriented Programming and Stepwise Reﬁnement. In Proceedings of the International Conference on Generative Programming and Component Engineering (GPCE), pages 101–112. ACM Press, 2008.
9. S. Apel, C. Kästner, and C. Lengauer. FeatureHouse: Language-Independent, Automated Software Composition. In Proceedings of the International Conference on Software Engineering (ICSE), pages 221–231. IEEE CS Press, 2009.
10. S. Apel, T. Leich, M. Rosenmüller, and G. Saake. FeatureC++: On the Symbiosis of FeatureOriented and Aspect-Oriented Programming. In Proceedings of the International Conference on Generative Programming and Component Engineering (GPCE), volume 3676 of LNCS, pages 125–140. Springer-Verlag, 2005.
11. S. Apel, T. Leich, and G. Saake. Aspectual Feature Modules. IEEE Transactions on Software Engineering (TSE), 34(2):162–180, 2008.
12. D. Batory. Feature Models, Grammars, and Propositional Formulas. In Proceedings of the International Software Product Line Conference (SPLC), volume 3714 of LNCS, pages 7–20. Springer-Verlag, 2005.
13. D. Batory, J. Sarvela, and A. Rauschmayer. Scaling Step-Wise Reﬁnement. IEEE Transactions on Software Engineering (TSE), 30(6):355–371, 2004.
14. A. Bergel, S. Ducasse, and O. Nierstrasz. Classbox/J: Controlling the Scope of Change in Java. In Proceedings of the International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), pages 177–189. ACM Press, 2005.
15. Y. Bertot and P. Casteran. Interactive Theorem Proving and Program Development – Coq’Art: The Calculus of Inductive Constructions. Texts in Theoretical Computer Science. An EATCS Series. Springer-Verlag, 2004.
16. V. Bono, A. Patel, and V. Shmatikov. A Core Calculus of Classes and Mixins. In Proceedings of the European Conference on Object-Oriented Programming (ECOOP), volume 1628 of LNCS, pages 43–66. Springer-Verlag, 1999.
17. G. Bracha and W. Cook. Mixin-Based Inheritance. In Proceedings of the European Conference on Object-Oriented Programming (ECOOP) and International Conference on ObjectOriented Programming Systems, Languages, and Applications (OOPSLA), pages 303–311. ACM Press, 1990.
18. D. Clarke, S. Drossopoulou, J. Noble, and T. Wrigstad. Tribe: A Simple Virtual Class Calculus. In Proceedings of the International Conference on Aspect-Oriented Software Development (AOSD), pages 121–134. ACM Press, 2007.
19. P. Clements and L. Northrop. Software Product Lines: Practices and Patterns. AddisonWesley, 2002.
20. C. Clifton, T. Millstein, G. Leavens, and C. Chambers. MultiJava: Design Rationale, Compiler Implementation, and Applications. ACM Transactions on Programming Languages and Systems (TOPLAS), 28(3):517–575, 2006.
21. K. Czarnecki and U. Eisenecker. Generative Programming: Methods, Tools, and Applications. Addison-Wesley, 2000.
22. K. Czarnecki and K. Pietroszek. Verifying Feature-Based Model Templates Against WellFormedness OCL Constraints. In Proceedings of the International Conference on Generative Programming and Component Engineering (GPCE), pages 211–220. ACM Press, 2006.
23. B. Delaware, W. Cook, and D. Batory. A Machine-Checked Model of Safe Composition. In Proceedings of the International Workshop on Foundations of Aspect-Oriented Languages (FOAL), pages 31–35. ACM Press, 2009.
39

24. S. Ducasse, O. Nierstrasz, N. Schärli, R. Wuyts, and A. Black. Traits: A Mechanism for FineGrained Reuse. ACM Transactions on Programming Languages and Systems (TOPLAS), 28(2):331–388, 2006.
25. E. Ernst, K. Ostermann, and W. Cook. A Virtual Class Calculus. In Proceedings of the International Symposium on Principles of Programming Languages (POPL), pages 270– 282. ACM Press, 2006.
26. M. Flatt, S. Krishnamurthi, and M. Felleisen. Classes and Mixins. In Proceedings of the International Symposium on Principles of Programming Languages (POPL), pages 171– 183. ACM Press, 1998.
27. V. Gasiunas, M. Mezini, and K. Ostermann. Dependent Classes. In Proceedings of the International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), pages 133–152. ACM Press, 2007.
28. J. Gosling, B. Joy, G. Steele, and G. Bracha. The Java Language Speciﬁcation. The Java Series. Addison-Wesley, 3rd edition, 2005.
29. R. Hirschfeld, P. Costanza, and O. Nierstrasz. Context-Oriented Programming. Journal of Object Technology (JOT), 7(3):125–151, 2008.
30. D. Hutchins. Eliminating Distinctions of Class: Using Prototypes to Model Virtual Classes. In Proceedings of the International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), pages 1–19. ACM Press, 2006.
31. D. Hutchins. Pure Subtype Systems: A Type Theory For Extensible Software. PhD thesis, School of Informatics, University of Edinburgh, 2008.
32. A. Igarashi, B. Pierce, and P. Wadler. Featherweight Java: A Minimal Core Calculus for Java and GJ. ACM Transactions on Programming Languages and Systems (TOPLAS), 23(3):396– 450, 2001.
33. A. Igarashi, C. Saito, and M. Viroli. Lightweight Family Polymorphism. In Proceedings of the Asian Symposium on Programming Languages and Systems (APLAS), volume 3780 of LNCS, pages 161–177. Springer-Verlag, 2005.
34. T. Kamina and T. Tamai. McJava – A Design and Implementation of Java with Mixin-Types. In Proceedings of the Asian Symposium on Programming Languages and Systems (APLAS), volume 3302 of LNCS, pages 398–414. Springer-Verlag, 2004.
35. K. Kang, S. Cohen, J. Hess, W. Novak, and A. Peterson. Feature-Oriented Domain Analysis (FODA) Feasibility Study. Technical Report CMU/SEI-90-TR-21, Software Engineering Institute, Carnegie Mellon University, 1990.
36. C. Kästner and S. Apel. Type-Checking Software Product Lines – A Formal Approach. In Proceedings of the International Conference on Automated Software Engineering (ASE), pages 258–267. IEEE CS Press, 2008.
37. C. Kästner, S. Apel, and D. Batory. A Case Study Implementing Features using AspectJ. In Proceedings of the International Software Product Line Conference (SPLC), pages 222–232. IEEE CS Press, 2007.
38. C. Kästner, S. Apel, and M. Kuhlemann. Granularity in Software Product Lines. In Proceedings of the International Conference on Software Engineering (ICSE), pages 311–320. ACM Press, 2008.
39. C. Kästner, S. Apel, S. Trujillo, M. Kuhlemann, and D. Batory. Guaranteeing Syntactic Correctness for all Product Line Variants: A Language-Independent Approach. In Proceedings of the International Conference on Objects, Models, Components, Patterns (TOOLS EUROPE), volume 33 of LNBI, pages 174–194. Springer-Verlag, 2009.
40. G. Lagorio, M. Servetto, and E. Zucca. Featherweight Jigsaw – A Minimal Core Calculus for Modular Composition of Classes. In Proceedings of the European Conference on ObjectOriented Programming (ECOOP), LNCS. Springer-Verlag, 2009.
41. L. Liquori and A. Spiwack. FeatherTrait: A Modest Extension of Featherweight Java. ACM Transactions on Programming Languages and Systems (TOPLAS), 30(2):1–32, 2008.
40

42. R. Lopez-Herrejon and D. Batory. A Standard Problem for Evaluating Product-Line Methodologies. In Proceedings of the International Conference on Generative and ComponentBased Software Engineering (GCSE), volume 2186 of LNCS, pages 10–24. Springer-Verlag, 2001.
43. R. Lopez-Herrejon, D. Batory, and W. Cook. Evaluating Support for Features in Advanced Modularization Technologies. In Proceedings of the European Conference on ObjectOriented Programming (ECOOP), volume 3586 of LNCS, pages 169–194. Springer-Verlag, 2005.
44. R. Lopez-Herrejon, D. Batory, and C. Lengauer. A Disciplined Approach to Aspect Composition. In Proceedings of the International Symposium Partial Evaluation and SemanticsBased Program Manipulation (PEPM), pages 68–77. ACM Press, 2006.
45. O. Madsen and B. Moller-Pedersen. Virtual Classes: A Powerful Mechanism in ObjectOriented Programming. In Proceedings of the International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), pages 397–406. ACM Press, 1989.
46. H. Masuhara and G. Kiczales. Modeling Crosscutting in Aspect-Oriented Mechanisms. In Proceedings of the European Conference on Object-Oriented Programming (ECOOP), volume 2743 of LNCS, pages 2–28. Springer-Verlag, 2003.
47. M. Mendonca, A. Wasowski, and K. Czarnecki. SAT-based Analysis of Feature Models is Easy. In Proceedings of the International Software Product Line Conference (SPLC). Software Engineering Institute, Carnegie Mellon University, 2009.
48. M. Mezini and K. Ostermann. Variability Management with Feature-Oriented Programming and Aspects. In Proceedings of the International Symposium on Foundations of Software Engineering (FSE), pages 127–136. ACM Press, 2004.
49. G. Murphy, A. Lai, R. Walker, and M. Robillard. Separating Features in Source Code: An Exploratory Study. In Proceedings of the International Conference on Software Engineering (ICSE), pages 275–284. IEEE CS Press, 2001.
50. N. Nystrom, S. Chong, and A. Myers. Scalable Extensibility via Nested Inheritance. In Proceedings of the International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), pages 99–115. ACM Press, 2004.
51. M. Odersky, V. Cremet, C. Röckl, and M. Zenger. A Nominal Theory of Objects with Dependent Types. In Proceedings of the European Conference on Object-Oriented Programming (ECOOP), volume 2743 of LNCS, pages 201–224. Springer-Verlag, 2003.
52. M. Odersky and M. Zenger. Scalable Component Abstractions. In Proceedings of the International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), pages 41–57. ACM Press, 2005.
53. K. Ostermann. Dynamically Composable Collaborations with Delegation Layers. In Proceedings of the European Conference on Object-Oriented Programming (ECOOP), volume 2374 of LNCS, pages 89–110. Springer-Verlag, 2002.
54. B. Pierce. Types and Programming Languages. MIT Press, 2002. 55. C. Prehofer. Feature-Oriented Programming: A Fresh Look at Objects. In Proceedings of the
European Conference on Object-Oriented Programming (ECOOP), volume 1241 of LNCS, pages 419–443. Springer-Verlag, 1997. 56. T. Reenskaug, E. Andersen, A. Berre, A. Hurlen, A. Landmark, O. Lehne, E. Nordhagen, E. Ness-Ulseth, G. Oftedal, A. Skaar, and P. Stenslet. OORASS: Seamless Support for the Creation and Maintenance of Object-Oriented Systems. Journal of Object-Oriented Programming (JOOP), 5(6):27–41, 1992. 57. M. Rosenmüller, C. Kästner, N. Siegmund, S. Sunkle, S. Apel, T. Leich, and G. Saake. SQL á la Carte – Toward Tailor-made Data Management. In Datenbanksysteme in Business, Technologie und Web – Fachtagung des GI-Fachbereichs Datenbanken und Informationssysteme, volume P-144 of GI-Edition – LNI, pages 117–136. Gesellschaft für Informatik, 2009.
41

58. M. Rosenmüller, N. Siegmund, G. Saake, and S. Apel. Code Generation to Support Static and Dynamic Composition of Software Product Lines. In Proceedings of the International Conference on Generative Programming and Component Engineering (GPCE), pages 3–12. ACM Press, 2008.
59. M. Rosenmüller, N. Siegmund, H. Schirmeier, J. Sincero, S. Apel, T. Leich, O. Spinczyk, and G. Saake. FAME-DBMS: Talor-made Data Management Solutions for Embedded Systems. In Proceedings of the EDBT Workshop on Software Engineering for Tailor-made Data Management (SETMDM), pages 1–6. ACM Press, 2008.
60. N. Siegmund, C. Kästner, M. Rosenmüller, F. Heidenreich, S. Apel, and G. Saake. Bridging the Gap between Variability in Client Application and Database Schema. In Datenbanksysteme in Business, Technologie und Web – Fachtagung des GI-Fachbereichs Datenbanken und Informationssysteme, volume P-144 of GI-Edition – LNI, pages 297–306. Gesellschaft für Informatik, 2009.
61. Y. Smaragdakis and D. Batory. Mixin Layers: An Object-Oriented Implementation Technique for Reﬁnements and Collaboration-Based Designs. ACM Transactions on Software Engineering and Methodology (TOSEM), 11(2):215–255, 2002.
62. R. Strniša, P. Sewell, and M. Parkinson. The Java Module System: Core Design and Semantic Deﬁnition. In Proceedings of the International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), pages 499–514. ACM Press, 2007.
63. P. Tarr, H. Ossher, W. Harrison, and S. Sutton, Jr. N Degrees of Separation: MultiDimensional Separation of Concerns. In Proceedings of the International Conference on Software Engineering (ICSE), pages 107–119. IEEE CS Press, 1999.
64. S. Thaker, D. Batory, D. Kitchin, and W. Cook. Safe Composition of Product Lines. In Proceedings of the International Conference on Generative Programming and Component Engineering (GPCE), pages 95–104. ACM Press, 2007.
65. M. VanHilst and D. Notkin. Using Role Components in Implement Collaboration-based Designs. In Proceedings of the International Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), pages 359–369. ACM Press, 1996.
66. A. K. Wright and M. Felleisen. A Syntactic Approach to Type Soundness. Information and Computation, 115(1):38–94, 1994.
A Type Soundness Proof of FFJ
Before giving the main proof, we state and proof some required lemmas.
LEMMA A.1 If mtype(m, last(D)) = C → C0, then mtype(m, last(C)) = C → C0 for all C <: D.
Proof Straightforward induction on the derivation of C <: D. There are two cases: First, if method m is not deﬁned in the declaration or in any reﬁnement of class C, then mtype(m, last(C)) should be the same as mtype(m, last(E)) where CT (Φ.C) = class C extends E { . . . } for some Φ. This follows from the deﬁnition of mtype that searches E’s reﬁnement chain from right to left if m is not declared in C’s reﬁnement chain. Second, if m is deﬁned in the declaration or in any reﬁnement of class C, then mtype(m, last(C)) should also be the same as mtype(m, last(E)) with CT (Φ.C) = class C extends E { . . . } for some Φ. This case is covered by the well-formedness rules for methods that use the predicate override to ensure that m is properly overridden, i.e., the signatures of the overridden and the overriding declaration of m are equal, and that m is not introduced twice, i.e., overloading is not allowed in FFJ.
42

LEMMA A.2 (Term substitution preserves typing) If Γ, x : B t : D and Γ, s : A, where A <: B, then Γ [x → s] t : C for some C <: D.
Proof By induction on the derivation of Γ, x : B t : D.
CASE (T-VAR) t = x x : D ∈ Γ
If x ∈ x, then the result is trivial since [x → s] x = x.10 On the other hand, if x = xi and D = Bi, then, since [x → s] x = si, letting C = Ai ﬁnishes the case.
CASE (T-FIELD) t = t0.fi Γ, x : B t0 : D0 ﬁelds(last (D0)) = C f D = Ci
By the induction hypothesis, there is some C0 such that Γ [x → s] t0 : C0 and C0 <: D0. It is easy to check that ﬁelds(last(C0)) = (ﬁelds(last(D0)), D g) for some D g. Therefore, by T-FIELD, Γ ([x → s] t0).fi : Ci. The fact that the reﬁnements of a class may add new ﬁelds does not cause problems. D g contains all ﬁelds that C0, including all of its reﬁnements, add to D0.
CASE (T-INVK) t = t0.m(t) Γ, x : B t0 : D0 mtype(m, last(D0)) = E → D Γ, x : B t : D D <: E
By the induction hypothesis, there are some C0 and C such that:
Γ [x → s] t0 : C0 C0 <: D0 Γ [x → s] t : C C <: D.
By Lemma A.1, we have mtype(m, last(C0)) = E → D. Moreover, C <: E by the transitivity of <: . Therefore, by T-INVK, Γ [x → s] t0.m([x → s] t) : D. The key is that subclasses and reﬁnements may override methods but the well-formedness rules of methods ensure that the method’s type is not altered, i.e., there is no overloading in FFJ.
CASE (T-NEW) t = new D(t) ﬁelds(last(D)) = D f Γ, x : B t : C C <: D
By the induction hypothesis, Γ [x → s] t : E for some E with E <: C. We have E <: D by the transitivity of <: . Therefore, by rule T-NEW, Γ new D([x → s] t) : D. Although reﬁnements of class D may add new ﬁelds, rule T-NEW ensures that the arguments of the object creation match the overall ﬁelds of D, including all reﬁnements, in number and types. That is, the number of arguments (t) equals the number of ﬁelds (f) which function ﬁelds returns.
CASE (T-UCAST) t = (D)t0 Γ, x : B t0 : C C <: D
By the induction hypothesis, there is some E such that Γ [x → s] t0 : E and E <: C. We have E <: D by the transitivity of <: , which yields Γ (D)( [x → s] t0) : D by T-UCAST.
CASE (T-DCAST) t = (D)t0 Γ, x : B t0 : C D <: C D = C
10 Note that [x → s] x is an abbreviation for [x1 → s1, . . . , xn → sn] x. It means that all occurrences of the variables x1, . . . , xn in the term x are substituted with the corresponsing terms s1, . . . , sn.
43

By the induction hypothesis, there is some E such that Γ [x → s] t0 : E and E <: C. If E <: D or D <: E, then Γ (D)([x → s] t0) : D by T-UCAST or T-DCAST, respectively. If both D <: E and E <: D, then Γ (D)([x → s] t0) : D (with a stupid warning) by T-SCAST.
CASE (T-SCAST) t = (D)t0 Γ, x : B t0 : C D <: C C <: D
By the induction hypothesis, there is some E such that Γ [x → s] t0 : E and E <: C. This means that E <: D because, in FFJ, each class has just one superclass and, if both E <: C and E <: D, then either C <: D or D <: C, which contradicts the induction hypothesis. So Γ (D)( [x → s] t0) : D (with a stupid warning), by T-SCAST.
LEMMA A.3 (Weakening) If Γ t : C, then Γ, x : D t : C
Proof Straightforward induction. The proof for FFJ is similar to the proof for FJ.
LEMMA A.4 If mtype(m, last(C0)) = D → D, and mbody(m, last(C0)) = (x, t), then for some D0 and some C <: D we have C0 <: D0 and x : D, this : D0 t : C .
Proof By induction on the derivation of mbody(m, last(C0)). The base case (in which m is deﬁned in the most speciﬁc reﬁnement of C0) is easy since m is deﬁned in CT (last(C0)) and the well-formedness of the class table implies that we must have derived x : D, this : C0 t : C by the well-formedness rules of methods. The induction step is also straightforward: if m is not deﬁned in CT (last(C0)), then mbody searches the reﬁnement chain from right to left; if m has not been found, the superclass’ reﬁnement chain is searched. There are two subcases: ﬁrst, m is deﬁned in the declaration or in any reﬁnement of C0; this case is similar to the base case. Second, m is deﬁned in a superclass D0 of C0 or in one of D0’s reﬁnements; in this case, the well-formedness of the class table implies that we must have derived x : D, this : D0 t : C by the wellformedness rules of methods, which ﬁnishes the case.
Note that this lemma holds because method reﬁnements do not change the types of the arguments and the result of a method, overloading is not allowed, and this points always to the class that is introduced or reﬁned.
THEOREM A.1 (Preservation) If Γ t : C and t −→ t , then Γ t : C for some C <: C.
Proof By induction on a derivation of t −→ t , with a case analysis on the ﬁnal rule.
CASE (E-PROJNEW) t = new C0(v).fi t = vi ﬁelds(last (C0)) = D f
From the shape of t, we see that the ﬁnal rule in the derivation of Γ t : C must be T-FIELD, with premise Γ new C0(v) : D0, for some D0, and that C = Di. Similarly, the last rule in the derivation of Γ new C0(v) : D0 must be T-NEW, with premises Γ v : C and C <: D, and with D0 = C0. In particular, Γ vi : Ci, which ﬁnishes the case, since Ci <: Di.
CASE (E-INVKNEW) t = (new C0(v)).m(u) t = [x → u, this → new C0(v)] t0 mbody(m, last(C0)) = (x, t0)
44

The ﬁnal rules in the derivation of Γ t : C must be T-INVK and T-NEW, with premises Γ new C0(v) : C0, Γ u : C, C <: D, and mtype(m, last(C0)) = D → C. By Lemma A.4, we have x : D, this : D0 t : B for some D0 and B, with C0 <: D0 and B <: C. By Lemma A.3, Γ, x : D, this : D0 t0 : B. Then, by Lemma A.2, we have Γ [x → u, this → new C0(v)] t0 : E for some E <: B. By the transitivity of <: , we obtain E <: C. Letting C = E completes the case.
CASE (E-CASTNEW) t = (D)(new C0(v)) C0 <: D t = new C0(v)
The proof of Γ (D)(new C0(v)) : C must end with T-UCAST since ending with TSCAST or T-DCAST would contradict the assumption of C0 <: D. The premises of T-UCAST give us Γ new C0(v) : C0 and D = C, ﬁnishing the case.
The cases for the congruence rules are easy. We show just the case E-CAST.
CASE (E-CAST) t = (D)t0 t = (D)t0 t0 −→ t0
There are three subcases according to the last typing rule used.
SUBCASE (T-UCAST) Γ t0 : C0 C0 <: D D = C
By the induction hypothesis, Γ t0 : C0 for some C0 <: C0. By transitivity of <: , C0 <: C. Therefore, by T-UCAST, Γ (C)t0 : C (with no additional stupid warning).
SUBCASE (T-DCAST) Γ t0 : C0 D <: C0 D = C
By the induction hypothesis, Γ t0 : C0 for some C0 <: C0. If C0 <: C or C <: C0, then Γ (C)t0 : C by T-UCAST or T-DCAST (without any additional stupid warning). On the other hand, if both C0 <: C or C <: C0, then Γ (C)t0 : C with a stupid warning by T-SCAST.
SUBCASE (T-SCAST) Γ t0 : C0 D <: C0 C0 <: D D = C
By the induction hypothesis, Γ t0 : C0 for some C0 <: C0. Then, also C0 <: C and C <: C0. Therefore Γ (C)t0 : C with a stupid warning. If C0 <: C, then C <: C0 since C <: C0 and, therefore, Γ (C)t0 : C with stupid war ning. If C0 <: C, then Γ (C)t0 : C by T-UCAST (with no additional stupid warning). This subcase is analogous to the case T-SCAST of the proof of Lemma A.2.
THEOREM A.2 (Progress) Suppose t is a well-typed term.
1. If t includes new C0(t).fi as a subterm, then ﬁelds(last(C0)) = C f for some C and f.
2. If t includes new C0(t).m(u) as a subterm, then mbody(m, last(C0)) = (x, t0) and |x| = |u| for some x and t0.
Proof If t has new C0(t).fi as a subterm, then, by well-typedness of the subterm, it is easy to check that ﬁelds(last(C0)) is well-deﬁned and fi appears in it. The fact that reﬁnements may add ﬁelds (that have not been deﬁned already) does not invalidate this conclusion. Note that for every ﬁeld of a class, including its superclasses and all its reﬁnements, there must be a proper argument. Similarly, if t has new C0(t).m(u) as a subterm, then it is also easy to show that mbody(m, last(C0)) = (x, t0) and |x| = |u| from the fact that mtype(m, last(C0)) = C → D where |x| = |C|. This conclusion holds for FFJ since a method reﬁnement must have the same signature than the method reﬁned and overloading is not allowed.
45

THEOREM A.3 (Type soundness of FFJ) If ∅ t : C and t −→∗ t with t a normal form, then t is either a value v with ∅ v : D and D <: C, or a term containing (D)(new C(t)) in which C <: D.
Proof Immediate from Theorem A.1 and A.2. Nothing changes in the proof of Theorem A.3 for FFJ compared to FJ.

B Type Soundness Proof of FFJPL
In this section, we provide proof sketches of the theorems Correctness of FFJPL and Completeness of FFJPL. A further formalization would be desirable, but we have stopped at this point. As is often the case with formal systems, there is a trade-off between formal precision and legibility. We decided that a semi-formal development of the proof strategies are the best ﬁt for our purposes.

B.1 Correctness

THEOREM B.1 (Correctness of FFJPL) Given a well-typed FFJPL product line pl (including with a well-typed term t, well-formed class, introduction, and reﬁnement tables CT , IT , and RT , and a feature model FM ), every program that can be derived with a valid feature selection fs is a well-typed FFJ program (cf. Figure 10).

pl = (t, CT , IT , RT , FM ) pl is well-typed fs is valid in FM derive(pl , fs) is well-typed

The proof strategy is as follows: assuming that the FFJPL type system ensures that each slice is a valid FFJ type derivation (Lemma B.1) and that each valid feature selection corresponds to a single slice (Lemma B.1), it follows that the corresponding feature-oriented program is well-formed. Before we prove Theorem B.1 we develop two required lemmas that cover the two assumptions of our proof strategy.

LEMMA B.1 Given a well-formed FFJPL product line, every slice of the product line’s type derivation corresponds to a (set of) valid type derivation(s) in FFJ.

Proof (Proof sketch) Given a well-formed FFJPL product line, the corresponding type derivation consists of possibly multiple slices.
The basic case is easy: there is only a simple derivation without branches due to mutually exclusive features (optional features may be present). In this case, each term has only a single type, which is the one that would also be determined by FFJ. Furthermore, FFJPL guarantees that referenced types, methods, and ﬁelds are present in all valid variants, using the predicate validref .
Let us illustrate this with the rule T-FIELDPL; the other rules are analogous:

∀ E ∈ E : validref (Φ, E.f) Γ t0 : E Φ ﬁelds(Φ, last(E)) = F , C f, G Γ t0.f : C11, . . . , Cn1, . . . , C1m, . . . , Cnm Φ

(T-FIELDPL)

46

In the basic case there are no branches in the type derivation and thus the term t0 has only a single type E1. For the same reason, ﬁelds returns only a simple list of ﬁelds that contains the declaration of ﬁeld f. Finally, T-FIELDPL checks whether the declaration of f is present in all valid variants (using validref ). Hence, in the basic case, an FFJPL derivation that ends at the rule T-FIELDPL is equivalent to a set of corresponding FFJ derivations, which do not contain alternative and optional features and thus t0 has a single type, ﬁelds returns a simple list of ﬁelds that contains the declaration of f, and the declaration of f is present. The reason that an FFJPL derivation without mutually exclusive features (i.e., a single slice) corresponds to multiple FFJ derivations is that the FFJPL derivation may contain optional features whose different combinations correspond to the different FFJ derivations. Using predicate validref , all type rules of FFJPL ensure that all possible combinations of optional features are welltyped.
In the case that there are multiple slices in the FFJPL derivation, a term t0 may have multiple types E. The type rules of FFJPL make sure that every possible shape of a given term is well-typed. Each possible type of the term leads to a branch in the derivation tree. The premise of T-FIELDPL checks whether all possible shapes of a given term are well-typed by taking the conjunction of all branches of the derivation. Hence, if T-FIELDPL is successful, each individual branch holds, i.e., each slice corresponds to a well-typed FFJ program. Ensuring that, in the presence of optional features, all relevant subterms are well-typed (i.e., all referenced elements are present in all valid variants), a well-typed slice covers a set of well-typed FFJ derivations that correspond to different combinations of optional features, like in the basic case.
For example, in a ﬁeld projection t0.f, the subterm t0 has multiple types E. For all these types, ﬁelds yields all possible combinations of ﬁelds declared by the variants of the types. It is checked whether, for each type of the subterm t0, each combination of ﬁelds contains a proper declaration of ﬁeld f. The different types of f become the possible types of the overall ﬁeld projection term. Like in the basic case, it is checked whether every possible type of t0 is present in all valid variants (using validref ), so that each slice corresponds a valid FFJ derivation, i.e., a whole set of derivations covering different combinations of optional features.
LEMMA B.2 Given a well-formed FFJPL product line, each valid feature selection corresponds to a single slice in the corresponding type derivation.
Proof (Proof sketch) By deﬁnition, a valid feature selection does not contain mutually exclusive features. Considering only a single valid feature selection, each term has only a single type. But the type derivation of the overall product line contains branches corresponding to alternative types of the terms. A successive removal of mutually exclusive features removes these branches until only a single branch remains. Consequently, a valid feature selection corresponds to a single slice.
Proof (Proof sketch of Theorem B.1 (Correctness of FFJPL)) The fact that the FFJPL type system ensures that each slice is a valid FFJ type derivation (Lemma B.1) and that each valid feature selection corresponds to a single slice (Lemma B.2), implies that each feature-oriented program that corresponds to a valid feature selection is well-formed.
47

B.2 Completeness
THEOREM B.2 (Completeness of FFJPL) Given an FFJPL product line pl (including a well-typed term t, well-formed class, introduction, and reﬁnement tables CT , IT , and RT , and a feature model FM ), and given that all valid feature selections fs yield well-typed FFJ programs, according to Theorem B.1, pl is a well-typed product line according to the rules of FFJPL.
pl = (t, CT , IT , RT , FM ) ∀ fs : (fs is valid in FM ⇒ derive(pl , fs) is well-typed) pl is well-typed
Proof (Proof sketch of Theorem B.2 (Completeness of FFJPL)) There are three basic cases: (1) pl has only mandatory features; (2) pl has only mandatory features except a single optional feature; (3) pl has only mandatory features except two mutually exclusive features. Proving Theorem B.2 for the ﬁrst basic case is trivial. Since only mandatory features exist, only a single FFJ program can be derived from the product line. If the FFJ program is well-typed, the product line is well-typed, too, because all elements are always reachable and each term has only a single type. In fact, the type rules of FFJPL and FFJ become equivalent in this case.
In the second basic case, two FFJ programs can be derived from the product line, one including and one excluding the optional feature. The difference between the two programs is the content of the optional feature. The feature can add new classes, reﬁne existing classes by new methods and ﬁelds, and reﬁne existing methods by overriding. If the two programs are well-typed, then the overall product line is well-typed as well since the reachability checks succeed in every type rule of FFJPL. Otherwise, at least one of the two programs would not be well-typed since, in this case, the reachability checks are the only difference between FFJPL’s and FFJ’s type rules (as in the ﬁrst case, each term has only a single type since there are no mutually exclusive features). The fact that the two FJ programs are well-typed implies that all elements are reachable in the type derivations of two FFJ programs. Thus, the reachability checks of the FFJPL derivation succeed in every case, i.e., the product line in question is well-typed.
In the third basic case, two FFJ programs can be derived from the product line, one including the ﬁrst alternative and the other including the second alternative of the feature in question. The difference between the two programs is, on the one hand, the program elements one feature introduces that are not present in the other and, on the other hand, the alternative deﬁnitions of similar elements, like two alternative deﬁnitions of a single class. The ﬁrst kind of difference is already covered by the second basic case. Alternative deﬁnitions of a program element (second kind of difference) that are well-typed in the context of their enclosing FFJ programs, are well-typed in FFJPL because they lead to two new branches in the derivation tree which are handled separately and the conjunction of their premises must hold. Since the corresponding FFJ type rule for the element succeeds in both FFJ programs, their conjunction in the FFJPL type rule always holds, i.e., the product line in question is well-typed.
Finally, we it remains to show that all other cases, i.e., all other combinations of mandatory, optional, and alternative features, can be reduced to combinations of the three basic cases, which proves Theorem B.2. To this end, we divide the possible relations between features into three disjoint sets: (1) a feature is reachable from another
48

feature in all variants, (2) a feature is reachable from another feature in some, but not in all, variants, (3) two features are mutually exclusive. From these three possible relations we construct a general case that can be reduced to a combination of the three basic cases.
Assume a feature Φ that is mandatory with respect to a set of features Π, that is optional with respect to a set of features Ω, and that is alternative to a set ∆ of features. We use arrows to illustrate to which of the three basic cases a pairwise relation between Φ and each element of a list is reduced:

Φ
1


AAAA2A3AAA/

Ω

Π∆

Such an arrow diagram can be created for every feature of a product line. The reason is that the three kinds of relations are orthogonal and there are no further relations relevant for type checking. Hence, the general case covers all possible relations between features and combinations of features. The description of the general case and the reduction ﬁnish the proof of Theorem B.2, i.e., FFJPL’s type system is complete.

49

