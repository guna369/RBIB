Annals of Mathematics and Artificial Intelligence 8(1993)383-405 383 
Proving Ramsey's theorem by the cover set induction: 
A case and comparison study* 
Hantao Zhang and Gary Xin Hua 
Department of Computer Science, The University of Iowa, Iowa City, IA 52242, USA 
Abstract 
An experiment of the cover set induction method in RRL is presented with a 
mechanical proof of Ramsey's theorem in graph theory. The proof is similar to the proof 
obtained by Kaufmarm using the Boyer-Moore theorem prover. We show that this 
similarity is not unusual, because there is a close relationship between the Boyer-Moore 
logic and the algebraic specification of abstract data types on which the cover set 
induction method is based. (This implies that many proofs done by the Boyer-Moore 
theorem prover can be reproduced by RRL.) Our experiment shows that RRL can 
automatically prove all the lemmas in Ramsey's theorem, while the Boyer-Moore 
theorem prover needs several user's hints and takes much longer (CPU time) to finish. 
1. Introduction 
Automating proofs of properties of functions defined on inductively constructed 
data structures is important in many computer science and artificial intelligence 
applications, in particular in program specification and verification. One of the 
powerful theorem provers which are capable of induction reasoning is the Boyer- 
Moore theorem prover (BMTP) [3], 
In [22], Zhang et al. developed an induction principle based on a constructor 
model of a data structure and have implemented it in RRL [16]. This principle 
together with a given function definition as a set of equations is used to construct 
automatically an induction scheme suitable for proving inductive properties of the 
function, The proposed induction principle thus gives different induction schemes 
for different function definitions. This idea was inspired by the way Boyer and 
Moore [3] used their induction principle. The major objective of this paper is to 
have an experimental comparison of the cover set induction method with BMTP. 
Another minor objective of the paper is to provide a tutorial to the use of the cover 
set induction method. 
*Partially supported by National Science Foundation Grants Nos. CCR-9202838 and INT-9016100. 
384 H. Zhang, G.X. Hua, Proving Ramsey's theorem 
The Boyer-Moore logic [3,4] is a quantifier-free, first-order predicate calculus 
with equality. Logic formulas are written in a prefix-style, Lisp-like notation. Three 
principles are defined in the Boyer-Moore logic: the shellprinciple allows the user 
to define new data objects;: the definition principle allows the user to define some 
total functions; and the induction principle allows the user to prove theorems valid 
in the logic. 
Unlike the Boyer-Moore logic, our induction principle applies to algebraic 
specifications inwhich functions are defined by equations. The specification language 
used by our theorem prover is exactly the one widely used in the algebraic approach 
to abstract data types. The cover set induction is a generalization of the structural 
induction in two aspects: 
(1) Instead of using the sets of terms llke {0, suc(x)} for the natural numbers, 
we can use many other sets (called cover sets) of terms like {0, suc(x) +y}. 
(2) Instead of the subterm relation like suc(x) > x, we use the reduction orderings, 
a very important and common concept in the term rewriting literature [7]. 
Consistency and sufficient completeness are two important properties of an 
algebraic specification [ 10], and they play an important role in our induction method. 
While our method works when a specification is not sufficiently complete, for the 
example to be discussed in this paper, the specification is sufficiently complete; in 
this case, our induction method proves theorems which are valid in the initial model 
of the specification [9]. 
Moreover, while the soundness of both the Boyer-Moore logic and our 
induction method is based on a well-founded ordering (i.e. well-founded induction), 
BMTP uses a semantic term ordering and we use syntactic term orderings, i.e. 
reduction orderings. 
Because the two methods vary in many ways, we feel that the best way to 
compare the two is by a detailed example. Recently, Kaufmann and Basin [1] 
conducted an experimental comparison of BMTP and the Nuprl Proof Development 
System [6]. They based their comparison on similar proofs of a specific theorem: 
the finite (exponent two) version of Ramsey's theorem in graph theory. The proofs 
are compared using both quantative and non-quantitative measures. We find that 
this version of Ramsey's theorem is a good candidate for comparison, because the 
theorem has a simple hand-proof, but also poses certain challenges to automatic 
theorem provers. 
The motive to have such a comparison has been clearly stated in [1]: ~ 
"We believe there is too little communication between those who use 
different mechanical proof-checking systems. This lack of communication 
encourages myths and preconceptions about the usability of various 
systems. Concrete comparisons bring to light the limitations and advantages 
of different systems, as well as their commonalities and differences". 
H. Zhang, G.X. Hua, Proving Ramsey's theorem 385 
The paper is organized as follows. Section 2 provides a proof of the Ramsey 
theorem and its formulation in a quantifier-free logic. Section 3 contains an informal 
description of the cover set induction method as implemented in RRL. Section 4 
presents aproof of Ramsey's theorem completed with RRL. In section 5, we compare 
our proof with Kaufmann's proof [1]. 
2. Ramsey's theorem and its formulation for provers 
In this section, after introducing some concepts of graph theory, we give an 
finite version of Ramsey's theorem with a "textbook proof". We then give the 
formulation of the theorem suitable for a theorem prover which cannot handle 
quantifiers. 
2.1. A VERSION OF RAMSEY'S THEOREM 
Let G = (V, E) be an undirected, simple graph, where V is a nonempty set of 
vertices and E is a set of edges on V. A subset I c V is called an independent set 
of G if no two vertices of I are adjacent in G; i.e. for any x,y  e l ,  (x,y) ~E. 
Similarly, a subset C c V is called a clique of G if for any x, y ~ C, (x, y) ~ E. 
Throughout this paper, we will consider the following theorem: 
RAMSEY'S THEOREM 
Given any natural numbers k and l, there exists a natural number n such that 
there exists either a clique of k vertices or an independent set of I vertices in any 
graph of n or more vertices. 
The smallest number satisfying the above condition is called the ramsey number 
and is denoted by r(k, l). This theorem can be stated as a first-logic formula: 
V(k, l)3nV(V, E) ( I Vl >- n) 
where 
3W((W c_ V) A (( I W I > k A clique(W, E)) v ( I W I > l A indep(W, E)))), 
clique(W, E) retums true iff for any two distinct vertices v, u ~ W, (v, u) ~E;  
indep(W, E) retums true iff for any two distinct verties v, u ~ W, (v, u) ~ E. 
Proof 
To prove the existence of the ramsey number, it is sufficient o show, by 
induction on k + l, that r(k, l) is bounded. For the basis case, it is easy to verify 
that r(1, l) = r(k, 1) = 1. For k > 1 and l > 1, let us prove that r(k, l) < r(k, l -  1) 
+ r (k -  1, l). 
386 H. Zhang, G.X. Hua, Proving Ramsey's theorem 
Let G = (V, E) be a graph on r(k, l - 1) + r(k - 1,,/) vertices. For any v ~ V, 
v partitions V -  {v} into two subsets, S and T, where each element of S is nonadjacent 
to v and each element of T is adjacent to v. Since r(k, l -  1) + r (k -  1, l) = IS I+ ITI + 1, 
we have either I S I > r(k, l - l )  or I T I -> r (k -  1, l). 
If IS I > r(k, l -  1), then v is nonadjacent to a set S of at least r(k, l -  1) 
vertices. For any subset V1 ~ V, let us call G[V 1] = (V1, E n (V1 x V1)) the subgraph 
of G induced by Vl. Since G[S] has at least r(k, l -  1) vertices, by the induction 
hypothesis, there exists in G[S] either a clique of k vertices or an independent set 
of l - 1 vertices. Therefore, G[S u {v}], a subgraph o f  G, contains either a clique 
of k vertices o ran  independent set of l vert ices .  
The case when I T I -> r(k - 1, l) is analogous, [] 
The above proof is a typical textbook proof [2]. The rest of this paper will 
show how the above proof can be reproduced by an automatic theorem prover. 
2.2. FORMULATION OF THE THEOREM IN A QUANTIFIER-FREE LOGIC 
In the statement of Ramsey's theorem and its proof, we intentionally wrote 
there exists in boldface. From the above proof of Ramsey's theorem, we can see 
that the proof mainly consists of  two steps: (i) aconstruction of a solution to the 
theorem (i.e. construct an instance for each existentially quantified variable), and 
(ii) the correctness proof of the constructed solution. 
Because both BMTP and RRL are designed to balance well between logical 
strength and automatic theorem proving power, and because handling existential 
quantifiers involves huge search space and cannot be easily automated, unlike other 
systems such as Nuprl [6] (which require heavy interaction from the user), both 
BMTP and RRL leave the burden of handling quantifiers (except outmost universal 
quantifiers) to the user. Hence, the first step toward a mechanical proof of  Ramsey's 
theorem is largely done by the user. That is, the user has to first replace each 
quantified variable by a well-designed function which retums the desired value. 
Because the theorem provers are used only to prove the correctness of the solutions 
constructed by the user and several intermediate l mmas have to be provided by the 
user, this kind of proofs is often termed as "proof checking" in the literature. 
However, we point out that the proof of a lemma may need several dozens of 
inference steps and is fully automated. 
For the first quantified variable n in Ramsey's theorem, we may define an 
upper bound, say ramsey(k, l), of r(k, l). From the proof of Ramsey's theorem, it 
is easy to recursively define ramsey(k, l), in the style of algebraic specification, as 
follows: 
DEFINITION 2.1 
ramsey : number x number ---> number 
H. Zhang, G.X. Hua, Proving Ramsey' s theorem 387 
ramsey(O,1) = 1 
ramsey(k, O) = 1 
ramsey(k + 1, l + 1) = ramsey(k + 1, l) + ramsey(k, l + 1). 
It is easy to compute ramsey(3, 3) = 20. In fact, the ramsey number (3, 3) is 6. 
The value of the second quantified variable in Ramsey's theorem is either a 
clique or an independent set. This variable is more difficult but still possible to 
eliminate. Let soIn(V, E, k, l) be the function to replace this variable. Then soln(V, E, k, l) 
must be either a clique of size at least k, or an independent set of  size at least l. 
To distinguish these two cases, we introduce a Boolean function flag(V, E, k, l), 
such that if flag(V, E, k, l) is true, then soln(V, E, k, l) is a clique of (V, E), otherwise, 
soln(V, E, k, l) is an independent set of (V, E). 
The definitions of flag and soln follow closely the previous proof of Ramsey's 
theorem, and need two auxiliary functions: 
9 S(v, V, E) returns a subset S c V such that for each vertex u ~S, (v, u) q~E. 
9 T(v, V, E) returns a subset T_c V such that for each vertex u ET, (v, u) ~E. 
The reader should notice that S(v, V, E) and T(v, V, E) correspond to the sets 
S and T, respectively, in the previous proof of the Ramsey theorem. 
DEFINITION 2.2 
flag" vertices x edges x number x number ~ bool 
f lag(~, E, k, l) = true ; 
flag({v} u V,E,O,I) = true; 
flag({v} u V, E, k + 1, 0) = false; 
flag({v} u V, E, k + 1, l + 1) 
flag(S(v, V, E), E, k + 1, l) 
= flag(T(v, V, E), E, k, l + 1) 
if IS(v, V, E) I > ramsey(k + 1,/); 
if IT(v, V, e)  l >- ramsey(k, t + 1). 
DEFINITION 2.3 
: soln 9 vertices x edges • number • number ~ set 
The intended meaning of flag is that, if flag(V, E, k, l) is true, soln(V, E, k, l), 
to be defined below, will retum a clique of (V, E); otherwise, soln(V, E, k, l) will 
return an independent set o f  (V, E) (this property will be proved later by our 
prover). 
388 H. Zhang, G.X. Hua, Proving Ramsey' s theorem 
soln(r E, k, l) = ~ ; 
soln(V, E, O, l) = ~ ; 
soln(V, E, k, O) = 0 ; 
soln({v} u V, E, k + 1, l + 1) 
Ssoln(S(v, v, E), k + 1, l) if flag(S(v, V, E), k + 1, l), 
[soln(S(v, V, E), k + 1, l) u {v} otherwise, 
where IS(v, V, E,)I > ramsey(k+ 1,/); 
soln({v} u V, E, k + 1, l + 1) 
= ~soln(T(v, V, E), k, 1 + 1) u {v} i f  flag(T(v, V, E), k, l + 1), 
[soln(T(v, V, E), k, l + 1) otherwise, 
where IT(v, V, E,)I >- ramsey(k, l + 1). 
The above two functions imitate exactly the construction used in the proof 
of Ramsey's theorem. 
Using ramsey(k, l) for n, soln(V, E, k, l) for W, the original theorem can be 
stated as follows: 
V(k, l, V, E) ( [ V I > ramsey(k, l)) =~ ((soln(V, E, k, l) ~ V) A 
( ( ( I soln( V, E, k, l) l >- k) ^  c lique( soln(V, E, k, l), E) ) v 
(( [ soln(V, E, k, l) [ > 1) A indep(soln(V, E, k, l), E)))). 
The above formulation of Ramsey's theorem is suitable for a theorem prover to 
attack. 
3. Inductive theorem proving in RRL 
In this section, we will give an informal presentation f the cover set induction 
method as implemented in RRL; this presentation will serve as a tutorial of the 
method. Along the presentation, we will highlight the differences between our 
method and BMTP. For a complete proof of Ramsey's theorem using BMTP, the 
reader may refer to [1]. 
In addition to the cover set induction method, RRL also supports the so-called 
"inductionless induction" approach [19, 13]. RRL has two different methods 
implementing the inductionless induction approach: the test set method [15] and the 
method using ground-reducibility [ 12], In RRL, the input to these different inductive 
methods are essentially the same; thus, it will be an advantage to understand the 
H. Zhang, G.X. Hua, Proving Ramsey's theorem 389 
cover set induction, if the reader is familiar with the inductionless induction approach. 
Because the two methods implemented in RRL cannot handle conditional equations, 
they cannot be used to prove Ramsey's theorem. If these two methods are extended 
with the techniques proposed by Kounalis and Rusinowitch [18], we may prove 
Ramsey's theorem using the inductionless induction approach. 
3.1. DATA TYPES 
In the formulation of Ramsey's theorem, several data types are involved: 
Boolean, natural numbers, vertices, edges, and sets. 
Only Boolean is built-in in RRL. To create new data types, the user may 
declare constructors for each new sort. For instance, the constructors could be 0 and 
suc (successor) for natural numbers, and null and cons for lists. These constructors 
can be declared as tree constructors, just in the same way as Huet and Hullot did 
in their implementation f the inductionless induction method [11 ].1! 
Intuitively, the terms built on constructors (called constructor terms) represent 
values of the given sort. When an equational specification is sufficiently complete 
[10], it is known that these constructor terms represent exactly the values of the 
initial model of the specification [9]. 
In BMTP, there are several built-in data types: Boolean, natural numbers, 
lists, literal atoms, and integers. These types are defined by the so-called shell 
principle [3], which plays a similar role as declaring free constructors. Similarly, 
the constructor terms are called explicit values in the Boyer-Moore logic; the 
validity of theorems are defined with respect o these explicit values. 
For Ramsey's theorem, each vertex will be represented by a natural number. 
Each edge will be represented by a pair of natural numbers; we use mkpair: hum, 
hum -> pair as the sole constructor for pairs. A set will be represented by a list. 
We will use list operations to replace correspondent set operations, uch as replacing 
0 by null, {x} u W by cons(x, W) and x ~ W by member(x, W). To ensure that the 
number of elements in a set is the same as the length of the corresponding list, we 
have to make sure that every element in the list is distinct. An undirected graph is 
represented by a pair (V, E), where V is a list of numbers and E is a list of pairs 
of numbers uch that if (x, y) E E, then (y, x) E E. 
Using this representation a d the function flag defined previously, Ramsey's 
theorem is stated as the following four formulas (setp(X) returns true iff every 
element in the list X is distinct): 
9 Goal 1: soln(V, E, k, l) c_ V. 
9 Goal 2: If setp(V), then setp(soln(V, E, k, l)). 
~)RRL also accepts non-free constructors, i.e. it allows equational relations between constructor terms; 
such relations are needed for def'ming integers, for example. For Ramsey's theorem, only free constructors 
are used. 
390 H. Zhang, G.X. Hua, Proving Ramsey's theorem 
Goal 3: If flag(V, E, k, l), then clique(soln(V, E, k, 1)), else indep(soln(V, E, k, l)). 
Goal 4: Suppose I VI -> ramsey(k, l). If flag(V, E, k, l), then I soln(V, E, k, l) I > k, 
else I soln(V, E, k, l) I > _ l. 
3.2. FUNCTION DEFINITIONS 
Defining functions in RRL is simple. For instance, ramsey of definition 2.1 
can be input to RRL as follows: 
[ramsey :num, num-> num] 
ramsey(O, y) := suc(O) 
ramsey(x, O) :-- suc(O) 
ramsey(suc(x), suc(y)) := ramsey(suc(x), y) + ramsey(x, suc(y)) 
The first line gives the arity of ramsey and suc(x) means x + 1. The symbol : = is 
required for equations defining a recursive function; this symbol is optional to 
nonrecursive function definitions. Note that RRL considers all identifiers starting 
with a letter in { u..z,  U. .7 } as variable names. 
The following two properties are required for equations defined by the 
symbol :=; the soundness of the cover set induction principle relies on these two 
properties: 
(1) They can be made (from left to right) into terminating rewrite rules. 
(2) They completely define the operator over the constructor terms (i.e. they 
guarantee the sufficient completeness of the specification). 2) 
In RRL, the default ordering used to orient equations is Dershowitz's Recursive 
Path Ordering [7]. Each of the equations involved in this experiment can be automatically 
made into a terminating rule by this ordering. 
Because of the second requirement (property 2), the definitions of flag and 
soln in the previous section are not acceptable by RRL, because RRL cannot prove 
that 
( IS(o, V, E) I > ramsey(k + 1, l)) v ( IT(v, V, E) I > ramsey(k, l + 1)) 
is true for every graph (V, E). In fact, the above disjunction is true under the 
condition I vI -> ramsey(k + 1, l + 1), which is not present in the definitions of flag 
and soln. However, we may define flag and soln as follows (to improve the readability, 
we will use u, v for vertices, V or W for vertex set, and Z for edge set): 
2)RRL allows partially defined functions. If a function is not completely defined, their definition 
equations will not be used by the cover set induction for generating induction schemes. In addition 
to partial functions, our requirements on definitions is less restricted than Huet-Hullot's definition 
principle [11 ] in two aspects: (1) relations between constructors are allowed; (2) conditional equations 
are  allowed. 
H. Zhang, G.X; Hua, Proving Ramsey's theorem 391 
[flag'list, list, num, num-> bool] 
flag(null, Z, x, y) := true 
flag(cons(v, W), Z, O, y) := true 
flag(cons(v, W), Z, suc(x), O) "= false 
flag(cons(v, W), Z, suc(x), suc(y)) := 
cond((length(S(v, W, Z)) >= ramsey(suc(x), y)), 
flag(S(v, W, Z), Z, suc(x), y), 
flag(T(v, W, Z), Z, x, suc(y))) 
[soin 9 lis t, list, num, num-> list] 
soin(null, Z; x, y) := null 
soln(cons(v, W), Z, O, y) "= null 
soln(cons(v, W), Z, suc(x), O) "= null 
soln(cons(v, W), Z, suc(x), suc(y)) := 
cond((length(S(v, W, Z)) >= ramsey(suc(x), y)), 
cond(flag(S(v, W, Z), Z, suc(x), y), 
soin(S(v, W, Z), Z, suc(x), y), 
cons(v, soln(S(v, W, Z), Z, suc(x), y))), 
cond(flag(T(v, W, Z), Z, x, suc(y)), 
cons(v, soln(T(v, W, Z), Z, x, suc(y))), 
soln(T(v, W, Z), Z, x, suc(y)))) 
where cond is a predefined function which satisfies 3) 
[cond : bool, univ, univ -> univ] 
cond(true, x, y) := x 
cond(false, x, y) := y 
The reader may compare the above definitions of flag and soln with definitions 2.2 
and 2.3. 
RRL can prove automatically that the above definitions of flag and soln are 
completely defined (see [I4] fo the method used). These definitions can be used in 
the proof of Ramsey's theorem, because the condition 1Vl --- ramsey(k + 1, 1 + 1) is 
present in Ramsey's theorem, and in this case, --,( I S(v, V, E) I >- ramsey(k + 1, l)) 
implies I T(v, V, E) 1 > ramsey(k, l + 1). 
In BMTP, a definition is a Lisp-like function.. For instance, the function 
ramsey is defined as follows: 
(defn ramsey (p q) 
(if (zerop p) 
1 
(if (zerop q) l (plus (ramsey (sub1 p) q) (ramsey p (sub1 q)))))) 
3)The definition of cond is similar to that of if in the Boyer-Moore logic. 
392 H. Zhang, G.X. Hua, Proving Ramsey' s theorem 
To ensure the termination of the function, the prover has to prove (sometimes with 
the user's hint) that the arguments of the function always decrease, under a predefined 
semantics ordering, during the recursive calls. This is the requirement of the definition 
principle. 
We point out that the soundness of both the Boyer-Moore induction principle 
and the cover set induction principle relies on well-founded orderings. These well- 
founded orderings are exactly those used in ensuring the termination of function 
definitions. The major difference between the two is that the well-founded ordering 
used in BMTP is a semantic ordering. For example, x is greater than sub1 (x) when 
x is greater than 0, even though x is a subterm of sub1 (x). For the cover set 
induction principle, the induction is done on reduction ordering which contains the 
subterm relation and can be constructed by many syntactic methods (see [7] for a 
survey). 
3_3. ORGANIZATION OF PROOF TECHNIQUES 
The organization of proof techniques in RRL resembles that of BMTP. The 
following six major proof techniques, as described in [4], are used by BMTP: 
(l) Simplification: acombination ofdecision procedures for propositional calculus, 
equality, and linear arithmetic, and term rewriting; 
(2) Destructor elimination: the trading of "bad" for "good" terms; 
(3) Cross-fertilization: the heuristic use and elimination of equality hypotheses; 
(4) Generalization: the adoption of a more general goal obtained by replacing 
some terms by new variables; 
(5) Elimination of irrelevance: the discarding of apparently unimportant 
hypotheses; and 
(6) Induction. 
Each of the above techniques i implemented as a process, which takes a formula 
as a goal and yields a set of formulas as subgoals. The goal is provable if each of 
the subgoals is. 
A similar set of proof techniques are implemented in RRL: 
(1) Simplification: a combination of the consistency checking procedure and the 
"contectual rewriting" [21] (which subsumes the conventional conditional 
rewriting and Boyer-Moore's cross-fertilization); 
(2) Case-split: a transformation of the formula Pl A P2 if C into/'1 if C and P2 
if C, and the formula P(cond(X, Y, Z)) into P(Y) if X and P(Z) if ~X; 
(3) Generalization: a combination ofBoyer-Moore's generalization and elimination 
of irrelevance; and 
(4) Induction: the cover set induction method reported in [22]. 
H. Zhang, G.X. Hua, Proving Ramsey's theorem 393 
The most significant idea we leamed from BMTP is that when proving a 
conjecture, cover sets can be automatically obtained from the definitions (as a set 
of equations) of the functions appearing in the conjecture. Because ach definition 
gives a different cover set, thus gives a different induction scheme, we used a 
(heuristic) numeric function to choose the functions appearing in the conjecture. 
Many heuristics developed in BMTP are integrated into this numeric function. Our 
experiments show that the cover sets constructed by this numeric function are very 
successful for proving many conjecture (the success ratio is about 99% or 790/800). 
In the following, we present a complete xample of the cover set induction method. 
3.4. AN EXAMPLE OF THE COVER-SET INDUCTION 
Suppose the "greater_than_or_equaLto" relation > on natural numbers is defined 
as" 
[>= :num,  num -> bool] 
x >= 0 := true 
0 >= suc(y) := false 
suc(x) >= suc(y) := x >= y 
We input the above definition to RRL and let it prove suc(x) >= y if x >= y. The 
following is quoted from the script of RRL. 
Rule [3] (x >= O) ---> true (* three rewrite rules made from definition of >= *) 
Rule [4] (0 >= suc(x)) ---> false 
Rule [5] (suc(x) >= suc(y)) ---> (x >= y) 
RRL -> prove suc(x) >= y if x >= y (* theorem to prove *) 
Let P(x, y) be [main] (suc(x)>= y)== true if (x >= y). 
The induction will be done on x, y in (x >= y), and will follow the scheme: 
[#1] P(x,0) 
[#2] P(0, suc(y)) 
[#3] P(suc(x), suc(y)) if {P(x, y)} 
By rule [3], [#1] is reduced to true. 
By rule [4], [#2] is reduced to true. 
Conjecture [#3] is split into: 
[#3.1] (suc(suc(x)) >= suc(y)) if ((suc(x) >= suc(y))) and (not((x >= y))) 
[#3.2] (suc(suc(x)) >= suc(y)) if ((suc(x) >= suc(y))) and ((suc(x) >= y)) 
By rule [5], [#3.1] is reduced to true. 
By rule [5], [#3.2] is reduced to true. (* the induction hypothesis is used in this proof. *) 
All subgoals of [main] are proved, hence it is an inductive theorem. 
Add Rule: [48] (suc(x) >= y) ---> true if (x >= y) 
394 H. Zhang, G,X. Hua, Proving Ramsey's theorem 
RRL made three rewrite rules, [3], [4] and [5], from the definition of >=. Then 
it detected the completeness of >=.S ince >= is a total function, RRL used its 
definition to formulate the induction scheme. The completeness of >= suggests  
that the finite set, consisting o f  the left-hand sides o f  definition equations, 
{(x >= 0), (0 >= suc(y)), (suc(x) >= sue(y))} is a cover set of the  inf inite set 
{(x >-- y) I x, y are natural numbers}. The right-hand side of the third equation in the 
definition of >=, i.e. (x >= y), indicates the format of induction hypothesis. Those 
lead to the above induction scheme, i.e. subgoals [#1], [#2] and [#3]. [#1] and [#2] 
are the basis cases, which are easy to prove by rule [3] and rule [4]. [#3] is the 
inductive case. 
To prove subgoal [#3], RRL needs to prove suc(suc(x))>= suc(y)if suc(x) 
>= suc(y) under the induction hypothesis suc(x) >= y if x >= y. Because a conditional 
equation E if C is equivalent to the formula ~ C v E, the induction hypothesis is 
split into two cases, not(x >= y) and suc(x) >= y. So RRL split [#3] into [#3.1] and 
[#3.2], and proved them by rule [5]. The proofs of [#1], [#2], [#3.1] and [#3.2] lead 
to a successful proof of suc(x) >= y if x >= y. Finally, the proved theorem is translated 
into a rewrite rule, which is added to the system for proving other theorems. 
4. A proof of Ramsey's theorem by RRL 
The input to RRL which led to the successful proof of  Ramsey's theorem 
includes 13 definitions, 19 lemmas and 4 goals, The 13 definitions include ramsey, 
flag, soln, as we have shown in section 3,2, and auxiliary functions, such as T(v, W, Z), 
S(v, W, Z), clique(V, Z) and indep(V, Z). The reader may refer to the appendix for 
details. The 19 lemmas must be proved before the goals. These lemmas are "discovered" 
in the process of proving the main goals. That is, if a goal cannot be proved during 
the first try, we look at the transcript of the prover and find out why it failed. We 
then design a lemma to take care of the failure case. This lcmma is then tried; if 
it succeeds, we try the main goal again; otherwise, we may need another lemma to 
support he proof of the current lemma, or wc may need a different lemma. In this 
way, we "trained" the prover to find the correct paths toward the goals by providing 
those lemmas. The transformation from the reformulated Ramsey theorem in section 
3.1 to the formulas acceptable for RRL is straightforward. The following arc the 
four goals, which correspond to Goals 1 -4  in section 3.1, for RRL to prove. 
Goal 1: subsetp(soln(V, Z, x, y), V) 
Goal 2: setp(soln(V, Z, x, y)) if setp(V) 
Goal 3: cond(flag(V, Z, x, y), 
clique(soln(V, Z, x, y), Z), indep(soln(V, Z, x, y), Z)) 
Goal 4: cond(flag(V, Z, x, y), 
(length(soln(V, Z, x, y)) >= x), 
(length(soln(V, Z, x, y)) >= y)) if (length(V) >= ramsey(x, y)) 
In the following sections, we explain how Goals 1 -4  are proved in RRL. 
H. Zhang, G.X. Hua, Proving Ramsey' s theorem 395 
4.1. PROOF OF GOAL 1 
In order to prove Goal 1 by the cover set induction, RRL denoted Goal 1 as 
P(V, x, y) and chose the definition of soln to formulate the induction scheme. This 
is shown in fig. 1, which is quoted from the script o f  RRL. 
RRL -> prove subsetp(soln(V, Z, x, y), V) 
Let P(V, x, y) be [main] subsetp(soln(V, Z, x, y), V) 
The induction will be done on V, x, y in soln(V, Z, x, y), and will 
follow the scheme: 
[#1] P(null, x, y) 
[#2] P(cons(v, W), O, y) 
[#3] P(cons(v, W), suc(x), O) 
[#4] P(cons(v, W), suc(x), suc(y)) if 
{ P(split(v, W, Z, false), suc(x), y), 
P(split(v, W, Z, true), x, suc(y)) } 
Fig. 1. The cover set induction scheme for Goal 1. 
The first attempt o prove Goal 1 failed. The output of RRL suggests (to an 
experienced eye) that the following lemmas are needed: 
Rule [49] 
Rule [53] 
Rule [55] 
subsetp(x, cons(y, z)) ---> true if { subsetp(x, z) } 
subsetp(X, Y) ---> true if { subsetp(X, Z), subsetp(Z, Y) } 
subsetp(split(u, V, Z, xf), V) ---> true 
where rule [49] is xEZ=:~xE {y} uZ,  rule [53] is X~Z^Z~Y=~X~ Y, and 
rule [55] is split(u, V, Z, x f )c  V. After successfully proving the  above lemmas, 
Goal 1 can be proved automatically; [#1] is trivial, [#2] and [#31 are reduced to true 
by rule [49], and [#4] is reduced to true by rules [49], [53] and [55]. After all subgoals 
are proved, Goal 1 is assumed to be true and converted into rule [61]. 
We would like to discuss the correctness of the machine-generated in uction 
scheme. Let us consider a mathematical induction proof of P(V,x, y). The induction 
on V, x and y can be nested as in fig. 2. 
It is easy to prove [#1] =~ [a], [#2] ~ [b.a], [#3] =~ [b.b.a] and [#4] ~ [b.b.b]. 
We would like to illustrate how [#41 =~ [b.b.b]. [b.b.b] is 
P(cons(v, W), x + 1, y + 1) if (P(W, x + 1,y + 1) ^  Q(x, y + 1) ^  R(x + 1, y)). 
I t  suffices to show 
P(cons(v, W), x + 1, y + 1) if P(W, x + 1, y + 1) A [# 4]. 
S ince I WI >-- I split(v, W, Z, x f )  l, both P(split(v, W, Z, false), x + 1, y )  and 
P(split(v, W, Z, true), x, y + 1) are true by P(W;x + 1, y+ 1). The if part of [#4] is 
396 H. Zhang, G.X. Hua, Proving Ramsey' s theorem 
{Prove P(V, x, y) by induction on V: } 
Basis case: IVl= 0; i.e. V is null. 
[a] P(null, x, y) 
Inductive ease: IVl = k+ 1; i.e. V= cons(v, W) 
[b] P(cons(v, W), x, y) if P(W, x, y) 
{Let [b] be Q(x, y), prove it by induction on x: } 
Basis case: x = 0; 
[b.a] Q(0, y) 
Inductive ease: x= x + 1; 
[b.b] Q(x + 1, y) if Q(x, y) 
{Let [b.b] be R(x+ 1,y), prove it by induction on y: } 
Basis case: y = 0; 
[b.b.a] R(x + 1, O) 
Inductive case: y = y + 1; 
[b.b.b] R(x + 1, y + I) if R(x + 1, y). 
Fig. 2. Nested formal induction schemes for Goal 1. 
true, so that P(cons(v, W), x + 1, y + 1) is true. This shows that the subgoals generated 
by the cover set induction scheme, as shown in fig. 1, imply the corresponding ones 
generated in fig. 2 by the formal induction scheme. Therefore, the machine-generated 
scheme is valid. 
4.2. PROOF OF GOALS 2 -4  
Each of Goals 2-4 contains the function soln. RRL chose soln to formulate 
the same induction scheme as in the proof of Goal 1 for each of them, so that the 
proofs of Goals 2 -4  are similar to that of Goal 1. 
For Goal 2, firstly, three additional lemmas are proved. They are: 
Rule [51] member(u, split(v, W, Z, xf)) ---> false if 
{ not(member(u, W)), subsetp(split(v, W, Z, xf), W)} 
Rule-[52] member(u, soln(V, Z, x, y)) ---> false if 
{not(member(u, V)), subsetp(soln(V, Z, x, y), V)} 
Rule [60] setp(split(u, V, Z, xf)) ---> true if { setp(V) } 
Secondly, let setp(soln(V, Z, x, y)) == true if setp(V) be P(V, x, y), Goal 2 is broken 
into four subgoals by RRL in the same way as shown in fig. 1. Because null is 
defined as the empty set, subgoals [#1], [#2] and [#3] of Goal 2 are trivially true. 
With the help of rules [51], [52],[55], [60] and [51], subgoal [#4] of Goal 2 is reduced 
to true. 
RRL used the same strategies and procedures to prove Goal 3 and Goal 4. For 
the formula cond(C, A, B), RRL will automatically split it into two subgoals, A if C 
and B i f~C.  Since both Goals 3 and 4 are of the form cond(x, y, z), RRL splits each 
of them into two subgoals, then applies the cover set induction on the subgoals. 
H. Zhang, G.X. Hua, Proving Ramsey' s theorem 397 
For instance, Goal 3, 
cond(flag(V, Z, x, y), homoset(soln(V, Z, x, y), Z, true), 
homoset(soln(V, Z, x, y), Z, false)), 
is split into the following two cases: 
[#1] homoset(soln(V, Z, x, y), Z, true) == true if flag(V, Z, x, y) 
[#2] homoset(soln(V, Z, x, y), Z, false)== true if not(flag(V, Z, x, y)) 
RRL decomposed [#1] and [#2] into four subgoals, respectively, in the same way as 
we have shown in fig. 1. We quote the script of RRL below. 
Let P(V, X, Y) be 
[#1] homoset(soln(V, Z, x, y), Z, true) == true if flag(V, Z, x, y) 
The induction will be done on V, x, y in soln(V, Z, x, y), and will follow the scheme: 
[#1.1] P(null, x, y) 
[#1.2] P(cons(v, W), O, y) 
[#1.3] P(cons(v, W), sue(x), O) 
[#1.4] P(cons(v, W), sue(x), sue(y)) if 
{ P(split(v, W, Z, false), sue(x), y), 
P(split(v, W, Z, true), x, suc(y))} 
, , . . ~ 9 
Let P(V, x, y) be 
[#2] homoset(soln(V, Z, x, y), Z, false) == true if not(flag(V, Z, x, y)) 
The induction will be done on V, x, y in soln(V, Z, x, y), and will follow the scheme: 
[#2.1] P(null, x, y) 
[#2.2] P(cons(v, W), O, y) 
[#2.3] P(cons(v, W), sue(x), O) 
[#2,4] P(cons(v, W), sue(x), sue(y)) if 
{ P(split(v, W, Z, false), sue(x), y), 
P(split(v, W, Z, true), x, sue(y))} 
All of the basis cases of subgoals [#1.] and [#2] are easy to prove by referring to 
corresponding definitions. The proofs of two inductive cases, [#1.4] and [#2.4], need 
rule [61] (Goal 1) and the following two lemmas: 
Rule [58] homo(u, soln(split(u, V, Z, xf), Z, x, y), Z, xf)- - -> true if 
{ subsetp(soln(split(u, V, Z. xf), Z, x, y), split(u, V, Z, xf)), 
homo(u, split(u, V, Z, xf), Z, xf) } 
Rule [59] homo(u, split(u, V, Z, xf), Z, xf) ---> true. 
RRL proved the above two lemmas and Goal 1 first, and then succeeded on Goal 3. 
In order to prove Goal 4, rules [581, [59], [61] and the following two lemmas 
about length are needed. 
398 H. Zhang, G2(. Hua, Proving Ramsey' s theorem 
Rule [44] (length(S(u, V, Z)) >= ramsey(suc(x), y)) ---> true if 
(suc(length(S(u, V, Z)) + length(T(u, V, Z))) >= ramsey(suc(x), suc(y))) and 
not(length(T(u, V, Z)) >= ramsey(x, suc(y))) 
Rule [48] length(S(u, V, Z)) + length(T(u, V, Z)) ---> length(V) 
The rest of the proof of Goal 4 is very similar to that of Goal 3 and is omitted here. 
5. Comparison with the Boyer-Moore theorem prover 
The Boyer-Moore theoreme prover (BMTP) is one of the most successful 
theorm provers existing today. The BMTP has been used to prove many impressive 
theorems and to verify large computer systems (see [5] for an overview). Boyer and 
Moore have been remarkably successful at designing heuristics for automating 
theorem proving, and the BMTP is poised on a delicate balance point between 
logical strength and theorem proving power. 
The major difference between the cover set method and Boyer and Moore's 
logic is that our axioms are in equational form, while theirs are in Lisp-like functional 
form. We have said in section 3 that the Boyer-Moore logic consists of primarily 
three principles: 
9 Shell principle: corresponds to the constructor declaration in an algebraic 
specification; 
9 Definition principle: corresponds toour requirement that each function defined 
by a set of equations must have the property of sufficient completeness; 
9 Induction principle: its soundness corresponds to our requirement that the 
set of equations defining a function can convert into a set of terminating 
rewrite rules. 
These differences are not profound and, in particular, as we mentioned before, the 
most significant idea we learned from the BMTP is that an induction scheme can 
be constructed from the definition of a function appearing in a conjecture to be 
proved. This is also the basic common point in the use of the two induction principles. 
In addition, there are many similarities in using heuristics and techniques to support 
the induction principle. 
These similarities also reflect in the proofs of Ramsey's theorem. For instance, 
some of the definitions and lemmas are used in both Kaufmann's proof and our 
proof. We said in section 2 that the proof of Ramsey's theorem consists of two parts: 
(i) construction of a solution, and (ii) correctness of the constructed solution. For (i), 
most work is done by the user and is provided to the provers in the form of function 
definitions. For (ii), most work is done by the provers and consists of a sequence of 
lemmas. For this reason, our comparison is mainly on the second part. Table 1 
provides the statistics of three theorem provers on Ramsey's theorem (the data for 
BMTP and Nuprl are taken from [1]), and we discuss them shortly. 
H. Zhang, G.X. Hua, Proving Ramsey's theorem 399 
Table 1 
The comparison statsitics. 
BMTP Nuprl RRL 
# Tokens 933 972 966 
# Definitions 10 24 13 
# Lemmas 26 25 23 
Replay time 3.7 min 57 min 0.14 min 
9 number o f  tokens, definitions and lemmas: The number of tokens is the total 
number of identifiers in the input file. The number of lemmas includes the final 
goals of Ramsey's theorem. From table 1, we can see that approximately the same 
number of lemmas were used for these proofs. 
The numbers presented in the table, as with many metrics, are potentially misleading; 
see [ 1 ] for good arguments. For instance, in RRL, the number of lemmas could 
be reduced by merging two lemmas together with an "and". 
Note that the decision procedure for linear arithmetics i not used in RRL. In other 
words, definitions and lemmas about + and >= could have been saved if such 
a decision procedure was used. Altogether, it could have saved 2 definitions, 5
lemmas and 141 tokens. 
9 automatic power: RRL proves all the 23 lemmas (including 4 goals) automatically 
without any user assistance (however, it is the user's responsibility to design 
"smart" lemmas). In contrast, BMTP needs several user's hints to carry out the 
whole proof. Some of these lemmas, like the transitivity of subsetp, contain 
variables which appear only in the condition of the lemma. Without the user's 
hint, BMTP cannot use them as rewrite rules. In RRL, we have a special procedure 
to handle this case. Of course, the automatic use of these lemmas is not cost-free: 
we had to input some instances of these lemmas as bridge lemmas. In this 
experiment, we used 5 bridge lemmas (rules [44], [51], [52], [54] and [58] in 
appendix A), which accounts for 128 tokens (see appendix B for a complete 
example of using bridge lemmas). Had we given more detailed instructions to 
RRL (through an interactive interface), these bridge lemmas could have been 
saved. 
replay time: Replay time is the total CPU time to execute all the input commands 
after a complete input file is available. The time for BMTP is measured on a 
Sun 3/60. (For Nuprl, it is measured on a Symbolics 3670 Lisp machine.) For 
RRL, it is measured on aSun Sparcstation 1. Both BMTP and RRL run in AKCL 
with 16 megabytes of main memory. RRL needs less that 8 seconds of replay 
time. If we count in the difference of the machines (Sparcstation 1 is about three 
times faster than Sun 3/60), RRL is still faster than BMTP on this example. When 
400 H. Zhang, G.X. Hua, Proving Ramsey's theorem 
using BMTP as weU as RRL, lemmas are usually "discovered" uring the process 
of proving a conjecture. That is, the user lets the prover prove the conjecture; if
is fails, the user then reads the transcript of the prover and then designs a lemma 
which would take care of the failure case. After the lemma is proved, the user 
then proves the conjecture again. For small problems uch as Ramsey's theorem, 
short replay time does not make a difference. Suppose we are proving a problem 
which needs everal hours of replay time; shorter eplay time certainly means that 
the user can try more cases in the same amount of time, thus it increases the 
user's productivity. 
9 programming facility: BMTP (as well as Nuprl) has strong connections with 
programming. The functions in BMTP can be complied into Lisp functions and 
executed efficiently. In contrast, RRL uses only rewriting for computing; it is 
very inefficient since we have not put any effort into this aspect. An alternative 
is to use O'Donnell's equational logic for computing [20]. The reader may check 
that the equational definitions we used for Ramsey's theorem satisfy the requirement 
of O'Donnell's ystem. 
9 readability o_fproofs: Due to the undecidable nature of the domain of applications, 
it is very difficult to mechanize inductive theorem proving to as great a degree 
as first-order theorem proving. Thus, issues such as the readability of proofs and 
the ease of discovering lemmas and carrying proofs become important to the 
success of the provers. However, because of the expertise involved in using such 
provers, it is almost controversial tosay one theorem prover is easier than another 
to use. We only remark here that RRL uses the algebraic specification, which is 
a multi-type language suitable for inductive reasoning, and today there exist 
dozens of programs supporting algebraic specifications. Excluding the five arithmetic 
lemmas and five bridge lemmas, RRL uses only thirteen lemmas, while BMTP 
uses twenty-six lemmas, in the proof of Ramsey's theorem. We think this difference 
is partially due to the use of algebraic specifications. 
9 user interface: In addition to the hint facility provided by BMTP, Kaufmann was 
very successful in building an interactive interface on the top of BMTP [17]. 
Inspired by his work, we have built a proof manager in RRL. The manager 
dynamically maintains the proof tree of the current ask. Each node of the tree 
is marked by a subgoal (the root is marked by the goal) and the link to its parent 
is marked by the inference rule which derived that subgoal from its parent, If a 
proof is completed successfully, the use may refer to its proof tree to see how 
the proof is obtained. When a proof fails, the user may backtrack along some 
branch of the proof tree to any node and re-try that step with hints from the user 
and using some special techniques provided by the proof manager. This gives the 
user the entire flexibility from a step-by-step manual proof to a non-stop automatic 
proof. In fact, when we started to work on Ramsey's theorem, RRL could not 
prove these equations automatically; i t was proved semi,automatically with the 
H. Zhang, G.X. Hua, Proving Ramsey' s theorem 401 
assistance of the proof manager. The semi-automatically generated proof inspired 
us to add some new techniques (such as the technique of automatically using 
induction hypotheses as described in [25] and the use of bridge Iemmas as 
described previously) to increase the automatic power of RRL; finally, we were 
able to obtain an automatic proof. 
While BMTP has been used extensively by the Boyer-Moore group in the past 
decade, our experiments on the cover set induction are thus far very limited. However, 
even from our limited experience, the method appears to have considerable 
potential. 
9 Our method has a close relationship with the Boyer-Moore logic, and many of 
the theorems proved by BMTP can be reproduced in RRL; Ramsey's theorem 
is just one of these examples. 
9 The language we used is the language of multi-sort equational specifications, 
which is very popular among computer scientists. The simple nature of this 
language makes our method quite accessible to a wider audience. 
9 We have implemented the cover set induction in Rewrite Rule Laboratory (RRL) 
[ 16], a theorem-proving environment for experimenting with reasoning algorithms 
for equational logic based on rewriting techniques. Many techniques developed 
from the term rewriting approach (see [8] for a survey), such as inductionless 
induction, associative-commutative rewriting, reduction ordering, etc., are readily 
available to us, and could be integrated into the inductive theorem prover. This 
point may be reflected in the short replay time of RRL. 
All in all, we are content o have such a comparison of BMTP and the cover 
set induction method. By providing this comparison, we wish that the people who 
are familiar with the algebraic specification to abstract data types will have a better 
understanding of the Boyer-Moore logic. Most importantly, we have shown the 
great potential of the cover set induction method because of its close relation to the 
Boyer-Moore logic. 
Acknowledgements 
We would like to thank Matt Kaufmann for his assistance with and enthusiasm 
for the work reported here. We also sincerely thank the anonymous referees for their 
helpful comments. 
References 
[1] D. Basin and M. Kaufmann, The Boyer-Moore prover and Nuprl: an experimental comparison, in: 
Proc. BRA Logical Frameworks Workshop (1990). 
[2] J. Bondy and R. Murthy, Graph Theory with Applications (American Elsevier, 1976). 
402 H. Zhang, G.X. Hua, Proving Ramsey's theorem 
[3] R.S. Boyer and J.S. Moore, A Computational Logic (Academic Press, New York, 1979). 
[4] R.S. Boyer and J.S. Moore, A Computational Logic Handbook (Academic Press, New York, 1988). 
[5] R.S. Boyer and J.S. Moore, Overview of a theorem-prover fo a computational logic, in: Proc. 8th 
Int. Confi. on Automated Deduction (CADE-8), Oxford, UK, (1986) (Springer, LNCS 230). 
[6] R.L. Constable et al., Implementing Mathematics with the Nuprl Proof Development System (Prentice- 
Hall, Englewood Cliffs, NJ, 1986). 
[7] N. Dershowitz, Termination of rewriting, J. Symbolic Comput. 3(1987)69-116. 
[8] N. Dershowitz and J.-P. Jouannaud, Rewrite systems, in: Handbook of Theoretical Computer 
Science B: Formal Methods and Semantics, eel. J. van Leeuwen (North-Holland, Amsterdam, 1990) 
chap. 6 pp. 243-320. 
[9] J.A. Goguen, J.W. Thatcher and E.W. Wagner, Initial algebra pproach tothe specification, correctness, 
and implementation f abstract data types, in: Data Structuring, Current Trends in Programming 
Methodology, 4, ed. R.T. Yeh (Prentice-Hall, Englewood Cliffs, NJ, 1978). 
[10] J.V. Guttag and J.J. Homing, The algebraic specification of abstract data types, Acta Informatica 
10(1978)27-~52. 
[11] G. Huet and J.M. Hullot, Proofs by induction in equational theories with constructors, in: 21stlEEE 
Syrup. on Foundations of Computer Science, Syracuse, NY (1980) pp. 96-107. 
[12] J.-P. Jouannaud and E. Kounalis, Proofs by induction in equational theories without constructors, 
ir~ Proc. of Logic in Computer Science Conf., Cambridge, MA (1986). 
[13] D. Kapur and D. Musser, Proof by consistencY, Artificial Intelligence 31(1987)125-157. 
[14] D. Kapur, P. Narendran and H. Zhang, On sufficient completeness and related properties of term 
rewriting systems, Acta Informatica 24(1987)395-415. 
[15] D. Kapur, P. Narendran and H, Zhang, Proof by induction using test sets, Proc. 8th Int. Conf. on 
Automated Deduction (CADE-8), Oxford, UK, 1986 (Springer, LNCS 230) pp. 99-117. 
[16] D. Kapur and H. Zhang, An overview of RRL: Rewrite Rule Laboratory, Proc. 3rd Int. Conf. on 
Rewriting Techniques and 7"heir Applications (RTA-89), Chapel Hill, NC, 1989 (Springer, LNCS 
355) pp. 513-529. 
[17] M. Kaufmann,. An interactive enhancement to the Boyer-Moore theorem prover, in: Proc. 9th Int. 
Conf. on Automated Deduction (CADE-9), Argonne, IL, 1988 (Springer, LNCS 310)pp. 735-736. 
[ 18] E. Kounalis and M. Rusinowitch, Mechanizing inductive reasoning, in: Proc. American Association 
for Artificial Intelligence Conf., Boston (AAAI Press and M1T Press, 1990) pp. 240-245, 
[19] D, Musser, On proving inductive properties ofabstract data types, Proc. 7th Principles of Programming 
Languages, Las Vegas (1980). 
[20] M. O'Donnell, EquatiOnal Logic as a Programming Language (MIT Press, Cambridge, 1985)~ 
[21] H. Zhang and D. Kaput, First-order logic theorem proving using conditional rewrite rules, in: Proc. 
9th Int. Conf. on Automated Deduction (CADE-9), ed. Lusk and Overbeek, Argonne, IL, 1988 
(Springer, LNCS 310) pp. 1-20. 
[22] H. Zhang, D. Kapur and M.S. Krishnamoorthy, A mechanizable induction principle for equational 
specifications, Proc. 9th Int. Conf. on Automated Deduction (CADE-9), Argonne, IL, 1988 (Springer, 
LNCS 310) pp. 250-265. 
[23] H. Zhang, Reduction, superposition and induction: Automated reasoning in an equational logic, 
Ph.D. Thesis, Rensselear Polytechnic Institute, New York (1988). Accepted for publication in the 
series of Lecture Notes in Artificial Intelligence (Springer, Berlin). 
[24] H. Zhang, Implementing contextual rewriting, in: Proc. 3rd Workshop on Conditional Rewriting 
Systems, ed. M. Rusinowitch and J.L. Remy, 1992 (Springer LNCS 656) pp. 363-377. 
[25] H. Zhang and X. Hua, Proving the Chinese remainder theorem by the cover set induction, in: Proc. 
l lth Int. Conf. on Automated Deduction, Saratoga, NY, ed. D. Kaput, 1992 (Springer, LNAI 607) 
pp. 431-445. 
H. Zhang, G.X. Hua, Proving Ramsey's theorem 403 
Appendix A: RRL Input F i le  
for Ramsey's Theorem 
init ; in i t ia l i ze  RRL 
option prove 9 ; choose  cover  set induction 
add ; input var ious  functions 
[0 : num] [SUC : hum -> hUm] 
[null : list] [cons : univ, list -> list] 
[mkpair : univ, univ -> pair] 
[+ : hum, nu~ -> num] 
x + 0 := x ; Rule  [I] 
x + suc(y) := suc(x + y) " Rule [2] 
[>= :num, hUm -> bool] 
x >= 0 := t rue  
0 >= sac(x )  :=  false 
suc(x) >= sue(y) := x >= y 
[length : list -> num] 
; length(x): length of llst x. 
length(null) := 0 ; Rule [6] 
length(cons(x, y)) := suc(len~th(y)) 
; Rule [7] 
[member : unlv, list -> boo l ]  
; member(x, w): true iff x is in v. 
member(x, null) := false ; Rule [8] 
member(x, cons(y, z)) := ; Ru le  [9] 
cond((x = y), true, member(x, z)) 
[ se tp  : list -> bool] 
; setp(~): t rue  iff each of w is distinct. 
se~p(null) := true ; Rule [I0] 
seep(cons(x, y)) := ; Rule [11] 
cond(member(x, y), false, setp(y)) 
[subsetp : list, last -> bool] 
subsetp(u, v): true iff u is a Subset of v. 
subsetp(null, W) := true ; Rule [12] 
subsetp(cons(x, y), W) := ; Rule [13] 
cond(member(x, W), subsetp(y, W), false) 
[isin : bool, univ, univ -> bool] 
; isin(true, x, y)  ~ests membership; 
; isin(false, x ,  y) tes ts  nonmembership, 
isin(true, x, y) := member(x, y) ; Rule [14] 
isin(false, x, y) := ;Ru le  [15] 
not(member(x, y)) 
[split : hum, list, list, bool -> list] 
; split(v, W, Z, true) returns a subse~ of W, 
; such that for any y in the returned subset 
; (v ,  y) is An Z. 
; split(v, W, Z, false) returns a subset of W. 
; such that fo r  any y in the returned subset 
; (v. y) is not in Z. 
split(v, null, Z, xf) := null ; Rule [16] 
split(v, cons(u, W), Z, xf) := ; Rule [17] 
cond(isin(xf, mkpair(v, U) ,  Z ) ,  
cons(u, split(v, W, Z ,  xf)), 
split(v, W, Z, xf)) 
; Rule [3 ]  
; Rule [4] 
; Rule [5] 
; Two abbreviations: 
T(v, W, Z) == split(v, W, Z, true) 
S(v, W, Z) == split(v, W, Z, false) 
; Rule [18] 
; Ru le  [193 
[homo :num, lAst, list, bool -> bool] 
; homo(v. W, Z, true) is true iff there As 
; an edge between v and all y in W. 
; homo(v, W, Z, false) is true if there are 
; no edges between v and any y in W. 
homo(v ,  null, Z, xf) := true ; Rule [20] 
homo(v, cons(u, W), Z, xf) := ; Rule [2i] 
isin(xf, mkpair(v, u) ,  Z) and 
homo(v, W, Z, xf) 
[homoset : list, list, bool ->bool ]  
; homoset(V, Z, true) is true Aff 
; (V, Z) As a complete  s raph ,  
; homoset(Y, Z, false) is t rue  i f~  
; (V, Z) is a null graph. 
homoset(null, Z, xf) := true ; Rule[22] 
homoset(cons(v, W), Z, xf) := ; Ru].e[23] 
homo(v, W, Z, Xf) and homoset(W, Z, xf) 
; Two abbreviations 
clique(V, Z) == homoset(V, Z, true) ; Rule [24~ 
indep(Y, Z) == homoset(V, Z, false) ; Rule [25] 
[rarasey : hum, nam -> num] 
; r~msey(k, I) retu[ns an upper boundof  
; Ramsey's number of (k, I). 
ramsey(O,y) := suc(O) ; Rule [26] 
ramsey(x, O) := suc(O) ; Rule [27] 
ramsey(suc(x), suc(y)) :=  ; Ru le  [28]  
ramsey(suc(x), y) + ramsey(x, suc(y)) 
[flag': last, last, hum, hum -> bool] 
; f lag(V,Z,  k, l) returus true iff 
; soln(V, Z, k, i) i~ a clique, 
; flag(V, Z,  k ,  I) returns false iff 
; soln(V, Z, k, I) is an independent set. 
flag(null, Z, x, y)  := true ; Rule  [29] 
flag(cons(v. W), Z, O, y) := true ; Rule [30] 
flag(cons(v, W), Z, suc(x), O) := false 
; Rule [31] 
flag(cons(v, W), Z, suc(x), sue(y)) := 
cond((length(S(v, W, Z)) >= ramsey(suc(x), 
fla~(S(v, W, Z), Z, suc(x), y), 
fleg(T(v, W, Z), Z, x, sue(y))) 
; Ru le  [32] 
[soln : list, list, nnm, num -> list] 
; soln(V, Z, k, l) returns either a clique 
; or an independent set, 
soln(null, Z, x, y) := null ; Rule [33] 
soln(cons(v, W), Z, O, y) := null ; Rule [34] 
soln(cons(v, W), Z, suc(x), 0 ) :  = null 
; Rule [35] 
soln(cons(v, W), Z, sue(x), sue(y)) := 
cond((length(S(v, W, Z)) >= ramsey(suc(x), yl 
cond(flag(S(v, W, Z), Z, suc(x), y), 
soln(S(v, W, Z), Z, sac(x), y) ,  
cons(v, soln(S(v. W, Z), Z, suc(x), y)] 
cond(flag(T(v, W, Z), Z, x,  sue(y)), 
cons(v, soln(T(v, W, Z), Z, x, suc(y))Z 
soln(T(v, W, Z), Z, x ,  suc(y)))) 
9 Rule [36~ 
] ; end Of  the  definitions 
operator constructor ; declare constructors 
404 H. Zhang, G.X. Hua, Proving Ramsey' s theorem 
0 suc null cons mkpair 
operator precedence 
; set the precedence for the Racursive Path Ordering. 
soln flag S T split subsetp setp indep clique homoset 
homo ramsay length isis member cued >= + 
makerule ; make terminating resrite rhles 
; Prove Various lemmas 
; [37] [38] [41] [43] are lemmas about arithmetics. 
prove ; Rule [37] 
O>=x==x=O 
prove ; Rule [38] 
(y + z) >= x if (y >= x) 
; missin~ rule numbers (li~e [39] and [40]), 
; indicate that intermediate lemmas are created 
; by RRL durln~ its proof process (of  [41]). 
prove ; Rule [41] 
(X >= y)  i~ (SUC(X + U) >= (y + v)) and not(u >= v) 
prove ; Rule [43] 
(y >= suc(x)) == not(x >= y) 
; [44], [46] ~ and [48] are lemmes about properties 
; of "split" and "ramsay". 
prove ; Rule [44], an ~nstance o~ [413. 
(len~th(S(u, V, Z)) >= ramsay(sic(x), y)) if 
.-(suc(length($(u, V,~ Z)) + length(T(u, V, Z))) >= 
ramsey(suc(x)~ suc(y)>) and 
no~(length(T(u, V, Z)) >= ramsay(x, sue(y))) 
y ; confirmation is needed when retaining 
; an instance Of an existing rule 
prove ; Rule [46] 
not(O >= ramsey(x,  y))  
prove ; Rule [48]: 
leng~h(S(u, V, Z)) + length(T(u, V, Z)) == 
length(V) 
; [49]--[55] are lemmas about "subsetp". 
prove ; Rule [49] 
subsetp(x, cons(y, z)) if subsetp(x, z) 
prove ; Rule [$0] 
not member(x, z) iT 
not member(x, y)  and subsetp(z, y) 
prove ; Rule [51] ,  an instance Of [50] .  
not member(u, split(ul, V, Z, xf)) if 
not(member(u~ V)) and 
subsetp(sp l i t (u l ,  V, Z, x f ) ,  V) 
Y 
prove ; Rule [52], an instance of  [SO]. 
not member(u, soln(V, Z, x, y)) i f  
not(member(u, V)) and 
subsetp(soln(V, Z, x, y), V) 
Y 
prove ; Rule [53], 'the transitiv'e law. 
subsetp(x ,  y) i f  
subsetp(x ,  z) and subsetp(z ,  y)  
prove ; Rule [54], an instance of [$3] 
subsetp(soln(split(ul, V, Z, xf), Z, x, y), 
cons(s, V)) if 
subsetp(solo(split(ul, V, Z~ Xf), Z, x, y), 
split(ul, V, Z, xf)) and 
subsetp(split(ol, V, Z, xf), COnS(u, V)) 
Y 
; [55]-[60] show Chat "split" an4 "homo" 
; have some desired properties~ 
prove ; Rule [55] 
subsetp(sp l i t (u ,  V, Z, xf), V) 
prove ; Rule [56] 
i s in (xT ,  mkpair(v,  o ) ,  Z) i f  
homo(v, W, Z, Xf) and member(u, W) 
prove ; Rule [57] 
; I f  u i s  (d i s )connected  to all nodes of  V, 
; then u is (d is )connected ~O all nodes of 
; any subset of V. 
homo(u, N, Z, Xf) if 
homo(u, V, Z, Xf) end subsetp(W, V) 
prove ; Rule [58] ,  an instance of [57]. 
homo(u, soln(split(u, V, Z, xf), Z. x. u Z, 
homo(u, split(u, V, Z~ xf), Z, xf) and 
subsetp(soln(split(u, V, Z, xf), Z ,x ,  y), 
split(u, V, Z, xf)) 
Y 
prove ; Rule [59] 
homo(u, split(u, V, Z, xf), Z, xf) 
prove ; Rule [60] 
setp(split(U, V, Z, xf ) )  i f  Setp(V) 
prove ; Goal 1 
subsetp(soln(V,Z, x, y), V) 
prove ; Goal 2 
setp(soln(V, Z, x, y)) if setp(V) 
prove ; Ooa13 
cued(flag(V, Z, x, y), 
clique(solo(V, Z,X,  y), Z), 
indep(soln(V, Z, x, y), Z)) 
prove ; Goal 4 
cued(flag(V, Z, X, y), 
(length(solo(V, Z, x, y)) >= x), 
(length(sole(V, Z, X, y)) >= y)) i f  
( length(V) >= ramsey(x, y))  
H. Zhang, G.X. Hua, Proving Ramsey' s theorem 405 
Appendix B: An example of using bridge lemmas 
Suppose that rules [41] and [44] are stored RRL as follows: 
[41] (x >= y) ~ true if {(suc(x + u) >= (y + v)) ,~(u >= v)}. 
[44] (length(S(u, V  Z)) >= ramsey(suc(x), y ) ---> true if 
{ (suc(length(S(u, V, Z)) + length(T(u, V, Z))) >= ramsey(suc(x), suc(y))), 
(length(T(u, V, Z)) >= ramsey(x, suc(y)))} 
Note that the variables u and v in rule [41] appear only in the condition. 
After simplifying rule [44] by 
ramsey(suc(x), suc(y) ---> ramsey(suc(x), y  + ramsey(x, suc(y)), 
it is easy to see that the simplified [44] is an instance of rule [41] (with u being 
instantiated by tength(T(u, V, Z)) and ~a by ramsey(x, suc(y))). That is, if we view 
both rules [41] and [44] as clauses, then rule [41] subsumes rule [44] (that is close 
to how rule [44] is proved from rule [41] in RRL; see [24] for the technique of using 
[41] as a rewrite rule). 
Note that a variant of rule [41] is 
[41"] (suc(x + u) >= (y + v)) ~ false if {--,(x >= y) ,~(u >= v)}, 
which is more useful than [41] as a rewrite rule. RRL can detect hat rule [44] is 
also an instance of rule [41']. 
Suppose that rule [48], 
[48] length(S(u, V, Z)) + Iength(T(u, V, Z)) ---> length(V) 
is also stored in RRL. Then it is trivial to see that 
[A44] (length(S(u, V Z)) >= ramsey(suc(x), y ) --> true if 
{ (suc(length(v)) >= ramsey(suc(x), suc(y))), 
(length(T(u, V, Z)) >= ramsey(x, suc(y))) }
follows from [44] and [48]. 
However, RRL cannot automatically prove [A44] from [41] and [48] only, 
even though [41] is more general than [44]. To prove [A44] from [41] and [48], 
we have to provide a hint saying that u and v in [41] are instantiated, respectively, 
by length(T(u, V, Z)) and ramsey(x, suc(y)) (that is what is done in BMTP). To 
avoid this hint, we have to use "bridge lemma" [44]. 
