Theoretical Computer Science 238 (2000) 183–220 www.elsevier.com/locate/tcs
Con uence of extensional and non-extensional -calculi with explicit substitutions
Delia Kesner ∗
Univ. de Paris-Sud (Paris XI), Centre de Orsay, Lab. de Recherche en Informatique, CNRS U.R.a. 410, Baˆt. 490, F-91405 Orsay Cedex, France
Received March 1997; revised March 1998 Communicated by P.-L. Curien
Abstract
This paper studies con uence of extensional and non-extensional -calculi with explicit substitutions, where extensionality is interpreted by Á-expansion. For that, we propose a scheme for explicit substitutions which describes those abstract properties that are su cient to guarantee con uence. Our method makes it possible to treat at the same time many well-known calculi such as ; ⇑ ; ; s; v; f; d and dn. c 2000 Elsevier Science B.V. All rights reserved.
Keywords: Functional programming; -calculi; Explicit substitutions; Con uence; Extensionality
1. Introduction
The -calculus is a convenient framework to study functional programming, where the evaluation process is modeled by ÿ-reduction. The main mechanism used to perform ÿ-reduction is substitution, which consists of the replacement of formal parameters by actual arguments. The correctness of substitution is guaranteed by a systematic renaming of bound variables, inconvenient which can be simply avoided in the -calculus aÂ la de Bruijn by using natural numbers to encode the names of variables. However, substitution remains, as far as classical -calculus or -calculus aÂ la de Bruijn is concerned, as a meta-level operation described by operations that are completely external to the language. This becomes a concrete problem in real implementations where the behavior of substitution must be described by other operations. Therefore, -calculi with explicit substitutions aÂ la de Bruijn appear as a natural formalism to implement ÿ-reduction as they are able to specify the substitution operation by symbols and reduction rules belonging to the syntax of the calculus. Nowadays, many theorems provers
∗ E-mail: delia.kesner@lri.fr (D. Kesner).
0304-3975/00/$ - see front matter c 2000 Elsevier Science B.V. All rights reserved. PII: S 0 3 0 4 - 3 9 7 5 ( 9 8 ) 0 0 1 6 6 - 2

184 D. Kesner / Theoretical Computer Science 238 (2000) 183–220
(HOL, ALF, Nuprl) and functional languages (Haskell, ML) use explicit substitutions in their implementations.
However, when working with functions, not only ÿ-reduction takes place in the process of evaluation, as an extensional equality is also necessary to reason about programs. Extensionality means that whenever two programs yield the same result for every possible argument, then they are equal. The classical extensional axiom in the theory of -calculus is the Á-equality, written in a classical formalism as
x : Mx =Á M if x is not free in M
This equality can be operationally interpreted from left to right, yielding the classical Á-contraction rule, or in the other way round as already suggested in [26, 40, 45], yielding the Á-expansion. The traditional contractive way is well behaved in the simply typed -calculus, but it breaks con uence in many other -calculi [8, 14, 31]. On the other hand, the typed Á-expansion can also be combined with many other reduction rules, such as expansive surjective pairing [2, 13, 16, 27], recursion [13, 16], sums [13, 16], algebraic rewriting systems [14] and second order -calculus [15]. All these combinations are well-behaved as they preserve con uence and strong normalization. However, none of the mentioned works covers the combination of Á-expansion with calculi having explicit substitutions as they are all based on formalisms with ÿ-reduction rules modelized by a meta-level substitution.
The main goal of this paper is to study con uence of -calculi with explicit substitutions in de Bruijn’s notation, with or without extensional rules. For that, we keep the classical deÿnition of Beta-reduction associated to ÿ-reduction, and deÿne the Etaexpansion rule associated to the classical Á-expansion one, this rule being more natural than all the contractive interpretations given before in the literature [5, 21, 22, 46]. We study con uence of the reduction relation associated to the Beta-reduction alone as well as that associated to the combination of Beta-reduction and Eta-expansion.
Since we are interested in many di erent -calculi with explicit substitutions (such as [1], ⇑ [24], [42], v [34], f [19], s [28], d [29] and dn [29]), we develop an “abstract” proof that allows to handle in a simple and general way all these calculi, by a simple instantiation of the proof on each case-study. This is done by extracting a set of su cient conditions to guarantee con uence, then formulating a notion of “scheme” of -calculi with explicit substitution, and ÿnally translating every mentioned calculus into a calculus verifying the scheme. If the calculus itself already ÿts in our scheme then the translation is just the identity, otherwise another function has to be used as is done for example for s.
This is an extended and detailed version of [29] which is organized as follows. In Section 2 we recall the untyped and typed versions of the -calculus aÂ la de Bruijn with their standard ÿ reduction rule. We present the deÿnition of the associated Á-expansion rule, which is only well-deÿned in a typed framework.
In Section 3 we describe the scheme of -calculi with explicit substitutions, which is deÿned to have a concrete structure of -terms, but it does not specify the full behavior of all the substitution constructors. The intended meaning of the scheme is to take into

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

185

the account at the same time various -calculi with explicit substitutions existing in the literature which ÿt this “abstract” speciÿcation.
We deÿne in Section 4 the notion of Eta-expansion associated to that of Á-expansion in classical -calculus, and we show that the deÿnition is correct with respect to the corresponding equational axiomatization. Section 5 is devoted to the abstract proofs of con uence of Beta and Beta ∪ Eta by using a generalized interpretation method.
In Section 6 we apply the method to some well known -calculi with explicit substitutions such as v; ; ; f; s; ⇑ ; d and dn. We ÿnally conclude in Section 7.

2. The -calculus aÂ la de Bruijn
When using the ÿ-reduction rule to model evaluation in classical -calculus, bound variables need to be renamed in order to ensure the correctness of the substitution operation. Thus substitution is not really deÿned on terms but on -equivalence classes.
A classical way to avoid -conversion problems is to use the de Bruijn’s notation [11, 12] for -terms, where names of variables are replaced by natural numbers. Hence, the set of ÿrst-order representations of -terms, called here pure terms or simply terms to di erentiate them from classical -terms, is deÿned by the following grammar, where n denotes some representation of the natural number n:
Naturals n ::= 1|n + 1
Pure Terms a ::= n|(a a)| a
Notice that this deÿnition is slight di erent from the original one [11, 12], where every variable is replaced exactly by a natural number and not by a given representation of a natural number. We prefer however this deÿnition which allows us to make the set of normal forms of a given calculus and the set of pure terms to coincide: for example, in , the representation of 2 is the term 1[↑], which is considered here as a pure term.
Indeed, a given occurrence u of a variable, say x, is replaced by the (representation of the) number of symbols whose occurrences are between the binder of this x and u. For example, x : y : x( z : zx)y is written ( (2( (1 3))1)). Remark that a same variable can be translated in many di erent ways (as the variable x is translated into 2 and 3), and that di erent variables can be translated into the same term (as the variables z and y are both translated into 1). Representation of free variables is retrieved from a given context of variables in such a way that an occurrence of a variable n represents the (n − m)-th free variables of the context when n¿m and there are m symbols surrounding this occurrence n. For example, the term x:(y z) is written as (2 3) with respect to the context y; z.
To avoid confusion we will note classical -terms with capital letters M; N; : : : and de Bruijn’s terms with lower case letters a; b; : : : .

186 D. Kesner / Theoretical Computer Science 238 (2000) 183–220

Deÿnition 2.1 (Contexts and applied terms). A context is a term containing a special symbol denoting a hole. We shall note a context as C[ ] and the textual replacement of the hole by a term a as C[a]. Thus, C[a] denotes a term. The subterm a in a term C[(a b)] is said to be applied.

2.1. ÿ-reduction in the -calculus aÂ la de Bruijn
In -calculus, evaluation is performed by means of the rule ( x : M )N → ÿ M {x ← N }, where { ← } denotes a meta-operation, usually deÿned by induction on terms as follows:
(M L){x ← N } = (M {x ← N } L{x ← N })
( y:M ){x ← N } = ( y:M {x ← N })
x{x ← N } = N
y{x ← N } = y
This operation is deÿned modulo -conversion in order to avoid the capture of free variables so that in the second equation x is di erent from y and y is not free in N . Working with de Bruijn’s notation allows to avoid clashes of variable names and thus explicit -conversion is no more needed in -calculus aÂ la de Bruijn [11, 12]. However, numbers have to be adjusted when a substitution is performed in order to guarantee correctness.

Deÿnition 2.2 (Substitutions). Let a and b be terms and n¿1. Then, the substitution of a by b at level n is deÿned by means of an updating function Uin (i¿0 and n¿1) as follows:

(a1 a2){n ← b} = (a1{n ← b})(a2{n ← b})

( a){n ← b} = (a{n + 1 ← b})



 m − 1 if m¿n

m{n

←

b}

=



U0n(b) m

if m = n if m¡n

Uin(a b) = Uin(a)Uin(b) Uin( a) = (Uin+1(a))

Uin(m) =

m + n − 1 if m¿i m if m6i

Now, it is possible to deÿne the ÿ-rule using the notions of substitution and contexts described above:

Deÿnition 2.3 (ÿ-reduction). Let a and b be pure terms. We say that a ÿ-reduces to b, written as a → ÿ b, if and only if there is a context C and terms d and e such that a = C[( d)e] and b = C[d{1 ← e}].

Notice that substitution is still a meta-operation in this calculus, completely external to the reduction rules of the formalism.
Type information can be added to this formalism in order to model the typed -calculus. Types are built over some set of base types by means of the arrow con-

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

187

structor for functional types. The type information will be kept in an environment, which is just a list of types. Typing judgments have the form a : A where is an environment, a is a pure term and A is a type. The typing rules are the following:

A; 1 : A
A; b : B A:b : A → B

n:B

A; n + 1 : B

a:A→B

b:A

(a b) : B

When a : A is derivable from the previous set of typing rules, the term a is said to be of type A. We may omit types if they are clear from the context.

2.2. Á-reduction in the -calculus aÂ la de Bruijn

Due to the deep connections between -calculus, proof theory and category theory, studies on extensional equalities have appeared with di erent motivations in all these ÿelds.
By far, the best known extensional equality in -calculus is the Á-axiom, written as

(Á) x : A:Mx = M provided x is not free in M

This equality captures the fact that both functions, x : A: Mx and M , return the same result when applied to the same argument in any context C[ ]. This is expressed as:

C[( x : A: Mx)N ] =ÿ C[MN ]
When one wants to turn the Á-equality into a rule there are two di erent choices: either from left to right as a contraction, called Á-contraction, or in the other way round as an expansion, called Á-expansion or Á-expansion depending on whether some other restrictions are imposed to its application.
The Á-axiom has traditionally been turned into a contraction. Such an interpretation is well behaved in the simply typed -calculus as it preserves con uence [44]. However, Á-contraction does not preserve con uence in many other -calculi [8, 14, 31].
Fortunately, expansions can be combined with many other higher-order reduction rules, such as expansive surjective pairing [2, 13, 16, 27], recursion [13, 16], sums [13, 16], algebraic rewriting systems [14] and second order -calculus [15]. All these combinations preserve con uence and strong normalization. For that, application of the Á-expansion has to be restricted by some conditions in order to guarantee the strong normalization property: indeed, remark that the reduction relation is no more a congruence on terms.

Deÿnition 2.4 (The conditional Á-expansion).

C[M ] → Á C[ x : A:(Mx)]

if

 

x ∈= FV (M ) M is of type

type

A

→

B



M M

is is

not not

a -abstraction applied in C[M ]

188 D. Kesner / Theoretical Computer Science 238 (2000) 183–220

This deÿnition is adequate, i.e. Á-expansion generates the same equational theory as the Á-axiom, even if it seems more restrictive because of the syntactic conditions it imposes. We refer the readers to [13] for a detailed discussion on these conditions.
The Á-equality in the calculus aÂ la de Bruijn must be able to express that for any context C[ ], the de Bruijn’s representations of two terms C[ x:Mx] and C[M ] are equal. In terms of representation of variables, this means that all the free variables in M (that may be bound with respect to C[ ]) traverse one more when M is replaced by x: Mx, suggesting in this way that a term a is not Á-equivalent to (a 1) because of the adjustments to be made on the free variables of a. As an example, the term
(2 1), placed for example in a context [ ] is Á-equivalent to the term 1 and not to 2. This is not surprising since ( (2 1)) is the de Bruijn’s representation of y: x:yx, which is Á-equivalent to y:y, represented by 1. Both conditions can be expressed using the following formalism:

Deÿnition 2.5 (Binding depth of a position in a term). The binding depth of a position in a term is deÿned by a function h from positions and pure terms to natural numbers deÿned in the following way:

h( ; m) = 0; h(1: ; a) = 1 + h( ; a);

h(1: ; ab) = h( ; a); h(2: ; ab) = h( ; b):

Deÿnition 2.6 (a∧n and a+). Let a be a pure term and n¿0. The term a∧n is deÿned as follows:

(a b)∧n = (a∧n b∧n )

( a)∧n = a∧n+1

m∧n =

m + 1 if m¿n m if m6n

From now on, we denote by a+ the term a∧0 , i.e. a+ is obtained by lifting any free variable of a by 1. This lifting is performed by replacing every index m at position such that m¿h( ; a) by m + 1.

Remark 2.1. If a is a pure term, then U02(a) is a+. Indeed, Um2(a) is exactly a∧m according to deÿnition 2.2 and thus U02(a) = a∧0 = a+. Deÿnition 2.7 (Á-equality). Let a and b be pure terms. Then (a 1) =Á b if a = b+.

The Á-contraction rule is obtained by orienting the previous equality from left to right, while the Á-expansion rule is obtained by orienting the equation into the other way round. Analogously to what is done in classical -calculus to guarantee strong normalization of extensional expansions [13], we can now deÿne a conditional Á-expansion as follows:

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

189

Deÿnition 2.8 (The conditional Á-expansion). Let C[ ] be any context and let a be a

pure term.

C[a] → Á C[ A:(a+ 1)]

  a is of type A → B

if



a a

is is

not not

a -abstraction applied in C[a]

Exactly as in the case of the simply typed -calculus, this deÿnition is adequate, i.e. the limitations imposed on the reduction system do not make us loose any valid equality as they are just introduced to avoid reduction loops. The result can be obtained by proving that any ÿÁ-equality can be generated by the re exive, symmetric and transitive closure of ÿ Á-reduction. We omit here the details of this (standard) proof, which can be found in [30] (Theorem 2.7).
As expected, the Á-expansion rule enjoys the subject reduction property:

Lemma 2.2 (Subject reduction for Á). If a : A and a → Á b; then b : A.

Proof. If a → Á b is a root expansion step, then A is a functional type B → C and

b = B:(a+ 1), so we have to show that

B:(a+ 1) : B → C. For that, we ÿrst

show by induction on the structure of a, that for every n¿0 and for every type B,

if ; a : A and n is the length of the environment , then ; B; a∧n : A. As

a corollary,

a : A implies B; a+ : A so that we obtain the following typing

sequence:

a:B→C B;
B; a+ : B → C

1:B

B; (a+ 1) : C

B:(a+ 1) : B → C

If a → Á b is not a root expansion, then one proceeds by induction on terms.

A direct proof of con uence of ÿ ∪ Á in the -calculus aÂ la de Bruijn can be found in [30], but since we know that the union of ÿ and Á yields a con uent reduction relation in the typed -calculus, and also that the -calculus is isomorphic 1 to the -calculus aÂ la de Bruijn [6, 11, 37], then we are able to conclude that

Theorem 2.3. →∗ is con uent in the typed -calculus aÂ la de Bruijn.
ÿÁ

As a consequence, using the fact that =ÿÁ can be generated by the re exive, symmetric and transitive closure of → ÿÁ we obtain

1 In the sense that there exist a translation T from -terms into -terms aÂ la de Bruijn such that a → ÿÁ b if and only if T(a) → ÿÁ T(b).

190 D. Kesner / Theoretical Computer Science 238 (2000) 183–220

Corollary

2.4.

If

a =ÿÁ b;

then

there

is

a

term

c

such

that

a →∗ c
ÿÁ

and

b →∗ c.
ÿÁ

3. A scheme for -calculi with explicit substitutions
When substitutions are speciÿed at a meta-level, as in classical -calculus or -calculus aÂ la de Bruijn, an external mechanism takes place each time a ÿ-redex needs to be reduced. The approach is very di erent in -calculi with explicit substitutions, where the manipulation of substitutions is incorporated in an explicit way to the calculus via a set of rewrite rules. Such -calculi o er the possibility to have a more reÿned control over substitutions, by allowing for example to delay or record them, and they can be used to describe di erent implementations in a uniform way. In this section we introduce a scheme for -calculi with explicit substitutions which is deÿned to have a concrete structure of terms, but does not specify the full behavior of all the substitution constructors. The intended meaning of this scheme is to extract from the various -calculi with explicit substitutions existing in the literature a uniform description of their behavior and a set of common features being su cient to reason about con uence.
3.1. Syntax and rewriting rules
Let us consider two distinguished symbols T (for terms) and S (for substitutions).
Deÿnition 3.1 (Substitution signatures). A substitution declaration is a (possibly empty) word over the alphabet {T; S}. A substitution signature is deÿned to be a set of symbols all equipped with an arity n and a substitution declaration of length n. We usually write : n; 1 : : : n if the symbol has arity n and substitution declaration 1 : : : n.
Deÿnition 3.2 (Substitution language). The set of objects over a substitution signature constitutes a substitution language which is the union of objects of sort T and S
constructed in the following way: • If n is a natural number, then n is of sort T. • If a and b are of sort T, then (a b) is of sort T. • If a is of sort T, then (a) is of sort T. • If a is of sort T and s is of sort S, then a[s] is of sort T. • If every fi is of sort i, and : n; 1 : : : n ∈ , then (f1; : : : ; fn) is of sort S.
We will say that n is a variable, (a b) an application, (a) a -abstraction and a[s] a closure. We also omit parenthesis when they are clear from the context. For each substitution language W , the set of objects of sort T (resp. S) is called the set of terms (resp. substitutions) of W . We write W for the set of terms and substitutions of W .

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

191

As an example, the substitution signature of the -calculus [34] is the set {#; ⇑; ↑}, where # : 1; T , ⇑: 1; S and ↑: 0; , while the the substitution signature of the
-calculus [1] is the set {·; ◦; id; ↑}, where · : 2; TS , ◦ : 2; SS , id : 0; and ↑: 0; . We refer the reader to Section 6 for a more detailed presentation of these calculi.
We now introduce some of the rewriting rules required for our scheme. We start with the Beta rule that is the main mechanism in all the -calculi with explicit substitutions: it is used to initiate the computation and to explicitly introduce substitutions in the terms to be evaluated. The left-hand side of the Beta rule corresponds to a classical ÿ-redex ( a)b while the right-hand side must be an expression used to denote the term a where the index 1 is replaced by the term b, the index 2 by 1, the index 3 by 2, etc. This is done in di erent ways according to the substitution language of the corresponding calculus, but we can, in general, write this expression as a[consW (b)], where consW is a cons-function from terms to substitutions that must be deÿned for each -calculus W . The Beta rule of the scheme can then be expressed as 2
(Beta) ( a)b → a[consW (b)]
As an example, the cons-function of the v-calculus is cons (b) = #(b), while the consfunction of the -calculus is cons (b) = b · id.
The second rule of the scheme for -calculi with explicit substitutions, called the App rule, is used to distribute a substitution with respect to the subterms of an application term. It is expressed as
(App) (a b)[s] → (a[s] b[s])
The third rule, called Lambda, is used when a substitution goes under a constructor. The left-hand side of this rule corresponds then to a redex ( a)[s], while the righthand side will be written in general as (a[liftW (s)]), where liftW is a lift-function from substitutions to substitutions which must be deÿned for each -calculus W . The substitution liftW (s) denotes a function which does not a ect the indices 1 (which represent the variables which are bound by the -abstraction that [s] has crossed within the Lambda rule) but only changes the other free variables making the correspondent adjustments of indices. The Lambda rule of the scheme can then be expressed as 3
(Lambda) ( a)[s] → (a[liftW (s)])
As an example, the lift-function of the v-calculus is liftv(s) = ⇑ (s), while the liftfunction of the -calculus is lift (s) = 1 · (s ◦ ↑).

2 Since the right-hand side of the Beta rule depends on the substitution calculus W , we should denote this rule as BetaW , but we prefer to omit the index W to make easier the notation.
3 Since the right-hand side of the Lambda rule depends on the substitution calculus W , we should denote this rule as LambdaW , but we prefer to omit the index W to make the notation easier.

192 D. Kesner / Theoretical Computer Science 238 (2000) 183–220
Deÿnition 3.3 (Substitution calculus). A rewrite rule l → r is said to be sortpreserving if r is of sort K when l is of sort K. A Substitution Calculus 4 consists of a signature containing the substitution constant shiftW : 0; , which is called a shift-constant and will be used to denote extensional equalities, a lift-function, a consfunction, and a set of sort-preserving rewriting rules containing App and Lambda (but not Beta). For simplicity we will often omit the superscript W from shiftW, liftW (s) and consW (b) when they are clear from the context.
Notation 3.1. We write simply W for the set of rewriting rules of the substitution calculus W , and W for the set W ∪ Beta. The notations → R and =R are respectively used to denote R-reduction and R-equality. If s is a substitution, we note [s]n the concatenation of substitutions [s] : : : [s], assuming that [s]0 denotes the empty word.
n times
For any function h, hi (i¿0) is deÿned by h0(s) = s and hn+1(s) = h(hn(s)).
3.2. The scheme
The rewriting rules Beta, App and Lambda introduced in Section 3.1 are necessary to describe some relations between terms and substitutions, but they are not su cient to express all of them. In particular, we want to prove con uence for some reduction relations associated to all the -calculi with explicit substitutions satisfying our scheme, so we have to impose some additional conditions on the set of rewriting rules of a substitution calculus W . These conditions are mainly inspired from the various proofs of con uence existing in the literature for the relations → W, where W is for example the -calculus [1], the ⇑-calculus [24], or the -calculus [34].
Deÿnition 3.4 (Basic conditions). A substitution calculus W is said to be basic (written BSC) if it satisÿes the following conditions: 1. W is strongly normalizing. 5 2. W is con uent. 3. W -normal forms of terms are pure terms. 4. W (a b) = (W (a) W (b)) and W ( a) = W (a), where W (a) denotes the W -normal
form of a. 5. For every substitution s in W , 1[liftW (s)] =W 1 6. For every substitution s in W and every m¿1, m + 1[liftW (s)] =W m[s][shiftW ] 7. For every term k in W and every m¿1, m + 1[consW (k)] =W m 8. For every term k in W , 1[consW (k)] =W k 9. For every variable m in W we have m[shiftW ] =W m + 1.
4 Another notion of substitution calculus can be found in [47]. 5 The well-known substitution calculi appearing in the literature are all strongly normalizing, and moreover, standard proof techniques like polynomial orders or semantic labellings [48] are usually su cient to show this property. However, when adding the Beta rule, strong normalization does not always hold, even in a typed framework [39].

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

193

It is evident that there exist even more abstract properties to ensure con uence and strong normalization of any rewriting system W , but the intention of Deÿnition 3.4 is to consider a set of su cient tools to reason about con uence of extensional and non-extensional -calculi; we think that this presentation is quite reasonable to attack these con uence problems from an abstract point of view.
From conditions 1 and 2 in Deÿnition 3.4 we deduce that W -normal forms are unique, 6 and this, together with condition 3 guarantees that for every object a in
W and every pure term b such that W (a) = b, then a →∗W b. This property will be used in several lemmas of the paper. Conditions 5–9 state the behavior of the main substitutions lift, shift and cons that we need in any calculus with explicit substitutions in order to implement ÿ and Á reduction. They interact between them as follows.

Corollary 3.2. Let W be a basic substitution calculus. Then for every m¿1; for every

n¿0; every term k in W and every substitution s in W :

W (m[liftn(s)]) =

W (m − n[s][shift]n) if m¿n; m if m6n;

W (m[liftn(shift)]) =

m + 1 if m¿n; m if m6n;

 m−1

if m¿n + 1;

W

(m[liftn(cons(k))])

=



m W

(k [shift]n )

if m¡n + 1; if m = n + 1:

Now, we add some simple restrictions that are very easy to prove when working with concrete calculi, as they just concern the interaction between variables and substitutions of the substitution language.

Deÿnition 3.3 (Scheme). We say that a basic substitution calculus W obeys the scheme
i for every variable m ∈ W and every function symbol ∈ of arity q one of the two following conditions holds:
• There exist a variable n, indices i1; : : : ; ip (p¿0) and substitutions u1; : : : ; uk (k¿0) such that
– 16i1; i2; : : : ; ip6q and the ij’s are all distinct, and – For all s1 : : : sq we have m[ (s1; : : : ; sq)] =W n[si1 ] : : : [sip ][u1] : : : [uk ]. • There exists i (16i6q) such that for all s1 : : : sq we have m[ (s1; : : : ; sq)] =W si. We assume these equations to be well-typed, in the sense that whenever the ÿrst
case holds, then si1 ; : : : ; sip are substitutions, and whenever the second case holds, then si is a term.

6 Even if uniqueness of normal forms can also be deduced from weak normalization and con uence, we require a substitution calculus to have the strong normalization property to guarantee that any evaluation strategy used to eliminate substitutions will terminate. Substitution calculi are supposed to preserve the properties of the languages they implement so it is reasonable to require strong (and not weak) normalization and con uence.

194 D. Kesner / Theoretical Computer Science 238 (2000) 183–220
This condition says that the behavior of any substitution s = (s1; : : : ; sq) with respect to a variable m is only determined by the constructor and not at all by the other components s1 : : : sq, that is, the semantics of any substitution is given by the constructor and not by their arguments. Remark that we use the equality =W instead of the rewrite relation → W because sometimes the scheme is veriÿed by a rewrite step → W and some other times by W ←: indeed, in the -calculus, we have m[s ◦ t]Clos←m[s][t], while for example in the v-calculus, we have m[↑] → VarShift1 m + 1.
To understand the (technical) motivations of Deÿnition 3.5 let us suppose that lift, shift and cons are just primitive constructors. Then, conditions 5, 6, 7 and 9 of Definition 3.4 corresponds to the ÿrst case of the scheme while condition 8 corresponds to the second one. Since lift, shift and cons are not always implemented via a single primitive constructor as for example lift (s) = 1 · (s ◦ ↑) is deÿned as a “macro” using three di erent constructors · ; ◦ and ↑, we ask all the primitive constructors of substitutions to verify the scheme. Doing so, the three “macro” substitutions lift, shift and cons as well as all the primitive constructors of the language for substitutions will follow the scheme, having in this way a certain type of “regular” behavior which makes easier to reason by induction on the structure of objects.
4. Extensional -calculi with explicit substitutions
In this section we deÿne the notion of Eta-expansion associated to that of Á-expansion in classical -calculus, and we show that the deÿnition is correct with respect to the corresponding equational axiomatization via the Eta-axiom. The basic conditions given in Deÿnition 3.4 will be su cient to show that the Eta-expansion rule is a correct restriction of the Eta-axiom, while the scheme given in Deÿnition 3.5 is also needed to show that both Beta and Beta ∪ Eta are con uent reduction relations.
4.1. The Eta-axiom
The standard equation corresponding to Á-equality in classical -calculus is usually written in the formalism of -calculi with explicit substitutions as the axiom:
(Eta) (a[shift] 1) = a
The shift-constant is then necessary to express the extensional Eta-axiom, but it will be also useful to express some relations between explicit substitutions, even if the Etaaxiom is not considered in the substitution calculus W . For example, one can express the behavior of lift-functions in terms of the shift-constant as done in Deÿnition 3.4, condition 6.
We show here a characterization of a pure term a+ and we give the relation between updating functions and explicit substitutions.
Lemma 4.1. Let W be a basic substitution calculus. Let a be a pure term; i¿0 and n¿1. Then Uin(a) = W (a[lifti(shift)]n−1).

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

195

Proof. By induction on the structure of the term a, using Corollary 3.2.

Corollary 4.2. Let W be a basic substitution calculus and let a be a pure term. Then W (a[shift]) is the term a+.

Proof. The property follows from Lemma 4.1 for the case n = 2 and i = 0, using the fact that U02(a) is a+ (Remark 2.1).

4.2. Turning the Eta-axiom into a reduction rule
When turning the Eta-axiom into a reduction rule some problems arise. If we orient this equation from left to right as the rewriting rule (a[shift] 1) → a, an inÿnite set of critical pairs is usually generated. As a consequence, the rule is often expressed by the following conditional rule [21, 22, 46]:
(Eta1) (a 1) → b if a =W b[shift]:
However, the condition a =W b[shift] depends on the particular deÿnition of the substitution calculus W , and may be di cult (or expensive) to be veriÿed each time that an Eta1-reduction is performed.
There is another unconditional rewriting rule associated to the Eta-axiom, proposed by Briaud [5], expressed in our syntax as follows:
(Eta2) (a 1) → a[cons(⊥)]
where ⊥ is a new constant added to the set of terms. This rule can be expressed in classical -calculus as
(Eta3) x:(M x) → M {x ← ⊥}
The Á-contraction rule in classical -calculus coincides with the Eta3-rule only if the variable x is not free in M . Similarly, the Eta2-rule coincides with the conditional Eta1-rule if the variable represented by 1 is not free in the term a. Otherwise, the Eta1rule is not allowed (because the condition is not veriÿed), but Eta2 is. The intended meaning of the constant ⊥ is to denote something that is not a term, i.e., a meaningless term. For this reason, every normal form involving terms with ⊥ has to be discharged, and this requires some kind of backtracking in the computation process, which is, as we know, an expensive operation. However, the Eta2-rule can also be interpreted as the following conditional rule
(Eta2) (a 1) → a[cons(⊥)]; if ⊥ ∈ W (a[cons(⊥)])
This leads to perform a veriÿcation before applying the rule and therefore this solution is still expensive by means of computation steps. Also, the Eta2 rule depends on the particular deÿnition of the substitution calculus W exactly as in the case of the Eta1-rule.

196 D. Kesner / Theoretical Computer Science 238 (2000) 183–220
Fortunately, there is still another reading of the Eta-axiom that avoids all these problems which corresponds to the unrestricted Eta-expansion:
(Eta) a → (a[shift] 1)
As explained in Section 2.2, the expansive interpretation of the Á-axiom has been very successful in these last years, mainly because it has been shown to be compatible with many other higher-order rules. This suggests that it would also be a good solution to deÿne extensional versions of -calculi with explicit substitutions containing the expansive interpretation of the Eta-axiom.
As the unrestricted Eta-expansion rule is not strongly normalizing, one has to restrict its application by imposing some conditions to guarantee termination, exactly as in the case of the Á-expansion rule. Even if we are not going to study strong normalization properties in this paper, a more restricted version of Eta-expansion will be considered here in order to model exactly the standard conditional Á-expansion rule. For that, we know that Á-expansion is only applied to typed terms of functional type which verify some syntactic restrictions: the terms are not -abstractions and they are not applied to other subterms. All these conditions can also be expressed when dealing with Eta-expansion in -calculi with explicit substitutions.
Deÿnition 4.1 (Applied-terms and Lambda-abstractions). We say that a term a is a Lambda-abstraction if a = b, or a = b[s] and b is a Lambda-abstraction. Similarly, let C[ ] be any context. We say that a subterm a is an Applied-term in C[a], if either it is applied in C[a], or a = b[s] and b is an Applied-term in C[b].
As an example, ( 1) and ( 1)[shift][shift] are Lambda-abstractions and 1 is an Applied-term in both (1 2) and (1[shift] 2).
The type system associated to each substitution calculus depends on the substitution function symbols of its signature. However, there is a set of common typing rules that will be found in all these systems:

A; 1 : A
n:B A; n + 1 : B
a:A→B ab : B

b:A

A; shift .
a:A s. a[s] : A
A; b : B A:b : A → B

We now present the conditional Eta-expansion rule, remark that the relation generated by this rule is no longer a congruence as in the case of classical -calculus and calculus aÂ la de Bruijn.

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

197

Deÿnition 4.2. The conditional Eta-expansion rule is deÿned as:

  a is of type A → B

C[a] → Eta C[ A:(a[shift] 1)]

if



a a

is is

not not

a Lambda-abstraction an Applied-term in C[a]

Deÿnition 4.3. Given a basic substitution calculus W , we deÿne its extensional version as the calculus containing the rules W , Beta and Eta. We denote the reduction relation associated to the extensional substitution calculus W by → W ∪Eta.

As expected, the Eta-expansion rule enjoys subject reduction.

Lemma 4.3 (Subject reduction for Eta). If a : C and a → Eta b; then b : C.
To justify the deÿnition of Applied-terms, it is su cient to remark that given a term C[(a[s] b)], then the Eta-expansion rule will not be terminating as the following inÿnite reduction sequence shows:
a → Eta (a[shift] 1) → Eta (( (a[shift] 1))[shift] 1) : : : However, our restriction is su cient to keep the strong normalization property:

Lemma 4.4 (Strong normalization of Eta). The reduction → Eta is strongly normalizing.

Proof. Using a decreasing measure as deÿned in [41], we refer the reader to [31] for details.

It is also worth noticing that even if a term a is not a Lambda-abstraction according to Deÿnition 4.1, its W -normal form may be one: for example 1[cons( 1)] is not a Lambda-abstraction but W (1[cons( 1)]) = 1 is. The same happens with the notion of Applied-terms. This remark suggests that one could also use a di erent notion of restriction in Deÿnition 4.2, saying that a term a is a Lambda-abstraction if a =W b. This alternative notion of restricted expansion coincides exactly with that of simply typed -calculus, but introduces at the same time a condition that depends on the particular deÿnition of the substitution calculus W , exactly as in the case of the Eta1 previously mentioned. Even if our approach also introduces a condition in order to use Eta as a reduction rule, the restriction does not depend at all on the particular theory generated by the substitution calculus and there is no backtracking at all.

4.3. Adequacy of Eta-expansions
The Eta-expansion generates the same equational theory generated by the Etaequality, even if it seems more restrictive because of the syntactic conditions to be veriÿed. This property is called adequacy of Eta with respect to Eta. We show here

198 D. Kesner / Theoretical Computer Science 238 (2000) 183–220

that Deÿnition 4.2 of Eta-expansion is adequate with respect to the equational theory generated by the Eta-equality in any -calculus with explicit substitutions verifying the basic conditions. For that, we ÿrst study some syntactic properties which are helpful not only in proving Theorem 4.6 but also for other results of the paper.
Lemma 4.5 describes two di erent cases where the successive application of two di erent explicit substitutions on a term does not change its meaning.

Lemma 4.5. Let W be a basic substitution calculus; a be a pure term and k be a term in W . Then for every n¿0;
1. a[liftn(shift)][liftn(cons(k))] →∗W a 2. a[liftn+1(shift)][liftn(cons(1))] →∗W a
Proof. By induction on pure terms, using Corollary 3.2.

We can now show Theorem 4.6 that has already been announced:

Theorem 4.6. Let W be a basic substitution calculus. Then any Eta-equality a =Eta b can be generated by the re exive; symmetric and transitive closure of → W ∪Eta.

Proof. Suppose a =Eta b holds but a does not Eta-reduce to b, neither b to a. Without loss of generality we can suppose that one of the restrictions holds for a, and we reason as follows: • a is a Lambda-abstraction according to Deÿnition 4.1. Then a = ( b)[s1] : : : [sn] and
we want to show that ( b)[s1] : : : [sn] and ((( b)[s1] : : : [sn])[shift] 1) are interreducible. Let us consider the pure term W (( b)[s1] : : : [sn]) that is necessarily a abstraction, say k, so that ( b)[s1] : : : [sn] →∗W k. Then,

((( b)[s1] : : : [sn])[shift] 1) →∗W

(( k)[shift] 1)

→ Lambda

(( k[lift(shift)]) 1) (k [lift (shift)][cons(1)])

→ Beta →∗W (by L 4:5(2))

k

• a is an Applied-term according to Deÿnition 4.1. Then a is a subterm of (a[s1] : : : [sn]c) and we want to show that (a[s1] : : : [sn] c) and (( (a[s1] : : : [sn][shift] 1))c) are interreducible. Let us take the term k such that a[s1] : : : [sn] →∗W k. Then,

(( (a[s1] : : : [sn][shift] 1)) c) →∗W

(( (k[shift] 1)) c)

→ Beta

(k[shift] 1)[cons(c)]

→ App

(k[shift][cons(c)] 1[cons(c)]) → W (Def 3:4(5))

(k[shift][cons(c)] c)

→∗W (by L 4:5(1))

(k c)

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

199

5. Con uence for the scheme

We show in this section that extensional and non-extensional basic substitution calculi having the scheme are con uent. As we deal with extensional rules, the interpretation method [20], which is the standard technique used to prove con uence of -calculi with explicit substitutions, has to be slightly modiÿed, resulting in the generalized interpretation method, that allows also to deal with conditional extensional rules. It is also worth noticing that standard techniques, like the Tait and Martin-Lof’s parallel moves lemma, do not work when dealing with restricted expansions, and this is the reason we prefer to use directly the interpretation method even for the non-extensional versions of our -calculi.
The interpretation method allows to reason in a quite modular way, by splitting an entire reduction relation R into two di erent and disjoint relations R1 and R2. Indeed, one has to verify that R1 is con uent and strongly normalizing; and also that R2 enjoys some kind of “preservation of reduction” by R1-normal forms. These facts make it possible to put them together guaranteeing con uence of the whole reduction relation R. The method can be summarized by the following lemma:

Lemma 5.1 (Interpretation method). Let R = R1 ∪ R2; where R1 is a con uent and
strongly normalizing reduction relation and R2 an arbitrary reduction relation. If
there exists a reduction relation S on the set of R1-normal forms such that (i) →∗S ⊆ →∗R; and (ii) a → R2 b implies R1(a) →∗S R1(b) then if S is con uent; R is also con uent.

When showing con uence for any relation → W associated to a -calculus with explicit substitutions, one usually takes S as ÿ, R1 as W and R2 as Beta. However, when the Eta-expansion is also considered in the reduction system, this method is no
longer useful because condition ii does not always hold, as the following example
shows:

Example 5.2. Let us consider the extensional v-calculus and the following Eta-

expansion step: a = 1[#( 1)] → Eta ( (1[shift] 1))[#( Then W (a) = 1 and W (b) = (( 1) 1), so it is

1)] = b. neither true

that

W (a) →∗

W (b),

Á

nor that W (a) →∗ W (b). In fact, W (a) is a ÿÁ-normal form so it cannot be reduced

ÿÁ

at all.

As the previous example suggests, condition (ii) required by the interpretation method can be weakened to recover con uence as follows:
a → R2 b implies R1(a) =T R1(b) where =T stands for an equality contained in →∗S S ∗←.

200 D. Kesner / Theoretical Computer Science 238 (2000) 183–220

This formulation yields our generalized interpretation method, as condition ii required by Lemma 5.1 is a particular case of this condition above.

Lemma 5.3 (Generalized interpretation method). Let R = R1 ∪ R2; where R1 is a conuent and strongly normalizing reduction relation and R2 an arbitrary reduction rela-
tion. If there exists a reduction relation S and an equality T on the set of R1-normal forms such that
(i) →∗S ⊆ →∗R; (ii) =T ⊆ →∗S S ∗← and (iii) a → R2 b implies R1(a) =T R1(b): Then R is con uent.

Proof. First of all, since R1 is con uent and strongly normalizing, we know that R1normal forms are unique and so, from condition iii we have that a →∗R b implies R1(a) =T R1(b). Now, suppose b R ∗← a →∗R c. Reduce b and c to their R1-normal forms R1(b) and R1(c). As R1 ⊆ R, then R1(b) R ∗← a →∗R R1(c) and by the previous remark we have that R1(b) = R1(R1(b)) =T R1(a) =T R1(R1(c)) = R1(c). By condition ii R1(b) →∗S S ∗← R1(c), and by condition i R1(b) →∗R R ∗← R1(c) so we can close the diagram as follows:
b →∗R R1(b) →∗R R ∗← R1(c) R ∗← c

When showing con uence for any relation → W , one usually takes S as ÿ, T as ÿ, R1 as W and R2 as Beta, while for any relation → W ∪Eta, one usually takes S as ÿ ∪ Á, T as ÿ ∪ Á, R1 as W and R2 as Beta ∪ Eta. We are now able to devote the rest of this section to prove the hypothesis required by Lemma 5.3, namely:

→∗ÿ

⊆

→∗ W

and →∗ ⊆ →∗
ÿÁ W ∪Eta

=ÿ ⊆

→∗ÿ ÿ ∗←

and

=ÿÁ ⊆

→∗
ÿÁ

ÿÁ ∗←

(1) (2)

a → Beta b implies W (a) =ÿ W (b) and a → Beta∪Eta b implies W (a) =ÿÁ W (b) (3)
Property 1 is quite simple to prove (see Lemma 5.17) whereas the ÿrst (resp. second) part of Property 2 holds by the fact that ÿ (resp. ÿÁ) is con uent. Property 3 is the essential part of the general abstract proof that distills the di erent techniques used in all the proofs appearing in the literature. The main idea used to prove them comes from the case where a and b are closures c[s] and c[s ] such that s → Beta s (resp. s → Eta s ). As ÿ (resp. Á) equality is only deÿned on pure terms (and W -normal forms of substitutions are not), the previous property needs to be proven together with a similar statement for substitutions, resulting in something like s → Beta s (resp. s → Eta s ) implies that for every pure term d, W (d[s]) =ÿ W (d[s ]) (resp. W (d[s]) =ÿÁ W (d[s ])). See Lemma 5.14 (resp. Lemma 5.15) for the precise formulation of these properties.

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

201

One remark concerning Property 3 above is that one might in fact prove a stronger property (as done in [29]), namely that a → Beta∪Eta b implies W (a) →∗ Á ÿ ∗← W (b). Even if this also yields to the desired result, the proof becomes more complicated as
we have to deal with a lot of details concerning the conditional reduction rule Á.

5.1. Some technical lemmas
When showing con uence of ÿ-reduction in classical -calculus, one is often faced to show the substitution lemma, which is usually stated as follows:
M [x := N ][y := L] = M [y := L][x := N [y := L]]; if x ∈ FV (L)
This section is devoted to show the substitution lemma in the framework of explicit substitutions, which will be used latter in Section 5.2 to show the properties required by our generalized interpretation method.

Lemma 5.4. For every basic substitution calculus W; every pure term a and every n¿0 we have W (a[shift][liftn+1(shift)]) = W (a[liftn(shift)][shift]).
Proof. One shows, by induction on the structure of a using Corollary 3.2, that for any n¿k¿0 W (a[liftk (shift)][liftn+1(shift)]) = W (a[liftn(shift)][liftk (shift)]). Then, the property follows from the case k = 0.

By n iterations of Lemma 5.4 we obtain:

Corollary 5.5. Let W be a basic substitution calculus. For any pure term a; we have W (a[shift]n[liftn(shift)]) = W (a[shift]n+1)

Lemma 5.6. Let W be a basic substitution calculus; a be a pure term and s be a substitution in W . Then W (a[s][shift]) = W (a[shift][lift(s)]).

Proof. We prove, by induction on the structure of a, that for every n¿0

W (a[liftn(s)][liftn(shift)]) = W (a[liftn(shift)][liftn+1(s)])
Then, the property follows from the case n = 0. • For a = m, we have two cases:
– If m¿n, then

W (m[liftn(s)][liftn(shift)])

=Cor 3:2

W (m − n[s][shift]n[liftn(shift)]) =Cor 5:5

W (m − n[s][shift]n+1)

=Cor 3:2

W (m + 1[liftn+1(s)])

=Cor 3:2

W (m[liftn(shift)][liftn+1(s)])

202 D. Kesner / Theoretical Computer Science 238 (2000) 183–220

– If otherwise m6n, then

W (m[liftn(s)][liftn(shift)]) =Cor 3:2

W (m[liftn(shift)])

=Cor 3:2

m =Cor 3:2

W (m[liftn+1(s)])

=Cor 3:2

W (m[liftn(shift)][liftn+1(s)])

• For a = (a1 a2) or a = b the property immediately follows from the induction hypothesis.

Corollary 5.7. Let W be a basic substitution calculus. Let a be a pure term and s be a substitution in W . Then for every k¿1 we have W (a[shift]k [liftk (s)]) = W (a[s] [shift]k ).

Proof. By induction on k using Lemma 5.6.

Lemma 5.8. Let W be a basic substitution calculus. Let a be a pure term; b be a term in W and n¿0. Then

W (a[liftn(cons(b))][liftn(s)]) = W (a[liftn+1(s)][liftn(cons(b[s]))])

Proof. By induction on the structure of a. We show only the interesting case which corresponds to a = m. • If m¿n + 1, then we have

W (m[liftn(cons(b))][liftn(s)])

=Cor 3:2

W (m − n[cons(b)][shift]n[liftn(s)])

=Def 3:4(7)

W (m − n − 1[shift]n[liftn(s)])

=Cor 5:7

W (m − n − 1[s][shift]n])

=L 4:5(1)

W (m − n − 1[s][shift][cons(b[s])][shift]n)

=Cor 5:7

W (m − n − 1[s][shift][shift]n[liftn(cons(b[s]))]) =Cor 3:2

W (m[liftn+1(s)][liftn(cons(b[s]))])

• If m = n + 1, then we have

W (m[liftn(cons(b))][liftn(s)]) =Cor 3:2

W (1[cons(b)][shift]n[liftn(s)]) =Def 3:4(8)

W (b[shift]n[liftn(s)])

=L 5:7

W (b[s][shift]n)

=Def 3:4(8)

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

W (1[cons(b[s])][shift]n)

=Cor 3:2

W (n + 1[liftn(cons(b[s]))])

=Def 3:4(9)

W (1[shift]n[liftn(cons(b[s]))])

=Def 3:4(5)

W (1[lift(s)][shift]n[liftn(cons(b[s]))]) =Cor 3:2

W (m[liftn+1(s)][liftn(cons(b[s]))])

203

• If otherwise m¡n + 1, then m6n and the property holds as a consequence of Corollary 3.2.

Corollary 5.9. Let W be a basic substitution calculus and let a and b be two terms in W . Then W (a[cons(b)][s]) = W (a[lift(s)][cons(b[s])]).

Proof. Taking n = 0 in Lemma 5.8, we can conclude that the property holds for pure terms. Now, W (a[cons(b)][s]) = W (W (a)[cons(b)][s]) and W (a) is a pure term by Deÿnition 3.4(3), so that W (W (a)[cons(b)][s]) is equal to W (W (a)[lift(s)][cons(b[s])]) = W (a[lift(s)][cons(b[s])]).

Lemma 5.10 gives the implementation of a classical substitution {n ← b} applied to a term a in terms of the W -normal form of an object in W .

Lemma 5.10. Let W be a basic substitution calculus. Let a and b be pure terms. Then for every n¿1 a{n ← b} = W (a[liftn−1(cons(b))]).
Proof. By induction on the structure of a, using Corollary 3.2 and Lemma 4.1.

The notion of ÿ-reduction is stable by substitution, but this is no longer true when

working with the Á-expansion rule: indeed, given a term x of type A → B, we have

x → Á y : A → B: xy, but x{x ← z : A → B:z} does not reduce via Á to ( y : A → B:xy){x ← z : A → B:z}. The same situation arises in the -calculus aÂ la de Bruijn,

and also when dealing with W (a[s]) →∗ W (b[s]) as the

explicit substitutions: it is following example shows:

not

true

that

a→Á b

implies

Á

Example 5.11. Let us consider the following Á-expansion step:

a = 1 → Á ( (2 1)) = b
Take s = 1. Then W (a[s]) = 1 and W (b[s]) = (( 1) 1) but W (a[s]) →∗ W (b[s])
Á
does not hold.
As in the case of the -calculus aÂ la de Bruijn, we can state a weak property that will be su cient for our purpose.

204 D. Kesner / Theoretical Computer Science 238 (2000) 183–220
Lemma 5.12. Let W be a basic substitution calculus; a and a be pure terms and s be any substitution in W . If a =ÿ a ; then W (a[s]) =ÿ W (a [s]); and if a =Á a ; then W (a[s]) =Á W (a [s]).
Proof. By induction on the number of derivation steps of a =ÿ a or a =Á a . If a =ÿ a (resp. a =Á a ) in 0 steps (by re exivity), the property is trivial. Otherwise, there is a term b such that a =ÿ b (resp. a =Á b) in 1 step and b =ÿ a (resp. b =Á a ) in n steps (n¿0) so that W (b[s]) =ÿ W (a [s]) (resp. W (b[s]) =Á W (a [s])) holds by induction hypothesis. Now, if a = b, then if the equality comes from a context closure, one proceeds by induction on the structure of a, otherwise we consider the two possible cases. If a =ÿ b then a = ( a1)a2, b = a1{1 ← a2} and we have
W (a[s])
= W ((( W (a1))W (a2))[s])
=App; Lambda ( W (a1[lift(s)]))W (a2[s]) → ÿ W (a1[lift(s)]){1 ← W (a2[s])}
=L 5:10 W (a1[lift(s)][cons(a2[s])])
=Cor 5:9 W (a1[cons(a2)][s])
=L 5:10 W (W (a1){1 ← W (a2)}[s])
= W (b[s])
If on the contrary a =Á b, then b = (a+ 1) and so we have W (b[s]) = W (( (a+ 1))[s]) =Lambda; App W (a+[lift(s)] 1[lift(s)]) =Def 3:4(5) (W (a+[lift(s)]) 1)
=Cor 4:2 (W (W (a[shift])[lift(s)]) 1)
= (W (a[shift][lift(s)]) 1)
=L 5:6 (W (a[s][shift]) 1) =Cor 4:2 (W (a[s])+) 1)
=Á W (a[s])
In both cases we obtain W (a[s]) =ÿ W (a [s]) (resp. W (a[s]) =Á W (a [s])) by transitivity.

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

205

Corollary 5.13. Let a and b be pure terms such that a =ÿÁb. Then, for every substitution s of any basic substitution calculus W we have W (a[s]) =ÿÁW (b[s]).

5.2. The con uence proofs
We proceed now to show the main lemmas of this section, where we can ÿnd the justiÿcation of the general conditions stated in Deÿnition 3.5.
Lemma 5.14. Let W be a basic substitution calculus having the scheme and let o be an object of W . If o → Beta o ; then 1. if o is a term; then W (o) =ÿ W (o ) 2. for every pure term d such that d[o] is a term; and every n¿0; we have
W (d[liftn(o)]) =ÿ W (d[liftn(o )])
Proof. We show the property by induction on the lexicographic order induced by the pair o; d . • If o is either a variable or a substitution constant, the properties vacuously hold
because o is in Beta-normal form. We also remark that if o is an application, an abstraction or a closure, there is nothing to prove for the second property because d[o] is not a term. • If o is an application (a b), we then consider two cases for the ÿrst property: – If either o = (a b), where a → Beta a , or o = (a b ), where b → Beta b , then the
ÿrst property immediately holds by the induction hypothesis (1) and Deÿnition 3.4(4) since a; d ¡ (a b); d and b; d ¡ (a b); d . – If o = c[cons(b)], where a = ( c), then we have
W (o) =App; Lambda ( W (c))W (b) → ÿ W (c){1 ← W (b)}
=l 5:10W (W (c)[cons(W (b))])
= W (c[cons(b)]) = W (o )
• If o is a -abstraction a, where a → Beta a , then the ÿrst property immediately holds by the induction hypothesis (1) and Deÿnition 3.4(4) since a; d ¡ a; d .
• If o is a closure a[v], then we consider two cases for the ÿrst property: – o = a [v], where a → Beta a . Since a is a subterm of o, then a; d ¡ a[v]; d , so we have W (a) =ÿ W (a ) by the induction hypothesis (1) and W (o) = W (W (a)[v]) =ÿW (W (a )[v]) = W (o ) by Lemma 5.12 and the fact that W -normal forms are pure terms by Deÿnition 3.4(3). – o = a[v ], where v → Beta v . Since W (a) is a pure term by Deÿnition 3.4(3), then W (o) = W (W (a)[v]) =ÿ W (W (a)[v ]) = W (o ) holds by the induction hypothesis (2) since v; W (a) ¡ a[v]; W (a) .
• If o is a substitution (s1; : : : ; sj; : : : ; sq) (q ¿ 0), and o = (s1; : : : ; sj; : : : ; sq), where sj → Beta sj, then there is nothing to prove for the ÿrst property as o is not a term. For the second property, we proceed by cases on the pure term d.

206 D. Kesner / Theoretical Computer Science 238 (2000) 183–220
– If d = (d1 d2) or d = d1, then the property follows using the induction hypothesis (2) since o; di ¡ o; d for i = 1; 2.
– If d = m, we have to prove that for all n¿0 we have W (m[liftn(o)]) =ÿ W (m[liftn(o )]). We proceed by induction on n. (i) If n = 0, we proceed by cases according to Deÿnition 3.3: (i.1) Suppose that there exist a variable l, indices i1; : : : ; ip (p¿0) and substitutions u1; : : : ; uk (k¿0) such that 16i1; i2; : : : ; ip6q, the ij’s are all distinct and for all s1 : : : sq m[ (s1; : : : ; sq)] =W l[si1 ] : : : [sip ][u1] : : : [uk ]. (i.1.1) If j ∈ {i1; : : : ; ip}, then the property is trivial since W (m[o]) = W (m[o ]) = W (l[si1 ] : : : [sip ][u1] : : : [uk ]). (i.1.2) If j ∈ {i1; : : : ; ip}, let us say j = ih, then the term W (m[o ]) is equal to W (l[si1 ] : : : [sih ] : : : [sip ][u1] : : : [uk ]) where W (l[si1 ] : : : [sih−1 ]) = e is a pure term by Deÿnition 3.4(3). We have sih ; e ¡ (s1; : : : ; sq); m , so by the induction hypothesis (2) W (e[sih ]) =ÿ W (e[sih ]). Since W (e[sih ]) is a pure term, we can repeatedly apply Lemma 5.12 to obtain:
W (m[o]) = W (W (e[sih ])[sih+1 ] : : : [sip ][u1] : : : [uk ])
=ÿ W (W (e[sih ])[sih+1 ] : : : [sip ][u1] : : : [uk ]) = W (m[o ])
(i.2) Suppose that there exists an index i (16i6q) such that for all s1 : : : sq we have m[ (s1; : : : ; sq)] =W si. (i.2.1) If i = j, then we trivially have W (m[o ]) = W (si) = W (m[o ]). (i.2.2) If i = j, then W (m[o]) = W (sj) and W (m[o ]) = W (sj). Since sj; m ¡ (s1; : : : ; sj; : : : ; sq); m , we get W (sj) =ÿ W (sj) by the induction hypothesis (1).
(ii) If n¿0, we consider two cases: (ii.1) If m6n; then W (m[liftn(o)]) = m = W (m[liftn(o )]) by Corollary 3.2. (ii.2) If m¿n, then by Corollary 3.2 we have
W (m[liftn(o)]) = W (m − 1[liftn−1(o)][shift])
W (m[liftn(o )]) = W (m − 1[liftn−1(o )][shift])
Since variables are equivalent with respect to our ordering o; d , we have (s1; : : : ; sj; : : : ; sq); m = (s1; : : : ; sj; : : : ; sq); m − 1 , and then we can apply the induction hypothesis on n to obtain
W (m − 1[liftn−1(o)]) =ÿ W (m − 1[liftn−1(o )])
Since every W -normal form of a term is a pure term by Deÿnition 3.4(3), the result ÿnally follows from Lemma 5.12, so that
W (m[liftn(o)]) = W (W (m − 1[liftn−1(o)])[shift])
=ÿ W (W (m − 1[liftn−1(o )])[shift]) = W (m[liftn(o )])

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

207

Lemma 5.15. Let W be a basic substitution calculus having the scheme and let o be an object of W . If o → Eta o ; then 1. if o is a term; then W (o) =ÿÁW (o ) 2. for every pure term d such that d[o] is a term; and every n¿0; we have
W (d[liftn(o)]) =ÿÁW (d[liftn(o )])
Proof. If o → Eta (o[shift] 1) = o is a root expansion, then o is a term and the second property vacuously holds since d[liftn(o)] is not a term. The ÿrst property holds since
W (o) =Á (W (o)+ 1) =cor 4:2 (W (W (o)[shift]) 1) = W ( (o[shift] 1)) = W (o )

If o → Eta o is not a root expansion, one proceeds exactly as in Lemma 5.14, showing simultaneously the two properties by induction on the lexicographic ordering induced by the pair o; d .

Corollary 5.16. Let W be a basic substitution calculus having the scheme and let a be a term of W such that a → Beta∪Eta b. Then W (a) =ÿÁ W (b).
Finally, we can obtain property (1) as follows:

Lemma 5.17. Let W be a basic substitution calculus and a be a pure term. If a →∗ÿ b;

then a →∗ b and if a →∗ b; then a →∗

b.

W ÿÁ W ∪Eta

Proof. The proof proceeds by induction on the number of steps from a to b. We only

show here the case a → ÿ b, the rest of the proof being straightforward. If a → ÿ b, then

a = C[( c)d] and b = C[c{1 ← d}]. By lemma 5.10 c{1 ← d} = W (c[cons(d)]), so

a = C[( c)d] → Beta C[c[cons(d)]] →W∗ C[c{1 ← d}] = b. Suppose now C[a] → Á

C[ (a+ 1)], where a → Á (a+ 1). Then a is not a -abstraction and is not applied

to is

another exactly

term a+,

so so

by deÿnition a that (a[shift]

→1)E→ta ∗W(a[s(hWif(t]a[1s)h,ifatn])d

by Corollary 4.2 W (a[shift]) 1) = (a+ 1) which implies

a →∗

(a+ 1) and concludes the proof.

W ∪Eta

Since every basic substitution calculus W satisfying the scheme is con uent and strongly normalizing, then we can use Lemma 5.17 and Corollary 5.16 to derive con-
uence of W and W ∪ Eta as follows:

Theorem 5.18 ( W is con uent). For every basic substitution calculus W satisfying the scheme; the relation W is con uent.

Proof. Using Lemma 5.3, where S is ÿ, T is ÿ, R1 is W and R2 is Beta.

Theorem 5.19 ( W ∪ Eta is con uent). For every basic substitution calculus W having the scheme; the relation W ∪ Eta is con uent.

208 D. Kesner / Theoretical Computer Science 238 (2000) 183–220
Proof. By Lemma 5.3, where S is ÿ ∪ Á, T is ÿ ∪ Á, R1 is W and R2 is Beta ∪ Eta.

6. Con uence for calculi with explicit substitutions
In this section we apply our method to some well-known calculi such as , ⇑ , , s, v, d, dn and f. The method applies directly to most of them, and needs a special treatment for -calculi which do not ÿt our deÿnition of substitution calculus, but that can be translated to some calculus ÿtting the scheme. For that, we require the following:

Theorem 6.1. Let X be a calculus such that

• X is strongly normalizing.

• X -normal forms of terms are pure terms.

•

a → ÿÁ

b

implies

a →∗

b.

X ∪Eta

• There is a translation T from X to terms of some substitution calculus W such

that:

• the translation T is the identity on pure terms;

•

a→

X ∪Eta b

implies

T(a) →∗

T(b).

W ∪Eta

Then X ∪ Eta is con uent.

Proof. Let a be a term such that b X ∪Eta ∗←a →∗ X ∪Eta c. Since X is strongly nor-

malizing we can reduce b and c to their X -normal forms X (b) = b and X (c) = c so

that b T(a)

X ∪Eta
→∗

∗←a →∗ T(b

X
)

so

that

W ∪Eta
W (T(b

))

→∗

c . By the translation we obtain T(a) →∗

T(c ) and

∪Eta

W ∪Eta

and by Corollary 5.16 W (T(b )) =ÿÁW (T(a)) =ÿÁW (T(c ))

k ∗← W (T(c )) by Theorem 2.3. Since b and c are pure

ÿÁ ÿÁ

terms by the second hypothesis, then T(b ) = b and T(c ) = c hold by the fourth

hypothesis and W (b ) = b and W (c ) = c hold by deÿnition of substitution

calculi. We have b →∗ k ∗ ← c , which implies, by the second hypothesis, that

b →∗

k∗

ÿÁ ÿÁ
← c and concludes the proof.

X ∪Eta X ∪Eta

In the case of , ⇑ , , v, d, dn and f the translation T( ) is simply the identity, while for the s-calculus one can use for example the translation from s to
v given in [28]. We omit here all the veriÿcations concerning the treatment of s but we refer the interested reader to [30] for full details.
As a summary of the calculi we analyze in this section, we give in the following table the set of substitutions as well as the representation of variables we use for each of them. In particular, the variable 1 is always represented by 1 but the representation of a variable n + 1 (n¿1) changes from one calculus to another.
When using composition, we will often assume the following notations:

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

209

Notation 6.2. We use the notation n∗ for succ(: : : succ(0) : : :), [↑]n for [↑] : : : [↑]. The

n times
notations n(s) and n(s; u) are deÿned by induction as follows:

n times

0(s) = id 1(s) = s n+1(s) = s ◦ n (s)

0(s; u) = u n+1(s; u) = n (s; (s ◦ u))

Note that n(s) ◦ u is di erent from n(s; u) (as we have for example 3(s) ◦ u = (s ◦ (s ◦ s)) ◦ u and 3(s; u) = s ◦ (s ◦ (s ◦ u))), but n(s) ◦ u =Ass n (s; u). Remark also that n(s; s) = n+1 (s).

Calculus
⇑
v f d dn

Reference [1] [24] [42] [34] [19] [29] [29]

Variable n + 1 (n¿1) 1[ n(↑)]
n+1 1[↑n∗ ]
n+1 1[↑]n 1[ n(↑)]
n+1

Substitutions
s ::= id | a · s | ↑ | s ◦ s
s ::= id | a · s | ⇑ (s) | ↑ | s ◦ s s ::= ↑n∗ | a · s | s ◦ s s ::= #(a) | ⇑ (s) | ↑ s ::= #(a) | ⇑ (s) | ↑
s ::= id | #(a) | ⇑ (s) | ↑ | s ◦ s s ::= id | #(a) | ⇑ (s) | ↑ | s ◦ s

The rewrite rules of each calculus will be given independently in di erent subsections, so that we present here the deÿnition of the di erent functions shiftW ; liftW and

consW .

Calculus shift

lift (s)

cons(b)

↑

1 · (s ◦ ↑)

b · id

⇑↑

⇑ (s)

b · id

↑succ(0) 1 · (s ◦ ↑succ(0)) b · ↑0

v↑ f↑ d↑ dn ↑

⇑ (s) ⇑ (s) ⇑ (s) ⇑ (s)

#(b) #(b) #(b) #(b)

6.1. The calculi ; ⇑ and
The calculus [1] was introduced as a bridge between the classical -calculus and concrete implementations of functional programming. It is inspired by de Bruijn notation [11, 12] and Categorical Combinatory Logic (CCL) [7], it is very useful to derive machines for the -calculus [25] or to implement higher-order uniÿcation [17]. We ÿnd in the -calculus the main features which characterize a calculus of explicit substitutions: substitutions are incorporated to the language and manipulated explicitly, terms are divided in two sorts – terms themselves and substitutions – and ÿ-reduction is simulated in two stages, ÿrst by the application of the Beta rule which activates the calculus of substitutions, then by propagation of the substitution until variables are

210 D. Kesner / Theoretical Computer Science 238 (2000) 183–220

reached. Strong normalization of the -calculus is proved in [10], but the -calculus does not preserve ÿ-strong normalization of terms [39], i.e. there exists a term which is ÿ-strong normalizing but it is not -strongly normalizing. The -calculus is con uent on closed terms, and remains con uent when meta-variables for terms are added to the syntax (i.e., is con uent on semi-open terms), but is no longer con uent when variables for substitutions are also considered (con uence fails for open terms). The rewriting rules of are

(Beta)

( a)b

→ a[b · id]

(App)

(a b)[s]

→ (a[s] b[s])

(Lambda) ( a)[s]

→ (a[1 · (s ◦ ↑)])

(Clos)

(a[s])[t] → a[s ◦ t]

(VarId )

1[id ]

→1

(VarCons) 1[a · s]

→a

(IdL)

id ◦ s

→s

(ShiftId) ↑ ◦ id

→↑

(ShiftCons) ↑ ◦ (a · s) → s

(Ass) (Map)

(s1 ◦ s2) ◦ s3 → s1 ◦ (s2 ◦ s3) (a · s) ◦ t → a[t] · (s ◦ t)

To overcome the problem of con uence of , Hardin and LeÃvy introduced in [24]
the ⇑ -calculus which considers a new operator, written ⇑, that allows to recover con uence on the set of open terms [9]. Indeed, the implementation of the lift-function
is much more simpler in the ⇑ -calculus: it only uses a unary constructor. As , neither the ⇑ -calculus preserve ÿ-strong normalization [38]. The rewriting rules of
⇑ are

(Beta)

( a)b

→ a[b · id]

(App)

(a b)[s]

→ (a[s] b[s])

(Lambda) ( a)[s]

→ (a[⇑ (s)])

(Clos)

(a[s])[t]

→ a[s ◦ t]

(Varshift1) n[↑]

→ n+1

(Varshift2) n[↑ ◦ s]

→ n + 1[s]

(FVar)

1[a · s]

→a

(FVarLift1) 1[⇑ (s)]

→1

(FVarLift2) 1[⇑ (s) ◦ t]

→ 1[t]

(RVar)

n + 1[a · s]

→ n[s]

(RVarLift1) n + 1[⇑ (s)] → n[s ◦ ↑]

(RVarLift2) n + 1[⇑ (s) ◦ t] → n[s ◦ (↑ ◦ t)]

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

(Ass)

(s1 ◦ s2) ◦ s3

→ s1 ◦ (s2 ◦ s3)

(Map)

(a · s) ◦ t

→ a[t] · (s ◦ t)

(Shift)

↑ ◦ (a · s)

→s

(ShiftLift1) ↑ ◦ ⇑ (s)

→ s◦ ↑

(ShiftLift2) ↑ ◦ (⇑ (s) ◦ t) → s ◦ (↑ ◦ t)

(Lift1)

⇑ (s) ◦ ⇑ (t)

→ ⇑ (s ◦ t)

(Lift2)

⇑ (s) ◦ (⇑ (t) ◦ u) → ⇑ (s ◦ t) ◦ u

(LiftEnv) ⇑ (s) ◦ (a · t)

→ a · (s ◦ t)

(IdL)

id ◦ s

→s

(IdR)

s ◦ id

→s

(LiftId )

⇑ (id)

→ id

(Id) a[id]

→a

211

The -calculus is not locally con uent on open terms, so that RÃos proposed in [46] a slight variant, called -calculus, in order to overcome this problem. The -calculus [42] is a left-linear variant of , which is practical for implementations and does not poses typing problems when working in higher-order type theories. As well as , the
-calculus is weak normalizing and con uent on semi-open terms. The rewriting rules of are

(Beta)

( a)b

→ a[b · ↑0]

(App) (Lambda)

(a b)[s] ( a)[s]

→ (a[s] b[s]) → (a[1 · s ◦ ↑succ(0)])

(Clos)

(a[s])[t]

→ a[s ◦ t]

(VarCons) 1[a · s] (Id) a[↑0]

→a →a

(Map)

(a · s) ◦ t

→ a[t] · (s ◦ t)

(IdL) (ShiftCons) (ShiftShift)

↑0 ◦ s

→

↑succ(n) ◦ (a · s) →

↑succ(n) ◦ ↑m

→

s ↑n ◦ s ↑n ◦ ↑succ(m)

(Shift1)

1 · ↑succ(0)

→ ↑0

(Shift2)

1[↑n] · ↑succ(n) → ↑n

212 D. Kesner / Theoretical Computer Science 238 (2000) 183–220

6.2. The calculi v and f
Pierre Lescanne introduces in [34] the v-calculus which preserves ÿ-strong normalization [3, 36], but is not con uent on (semi) open terms. The system is very simple as it has no composition operators for substitutions and has as few forms of substitutions as possible. As a consequence, it can be derived from our scheme in a very direct way: we have just to associate a constant to the shift-constant shift , a unary substitution constructor to the cons-function cons , and another one to the the lift-function lift , then each of the basic conditions 5, 6, 7, 8 and 9 becomes a rewrite rule; whereas conditions on substitutions in Deÿnition 3.5 can be immediately deduced from the calculus which is obtained from the basic conditions. The rewriting rules of v are

(Beta) (App) (Lambda) (FVar) (RVar) (FVarLift1) (RVarLift1) (Varshift1)

( a)b (a b)[s] ( a)[s] 1[#(a)] n + 1[#(a)] 1[⇑ (s)] n + 1[⇑ (s)] n[↑]

→ → → → → → → →

a[#(b)] (a[s] b[s])
(a[⇑ (s)]) a n 1 n[s][↑] n+1

The f-calculus was introduced in [19] in order to show preservation of ÿ-strong normalization of d and dn. It is in some sense the minimal calculus of explicit substitutions that one can expect: it correctly implements the lambda calculus and it has as few forms of substitutions and rewriting rule schemes as possible. The vcalculus can also be translated to it [19]. The rewriting rules of f are the following, where i¿0; ⇑0 (s) denotes s and ⇑n (s) denotes ⇑ (: : : ⇑(s) : : :).
n times

(Beta)

( a)b

→ a[#(b)]

(App)

(a b)[s]

→ (a[s] b[s])

(Lambda) ( a)[s]

→ (a[⇑ (s)])

(FVar)

1[#(a)]

→a

(FVarLift1) 1[⇑ (s)]

→1

(Shift)

a[⇑i (↑)][⇑i (#(b))] → a

(ShiftLift) a[⇑i (↑)][⇑i+1 (s)] → a[⇑i (s)][⇑i (↑)]

6.3. The calculi d and dn
Strongly inspired from the -calculus in [46], which was in turn inspired by [18], we proposed in [29] the d-calculus by putting together the nice properties of the three previous substitution calculi: we just use unary substitution operators for the lift-

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

213

function and the cons-function, keeping composition of substitutions which is one the main features needed to describe di erent implementations of functional programming. The rewriting rules of d are

(Beta)

( a)b

→ a[#(b)]

(App)

(a b)[s]

→ (a[s] b[s])

(Lambda) ( a)[s]

→ (a[⇑ (s)])

(Clos)

(a[s])[t]

→ a[s ◦ t]

(FVar1)

1[#(a)]

→a

(FVar2)

1[#(a) ◦ s]

→ a[s]

(FVarLift1) 1[⇑ (s)]

→1

(FVarLift2) 1[⇑ (s) ◦ t]

→ 1[t]

(Ass) (Shift1)

(s1 ◦ s2) ◦ s3 ↑ ◦ #(a)

→ s1 ◦ (s2 ◦ s3) → id

(Shift2)

↑ ◦ (#(a) ◦ s) → s

(ShiftLift1) ↑ ◦ ⇑ (s)

→ s◦ ↑

(ShiftLift2) ↑ ◦ (⇑ (s) ◦ t) → s ◦ (↑ ◦ t)

(Lift1)

⇑ (s) ◦ ⇑ (t)

→ ⇑ (s ◦ t)

(Lift2)

⇑ (s) ◦ (⇑ (t) ◦ u) → ⇑ (s ◦ t) ◦ u

(IdL)

id ◦ s

→s

(IdR)

s ◦ id

→s

(LiftId )

⇑ (id)

→ id

(Id) a[id]

→a

Note that the MapEnv rule of the -calculus in [46] #(a) ◦ s → ⇑ (s) ◦ #(a[s]) is replaced here by FVar2 and Shift2. This may be in principle super uous, but is essential to make our calculus ÿt in the scheme proposed in this paper. This di erence makes it possible to prove con uence and strong normalization of d, while con uence of is still a conjecture and -strong normalization does not hold [35]. However, the rule MapEnv is essential if one wants to recover con uence on open terms, 7 and is at the same time, as explained by [39] and [3], the cause of non termination in many
-calculi with explicit substitutions. Preservation of ÿ-strong normalization holds for d and dn (see [19] for details).

7 Indeed, the open term (( X )a)[s] reduces to both X [#(a) ◦ s] and X [⇑ (s) ◦ #(a[s])], which have no common reduct in d but can be joined in the -calculus proposed in [46].

214 D. Kesner / Theoretical Computer Science 238 (2000) 183–220

The dn-calculus is just d plus natural numbers to represent variables. It is a natural extension of d which also satisÿes the abstract properties required by the scheme. To deÿne the set of rewriting rules of dn, we add the following set of rules to those of
d:

(Varshift1) (Varshift2) (RVar) (RVarLift1) (RVarLift2) (RMap)

n[↑] n[↑ ◦ s] n + 1[#(a)] n + 1[⇑ (s)] n + 1[⇑ (s) ◦ t] n + 1[#(a) ◦ s]

→ → → → → →

n+1 n + 1[s] n n[s ◦ ↑] n[s ◦ (↑ ◦ t)] n[s]

It remains now to verify for each calculus presented above not only the existence of the Lambda; App and Beta rules, but also the basic conditions required in Deÿnitions 3.4 and the conditions on substitutions appearing in Deÿnition 3.5. We start by studying the basic conditions.

Theorem 6.3. Every calculus W ∈ { ; ⇑; ; ; f; d; dn} is strongly normalizing.

Proof. See [10, 23] for , [24] for ⇑ , [34] for v, [42] for and [19] for f. For d and dn we proceed as follows. We ÿrst deÿne a function T from objects in dn into objects in ⇑:

T(m) = m T(↑) = ↑ T(id) = id

T( a) = (T(a)) T(a b) = T(a) T(b) T(a[s]) = T(a)[T(s)]

T(⇑ (s)) = ⇑ (T(s)) T(s ◦ t) = T(s) ◦ T(t) T(#(a)) = T(a) · id

Since d ⊆ dn, then the function T also deÿnes a translation from d to ⇑ . Now, one shows that for every o ∈ d (resp. for every o ∈ dn) such that o → d o (resp. o → dn o ), then T(o)→+ ⇑ T(o ), so that strong normalization of ⇑ implies that of d and dn. For that, it is su cient to check the cases where the reduction
o → d o (resp. o → dn o ) takes place at the root of o, veriÿcations that we leave to the reader, for the other cases one proceeds by induction on the object o.

Theorem 6.4. Every calculus W ∈ { ; ⇑; ; ; f; d; dn} is con uent.
Proof. A consequence of local con uence and Theorem 6.3, by application of Newman’s lemma.

Theorem 6.5. For every calculus W ∈ { ; ⇑; ; ; f; d; dn}; all the W -normal forms are pure terms.

Proof. See [1] for , [24] for ⇑ , [34] for v, [42] for and dn we proceed as in [46]:

and [19] for f. For d

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

215

• Let a ∈ d in d-normal form. We proceed by induction on the structure of a: If a is 1 the property holds. Now, if a is an application or an abstraction, the property comes by induction hypothesis. So, let us suppose that a is equal to k[s]. If k is an application (resp. a -abstraction or a substituted term k [t]), then App (resp. Lambda and Clos) can be applied, so k is necessarily the variable 1. Let us see which are the possible cases for s. If s is #; ⇑ or id, then FVar1; FVarLift1 or Id can be applied, so s is necessarily ↑ or ◦. If s = ↑ we are done because 1[↑] is a pure term according to our deÿnition. So let us suppose that s = t ◦ u. If t is #; ⇑; ◦ or id, then FVar2; FVarLift2; Ass or IdL can be applied, so t is necessarily ↑. Let us show by induction on u that ↑ ◦ u is n(↑) for some n. If u is id; # or ⇑, then IdR; Shift1 or ShiftLift1 can be applied, so u is ↑ or u1 ◦ u2. If u = ↑ we are done because ↑ ◦ ↑ = 2 (↑). If u = u1 ◦ u2, suppose that u1 is ◦; id; # or ⇑. Then Ass; IdL; Shift2 or ShiftLift2 can be applied, so that u1 is ↑ and by induction hypothesis u2 is m(↑) for some m so that u = u1 ◦ u2 is equal to ↑ ◦ m (↑) = m+1 (↑). Now, since s = ↑ ◦ u and u = n (↑) for some n, then k[s] is equal to 1[ n+1(↑)] that is a pure term according to our deÿnition.
• Let a ∈ d in dn-normal form. We proceed by induction on the structure of a: If a is a variable the property holds. Now, if a is an application or an abstraction, the property comes by induction hypothesis. So, let us suppose that a is equal to k[s]. If k is an application (resp. a -abstraction or a substituted term k1[t]), then App (resp. Lambda and Clos) can be applied, so k is necessarily a variable n. Now, if s is #, then FVar1 or RVar applies. If s is ⇑, then FVarLift1 or RVarLift1 applies. If s is id (resp. ↑), then Id (resp. Varshift1) applies. So let us see the case s = s1 ◦ s2. If s1 is ⇑, then FVarLift2 or RVarLift2 applies. If s1 is #, then RMap applies. If s1 is id (resp. ↑), then IdL (resp. Varshift2) applies. So, s1 = s3 ◦ s4 but in that case Ass applies. We can conclude that a cannot be a term k[s] and thus we are done.

Theorem 6.6. Every W ∈ { ; ⇑; ; ; f; d; dn} veriÿes the basic conditions in Deÿnition 3.4.

Proof. Every calculus W ∈ { ; ⇑; ; ; f; d; dn} is strongly normalizing (Theorem 6.3) and con uent (Theorem 6.4). On the other hand, W -normal forms are pure terms by
Theorem 6.5 and Property 4 is evident for all the cases, so it remains now to verify
Properties 5, 6, 7, 8 and 9 in Deÿnition 3.4. • Property 5: we have 1[liftW (s)] =VarCons 1 for W ∈ { ; }, and 1[⇑ (s)] =FVarLift1 1
in ⇑; d; dn; v and f. • Property 6: We have m + 1[⇑ (s)] =RVarLift1;Clos m[s][↑] in ⇑ and dn; m + 1[⇑ (s)]
=RVarLift1 m[s][↑] in v; m + 1[⇑ (s)] = 1[↑]m−1[↑][⇑ (s)] =ShiftLift 1[↑]m−1[s][↑] = m[s][↑] in f.

216 D. Kesner / Theoretical Computer Science 238 (2000) 183–220

– For we have m + 1[1 · (s ◦ ↑)] = 1[ m(↑)][1 · (s ◦ ↑)] =Clos; Ass 1[ m(↑; ()1 · (s ◦ ↑))]. If m = 1, the

1[ 1(↑; (1 · (s ◦ ↑)))] = 1[↑ ◦ (1 · (s ◦ ↑))] =ShiftCons 1[s ◦ ↑] =Clos 1[s][↑] If m¿1, then

1[ m(↑; (1 · (s ◦ ↑)))] = 1[ m−1(↑; ↑ ◦ (1 · (s ◦ ↑)))] =ShiftCons

1[ m−1(↑; (s ◦ ↑))]

=Ass

1[ m(↑) ◦ (s ◦ ↑)]

=Clos m[s][↑]

– For :

m + 1[1 · (s ◦ ↑succ(0))]

= 1[↑succ(m−1)][1 · (s ◦ ↑succ(0))] =Clos

1[↑succ(m−1) ◦ (1 · (s ◦ ↑succ(0)))] =ShiftCons 1[↑m−1 ◦ (s ◦ ↑succ(0))]

If m = 1, then 1[↑m−1 ◦ (s ◦ ↑succ(0))] =IdL 1[s ◦ ↑succ(0)] =Clos 1[s][↑]. If m¿1, then 1[↑m−1 ◦ (s ◦ ↑succ(0))] = 1[↑succ(m−2) ◦ (s ◦ ↑succ(0))] which is equal by Clos to 1[↑succ(m−2)][s][↑succ(0)] = m[s][↑].
– For d:

m + 1[⇑ (s)] = 1[ m(↑)][⇑ (s)] =Clos 1[ m(↑) ◦ ⇑ (s)] =Ass 1[ m(↑; ⇑ (s))]

If m = 1, then 1[ 1(↑; ⇑ (s))] = 1[↑ ◦ ⇑ (s)] =ShiftLift1 1[s ◦ ↑] =Clos 1[s][↑]. If m¿1, then

1[ m(↑; ⇑ (s))] = 1[ m−1(↑; ↑ ◦ ⇑ (s))] =ShiftLift1 1[ m−1(↑; s ◦ ↑)] =Ass 1[ m−1(↑) ◦ (s ◦ ↑)] =Clos m[s][↑]
• Property 7: we have m + 1[k · id ] =RVar; Idm in ⇑; m + 1[#(k)] =RVar m in v and dn m + 1[#(k)] = 1[↑]m−1[↑][#(k)] =Shift 1[↑]m−1 = m in f. – For we have m + 1[k · id] = 1[ m(↑)][k · id] =Clos; Ass 1[ m(↑; (k · id))]. If m = 1, then 1[ 1(↑; (k · id ))] = 1[↑ ◦ (k · id )] =ShiftCons 1[id ] =VarId 1. If m¿1, then
1[ m(↑; (k · id ))] = 1[ m−1(↑; (↑ ◦ (k · id )))] =ShiftCons; ShiftId 1[ m−1(↑)] = m

– For : m + 1[b · ↑0] = 1[↑succ(m−1)][b · ↑0] =Clos; ShiftCons 1[↑m−1 ◦ ↑0] =ShiftId 1[↑m−1] = m
– For d: m + 1[#(k)] = 1[ m(↑)][#(k)] =Clos 1[ m(↑) ◦ #(k)] =Ass 1[ m(↑; #(k))]
If m = 1, then 1[ 1(↑; #(k))] = 1[↑ ◦ #(k)] =Shift1 1[id] =Id 1.

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

217

If m¿1, then
1[ m(↑; #(k))] = 1[ m−1(↑; ↑ ◦ #(k))] =Shift1 1[ m−1(↑; id )] =IdR 1[ m−1(↑)] = m
• Property 8: we have 1[k · id ] =VarCons k in ; 1[k · id ] =FVar k in ⇑; 1[#(k)] =FVar k in and f; 1[#(k)] =VarCons k in ; 1[#(k)] =FVar 1k in d and dn.
• Property 9: we have m[↑] =Varshift1 m + 1 in ⇑; ; dn, and m[↑] = 1[↑]m−1 [↑] = m + 1 in f. • For and d: If m = 1, then 1[↑] = 2. If m¿1, then m[↑] = 1[ m−1(↑)][↑] =Clos 1[ m−1(↑) ◦ ↑] =Ass 1[ m(↑)] = m + 1 • For : If m = 1, then 1[↑succ(0)] = 2. If m¿1, then m[↑] = 1[↑succ(m−2)][↑succ(0)] =Clos 1[↑succ(m−2) ◦ ↑succ(0)] =ShiftShift 1[↑0 ◦ ↑succ(m−1)] =IdL 1[↑m] = m + 1
Theorem 6.7. Every calculus W ∈ { ; ⇑; ; ; f; d; dn} veriÿes the scheme in Deÿnition 3.5.

Proof. We have to verify that for every variable m and every constructor one of
the conditions described in Deÿnition 3.5 holds. So let us analyze each constructor in
detail:
• For id: one veriÿes for W ∈ { ; ⇑; d; dn}, that m[id] =Id m, so that the ÿrst case of Deÿnition 3.5 applies for n = m; k = 0 and p = 0.
• For ◦: one veriÿes for W ∈ { ; ⇑; ; d; dn}, that for every substitutions s and t we have m[s ◦ t] =Clos m[s][t], so the ÿrst case of Deÿnition 3.5 applies for n = m; k = 0; p = 2; i1 = 1 and i2 = 2.
• For #: let us consider W ∈ {d; dn; f; v} where we have deÿned consW (a) = #(a). If m = 1, then by Deÿnition 3.4(8) we have 1[consW (k)] =W k, so that the second case of Deÿnition 3.5 applies for i = 1. Otherwise, by Deÿnition 3.4(7) we have
m + 1[#(a)]) =W m, so the ÿrst case of Deÿnition 3.5 applies for n = m; p = 0 and k = 0. • For ⇑: let us consider W ∈ {d; dn; f; v; ⇑} where we have deÿned liftW (s) = ⇑ (s). If m = 1, then by Deÿnition 3.4(5) we have 1[⇑ (s)] =W 1, so the ÿrst case of Deÿnition 3.5 applies for n = 1; p = 0 and k = 0. Otherwise, by Deÿnition 3.4(6) we have
m + 1[⇑ (s)] =W m[s][↑], so the ÿrst case of Deÿnition 3.5 applies for n = m; p = 1; i1 = 1; k = 1 and u1 = ↑. • For ·: let us consider W ∈ { ; ; ⇑}. If m = 1, then 1[a · s] =W a, so the second case of Deÿnition 3.5 applies for i = 1. Otherwise, m + 1[a · s] =W m[s] so that the ÿrst case of Deÿnition 3.5 applies for n = m; p = 1; i1 = 2 and k = 0. • For ↑: let us consider W ∈ { ; ⇑; f; d; dn; } where shiftW = ↑. Then m[↑] =W m + 1 by Deÿnition 3.4(9), so that the ÿrst case of Deÿnition 3.5 applies for n = m + 1;
p = 0 and k = 0. • For ↑k∗ : this constructor only concerns the -calculus, where m[↑k∗ ] = m + k, so
that the ÿrst case of Deÿnition 3.5 applies for n = m + k; p = 0 and k = 0.

218 D. Kesner / Theoretical Computer Science 238 (2000) 183–220
Theorem 6.8. The non-extensional and extensional versions of ; ⇑ ; ; v; d; dn and f are all con uent.
Proof. The proof comes from Theorems 6.6 and 6.7, by application of Theorems 5.18 and 5.19.
7. Conclusion
We give a general and homogeneous treatment of -calculi with explicit substitutions. Such treatment is essential in the ÿeld of implementation of functional programming because of the growing number of such calculi proposed in the literature. The major contributions of this paper can be summarized by the following points: • We propose a scheme for -calculi with explicit substitutions which allows to reason
about explicit substitutions in an abstract way. In particular, we are able to deal with many di erent calculi such as , ⇑ ; v; f; ; d; dn and s, using the same formalism and tools. • We study con uence of extensional and non-extensional -calculi with explicit substitutions, where extensionality is interpreted by Á-expansion. This reading of extensionality turns out to be much more natural and less complex than previous interpretations via Á-contraction. Our approach turns out to be also useful to derive new calculi with explicit substitutions having nice properties. In particular, d and dn were derived in [29] from the scheme using an automatic tool to perform completion. We think that an abstract approach in the spirit of the one proposed in this paper would also be useful to study con uence on open terms and preservation of strong normalization, the challenge being the deÿnition of an appropriate scheme associated to those properties. The scheme proposed in this paper could also be combined with Combinatory Reduction Systems [32, 33], generalizing in that way the formalisms in [4, 43] which are deÿned to just cover one particular explicit substitution calculus.
Acknowledgement
I would like to thank Pierre Lescanne and Gilles Dowek for interesting discussions, Roberto Di Cosmo and Pierre-Louis Curien for useful comments, and Alejandro RÃos and Paul-AndreÃ Mellies for explaining me some key points in the theory of calculi with explicit substitutions.
References
[1] M. Abadi, L. Cardelli, P.L. Curien, J.-J. LeÃvy, Explicit substitutions, J. Funct. Programming 4 (1) (1991) 375 – 416.

D. Kesner / Theoretical Computer Science 238 (2000) 183–220

219

[2] Y. Akama, On Mints’ reductions for ccc-Calculus, in: Proc. Int. Conf. on Typed Lambda Calculi and Applications (TLCA), Lecture Notes in Computer Science, vol. 664, Springer, Berlin, 1993.
[3] Z.-E.-A. Benaissa, D. Briaud, P. Lescanne, J. Rouyer-Degli, , a calculus of explicit substitutions which preserves strong normalisation, J. Funct. Programming 6 (5) (1996) 699 – 722.
[4] R. Bloo, K. Rose, Combinatory reduction systems with explicit substitution that preserve strong normalisation, in: H. Ganzinger (Ed.), Proc. 7th Internat. Conf. on Rewriting Techniques and Applications (RTA), Lecture Notes in Computer Science, vol. 1103, Springer, Berlin, 1996.
[5] D. Briaud, An explicit eta rewrite rule, in: M. Dezani-Ciancaglini, G. Plotkin (Eds.), Proc. Internat. Conf. on Typed Lambda Calculi and Applications (TLCA), Lecture Notes in Computer Science, vol. 902, Springer, Berlin, 1995.
[6] P.-L. Curien, Combinateurs CateÃgoriques, algorithmes seÃquentiels et programmation applicative, TheÂse d’etat, UniversiteÃ Paris VII, 1983.
[7] P.-L. Curien, Categorical combinators, sequential algorithms and functional programming, Progress in Theoretical Computer Science, 1st ed., Birkhauser, Basel, 1986.
[8] P.-L. Curien, R. Di Cosmo, A con uent reduction system for the -calculus with surjective pairing and terminal object, in: Leach, Monien, Artalejo (Eds.), Internat. Conf. on Automata, Languages and Programming (ICALP), Lecture Notes in Computer Science, vol. 510, Springer, Berlin, 1991, pp. 291– 302.
[9] P.-L. Curien, T. Hardin, J.-J. LeÃvy, Con uence Properties of Weak and Strong Calculi of Explicit substitutions, Technical Report 1617, INRIA-Rocquencourt, 1992.
[10] P.-L. Curien, T. Hardin, A. RÃos, Strong normalisation of Substitutions, MFCS’92, Lecture Notes in Computer Science, vol. 629, Springer, Berlin, 1992, pp. 209 – 218.
[11] N. de Bruijn, Lambda-Calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser theorem, Indag. Mat. 5 (35) (1972) 381– 392.
[12] N. de Bruijn, Lambda-Calculus notation with namefree formulas involving symbols that represent reference transforming mappings, Indag. Mat. 40 (1978) 356 – 384.
[13] R. Di Cosmo, D. Kesner, A con uent reduction for the extensional typed -calculus with pairs, sums, recursion and terminal object, in: A. Lingas (Eds.), Internat. Conf. on Automata, Languages and Programming (ICALP), Lecture Notes in Computer Science, vol. 700, Springer, Berlin, 1993.
[14] R. Di Cosmo, D. Kesner, Combining ÿrst order algebraic rewriting systems, recursion and extensional typed lambda calculi, Internat Conf. on Automata, Languages and Programming (ICALP), Lecture Notes in Computer Science, vol. 820, Springer, Berlin, 1994.
[15] R. Di Cosmo, D. Kesner, Rewriting with Extensional Polymorphic -Calculus (Extended Abstract), in: Proc. Annual Conf. of the European Association for Computer Science Logic (CSL), Lecture Notes in Computer Science, vol. 1092, Springer, Berlin, 1995.
[16] D. Dougherty, Some lambda calculi with categorical sums and products, Proc. 5th Int. Conf. on Rewriting Techniques and Applications (RTA), Lecture Notes in Computer Science, vol. 690, Springer, Berlin, 1993.
[17] G. Dowek, T. Hardin, C. Kirchner, Higher-Order Uniÿcation via explicit substitutions, Proc. Symp. on Logic in Computer Science (LICS), 1995.
[18] T. Ehrhard, Une seÃmantique cateÃgorique des types deÃpendants. Application au calcul des constructions, TheÂse de doctorat, UniversiteÃ de Paris VII, 1988.
[19] M.C.F. Ferreira, D. Kesner, L. Puel, -Calculi with Explicit Substitutions and Composition which preserve ÿ-Strong Normalization (Extended abstract), in: M. Hanus, M. RodrÃguez-Artalejo (Eds.), Proc. 5th Int. Conf. on Algebraic and Logic Programming (ALP), Lecture Notes in Computer Science, vol. 1139, Springer, Berlin, 1996, pp. 284 – 298.
[20] T. Hardin, ReÃsultats de con uence pour les reÂgles fortes de la logique combinatoire cateÃgorique et liens avec les lambda-calculs, TheÂse de doctorat, UniversiteÃ de Paris VII, 1987.
[21] T. Hardin, Á-reduction for explicit substitutions, Algebraic and Logic Programming’92, Lecture Notes in Computer Science, vol. 632, Springer, Berlin, 1992.
[22] T. Hardin, Eta-conversion for the languages of explicit substitutions, Applicable Alg. Eng. Commun. Comput. 5 (1994) 317– 341.
[23] T. Hardin, A. Laville, Proof of termination of the rewriting system subst on c.c.l., Theoret. Comput. Sci., 1986.
[24] T. Hardin, J.-J. LeÃvy, A con uent calculus of substitutions, France–Japan Artiÿcial Intelligence and Computer Science Symp., 1989.

220 D. Kesner / Theoretical Computer Science 238 (2000) 183–220
[25] T. Hardin, L. Maranget, B. Pagano, Functional back-ends and compilers within the lambda-sigma calculus, 1995, Draft.
[26] G. Huet, ReÃsolution d’eÃquations dans les langages d’ordre 1; 2; : : : ; !, TheÂse de Doctorat d’eÃtat, UniversiteÃ Paris VII, 1976.
[27] C.B. Jay, N. Ghani, The Virtues of Eta-expansion, J. Funct. Programming (5) (2) (1995) 135 –154. [28] F. Kamareddine, A. RÃos, A -calculus aÂ la de Bruijn with explicit substitutions, Proc. Int. Symp. on
Programming Language Implementation and Logic Programming, Lecture Notes in Computer Science, vol. 982, Springer, Berlin, 1995. [29] D. Kesner, Con uence properties of extensional and non-extensional -calculi with explicit substitutions, in: Harald Ganzinger (Ed.), Proc. 7th Internat. Conf. on Rewriting Techniques and Applications (RTA), Lecture Notes in Computer Science, vol. 1103, Springer, Berlin, 1996, pp. 184 –199. [30] D. Kesner, Con uence of extensional and non-extensional -calculi with explicit substitutions, Technical Report 1103, LRI, UniversiteÃ Paris-Sud, 1997. [31] D. Kesner, Reasoning about redundant patterns, J. Funct. Logic Programming, 1997, to appear. [32] J.W. Klop, Combinatory Reduction Systems, Mathematical Centre Tracts, vol. 127, CWI, Amsterdam, 1980, Ph.D. Thesis. [33] J.W. Klop, V. van Oostrom, F. van Raamsdonk, Combinatory reduction systems: introduction and survey, Theoret. Comput. Sci. 121 (1993) 279 – 308. [34] P. Lescanne, From to v, a journey through calculi of explicit substitutions, in: Ann. ACM Symp. on Principles of Programming Languages (POPL), ACM, 1994, pp. 60 – 69. [35] P. Lescanne, Personal Communication, 1996. [36] P. Lescanne, J. Rouyer-Degli, The calculus of explicit substitutions , Technical Report, INRIA, Lorraine, 1994. [37] M. Mauny, Compilation des langages fonctionnels dans les combinateurs cateÃgoriques. Applications au langage ML, TheÂse 3emÂ e cycle, UniversiteÃ Paris VII, 1985. [38] P.-A. Mellies, Four typed-lambda calculi with explicit substitutions may not terminate: the ÿrst examples, 1994, Draft. [39] P.-A. Mellies, Typed -calculi with explicit substitutions may not terminate, in: M. Dezani-Ciancaglini, G. Plotkin (Eds.), Proc. Internat. Conf. on Typed Lambda Calculi and Applications (TLCA), Lecture Notes in Computer Science, vol. 902, Springer, Berlin, 1995. [40] G. Mints, Closed categories and the theory of proofs, Zapiski Nauchnykh Seminarov Leningradskogo Otdeleniya Matematicheskogo Instituta im. V.A. Steklova AN SSSR 68 (1977) 83 –114. [41] G. Mints, Teorija categorii i teoria dokazatelstv.I, Aktualnye problemy logiki i metodologii nauky, 1979, pp. 252 – 278. [42] C. Mun˜oz, A left-linear variant of , in: M. Hanus, J. Heering, K. Meinke (Eds.), Proc. Internat. Conf. on Algebraic and Logic Programming (ALP’97), Lecture Notes in Computer Science, vol. 1298, Springer, Berlin, 1997. [43] B. Pagano, Des calculs de substitution explicite et de leur application aÂ la compilation des langages fonctionnels, TheÂse de doctorat, UniversiteÃ Pierre et Marie Curie, 1998. [44] G. Pottinger, The Church Rosser theorem for the typed lambda-calculus with Surjective pairing, Notre Dame J. Formal Logic 22 (3) (1981) pp. 264 – 268. [45] D. Prawitz, Ideas and results in proof theory, Proc. 2nd Scandinavian Logic Symp., 1971, pp. 235 – 307. [46] A. RÃos, Contribution aÂ l’eÃtude des -calculus avec substitutions explicites, TheÂse de doctorat, UniversiteÃ de Paris VII, 1993. [47] V. van Oostrom, F. van Raamsdonk, Weak orthogonality implies con uence: the higher-order case, Proc. 3rd Internat. Symp. on Logical Foundations of Computer Science, 1994, pp. 379 – 392. [48] H. Zantema, Termination on term rewriting: interpretation and type elimination, J. Symbolic Comput. 1 (17) (1994) 23 – 50.

