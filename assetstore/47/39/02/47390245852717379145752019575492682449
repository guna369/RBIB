A Universally Composable Cryptographic Library
Michael Backes, Birgit Pﬁtzmann, and Michael Waidner IBM Zurich Research Lab
January 24, 2003
Abstract
Bridging the gap between formal methods and cryptography has recently received a lot of interest, i.e., investigating to what extent proofs of cryptographic protocols made with abstracted cryptographic operations are valid for real implementations. However, a major goal has not been achieved yet: a soundness proof for an abstract crypto-library as needed for the cryptographic protocols typically proved with formal methods, e.g., authentication and key exchange protocols. Prior work that directly justiﬁes the typical Dolev-Yao abstraction is restricted to passive adversaries and certain protocol environments. Prior work starting from the cryptographic side entirely hides the cryptographic objects, so that the operations are not composable: While secure channels or signing of application data is modeled, one cannot encrypt a signature or sign a key.
We make the major step towards this goal: We specify an abstract cryptolibrary that allows composed operations, deﬁne a cryptographic realization, and prove that the abstraction is sound for arbitrary active attacks in arbitrary reactive scenarios. The library currently contains public-key encryption and signatures, nonces, lists, and application data.
The proof is a novel combination of a probabilistic, imperfect bisimulation with cryptographic reductions and static information-ﬂow analysis.
1 Introduction
We present the ﬁrst crypto-library with composable operations for which the gap between an abstract and a cryptographic version can be bridged for arbitrary active attacks, and within the context of arbitrary surrounding interactive protocols. This holds independently of the goals that one wants to prove about the surrounding protocols.
Why does one want to reconcile abstractions and cryptography? For about 20 years, formal and cryptographic methods for proving security protocols have coexisted, and each community was busy solving its own problems. For the formalmethods community, this main goal was to express security goals, and eﬃcient proof techniques that allow full automation even for inﬁnite state spaces. The abstraction from cryptography was essentially always the Dolev-Yao model. Here cryptographic operations, e.g., E for encryption and D for decryption, are considered as operators in a term algebra where only certain cancellation rules hold. For instance, encrypting a message m twice does not yield another message from the basic message space but the term E(E(m)). A typical cancellation rule is D(E(m)) = m for all m. In the cryptographic community, the main goal was to deﬁne the security of many types of cryptographic algorithms and protocols against the most powerful active attacks, but within polynomial-time restrictions, and to prove that certain realizations, typically number-theoretic, oﬀer this security under certain
1

assumptions. However, the cryptographic deﬁnitions are at a ﬁrst glance quite unrelated to the abstractions used in formal methods. On the other hand, for larger cryptographic protocols, the deﬁnitions, and even more the typical computational reduction proofs, are very long and error-prone, so that abstractions would really be useful.
Our work is the major step in combining the advantages of both approaches: For the ﬁrst time we can show that an abstract library consisting of Dolev-Yao-style primitives is safely realized by a cryptographic implementation under arbitrary active attacks, in arbitrary protocol contexts, and for arbitrary security properties, in particular conﬁdentiality, authenticity, and other integrity properties. The library contains public-key encryption and digital signatures, nonces, list operations, and arbitrary application data. Its real version is built from arbitrary, cryptographically secure public-key encryption and signature systems, enhanced by additional operations like tagging and randomization. The additional operations do not cost much eﬃciency compared with the underlying schemes. Thus protocol design via the abstraction does not lead to eﬃciency problems in the resulting protocols.
To model the active attacks, and also surrounding interactive protocols about which the protocol designer knows nothing a priori, we work in a reactive setting. Thus “our Dolev-Yao model” is not just an algebra, but a stateful system with possible operations for honest participants and adversaries, depending on prior cryptographic operations and network actions. In this sense it corresponds more to “the CSP Dolev-Yao model” or “the Strand-space Dolev-Yao model” etc., which also have models of participants, interaction, and adversary besides the underlying cryptographic term algebras.
The notion that the real crypto-library is “as good as” the abstract one in all contexts and for all security goals is given by simulatability. Brieﬂy this means that everything that can happen to users of the real crypto-library, in the presence of arbitrary polynomial-time attackers that can corrupt their machines, modify messages on insecure channels, inﬂuence the scheduling, and inﬂuence the users themselves, can also happen to the same users with the abstract crypto-library, where attacks are much more restricted. Existing composition and preservation theorems for simulatability give us exactly the properties we want: First, if we design a protocol with the abstract crypto-library, and then plug the real crypto-library in, the entire real protocol is as good as the abstract one in the same simulatability sense. Secondly, if we prove speciﬁc security properties for the abstract protocol, they also hold for the real protocol.
Related work The Dolev-Yao model is from [16]. Cryptographic deﬁnitions of public-key encryption and signature schemes were developed in [38, 20, 15, 21]. First automated proof tools based on the Dolev-Yao model were presented in [30, 28, 24]. Early examples of the large body of work of embedding the Dolev-Yao model in standard tools are [1, 27]. Simulatability, the basic notion for comparing an abstract and a real system, was ﬁrst invented for multi-party function evaluation [37, 19, 7, 29, 9], i.e., systems with only one initial input set and only one output set. An extension to a reactive scenario, where participants can make new inputs many times, e.g., start new sessions like key exchanges, was ﬁrst fully deﬁned in [33], with extensions to asynchronous systems in [34, 10]. We use the IO-automata model of Pﬁtzmann/Waidner. First examples of tool-supported proofs in that model exists [6, 5], using PVS [31]. Earlier, but less complete or less abstract reactive simulatability notions exist in [26, 23].
The reactive simulatability papers already had the goal of bridging the gap between abstract and concrete cryptographic systems. However, so far they abstracted from cryptography so completely that cryptographic operations cannot be
2

composed. For instance, [34] models secure channels. While these are an important high-level security primitive also in the formal-methods literature, one cannot express many lower-level protocols with them alone. Models for low-level systems like signatures exist too, e.g., in [10], but those simply store what application data has already been signed, without the possibility to sign a signed message again or a key. One cannot simply extend this by allowing the export of keys and signatures as application data because that would immediately destroy the simulatability.
Another approach at bridging the abstraction gap started with the full DolevYao model with composable algorithms, at least for symmetric encryption and synchronous protocols [3, 2]. There, however, the adversary is restricted to passive eavesdropping. Consequently, it was not necessary to choose a reactive model of a system and its honest users, and the security goals are all formulated as indistinguishability, i.e., if two abstract systems are indistinguishable by passive adversaries, then so are two corresponding real systems. There are no theorems about composition or property-preservation from the abstract system to the real system yet in this model. We pay for the greater applicability of reactive simulatability and for allowing active attacks by a much more complicated proof.
Some further approaches for special security goals or primitives are [36, 22, 25].
2 Overview of the Simulatable Cryptographic Library
In this section, we give an overview of our abstract and real crypto-library, in particular their relations to the standard Dolev-Yao model and standard cryptographic deﬁnitions, respectively. To understand some design decisions, a basic understanding of simulatability is important. Thus we ﬁrst brieﬂy sketch the deﬁnitions from [34].
2.1 Overview of Simulatability
A system consists of several possible structures. A structure consists of a set Mˆ of connected correct machines and a subset S of free ports, called speciﬁed ports. In a standard cryptographic system, the structures are derived from one intended structure and a trust model. The trust model consists of an access structure ACC and a channel model χ. Here ACC contains the possible sets H of indices of uncorrupted machines (among the intended ones), and χ designates whether each channel is secure, authentic (but not private) or insecure. Each structure is complemented to a conﬁguration by adding an arbitrary user machine H and adversary machine A. H connects only to ports in S and A to the rest, and they may interact. The general scheduling model in [34] gives each connection c (from an output port c! to an input port c?) a buﬀer, and the machine with the corresponding clock port c ! can schedule a message when it makes a transition. In real asynchronous cryptographic systems, network connections are typically scheduled by A. Thus a conﬁguration is a runnable system, i.e., one gets a probability space of runs. Views of individual machines in these runs are the restriction to all in- and outputs this machine sees and its internal state.
Simulatability essentially means that whatever can happen to certain users in the real system can also happen to the same users in the ideal (abstract) system: For every structure struc1 of the real system, every user H, and every adversary A1 there exists an adversary A2 on a corresponding ideal structure, struc2, such that the view of H in the two conﬁgurations is indistinguishable. Indistinguishability is a well-deﬁned cryptographic notion from [38]. This is shown in Figure 1. For
3

Figure 1: Overview of the simulatability deﬁnition. The view of H must be indistinguishable in the two conﬁgurations. In this example, H = {1, 2}.
the crypto-library, we even show blackbox simulatability, where A2 consists of a simulator Sim depending only on struc1 and using A1 as a blackbox submachine.
In a typical ideal system, each structure contains only one machine TH called trusted host. Corresponding structures are designated by a function f . For standard cryptographic systems, f maps a real structure to a trusted host with the same set S of speciﬁed ports, so that the same honest users can connect.
2.2 Overview of the Ideal System
An ideal (abstract) crypto-library oﬀers its users abstract cryptographic operations, such as commands to encrypt or decrypt a message, to make or test a signature, and to generate a nonce. All these commands have a simple, deterministic semantics. In a reactive scenario, this semantics is based on state, e.g., of who already knows which terms. We store state in a “database”. Each entry has a type (e.g., “signature”), and pointers to its arguments (e.g., a key and a message). This corresponds to the top level of a Dolev-Yao term; an entire term can be found by following the pointers. Further, each entry contains handles for those participants who already know it. Thus the database index and these handles serve as an inﬁnite, but efﬁciently constructible supply of global and local names for cryptographic objects. However, most libraries have export operations and leave message transport to their users (“token-based”). An actual implementation of the simulatable library might internally also be structured like this, but higher protocols are only automatically secure if they do not use this export function except via the special send operations.
The ideal crypto-library does not allow cheating. For instance, if it receives a command to encrypt a message m with a certain key, it simply makes an abstract database entry for the ciphertext. Another user can only ask for decryption of this ciphertext if he has handles to both the ciphertext and the secret key. Similarly, if a user issues a command to sign a message, the ideal system looks up whether this user should have the secret key. If yes, it stores that this message has been signed with this key. Later tests are simply look-ups in this database.
A send operation makes an entry known to other participants, i.e., it adds handles to the entry. Recall that our model is an entire reactive system like “the CSP Dolev-Yao model” and therefore contains an abstract network model. We oﬀer three types of send commands, corresponding to three channel types {s, a, i}, meaning secure, authentic (but not private), and insecure. The types could be extended.
As to the operations, the main diﬀerences between our ideal crypto-library and the standard Dolev-Yao model are the following. Some of them already exist in prior extensions of the Dolev-Yao model.
• Signature schemes are not “inverses” of encryption schemes.
• Secure encryption schemes are necessarily probabilistic, and typically so are secure signature schemes. Hence if the same message is signed or encrypted
4

several times, we have to distinguish the versions, i.e., we make diﬀerent database entries. For each entry, we only need to store its type (e.g., “signature”) and pointers to its arguments (e.g., a key and a message). This corresponds to the top level of a Dolev-Yao-like term.
• Secure signature schemes often have memory. The standard deﬁnition [21] does not even exclude that one signature divulges the entire history of messages signed before. We have to restrict this deﬁnition, but will allow a signature to divulge the number of previously signed messages, so that we include the most eﬃcient provably secure schemes under classical assumptions like hardness of factoring [21, 11, 12].1
• We cannot (easily) allow participants to send secret keys around because then the simulation is not always possible.2 Fortunately, for public-key cryptosystems this is not needed in standard protocols.
• Encryption schemes cannot keep the length of arbitrary cleartexts entirely secret. Typically one can even see the length quite precisely because message expansion is minimized. Hence we also allow this in the ideal system. A ﬁxedlength version would be an easy addition to the library, or can be implemented on top of the library by padding to a ﬁxed length.
• Adversaries may include incorrect messages in encrypted parts of a message which the current recipient cannot decrypt, but may possibly forward to another recipient who can, and will thus notice the incorrect format. Hence we also allow certain “garbage” terms in the ideal system.
Moreover, our ideal crypto-library contains explicit bounds on message lengths and the number of accepted inputs, so that a polynomial-time real system can simulate it correctly. In practice one would typically choose these bounds so large that they are not reached under ordinary circumstances.
2.3 Overview of the Real System
The real crypto-library oﬀers its users the same commands as the ideal one, i.e., honest users operate on cryptographic objects via handles. This is actually quite close to standard APIs for real implementations of crypto-libraries that include key storage. The database of the real system contains real cryptographic keys, ciphertexts, etc., and sending a term on an insecure channel releases the actual bitstring to the adversary, who can do with it what he likes. The adversary can also insert arbitrary bitstrings on non-authentic channels. The simulatability proof will show that nevertheless, everything a real adversary can achieve can also be achieved by an adversary in the ideal system, or otherwise the underlying cryptography can be broken.
We base the implementation of the commands on arbitrary secure encryption and signature systems according to standard cryptographic deﬁnitions. However, we “idealize” the cryptographic objects and operations by measures similar to robust protocol design [4]. Some of these measures have already been used in prior, specialized designs.
• All objects are tagged with a type ﬁeld so that, e.g., signatures cannot also be acceptable ciphertexts or keys.
1Memory-less schemes exist with either lower eﬃciency or based on stronger assumptions (e.g., [18, 14, 17]). We could add them to the library as an additional primitive.
2The primitives become “committing”. This is well-known from individual simulation proofs. It is also the reason why the approach in [3], developed for symmetric cryptosystems, is hard to extend to active attacks.
5

• Several objects are also tagged with their parameters, e.g., signatures with the public key used.
• Randomized operations must be randomized completely. For instance, as the ideal system represents several signatures under the same message with the same key as diﬀerent, the real system has to guarantee that they will be diﬀerent, except for small error probabilities. Even probabilistic encryptions are randomized additionally because they are not always suﬃciently random for keys chosen by the adversary.
The reason to tag signatures with the public key needed to verify them is that the usual deﬁnition of a secure signature scheme does not exclude “signature stealing:” Let (skh , pkh ) denote the key pair of a correct participant. With ordinary signatures an adversary might be able to compute a valid key pair (ska , pka ) such that signatures that pass the test with pkh also pass the test with pka . Thus, if a correct participant receives an encrypted signature on m, it might accept m as being signed by the adversary, although the adversary never saw m. It is easy to see that this would result in protocols that could not be simulated. (An example is given in [32], Section 6.4.) Our modiﬁcation prevents this anomaly.
For the additional randomization of signatures, we include a random string r in the message to be signed. Alternatively we could replace r by a counter, and if a signature scheme is strongly randomized already we could omit r.
Ciphertexts are randomized by including the same random string r in the message to be encrypted and in the ciphertext. The outer r prevents collisions among ciphertexts from honest participants, the inner r ensures continued non-malleability.
3 Notation
We mostly use a straight font for machines, algorithms, functions, and constants; italics for sets and other variables, and a calligraphic font for T YPES and Index sets.
We write “:=” for deterministic and “←” for probabilistic assignment, and “←R” for uniform random choice from a set. In an algorithm X executed by a machine M and with a named output m, “M returns n” means that M outputs m := n and stops executing X. We usually omit the return statement if an execution path ends by returning a variable m as the output m. By x := y++ for integer variables x, y we mean y := y + 1; x := y.
A function g : N → R is called negligible, written g ∈ NEGL, if for all positive polynomials Q, ∃k0∀k ≥ k0: |g(k)| ≤ 1/Q(k).
We make the following assumptions about the representation of structured data types.
• For reasons of distinguishability, we use a type system consisting of abstract datatypes N AT (“naturals”), HN DS (“handles”), IN DS (“indices”), BOOL (“Boolean”), ERR (“error”), CHARST R (“character strings”), BIT ST R (“bitstrings”), and LIST (“lists”). The union of all these datatypes is denoted as T YPES.
• The types N AT , HN DS, and IN DS are isomorphic to N = {1, 2, . . .}, and we write elements and operations as for natural numbers. N AT is extended to N AT 0, which is isomorphic to N0 = N ∪ {0}.
• We write BOOL = {true, false} and ERR = {↓}. CHARST R is isomorphic to Σ+ for some ﬁnite alphabet Σ ⊇ {a, . . . , z} ∪ {0, 1} with ↓ ∈ Σ, and BIT ST R isomorphic to {0, 1}∗.
6

• The type LIST contains lists of elements of {0, 1}∗. The empty list is written (). We write a list of x1, . . . , xh as (x1, . . . , xj). If l = (x1, . . . , xj) then l[i] := xi for 1 ≤ i ≤ j, and l[i] := ↓ for i > j. By “adding an element to a list” and similar formulations we mean appending it at the end.
• The ranges and domains of all algorithms and functions implicitly contain the error element ↓ of type ERR. If ↓ is used as an argument for an algorithm, function or as a selector for a datatype (e.g., as an index of a list element), the result is always ↓. However, comparisons “if v = ↓” return true or false.
• In order to built up lists of elements of our abstract datatypes, and to apply cryptographic operations to them (again with the exception of ↓), we assume that elements of T YPES \ ERR are uniquely encoded into the set {0, 1}∗. The exact encoding does not matter, but if a function is eﬃciently computable for an abstract datatype, it must be eﬃciently computable also on the encoding. In particular, this comprises element retrieval for lists, comparisons and algorithms on natural numbers etc.
• The length |w| of w ∈ {0, 1}∗ is, as usual, the unique k with w ∈ {0, 1}k. The length |w| of w ∈ T YPES \ ERR for a given encoding en is deﬁned as |w| := |en(w)|. We require the length of the encoding of a list l to depend only on the length of its encoded arguments: there is a function list len such that |(x1, . . . , xj)| = list len(x1, . . . , xj) ≥ |x1| + . . . + |xj| for all j ∈ N0 and all x1, . . . , xj ∈ T YPES \ ERR.
• By a “database” D we mean a ﬁnite set of mappings from ﬁnite subsets of CHARST R to T YPES ∪ {0, 1}∗. These mappings are called tuples and their arguments are called attributes. With t.a we mean the result of t ∈ D on argument a ∈ Σ∗. As usual, t.a = ↓ means that t.a is undeﬁned.
We use D :⇐ t as abbreviation of D := D ∪ {t}. We often write tuples as lists of assignments, like (a1 := x1, . . . , ak := xk), and if the attributes and their order are clear from the context we just write (x1, . . . , xk).
We will use some relational-database notation:
– If P (A) is a logical condition with the attributes in A as free variables then we deﬁne the selection σP (A)(D) as the set of all t ∈ D whose actual attribute values satisfy P (A). Let D[P (A)] := t if σP (A)(D) = {t}, and D[P (A)] := ↓ if |σP (A)(D)| = 1.
– A key attribute is an attribute a such that t.a is deﬁned (= ↓) and unique for all t ∈ D. If we designate a speciﬁc key attribute a as a primary key attribute then we write D[x] instead of D[a = x].

4 Ideal System for a Cryptographic Library
We now present the ideal crypto-library. We include all deﬁnition details like ports and structures as needed for the notion of simulatability, because the ideal system is the abstract cryptographic module based on which protocols should be proved in future work. Hence it has to be deﬁned precisely, and encoded faithfully into proof tools.

4.1 Structures

Given a number n of participants and a tuple L of parameters (mainly about lengths) discussed in Section 4.2, the ideal system is of the form

Sys

cry,id n,L

=

{({THH},

SH)

|

H

⊆

{1, .

.

.

, n}},

7

where H denotes the set of honest participants (i.e., the access structure makes no

restriction on the possible corruptions).

Actually,

we

consider

two

versions

Sys

cry,id,stan n,L

and

Sys

cry,id,loc n,L

called

stand-alone

and localized; in the former, in- and outputs for the users are scheduled by the ad-

versary, in the latter locally (i.e., the crypto library is then used as local subroutines

by protocols using it). The ports of THH intended for the users are, respectively,

userportsHstan := {inu ?, outu ! | u ∈ H};

userportsHloc := {inu ?, outu !, outu ! | u ∈ H}.
Intuitively each u represents one user. The ports of the users which connect to those ports are, respectively,

SHstanc := {inu !, outu ? | u ∈ H}; SHlocc := {inu !, outu ?, inu ! | u ∈ H}. The localized version is shown in Figure 2.3

inu! H inu ! outu? SH • • •
inu? outu ! outu!
THH

outa! ina?

net_idu,v,x for (u, v, x) ∈ ch_honest
Figure 2: Ports of THH; localized version. Dotted arrows are clock connections; they end at buﬀers, which are not shown.
For the adversary, THH mainly oﬀers two ports ina? and outa!. Furthermore, to allow the adversary to schedule messages even on secure channels, there are abstract versions of these secure channels. We use the following abbreviations:
ch honest := {(u, v, x)|u, v ∈ H ∧ x ∈ {s, a}}; ch from adv := {(u, v, x)|v ∈ H ∧ (u ∈ H ∨ x = i)};
ch to adv := {(u, v, x)|u ∈ H ∧ (v ∈ H ∨ x ∈ {a, i})}.
Then for xtin{stan, loc}:
PortsTHtH := userportsHt ∪ {ina?, outa!, outa !} ∪ {net idu,v,x !, net idu,v,x ? | (u, v, x) ∈ ch honest }.
4.2 Lengths and Bounds
We already mentioned that we do not assume encryption systems to hide the length of the message. Furthermore, higher protocols may need to know the length of certain terms even for honest participants. Thus the trusted host is parameterized with
3The set SH of speciﬁed ports is deﬁned as the free ports at the end of the buﬀers. Hence here it is easier to show its complement, SHc , which are the ports that H may have to connect to THH.
8

certain length functions denoting the length of a corresponding value in the real system. In abbreviated notation, these functions are data len∗(l), list len∗(l1, . . . , lj) for all j ∈ N0, nonce len∗(k), pks len∗(k), sig len∗(k, l), pke len∗(k), and enc len∗(k, l). The domain of each parameter is N0, of each result N, and k denotes the security parameter, while l and the li’s are lengths of messages.
Furthermore, to allow a polynomial-time system to be as secure as this ideal system, we use functions max len(k), max skc(k), and max in(k) bounding the length of messages, the number of signatures per key, and the number of inputs at each port of correct real machines, respectively. To avoid unrealistic special cases, we require for all k ∈ N that max len(k) > 3; nonce len∗(k), pks len∗(k), pke len∗(k) < max len(k); max skc(k) ≤ max in(k); and |i| < max len(k) for all i ∈ N with i ≤ max skc(k).
The tuple of all these functions is the system parameter L. Each function must be bounded by a (multivariate) polynomial and eﬃciently computable.
4.3 States
The state of THH consists of a database D and variables size, curhndu for u ∈ H ∪ {a}, and stepsp? for each input port p?.
4.3.1 Database D
The main data structure of THH is a database D. The entries of D are abstract representations of the data produced during a system run, together with the information on who knows these data. Each entry in D has attributes
(ind , type, arg, hnd u1 , . . . , hnd um , hnd a, len)
where H = {u1, . . . , um}. For each tuple x ∈ D:
• x.ind ∈ IN DS, called index, consecutively numbers all entries in D. We use it as a primary key attribute, i.e., we will write D[i] for D[ind = i].
• x.type ∈ typeset := {data, list, nonce, ske, pke, enc, sks, pks, sig, garbage} identiﬁes the type of x. Further extensions of the library can extend this set.
• x.arg = (a1, a2, . . . , aj) is a possibly empty list of arguments. Many values ai are indices of other entries in D and thus in IN DS. We sometimes distinguish them by a superscript “ind.”4 The argument domains are deﬁned implicitly by the commands, see Section 4.5. They are easy to look up there because most types of entry are only constructed with on command; exceptions are explicitly mentioned there.
• x.hnd u ∈ HN DS ∪ {↓} for u ∈ H ∪ {a} identiﬁes how u knows this entry. The value a represents the adversary, and x.hnd u = ↓ indicates that u does not know this entry. A value x.hnd u = ↓ is called the handle for u to entry x. We always use a superscript “hnd” for handles and usually denote a handle to an entry D[i] by ihnd.
• x.len ∈ N0 denotes the “length” of the entry.5
4This is similar to the Dolev-Yao model: The arguments are just listed, not evaluated as in a real system.
5It is computed by THH using the given length functions. For most types, this length could be recomputed when it is needed instead of storing it, but not for the type garbage.
9

4.3.2 Conventions about Indices
Initially, D is empty. THH keeps a variable size of type IN DS denoting the current number of elements in D. New entries x always receive x.ind := size++ (increment, then assign), and x.ind is never changed. Thus, ind is indeed a key attribute.

4.3.3 Conventions about Handles

For each u ∈ H ∪ {a}, THH maintains a counter curhndu (current handle) of

type HN DS initialized with 0, and each new handle for u will be chosen as

ihnd := curhndu ++. Thus handles are uniquely and consecutively assigned, i.e.,

D always fulﬁlls the invariant |σhndu =ihnd (D)| = 0 for all ihnd

that |σhndu > curhndu

=ihnd (D)| . We call

= 1 for each ihnd ≤ curhndu , and this fact “handle uniqueness.”

The algorithm ind2hndu (with side eﬀect) denotes that THH determines a handle

ihnd for u to an entry D[i]: On input i ∈ IN DS, it returns D[i].hnd u if it is not

↓; else it sets D[i].hnd u := curhndu ++ and returns D[i].hnd u . We extend it by ind2hndu(i) := i for i ∈ IN DS. For lists, the algorithm ind2hnd∗u applies ind2hndu to each element.

4.3.4 Input Counters
For each of its input ports p?, THH maintains a counter stepsp? ∈ N0 initialized with 0 for the number of inputs at that port. These counters are used to ensure polynomial runtime of THH. Hence for each port, there is a bound boundp? that the counter must not exceed.6 This bound is max in(k) for all ports except for ina?, where it can be max ina(k) := 10n2max in(k)max len(k) or any larger polynomial. (This ﬁts a real system with the bound max in(k) for all ports.)

4.4 Overview of Possible Inputs
Each input c at a port inu ? with u ∈ H ∪ {a} should be a list (cmd , x1, . . . , xj). We usually write it
y ← cmd (x1, . . . , xj)
with a variable y designating the result that THH returns at outu !. The value cmd should be a command string: Let
basic cmds := {get type, get len, store, retrieve, list, list proj, gen nonce, gen sig keypair, sign, verify, pk of sig, msg of sig, gen enc keypair, encrypt, decrypt,
pk of enc};
send cmds := {send s, send a, send i};
adv local cmds := {adv garbage, adv invalid ciph, adv transform sig, adv parse};
adv send cmds := {adv send s, adv send a, adv send i}.
Then cmd must be in basic cmds ∪ send cmds if u = a, and otherwise from basic cmds ∪ adv local cmds ∪ adv send cmds. Each basic command represents one cryptographic operation; arbitrary “terms” similar to the Dolev-Yao model can be built up or decomposed by a sequence of commands. The sets of commands can be enlarged by further extensions of the library. The permitted argument numbers j and exact domains are deﬁned in Section 4.5. Membership in all domains is easily veriﬁable.
The inputs at a port net idu,v,x ? come from THH itself; each one is simply a message index l ind.
6For simulatability, we do not need THH to be polynomial-time; we only need the counters and bounds for the user ports inu ?.

10

4.5 Inputs and their Evaluation
We now deﬁne the precise inputs and how THH evaluates them based on its abstract state. The main ideas were already explained in Section 2.2. The following more speciﬁc design decisions were made, mainly to simplify the system:
• There are commands to store real-world messages in the library and to retrieve them by a handle. Thus other commands can assume that everything is addressed by handles.
• We only allow lists to be signed and transferred, because the list-operation is a convenient place to concentrate all veriﬁcations that no secret items are put into messages.
• THH always oﬀers all types of channels for all participants. Otherwise we would need many diﬀerent trusted hosts. Many real protocols using cryptography should only use secret and authentic channels for key distribution at the beginning. As the channel type is part of the send-command name, syntactic checks can ensure that a protocol designed with the ideal crypto-library fulﬁlls such requirements.
4.5.1 General Conventions
Upon each input at a port p?, the trusted host THH ﬁrst increments the counter stepsp?. The machine model in [34] is such that only non-empty inputs count, as only for those a Turing step is needed in the Turing machine realization.
Furthermore, the machine model contains length functions which allow to bound how many bits of input are accepted at each port, depending on the current state. The value 0 for port p? means that no input is accepted (again without a Turing step). Once a counter stepsp? has reached its bound boundp?, the length function for this port is always zero.
Otherwise, the length functions are determined by the domain speciﬁed for each input in the part “for . . . ” after the parameter list below. The domain of each parameter with the superscript hnd is HN DS, and the handle must be assigned at the time of execution, i.e., ≤ curhndu in the given state. An input is well-formed if it is in the correct domain (at the time of execution). If an input is not well-formed, which is easily veriﬁable, THH aborts the transition without further action. (But the counter stepsp? has been incremented.) The overall length function for each port p? in each state is the maximum of the possible lengths of well-formed inputs at that port in that state; it can easily be computed.
The localized version THlHoc accompanies every output at a port outu ! for u ∈ H ∪ {a} by an output 1 at outu !, i.e., it schedules that output immediately, the stand-alone version THsHtan only for u = a.
From now on, we only need to deﬁne well-formed inputs further.
4.5.2 Basic Commands
In this section we deﬁne how THH evaluates a command from basic cmds, entered at a port inu ? with u ∈ H ∪ {a}. These commands are local, i.e., they produce a result at port outu ! and possibly update the database D, but do not produce outputs at other ports. They also do not touch handles for participants v = u.
Type and length queries
• Type query: t ← get type(xhnd).
11

Set t := D[hnd u = xhnd].type.7
• Length query: l ← get len(xhnd). Set l := D[hnd u = xhnd].len.
Storing and retrieving data THH stores a string and gives u a handle to it, respectively retrieves a previously stored string.
• Storing: mhnd ← store(m), for m ∈ BIT ST R with |m| ≤ max len(k). If i := D[type = data ∧ arg = (m)].ind = ↓ then return mhnd := ind2hndu(i).8 Otherwise if data len∗(|m|) > max len(k) return ↓. Else set mhnd := curhndu ++ and
D :⇐ (ind := size++, type := data, arg := (m), hnd u := mhnd, len := data len∗(|m|)).
• Retrieval: m ← retrieve(mhnd). m := D[hnd u = mhnd ∧ type = data].arg[1].9
Lists Entries that can be sent to other players, like data, ciphertexts, and public keys, can be combined into lists. Lists cannot include secret keys because no information about those must be given away. The following commands create a list and determine the i-th element in a list.
• Generate a list: lhnd ← list(xh1nd, . . . , xhjnd), for 0 ≤ j ≤ max len(k). Let xi := D[hnd u = xhi nd].ind for i = 1, . . . , j. If any D[xi].type ∈ {sks, ske}, set lhnd := ↓. If l := D[type = list ∧ arg = (x1, . . . , xj)].ind = ↓, then return lhnd := ind2hndu(l). Otherwise, set length := list len∗(D[x1].len, . . . , D[xj].len) and return ↓ if length > max len(k). Else set lhnd := curhndu ++ and
D :⇐ (ind := size++, type := list, arg := (x1, . . . , xj), hnd u := lhnd, len := length).
• i-th projection: xhnd ← list proj(lhnd, i), for 1 ≤ i ≤ max len(k). If D[hnd u = lhnd ∧ type = list].arg = (x1, . . . , xj) with j ≥ i, then xhnd := ind2hndu(xi), otherwise xhnd := ↓.
Nonces In reality nonces are randomly chosen words, used, e.g., to verify freshness of messages. THH just creates a new entry.
• Generation: nhnd ← gen nonce(). Set nhnd := curhndu ++ and
D :⇐ (ind := size++, type := nonce, arg := (), hnd u := nhnd, len := nonce len∗(k)).
7Note that u cannot get the type of entries he does not know because D∗[hnd u = xhnd] = ↓ implies t = ↓.
8Hence if the same string m is stored twice, THH reuses the ﬁrst result. In general THH ensures that two identical pieces of data get the same index. However, encryption or signing always create new entries, because these operations are indeterministic.
9This implies that mhnd was created by a store command, as no other command creates entries with type = data. Thus only explicitly stored data can be retrieved and not, e.g., keys or ciphertexts.
12

Signatures This comprises operations for key generation, signature generation and veriﬁcation, and retrieval of signature components.
• Key generation: (skhnd, pkhnd) ← gen sig keypair(). Set skhnd := curhndu ++; pkhnd := curhndu ++ and
D :⇐ (ind := size++, type := sks, arg := (0), hnd u := skhnd, len := 0);
D :⇐ (ind := size++, type := pks, arg := (), hnd u := pkhnd, len := pks len∗(k)). The argument of the secret-key entry is a counter initialized with 0.
• Signature generation: shnd ← sign(skhnd, lhnd). Let sk := D[hnd u = skhnd ∧ type = sks].ind and l := D[hnd u = lhnd ∧ type = list].ind . If either of these is ↓ or if length := sig len∗(k, D[l].len) > max len(k), return ↓. Also return ↓ if D[sk ].arg[1] ≥ max skc(k) and u = a. Otherwise, set shnd := curhndu ++, pk := sk + 1 (recall that key pairs get successive indices), c := D[sk ].arg[1]++, and
D :⇐ (ind := size++, type := sig, arg := (pk , l, c), hnd u := shnd, len := length).10
• Signature veriﬁcation: v ← verify(shnd, pkhnd, lhnd). Let s := D[hnd u = shnd ∧ type = sig].ind . If s = ↓ then return ↓. Otherwise, let (pk , l, c) := D[s].arg. If D[pk ].hnd u = pkhnd or D[l].hnd u = lhnd, then v := false, else v := true.11
• Public-key retrieval: pkhnd ← pk of sig(shnd). Let pk := D[hnd u = shnd∧type = sig].arg[1] and return pkhnd := ind2hndu(pk ).
• Message retrieval: lhnd ← msg of sig(shnd). Let l := D[hnd u = shnd ∧type = sig].arg[2] and return lhnd := ind2hndu(l).12,13
Public-key encryption This comprises operations for key generation, encryption, decryption, and retrieval of the public key from a ciphertext.
• Key generation: (skhnd, pkhnd) ← gen enc keypair(). Sets skhnd := curhndu ++, pkhnd := curhndu ++, and
D :⇐ (ind := size++, type := ske, arg := (), hnd u := skhnd, len := 0);
D :⇐ (ind := size++, type := pke, arg := (), hnd u := pkhnd, len := pke len∗(k)).
• Encryption: chnd ← encrypt(pkhnd, lhnd). Let pk := D[hnd u = pkhnd ∧ type = pke].ind and l := D[hnd u = lhnd ∧ type = list].ind and length := enc len∗(k, D[l].len). If length > max len(k) or pk = ↓ or l = ↓, then return ↓. Else set chnd := curhndu ++ and
D :⇐ (ind := size++, type := enc, arg := (pk , l), hnd u := chnd, len := length).14
10This type also exists with c = false due to the command adv transform sig. 11Given the next two commands, signature veriﬁcation is redundant. This works because for received real alleged signatures, the type sig and the arguments are only assigned after cryptographic veriﬁcation; otherwise the type becomes garbage. 12This command implies that real signatures must contain the message, which may seem ineﬃcient. However, the simulator needs this to translate signatures from the adversary into abstract ones. Thus we also oﬀer message retrieval to honest users so that they need not send the message separately. 13A similar operation for retrieving the counter is only for the adversary because not all signature schemes allow it. 14This type also has a second format due to the command adv invalid ciph.
13

• Decryption: lhnd ← decrypt(skhnd, chnd). Let sk := D[hnd u = skhnd ∧ type = ske].ind and c := D[hnd u = chnd ∧ type = enc].ind . Return ↓ if c = ↓ or sk = ↓ or pk := D[c].arg[1] = sk + 1 or l := D[c].arg[2] = ↓ (as a result of the command adv invalid ciph). Else return lhnd := ind2hndu(l).
• Public-key retrieval: pkhnd ← pk of enc(chnd). Let c := D[hnd u = chnd ∧ type = enc].ind . If c = ↓, return ↓. Otherwise, let pk := D[c].arg[1] and return pkhnd := ind2hndu(pk).
4.5.3 Local Adversary Commands
The following commands are also local, but, as deﬁned in Section 4.4, only wellformed at the port ina?. Hence they are not available as commands for the honest users in the real system. They model tolerable imperfections of the real system, i.e., actions that may be possible in real systems but that are not required.
First, an adversary may create invalid entries of a certain length; they obtain the type garbage. Secondly, invalid ciphertexts are a special case because participants not knowing the secret key can reasonably ask for their type and query their public key, hence they cannot be of type garbage. Thirdly, the security deﬁnition of signature schemes does not exclude that the adversary transforms signatures by honest participants into other valid signatures on the same message with the same public key.
Finally, we allow the adversary to retrieve all information that we do not explicitly require to be hidden. We write this as a command adv parse. It returns the type and usually all the abstract arguments of a value (with indices replaced by handles), except that for ciphertexts where the adversary does not know the secret key it only returns the length of the cleartext instead of the cleartext itself. Most of these arguments could also be queried with basic commands, but not the signature counter and the cleartext length.
• Invalid entry: yhnd ← adv garbage(l), for l ∈ N with l ≤ max len(k). Set yhnd := curhnda++ and15
D :⇐ (ind := size++, type := garbage, arg := (), hnd a := yhnd, len := l).
• Signature transformation: thnd ← adv transform sig(shnd). Let s := D[hnd a = shnd ∧ type = sig].ind . If s = ↓ then return ↓. Otherwise let (pk , l, c) := D[s].arg. Set thnd := curhnda++ and
D :⇐ (ind := size++, type := sig, arg := (pk , l, false), hnd a := thnd, len := D[s].len).
• Invalid ciphertext of length l: chnd ← adv invalid ciph(pkhnd, l), for 1 ≤ l ≤ max len(k). Let pk := D[hnd a = pkhnd ∧ type = pke].ind . If pk = ↓, then return ↓. Otherwise set chnd := curhnda++ and
D :⇐ (ind := size++, type := enc, arg := (pk ), hnd a := chnd, len := l).
15This does not mean that the same garbage is always treated diﬀerently, only that the simulation has to ensure that this command is only used for new garbage.
14

• Parameter retrieval: (type, arg) ← adv parse(mhnd).
Let m := D[hnd a = mhnd].ind and type := D[m].type. In most cases, set arg := ind2hnd∗a (D[m].arg). (Recall that this only transforms arguments in IN DS.) The only exception is for type = enc and D[m].arg of the form (pk , l) (a valid ciphertext) and D[pk − 1].hnd a = ↓ (the adversary does not know the secret key); then arg := (ind2hnda(pk ), D[l].len).

4.5.4 Send Commands
We now deﬁne the send commands in detail. Essentially, messages from one honest user to another (on a secure or authentic channel) are put on an abstract secure channel for scheduling, while messages to or from the adversary (either by their addresses, or because the channel is not private) are output immediately.
• send x (v, lhnd), for x ∈ {s, a, i} and v ∈ {1, . . . , n}. Intuitively, the list l shall be sent to user v. Let l ind := D[hnd u = lhnd ∧ type = list].ind . If l ind = ↓, then depending on the channel type (where both cases may occur for one message):
– If (u, v, x) ∈ ch honest , output l ind at net idu,v,x !. – If (u, v, x) ∈ ch to adv , output (u, v, x, ind2hnda(l ind)) at outa!.
• adv send x (u, v, lhnd), for x ∈ {s, a, i}, u ∈ {1, . . . , n} and v ∈ H at port ina?. Intuitively, the adversary wants to send list l to v, pretending to be u. Let l ind := D[hnd a = lhnd ∧ type = list].ind . If l ind = ↓ and (u, v, x) ∈ ch from adv , output (u, v, x, ind2hndv(l ind)) at outv !.

4.5.5 Inputs from Secure Channels
• Input from secure channel: On input l ind at a port net idu,v,x ?, for l ind ∈ IN DS with l ind ≤ size. THH outputs (u, x, ind2hndv(l ind)) at outv !.

4.6 Properties of the Ideal System
The following properties of the ideal system will be useful as invariants in the security proof. For every entry x in D, let owners(x) := {u ∈ H ∪ {a} | x.hndu = ↓}.

Lemma 4.1

The

ideal

systems

Sys

cry,id,x n,L

for

x

∈

{stan, loc}

have

the

following

properties:

1. Index and handle uniqueness: The argument ind of D is a key attribute.

Further, D always |σhndu =ihnd (D)| = 0

fulﬁlls |σhnd for each ihnd

u =ihnd (D)| = > curhndu .

1

for

each

ihnd

≤

curhndu ,

and

2. Well-deﬁned terms: If an entry x = D[i] has an index argument, i.e., a := x.arg[j] ∈ IN DS for some j ∈ N, then a < i. (Thus following the arguments of an entry backwards recursively yields a ﬁnite, Dolev-Yao-like term.) We call the entry D[a] a direct component of x, and recursively deﬁne the set of all components of x in the obvious way.

3. Message correctness: At all times and for all (u, v, x) ∈ ch honest, each message l ind := net idu,v,x [i] with l ind = ↓ has D[l ind].type = list. Here, net idu,v,x [i] denotes the i-th element in the buﬀer queue of the connection.

15

4. Length bounds: At all times, x.len ≤ max len(k) for all x ∈ D.
5. Correct key pairs: Key entries only exist in pairs, i.e., D[i].type = sks ⇐⇒ D[i + 1].type = pks and D[i].type = ske ⇐⇒ D[i + 1].type = pke at all times and for all i ∈ N0. If the conditions are true, we further have D[i + 1].hnd u = D[i].hnd u + 1 for u := owner(D[i]).
6. Key secrecy: If D[i].type ∈ {sks, ske}, then D[i] is not a component of D[j] for any j = i. Further, |owners(D[i])| = 1. We write owner(D[i]) for the element of owners(D[i]) in this case. It cannot change later.
2

Proof. Part 1 was already shown in Sections 4.3.2 and 4.3.3; it is easy to see that all commands respect the conventions introduced there.
Parts 2, 3, 4, and 5 can easily be seen by inspection of the commands, and for Part 4 by the precondition on the lengths of nonces and keys.
For Part 6, inspection easily shows that no type of entry has a direct component of a type in {sks, ske}, and thus also no component. Handles may be added to existing entries upon the following inputs: Data storing and list generation, but only to data and lists; list projection, decryption, retrieval from signatures and ciphertexts, and adv parse, but only to direct components of the given entry and thus not to secret keys; send x and adv send x , but only to lists; and network inputs, but only to lists by Part 3.
Moreover, the following properties will prove useful.

Lemma

4.2

The

ideal

systems

Sys

cry,id,stan n,L

and

Sys

cry,id,loc n,L

have the following prop-

erties:

1. The systems are polynomial-time.

2. No ideal network input is rejected because a counter stepsnet idu,v,x ? reached its bound.

3. The only modiﬁcations to existing entries x in D are assignments to previously
undeﬁned attributes x.hnd u, and (via the command sign) counter updates in entries of type sks.

4. Whenever THH assigns a handle x.hnd u , it outputs it at port outu ! in the same transition. Further, every new entry has exactly one handle.

2

Proof. For Part 1, we have to show that THH only accepts a polynomial number of polynomial-length inputs; the action in each command is then clearly polynomial-
time by the assumptions about the functions in L. For the input number, this holds
because there is a counter stepsp? for inputs at each port p?, each with a bound boundp? polynomial in k. Hence the dynamic bounds curhndu on handle parameters and size on ideal network inputs are bounded by a statically ﬁxed polynomial.
All other input parameters have static polynomial domain restrictions. Hence the
length bounds on inputs (recall Section 4.5.1) are indeed polynomial in k.
Part 2 holds because messages only get into a buﬀer net idu,v,x by a command send x input at inu ?, one per command. There are at most max in(k) such inputs, and max in(k) messages are accepted at net idu,v,x ? if scheduled.
Parts 3 and 4 can easily be seen by inspection of the commands.

16

5 Real System
In a real system, the commands are implemented by real cryptographic algorithms, and messages are actually sent between machines. We ﬁrst describe the underlying algorithms; then we deﬁne the machines of the real system in an order similar to the ideal system.

5.1 Cryptographic Operations
The real system uses digital signatures and public-key encryption. The ranges of all algorithms are {0, 1}+ ∪ {↓}.

5.1.1 Digital Signatures
We denote a digital signature scheme by a tuple S = (genS, sign, test, pks len, sig len) of polynomial-time algorithms. We write
(sk , pk ) ← genS(1k, 1s)
for the generation of a secret signing key and a public test key based on a security parameter, k ∈ N, and the desired maximum number of signatures, s ∈ N. The length of pk is pks len(k, s) > 0. By
sig ← signsk,sc(m)
we denote the (probabilistic) signing of a message m ∈ {0, 1}+, where sc ∈ {1, . . . , s} is a counter value.16 Veriﬁcation
b := testpk (sig, m)
is deterministic and returns true (then we say that the signature is valid) or false. Correctly generated signatures for correct key pairs must always be valid. The length of sig is sig len(k, s, |m|) > 0.17 This is also true for every sig with testpk (sig , m) = true for a value pk ∈ {0, 1}pks len(k,s). The functions pks len, sig len must be bounded by multivariate polynomials.
The accepted security deﬁnition for general-purpose signing is security against existential forgery under adaptive chosen-message attacks [21]. We only use our notation for interacting machines.

Deﬁnition 5.1 (Signature Security) Given a signature scheme and a function s over N, the signer machine Sigs is deﬁned as follows: It has one input and one output port, variables sk , pk initialized with ↓ and a counter sc initialized with 0, and the following transition rules:

• First generate a key pair, (sk , pk ) ← genS(1k, 1s(k)), and output pk .

• On input (sign, mj), and if sc < s(k), set sc++ and return sigj ← signsk,sc(mj).

The signature scheme is called existentially unforgeable under adaptive chosen-

message attack if for every eﬃciently computable, polynomially bounded s and every

probabilistic polynomial-time machine Asig that interacts with Sigs and outputs a

pair (m, sig), the probability that testpk (sig, m) = true and m was not signed by

Sigs during the interaction (i.e., a forged signature), is negligible (in k).

3

16The most eﬃcient implementations of typical signature schemes needing counters also store
a path in a tree. Functionally, this or any other function of random values chosen during earlier
applications of signsk is equivalent to just a counter, because all random values needed can be seen as part of sk and chosen initially.
17For real signature schemes one often gets only upper bounds on these lengths. By appropriate
padding one can easily ensure that these bounds are met exactly.

17

5.1.2 Encryption
We denote a public-key encryption scheme by a tuple E = (genE, E, D, pke len, enc len) of polynomial-time algorithms. We assume that messages of arbitrary length can be encrypted and that secrecy holds within all subsets of messages of the same length. We write
(sk , pk ) ← genE(1k)
for the generation of a secret decryption key and a public encryption key. The length of pk is pke len(k) > 0. We denote the (probabilistic) encryption of a message m ∈ {0, 1}+ by
c ← Epk (m),
and deterministic decryption by
m := Dsk (c).
The result m may be ↓ for wrong ciphertexts. The length of c is enc len(k, |m|) ≥ |m| > 0 for every value pk ∈ {0, 1}pke len(k), and also for every c with m := Dsk (c ) = ↓ for a correctly generated secret key. The functions pke len, enc len must be bounded by multivariate polynomials.
The following security deﬁnition means that any two equal-length messages are indistinguishable even in adaptive chosen-ciphertext attacks. Indistinguishability was introduced in [20], chosen-ciphertext security in [35] and formalized as “INDCCA2” in [8]. It is the accepted deﬁnition for general-purpose encryption. An eﬃcient encryption system secure in this sense is [13].

Deﬁnition 5.2 (Encryption Security) Given an encryption scheme, the decryptor machine Dec is deﬁned as follows: It has one input and one output port, variables sk , pk , c initialized with ↓, and the following transition rules:

• First set (sk , pk ) ← genE(1k) and output pk .

• On input (enc, m0, m1) (intuitively a pair of messages an adversary hopes to be able to distinguish), and if |m0| = |m1| and c = ↓, set b ←R {0, 1} and store
and output the encryption c ← Epk (mb).

• On input (dec, cj) and if cj = c, return m := Dsk (c).

The encryption scheme is called indistinguishable under adaptive chosen-ciphertext

attack if for every probabilistic polynomial-time machine Aenc that interacts with Dec and ﬁnally outputs a bit b∗ (meant as a guess at b), the probability of the event b∗ = b

is bounded by 1/2 + g(k) for a negligible function g.

3

5.2 Structures

Given a signature scheme S and an encryption scheme E, we now deﬁne a real

crypto-library,

again

in

a

stand-alone

and

a

localized

version

Sys

cry,real,stan n,S ,E ,L

and

Syscnr,yS,r,eEa,lL,loc. The parameter n denotes the number of participants, and L is a

tuple of parameters discussed in Section 5.3.

The systems are standard cryptographic systems as deﬁned in [34] and sketched

in Section 2.1.

• The intended structure has n machines {M1, . . . , Mn}.
• The intended speciﬁed ports are deﬁned via S ∗,stanc := {inu !, outu ? | u ∈ {1, . . . n}};
S ∗,locc := {inu !, outu ?, inu ! | u ∈ {1, . . . n}}.

18

• Correspondingly, each Mu has ports inu ? and outu !, and in the localized version also outu !
• Each Mu has three connections to each Mv with v ∈ {1, . . . n}, called netu,v,s, netu,v,a and netu,v,i. They are called network connections and the corresponding ports network ports. All the network connections are scheduled by the adversary.
• The access structure ACC consists of all subsets H of {1, . . . , n}. • The channel model χ maps each connection netu,v,x to x. The channel model means that in an actual structure, an honest intended recipient gets all messages output at ports of type s (secret) and a (authentic) and the adversary gets all messages output at ports of type a and i (insecure). Furthermore, all messages received at an input port of type i come from the adversary. This is shown in Figure 3. To ensure globally unique port names, some ports get a superscript a according to the rules in [34]. In the following, the machine is always clear from the context; thus we usually omit these superscripts.
Figure 3: Connections from a correct machine to another in the real system. User in- and outputs are scheduled as in the ideal system, network connections by the adversary.
5.3 Lengths and Bounds
The parameter L of the real system consists of functions max len(k), max skc(k), and max in(k) as in the ideal system and a function nonce len(k) of the same type, where 2−nonce len(k) must be negligible.
For use in preconditions and lemmas, we deﬁne the resulting lengths of data items in the real system, i.e., the length functions of the corresponding ideal system, as a function L := R2Ipar(S, E, L ). We abbreviate
• pks len (k) := pks len(k, max skc(k)); • sig len (k, l) := sig len(k, max skc(k), list len(nonce len(k), l)); and • enc len (k, l) := enc len(k, list len(nonce len(k), l)). Now L consists of the following functions: • data len∗(l) := list len(|data|, l); • list len∗(l1, . . . , lj) := list len(|list|, l1, . . . , lj); • nonce len∗(k) := list len(|nonce|, nonce len(k)); • pks len∗(k) := list len(|pks|, pks len (k));
19

• sig len∗(k, l) := list len(|sig|, pks len (k), nonce len(k), l, sig len (k, l));
• pke len∗(k) := list len(|pke|, pke len(k));
• enc len∗(k, l) := list len(|enc|, pke len(k), enc len (k, l), nonce len(k));
and max len, max skc and max in are taken unchanged from L . We require that nonce len∗(k), pks len∗(k), and pke len∗(k) are upper bounded
by max len(k).

Lemma 5.1 For a correct tuple L of parameters for the real crypto-library and

correct signature and encryption systems, the algorithm L := R2Ipar(S, E, L ) yields

a correct tuple L of parameters for the ideal crypto-library.

2

Proof. We have to verify the conditions from Section 4.2. Clearly the range of all functions type len∗ is indeed N. Next, type len∗(k) < max len(k) for type ∈
{nonce, pks, pke} and max skc(k) < max in(k) holds by direct preconditions. Finally,
one easily sees that all the functions are bounded by a multivariate polynomial and
eﬃciently computable because all the basic functions in the deﬁnitions are.

5.4 States of a Machine
The state of each machine Mu consists of a database Du and variables curhndu and stepsp? for each input port p?.
5.4.1 Database Du
The main data structure of Mu is a database Du that contains implementationspeciﬁc data such as ciphertexts and signatures produced during a system run. Its primary key attribute corresponds to the handles for u in the ideal system. Each entry x in Du has attributes
(hnd u , word , type, add arg).
• x.hnd u ∈ HN DS consecutively numbers all entries in Du. We use it as a primary key attribute, i.e., we will write Du[ihnd] for Du[hnd u = ihnd].
• x.word ∈ {0, 1}+ is the real representation of x.
• x.type ∈ typeset ∪ {null} identiﬁes the type of x. The value null denotes that the entry has not yet been parsed. Again, the typeset can be extended.
• x.add arg is a list of (“additional”) arguments. Typically it is (), only for signing keys it contains the counter.
5.4.2 Conventions about Handles
Initially, Du is empty. Mu maintains a counter curhndu of type HN DS denoting the current number of elements in Du. New entries x always receive x.hnd u := curhndu ++, and x.hnd u is never changed. Thus, hnd u is indeed a key attribute. By
(ihnd, Du) :← (i, type, add arg), spoken “determine a handle ihnd for . . . in Du”, for i ∈ {0, 1}+, type ∈ typeset, and add arg ∈ LIST , we abbreviate the following algorithm: If ihnd := Du[word = i ∧ type ∈ {sks, ske}].hnd u = ↓, return ihnd, assigning the input values type and add arg to the corresponding attributes of Du[ihnd] only if Du[ihnd].type was null. Else if |i| > max len(k), return ihnd = ↓. Otherwise, set ihnd := curhndu ++, Du :⇐ (ihnd, i, type, add arg) and return ihnd.

20

5.4.3 Input Counters
For each of its input ports p?, Mu maintains a counter stepsp? ∈ N0 initialized with 0 for the number of inputs at that port. All corresponding bounds boundp? are max in(k).
5.5 Inputs and their Evaluation
Now we describe how Mu evaluates individual inputs. Mainly, these are the cryptographic operations with the modiﬁcations motivated in Section 2.3. For general unambiguity, not only all cryptographic objects are tagged, but also data and lists.
5.5.1 General Conventions
The general conventions are similar to those in the ideal system. (In fact, the domains for inputs at port inu ? are the same as in THH in corresponding states, which will be deﬁned later.)
Upon each input at a port p?, the machine Mu ﬁrst increments the counter stepsp?, and once a counter stepsp? has reached its bound max in(k), the length function for this port is always zero.
Otherwise, the length function is determined by the domain speciﬁed for each input in the part “for . . . ” below. The domain of each parameter with subscript hnd is HN DS, and it must be ≤ curhndu at the time of execution. An input in the correct domain is called well-formed. If an input is not well-formed, which is easily veriﬁable, Mu aborts the transition without further action. (But the counter stepsp? has been incremented.) The overall length function for each port p? in each state is the maximum of the possible lengths of well-formed inputs at that port in that state; it can easily be computed.
In the localized version, Mu accompanies every output at the port outu ! by an output 1 at outu !, i.e., it schedules that output immediately.
From now on, we only need to consider well-formed inputs further.
5.5.2 Constructors and One-level Parsing
Constructors For each type, we deﬁne the main constructor via an algorithm make type, which is purely functional, i.e., it does not use or modify global variables, except that it uses k.18
Functional parsing We also deﬁne a functional algorithm parse, written
(type, arg) ← parse(m),
for m ∈ {0, 1}+ and with outputs type ∈ typeset and a list arg with elements in Σ∗. On input m, it tests if m is of the form (type, m1, . . . , mj) with type ∈ typeset \
{sks, ske, garbage} and j ≥ 0. If this fails, it returns (garbage, ()). Otherwise it makes a call arg ← parse type(m) to an algorithm which returns ↓ if m is not really of this type and otherwise computes the arguments. These algorithms are described after the corresponding constructors in Section 5.5.3. If parse type returns arg = ↓, parse again outputs (garbage, ()).
Parsing in Du By
“parse mhnd”
18This is mainly useful for the security proof. An implementation may be inline.
21

we abbreviate that Mu calls (type, arg) ← parse(Du[mhnd].word ), assigns Du[mhnd].type := type if it was still null, and may then use arg. By
“parse mhnd if necessary” we mean the same except that Mu does nothing if Du[mhnd].type = null.19

5.5.3 Basic Commands and parse type
We now deﬁne how Mu evaluates a command from basic cmds, entered at the port inu ?. Basic commands are again local, i.e., they produce a result at outu ! and possibly update the database Du, but do not produce outputs at other ports.

Type and length queries • Type query: t ← get type(xhnd). Parse xhnd if necessary. Then let t := Du[xhnd].type.
• Length query: l ← get len(xhnd). Parse xhnd if necessary. If Du[xhnd].type ∈ {sks, ske} then let l |Du[xhnd].word |, otherwise let l := 0.

:=

Storing and retrieving data • Constructor: d ← make data(m), for m ∈ {0, 1}∗. Let d := (data, m).
• Storing: mhnd ← store(m), for m ∈ {0, 1}∗ with |m| ≤ max len(k). Let d ← make data(m) and (dhnd, Du) :← (d, data, ()).
• Parsing: arg ← parse data(m). If m is of the form (data, m ) with m ∈ {0, 1}∗, return (m ), else ↓.
• Retrieval: m ← retrieve(mhnd). Parse mhnd if necessary. Return parse data(Du[hnd u = mhnd ∧ type = data].word )[1].

Lists

• Constructor: l ← make list(x1, . . . , xj), for j ∈ N0 and xi ∈ {0, 1}+ for i := 1, . . . , j.

Let l := (list, x1, . . . , xj).

• Generate a list: lhnd ← list(xh1nd, . . . , xhjnd), for 0 ≤ j ≤ max len(k). If there is an i with Du[xhi nd].type ∈ {sks, ske}, return ↓.20 Else set l := make list(Du[xh1nd].word , . . . , Du[xhjnd].word ) and (lhnd, Du) :← (l, list, ()).

• Parsing: arg ← parse list(l).

If l is of the form (list, x1, . . . , xj) with j ∈ N0 and xi ∈ {0, 1}+ for i := 1, . . . , j, return (x1, . . . , xj), else ↓. In the ﬁrst case, we call l a tagged list.

• i-th projection: xhnd ← list proj(lhnd, i), for 1 ≤ i ≤ max len(k).

Parse lhnd, yielding arg. If Du[lhnd].type = list, return ↓. Otherwise let x := arg[i]. If x = ↓, return ↓, else let (xhnd, Du) :← (x, null, ()).

19This notation is mainly used for reasons of readability. Both algorithms can be formalized as

ar2g0←WepanreseedDun(omt hpnadr)saentdhepainrspeuctsonbdeDcua(umsehnpda)rs(iwnigthnesvideer

eﬀects). gives types

from

{sks,

ske},

and

garbage

in lists is allowed.

22

Nonces
• Constructor: n ← make nonce(). Let n ←R {0, 1}nonce len(k) and n := (nonce, n ).
• Generation: nhnd ← gen nonce(). Let n ← make nonce(), nhnd := curhndu ++ and Du :⇐ (nhnd, n, nonce, ()).
• Parsing: arg ← parse nonce(n). If n is of the form (nonce, n ) with n ∈ {0, 1}nonce len(k), return (), else ↓.

Signatures

• Key constructor: (sk ∗, pk ∗) ← make sig keypair().
Let (sk , pk ) ← genS(1k, 1max skc(k)) and set sk ∗ := (sks, sk , pk ) and pk ∗ := (pks, pk ).

• Key generation: (skhnd, pkhnd) ← gen sig keypair(). Let (sk ∗, pk ∗) ← make sig keypair(), skhnd := curhndu ++, pkhnd := curhndu ++, Du :⇐ (skhnd, sk ∗, sks, (0)), and Du :⇐ (pkhnd, pk ∗, pks, ()).21
• Public-key parsing: arg ← parse pks(pk ∗). If pk ∗ is of the form (pks, pk ) with pk ∈ {0, 1}pks len (k), return (), else ↓.

• Signature constructor: s∗ ← make sig(sk ∗, l, c), with sk ∗, l ∈ {0, 1}+ and c ∈ N with c ≤ max skc(k).
Select r ←R {0, 1}nonce len(k), set (sk := sk ∗[2] and pk := sk ∗[3], sign sig ← signsk,c((r, l)), and return s∗ := (sig, pk , r, l, sig).

• Signature generation: shnd ← sign(skhnd, lhnd).
Parse lhnd if necessary. (Secret keys are not received from the network and thus always parsed.) If Du[skhnd].type = sks or Du[skhnd].add arg[1] ≥ max skc(k) or Du[lhnd].type = list, then return ↓. Otherwise set sk ∗ := Du[skhnd].word , c := Du[skhnd].add arg[1]++, l := Du[lhnd].word , and s∗ ← make sig(sk ∗, l, c). If |s∗| > max len(k), decrement Du[skhnd].add arg[1] again and return ↓, else set shnd := curhndu ++ and Du :⇐ (shnd, s∗, sig, ()).
• Signature parsing: arg ← parse sig(s∗).
If s∗ is not of the form (sig, pk , r, l, sig) with pk ∈ {0, 1}pks len (k), r ∈ {0, 1}nonce len(k), l ∈ {0, 1}+, and sig ∈ {0, 1}sig len (k,|l|), return ↓. Also return ↓ if l is not a tagged list or if testpk (sig, (r, l)) = false. Otherwise set pk ∗ := (pks, pk ) and arg := (pk ∗, l).

• Signature veriﬁcation: v ← verify(shnd, pkhnd, lhnd). Parse shnd yielding arg. If Du[shnd].type = sig, return ↓. Else let (pk ∗, l) := arg. Let v := true if Du[pkhnd].word = pk ∗ and Du[lhnd].word = l, else v := false.22

• Public-key retrieval: pkhnd ← pk of sig(shnd). Parse shnd yielding arg. If Du[shnd].type = sig, return ↓. (pkhnd, Du) :← (arg[1], pks, ()).

Otherwise, let

21The argument 0 of the secret key is the counter and will change. 22The actual signature test is already performed when shnd is parsed. We simply return false if
a test is attempted with another public key or message than those contained in the signature.

23

• Message retrieval: lhnd ← msg of sig(shnd). Parse shnd yielding arg. If Du[shnd].type = sig, return ↓. (lhnd, Du) :← (arg[2], list, ()).

Otherwise, let

Public-key encryption

• Key constructor: (sk ∗, pk ∗) ← make enc keypair(). Let (sk , pk ) ← genE(1k) and set sk ∗ := (ske, sk ) and pk ∗ := (pke, pk ).
• Key generation: (skhnd, pkhnd) ← gen enc keypair(). Set (sk ∗, pk ∗) ← make enc keypair(), skhnd := curhndu ++, pkhnd := curhndu ++, Du :⇐ (skhnd, sk ∗, ske, ()), and Du :⇐ (pkhnd, pk ∗, pke, ()).
• Public-key parsing: arg ← parse pke(pk ∗). If pk ∗ is of the form (pke, pk ) with pk ∈ {0, 1}pke len(k), return (), else ↓.

• Encryption constructor: c∗ ← make enc(pk ∗, l), for pk ∗, l ∈ {0, 1}+. Let pk := pk ∗[2], set r ←R {0, 1}nonce len(k), encrypt c ← Epk ((r, l)), and let c∗ := (enc, pk , c, r).

• Encryption: chnd ← encrypt(pkhnd, lhnd).
Parse pkhnd and lhnd if necessary. If Du[pkhnd].type = pke or Du[lhnd].type = list, then return ↓. Otherwise, set pk ∗ := Du[pkhnd].word , l := Du[lhnd].word , and c∗ ← make enc(pk ∗, l). If c∗ = ↓ or |c∗| > max len(k) then return ↓, else set chnd := curhndu ++ and Du :⇐ (chnd, c∗, enc, ()).
• Ciphertext parsing: arg ← parse enc(c∗).
If c∗ is not of the form (enc, pk , c, r) with pk ∈ {0, 1}pke len(k), c ∈ {0, 1}+, and r ∈ {0, 1}nonce len(k), return ↓, else arg := (pk ∗) := ((pke, pk )).

• Functional decryption: l ← parse decrypt(sk ∗, c∗). Let sk := sk ∗[2], c := c∗[3], and r := c∗[4]. Decrypt l∗ := Dsk (c). If l∗ = ↓ or l∗[1] = r or l∗[2] is not a tagged list, return l := ↓, else l := l∗[2].

• Decryption: lhnd ← decrypt(skhnd, chnd). Parse chnd yielding arg =: (pk ∗). Return ↓ if Du[skhnd].type = ske or Du[chnd].type = enc or Du[skhnd + 1].word = pk ∗.23 Otherwise, set sk ∗ := Du[skhnd].word , c∗ := Du[chnd].word , and l ← parse decrypt(sk ∗, c∗). If l = ↓, return ↓. Otherwise let (lhnd, Du) :← (l, list, ()).

• Public-key retrieval: pkhnd ← pk of enc(chnd). Parse chnd yielding arg. If Du[chnd].type = enc, return ↓. (pkhnd, Du) :← (arg[1], pke, ()).

Otherwise let

5.5.4 Send Commands
• send x (v, lhnd), for x ∈ {s, a, i} and v ∈ {1, . . . , n}. Parse lhnd if necessary. If Du[lhnd].type = list, output Du[lhnd].word at port netu,v,x !.
23This means that one never tries to decrypt with respect to another public key than the one contained in the ciphertext.

24

5.5.5 Network Inputs
• Network input: On input l at a port netw,u,x ?, for l ∈ {0, 1}+ and |l| ≤ max len(k). Test if l = (list, x1, . . . , xj) for some j ∈ N0 and values xi ∈ {0, 1}+. If yes, let (lhnd, Du) :← (l, list, ()) and output (w, x, lhnd) at outu !.

5.6 Properties of the Real System
The following properties of the real system are useful:

Lemma 5.2

The

real

systems

Sys

cry,real,x n,S ,E ,L

for x

∈

{stan, loc} have the following

properties:

1. The argument hnd u of Du is a key attribute.
2. The only modiﬁcations to existing entries x in Du are that x.type changes from null to something else and that x.add arg changes from () to something else at the same time, and counter updates in entries of type sks.

3. At all times we have |x.word | ≤ max len(k) for all x ∈ Du, except possibly if x.type ∈ {sks, ske}.
4. The systems are polynomial-time.
2

Proof.
1. This was already shown in Section 5.4.2.
2. This can easily be seen by inspection of the commands.
3. By Part 2, we only need to consider commands that produce new entries. In most cases, the subroutine “(xhnd, Du) :← . . .” is used, which tests for this bound. For signatures and encryptions, the outer command contains the test. For nonces and public keys, their lengths are nonce len∗(k), pks len∗(k), and pke len∗(k), respectively, which are bounded by max len(k) by Section 5.3.
4. We have to show that each Mu only accepts a polynomial number of polynomial-length inputs; the action in each command is then clearly polynomial-time because all basic algorithms used are this. For the numbers, this holds because there is a counter stepsp? for inputs at each port p?, each with the polynomial bound max in(k). As each input adds at most 2 entries to Du, the dynamic bound curhndu for handle parameters is also polynomially bounded. All other input parameters have static polynomial domain restrictions. Hence the length bounds on inputs (recall Section 4.5.1) are indeed polynomial in k.

25

% $
"# "$

!
Figure 4: Set-up of the simulator. User in- and outputs are scheduled as in the ideal system.

6 Simulator

We

claim

that

every

real

system

Sys

cry,real,x n,S ,E ,L

for

x

∈

{stan, loc}

in

Section

5

is

as

secure

as

the

ideal

system

Sys

cry,id,x n,L

in

Section

4

for

the

parameters

L

:=

R2Ipar(S, E, L ), even with a blackbox simulation. The main step in this proof

is to construct a simulator SimH for each set H such that for every real adversary A, the combination SimH(A) of SimH and A achieves the same eﬀects in the ideal system as the adversary A in the real system, see Figure 4.

Basically SimH has to translate real messages from the real adversary A into handles as THH expects them at its adversary input port ina? and vice versa, see Figure 4. In both directions, SimH has to parse messages completely because it can only construct the other version (abstract or real) bottom-up. This is done by re-

cursive algorithms. In some cases, the simulator cannot produce any corresponding

message. We collect these cases in so-called error sets and show later that they

cannot occur at all or only with negligible probability.

6.1 Ports and Scheduling
The ports of SimH are shown in Figure 4. In particular, the clock ports, i.e., the scheduling, are as follows: A remains the master scheduler. It also still schedules the connections between itself and H, the network connections netu,v,x with (u, v, x) ∈ ch honest (including the doubled connections netau,v,x), and in the standalone version the user in- and outputs, i.e., these clock ports of A are unchanged. Each clock port netu,v,x ! with (u, v, x) ∈ ch honest is renamed into net idu,v,x ! so that A also schedules the ideal secure channels. (Port renaming is allowed in blackbox reductions, cf. [34].) Recall that THH schedules its outputs at outa!.
Thus SimH mainly schedules the connection ina. It immediately does this (by outputting 1 at ina !), whenever it makes an output at ina!; we do not repeat this below. For local commands, we abbreviate subroutine behavior as follows:
“Call y ← x at ina!, expecting . . .”,
means that SimH outputs x at port ina! and schedules it, waits for an input at outa? by setting all other length functions to 0, and assigns the input to a variable y. If y is not in the domain given after “expecting”, SimH aborts all current recursive algorithms and its outermost transition. As THH reacts to local commands with an output at outa! and schedules it immediately, we really get subroutine behavior.

26

6.2 Long-term States of the Simulator
The state of SimH consists of a database Da and variables curhnda and stepsp? for each input port p?.
6.2.1 Database Da To ensure that the same abstract message is always mapped to the same real message and vice versa, SimH maintains a database Da of already mapped adversary handles. Each entry in Da has attributes
(hnd a, word , add arg).
For each tuple x ∈ Da:
• x.hnd a ∈ HN DS is used as the primary key attribute. However, its use is not as straightforward as in the ideal and real system, compare Lemma 6.2.
• x.word ∈ {0, 1}∗ is the real representation of x, or for unknown secret keys (of the adversary).
• x.add arg is a list of additional arguments. Typically it is (). However, for public keys received from the adversary it is (adv), and for keys from honest users, where the simulator generated a key pair, it is of the form (honest, sk ∗).
6.2.2 Conventions about Handles
Initially, Da is empty. SimH keeps a counter curhnda of type HN DS, which denotes the current size of Da, except temporarily within the algorithm id2real deﬁned below.
6.2.3 Input Counters
For each of its input ports p?, SimH maintains a counter stepsp? ∈ N0 initialized with 0 for the number of inputs at that port. The corresponding bounds boundp? are max in(k) for the network ports and max ina(k) = 10n2max in(k)max len(k) for outa?.
6.3 Input Evaluation
6.3.1 General Conventions
Upon each input at a port p?, the main simulator SimH ﬁrst increments the counter stepsp?. This is the only case where such a counter is increased. Once a counter stepsp? has reached boundp?, the length function for this port is always zero.
Otherwise, the length functions are determined by the domain speciﬁed for each input below.
6.3.2 Send Commands
In this section, we deﬁne the behavior of SimH when it receives an input from THH. We only consider “unsolicited” inputs here, not the immediate results of local commands. These inputs are the results of send commands by honest users.
• Input from THH: On input m at port outa?, for m = (u, v, x, lhnd) with (u, v, x) ∈ ch to adv and lhnd ≤ max hnd(k) := 6n2max in(k)max len(k). If Da[lhnd] = ↓, let l := Da[lhnd].word . Else set curhnda++ and produce such a word with an algorithm l ← id2real(lhnd) (with side-eﬀects). Then output l at port netu,v,x !.
27

We will show that max hnd(k) is an upper bound on the database size in THH if THH interacts with SimH. Actually THH always uses lhnd = curhnda++ for new adversary handles. Hence SimH’s update of curhnda restores “correct derivation”.
Overall structure of id2real The algorithm id2real recursively parses an abstract message, builds up a corresponding real message, and enters all new message parts into Da. It only interacts with THH by local commands, so that we get an uninterrupted dialogue between SimH and THH.
The domain expectations of id2real and certain additional format claims made will be proven in Section 7 for interaction with THH. The main explanation is that id2real is only called for new handles. They only occur if the corresponding entry in THH was constructed at the request of an honest user, and thus by a basic command. Hence none of the exceptional data formats occurs.
Now id2real(mhnd) is deﬁned as follows.
1. Call (type, (mh1nd, . . . , mhjnd)) ← adv parse(mhnd) at ina! (we use the superscript hnd although not all ideal attributes are handles), expecting type ∈ typeset \ {sks, ske, garbage} and j ≤ max len(k), and mhi nd ≤ max hnd(k) if mhi nd ∈ HN DS and otherwise |mhi nd| ≤ max len(k).
2. For i := 1, . . . , j: If mhi nd ∈ HN DS and mhi nd > curhnda, set curhnda++.
3. For i := 1, . . . , j: If mhi nd ∈ HN DS, set mi := mhi nd. Else if Da[mhi nd] = ↓, let mi := Da[mhi nd].word . Else make a recursive call mi ← id2real(mhi nd). Let argreal := (m1, . . . , mj).
4. Construct and enter the real message m depending on type:
• If type ∈ {data, list, nonce}, set m ← make type(argreal) and Da :⇐ (mhnd, m, ()).
• If type ∈ {pks, pke}, call (sk ∗, pk ∗) ← make sig keypair() or (sk ∗, pk ∗) ← make enc keypair(), respectively, and set m := pk ∗ and Da :⇐ (mhnd, m, (honest, sk ∗)).
• If type = sig, we claim that argreal is of the form (pk ∗, l, c) with c ∈ N. Let pkhnd := mh1nd. We claim that Da[pkhnd].add arg is of the form (honest, sk ∗). Then set m ← make sig(sk ∗, l, c) and Da :⇐ (mhnd, m, ()).
• If type = enc, we claim that lhnd := mh2nd =↓, and distinguish two cases: If lhnd ∈ HN DS (i.e., a cleartext handle, not only a length was output), let m ← make enc(argreal) and Da :⇐ (mhnd, m, ()). Otherwise argreal is of the form (pk ∗, len) with len ∈ N. Then SimH encrypts a ﬁxed message of the correct length; it must not be a list. Let pk := pk ∗[2] and len∗ := list len(nonce len(k), len). Encrypt c ← Epk (1len∗ ) and set r ←R {0, 1}nonce len(k), m := (enc, pk , c, r), and Da :⇐ (mhnd, m, ()).
6.3.3 Network Inputs
Now we deﬁne the behavior of SimH when it receives an input from A.
• Network input: On input l at a port netw,u,x ? with (w, u, x) ∈ ch from adv , for l ∈ {0, 1}+ and |l| ≤ max len(k).
If l is not a tagged list, abort the transition. Otherwise translate l into a corresponding handle lhnd by an algorithm lhnd ← real2id(l) (with side-eﬀects). Then output the command adv send x (w, u, lhnd) at port ina!.
28

Overall structure of real2id The algorithm real2id recursively parses a real message, builds up a corresponding term in THH, and enters all subterms into Da. It only interacts with THH by local commands. As these have a subroutine behavior, we get an uninterrupted dialogue between SimH and THH.
• mhnd ← real2id(m), for m ∈ {0, 1}+. If there is already a handle mhnd with Da[mhnd].word = m, return that. Otherwise set (type, arg) := parse(m) and call a type-speciﬁc algorithm add arg ← real2id type(m, arg) (with side-eﬀects). Set mhnd := curhnda++ and Da :⇐ (mhnd, m, add arg).
In the deﬁnitions of real2id type, we write the parameter arg in the form that it must have when parse returned (type, arg). Each real2id type ignores the results of its calls to THH, which are predictable handles. Thus the length function for outa? can be 1 in those states.
Garbage add arg ← real2id garbage(m, ()). Call mhnd ← adv garbage(|m|) at ina!. Then return ().
Data add arg ← real2id data(m, (m )). Call mhnd ← store(m ) at ina!. Return ().
Lists add arg ← real2id list(m, (m1, . . . , mj)). Make recursive calls mhi nd ← real2id(mi) for i := 1, . . . , j (in this order). Then call mhnd ← list(mh1nd, . . . , mhjnd) at ina!. Return ().
Nonces add arg ← real2id nonce(m, ()). Call mhnd ← gen nonce() at ina!. Return ().
Signatures
• add arg ← real2id pks(m, ()). Call (skhnd, pkhnd) ← gen sig keypair() at ina!. Set Da :⇐ (curhnda++, , ()) for the secret key and return add arg := (adv) for the public key.24
• add arg ← real2id sig(s∗, (pk ∗, l)). Make recursive calls pkhnd ← real2id(pk ∗) and lhnd ← real2id(l). If Da[pkhnd].add arg = (adv), set skhnd := pkhnd − 1. Then call shnd ← sign(skhnd, lhnd) at ina! and return ().25 Otherwise, let (sig, pk , r, l, sig) := s∗. Verify whether the adversary has seen another signature on the same message, i.e., if there exist shnd, r , and sig with Da[shnd].word = (sig, pk , r , l, sig ) and Da[shnd].type = sig. If yes, call thnd ← adv transform sig(shnd) at ina! and return (). Otherwise, SimH gives up the simulation.26
24Here m is a new public key from the adversary. THH sets skhnd := curhnda++; pkhnd := curhnda++, while SimH does not know a real secret key. SimH therefore makes an “empty” entry in Da for the secret key, while the public key is entered in Da by the last step of real2id as for all other data types.
25THH typically uses another counter value c for this signature than that used in the real adversary signature. Honest users cannot notice this because there is no basic command to retrieve c. Neither can A retrieve c with adv parse, because SimH only uses that command when constructing signatures it has not seen before.
26This is the case of a forged signature on a new message, and no command of THH allows that. It is easy to see that an adversary against SimH indeed forged a signature here. However, in the real system such a signature may already exist, but not be available to the adversary. Thus the proof that this case is cryptographically impossible is more complicated; see Section 7.7.6.
29

Public-key encryption
• add arg ← real2id pke(m, ()). Call (skhnd, pkhnd) ← gen enc keypair() at ina!. Set Da :⇐ (curhnda++, , ()) for the secret key and return add arg := (adv) for the public key.
• add arg ← real2id enc(c∗, (pk ∗)). Make a recursive call pkhnd ← real2id(pk ∗). Now, to produce a corresponding abstract ciphertext in THH, we try to ﬁnd out the message. If Da[pkhnd].add arg = (adv), then SimH does not know the corresponding secret key. Call chnd ← adv invalid ciph(pkhnd, |c∗|) at ina! and return ().27 If Da[pkhnd].add arg = (honest, sk ∗), let l ← parse decrypt(sk ∗, c∗). If l = ↓, call chnd ← adv invalid ciph(pkhnd, |c∗|) at ina! and return (). Else make a recursive call lhnd ← real2id(l), call chnd ← encrypt(pkhnd, lhnd) at ina!, and return ().

6.4 Properties of the Simulator
We ﬁrst show that the simulator is valid.

Lemma 6.1 Each machine SimH is polynomial-time. Hence for every polynomial-

time adversary A on the real system, the joint machine SimH(A) is polynomial-time

and thus a valid adversary on the ideal system.

2

Proof. For each of its input ports, SimH has a polynomially bounded input counter and polynomially bounded length functions. Further, every transition is polynomial-time because an execution of id2real without inner recursions is clearly polynomial-time, and every inner recursion starts with an output at ina! and thus ends a transition. The combination SimH(A) of two polynomial-time machines SimH and A is clearly polynomial-time again.
The following properties of the simulator are useful for the correctness proof.

Lemma 6.2 Each machine SimH has the following properties:
1. Each call id2real(mhnd) leads to Da[mhnd] = ↓ unless the execution aborts.
2. If SimH interacts with THH, the following holds for the algorithm id2real:
• Calls id2real(mhnd) are only made for mhnd ≤ max hnd(k), and at most one such call for each mhnd.
• At most max hnd(k) outputs at ina! are made. • No new entries in D (of THH) are made.
3. Each call real2id(m) leads to a recursion tree with the following properties:
• At most |m|−1 additional calls real2id(mi), each with |mi| > 0 are made. • At most |m| outputs at are made at ina!. • curhnda is increased by at most 2|m|, and thus at most 2|m| new entries
are made in Da.
27In the real system, this ciphertext is not necessarily invalid. However, it was made by A with its own public key. (If it had been produced by an honest participant, SimH would have ﬁrst entered it into Da upon a send command.) Thus no real machine Mv will try to decrypt it, so that the honest users do not notice the diﬀerence. Further, if they send it back to A, then SimH sends the original.

30

4. If SimH interacts with THH, the following holds:
• The argument hnd a of Da is a key attribute. • Outside any execution of id2real, the entries in Da are consecutively num-
bered, i.e., {x.hnd a | x ∈ Da} = {1, . . . , curhnda}.
5. In interaction of THH and SimH, the following holds:
• No handle output by THH is rejected by SimH. • The counters stepsouta? of SimH and stepsina? of THH never reach their
bounds.
2
Proof.
1. Unless an execution of id2real(mhnd) aborts, it ends in Step 4 with an assignment Da :⇐ (mhnd, . . .).
2. Calls id2real(mhnd) are only made by the outer transition for send commands and in Step 3 of id2real. Both times it was veriﬁed that mhnd ≤ max hnd(k) and Da[mhi nd] = ↓. We want to show that every mhnd is used in at most one call.
By Part 1, this can only be violated if a ﬁrst call id2real(mhnd) has not ﬁnished when a second one is made, i.e., the second call is a node in the recursion tree of the ﬁrst one. In a recursion tree, SimH only obtains new handles with the command adv parse. Hence THH only follows the components of a term. By Lemma 4.1.2, all components of a term in THH have smaller indices. In particular, no index and thus no adversary handle occurs twice, which proves our claim.
The other bound follows immediately because each subcall (without inner recursions) makes one output at ina! (in Step 1).
As the only command to THH is adv parse, no new entries in D are made.
3. We consider a call real2id(m) with L := |m|. Once we have shown the bound on the number of recursive calls, the other bounds follow immediately because each subcall (without inner recursions) makes at most one output at ina! and increases curhnda by at most 2.
We show the ﬁrst claim inductively over L. Subcalls only happen when parsing results in type ∈ {list, sig, enc}. The basis L = 1 is clear because no subcall happens for a message of length 1. Now let L > 1.
For lists, we have m = (list, m1, . . . , mj) and all mi are non-empty. By the preconditions on list len we have |mi| < L for all i. Hence we can use the induction hypothesis for each mi. This immediately gives that all subcalls are made for non-empty messages, and the number of subcalls is bounded by j + (|m1| − 1) + . . . + (|mj| − 1) = |m1| + . . . + |mj| ≤ L − 1. For signatures, we have m = s∗ = (sig, pk , r, l, sig) and subcalls are made for pk ∗ = (pks, pk ) and l. Clearly |pk∗| > 0, and |l| > 0 was veriﬁed in parsing. Parsing pk ∗ yields type = pks; thus no further subcalls are made for it. Further, |l| ≤ L − 4 because all components are non-empty. By the induction hypothesis, at most L − 5 subcalls are made for it, and thus overall at most L − 3.
For ciphertexts, we have m = c∗ = (enc, pk , c, r), and subcalls are made for pk ∗ = (pks, pk ) and possibly l := l∗[2], where l∗ is the result of decrypting
31

with the encryption machine and |l∗| ≤ |c| was veriﬁed. Clearly |pk∗| > 0, and |l| > 0 by a test that l is a tagged list before the recursive call. Parsing pk ∗ yields type = pke; thus no further subcalls are made for it. Further, |c| ≤ L − 3 because all components are non-empty, and thus also |l| ≤ L − 3. By the induction hypothesis, at most L − 3 subcalls are made for it, and thus overall at most L − 2.
4. We show these conditions on handles inductively over the inputs.
Upon network inputs, new entries in Da are always made with the handle curhnda++. The ﬁrst two claims follow immediately. Upon inputs from THH, curhnda is always immediately updated when THH sends a new handle; thus curhnda equals THH’s variable curhnda, for which the claim holds with THH’s handles. Further, THH immediately outputs each handle (Lemma 4.2.4), and by Part 1 each call id2real(mhnd) ends with a new entry x with x.hnd a = mhnd. Hence at the end of an outermost execution of id2real the claim also holds for the handles in Da.
5. In the given combination, the free ports are inu ? for u ∈ H and netw,u,x ? with (w, u, x) ∈ ch from adv and the clock ports for the secure channels (recall Figure 4). We ﬁrst consider the eﬀects of inputs there separately.
• User inputs. There are at most n user ports, each accepting at most max in(k) inputs. These inputs directly lead to at most 2nmax in(k) new entries in D. Further, each such input leads to at most one direct output at outa! (if it is a send command), which leads to one call id2real(mhnd). These calls lead to at most max hnd(k) outputs at ina! and thus at most max hnd(k) responses at outa!, whose consequences we have already covered by considering the entire executions of id2real, and to no new entries in D.
• Network inputs. There are at most 2n2 network ports, each accepting at most max in(k) inputs of length at most max len(k). Each input m leads to at most one direct output at ina! (the ﬁnal ideal message) and a call real2id(m). This call leads to at most max len(k) − 1 further outputs at ina!. Overall this gives at most
max ina net(k) := 2n2max in(k)max len(k)
outputs at ina!. This also gives max ina net(k) responses at outa!, whose consequences we have already covered by considering the entire execution of real2id(m). Hence in THH, these inputs lead to at most 2max ina net(k) new entries in D.
• Ideal secure channels. Inputs at a port net idu,v,x? in THH neither lead to new entries in D nor to outputs at outa!.
Altogether, we get at most
2nmax in(k) + 2max ina net(k)
entries in D (independent of how we chose the bounds for the inner ports), and this bounds curhnda in THH. Thus SimH’s handle bound max hnd(k) = 6n2max in(k)max len(k) is safe.
The outputs at outa! and ina! are bounded by, respectively,
nmax in(k) + max hnd(k) + max ina net(k);
32

max hnd(k) + max ina net(k).
Both are smaller than the value max ina(k) = 10n2max in(k)max len(k), which is used as boundina? by THH and as boundouta? and boundoutenc,u ? by SimH. This proves the remaining claims.

7 Security Proof

In the following, we omit the index x ∈ {stan, loc} (stand-alone or localized). The theorem and proof hold for both versions.

Theorem 7.1 (Security of Cryptographic Library) Let a secure signature scheme

S and a secure encryption scheme E be given. Then for all n ∈ N, all correct pa-

rameters L , and all H ⊆ {1, . . . , n}, there is a simulator SimH such that for all polynomial-time honest users H and adversaries A, the view of H while interact-

ing with the correct machines Mu,H (i.e., the derivations according to the channel model) for u ∈ H and A is polynomially indistinguishable from the view of H while

interacting with THH and SimH(A) for the parameters L := R2Ipar(S, E, L ). Using the notation of [34]: For all n and L and for L := R2Ipar(S, E, L ), we

have

Sys

cry,real n,S ,E ,L

≥fse,cpoly

Sys

cry,id n,L

for the canonical mapping f with blackbox simulatability.

2

We ﬁrst give an outline of the proof, see Figure 5.

• Introducing encryption machines: We present the two encryption machines EncH and Encsim,H of [34], which will later be used to answer encryption and decryption request of the system. Roughly, the ﬁrst system calculates the correct encryption of a message m, whereas the second one always encrypts the ﬁxed message 1|m| and answers decryption requests for ciphertexts generated that way by table look-up. It was shown in [34] that the system EncH is at least as secure as the system Encsim,H.
• Rewriting the real system: We rewrite the machines Mu such that they use the encryption system EncH (Step 1 in Figure 5). This yields modiﬁed machines Mu. We then replace EncH by its idealized counterpart Encsim,H (Step 2 in Figure 5) and use a composition theorem to show that the derived system is as secure as the original system.

• Combined system: We want to prove that the modiﬁed real system is at least as secure as the ideal system consisting of the machine THH. We use the simulator from Section 6. More precisely, we compare the combination MH of the machines Mu and Encsim,H with the combination THSimH of the machines THH and SimH. However, there is no direct invariant mapping between the states of these two joint machines. We solve this problem by introducing an intermediate system CH with a combined state space (Step 3 in Figure 5).
• Bisimulations with error sets: We show that the joint view of H and A, together with the buﬀers leading to and from them, is equal in interaction with the combined machine CH and the two machines THSimH and MH, except for certain runs, which we collect in so-called error sets. We make this comparison by performing two bisimulation simultaneously (Step 4 in Figure 5). Transitivity and symmetry of indistinguishability then yield the desired result for THSimH and MH.

33

)( '(

$# % &

"#

$% &

!

Figure 5: Overview of the proof of Theorem 7.1.

34

• Reduction proofs against the underlying cryptography: We ﬁnally show that the aggregated probability of the runs in error sets is negligible as we could otherwise break the underlying cryptography. I.e., we perform reduction proofs against the security deﬁnitions of the primitives. This proves that MH is (computationally) as secure as the ideal system (Step 5 in Figure 5).
Finally, simulatability is transitive. Hence also the original real system is as secure as the ideal system. The reason for treating encryption separately at the beginning (and not in the ﬁnal reduction proofs like the other primitives), although every additional machine makes a bisimulation more tedious, is that computational indistinguishability of real and simulated ciphertexts does not give us a mapping that is almost everywhere correct. In the following, we present the proof in detail.

7.1 Introducing Encryption Machines
First we want to replace the encryption of each message m sent among honest users by an encryption of the ﬁxed message 1|m|, and the decryption of each ciphertext generated that way by table look-up.

7.1.1 Encryption Machines
We use the two encryption systems EncH and Encsim,H from [34]; we only exploit our more powerful database notation for a slightly diﬀerent, but equivalent presentation.

Scheme 7.1 (Ideal and “Real” Encryption Systems) Let an encryption
scheme (genE, E, D, pke len, enc len) and parameters n ∈ N and skeys , sencs : N ⇒ N be given. The functions skeys and sencs must be polynomially bounded in k. skeys (k) denotes the maximum number of keys generated in the system and sencs (k) the maximum number of encryptions per key. We deﬁne two systems

•

Sys

enc,real n,skeys ,sencs

:= {({EncH}, Senc,H) | H ⊆ {1, . . . , n}},

•

Sys

enc,sim n,skeys ,sencs

:= {({Encsim,H}, Senc,H) |

H ⊆ {1, . . . , n}}.

For every H, the ports are

• PortsEncH := PortsEncsim,H := {inenc,u ?, outenc,u !, outenc,u ! | u ∈ H},
• Secnc,H := {inenc,u !, inenc,u !, outenc,u ? | u ∈ H}.
Each machine maintains a key counter curkey ∈ N initialized with 0, and initially empty databases keys and ciphers. Entries in keys have attributes (owner , skenc, pkenc, ec). Entries in ciphers have attributes (msg, pkenc, ciph) and are used to look up intended cleartexts in the ideal system. The transition functions are given by the following rules. Let inenc,u ? be the port where the current input is made; the resulting output goes to outenc,u ! with outenc,u ! := 1.
• pk ← (generate). (In EncH and Encsim,H.) If curkey < skeys (k) then set curkey++, (sk , pk ) ← genE(1k), and keys :⇐ (u, sk , pk , 0), where 0 is the initial value of an encryption counter, and return pk . Otherwise return ↓.
• c ← (encrypt, pk , m), for pk , m ∈ {0, 1}+. Let K := keys[pkenc = pk ]. If K = ↓ or K.ec ≥ sencs , return ↓, else set K.ec++ and
– in EncH: Return c ← Epk (m);

35

– in Encsim,H: Set c ← Epk (1|m|) and ciphers :⇐ (m, pk , c) and return c.
• m ← (decrypt, pk , c), for pk , c ∈ {0, 1}+. (Note that pk is used to designate the desired secret key.) Let K := keys[pkenc = pk ∧ owner = u]. If K = ↓, return ↓, else let sk := K.skenc and
– in EncH: Return m := Dsk (c); – in Encsim,H: Let m := ciphers[pkenc = pk ∧ ciph = c].msg. If m = ↓,
return m, else return m := Dsk (c).28
3
We need the following properties of these encryption machines.

Lemma 7.1 The encryption systems have the following properties:

1. The two systems are computationally indistinguishable (without even a simu-

lator),

i.e.,

Sys

enc,real n,skeys ,sencs

≥fse,cpoly

Sys

enc,sim n,skeys ,sencs

holds

for

the

canonical

mapping

f and all parameters n ∈ N and skeys , sencs ∈ N[x].

2. Each transition is polynomial-time.

2

The ﬁrst part was shown in [34] for polynomials skeys and sencs . Inspection of the proof easily reveals that this also holds for polynomially bounded functions. The
second part is obvious.

7.1.2 Rewriting the Real System with Encryption Machines
We now rewrite the real machines Mu such that they use one of the encryption systems instead of doing all the work themselves. We call the modiﬁed machines Mu. We set the parameters for the encryption system to skeys := sencs := max in(k) + 1. This will ensure that the encryption system does not refuse actions that the overall system needs.
Each Mu has three additional ports inenc,u !, inenc,u !, and outenc,u ? for connecting to the encryption machine. It maintains a counter stepsoutenc,u? with bound boundoutenc,u? := max in(k) + 1; the counter and length functions are treated as in the other systems. By “call the encryption machine with y ← x, expecting y . . .” we abbreviate the same subroutine behavior as in the simulator, where Mu uses the port inenc,u !.
The state is unmodiﬁed; only the actual entries in Du for secret decryption keys are diﬀerent.
The following transitions are modiﬁed:
• (skhnd, pkhnd) ← gen enc keypair().
Set skhnd := curhndu ++; pkhnd := curhndu ++. Call the encryption machine with pk ← (generate), expecting |pk | = pke len(k), and store Du :⇐ (skhnd, , ske, ()) and Du :⇐ (pkhnd, (pke, pk ), pke, ()). Note that the secret key is only stored in the encryption machine.
28If two entries with this condition existed, the notation in [34] would lead to a non-deterministic choice, while we get ↓. However, the proof in [34] immediately yields that m in all such entries would be equal, and our deﬁnition of databases as sets joins equal entries.

36

• c∗ ← make enc(pk ∗, l), for pk ∗, l ∈ {0, 1}+. (Note that this function is no longer state-less.) If enc len∗(k, |l|) > max len(k), return ↓. Otherwise let pk := pk ∗[2], r ←R {0, 1}nonce len(k), and l∗ := (r, l). Call the encryption machine with c ← (encrypt, pk , l∗), expecting |c| ≤ max len(k). If c = ↓ (it was an adversary key), encrypt directly as c ← Epk (l∗). Set c∗ := (enc, pk , c, r).
• lhnd ← decrypt(skhnd, chnd). Parse chnd yielding arg =: (pk ∗). Return ↓ if Du[skhnd].type = ske or Du[chnd].type = enc or Du[skhnd + 1].word = pk ∗. Otherwise, set pk := pk ∗[2], c := Du[chnd].word [3], and r := Du[chnd].word [4]. Call the encryption machine with l∗ ← (decrypt, pk , c), expecting |l∗| ≤ |c|. If l∗ = ↓ or l∗[1] = r or l := l∗[2] is not a tagged list, then lhnd := ↓; else let (lhnd, Du) :← (l, list, ()).
The commands make enc keypair and parse decrypt can be omitted, while parse pke, encrypt, parse enc, and pk of enc remain unchanged.
The following properties of the rewritten system are useful:
Lemma 7.2 The rewritten real machines Mu have the following properties:
1. They are polynomial-time.
2. If they are used together with EncH or Encsim,H, no counter stepsoutenc,u ?, curkey, or K.ec reaches its bound.
3. If used with EncH, their behavior is perfectly indistinguishable (for A and H) from the real system.
2
Proof.
1. Each machine Mu is polynomial-time because the new input port outenc,u ! only allows a polynomial number of inputs because of the corresponding counter, the length function for this port is polynomially bounded and each modiﬁed transition only takes a polynomial number of steps.
2. First we consider a counter stepsoutenc,u? for u ∈ H. Each output by EncH or Encsim,H at outenc,u ! is preceded by an input at inenc,u !, and Mu only makes such an input upon a basic command, i.e., an input at inu ?. Thus there are at most max in(k) such outputs. Similarly, the counter curkey in EncH or Encsim,H is only incremented upon key generation commands input at a port inu ? with u ∈ H, and thus at most nmax in(k) < skeys times. Each counter keys.ec is only incremented upon encryption commands input at a port inu ? with u ∈ H, and thus at most nmax in(k) < sencs times.
3. To prove equal outside behavior, we tacitly use Part 2. The major change is that secret decryption keys are no longer stored in Du, but in ciphers. However, considering key generation and decryption together one easily sees that the same secret key is always used in both systems. As the search in the subroutine :← does not include secret keys, no other command operates on secret keys. The other change is that Mu returns ↓ in make enc if |c| > max len(k), while Mu returns c∗. However, this does not matter since Mu then rejects c∗ in the surrounding command encrypt.
37

7.1.3 Replacing the Encryption Machine in the Real System
We now want to replace the system EncH with Encsim,H. This can be achieved by using the composition theorem of [34], i.e., it is possible to securely replace a subsystem of a larger system if the subsystem is as secure as the replacement in the sense of simulatability. We only have to show that the preconditions of the theorem are fulﬁlled. This is straightforward except for showing that the system on top of the replaced subsystem is polynomial-time, and this was shown in Lemma 7.2.
7.2 Combined System
We have to show that the modiﬁed real system, using the encryption machine, is at least as secure as the ideal system. We even show the stronger statement that the joint view of H and A, together with the buﬀers of connections leading to or from them, is indistinguishable.
In other words, we compare the joint machine THSimH consisting of THH and SimH with the combination MH of the correct machines Mu with u ∈ H and Encsim,H (recall Figure 5).
A method to compare the observable behavior of two distributed systems is to deﬁne a mapping between their states and to show that the same input in corresponding states leads to the same output and corresponding states again, i.e., a bisimulation. However, the states of THSimH and MH are not immediately comparable: a simulated state has no real versions for data that the adversary has not yet seen, while a real state has no global indices, adversary handles, and entries for data that are still unparsed in the correct machines. Similarly, the respective encryption machines are not always in a comparable state, e.g., because basic commands from the honest users cause the subsystems of MH to generate keys and ciphertexts, whereas for the subsystems of the simulator, this only happens when such a message is sent to A.
Therefore we deﬁne an intermediate system CH (“combined”) with a combined state space of MH and THSimH. We then compare CH with MH using a mapping from the states of CH to those of MH, and similarly with THSimH. By the transitivity of indistinguishability (of the families of views of the same A and H in all three conﬁgurations), we obtain the desired result.
7.2.1 Timing
The goal of a bisimulation is to prove that each input from A or H leads to the same outputs to A and H and to mapped states in the two pairs of conﬁgurations (except for the error sets). In this section, we show how this corresponds to our scheduling model.
We have already informally introduced machines THSimH, MH, and CH as combinations of other machines. However, a combination in the standard sense (formally deﬁned in [34]) leaves all buﬀers separate, and thus its transitions are microtransitions where only one submachine switches. Here we want macro-transitions where the submachines run until control is returned to A or H. Thus buﬀers that are entirely within the combination (i.e., their in, out and clock port) become a normal part of the state of the combined machine. Only for these macro-transitions can we hope for the bisimulation properties. We have to show that they are well-deﬁned for our combinations.
MH is mainly a standard combination of the correct machines Mu because A schedules all the network connections. Only the connections to Encsim,H become internal. As at most one subroutine call to Encsim,H is made in each transition, every macro-transition clearly terminates.
38

In THSimH, the buﬀers ina and outa become internal. When THH obtains a send command or SimH a network input, the entire sequence of steps including id2real or real2id, respectively, becomes one macro-transition. Each one is a legitimate state transitions, because it terminates, as shown in Lemma 6.2, and leads to at most one output at each external port. (A send command leads to at most one network output, but possibly into duplicated buﬀers, and a network input leads to at most one user output.)
7.2.2 Deﬁnition of the Combined System
We now brieﬂy deﬁne the combined system. Possible ambiguities will disappear below, where we compare the eﬀects of all inputs in the three systems.
States of CH The main part of CH is a database D∗ structured like D in THH. An entry x may have the following additional attributes:
• x.word ∈ {0, 1}∗ is always deﬁned and contains real data as in MH or SimH under the same handle(s). For x.type ∈ {sks, ske}, it is for adversary keys, i.e., if owner(x) = a (recall Lemma 4.1.6), else a real secret key. For all other types, the word is non-empty.
• x.parsedu ∈ {true, false} for u ∈ H is ↓ if x.hndu = ↓; otherwise true indicates that the entry would be parsed in Du, and false that it would still be of type null.
• x.owner for ciphertexts with honest-user keys is adv if the ciphertext was received from the adversary, otherwise honest. For other ciphertexts it is ↓.
• x.ec for secret encryption keys corresponds to the encryption counter in ciphers of the encryption machines.
Its state also contains variables size and curhndu as in THH, the inner buﬀer variables outa and ina, all variables stepsp? as in THSimH, and variables stepsoutenc,u ? equal to the step counters in MH.
Transitions of CH The D-part of CH’s database D∗, the variables size and curhndu , and the ideal secure channels are treated exactly as in THH. An entry whose ﬁrst handle x.hndu is for u ∈ H gets the word that Mu would contain under this handle except that also the secret keys from Encsim,H are entered, and otherwise that from SimH. Thus, essentially, entries created due to basic commands from H get the words that Mu and Encsim,H would construct, while words received in network inputs from A are parsed completely and entered as by SimH. Outputs to H are made as in THH, outputs to A as in MH.
7.2.3 Derivations
We now deﬁne the derivations of the original systems from the combined system. They are the mappings that we will show to be bisimulations. We use the following additional notation:
• Let ω abbreviate word lookup, i.e., ω(i) := D∗[i].word if i ∈ HN DS, else ω(i) := i. Let ω∗, applied to a list, denote that ω is applied to each element.
• We give most derived variables and entire machine states a superscript ∗, because in the bisimulation we have to compare them with the “original” versions. We make an exception with some variables of THSimH that are equal by construction in CH; in particular D∗ is CH’s extended database and the derived D-part for THH is immediately called D again.
39

We now assume that a state of CH is given and deﬁne derived states corresponding to the original systems.
THH: D: This is the restriction of D∗ to all attributes except word and parsedu . curhndu (for u ∈ H ∪ {a}), size, and stepsp?: All these variables are equal to those in CH.
MH∗: Du∗: (For every u ∈ H.) We derive Du∗ as follows, starting with an empty database: For every xhnd ≤ curhndu , let x := D∗[hnd u = xhnd].ind , type := D∗[x].type, and m := D∗[x].word . Then • If D∗[x].parsedu = false, then Du∗ :⇐ (xhnd, m, null, ()). • Else if type = {sks, ske}, then Du∗ :⇐ (xhnd, m, type, ()). • Else if type = sks, then Du∗ :⇐ (xhnd, m, sks, D∗[x].arg). (Both have a signature counter.) • Else if type = ske, then Du∗ :⇐ (xhnd, , ske, ()). (A secret key of an honest user is only in Encsim,H.)
curhndu∗: This variable equals curhndu of CH. stepsp∗?: These variables equal stepsp? of CH, except for p? = netu,v,x ? with
(u, v, x) ∈ ch honest , where they equal stepsnet .idu,v,x ? netu∗,v,x : (For every (u, v, x) ∈ ch honest .) Let netu∗,v,x := ω∗(net idu,v,x ).
SimH∗: Da∗: We derive Da∗ as follows, starting with an empty database: For all xhnd ≤ curhnda, let x := D∗[hnd a = xhnd].ind , type := D∗[x].type, and m := D∗[x].word . • If type ∈ {pks, pke} (i.e., not a public key), then Da∗ :⇐ (xhnd, m, ()). • If type ∈ {pks, pke}, let sk ind := x − 1. If owner(D∗[sk ind]) = a, then Da∗ :⇐ (xhnd, m, (adv)), else Da∗ :⇐ (xhnd, m, (honest, ω(sk ind))).
curhnda∗: This variable equals curhnda of CH. stepsp?: These variables are identical to those in CH.
THSimH: outa, ina: These buﬀer contents are equal to those in CH, and we claim that they are empty after each macro-transition.
net id u,v,x: (For every (u, v, x) ∈ ch honest.) The buﬀers of messages on secure channels are equal to those in CH.
Enc∗sim,H: keys∗: We derive keys∗ as follows, starting with an empty database: For all sk ind ≤ size with D∗[sk ind].type = ske and u := owner(D∗[sk ind]) ∈ H, let keys∗ :⇐ (u, D∗[sk ind].word [2], D∗[sk ind + 1].word [2], D∗[sk ind].ec). Thus we take the owner, untagged secret key and counter from the secretkey entry and the untagged public key from the corresponding public-key entry.
ciphers∗: We derive ciphers∗ as follows, starting with an empty database: For all cind ≤ size with D∗[cind].type = enc and D∗[cind].owner = honest, let (pk ind, l ind) := D∗[cind].arg, (l, pk ∗, c∗) := ω∗((l ind, pk ind, cind)), and l∗ = (c∗[4], l). Then set ciphers∗ :⇐ (l∗, pk ∗[2], c∗[3]).
curkey∗: Let curkey∗ = |keys∗|. The buﬀers to and from Enc∗sim,H are empty after each macro-transition.
In the comparison between CH and MH and THSimH, we show that the derived states and outputs are the same as in the original systems except for certain cases that we collect in (families of) error sets. We show in Section 7.7 that the error sets have negligible probability.
40

7.2.4 Invariants in CH
For the bisimulation, we need invariants about CH. Those that concern only the D-part of the state have already been presented in Lemma 4.1. They are index and handle uniqueness, well-deﬁned terms, message correctness, key secrecy, length bounds, and correct key pairs. This lemma also holds for CH because CH always treats the D-part of its state with transitions of THH. We now present new invariants.
• Fully deﬁned. For every x ∈ D∗, the attributes x.ind , x.type, x.arg, x.length, and x.word are never ↓.
• Word uniqueness. For each word m ∈ {0, 1}∗, we have |D∗[word = m ∧ type ∈ {sks, ske}]| ≤ 1.
• Correct length. For all i ≤ size, D[i].len = |D∗[i].word |, except if D[i].type ∈ {sks, ske}.
• No unparsed secret keys. If u ∈ owners(D∗[i]) ∩ H and D∗[i].parsedu = false, then D∗[i].type ∈ {sks, ske}.
• Correct arguments. For all i ≤ size, the real message m := D∗[i].word and the abstract type and arguments, typeid := D∗[i].type and argind := D∗[i].arg, are compatible. More precisely, let argreal := ω∗(argind). Then we require:
– If m = , then typeid ∈ {sks, ske}. – If typeid ∈ {sks, ske}, let (type, argparse) := parse(m). Then type = typeid,
and: ∗ If type ∈ {sig, enc}, then argparse = argreal. ∗ If type = sig, then argparse = argreal[1, 2]. (Parsing does not output a counter.) ∗ If type = enc, then argparse[1] = argreal[1]. Further, let o := D∗[i].owner and sk ind := argind[1] − 1. Then (owner(D∗[sk ind]) = a ⇐⇒ o = ↓). For o = honest, we only claim that l ind := argind[2] = ↓. For o = adv, we claim that the decrypted and looked-up cleartexts are equal: Let sk ∗ := ω(sk ind), l ind := argind[2], and l := parse decrypt(sk ∗, m). We claim that l = ω(l ind).
• Strongly correct arguments if a ∈ owners(D∗[i]) or D∗[i].owner = honest. Let type := D∗[i].type, argind := D∗[i].arg and argreal := ω∗(argind). Then type = garbage and m := D∗[i].word has the following probability distribution:29
– If type ∈ {data, list, nonce}, then m ← make type(argreal).
– If type ∈ {sks, pks, ske, pke}, the formula is applied to pairs, i.e., we have pk ind = sk ind + 1 with appropriate types, and (sk ∗, pk ∗) ← make sig keypair() or (sk ∗, pk ∗) ← make enc keypair(), respectively, for (sk ∗, pk ∗) := ω∗(sk ind, pk ind).
– If type = sig, then argind is of the form (pk ind, l ind, c) with c ∈ N and c ≤ max skc(k). Let sk ind := pk ind − 1 and arg real := ω∗(sk ind, l ind, c). Then a = owner(D∗[sk ind]) and m ← make sig(arg real).
29Here one sees that the bisimulation is probabilistic, i.e., we actually consider distributions of states before and after a transition. This invariant says that in such a state distribution, and given the mentioned arguments, m is distributed as described independent of other state parts.
41

– If type = enc, then argreal is of the form (pk ∗, l) and m of the form (enc, pk , c, r) with pk = pk ∗[2] and where r is distributed as r ←R {0, 1}nonce len(k). Further, o := D∗[i].owner = adv. The distribution of c depends on o: If o = honest (a ciphertext among honest users), then c ← Epk (1|(r,l)|). If o = ↓ (a ciphertext from an honest user to the adversary), then c ← Epk ((r, l)).
• Word secrecy. We require that the adversary never obtains information about nonce-like word components without adversary handles. For this, we deﬁne a set Pub Var of “public” variables that A may know or get to know later as follows: It contains
– all words D∗[i].word with D∗[i].hnd a = ↓;
– the state of A and H;
– the THH-part of the state of CH and the ideal secure channels; – secret keys where the public keys are public, i.e., if D∗[i].hnd a = ↓ and
D∗[i].type ∈ {pks, pks}, then also D∗[i − 1].word .30
We claim that at all times, no information from outside has ﬂown into Pub Var in the sense of information ﬂow in programming languages (static program analysis).
“Word secrecy” implies that no information from “oﬃcial” nonces n , random values r in signatures and ciphertexts, and public keys has ﬂown into Pub Var unless these values have adversary handles. There, the treatment of absence of information ﬂow in the static sense implies absence of Shannon information. We need this stronger notion for the bisimulation because it is inductive: If two variables x and y individually obtain no information ﬂow about a variable z, then neither does the pair (x, y), in contrast to Shannon information.
The following deﬁnition summarizes what we plan to do with these invariants:

Deﬁnition 7.1 (Bisimulation Property) By “an input retains all invariants” we mean the following:

• The resulting macro-transition of CH retains the invariants if they were true before the input.

• If the input is made to MH or THSimH in the state derived from CH, then the probability distribution of the next state equals that of the states derived from
the next state of CH. We call this “correct derivation”.

All conditions are obviously true initially, when all databases and buﬀers are empty

and the counters 0.

3

We use the following general lemma about transitions of CH:

Lemma 7.3 The combined machine CH has the following property:
1. The only modiﬁcations to existing entries x in D∗ of CH are assignments to previously undeﬁned attributes x.hnd u together with x.parsedu := false, changes of x.parsedu from false to true, and (via the commands sign and encrypt) modiﬁcations to the counters in entries of type sks and ske.
30These secret keys are included because information from them ﬂows into the public keys, signatures, and decryptions, but they do not get adversary handles when those values are published. Note that we do not use this analysis for security proofs about the signature and encryption systems.

42

2. The function owner of a secret key never changes.
3. If a state change in CH only consists in a new handle x.hnd u in an existing entry x in D∗ and an assignment to x.parsedu , only the following invariants have to be shown:
• “Correct derivation” of Du and curhndu∗. • “Word secrecy” if u = a.
2
Proof. Part 1 follows immediately from the deﬁnition of CH, and can easily be veriﬁed by inspection of the detailed commands.
For Part 3, it is clear that the other derivations are not aﬀected. “Fully deﬁned”, “word uniqueness”, and “correct length” are clear, and so is “correct arguments” given Part 2. “Strongly correct arguments” is required for fewer entries if an adversary handle is added, and clear for those. For “no unparsed secret keys”, our preconditions never occur for secret keys by “key secrecy”. For “word secrecy” in the case u = a, the new handle does not change which words belong to Pub Var , and the information in x.hnd u is from the D-part of D∗ and thus within Pub Var .
7.3 Comparison of Basic Commands
We ﬁrst consider the eﬀects of a basic command c input at a port inu ? with u ∈ H. Recall that the actions of CH on a large part of its state are by deﬁnition equal to those of THH, and so is CH’s output at outu !. We will not always mention this again.
7.3.1 General Aspects
Lemma 7.4 For an individual basic command c input at inu ?, we can assume it is well-formed and we only have to show the following properties:
• The outputs at outu ! in CH (where it is deﬁned to be as in THH) and MH are the same.
• “Correct derivation” of Du and curhndu .
• For the commands gen enc keypair and encrypt, “correct derivation” of the state of Encsim,H.
• The invariants in D∗ are retained, where “word secrecy” is already clear.
2
Proof. The length functions in THH, and thus CH, and Mu are deﬁned from identical variables stepsinu?, with identical bounds boundsinu? = max in(k), and from identical input domains. The latter follows because the domains are textually equal, and the only dynamic condition is that handle parameters are < curhndu , which is also equal. Hence CH and Mu obtain the same actual inputs. Then they both increment stepsinu?. Next follow domain tests, which are equal as we just saw. Hence the general conventions lead to abortion in the same cases. Hence from now on, we assume that c is well-formed.
Now we exploit that c is local in both THH and Mu. First this implies that the only output in all systems is made at outu !, and that all buﬀer contents and remaining step variables remain correctly derived.
43

Secondly, the submachine SimH of THSimH is not involved, nor is any other machine Mv. We show that their derived counterparts Dv∗ and curhndv∗ with v ∈ H ∪ {a} \ {u} are also unchanged. Locality also means that THH and thus CH does not modify handles for such a value v. Thus curhndv∗ is indeed unchanged, and the database Dv∗ can change at most by changes to a non-handle attribute of an existing entry x of D∗ with x.hnd v = ↓. By Lemma 7.3.1, this can only happen if x.type = sks and in a sign command. (The attribute x.ec for x.type = ske is only used in the derivation of Encsim,H.) However, by “key secrecy” (Lemma 4.1.6), this would imply x.hnd u = ↓, and we easily see below that this is not the case in such a sign command (honest users only sign with their own keys). This proves all the derivations that are not shown individually.
Basic commands other than gen enc keypair and encrypt clearly do not change the state of Encsim,H. Further, they do not modify entries of type ske, pke and enc, upon which the derivation relies.
Finally, we show word secrecy: The output at outu ! and the updates to the D-part of D∗ are made entirely with commands of THH and thus within Pub Var . New or existing words only get a handle for u, so that nothing is added to Pub Var .
7.3.2 One-level Parsing
Many command executions in Mu contain a subroutine “parse xhnd (if necessary)”. We show that it retains the invariants and ensures Du[xhnd].type = null.
The subroutines assign Du[xhnd].type by parsing Du[xhnd].word = D∗[hnd u = xhnd].word if it was still null. By “correct arguments” this is D∗[hnd u = xhnd].type unless we would use it for secret keys, which is excluded by “no unparsed secret keys”. Here CH sets D∗[hnd u = xhnd].parsedu := true if it was still false. Thus in the derived Du∗ we change from (xhnd, m, null, ()) to (xhnd, m, D∗[hnd u = xhnd].type, ()). (Again, exceptions for secret keys are excluded by “no unparsed secret keys”.) This retains “correct derivation” of Du, the only invariant that could be aﬀected, and ensures Du[xhnd].type = null.
7.3.3 Type and Length Queries
We only have to show equal outputs because no state changes are made (beyond possibly that in parsing).
• Type query: t ← get type(xhnd). In THH and thus in CH, we get t = D∗[hnd u = xhnd].type. In Mu, parsing ensures Du[xhnd].type = null, and thus by “correct derivation” t = Du[xhnd].type = D∗[hnd u = xhnd].type. This is equal.
• Length query: l ← get len(xhnd). In THH, we get l = D∗[hnd u = xhnd].len. In Mu, parsing ensures Du[xhnd].type = null. Thus, if Du[xhnd].type ∈ {sks, ske}, we get l = |Du[xhnd].word | = |D∗[hnd u = xhnd].word |. By the invariant “correct length”, this is equal. For Du[xhnd].type ∈ {sks, ske}, both output l = 0.
7.3.4 Storing and Retrieving Data
• Storing: mhnd ← store(m), for m ∈ {0, 1}∗. Let m∗ := (data, m). Correct arguments for the type data means that for every i, D∗[i].type = data and D∗[i].arg = (m) if and only if D∗[i].word = m∗. THH ﬁrst searches for the former kind of entry, Mu for the latter in the derived Du.
44

If it exists and has a u-handle mhnd, both return mhnd. (By word and handle uniqueness, there is at most one.)
If it exists but has no u-handle, THH and thus CH assigns a new handle mhnd := curhnd ++. Mu veriﬁes (in the subroutine :←) that |m∗| ≤ max len(k); this is true by “correct length” for D∗[i]. Thus it makes a new entry (mhnd, m∗, data, ()) with the same handle (by “correct derivation” of curhndu ). Thus CH sets D∗[i].parsedu := true. The outputs are equal and “correct derivation” is retained. By Lemma 7.3.3, this is all we have to show.
If there is no such entry, THH, and thus CH, veriﬁes data len∗(|m|) ≤ max len(k). Mu acts as in the previous case. The length tests are equivalent because data len∗(|m|) = list len(|data|, |m|) = |m∗|. Then both make an entry with mhnd := curhnd ++ and resulting in D∗ :⇐ (ind := size++, type := data, arg := (m), hnd u := mhnd, len := data len∗(|m|), parsedu := true, word := m∗). The outputs are equal, and “correct derivation” is clearly retained. The invariants are shown as follows: “Fully deﬁned” and “no unparsed secret keys” are obvious. “Word uniqueness” holds by the preconditions of this case. “Correct length” holds because we already showed |m∗| = data len∗(|m|). “Correct arguments” was already written out above. “Strongly correct arguments” holds by construction.
• Retrieval: m ← retrieve(mhnd).
Let mind := D∗[hnd u = mhnd].ind and m := D∗[mind].word . THH returns ↓ if D∗[mind].type = data, and Mu if Du[mhnd] = data after parsing. This is equivalent. Otherwise THH returns D∗[mind].arg[1], and Mu returns parse data(Du[mhnd].word )[1]. This is equal by “correct derivation” and “correct arguments”.
7.3.5 Lists
• Generate a list: lhnd ← list(xh1nd, . . . , xhjnd), for j ≥ 0. Let xi := D∗[hnd u = xhi nd].ind for i = 1, . . . , j. THH returns ↓ if any D∗[xi].type ∈ {sks, ske}, and Mu if Du[xhi nd].type ∈ {sks, ske}. This is equivalent even though Du[xhi nd].type may still be null, i.e., D∗[xi].parsedu = false, by “no unparsed secret keys”. Otherwise let l := (list, D∗[x1].word , . . . , D∗[xj].word ).
The rest is similar to store; thus we are briefer: By “correct arguments”, for every i we have D∗[i].type = list and D∗[i].arg = (x1, . . . , xj) iﬀ D∗[i].word = l. If such an entry exists, both THH and Mu determine and return a handle for u to it; Mu’s veriﬁcation that |l| ≤ max len(k) (in :←) is true by “correct length” for D∗[i]. Thus they make the same output and retain “correct derivation”.
If no such entry exists, THH sets length := list len∗(D∗[x1].len, . . . , D∗[xj].len) and veriﬁes length ≤ max len(k). Mu acts as in the previous case. The length tests are equivalent because length = list len(|list|, D∗[x1].len, . . . , D∗[xj].len) = |l| by “correct length” for the entries D∗[xi], which are not secret keys. Then both make an entry with lhnd := curhnd ++ and resulting in D∗ :⇐ (ind := size++, type := list, arg := (x1, . . . , xj), hnd u := lhnd, len := length, parsedu := true, word := l).
The outputs are equal and “correct derivation” is clearly retained. The invariants “fully deﬁned” and “no unparsed secret keys” are obvious, “word uniqueness” holds by the preconditions of this case, “correct length” was already shown, and “correct arguments” and “strongly correct arguments” are obvious.
45

• i-th projection: xhnd ← list proj(lhnd, i), for i ∈ N.
Both THH and Mu return ↓ if D∗[hnd u = lhnd].type = list. This is equivalent because Mu ﬁrst parses. Otherwise THH uses xiind := D∗[hnd u = lhnd].arg[i], while Mu parses D∗[hnd u = lhnd].word , yielding arg, and sets xi := arg[i]. By “correct arguments”, D∗[xiind].word = xi. If xhnd := D∗[xiind].hnd u already exists, THH returns it, and as D∗[xiind].type ∈ {sks, ske} by “key secrecy”, Mu also ﬁnds this entry in the subroutine :← and returns xhnd. Otherwise THH adds it as xhnd := curhndu ++. By “word uniqueness” and “correct derivation”, Mu does not ﬁnd another entry with the word xi, and thus makes a new entry (xhnd, xi, null, ()) with the same handle. (Its test |xi| ≤ max len(k) is true by “correct length” for D∗[xiind].) Equal outputs and “correct derivation” is clear. By Lemma 7.3.3, this is all we have to show.

7.3.6 Nonces
• Generation: xhnd ← gen nonce().
Both THH and Mu set xhnd := curhndu ++ and make a new entry. In CH this results in D∗ :⇐ (ind := size++, type := nonce, arg := (), hnd u := nhnd, len := nonce len∗(k), parsedu := true, word := (nonce, n )) with n ←R {0, 1}nonce len(k).
Equal outputs and “correct derivation” are clear, and so are “fully deﬁned” and “no unparsed secret keys”. If “word uniqueness” is not fulﬁlled, i.e., n equals an old nonce, we put the run in an error set Nonce Coll . “Correct length” is fulﬁlled by obvious computation, and “correct arguments” and “strongly correct arguments” obviously.

7.3.7 Signatures

• Key generation: (skhnd, pkhnd) ← gen sig keypair().
Both THH and Mu set skhnd := curhndu ++; pkhnd := curhndu ++ and make two new entries. In CH this gives D∗ :⇐ (ind := size++, type := sks, arg := (0), hnd u := skhnd, len := 0, parsedu := true, word := sk ∗) and D∗ :⇐ (ind := size++, type := pks, arg := (), hnd u := pkhnd, len := pks len∗(k), parsedu := true, word := pk ∗), where (sk ∗, pk ∗) ← make sig keypair().
The outputs are equal. “Correct derivation” follows with the special deﬁnition for type sks. “Fully deﬁned” is clear, and “no unparsed secret keys” holds because the secret key is parsed. If “word uniqueness” is not fulﬁlled, we put the run in an error set Key Coll . In this case, pk matches an already existing value. (Recall that “word uniqueness” is not required for entries of type sks.) “Correct length” is fulﬁlled by the exception for secret keys, and because pks len∗(k) = list len(|pks|, pks len (k)) = |pk ∗| by deﬁnition of make sig keypair. Under “correct arguments”, nothing is required for type sks, and for pks it is clearly fulﬁlled. “Strongly correct arguments” is obvious.

• Signature generation: shnd ← sign(skhnd, lhnd).

Let sk ind := D∗[hnd u = skhnd].ind and l ind := D∗[hnd u = lhnd].ind . Both

THH D∗[sk

iandn]d.arMg [u1]

return ≥ max

↓ if D∗[sk ind].type skc(k). Their tests

= sks or D∗[l ind].type = are equivalent by “correct

list or deriva-

tion” and although Mu only ensures that Du[lhnd] is parsed by “no unparsed

secret keys”.

Further, THH returns ↓ if length := sig len∗(k, D∗[l ind].len) > max len(k). Else it sets shnd := curhndu ++, pk ind := sk ind + 1 and c := D∗[sk ind].arg[1]++.

46

Then THH makes a new entry D :⇐ (ind := size++, type := sig, arg := (pk ind, l ind, c), hnd u := shnd, len := length).
Mu uses (sk ∗, l) := ω(sk ind, l ind) and sets c := Du[skhnd].add arg[1]++ and s∗ ← make sig(sk ∗, l, c). If |s∗| > max len(k), it decrements Du[skhnd].add arg[1] again and returns ↓. This length test equals that in THH: By “strongly correct arguments”, the key pair including sk ∗ was generated with make sig keypair (because by “key secrecy” the secret key has at most one handle, and this is D∗[sk ind].hndu by the input condition). With the notation from inside make sig, this means that sk was correctly generated, and thus by Section 5.1.1, we have |sig| = sig len(k, max skc(k), |(r, l)|) = sig len (k, |l|). This yields |s∗| = sig len∗(k, |l|), and by “correct length” for the entry D∗[l ind] (which is not a secret key) this is what THH veriﬁed.
Hence either both do not change their state and return ↓, or both make the described updates and Mu sets shnd := curhndu ++ and makes an entry Du :⇐ (shnd, s∗, sig, ()).
The outputs are equal, and the update to D∗[sk ind] retains “correct derivation” because the counters are updated consistently, and no invariants is aﬀected.
Now we consider the new signature entry: “Correct derivation” is clear if we augment THH’s entry with the word s∗ and parsedu = true. “Fully deﬁned” and “no unparsed secret keys” are clear. If “word uniqueness” is not fulﬁlled, then r within s∗ equals an old value in the same place in a word; hence we put the run in an error set Nonce Coll . “Correct length” is fulﬁlled as shown above.
“Correct arguments” follows by comparing the output format of make sig with the predicate in parse sig. Here we exploit that correctly generated signatures for correct key pairs are always valid (Section 5.1.1), that l is a tagged list by “correct arguments” for D∗[l ind], and that D∗[pk ind] = pk ∗ as returned by parsing by “strongly correct arguments” for the key pair. “Strongly correct arguments” holds by construction and because c ≤ max skc(k).

• Signature veriﬁcation: v ← verify(shnd, pkhnd, lhnd).

Let sig.

s

ind := D∗[hnd (Indeed Mu

u= has

shnd].ind parsed

. Both THH the entry.)

and Mu return ↓ Otherwise, let

if D∗[sind].type = (pk ind, l ind, c) :=

D∗[sind].arg, s∗ := D∗[sind].word , and (pk ∗, l) ← parse sig(s∗). By “correct

arguments” for the entry D∗[sind], we have (pk ∗, l) = ω∗(pk ind, l ind).

Then THH outputs true if pkhnd = D∗[pk ind].hnd u and lhnd = D∗[l ind].hnd u , and Mu if D∗[hnd u = pkhnd].word = pk ∗ and D∗[hnd u = lhnd].word = l. By the previous paragraph, the former clearly implies the latter. By “word uniqueness”, the latter also implies the former. Otherwise both output false.

• Public-key retrieval: pkhnd ← pk of sig(shnd).

We start exactly as in signature veriﬁcation: Let sind := D∗[hnd u = shnd].ind .

Both THH and Mu entry.) Otherwise,

return ↓ if D∗[sind].type = sig. (Indeed let (pk ind, l ind, c) := D∗[sind].arg, s∗ :=

Mu has parsed the D∗[sind].word , and

(pk ∗, l) ← parse sig(s∗). By “correct arguments” for the entry D∗[sind], we

have (pk ∗, l) = ω∗(pk ind, l ind).

The rest is as in list projection: If D∗[pk ind].hnd u already exists, both return it. Otherwise THH adds it as pkhnd := curhndu ++. By “word uniqueness” and “correct derivation”, Mu does not ﬁnd another entry with the word pk ∗, and thus makes a new entry (pkhnd, pk ∗, null, ()) with the same handle. (Its test |pk ∗| ≤ max len(k) is true by “correct length” for D∗[pk ind].) Equal outputs

47

and “correct derivation” are clear. By Lemma 7.3.3, this is all we have to show.
• Message retrieval: lhnd ← msg of sig(shnd). This is exactly like public-key retrieval, only with the second argument, l ind, of D∗[s].arg.

7.3.8 Public-key Encryption

For the ﬁrst two of the following commands, Lemma 7.4 requires us to also consider the encryption machine. Recall that the counters curkey and K.ec of entries in keys never reach their bounds. (This follows from Lemma 7.2.2 inductively with the fact that the derived real system that we actually consider equals a normal real one.)

• Key generation: (skhnd, pkhnd) ← gen enc keypair().
Both THH and Mu set skhnd := curhndu ++, pkhnd := curhndu ++.
Then Mu calls the encryption machine with pk ← (generate) at port inenc,u ?. As curkey has not reached its bound, Encsim,H generates a key pair as (sk , pk ) ← genE(1k) and makes an entry (u, sk , pk , 0) in keys. This implies |pk | = pke len(k) and thus Mu accepts pk . Then THH and Mu each make two new entries. In CH, this gives D∗ :⇐ (ind := size++, type := ske, arg := (), hnd u := skhnd, len := 0, parsedu := true, word := (ske, sk ), ec := 0) and D∗ :⇐ (ind := size++, type := pke, arg := (), hnd u := pkhnd, len := pke len∗(k), parsedu := true, word := (pke, pk )).
Equal outputs and “correct derivation” of Du and curhndu are clear. In the derived keys∗, the new secret-key entry in D∗ leads to an entry (u, sk , pk , 0). This equals the new entry in keys. The counters curkey and curkey∗ clearly remain equal, and nothing changes in ciphers and ciphers∗.
“Fully deﬁned” is clear, and “no unparsed secret keys” holds because the secret key is parsed. “Word uniqueness” is only required for the public key. If it is not fulﬁlled, and thus pk equals an old key, we put the run in an error set Key Coll . “Correct length” is only needed for the public key and follows from the deﬁnition of pke len∗. “Correct arguments” is only needed for the public key and clear there. “Strongly correct arguments” holds by simple comparison with the algorithm make enc keypair.

• Encryption: chnd ← encrypt(pkhnd, lhnd).

Let pk ind := D∗[hnd u = pkhnd].ind and l ind := D∗[hnd u = lhnd].ind . Both

MTHuHhaasnpdaMrseudrebtoutrhne↓ntirfieDs.∗)[pLkeintd(].ptkyp∗e, l)=:=pkωe ∗o(r(pDk∗in[dl

ind].type = , l ind)) and

list. (Indeed, pk := pk ∗[2].

We have |pk | = pke len(k) even if it is an adversary key because “correct

arguments” for D∗[pk ind] implies that parse pke(pk ∗) does not return ↓.

Further, THH returns ↓ if length := enc len∗(k, D∗[l ind].len) > max len(k), and so does Mu if enc len∗(k, |l|) > max len(k) (by the rewritten algorithm make enc). This is equivalent by “correct length” for D∗[l ind].

Now Mu sets r ←R {0, 1}nonce len(k) and l∗ := (r, l), and calls the encryption machine with c ← (encrypt, pk , l∗) at port inenc,u ?. We distinguish two cases, where sk ind := pk ind − 1 and v := owner(D∗[sk ind]):

– If v ∈ H, then by “correct derivation” of keys, there is an entry K in keys with K.pkenc = pk . Encsim,H sets K.ec++, and CH reﬂects that in D∗[sk ind].ec++. Then Encsim,H sets c ← Epk (1|l∗|) and ciphers :⇐ (l∗, pk , c) and returns c. Clearly |c| = enc len (k, |l|).

48

– If v = a, then by “correct derivation” of keys and “word uniqueness”, there is no such entry K in keys. Then Encsim,H immediately returns ↓, and Mu itself encrypts c ← Epk (l∗). Again we have |c| = enc len (k, |l|). (Recall that pk is of correct length even for adversary keys.)

In both cases, Mu sets c∗ := (enc, pk , c, r), and we get |c∗| = enc len∗(k, |l|). Thus c∗ passes the length test in the outer algorithm encrypt.
Now both THH and Mu set chnd := curhndu ++ and make a new entry. In CH, this gives D∗ :⇐ (ind := size++, type := enc, arg := (pk ind, l ind), hnd u := chnd, len := length, parsedu := true, word := c∗), and additionally D∗[size].owner := honest if v ∈ H.
The outputs are equal. “Correct derivation” of Du and curhndu is clear for the new entry, and the counter update in D∗[sk ind] does not inﬂuence this derivation. If v = a, then Encsim,H does not change its state and the new entry in D∗ does not inﬂuence Enc∗sim,H either. If v ∈ H, the update K.ec++ occurs in both keys and keys∗. Further, the new entry in D∗ leads to an entry ((c∗[4], l), pk ∗[2], c∗[3]) in ciphers∗, which equals the new entry in ciphers.
Among the invariants, “fully deﬁned” and “no unparsed secret keys” are clear. If “word uniqueness” is not fulﬁlled, then r equals a previous value in an encryption entry. Hence we put the run in an error set Nonce Coll . “Correct length” was already shown. For “correct arguments”, only the public-key equality and the conditions involving o are required in both our cases, which are obvious. “Strongly correct arguments” holds by construction, exactly according to our two cases.

• Decryption: lhnd ← decrypt(skhnd, chnd).

Let sk ind := D∗[hnd u = skhnd].ind and cind := D∗[hnd u = chnd].ind . Both THH and Mu return ↓ if D∗[sk ind].type = ske or D∗[cind].type = enc. Their

tests that

are equivalent by Du[chnd] is parsed

“correct derivation” and although Mu only by “no unparsed secret keys”. Otherwise, let

ensures pk ind :=

D∗[cind].arg[1], c∗ := D∗[cind].word , and (pk ∗) ← parse enc(c∗). By “correct

arguments” for the entry D∗[cind], we have pk ∗ = D∗[pk ind].word .

Next, THH returns ↓ if pk ind = sk ind + 1, while Mu sets pkhnd := skhnd + 1 and returns ↓ if Du[pkhnd].word = pk ∗. This is equivalent to THH’s test: We have u = owner(D∗[sk ind]) by key secrecy and because there is the handle skhnd for u. Hence if pk ind = sk ind + 1, then by “correct key pairs” we have D∗[pk ind].hnd u = pkhnd and the word is indeed pk ∗. Else by “word uniqueness” it is not.

Now both machines are willing to decrypt. THH uses l ind := D∗[cind].arg[2]. We have l ind = ↓ or D∗[l ind].type = list, as D∗[cind] must have been constructed with the command encrypt or adv invalid ciph. Hence l := ω(l ind) is either ↓
or, by “correct arguments”, a tagged list. We show that Mu’s internal result equals l.

Mu sets pk := pk ∗[2] and (c, r) := c∗[3, 4] and calls the encryption machine with l∗ ← (decrypt, pk , c) at port inenc,u !. By “correct derivation” of keys, there is an entry K = (u, sk , pk , ec) ∈ keys, where sk = sk ∗[2] for sk ∗ := D∗[sk ind].word . Encsim,H ﬁnds exactly this entry because pkenc is a key attribute. Now it decrypts to some l∗. We distinguish two cases according to o := D∗[cind].owner , where o = ↓ because u = owner(D∗[sk ind]) ∈ H.

– If o = honest, then by “correct arguments”, l ind = ↓. Thus by “correct derivation”, ciphers contains the entry e := ((r, l), pk , c). If there is

49

another entry e with the same pk and c and another attribute e .msg, we put the run in an error set Ciph Coll . Thus we now assume that Encsim,H ﬁnds entry e. Hence it returns (r, l), which passes Mu’s tests in decrypt. Hence Mu obtains l.
– If o = adv, no entry in ciphers is derived from D∗[cind]. Typically Encsim,H will therefore return l∗ := Dsk (c). Together with the rest of decrypt this means that Mu derives its result as l := parse decrypt(sk ∗, c∗). (The additional length test |l∗| ≤ |c| is fulﬁlled by Section 5.1.2.) “Correct arguments” for this case implies l = l.

– If o = adv, there might nevertheless be an entry ((r1, l1), pk , c) ∈ ciphers,

derived from (using “word

uannioqtuheenresesn”t)r,yDin∗[cDh1n∗d].waritgh[1]D=∗[cph1knidn]d.,owωn(Der∗[c=h1ndh]o.anregs[t2]a)n=d

l1, and D∗[ch1nd].word = (enc, pk , c, r1). “Word uniqueness” implies c∗1 =

c∗ and thus r1 = r. Then Encsim,H returns (r1, l1) and in decrypt, the

comparison with r from c∗ fails. (This is the non-malleability of the

encryption system with additional randomization.) Hence Mu sets l := ↓.

We have to show that also l ind = ↓. “Strongly correct arguments” applies to D∗[ch1nd]. Thus c was chosen as Epk (1|(r1,l1)|). This implies Dsk (c) = 1|(r1,l1)|. Hence for the entry D∗[cind], where “correct arguments” applies, we have parse decrypt(sk ∗, c∗) = ↓ because the intermediate result l∗ = 1|(r1,l1)| is not a list. This implies l ind = ↓ as desired.

The next part is as in list projection: If D∗[l ind].hnd u already exists, both return it. Otherwise THH adds it as lhnd := curhndu ++. By “word uniqueness” and “correct derivation”, Mu does not ﬁnd another entry with the word l , and thus makes a new entry (lhnd, l , list, ()) with the same handle. (Its test |l | ≤ max len(k) is true by “correct length” for D∗[l ind].) Equal outputs are clear, and for “correct derivation” D∗[l ind].type = list was already shown. By
Lemma 7.3.3, this is all we have to show.

• Public-key retrieval: pkhnd ← pk of enc(chnd).

This works almost exactly as for signatures: Let cind := D∗[hnd u = chnd].ind .

Both THH the entry.)

and Mu return Otherwise, let

↓ if (pk

inDd,∗l[icndin)d]:.=typDe ∗=[ciennd]c..arg(I,ncd∗ee:d=MDu∗

has [cind

parsed ].word ,

and (pk ∗) ← parse enc(c∗). By “correct arguments” for the entry D∗[cind], we

have pk ∗ = ω(pk ind).

If D∗[pk ind].hnd u already exists, both return it. Otherwise THH adds it as pkhnd := curhndu ++. By “word uniqueness” and “correct derivation”, Mu does not ﬁnd another entry with the word pk ∗, and thus makes a new entry (pkhnd, pk ∗, null, ()) with the same handle. (Its test |pk ∗| ≤ max len(k) is true by “correct length” for D∗[pk ind].) Equal outputs and “correct derivation” are
clear. By Lemma 7.3.3, this is all we have to show.

7.4 Send Command from Honest User
We now consider an input send x (v, luhnd) at a port inu ? with u ∈ H. Intuitively, this part of the proof shows that the adversary does not get any information in the real system that it cannot get in the ideal system, because any real information can be simulated indistinguishably given only the outputs from THH.

50

7.4.1 General Aspects
As with basic commands, the length function for the port inu ?, and thus the actual input, is equal in THH, and thus CH, and Mu. Then they all increment stepsinu? and make the same domain test. Hence from now on, we assume that the input is well-formed. Let l ind := D∗[hnd u = luhnd].ind . Both THH and Mu continue only if D∗[l ind].type = list. (The conditions are equivalent by “correct derivation” and because Mu has parsed the entry.)
Now Mu always outputs l := D∗[l ind].word (here we used “correct derivation” again) at port netu,v,x ! without further action. We distinguish two overlapping cases.
Secure Channel: (u, v, x) ∈ ch honest. Then THH and CH output l ind at net idu,v,x ! without further action. The only invariant that could be aﬀected is correct derivation of secure-channel buﬀers. This holds by deﬁnition for THSimH. For MH, we retain netu∗,v,x = ω∗(net idu,v,x ) because we already showed l = D∗[l ind].word .
Output to Adversary: (u, v, x) ∈ ch to adv . Here netu,v,x ! is connected to A, and thus CH outputs l there like Mu at the end. However, it ﬁrst continues to update the THH-part of its state.
If lhnd := D∗[l ind].hnd a already exists, THH outputs (u, v, x, lhnd) at outa! and schedules it. By Lemma 6.2.5, handles output by THH are always accepted by SimH and the counters stepsouta? of SimH and stepsina? of THH never reach their bounds. This also holds for the counters in CH; this follows (inductively) from the equality of these values with the state of THSimH.
Thus SimH accepts the resulting input. By “correct derivation”, SimH ﬁnds Da[lhnd].word = D∗[l ind].word = l and outputs it at netu,v,x !. This ensures equal outputs. Also “correct derivation” of the buﬀers outa and ina and the corresponding counters is clear. The only other invariant that could be aﬀected is “word secrecy”. It follows because the output already had an a-handle, so that the ﬂow is within Pub Var .
Thus the case D∗[l ind].hnd a = ↓ remains. Here THH assigns lhnd := curhnda++ and outputs (u, v, x, lhnd) at outa!. As above, this input is accepted by SimH. By “correct derivation”, SimH ﬁnds Da[lhnd] = ↓. It sets curhnda++, thus maintaining “correct derivation” of these variables. Then SimH calls l ← id2real(lhnd) and outputs l at netu,v,x !. It is therefore suﬃcient to show that id2real together with the commands it inputs to THH retains all invariants and yields l = D∗[l ind].word .
7.4.2 General Aspects of id2real
We use an inductive proof that id2real retains all invariants and produces the right output. The following lemma deﬁnes the weaker conditions that hold for all subcalls, and proves some invariants once and for all.
Lemma 7.5 It is suﬃcient to show the following for each recursive call m ← id2real(mhnd):
• Initially,
– mhnd ≤ curhnda, – the entry e := D∗[hnd a = mhnd] has e.type = list or is a component of
another entry, and
– the entry e already existed with a ∈ owners(e).
51

• The following invariants hold before every subcall and at the end:

– Weakly correct derivation of Da: We have curhnda = curhnda∗ and Da is a subset of Da∗.
– Weak word secrecy. Secret information only must not ﬂow into the smaller set Pub Var containing only the words Da[ihnd].word instead of all D∗[i ind].word with D∗[i ind].hnd a = ↓, and the corresponding secret keys.

• At the end, the following holds:

– Result: The result is m = m∗ := e.word .

– Progress: If Da and curhnda are the values before the call, and Da and curhnda those after the call, then Da is a superset of Da and contains entries Da[mhnd] and Da[xhnd] for all curhnda < x ≤ curhnda.

The initial conditions and invariants are fulﬁlled before the outermost call.

2

Proof. All normal invariants were true before CH, like THH, assigned D∗[l ind].hnd a := lhnd := curhnda++ before the outermost call. After this assignment, they still hold except that the entry Da∗[lhnd] is missing in Da, and that we do not know about “word secrecy” for the entry with the new adversary handle.
Thus the weaker invariants of this lemma hold. The initial conditions also hold because D∗[l ind].type = list was explicitly veriﬁed, and the entry had D∗[l ind].hnd a = ↓ before the assignment.
As only Da∗[lhnd] is missing before the outermost call, “weakly correct derivation” and “progress” imply that normal “correct derivation” of Da holds after this call. This also implies “word secrecy”. Furthermore, the result is then l = D∗[hnd a = lhnd].word = D∗[l ind].word , as required.
We now show why the remaining invariants hold automatically. “Correct deriva-
tion” of the state of THH holds by deﬁnition, as well as of the buﬀers outa and ina and the corresponding counters. These buﬀers are empty after the macro-transition
by the subroutine behavior within id2real.
In MH and its encryption machine Encsim,H, nothing changes, and nor does it in the derived version because only the command adv parse is executed in THH during id2real, and it only assigns new adversary handles (recall Lemma 7.3.3).
As CH only assigns adversary handles in D∗, the invariants except for “word secrecy” are unaﬀected.
Now we consider one of these recursive calls m ← id2real(mhnd) and show that it retains the invariants of Lemma 7.5. Let mind := D∗[hnd a = mhnd].ind and m∗ := D∗[mind].word and (m1ind, . . . , mjind) := D∗[mind].arg.

7.4.3 Steps 1 and 2: Parsing and Handle Updates
In Step 1, id2real calls (type, (mh1nd, . . . , mhjnd)) ← adv parse(mhnd) at ina!. By deﬁnition, this gives type := D∗[mind].type, and, except if type = enc, also (mh1nd, . . . , mhjnd) := ind2hnd∗a ((m1ind, . . . , mjind)).
We show that the domain expectations of id2real are fulﬁlled:
• type ∈ typeset \{sks, ske, garbage}: For garbage this follows from “strongly correct arguments”, because D∗[mind] already existed without adversary handle by the preconditions of Lemma 7.5. For sks, ske it follows from key secrecy, because D∗[mind] is of type list or a component of another entry.

52

• j ≤ max len(k): The only type of entry in D∗ with multiple arguments is list, and in list generation THH, and thus CH, veriﬁes this condition.
• mhi nd ≤ max hnd(k) if mhi nd ∈ HN DS follows from Lemma 6.2.5. (We already showed that it also holds in CH.)
• Otherwise |mhi nd| ≤ max len(k) holds because arguments that are not handles only occur for the following types: data, where THH veriﬁed it when storing; sks, which was excluded; sig, where it is a counter c that can become at most max skc(k) by “strongly correct arguments”, so that |c| ≤ max len(k) follows from the conditions on length functions; enc if the ciphertext length len is output; then it follows from Lemma 4.1.4.
The only resulting change in D∗ is that new a-handles may have been assigned to some of the entries D∗[miind]. (We do not mention the step-counters because we already know “correct derivation” for them and that they do not reach their bounds.) Clearly these handles are in HN DS and appear in increasing order in (mh1nd, . . . , mhjnd).
Hence Step 2 of id2real updates curhnda consistently. This reestablishes “weak correct derivation of Da”. Further, it clearly retains “weak word secrecy”.
7.4.4 Step 3: Recursion In Step 3, id2real considers the values mhi nd ∈ HN DS. For those with Da[mhi nd] = ↓, it sets mi := Da[mhi nd].word without any state changes, so that the invariants are clearly retained. For the others, it makes recursive calls mi ← id2real(mhi nd).
We have to show that the initial conditions from Lemma 7.5 hold for these calls.
• mhi nd ≤ curhnda is clear by the updates of curhnda in Step 2. • The entries D∗[hnd a = mhi nd] are components of the entry D∗[hnd a = mhnd]
by deﬁnition of components and adv parse.
• The entry D∗[hnd a = mhi nd] already existed before the outermost call (because no new entries are made). At that time a ∈ owners(D∗[hnd a = mhi nd]) must have been true because normal “correct derivation of Da” held.
Thus by the induction hypothesis, these calls retain the invariants. We show that they also establish the second “progress” property for our call id2real(mhnd): The ﬁrst “progress” property of each subcall, the existence of an entry Da[mhi nd], means that entries in Da now exist for all values assigned to curhnda directly in our call id2real(mhnd) (in Step 2). The second “progress” property of the subcalls ensures that entries also exist for all further increments they made to curhnda. Hence indeed entries exist for all new values of curhnda of our call and its subcalls. By the “result” properties of the subcalls, we obtain mi = D∗[hnd a = mhi nd].word = D∗[miind].word = ω(miind) for all mhi nd ∈ HN DS. As id2real sets mi := mhi nd = miind for the other i’s, it obtains
argreal := (m1, . . . , mj ) = ω∗(argind),
except in certain cases for type = enc, and where argreal equals that in the formulation of “strongly correct arguments”.
53

7.4.5 Step 4: General Aspects of Type-speciﬁc Part
Now id2real proceeds depending on type. Each of these variants ends with an assignment to m, which is then output, and Da :⇐ (mhnd, m, add arg) for certain arguments add arg. No further changes to Da are made and THH is not involved.
Lemma 7.6 For the individual types, we only have to show:
• a correct result m = m∗, where we can assume “strongly correct arguments” for m∗, i.e., the entry D∗[mind];
• “correct derivation” of add arg in the new entry, and only for type ∈ {pks, pke};
• “word secrecy” for m, i.e., no ﬂow of secret information into m, where arguments mi are not secret information.
2
Proof. “Strongly correct arguments” holds for D∗[mind] because it had no adversary handle initially by Lemma 7.5. The rest of “weakly correct derivation” follows from the correctness of m and because add arg is always () for the other types, as required (recall that the types sks and ske are not possible). The new entry in Da gives us the missing ﬁrst part of “progress”. For “weak word secrecy”, only m is added to Pub Var . All values mi already belong to Pub Var : If mhi nd ∈ HN DS they were entered into Da at the latest in Step 3, and if mhi nd ∈ HN DS they were output by THH.

7.4.6 Data, Lists, and Nonces
If type ∈ {data, list, nonce}, then id2real sets m ← make type(argreal). “Strongly correct arguments” for these types means that m∗ also has the prob-
ability distribution m∗ ← make type(argreal). Thus derivation of Da∗ gives the same distribution as we get in Da.
“Word secrecy” for m holds for data and list because their generation depends only on the arguments mi (the list elements or the raw data). For nonces it holds since each nonce generation does not depend on prior information.

7.4.7 Public Signature Keys

If type = pks, then id2real sets (sk ∗, pk ∗) ← make sig keypair(), m := pk ∗ and

add arg := (honest, sk ∗).

Let sk ind = mind − 1 and (sk ∗real, pk ∗real) := (D∗[sk ind].word , m∗). By “strongly

correct arguments” (sk ∗real, pk ∗real) was chosen with make sig keypair(). “Correct

key pairs” implies a = owner(D∗[sk ind]), because otherwise D∗[mind] would also

have got (mhnd, pk

an a-handle at ∗real, (honest, sk ∗

reoaln)c)ew. itIhnththeesadmereivdeidstrDiba∗u,tiwone

therefore have an as id2real’s choice.

entry

“Word secrecy” for m = pk ∗ holds since key generation does not depend on

prior information, and both pk ∗ and sk ∗ become elements of Pub Var .

7.4.8 Signatures
If type = sig, “strongly correct arguments” implies that argind is of the form (pk ind, l ind, c) with c ∈ N. Let (pk ∗, l, c) := argreal = ω∗(argind). First this implies c = false, as claimed in id2real. Let sk ind := pk ind − 1 and sk ∗ := ω(sk ind). By “strongly correct arguments”, m∗ is distributed as m∗ ← make sig(sk ∗, l, c). Furthermore, it

54

implies a = owner(D∗[sk ind]). By “correct derivation” of Da for the existing entries, this implies Da[pkhnd].add arg = (honest, sk ∗), where pkhnd = D∗[pk ind]. This proves the second format claim in id2real, and id2real sets m ← make sig(sk ∗, l, c).
This is the same distribution. For proving “word secrecy” for m, we only have to consider the parameter sk ∗,
because l and c are parameters mi (and make sig is functional). By deﬁnition of “word secrecy”, sk ∗ belongs to Pub Var , but may contain information from the corresponding public key pk ∗. As this is our parameter m1, it belongs to Pub Var already. This proves “word secrecy”.

7.4.9 Public Encryption Keys

If type = pke, then id2real sets (sk ∗, pk ∗) ← make enc keypair(), m := pk ∗, and

add arg := (honest, sk ∗).

Let sk ind = mind − 1 and (sk ∗real, pk ∗real) := (D∗[sk ind].word , m∗). By “strongly

correct arguments” (sk ∗real, pk ∗real) was chosen with make enc keypair(). “Correct

key pairs” implies a = owner(D∗[sk ind]), because otherwise D∗[mind] would also

have got (mhnd, pk

an a-handle at ∗real, (honest, sk ∗

reoaln)c)ew. itIhnththeesadmereivdeidstrDiba∗u,tiwone

therefore have an as id2real’s choice.

entry

“Word secrecy” for m = pk ∗ holds since key generation does not depend on

prior information, and both pk ∗ and sk ∗ become elements of Pub Var .

7.4.10 Ciphertexts
If type = enc, then by “strongly correct arguments”, argind is of the form (pk ind, l ind) with l ind = ↓. This proves the format claim in id2real. Let (pk ∗, l ) := ω∗(pk ind, l ind), sk ind := pk ind − 1, v := owner(D∗[sk ind]), and o := D∗[mind].owner .
“Strongly correct arguments” further implies that o = adv and m∗ is of the form (enc, pk , c, r) with pk = pk ∗[2] and r distributed as r ←R {0, 1}nonce len(k).

Case 1: Ciphertext for Adversary If v = a, no exception occurred in adv parse and id2real obtained argreal = (pk ∗, l ) as usual. Then it sets m ← make enc(pk ∗, l )
(for the unmodiﬁed make enc) and add arg := (). For m∗, “correct arguments” implies o = ↓. Thus by “strongly correct argu-
ments”, c is distributed as c ← Epk ((r, l)). Hence altogether m∗ is also distributed as make enc(pk ∗, l ).
“Weak word secrecy” holds because only parameters mi are used and make enc is functional.

Case 2: Ciphertext for Honest User If v ∈ H, the output of adv parse was arg = (pk ind, len) with len := D∗[l ind].len, and id2real derived argreal = (pk ∗, len) as claimed. Then it sets len∗ := list len(nonce len(k), len), c ← Epk (1len∗ ), r ←R {0, 1}nonce len(k), m := (enc, pk , c , r ), and add arg := ().
For m∗, “correct arguments” and o = adv imply o = honest. Thus by “strongly correct arguments”, c is distributed as c ← Epk (1|(r,l)|). Here |l| = len by “correct length” for D∗[l ind], and thus |(r, l)| = len∗. Thus the distributions of c and c are equal, and hence also those of m and m∗.
For “weak word secrecy”, the variables used in computing m are len, constants, pk ∗, and r , where len is an output of THH and thus already in Pub Var , pk ∗ is m1 and need not be considered, and r is a newly generated nonce r and not stored in
other variables. Hence, “weak word secrecy” holds.

55

7.5 Network Input from the Adversary
We now consider the eﬀects of an input l from A at a port netw,u,x ? with (w, u, x) ∈ ch from adv . Recall that on such an input CH acts entirely like THSimH.
7.5.1 General Aspects
The length function for the port netw,u,x ?, and thus the actual input, is equal in SimH, and thus CH, and Mu. Then they all increment stepsnetw,u,x ? and only continue if l is a tagged list. Hence from now on, we assume this.
Now SimH and thus CH call lahnd ← real2id(l) to parse the input. We ﬁrst reduce our goals to properties of this algorithm and its side eﬀects.
Lemma 7.7 To show that network inputs give equal outputs and retain all invariants, it is suﬃcient to prove the following properties of each call lahnd ← real2id(l) with 0 < |l| ≤ max len(k) and l ∈ Pub Var :
• At the end, D∗[hnd a = lahnd].word = l and D∗[hnd a = lahnd].type ∈ {sks, ske}.
• “Correct derivation” of Da and curhnda.
• The invariants within D∗ are retained, where “strongly correct arguments” is already clear and “word secrecy” need only be shown for the outermost call (without subcalls) if more entries than D∗[hnd a = lahnd] are made or updated there.
2
Proof. Correct derivation of entire state for real2id: First we show that the execution of real2id retains the remaining derivations:
For the state of THH this holds by deﬁnition, as well as for the buﬀers outa and ina and the corresponding counters. These buﬀers are empty after the macrotransition by the subroutine behavior within real2id.
In MH, nothing changes. We show that its derived counterparts Dv∗ and curhndv∗ with v ∈ H are also unchanged. As real2id only uses local commands, handles for these users are not aﬀected. Thus curhndv∗ is indeed unchanged, and Dv∗ can change at most by changes to a non-handle attribute of an existing entry x ∈ D∗ with x.hnd v = ↓. By Lemma 7.3.1, this can only happen if x.type = sks and in a sign command. (The changeable attribute x.ec for x.type = ske is not involved in derivations.) However, by “key secrecy” (Lemma 4.1.6), this would imply x.hnd a = ↓, and we easily see below that this is not the case in such a sign command.
Nothing changes in Encsim,H because MH is not involved. The derived Encsim,H could only change by updates to secret-key entries with honest owner, which is clearly impossible by commands entered at ina?, and new entries of type enc with attribute owner = honest, which is also impossible.
Remaining invariants for real2id: “Strongly correct arguments” holds because all new entries in C∗ due to inputs at ina? get an adversary handle and do not get the attribute owner = honest, so that nothing is required. For “word secrecy”, we need not consider the entry D∗[hnd a = lahnd] because the content l of D∗[hnd a = lahnd].word is already in Pub Var by a precondition.
Actions after real2id: Now we show that the remaining actions of the macrotransition retain all invariants and produce the same output in all systems. When real2id returns lahnd, SimH outputs and schedules adv send x (w, u, lahnd) at ina!. Let l ind := D∗[hnd a = lahnd].ind . Then THH veriﬁes that D∗[l ind].type = list; this is true by “correct arguments” because D∗[l ind].word = l is a tagged list.
56

If luhnd := D∗[l ind].hnd u = ↓, THH outputs (w, x, luhnd) at outu !. By “correct derivation” of Du, Mu ﬁnds the same handle when executing (luhnd, Du) :← (l, list, ()) and makes the same output. Then all invariants are clearly maintained.
Otherwise THH adds this handle as luhnd := curhndu ++. By “word uniqueness” and “correct derivation”, Mu does not ﬁnd another entry with the word l, and thus makes a new entry (luhnd, l, list, ()) with the same handle. (The test |l| ≤ max len(k) in :← is true by the initial domain test.) “Correct derivation” is clear. By Lemma 7.3.3, this is all we have to show.
7.5.2 General Aspects of real2id
We show inductively that for every m ∈ {0, 1}+ with |m| ≤ max len(k) and m ∈ Pub Var , the execution of mhnd ← real2id(m) together with its side eﬀects fulﬁlls the conditions from Lemma 7.7.
If there is already a handle mhnd with Da[mhnd].word = m, real2id returns that. The output condition of Lemma 7.7 is fulﬁlled by “correct derivation”, and the others because no state changes are made.
Otherwise, the word m is not yet present in Da. Then id2real sets (type, arg) := parse(m). This yields type ∈ typeset \ {sks, ske}. As parse is a functional algorithm, no invariants are aﬀected. Then id2real calls an algorithm add arg ← real2id type(m, arg) with side-eﬀects. Finally it sets mhnd := curhnda++ and Da :⇐ (mhnd, m, add arg).
We therefore have to show the properties from Lemma 7.7 for these type-speciﬁc algorithms together with those last two assignments. In the following, we write arg in the form it must have in an output (type, arg) of parse.
7.5.3 Garbage
The algorithm real2id garbage(m, ()) calls mhnd ← adv garbage(|m|) at ina! and sets add arg := (). Then THH makes a new entry with mhnd := curhnda++. Together with the new entry in Da, this results in D∗ :⇐ (ind := size++, type := garbage, arg := (), hnd a := mhnd, len := |m|, word := m). (Attributes parsedu are only deﬁned for u ∈ H and are all still ↓.)
“Correct derivation” is clearly retained, and the new entry is as required in Lemma 7.7. “Fully deﬁned”, “correct length”, “no unparsed secret keys”, and “correct arguments” are obvious. “Word secrecy” is clear as no other entries are involved.
Now assume that “word uniqueness” were not fulﬁlled. Then there is a prior entry x ∈ D∗ with x.word = m and x.type ∈ {sks, ske}. Further, it has x.hnd a = ↓ because the word m does not exist in Da. By “correct arguments”, it has x.type ∈ {sks, ske, garbage}. This leaves only the case garbage, but that is impossible because such entries are only made due to adversary commands and thus with x.hnd a = ↓.
7.5.4 Data
When the algorithm real2id data(m, (m )) is called, we know that m = (data, m ). It simply calls mhnd ← store(m ) at ina! and sets add arg := (). THH accepts
this input because |m | < |m| ≤ max len(k) by the preconditions. Then THH checks whether there is an mind with D∗[mind].type = data and D∗[mind].arg = (m ). By “correct arguments”, this is equivalent to D∗[mind].word = m. If this entry exists, it has no a-handle yet, because that would contradict the absence of m in Da by “correct derivation”. Thus THH assigns mhnd := curhnda++. “Correct derivation” together with the new entry in Da is then clear, and the other conditions of Lemma 7.7 clearly hold.
57

Otherwise, THH veriﬁes data len∗(|m |) ≤ max len(k). This holds because data len∗(|m |) = |m|. Then THH makes a new entry with mhnd := curhnda++. Together with the new entry in Da, this results in D∗ :⇐ (ind := size++, type := data, arg := (m ), hnd a := mhnd, len := data len∗(|m |), word := m). “Correct derivation” is clearly retained, and the output condition of Lemma 7.7 fulﬁlled. “Fully deﬁned”, “correct length”, and “no unparsed secret keys” are obvious. “Word uniqueness” holds by the preconditions of this case. “Correct arguments” was already written out above. “Word secrecy” is clear as no other entries are involved.
7.5.5 Lists
When the algorithm real2id list(m, (m1, . . . , mj) is called, we know that m = (list, m1, . . . , mj) with mi ∈ {0, 1}+ for all i. The precondition |m| ≤ max len(k) implies j ≤ max len(k) and |mi| ≤ max len(k) for all i. Further mi ∈ Pub Var for all i because they have been generated from m ∈ Pub Var by the functional algorithm parse.
Hence when real2id list starts with recursive calls mhi nd ← real2id(mi) for i := 1, . . . , j, these calls fulﬁll the preconditions of Lemma 7.7. Thus each call retains all the invariants and ensures D∗[hnd a = mhi nd].word = mi for i = 1, . . . , j. Let mi ind := D∗[hnd a = mhi nd].ind .
Then real2id list calls mhnd ← list(mh1nd, . . . , mhjnd) at ina! and sets add arg := (). THH’s domain expectations j ≤ max len(k) and miind = ↓ are fulﬁlled, and D∗[miind].type ∈ {sks, ske} is also a consequence of Lemma 7.7.
Thus THH checks whether there is an mind with D∗[mind].type = list and D∗[mind].arg = (m1ind, . . . , mjind). By “correct arguments”, this is equivalent to D∗[mind].word = m. If this entry exists, it has no a-handle yet, because that would contradict the absence of m in Da by “correct derivation”. Thus THH assigns one as mhnd := curhnda++. “Correct derivation” together with the new entry in Da is then clear, and the other conditions of Lemma 7.7 clearly hold.
Otherwise, THH sets length := list len∗(D∗[m1ind].len, . . . , D∗[mjind].len) and veriﬁes length > max len(k). This holds because by “correct length” length = list len∗(|m1|, . . . , |mj|) = |m|. Then THH makes a new entry with mhnd := curhnda++. Together with the new entry in Da, this results in D∗ :⇐ (ind := size++, type := list, arg := (m1ind, . . . , mjind), hnd a := mhnd, len := length, word := m).
“Correct derivation” is clearly retained, and the output condition of Lemma 7.7 fulﬁlled. “Fully deﬁned” and “no unparsed secret keys” are obvious. “Word uniqueness” holds by the preconditions of this case. “Correct length” was already shown, and “correct arguments” was written out above. “Word secrecy” is clear as no other entries are involved.
7.5.6 Nonces
The algorithm real2id nonce(m, ()) calls mhnd ← gen nonce() at ina! and sets add arg := (). Then THH makes a new entry with mhnd := curhnda++. Together with the new entry in Da, this results in D∗ :⇐ (ind := size++, type := nonce, arg := (), hnd a := mhnd, len := nonce len∗(k), word := m).
“Correct derivation” is clearly retained, and the output condition of Lemma 7.7 fulﬁlled. “Fully deﬁned”, “no unparsed secret keys”, and “correct arguments” are obvious. For “correct length”, the tests in parse imply that m is of this length. “Word secrecy” is clear as no other entries are involved.
For “word uniqueness”, assume there is a prior entry x ∈ D∗ with x.word = m. We then put this run in the error set Nonce Guess. We have x.hnd a = ↓ by “correct derivation” of Da, because m is not present in Da. Thus x.word ∈ Pub Var . By “correct arguments”, clearly also x.type = nonce.
58

7.5.7 Public Signature Keys
The algorithm real2id pks(m, ()) calls (skhnd, mhnd) ← gen sig keypair() at ina! and sets Da :⇐ (curhnda++, , ()) for the secret key and add arg := (adv) for the public key.
THH then also makes two new entries with skhnd := curhnda++ and mhnd := curhnda++. In CH, the secret-key entry results in D∗ :⇐ (ind := size++, type := sks, arg := (0), hnd a := skhnd, len := 0, word := ). Here “correct derivation” and “fully deﬁned” are clear, nothing is required under “word uniqueness”, “correct length”, and “correct arguments”, nor under “no unparsed secret keys” because the owner is a. “Word secrecy” for this additional entry holds because D∗[hnd a = skhnd].word = is a constant.
The public-key entry results in D∗ :⇐ (ind := size++, type := pks, arg := (), hnd a := mhnd, len := pks len∗(k), word := m). It fulﬁlls the output conditions of Lemma 7.7. Let pk ind := size. Then “correct derivation” holds because sk ind := pk ind − 1 designates the secret-key entry with owner(D∗[sk ind]) = a, so that add arg = (adv) is the correct choice in Da. “Fully deﬁned”, “no unparsed secret keys”, and “correct arguments” are obvious. For “correct length”, the tests in parse imply that m is of this length. “Word secrecy” need not be shown for this entry.
For “word uniqueness”, assume there is a prior entry x ∈ D∗ with x.word = m. We then put this run in the error set Key Guess. We have x.hnd a = ↓ by “correct derivation” of Da, because m is not present in Da. Thus x.word ∈ Pub Var .
7.5.8 Signatures
When real2id sig(m, (pk ∗, l)) is called, we know from parsing that pk ∗ is of the form (pks, pk ) and |pk ∗| = pks len∗(k) ≤ max len(k). Further, l is a tagged list and shorter than m, so that also |l| ≤ max len(k). Moreover, pk ∗, l ∈ Pub Var because they were generated from m ∈ Pub Var by the functional algorithm parse.
Hence when real2id sig starts with recursive calls pkhnd ← real2id(pk ∗) and lhnd ← real2id(l), these calls fulﬁll the preconditions of Lemma 7.7. Thus they retain all invariants and ensure D∗[hnd a = pkhnd].word = pk ∗ and D∗[hnd a = lhnd].word = l.
Let pk ind := D∗[hnd a = pkhnd].ind , l ind := D∗[hnd a = lhnd].ind , and sk ind := pk ind − 1. The consequences on pk ∗ and l from parsing m imply that they parse to type pks and list, respectively. Hence “correct arguments” implies D∗[pk ind].type = pks and D∗[l ind].type = list, and “correct key pairs” implies D∗[sk ind].type = sks.
Case 1: Adversary Key If Da[pkhnd].add arg = (adv), then real2id sig sets skhnd := pkhnd − 1 , calls mhnd ← sign(skhnd, lhnd) at ina! and sets add arg := ().
By “correct derivation” for pkhnd, this case implies owner(D∗[sk ind]) = a. With “correct key pairs” this further implies D∗[sk ind].hnd a = D∗[pk ind].hnd a − 1 = skhnd.
Thus the input passes THH’s type checks. Next THH sets length := sig len∗(k, D∗[l ind].len) and veriﬁes length ≤ max len(k). This holds because |m| ≤ max len(k) and we know from parsing that |m| = list len(|sig|, pks len (k), nonce len(k), |l|, sig len (k, |l|)) = sig len∗(k, |l|) and from “correct length” that D∗[l ind].len = |l|. As owner(D∗[sk ind]) = a, THH does not verify the counter size.
Hence THH sets mhnd := curhnda++, obtains pk ind as sk ind + 1, updates the signature counter and makes a new entry. Together with the new entry in Da, this results in c := D∗[sk ind].arg[1]++ and D∗ :⇐ (ind := size++, type := sig, arg := (pk ind, l ind, c), hnd a := mhnd, len := length, word := m).
The change in the entry D∗[sk ind] retains “correct derivation”. Among the invariants, it can only aﬀect “correct arguments”, but for secret keys nothing is required, and “word secrecy”, but the update information is from within THH and A.
59

We now consider the signature entry. “Correct derivation” is clearly retained,

and the output condition of Lemma 7.7 fulﬁlled. “Fully deﬁned” and “no unparsed

secret keys” are obvious, and so is “correct arguments” given the special deﬁnition

for type sig. “Correct length” was already shown above. “Word secrecy” need not

be shown for this entry.

Finally, we prove “word uniqueness”: Assume there were a prior entry x ∈ D∗

with x.word = m. It has x.hnd a = ↓ because the word m does not exist in Da. However, such an adversary signature without a-handle is impossible: “Correct arguments” and “word uniqueness” for pk ∗ and l imply x.type = sig and x.arg = (pk ind, l ind, c ) for some c . Such entries arise only from commands sign

and adv transform sig in THH and thus in CH. The latter always gives an a-handle,

and so does the former if

an

argument

sk

hnd u

where

input sk ind

at +1

ina?. = pk

If
ind

input at for sk ind

inu ? with u := D∗[hnd u

∈ H, = sk

it needs hund].ind .

This implies sk ind = sk ind, and this contradicts “key secrecy” because we know the

handle D∗[sk ind].hnd a = skhnd.

Case 2: Transformed Signature Now let Da[pkhnd].add arg = (honest, sk ∗). By “correct derivation” for pkhnd, this implies v := owner(D∗[sk ind]) ∈ H. Further,
m can be written as (sig, pk , r, l, sig) by parsing. Now assume there exist shnd, r , and sig with m := Da[shnd].word =
(sig, pk , r , l, sig ) and Da[shnd].type = sig. Then real2id sig calls mhnd ← adv transform sig(shnd) at ina! and sets add arg := ().
Let sind := D∗[hnd a = shnd].ind . By “correct derivation”, we have D∗[sind].type = sig. With the preconditions about m , “correct arguments” for sind, and “word uniqueness” for pk ∗ and l, this implies D∗[sind].arg = (pk ind, l ind, c)
for some c. Hence THH sets mhnd := curhnda++ and makes a new entry. Together with the
new entry in Da, this results in D∗ :⇐ (ind := size++, type := sig, arg := (pk ind, l ind, false), hnd a := mhnd, len := D∗[sind].len, word := m).
“Correct derivation” is clearly retained, and the output condition of Lemma 7.7
fulﬁlled. “Fully deﬁned” and “no unparsed secret keys” are obvious. “Correct arguments” holds because we showed that the arguments copied from D∗[sind] are
those that we get by parsing m. “Word uniqueness” is shown exactly as in Case 1. For “correct length”, we use that D∗[sind].len = |m | by “correct length” for sind.
Thus we only have to show |m| = |m |. This holds because both parse as signatures
with the same component l. “Word secrecy” need not be shown for this entry.

Case 3: Forged Signature In the ﬁnal case, we have Da[pkhnd].add arg = (honest, sk ∗) and thus v := owner(D∗[sk ind]) ∈ H as in Case 2 and again m =: (sig, pk , r, l, sig). However, now there exist no shnd, r , and sig with Da[shnd].word = (sig, pk , r , l, sig ) and Da[shnd].type = sig. Here SimH gives up. We distinguish two cases.
If there exists an entry x ∈ D∗ and sig with x.word = (sig, pk , r, l, sig ) and
x.type = sig, we put the run in the error set Nonce Guess. (The adversary has
guessed the nonce-part r.) We have x.hnd a = ↓ by “correct derivation” of Da, because in Case 3 no such word is present in Da. Thus x.word ∈ Pub Var .
Otherwise, we put the run in the error set Forge and designate the forgery
(pk , (r, l), sig). Note that testpk (sig, (r, l)) = true because this was veriﬁed when parsing m, and that v = owner(D∗[sk ind]) ∈ H. Further, “key secrecy” and “strongly correct arguments” for D∗[sk ind] imply that pk was chosen in gen sig keypair together with sk := D∗[sk ind].word [2], and thus as (sk , pk ) ← genS(1k, 1max skc(k)).

60

7.5.9 Public Encryption Keys
The algorithm real2id pke(m, ()) calls (skhnd, mhnd) ← gen enc keypair() at ina! and sets Da :⇐ (curhnda++, , ()) for the secret key and add arg := (adv) for the public key.
THH then also makes two new entries with skhnd := curhnda++ and mhnd := curhnda++. In CH, the secret-key entry results in D∗ :⇐ (ind := size++, type := ske, arg := (), hnd a := skhnd, len := 0, word := ). Here “correct derivation” and “fully deﬁned” are clear. Nothing is required under “word uniqueness”, “correct length”, and “correct arguments”, nor under “no unparsed secret keys” because the owner is a. “Word secrecy” for this additional entry holds because D∗[hnd a = skhnd].word = is a constant.
The public-key entry results in D∗ :⇐ (ind := size++, type := pke, arg := (), hnd a := mhnd, len := pke len∗(k), word := m). It fulﬁlls the output conditions of Lemma 7.7. Let pk ind := size. Then “correct derivation” holds because sk ind := pk ind − 1 designates the secret-key entry with owner(D∗[sk ind]) = a, so that add arg = (adv) is the correct choice in Da. “Fully deﬁned”, “no unparsed secret keys”, and “correct arguments” are obvious. For “correct length”, the tests in parse imply that m is of this length. “Word secrecy” need not be shown for this entry.
For “word uniqueness”, assume there is a prior entry x ∈ D∗ with x.word = m. We then put this run in the error set Key Guess. We have x.hnd a = ↓ by “correct derivation” of Da, because m is not present in Da. Thus x.word ∈ Pub Var .
7.5.10 Ciphertexts
When real2id enc(m, (pk ∗)) is called, we know from parsing that pk ∗ = (pke, pk ) with |pk ∗| = pke len∗(k) ≤ max len(k). Further, pk ∗ ∈ Pub Var because it was generated from m ∈ Pub Var by the functional algorithm parse.
Hence when real2id enc starts with a recursive call pkhnd ← real2id(pk ∗), this call fulﬁlls the preconditions of Lemma 7.7. Thus it retains all invariants and ensures D∗[hnd a = pkhnd].word = pk ∗.
Let pk ind := D∗[hnd a = pkhnd].ind and sk ind := pk ind − 1. The consequences on pk ∗ from parsing m imply that it parses to type pke. Hence “correct arguments” implies D∗[pk ind].type = pke, and “correct key pairs” implies D∗[sk ind].type = ske. Let v := owner(D∗[sk ind]).
In all cases of real2id enc, only the entry for mhnd is made, and always with word m and type enc; further always add arg = (). Thus “correct derivation” is clearly retained, and the output condition of Lemma 7.7 fulﬁlled. Further, “fully deﬁned” and “no unparsed secret keys” are obvious, and “word secrecy” need not be shown for this entry. For “word uniqueness”, we put the run in the error set Nonce Guess if there is a prior entry x ∈ D∗ with x.word = m. (The adversary has guessed the nonce-part r of m.) We have x.hnd a = ↓ because the word m does not exist in Da. Thus x.word ∈ Pub Var . By “correct arguments”, clearly also x.type = enc.
Hence in the individual cases, “correct length” and “correct arguments” remain to be shown.
Case 1: Adversary Key If v = adv, then “correct derivation” implies Da[pkhnd].add arg = (adv). Hence real2id enc calls mhnd ← adv invalid ciph(pkhnd, |m|) at ina! and sets add arg := ().
This input passes THH’s domain and type check. Hence THH sets mhnd := curhnda++ and makes a new entry. Together with the new entry in Da, this results in D∗ :⇐ (ind := size++, type := enc, arg := (pk ind), hnd a := mhnd, len := |m|, word := m).
61

“Correct length” is obvious. For “correct arguments”, the general requirement for the public-key argument is clearly fulﬁlled. The fact o := D∗[size].owner = ↓ is correct for v = a, and nothing else needs to be shown in this case.
Case 2: Invalid Ciphertext for Honest User If v ∈ H, then “correct derivation” implies Da[pkhnd].add arg = (honest, sk ∗) with sk ∗ = ω(sk ind). Thus real2id enc computes l := parse decrypt(sk ∗, m).
For this case, assume l = ↓. Then real2id enc calls chnd ← adv invalid ciph(pkhnd, |m|) at ina! and sets add arg := ().
As above, this input passes THH’s domain and type check, and THH sets mhnd := curhnda++ and makes a new entry. Together with the new entry in Da, this results in D∗ :⇐ (ind := size++, type := enc, arg := (pk ind), hnd a := mhnd, len := |m|, word := m, owner := adv).
“Correct length” is obvious. For “correct arguments”, the general requirement for the public-key argument is clearly fulﬁlled. The fact o := D∗[size].owner = adv is correct for v ∈ H. The resulting requirement on decryption is fulﬁlled by construction because l ind := argind[2] = ↓, and l := parse decrypt(sk ∗, m) = ↓ is the precondition of this case.
Case 3: Valid Ciphertext for Honest User Let v ∈ H again and sk ∗ and l be deﬁned as in Case 2, but now l = ↓.
Then real2id enc makes a recursive call lhnd ← real2id(l). We have to show that this call fulﬁlls the preconditions of Lemma 7.7. First, |l| ≤ max len(k) because the construction of parse decrypt implies |l| ≤ |m|. Secondly, l only depends on sk ∗ and m. By a precondition, m ∈ Pub Var . Further, by the deﬁnition of Pub Var , the existence of D∗[pk ind].hnd a implies that also sk ∗ ∈ Pub Var . Thus also l ∈ Pub Var .
Thus the recursive call retains all invariants and ensures D∗[hnd a = lhnd].word = l . Now real2id enc calls chnd ← encrypt(pkhnd, lhnd) at ina! and sets add arg := ().
The arguments pass THH’s domain check and the type check for pkhnd. Further, l is a tagged list by the tests in parse decrypt, and thus by “correct arguments”, D∗[l ind].type = list for l ind := D∗[hnd a = lhnd].ind . Thus THH sets length := enc len∗(k, D∗[l ind].len), where D∗[l ind].len = |l|. The tests made when parsing m and in parse decrypt imply that length = |c| ≤ max len(k). Thus THH sets mhnd := curhnda++ and makes a new entry. Together with the new entry in Da, this results in D∗ :⇐ (ind := size++, type := enc, arg := (pk ind, l ind), hnd a := mhnd, len := |m|, word := length, owner := adv).
“Correct length” was just shown. For “correct arguments”, the general requirement for the public-key argument is clearly fulﬁlled. The fact o := D∗[size].owner = adv is correct for v ∈ H. The resulting requirement on decryption is fulﬁlled by construction because indeed ω(l ind) = l where l was deﬁned as l := parse decrypt(sk ∗, m).
7.6 Scheduling of a Secure Channel
Finally, we consider a scheduling signal i from A for a secure channel, i.e., for (w, u, x) ∈ ch honest. By “correct derivation”, we have netw,u,x = ω∗(net idw,u,x ), where the former is the buﬀer in MH and the latter in THSimH and CH. This implies that the buﬀers are of the same length i . If i > i , nothing happens. Otherwise, THH gets the input l ind := net idw,u,x [i] and Mu gets l := netw,u,x [i] = D∗[l ind.word ]. By “message correctness” (recall Lemma 4.1), we have D[l ind].type = list, and thus by “correct arguments”, l is a tagged list. Further, |l| ≤ max len(k) by “correct length” and “length bounds”. Hence Mu accepts l.
62

If D∗[l ind].hnd u already exists, both return it. Otherwise THH adds it as lhnd := curhndu ++. By “word uniqueness” and “correct derivation”, Mu does not ﬁnd another entry with the word l, and thus makes a new entry (lhnd, l, list, ()) with the same handle. “Correct derivation” is clear. By Lemma 7.3.3, this is all we have to show.
7.7 Error Sets
We now show that the union of all error sets has negligible probability. More precisely, this means sequences of error sets, indexed by the basic security parameter k, such as (Forgek )k∈N. We continue to omit the parameter k when it is irrelevant. The proofs rely on the security of the cryptographic primitives.
Recall that we had error sets Nonce Coll , Key Coll , Ciph Coll , Nonce Guess, Key Guess, and Forge. This gives a constant number of sequences. Hence, if each sequence has negligible probability, then so has the sequence of the set unions. Hence we now assume for contradiction that one sequence has a larger probability for certain polynomial-time users H and adversary A.
Recall that the elements of the error sets are runs of the combined system CH. The proofs rely on the fact that the execution of CH with H and A is polynomial-time. CH is even polynomial-time on its own, because THSimH and MH are polynomial-time by Lemmas 4.2.1, 6.1, and 7.2.1, and essentially all actions of CH occur in one of these systems.
7.7.1 Nonce Collisions
The error set Nonce Coll occurs in Sections 7.3.6, 7.3.7, and 7.3.8 for the generation of “oﬃcial” nonces, and the nonce-components r in ciphertexts and signatures. A run is put into this set if a new nonce, created randomly as r ←R {0, 1}nonce len(k), matches an already existing value. Hence for every pair of a new nonce and an old value, the success probability is bounded by 2−nonce len(k), which we required to be negligible. As there are only polynomially many such pairs, the overall probability is also negligible.
7.7.2 Key Collisions
The error set Key Coll occurs in Sections 7.3.7 and 7.3.8 for the generation of public signature and encryption keys. We ﬁrst consider encryption keys. A run is put into this set if a new public key pk , created correctly with (sk , pk ) ← genE(1k), matches an already existing value, which may have been chosen by the adversary.
Let Pmax,k be the maximum probability of any particular value of pk for security parameter k. Then Pmax,k is an upper bound for the collision probability of every pair of an old value and new public key. As there are only polynomially many such pairs, it is suﬃcient to prove that Pmax,k is negligible. Assume for contradiction it were not.
Let an adversary Aenc on the encryption system, given a key pk , independently generate a key pair (sk , pk ) ← genE(1k). Then the probability of pk = pk is at least Pmax,k 2, which is still not negligible. In this event, we have m = Dsk (c) for every ciphertext c ← Epk (m), i.e., the adversary can decrypt ciphertexts intended for the honest participant, which clearly contradicts the security of the encryption system.
The argument for signature keys is completely analogous, where signatures made with sk pass the test with pk .
63

7.7.3 Ciphertext Collisions
The error set Ciph Coll occurs in Section 7.3.8 for the basic command decrypt. A run is put into this set if the encryption machine Encsim,H has generated two entries (l1∗, pk , c) and (l2∗, pk , c) with the same public and ciphertext, but l1∗ = l2∗, in ciphers. In the real encryption machine EncH, this situation is impossible because the ciphertexts are actually under the messages l1∗ and l2∗ (while in Encsim,H they are under ﬁxed messages), and decryption is unique for correctly generated key pairs. Indistinguishability of Encsim,H and EncH, and the fact that the content of ciphers is visible externally, implies that the probability of the same event is at most negligible in Encsim,H.
7.7.4 Nonce Guessing
The error set Nonce Guess occurs in Section 7.5.6, 7.5.8, and 7.5.10. A run is put into this set if the adversary has guessed an existing nonce value that ideally he should not have seen. In all these cases we showed that the adversary had guessed the word of an entry x ∈ D∗ with x.hnd a = ↓, x.word ∈ Pub Var , and x.type ∈ {nonce, sig, enc}.
“Strongly correct arguments” applies to these entries. Thus each of them contains a nonce part generated as r ←R {0, 1}nonce len(k) independently of everything else.
“Word secrecy” means that no information ﬂowed from r into Pub Var , which is a superset of the information known to the adversary A. Hence for one guess at one value, the success probability is 2−nonce len(k) and thus negligible, and there are only a polynomially many values and polynomially many opportunities of guessing.
7.7.5 Key Guessing
The error set Key Guess occurs in Sections 7.5.7 and 7.5.9. A run is put into this set if the adversary has guessed an existing public key that ideally he should not have seen. Similar to nonce guessing, we showed that the adversary had guessed the word of an entry x ∈ D∗ with x.hnd a = ↓, x.word ∈ Pub Var , and x.type ∈ {pks, pke}.
As above, word secrecy implies that the adversary had no information at all about the component pk := x.word [2]. Hence for one guess at one value, the success probability is bounded by Pmax,k as in Section 7.7.2 and thus negligible, and there are only a polynomially many guesses and values.
7.7.6 Signature Forgery
The error set Forge occurs in Section 7.5.8 for signature forgeries. In the runs put into this set we designated a triple (pk , (r, l), sig) as a forgery and showed that testpk (sig, (r, l)) = true for a key pair chosen correctly as (sk , pk ) ← genS(1k, 1max skc(k)).
In the combined system CH, this secret key sk was a component D∗[sk ind].word [2] with v = owner(D∗[sk ind]) ∈ H. Thus it is only used if the command sign is entered at port inv ?, and there within normal signing operations sig ← signsk,c((r, l)), executed with an internal signature counter c which is incremented with each signature and not used otherwise.
Further, if (r, l) had ever been signed with sk before, the command sign would lead to an entry x ∈ D∗ with x.type = sig and x.word of the form (sig, pk , r, l, sig ). However, the existence of such an entry was excluded in the conditions for putting the run in the set Forge. Thus we have indeed a valid forgery for the underlying signature system.
64

This argument was almost a rigorous reduction proof already: We construct an adversary Asig against the signer machine Sigs from Deﬁnition 5.1 with the function s := max skc by letting Asig execute CH, using the given A and H as blackboxes. It only has to choose an index i ←R {1, . . . , n · max in(k)} indicating for which of the up to n · max in(k) key pairs generated due to inputs at ports inu ? with u ∈ H it uses pk obtained from the signer machine Sigs instead. We showed above that the use of sk can be perfectly rewritten by interaction with Sigs, and that Asig obtains a valid forgery if its guess i was correct.
Hence the success probability of Asig for each k is at least (n · max in(k))−1 (from guessing i correctly) times the probability of Forgek . Hence the security of the signature scheme implies that the probability of the sets Forgek is negligible.
8 Conclusion
We have presented a faithful abstraction of a crypto-library, which comprises important cryptographic operations like public-key encryption, digital signatures, and nonces. Faithful means that we can implement the abstraction securely in the cryptographic sense, so that properties proved for the abstraction carry over to the implementation without any further work. We provided one possible implementation whose security is based on provably secure cryptographic systems.
This faithfulness now allows for a meaningful analysis of protocol properties on the abstract level. As such an analysis is in scope of formal veriﬁcation techniques, this bridges the up-to-now missing link between cryptography and formal methods. Exploring the complexity of our abstraction and further reducing it by developing or adapting currently used data-independence techniques is of independent interest.
As many protocols commonly analyzed in the literature can be expressed with our library, this enables the ﬁrst formal, machine-aided veriﬁcation of these protocols which is not only meaningful for Dolev-Yao-like abstractions, but whose security guarantees are equivalent to the security of the underlying cryptography.
Acknowledgments
We thank Andre Adelsbach, Matthias Schunter, and Michael Steiner for interesting discussions.
This work was partially supported by the European IST Project MAFTIA. However, it represents the view of the authors. The MAFTIA project is partially funded by the European Commission and the Swiss Department for Education and Science.
References
[1] M. Abadi and A. D. Gordon. A calculus for cryptographic protocols: The spi calculus. Information and Computation, 148(1):1–70, 1999.
[2] M. Abadi and J. Ju¨rjens. Formal eavesdropping and its computational interpretation. In Proc. 4th International Symposium on Theoretical Aspects of Computer Software (TACS), pages 82–94, 2001.
[3] M. Abadi and P. Rogaway. Reconciling two views of cryptography: The computational soundness of formal encryption. In Proc. 1st IFIP International Conference on Theoretical Computer Science, volume 1872 of Lecture Notes in Computer Science, pages 3–22. Springer, 2000.
65

[4] R. Anderson and R. Needham. Robustness principles for public key protocols. In Advances in Cryptology: CRYPTO ’95, volume 963 of Lecture Notes in Computer Science, pages 236–247. Springer, 1995.
[5] M. Backes and C. Jacobi. Cryptographically sound and machine-assisted veriﬁcation of security protocols. In Proc. 20th Annual Symposium on Theoretical Aspects of Computer Science (STACS), 2003. To appear.
[6] M. Backes, C. Jacobi, and B. Pﬁtzmann. Deriving cryptographically sound implementations using composition and formally veriﬁed bisimulation. In Proc. 11th Symposium on Formal Methods Europe (FME 2002), volume 2391 of Lecture Notes in Computer Science, pages 310–329. Springer, 2002.
[7] D. Beaver. Secure multiparty protocols and zero knowledge proof systems tolerating a faulty minority. Journal of Cryptology, 4(2):75–122, 1991.
[8] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway. Relations among notions of security for public-key encryption schemes. In Advances in Cryptology: CRYPTO ’98, volume 1462 of Lecture Notes in Computer Science, pages 26–45. Springer, 1998.
[9] R. Canetti. Security and composition of multiparty cryptographic protocols. Journal of Cryptology, 3(1):143–202, 2000.
[10] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In Proc. 42nd IEEE Symposium on Foundations of Computer Science (FOCS), pages 136–145, 2001.
[11] R. Cramer and I. Damg˚ard. Secure signature schemes based on interactive protocols. In Advances in Cryptology: CRYPTO ’95, volume 963 of Lecture Notes in Computer Science, pages 297–310. Springer, 1995.
[12] R. Cramer and I. Damg˚ard. New generation of secure and practical RSA-based signatures. In Advances in Cryptology: CRYPTO ’96, volume 1109 of Lecture Notes in Computer Science, pages 173–185. Springer, 1996.
[13] R. Cramer and V. Shoup. Practical public key cryptosystem provably secure against adaptive chosen ciphertext attack. In Advances in Cryptology: CRYPTO ’98, volume 1462 of Lecture Notes in Computer Science, pages 13– 25. Springer, 1998.
[14] R. Cramer and V. Shoup. Signature schemes based on the strong RSA assumption. In Proc. 6th ACM Conference on Computer and Communications Security, pages 46–51, 1999.
[15] D. Dolev, C. Dwork, and M. Naor. Nonmalleable cryptography. SIAM Journal on Computing, 30(2):391–437, 2000.
[16] D. Dolev and A. C. Yao. On the security of public key protocols. IEEE Transactions on Information Theory, 29(2):198–208, 1983.
[17] R. Gennaro, S. Halevi, and T. Rubin. Secure hash-and-sign signatures without the random oracle. In Advances in Cryptology: EUROCRYPT ’99, volume 1592 of Lecture Notes in Computer Science, pages 123–139. Springer, 1999.
[18] O. Goldreich. Two remarks concerning the Goldwasser-Micali-Rivest signature scheme. In Advances in Cryptology: CRYPTO ’86, volume 263 of Lecture Notes in Computer Science, pages 104–110. Springer, 1986.
66

[19] S. Goldwasser and L. Levin. Fair computation of general functions in presence of immoral majority. In Advances in Cryptology: CRYPTO ’90, volume 537 of Lecture Notes in Computer Science, pages 77–93. Springer, 1990.
[20] S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Computer and System Sciences, 28:270–299, 1984.
[21] S. Goldwasser, S. Micali, and R. L. Rivest. A digital signature scheme secure against adaptive chosen-message attacks. SIAM Journal on Computing, 17(2):281–308, 1988.
[22] J. D. Guttman, F. J. Thayer Fabrega, and L. Zuck. The faithfulness of abstract protocol analysis: Message authentication. In Proc. 8th ACM Conference on Computer and Communications Security, pages 186–195, 2001.
[23] M. Hirt and U. Maurer. Player simulation and general adversary structures in perfect multiparty computation. Journal of Cryptology, 13(1):31–60, 2000.
[24] R. Kemmerer. Analyzing encryption protocols using formal verﬁcation techniques. IEEE Journal on Selected Areas in Communications, 7(4):448–457, 1989.
[25] P. Laud. Semantics and program analysis of computationally secure information ﬂow. In Proc. 10th European Symposium on Programming (ESOP), pages 77–91, 2001.
[26] P. Lincoln, J. Mitchell, M. Mitchell, and A. Scedrov. A probabilistic poly-time framework for protocol analysis. In Proc. 5th ACM Conference on Computer and Communications Security, pages 112–121, 1998.
[27] G. Lowe. Breaking and ﬁxing the Needham-Schroeder public-key protocol using FDR. In Proc. 2nd International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS), volume 1055 of Lecture Notes in Computer Science, pages 147–166. Springer, 1996.
[28] C. Meadows. Using narrowing in the analysis of key management protocols. In Proc. 10th IEEE Symposium on Security & Privacy, pages 138–147, 1989.
[29] S. Micali and P. Rogaway. Secure computation. In Advances in Cryptology: CRYPTO ’91, volume 576 of Lecture Notes in Computer Science, pages 392– 404. Springer, 1991.
[30] J. K. Millen. The interrogator: A tool for cryptographic protocol security. In Proc. 5th IEEE Symposium on Security & Privacy, pages 134–141, 1984.
[31] S. Owre, N. Shankar, and J. M. Rushby. PVS: A prototype veriﬁcation system. In Proc. 11th International Conference on Automated Deduction (CADE), volume 607 of Lecture Notes in Computer Science, pages 748–752. springer, 1992.
[32] B. Pﬁtzmann, M. Schunter, and M. Waidner. Secure reactive systems. Research Report RZ 3206, IBM Research, 2000.
[33] B. Pﬁtzmann and M. Waidner. Composition and integrity preservation of secure reactive systems. In Proc. 7th ACM Conference on Computer and Communications Security, pages 245–254, 2000.
[34] B. Pﬁtzmann and M. Waidner. A model for asynchronous reactive systems and its application to secure message transmission. In Proc. 22nd IEEE Symposium on Security & Privacy, pages 184–200, 2001.
67

[35] C. Rackoﬀ and D. R. Simon. Non-interactive zero-knowledge proof of knowledge and chosen ciphertext attack. In Advances in Cryptology: CRYPTO ’91, volume 576 of Lecture Notes in Computer Science, pages 433–444. Springer, 1992.
[36] D. Volpano and G. Smith. Verifying secrets and relative secrecy. In Proc. 27th Symposium on Principles of Programming Languages (POPL), pages 268–276, 2000.
[37] A. C. Yao. Protocols for secure computations. In Proc. 23rd IEEE Symposium on Foundations of Computer Science (FOCS), pages 160–164, 1982.
[38] A. C. Yao. Theory and applications of trapdoor functions. In Proc. 23rd IEEE Symposium on Foundations of Computer Science (FOCS), pages 80–91, 1982.
68

